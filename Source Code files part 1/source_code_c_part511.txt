se(STRESS_COMMAND_SERVER_LOGURL, szPostLogData, szExtraHeaders);
	//OutputDebugStringA(szPostLogData);

Exit:
	if (szPostLogData)
		delete [] szPostLogData;

	delete [] szDllVersion;
	delete [] szNumber;

	return bResult;
}


////////////////////////////////////////////////////////////
// Function:  NetworkTools__GetDllVersion(LPTSTR, LPSTR, DWORD)
//
// Purpose:
//	Takes a DLL name and return the version as an ASCII string.
//
////////////////////////////////////////////////////////////
BOOL
NetworkTools__GetDllVersion(
	LPTSTR	lpszDllName,
	LPSTR	szVersionBuffer,
	DWORD	dwVersionBufferSize
)
{
	BOOL	bResult			= TRUE;
	DWORD	dwHandle;
	DWORD	dwVersionSize;
	LPSTR	szVersionInfo	= NULL;
	LPSTR	szVersionOutput	= NULL;
	UINT	uiLength;


	ZeroMemory(szVersionBuffer, dwVersionBufferSize);

	dwVersionSize	= GetFileVersionInfoSize(lpszDllName, &dwHandle);
	
	if (0 >= dwVersionSize)
	{
		bResult = FALSE;
		goto Exit;
	}

	// allocate new buffer for the query
	szVersionInfo = new CHAR[dwVersionSize];

	ZeroMemory(szVersionInfo, dwVersionSize);
	if (!GetFileVersionInfo(lpszDllName, NULL, dwVersionSize, szVersionInfo))
	{
		bResult = FALSE;
		goto Exit;
	}


	// *****************************
	// ** build the version info query string

	struct LANGANDCODEPAGE {
	  WORD wLanguage;
	  WORD wCodePage;
	} *lpTranslate;


	CHAR szVersionQuery[200];
	ZeroMemory(szVersionQuery, 200);

	// Read the list of languages and code pages.
	VerQueryValueA(szVersionInfo, 
				  "\\VarFileInfo\\Translation",
				  (LPVOID*)&lpTranslate,
				  &uiLength);

	// build the ver info query string that contains the language bits
	sprintf(szVersionQuery, "\\StringFileInfo\\%04x%04x\\ProductVersion", lpTranslate->wLanguage, lpTranslate->wCodePage);


	// *****************************
	// ** Get the version and copy to buffer
	uiLength = 0;
	if (!VerQueryValueA(szVersionInfo, szVersionQuery, (VOID **) &szVersionOutput, &uiLength))
	{
		bResult = FALSE;
		goto Exit;
	}

	// copy the version info string to the buffer
	strncpy(szVersionBuffer, (LPSTR) szVersionOutput, dwVersionBufferSize-1);


Exit:
	if (szVersionInfo)
		delete [] szVersionInfo;

	return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\stress\stressapps\stressapps.inc ===
!IF 0

Copyright (c) 2001  Microsoft Corporation

!ENDIF

#
# if TARGETPATH is not defined (in the paths that build libraries) then this
# is the default target path
#
!IFNDEF TARGETPATH
TARGETPATH=obj
TARGETTYPE=UMAPPL_NOLIB
!ENDIF

#
# define some macros that subprojects can use
#
ROOT=$(SDXROOT)\inetcore\winhttp\tools\stress
STRESSINC=$(ROOT)\stressapps\core
WINHTTPLIB=$(SDXROOT)\inetcore\winhttp\v5\dll\obj\i386
WINHTTPINC=$(SDXROOT)\inetcore\winhttp\v5\inc

#
# what it is that we're building
#
MAJORCOMP=stressapps
USE_NOLIBS=1
NO_NTDLL=1

#
# Linker flags
#
WIN32_WINNT_VERSION=0x0500
#WIN32_WIN95_VERSION=0x0400

#
# compiler warning flags
#
MSC_WARNING_LEVEL=/W3 /WX

#
# enable exception handling
#
USE_NATIVE_EH=1

#
# compiler definitions
#
C_DEFINES=$(C_DEFINES) -DWIN32

#
# Set debugging level
#
!IF "$(NTDEBUG)" != "" && "$(NTDEBUG)" != "retail" && "$(NTDEBUG)" != "ntsdnodbg"
C_DEFINES=$(C_DEFINES) -D_DEBUG
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\stress\res\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//
#define IDI_MAIN_ICON                   101
#define IDR_POPUPMENU                   107
#define IDM_BEGIN_STRESS                40007
#define IDM_END_STRESS                  40008
#define IDM_EXIT                        40009
#define IDM_OPENSTRESSADMIN             40012
#define IDM_WINHTTP_HOME                40014

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        120
#define _APS_NEXT_COMMAND_VALUE         40015
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\stress\stressinstance.h ===
//////////////////////////////////////////////////////////////////////
// File:  StressInstance.h
//
// Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
// Purpose:
//	StressInstance.h: interface for the StressInstance class.
//	This class is used spawn and monitor instances of the stressEXE app.
//
// History:
//	02/15/01	DennisCh	Created
//
//////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////
// Includes
//////////////////////////////////////////////////////////////////////

//
// WIN32 headers
//
#define UNICODE
#define _UNICODE

#include <stdio.h>
#include <windows.h>
#include <tchar.h>
#include <winhttp.h>

//
// Project headers
//
#include <debugger.h>

//////////////////////////////////////////////////////////////////////
// Constants
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_STRESSINSTANCE_H__806226FB_2170_4FE3_ACCA_EF8952E6A524__INCLUDED_)
#define AFX_STRESSINSTANCE_H__806226FB_2170_4FE3_ACCA_EF8952E6A524__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


#define	RESPONSE_HEADER__STRESS_BEGIN			_T("WinHttpStress_Begin: Begin Stress")
#define	RESPONSE_HEADER__STRESS_END				_T("WinHttpStress_End: End Stress")


// ***************************
// ** max string URL length
#define MAX_STRESS_URL							MAX_PATH * 2


// ***************************
// ** time to check the stress exe in milliseconds
#define STRESSINSTANCE_MONITOR_EXE_TIME			1200000	// 20 minutes

// ***************************
// ** Command line CreateProcess will use. Takes two params: the path+filename of the stressExe and CDB pipe name
//#define STRESSINSTANCE_DEBUG_COMMANDLINE		_T("c:\\debuggers\\remote.exe /s \"c:\\debuggers\\cdb.exe -g -G \"%s\"\" %s")
#define STRESSINSTANCE_DEBUG_COMMANDLINE		_T("\"%s\"")

// ***************************
// ** Memory dump path
#define	STRESSINSTANCE_DEFAULT_MEMORY_DUMP_PATH	_T("\\\\hairball\\dump$\\")

// ***************************
// ** relative path to the directory where the stressExe files will be downloaded to.
#define STRESSINSTANCE_STRESS_EXE_DOWNLOAD_DIR	_T("stressExe")

// ***************************
// ** Time to wait for stressExe to close after telling it
#define STRESSINSTANCE_STRESS_EXE_CLOSE_TIMEOUT	100

// ***************************
// ** Cross process event object names. We append the PID of the process to the end to prevent name collisions.
#define STRESSINSTANCE_STRESS_EXE_EVENT_EXITPROCESS			_T("ExitProcessEvent")


class StressInstance  
{
public:
				StressInstance();
	virtual		~StressInstance();

	BOOL		Begin();
	VOID		End();
	BOOL		IsRunning(DWORD);

	DWORD		Get_ID();
	LPTSTR		Get_StressExeMemoryDumpPath();

	VOID		Set_StressExeMemoryDumpPath(LPTSTR);
	VOID		Set_StressExeURL(LPTSTR);
	VOID		Set_StressExePdbURL(LPTSTR);
	VOID		Set_StressExeSymURL(LPTSTR);
	VOID		Set_StressExeID(DWORD);
	VOID		Set_PageHeapCommands(LPCTSTR);
	VOID		Set_UMDHCommands(LPCTSTR);

	BOOL		DownloadStressExe();

				// This is the timer callback proc that monitors the stressExe process.
	friend		VOID CALLBACK StressExe_TimerProc(HWND, UINT, UINT_PTR, DWORD);

				// This is the timer callback proc for the debugger object
	friend		DWORD DebuggerCallbackProc(DWORD, LPVOID, LPTSTR, LPVOID);

private:
	DWORD		m_dwStressExe_ID;					// ID from the stressAdmin DB uniquely identifying this stress EXE.
	LPTSTR		m_szStressExe_URL;					// URL to the stress app
	LPTSTR		m_szStressExe_PDB_URL;				// URL to the stress app's pdb file
	LPTSTR		m_szStressExe_SYM_URL;				// URL to the stress app's sym file
	LPTSTR		m_szStressExe_FilePath;				// Local relative path of the downloaded stress EXE
	LPTSTR		m_szStressExe_FileName;				// Local filename of the downloaded stress EXE
	LPTSTR		m_szStressExe_FilePathAndName;		// Path and filename to the local stressExe downloaded
	LPTSTR		m_szStressExe_PageHeapCommandLine;	// Command line params when enabling pageheap.
	LPTSTR		m_szStressExe_UMDHCommandLine;		// Command line params when enabling UMDH.

	LPTSTR		m_szStressExe_MemDumpPath;			// path that the minidump will dump to

	Debugger	*m_objDebugger;						// the debughelp debugger object

	PROCESS_INFORMATION 	m_piStressExeProcess;	// stuct containing info on the stressExe process
	HANDLE					m_hStressExe_ProcessExitEvent;	// Cross process event we send stressExe to tell it to exit
};


#endif // !defined(AFX_STRESSINSTANCE_H__806226FB_2170_4FE3_ACCA_EF8952E6A524__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\stress\winhttpstressscheduler.cpp ===
///////////////////////////////////////////////////////////////////////////
// File:  WinHttpStressScheduler.cpp
//
// Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
// Purpose:
//	Global interfaces for the WinHttpStressScheduler project.
//
// History:
//	02/05/01	DennisCh	Created
///////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////
//
// Includes
//
//////////////////////////////////////////////////////////////////////

//
// Win32 headers
//

//
// Project headers
//
#include "WinHttpStressScheduler.h"
#include "ServerCommands.h"
#include "NetworkTools.h"


//////////////////////////////////////////////////////////////////////
//
// Globals and statics
//
//////////////////////////////////////////////////////////////////////

HINSTANCE		g_hInstance;
HWND			g_hWnd;
ServerCommands	g_objServerCommands;

// Forward function definitions
LRESULT	CALLBACK	MainWndProc(HWND, UINT, WPARAM, LPARAM);
BOOL				SystemTray_UpdateIcon(HWND hwnd, DWORD dwMessage, UINT uID, HICON hIcon, PSTR pszTip);
BOOL				Show_IconShortCutMenu();
BOOL				OS_IsSupported();


////////////////////////////////////////////////////////////
// Function:  WinMain( HINSTANCE, HINSTANCE, LPWSTR, int )
//
// Purpose:
//	This is the entry-point into WinHttpStressScheduler.
//
// Called by:
//	[System]
////////////////////////////////////////////////////////////
int
WINAPI
WinMain
(
   HINSTANCE	hInstance,		// [IN] handle to the process instance
   HINSTANCE	hPrecInstance,	// [IN] handle to the previous instance
   LPTSTR		lpCmdLine,		// [IN] command line
   int			nShowCmd		// [IN] show command
)
{
	MSG				msg;
	WNDCLASSEX		wndClass;

	wndClass.cbSize			= sizeof(WNDCLASSEX); 
	wndClass.style			= CS_HREDRAW | CS_VREDRAW;
	wndClass.lpfnWndProc	= MainWndProc;
	wndClass.cbClsExtra		= 0;
	wndClass.cbWndExtra		= 0;
	wndClass.hInstance		= hInstance;
	wndClass.hIcon			= NULL;
	wndClass.hCursor		= NULL;
	wndClass.hbrBackground	= NULL;
	wndClass.lpszMenuName	= NULL;
	wndClass.lpszClassName	= WINHTTP_STRESS_SCHEDULER__NAME;
	wndClass.hIconSm		= NULL;

	RegisterClassEx(&wndClass);

	// cache our hInstance
	g_hInstance = hInstance;

    // Create window. 
	g_hWnd = NULL;
    g_hWnd = CreateWindow( 
        WINHTTP_STRESS_SCHEDULER__NAME,
        NULL,
        WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT,
        0,
        CW_USEDEFAULT,
        0,
        NULL,
        NULL,
        hInstance,
        NULL);

	if (!g_hWnd)
		return FALSE;

	// Verify that we're running a supported version of Windows
	if (!OS_IsSupported())
		return FALSE;

	// Add icon to the system tray icon
	if (!SystemTray_UpdateIcon(g_hWnd, NIM_ADD, 0, LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_MAIN_ICON)), WINHTTP_STRESS_SCHEDULER__NAME))
		return FALSE;

	// Create timer to ping the Command Server for commands
	SetTimer(g_hWnd, IDT_QUERY_COMMAND_SERVER, g_objServerCommands.Get_CommandServerUpdateInterval(), (TIMERPROC) NULL);

	// Message loop
	while (GetMessage(&msg, NULL, 0, 0))
	{
		TranslateMessage(&msg);
		DispatchMessage(&msg);
	}

	// remove the icon from the system tray
	if (WM_QUIT == msg.message)
		SystemTray_UpdateIcon(g_hWnd, NIM_DELETE, 0, NULL, NULL);

	return msg.wParam;
}


////////////////////////////////////////////////////////////
// Function:  MainWndProc( HWND, UINT, WPARAM, LPARAM)
//
// Purpose:
//	Window callback procedure for UI.
//
// Called by:
//	WinMain
////////////////////////////////////////////////////////////
LRESULT
CALLBACK
MainWndProc
(
	HWND	hwnd,	// [IN] Handle to current window
	UINT	iMsg,	// [IN] Incoming message
	WPARAM	wParam,	// [IN] Parameter
	LPARAM	lParam	// [IN] Parameter
)
{
	switch (iMsg)
	{
		case MYWM_NOTIFYICON:
			// Notifications sent for the System Tray icon
			switch (lParam)
			{
				case WM_LBUTTONDOWN:

				case WM_RBUTTONDOWN:
					Show_IconShortCutMenu();
					return 0;

				default:
					break;
			}
			return 0;

		case WM_COMMAND:

			// User clicked on the popup menu
			switch (LOWORD(wParam))
			{
				case IDM_BEGIN_STRESS:
					// begin stress only if it's time to
					if (g_objServerCommands.IsTimeToBeginStress())
						g_objServerCommands.BeginStress();
					else
						g_objServerCommands.QueryServerForCommands();
				break;

				case IDM_END_STRESS:
					// end stress only if it's time to.
					if (!g_objServerCommands.IsTimeToBeginStress())
						g_objServerCommands.EndStress();
				break;

				case IDM_WINHTTP_HOME:
					ShellExecute(g_hWnd, "open", WINHTTP_WINHTTP_HOME_URL, NULL, NULL, SW_SHOW);
				break;

				case IDM_OPENSTRESSADMIN:
					ShellExecute(g_hWnd, "open", WINHTTP_STRESSADMIN_URL, NULL, NULL, SW_SHOW);
				break;

				case IDM_EXIT:
					g_objServerCommands.EndStress();
					PostQuitMessage(0);
				break;
			}
			return 0;

		case WM_TIMER:
			switch (wParam)
			{
				case IDT_QUERY_COMMAND_SERVER:
					// Query the server for commands
					g_objServerCommands.QueryServerForCommands();

					// Update the timer timeout
					KillTimer(g_hWnd, IDT_QUERY_COMMAND_SERVER);
					SetTimer(
						g_hWnd,
						IDT_QUERY_COMMAND_SERVER,
						g_objServerCommands.Get_CommandServerUpdateInterval(),
						(TIMERPROC) NULL);

					// ***************************
					// ***************************
					// ** Act accordingly based on Command Server messages
					// **

					// *********************************
					// ** EXIT stressScheduler
					if (g_objServerCommands.IsTimeToExitStress())
					{
						g_objServerCommands.EndStress();

						// quit stressScehduler
						PostQuitMessage(0);
						return 0;
					}

					// *********************************
					// ** BEGIN/END stress
					// Begin/end stress if it's time
					if (g_objServerCommands.IsTimeToBeginStress())
						g_objServerCommands.BeginStress();
					else
						g_objServerCommands.EndStress();

					return 0;

				break;
			}
			return 0;

		case WM_CREATE:
			return 0;

		case WM_DESTROY:
			return 0;

		default:
			return DefWindowProc (hwnd, iMsg, wParam, lParam);
	}
}



////////////////////////////////////////////////////////////
// Function:  SystemTray_UpdateIcon(HWND hDlg, DWORD dwMessage, UINT uID, WORD wIconResource, PSTR pszTip)
//
// Purpose:
//	This add/modifies/removes an icon from the system tray.
//
// Called by:
//	WinMain
////////////////////////////////////////////////////////////
BOOL
SystemTray_UpdateIcon(
	HWND hwnd,			// [IN] handle to the window object
	DWORD dwMessage,	// [IN] option to apply to the icon
	UINT uID,			// [IN] ID of the icon
	HICON hIcon,		// [IN] handle to an icon if we're loading one
	PSTR pszTip			// [IN] string containing the tool tip text
)
{
    BOOL			bSuccess;
	NOTIFYICONDATA	tnd;

	tnd.cbSize				= sizeof(NOTIFYICONDATA);
	tnd.hWnd				= hwnd;
	tnd.uID					= uID;
	tnd.uFlags				= NIF_MESSAGE | NIF_ICON | NIF_TIP;
	tnd.uCallbackMessage	= MYWM_NOTIFYICON;
	tnd.hIcon				= hIcon;

	if (pszTip)
		lstrcpyn(tnd.szTip, pszTip, sizeof(tnd.szTip));
	else
		tnd.szTip[0] = '\0';

	bSuccess = Shell_NotifyIcon(dwMessage, &tnd);

	if (hIcon)
		DestroyIcon(hIcon);

	return bSuccess;
}



////////////////////////////////////////////////////////////
// Function:  Show_IconShortCutMenu()
//
// Purpose:
//	This will show the popup menu at the position of the mouse
//	pointer.
//
// Called by:
//	MainWndProc
////////////////////////////////////////////////////////////
BOOL
Show_IconShortCutMenu()
{
	POINT		ptMouse;
	HMENU		hPopUpMenu	= NULL;
	HMENU		hMenu		= NULL;
	MENUINFO	menuInfo;
	BOOL		bResult		= FALSE;

	// Get the current mouse position
	if (0 != GetCursorPos(&ptMouse))
	{
		// show the popup menu
		hMenu = LoadMenu(g_hInstance, MAKEINTRESOURCE(IDR_POPUPMENU));
		if (!hMenu)
			return FALSE;

		hPopUpMenu	= GetSubMenu(hMenu, 0);
		if (!hPopUpMenu)
			return FALSE;

		/*
		// Make the menu go away after mouseover
		ZeroMemory(&menuInfo, sizeof(MENUINFO));
		menuInfo.cbSize		= sizeof(MENUINFO);
		menuInfo.fMask		= MIM_APPLYTOSUBMENUS | MIM_STYLE;
		menuInfo.dwStyle	= MNS_AUTODISMISS;

		BOOL temp = SetMenuInfo(hPopUpMenu, &menuInfo);
		*/
		bResult = 
			TrackPopupMenuEx(
			hPopUpMenu,
			TPM_RIGHTALIGN | TPM_BOTTOMALIGN,
			ptMouse.x,
			ptMouse.y,
			g_hWnd,
			NULL);
	}

	DestroyMenu(hMenu);

	return bResult;
}


////////////////////////////////////////////////////////////
// Function:  OS_IsSupported()
//
// Purpose:
//	Returns TRUE if this APP is supported in the OS and FALSE if not.
//	As of now, winhttp is only supported on NT platforms. NT4, Win2k, and WinXP.
//
// Called by:
//	MainWndProc
////////////////////////////////////////////////////////////
BOOL
OS_IsSupported()
{
	BOOL			bSupported = TRUE;
	OSVERSIONINFO	osVI;

	osVI.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

	if (GetVersionEx(&osVI))
	{
		if (VER_PLATFORM_WIN32_NT == osVI.dwPlatformId)
			bSupported = TRUE;
		else
			bSupported = FALSE;
	}
	else
		bSupported = FALSE;

	return bSupported;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\stress\winhttpstressscheduler.h ===
///////////////////////////////////////////////////////////////////////////
// File:  WinHttpStressScheduler.h
//
// Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
// Purpose:
//	Global types and interfaces for the WinHttpStressScheduler project.
//
// History:
//	02/01/01	DennisCh	Created
///////////////////////////////////////////////////////////////////////////


#if !defined INC__WINHTTPSTRESSSCHEDULER_H
	#define  INC__WINHTTPSTRESSSCHEDULER_H


//////////////////////////////////////////////////////////////////////
// Constants
//////////////////////////////////////////////////////////////////////
#define _UNICODE

#define WINHTTP_STRESS_SCHEDULER__NAME	"WinHttp stressScheduler"
#define WINHTTP_WINHTTP_HOME_URL		"http://winhttp"
#define WINHTTP_STRESSADMIN_URL			"http://hairball/stressAdmin/configure-client.asp"

// used to notify the tray icon
#define MYWM_NOTIFYICON	(WM_APP+100)


//////////////////////////////////////////////////////////////////////
// Includes
//////////////////////////////////////////////////////////////////////

//
// WIN32 headers
//
#include <windows.h>
#include <tchar.h>

//
// Project headers
//
#include "res\resource.h"

#endif // defined INC__WINHTTPSTRESSSCHEDULER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\stress\stressapps\asyncwebcrawler\crawler.h ===
// crawler test app header file
#include "stressMain.h"
#include <msxml.h>
#include <oleauto.h>

#define CASE_OF(constant) case constant: return # constant

#define WORKER_THREADS 4
#define MAX_CONCURRENT 4
#define CK_QUIT_THREAD 0xFFFFFFFF

CHAR*  __widetoansi(const WCHAR* pwsz);
WCHAR* __ansitowide(const char* psz);
int    DataDumpFormat(LPSTR buffer, LPBYTE data, DWORD len);
void   DataDump(LPBYTE data, DWORD len);
LPSTR  MapErrorToString(int error);
LPSTR  MapCallbackToString(DWORD callback);
LPSTR  MapAsyncErrorToString(DWORD error);

VOID CALLBACK MyStatusCallback(
    HINTERNET	hInternet,
    DWORD_PTR		dwContext,
    DWORD		dwInternetStatus,
    LPVOID		lpvStatusInformation,
    DWORD		dwStatusInformationLength
);

class XMLDict
{
  public:
    XMLDict(LPWSTR dictname);
    ~XMLDict();

  public:
    BOOL IsLoaded(void);
    BSTR GetWord(void);
    void Reset(void) { lCurrentWord = 0L; }

  private:
    IXMLDOMDocument* pDoc;
    IXMLDOMElement*  pRoot;
    IXMLDOMNodeList* pList;
    BSTR             szPattern;
    LONG             lWords;
    LONG             lCurrentWord;
};

typedef class XMLDict  XMLDICT;
typedef class XMLDict* PXMLDICT;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\stress\stressapps\asyncwebcrawler\stresstesttemplate.cpp ===
//////////////////////////////////////////////////////////////////////
// File:  stressTest.cpp
//
// Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
// Purpose:
//		<Description>
//
// History:
//	05/24/2001	pmidge		Created
//
//////////////////////////////////////////////////////////////////////


#include "crawler.h"


LPSTR	    g_szStressTestName = "AsyncWebCrawler";
LPWSTR    g_szDictPath       = L"http://mildew/stress/xmldict/5000.xml";
HINTERNET g_hSession         = NULL;
PXMLDICT  g_pDictionary      = NULL;
HANDLE    g_hIOCP            = NULL;
HANDLE    g_evtMoreUrls      = NULL;
HANDLE    g_evtQuit          = NULL;
HANDLE    g_arThreads[WORKER_THREADS];

LONG      g_lRefCount        = 0L;
LONG      g_lUrlObjsAlloc    = 0L;
LONG      g_lUrlObjsFreed    = 0L;

DWORD WINAPI WorkerThread(LPVOID pv);


#define CALLBACK_FLAGS ( WINHTTP_CALLBACK_STATUS_SENDREQUEST_COMPLETE \
                       | WINHTTP_CALLBACK_STATUS_REDIRECT             \
                       | WINHTTP_CALLBACK_STATUS_REQUEST_ERROR        \
                       | WINHTTP_CALLBACK_STATUS_HEADERS_AVAILABLE    \
                       | WINHTTP_CALLBACK_STATUS_DATA_AVAILABLE       \
                       | WINHTTP_CALLBACK_STATUS_READ_COMPLETE        \
                       | WINHTTP_CALLBACK_STATUS_HANDLE_CLOSING       \
                       | WINHTTP_CALLBACK_STATUS_CONNECTION_CLOSED    )



void
AddRef(void)
{
  InterlockedIncrement(&g_lRefCount);
}


void
Release(void)
{
  InterlockedDecrement(&g_lRefCount);

  if( g_lRefCount == 0 )
    SetEvent(g_evtQuit);
}


class Url
{
  public:
    Url(LPSTR host, LPSTR object, USHORT port)
    {
      this->host    = __ansitowide(host);
      this->object  = __ansitowide(object);
      this->port    = port;
      connect       = NULL;
      request       = NULL;
      bytes         = 0L;
      read          = 0L;
      closed        = FALSE;
      buffer        = NULL;
      qda           = FALSE;
      pending       = FALSE;

      InterlockedIncrement(&g_lUrlObjsAlloc);
    }
    
    ~Url()
    {
      if( !HandlesClosed() )
      {
        if( connect )
        {
          WinHttpSetStatusCallback(
            connect,
            NULL,
            CALLBACK_FLAGS,
            NULL
            );
        }

        if( request )
        {
          WinHttpSetStatusCallback(
            request,
            NULL,
            CALLBACK_FLAGS,
            NULL
            );
        }
        
        CloseHandles();
      }

      if( connect )
        Release();

      if( request )
        Release();

      delete [] host;
      delete [] object;

      if( buffer )
        delete [] buffer;

      InterlockedIncrement(&g_lUrlObjsFreed);
    }

  public:
    LPWSTR    Host(void)                        { return host; }
    LPWSTR    Object(void)                      { return object; }
    USHORT    Port(void)                        { return port; }
    void      Connect(HINTERNET hConnect)       { AddRef(); connect = hConnect; }
    void      Request(HINTERNET hRequest)       { AddRef(); request = hRequest; }
    HINTERNET Connect(void)                     { return connect; }
    HINTERNET Request(void)                     { return request; }
    void      Read(DWORD cbData);
    void      CloseHandles(void)                { closed=TRUE; WinHttpCloseHandle(request); WinHttpCloseHandle(connect); }
    BOOL      HandlesClosed(void)               { return closed; }
    BOOL      IsConnect(HINTERNET hInternet)    { return (hInternet == connect); }
    BOOL      IsPending(void)                   { return pending; }

  private:
    LPWSTR    host;
    LPWSTR    object;
    USHORT    port;
    HINTERNET connect;
    HINTERNET request;
    LPBYTE    buffer;
    DWORD     bytes;
    DWORD     read;
    BOOL      qda;
    BOOL      pending;
    BOOL      closed;
};


typedef class Url  URL;
typedef class Url* PURL;


BOOL  Initialize(void);
void  Cleanup(void);
BOOL  NavigateAsync(PURL pUrl);
void  DumpHeaders(PURL pUrl);
DWORD GetContentLength(PURL pUrl);


// main function
BOOL
WinHttp_StressTest()
{
	BOOL  bContinueStress = TRUE;
  BOOL  bContinue       = TRUE;
  BSTR  bsWord          = NULL;
  PURL  pUrl            = NULL;
  CHAR  url[MAX_PATH];

  if( !Initialize() )
  {
    LogText("[tid=%#0.8x] failed to initialize, exiting", GetCurrentThreadId());
    bContinueStress = FALSE;
    goto exit;
  }

  while( bContinue && !IsTimeToExitStress() )
  {
    LogText("[tid=%#0.8x] processing urls...", GetCurrentThreadId());

    for(int n=0; n < 100; n++)
    {
      if( bsWord = g_pDictionary->GetWord() )
      {
        wsprintf(url, "www.%S.com", bsWord);

        if( pUrl = new URL(url, "/", 80) )
          PostQueuedCompletionStatus(g_hIOCP, 0L, (ULONG_PTR) pUrl,  NULL);

        /*
        if( pUrl = new URL(url, "/", 443) )
          PostQueuedCompletionStatus(g_hIOCP, 0L, (ULONG_PTR) pUrl, NULL);
        */

        SysFreeString(bsWord);
      }
      else
      {
        LogText("[tid=%#0.8x] urls exhausted, signaling workers to exit", GetCurrentThreadId());
        //bContinueStress = FALSE; // DEBUGONLY
        bContinue = FALSE;
        break;
      }
    }
    
    WaitForSingleObject(g_evtMoreUrls, 120000);
    LogText("[tid=%#0.8x] url object stats: alloc=%d; freed=%d", GetCurrentThreadId(), g_lUrlObjsAlloc, g_lUrlObjsFreed);
  }

  //
  // post quit messages and wait
  //

  LogText("[tid=%#0.8x] waiting for threads to exit...", GetCurrentThreadId());

  for(int n=0; n < WORKER_THREADS; n++)
  {
    PostQueuedCompletionStatus(g_hIOCP, 0L, CK_QUIT_THREAD, NULL);
  }

  WaitForMultipleObjects(WORKER_THREADS, g_arThreads, TRUE, INFINITE);

  for(int n=0; n < WORKER_THREADS; n++)
  {
    CloseHandle(g_arThreads[n]);
    g_arThreads[n] = NULL;
  }

  while( g_lRefCount > 0 )
  {
    LogText("[tid=%#0.8x] waiting for %d internet handles...", GetCurrentThreadId(), g_lRefCount);
    WaitForSingleObject(g_evtQuit, 5000);
  }

exit:

  Cleanup();

  LogText("[tid=%#0.8x] final url object stats: alloc=%d; freed=%d", GetCurrentThreadId(), g_lUrlObjsAlloc, g_lUrlObjsFreed);

	return bContinueStress;
}


DWORD
WINAPI
WorkerThread(LPVOID pv)
{
  DWORD        bytes = 0L;
  ULONG_PTR    key   = 0L;
  LPOVERLAPPED lpo   = NULL;
  PURL         pUrl  = NULL;
  BOOL         bQuit = FALSE;

  while( !bQuit )
  {
    if( !GetQueuedCompletionStatus(g_hIOCP, &bytes, &key, &lpo, 7000) )
    {
      if( GetLastError() == WAIT_TIMEOUT )
      {
        SetEvent(g_evtMoreUrls);
        continue;
      }
    }
    else
    {
      switch( key )
      {
        case CK_QUIT_THREAD :
          {
            bQuit = TRUE;
          }
          break;

        case NULL :
          {
            LogText("[tid=%#0.8x] ERROR! NULL pUrl dequeued!", GetCurrentThreadId());
          }
          break;

        default :
          {
            pUrl = (PURL) key;
            NavigateAsync(pUrl);
          }
          break;
      }
    }
  }

  LogText("[tid=%#0.8x] exiting", GetCurrentThreadId());
  return 1L;
}


BOOL
NavigateAsync(PURL pUrl)
{
  BOOL      bRet            = FALSE;
  DWORD     dwError         = ERROR_SUCCESS;
  HINTERNET hConnect        = NULL;
  HINTERNET hRequest        = NULL;
  LPCWSTR   arAcceptTypes[] = {L"*/*",L"image/*",L"text/*",NULL};


  //-------------------------------------------------------------------------------------
  // open connect handle
  //-------------------------------------------------------------------------------------
  hConnect = WinHttpConnect(
               g_hSession,
               pUrl->Host(),
               pUrl->Port(),
               0L
               );

    if( hConnect )
    {
      pUrl->Connect(hConnect);
    }
    else
    {
      dwError = GetLastError();

      LogText(
        "[tid=%#0.8x] WinHttpConnect failed for servername %S, error %d [%s]",
        GetCurrentThreadId(),
        pUrl->Host(),
        dwError,
        MapErrorToString(dwError)
        );

      goto quit;
    }


  //-------------------------------------------------------------------------------------
  // set the callback
  //-------------------------------------------------------------------------------------
  WinHttpSetStatusCallback(
    pUrl->Connect(),
    MyStatusCallback,
    CALLBACK_FLAGS,
    NULL
    );


  //-------------------------------------------------------------------------------------
  // open request handle
  //-------------------------------------------------------------------------------------
  hRequest = WinHttpOpenRequest(
               pUrl->Connect(),
               L"GET",
               pUrl->Object(),
               NULL,
               NULL,
               arAcceptTypes,
               ((pUrl->Port() == 80) ? 0L : WINHTTP_FLAG_SECURE)
               );

    if( hRequest )
    {
      pUrl->Request(hRequest);
    }
    else
    {
      dwError = GetLastError();

      LogText(
        "[tid=%#0.8x] WinHttpOpenRequest failed for %S, error %d [%s]",
        GetCurrentThreadId(),
        pUrl->Object(),
        dwError,
        MapErrorToString(dwError)
        );

      goto quit;
    }


  //-------------------------------------------------------------------------------------
  // send the request - this is the first opportunity for a call to go async
  //-------------------------------------------------------------------------------------
  if( !WinHttpSendRequest(pUrl->Request(), NULL, 0L, NULL, 0L, 0L, (DWORD_PTR) pUrl) )
  {
    dwError = GetLastError();

    if( dwError == ERROR_IO_PENDING )
    {
#if 0
      LogText(
        "[tid=%#0.8x; con=%#0.8x; req=%#0.8x] %s://%S%S request went async...",
        GetCurrentThreadId(),
        hConnect,
        hRequest,
        ((pUrl->Port() == 80) ? "http" : "https"),
        pUrl->Host(),
        pUrl->Object()
        );
#endif
    }
    else
    {
      LogText(
        "[tid=%#0.8x; con=%#0.8x; req=%#0.8x] %s://%S%S request failed: %d [%s]!",
        GetCurrentThreadId(),
        hConnect,
        hRequest,
        ((pUrl->Port() == 80) ? "http" : "https"),
        pUrl->Host(),
        pUrl->Object(),
        dwError,
        MapErrorToString(dwError)
        );

      goto quit;
    }
  }
  else
  {
    LogText("[tid=%#0.8x] ERROR! WinHttpSendRequest returned TRUE in async mode!!!", GetCurrentThreadId());
    goto quit;
  }


  //-------------------------------------------------------------------------------------
  // if we get here, we've succeeded in our mission, set exit code to true
  //-------------------------------------------------------------------------------------
  bRet = TRUE;


quit:

  //-------------------------------------------------------------------------------------
  // handle errors and exit
  //-------------------------------------------------------------------------------------
  if( !bRet )
    delete pUrl;

  return bRet;
}



VOID
CALLBACK
MyStatusCallback(
  HINTERNET	hInternet,
  DWORD_PTR dwContext,
  DWORD		  dwInternetStatus,
  LPVOID    lpvStatusInformation,
  DWORD	  	dwStatusInformationLength
  )
{
  PURL pUrl = (PURL) dwContext;

#if 0
  LogText(
    "[tid=%#0.8x; con=%#0.8x; req=%#0.8x] %s://%S%S in %s",
    GetCurrentThreadId(),
    pUrl->Connect(),
    pUrl->Request(),
    ((pUrl->Port() == 80) ? "http" : "https"),
    pUrl->Host(),
    pUrl->Object(),
    MapCallbackToString(dwInternetStatus)
    );
#endif


	switch(dwInternetStatus)
	{
    case WINHTTP_CALLBACK_STATUS_SENDREQUEST_COMPLETE :
      {
        //
        // a WHSR call is completing
        //
        WinHttpReceiveResponse(pUrl->Request(), NULL);
      }
      break;

    case WINHTTP_CALLBACK_STATUS_REDIRECT :
      {
        pUrl->CloseHandles();
      }
      break;

    case WINHTTP_CALLBACK_STATUS_HEADERS_AVAILABLE :
      {
        //
        // a WHRR call is completing
        //
        pUrl->Read(GetContentLength(pUrl));
        //pUrl->Read(0);
      }
      break;

    case WINHTTP_CALLBACK_STATUS_DATA_AVAILABLE :
      {
        //
        // a WHQDA call is completing
        //
        pUrl->Read(dwStatusInformationLength);
      }
      break;

    case WINHTTP_CALLBACK_STATUS_READ_COMPLETE :
      {
        //
        // a WHRD call is completing
        //

#if 0
        DataDump((LPBYTE) lpvStatusInformation, dwStatusInformationLength);
#endif

        pUrl->Read(dwStatusInformationLength);
      }
      break;

    case WINHTTP_CALLBACK_STATUS_CONNECTION_CLOSED :
      {
        if( !pUrl->IsPending() )
        {
          if( !pUrl->HandlesClosed() )
          {
            pUrl->CloseHandles();
          }
        }
      }
      break;

    case WINHTTP_CALLBACK_STATUS_HANDLE_CLOSING :
      {
        //
        // we're done with this particular URL
        //

        if( pUrl->IsConnect(hInternet) )
          delete pUrl;
      }
      break;

    case WINHTTP_CALLBACK_STATUS_REQUEST_ERROR :
      {
#if 0
        WINHTTP_ASYNC_RESULT* pwar = (WINHTTP_ASYNC_RESULT*) lpvStatusInformation;

        LogText(
          "[tid=%#0.8x; hInternet=%#0.8x] async api error: dwResult=%d; dwError=%s",
          GetCurrentThreadId(),
          hInternet,
          pwar->dwResult,
          MapAsyncErrorToString(pwar->dwError)
          );
#endif
        pUrl->CloseHandles();
      }
      break;
  }
}


void
Url::Read(DWORD cbData)
{
  BOOL  bSuccess = FALSE;
  DWORD dwError  = ERROR_SUCCESS;

query_data:

  // if a read is pending, we know that we're handling a READ_COMPLETE callback
  if( !pending )
  {
    // if we haven't recently called WHQDA, do so and handle errors
    if( !qda && !(bytes = cbData) )
    {
      bSuccess = WinHttpQueryDataAvailable(request, &bytes);
      dwError  = GetLastError();

      if( !bSuccess )
      {
        if( dwError != ERROR_IO_PENDING )
        {
          CloseHandles();
        }
        else
        {
          qda = TRUE;
        }
        
        return;
      }
    }

    // we got here, so there must be some data to read, reset the QDA flag and read data.
    qda      = FALSE;
    buffer   = new BYTE[bytes];
    bSuccess = WinHttpReadData(request, (LPVOID) buffer, bytes, &read);
    dwError  = GetLastError();

    if( bSuccess && (read == 0) )
    {
      CloseHandles();
    }
    else
    {
      if( dwError == ERROR_IO_PENDING )
      {
        pending = TRUE;
      }
      else
      {
        CloseHandles();
      }
    }
  }
  else
  {
    // an async read has completed, did we read anything? if not, close handles and return,
    // otherwise free the old buffer and reset our internal state. then, to keep things
    // rolling, loop back up and call WHQDA.
    if( cbData == 0 )
    {
      pending = FALSE;
      CloseHandles();
    }
    else
    {
      delete [] buffer;

      buffer  = NULL;
      bytes   = 0;
      read    = 0;
      cbData  = 0;
      pending = FALSE;

      goto query_data;
    }
  }
}





DWORD
GetContentLength(PURL pUrl)
{
  DWORD dwCL   = 0L;
  DWORD cbData = sizeof(DWORD);

  WinHttpQueryHeaders(
    pUrl->Request(),
    WINHTTP_QUERY_CONTENT_LENGTH + WINHTTP_QUERY_FLAG_NUMBER,
    NULL,
    &dwCL,
    &cbData,
    NULL
    );

  SetLastError(0);

  return dwCL;
}


BOOL
Initialize(void)
{
  BOOL  bRet    = FALSE;
  DWORD dwError = 0L;

  if( FAILED(CoInitializeEx(NULL, COINIT_MULTITHREADED)) )
  {
    LogText("failed to initialize COM");
    goto exit;
  }


  //-------------------------------------------------------------------------------------
  // open dictionary file
  //-------------------------------------------------------------------------------------
  if( !g_pDictionary )
  {    
    g_pDictionary = new XMLDICT(g_szDictPath);

      if( !g_pDictionary )
      {
        goto exit;
      }

      if( g_pDictionary->IsLoaded() )
      {
        LogText("dictionary loaded.");
      }
      else
      {
        goto exit;
      }
  }


  //-------------------------------------------------------------------------------------
  // create completion port
  //-------------------------------------------------------------------------------------
  g_hIOCP = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0L, MAX_CONCURRENT);

    if( !g_hIOCP )
    {
      dwError = GetLastError();
      LogText("failed to open completion port, error %d [%s]", dwError, MapErrorToString(dwError));
      goto exit;
    }


  //-------------------------------------------------------------------------------------
  // create worker threads
  //-------------------------------------------------------------------------------------
  for(int n=0; n < WORKER_THREADS; n++)
  {
    g_arThreads[n] = CreateThread(
                       NULL,
                       0L,
                       WorkerThread,
                       NULL,
                       0L,
                       NULL
                       );

    if( !g_arThreads[n] )
    {
      dwError = GetLastError();
      LogText("failed to create thread %d, error %d [%s]", n, dwError, MapErrorToString(dwError));
      goto exit;
    }
  }


  //-------------------------------------------------------------------------------------
  // create 'no more urls' event
  //-------------------------------------------------------------------------------------
  g_evtMoreUrls = CreateEvent(NULL, FALSE, FALSE, NULL);

    if( !g_evtMoreUrls )
    {
      dwError = GetLastError();
      LogText("failed to create url event, error %d [%s]", dwError, MapErrorToString(dwError));
      goto exit;
    }


  //-------------------------------------------------------------------------------------
  // create 'all requests complete' event
  //-------------------------------------------------------------------------------------
  g_evtQuit = CreateEvent(NULL, FALSE, FALSE, NULL);

    if( !g_evtQuit )
    {
      dwError = GetLastError();
      LogText("failed to create quit event, error %d [%s]", dwError, MapErrorToString(dwError));
      goto exit;
    }


  //-------------------------------------------------------------------------------------
  // open shared session handle
  //-------------------------------------------------------------------------------------
  g_hSession = WinHttpOpen(
                 L"foo",
                 WINHTTP_ACCESS_TYPE_NAMED_PROXY,
                 L"itgproxy",
                 L"<local>",
                 WINHTTP_FLAG_ASYNC
                 );

    if( !g_hSession )
    {
      dwError = GetLastError();
      LogText("failed to open winhttp, error %d [%s]", dwError, MapErrorToString(dwError));
      goto exit;
    }


  //-------------------------------------------------------------------------------------
  // set global timeouts
  //-------------------------------------------------------------------------------------
  bRet = WinHttpSetTimeouts(
           g_hSession,
           60000, // resolve
           10000, // connect
           5000,  // send
           5000   // receive
           );

    if( !bRet )
    {
      dwError = GetLastError();
      LogText("failed to set timeouts, error %d [%s]", dwError, MapErrorToString(dwError));
    }

exit:

  return bRet;
}


void
Cleanup(void)
{
  if( g_pDictionary )
  {
    //g_pDictionary->Reset();

    delete g_pDictionary;
    g_pDictionary = NULL;
  }

  if( g_hIOCP != NULL )
  {
    CloseHandle(g_hIOCP);
    g_hIOCP = NULL;
  }

  if( g_evtMoreUrls != NULL )
  {
    CloseHandle(g_evtMoreUrls);
    g_evtMoreUrls = NULL;
  }

  if( g_evtQuit != NULL )
  {
    CloseHandle(g_evtQuit);
    g_evtQuit = NULL;
  }

  if( g_hSession )
  {
    WinHttpCloseHandle(g_hSession);
    g_hSession = NULL;
  }

  CoUninitialize();
}


XMLDict::XMLDict(LPWSTR dictname)
{
  HRESULT      hr       = S_OK;
  BSTR         tag      = NULL;
  VARIANT_BOOL bSuccess = VARIANT_FALSE;
  VARIANT      doc;

  LogText("loading dictionary...");

  hr = CoCreateInstance(
         CLSID_DOMDocument,
         NULL,
         CLSCTX_INPROC_SERVER,
         IID_IXMLDOMDocument,
         (void**) &pDoc
         );

  if( SUCCEEDED(hr) )
  {
    hr = pDoc->put_async(bSuccess);

    VariantInit(&doc);

    V_VT(&doc)   = VT_BSTR;
    V_BSTR(&doc) = SysAllocString(dictname);

    hr = pDoc->load(doc, &bSuccess);

      if( FAILED(hr) || (bSuccess == VARIANT_FALSE) )
      {
        LogText("failed to load xml dictionary");
        goto quit;
      }

    hr = pDoc->get_documentElement(&pRoot);

      if( FAILED(hr) )
      {
        LogText("couldn\'t find root node!");
        goto quit;
      }

    tag = SysAllocString(L"keyphrase");
    hr  = pDoc->getElementsByTagName(tag, &pList);

      if( FAILED(hr) )
      {
        LogText("couldn\'t find any words!");
        goto quit;
      }

    hr = pList->get_length(&lWords);

      if( FAILED(hr) )
      {
        LogText("couldn\'t determine the number of words in the list!");
      }

    szPattern    = SysAllocString(L"string");
    lCurrentWord = 0L;
  }

quit:
  
  VariantClear(&doc);

  if( tag )
  {
    SysFreeString(tag);
  }
}


XMLDict::~XMLDict()
{
  LogText("unloading dictionary...");

  if( szPattern )
  {
    SysFreeString(szPattern);
  }

  if( pList )
  {
    pList->Release();
  }

  if( pRoot )
  {
    pRoot->Release();
  }

  if( pDoc )
  {
    pDoc->Release();
  }
}


BOOL
XMLDict::IsLoaded(void)
{
  LONG state = 0L;

  if( pDoc )
  {
    pDoc->get_readyState(&state);
  }
  else
  {
    return state;
  }

  return (state == 4);
}


BSTR
XMLDict::GetWord(void)
{
  HRESULT      hr     = S_OK;
  IXMLDOMNode* pEntry = NULL; 
  IXMLDOMNode* pWord  = NULL; 
  BSTR         bsWord = NULL;

do_over:

  hr = pList->get_item(lCurrentWord, &pEntry);

    if( FAILED(hr) || !pEntry )
      goto quit;

  ++lCurrentWord;

  hr = pEntry->selectSingleNode(szPattern, &pWord);

    if( FAILED(hr) || !pWord )
      goto quit;

  hr = pWord->get_text(&bsWord);

    if( FAILED(hr) )
      goto quit;

  // some of the words in the dictionary have apostrophes. urls can't have
  // apostrophes, so we strip them out.
  if( wcschr(bsWord, L'\'') )
  {
    SysFreeString(bsWord);
    bsWord = NULL;
    pEntry->Release();
    pWord->Release();
    goto do_over;
  }

quit:

  if( pEntry )
    pEntry->Release();

  if( pWord )
    pWord->Release();

  return bsWord;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\stress\stressapps\asynchttpspost-basicserver_ntlmproxy_sc\asynchttpspost-basicserver_ntlmproxy_sc.cpp ===
//////////////////////////////////////////////////////////////////////
// File:  AsyncHTTPSPost-BasicServer_NTLMProxy_SC.cpp
//
// Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
// Purpose:
//		This file contains your implementation of the stress test function
//		WinHttp_StressTest() that is called in stressMain.cpp.
//
//		Steps:
//			- Set your test case name in g_szStressTestName.
//			- Add your test code to WinHttp_StressTest(). 
//
// History:
//	04/02/01	adamb	Created
//
//////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////
// Includes
//////////////////////////////////////////////////////////////////////
#include "stressMain.h"

//////////////////////////////////////////////////////////////////////
// Globals and constants
//////////////////////////////////////////////////////////////////////

// ************************************
// ************************************
// ** Fill in your test case name below
// ** 
LPSTR	g_szStressTestName = "Basic auth to https over NTLM auth proxy tunnel, set creds using WinHttpSetCredentials, Asynchronous";

VOID CALLBACK MyStatusCallback(
    HINTERNET	hInternet,
    DWORD		dwContext,
    DWORD		dwInternetStatus,
    LPVOID		lpvStatusInformation,
    DWORD		dwStatusInformationLength
);

DWORD g_dwContext = 0;
HINTERNET hOpen = NULL;
HINTERNET hConnect = NULL;
HINTERNET hRequest = NULL;

BOOL WinHttp_StressTest(void);

//post stuff
LPSTR	pPostData = NULL;
DWORD	dwPostDataLength = 0;

//WinHttpSetStatusCallback
WINHTTP_STATUS_CALLBACK iscCallback; 	

//WinHttpReadData
DWORD dwSize = 0, dwDownloaded=0, nCounter;
LPSTR lpszData;

DWORD	Count = 0, dwAccessType = WINHTTP_ACCESS_TYPE_NO_PROXY,
		dwAuthScheme=0,dwAuthTargets=0,dwOtherScheme=0,dwOpenRequestFlags=0,
		dwStatus=0, cbStatus=0;

LPWSTR	wszHost=NULL, wszUri=NULL, wszUserName=NULL, wszPassword=NULL,
		wszProxy = NULL, wszProxyUserName = NULL, wszProxyPassword = NULL,
		wszVerb=L"GET";

INTERNET_PORT	nPort = INTERNET_DEFAULT_HTTP_PORT;

////////////////////////////////////////////////////////////
// Function:  MyStatusCallback(HINTERNET, DWORD, DWORD, LPVOID, DWORD)
//
// Purpose:
//		Status callback proc for WinHttp.
//
////////////////////////////////////////////////////////////
VOID CALLBACK MyStatusCallback(
    HINTERNET	hInternet,
    DWORD		dwContext,
    DWORD		dwInternetStatus,
    LPVOID		lpvStatusInformation,
    DWORD		dwStatusInformationLength
)
{
	switch(dwInternetStatus)
	{
		case WINHTTP_CALLBACK_STATUS_RESOLVING_NAME:
			LogText("\t[ WINHTTP_CALLBACK_STATUS_RESOLVING_NAME ]");
			break;
		case WINHTTP_CALLBACK_STATUS_NAME_RESOLVED:	
			LogText("\t[ WINHTTP_CALLBACK_STATUS_NAME_RESOLVED ]");
			break;
		case WINHTTP_CALLBACK_STATUS_CONNECTING_TO_SERVER:
			LogText("\t[ WINHTTP_CALLBACK_STATUS_CONNECTING_TO_SERVER ]");
			break;
		case WINHTTP_CALLBACK_STATUS_CONNECTED_TO_SERVER:
			LogText("\t[ WINHTTP_CALLBACK_STATUS_CONNECTED_TO_SERVER ]");
			break;
		case WINHTTP_CALLBACK_STATUS_SENDING_REQUEST:
			LogText("\t[ WINHTTP_CALLBACK_STATUS_SENDING_REQUEST ]");
			break;
		case WINHTTP_CALLBACK_STATUS_REQUEST_SENT:
			LogText("\t[ WINHTTP_CALLBACK_STATUS_REQUEST_SENT ]");
			break;
		case WINHTTP_CALLBACK_STATUS_RECEIVING_RESPONSE:
			LogText("\t[ WINHTTP_CALLBACK_STATUS_RECEIVING_RESPONSE ]");
			break;
		case WINHTTP_CALLBACK_STATUS_RESPONSE_RECEIVED:	
			LogText("\t[ WINHTTP_CALLBACK_STATUS_RESPONSE_RECEIVED ]");
			break;
		case WINHTTP_CALLBACK_STATUS_CLOSING_CONNECTION:
			LogText("\t[ WINHTTP_CALLBACK_STATUS_CLOSING_CONNECTION ]");
			break;
		case WINHTTP_CALLBACK_STATUS_CONNECTION_CLOSED:	
			LogText("\t[ WINHTTP_CALLBACK_STATUS_CONNECTION_CLOSED ]");
			break;
		case WINHTTP_CALLBACK_STATUS_HANDLE_CREATED:
			LogText("\t[ WINHTTP_CALLBACK_STATUS_HANDLE_CREATED ]");
			break;
		case WINHTTP_CALLBACK_STATUS_HANDLE_CLOSING:
			LogText("\t[ WINHTTP_CALLBACK_STATUS_HANDLE_CLOSING ]");
			break;
		case WINHTTP_CALLBACK_STATUS_DETECTING_PROXY:
			LogText("\t[ WINHTTP_CALLBACK_STATUS_DETECTING_PROXY ]");
			break;
		case WINHTTP_CALLBACK_STATUS_REDIRECT:
			LogText("\t[ WINHTTP_CALLBACK_STATUS_REDIRECT ]");
			break;
		case WINHTTP_CALLBACK_STATUS_INTERMEDIATE_RESPONSE:
			LogText("\t[ WINHTTP_CALLBACK_STATUS_INTERMEDIATE_RESPONSE ]");
			break;
		case WINHTTP_CALLBACK_STATUS_REQUEST_COMPLETE:
			LogText("\t[ WINHTTP_CALLBACK_STATUS_REQUEST_COMPLETE ]");
			break;
		default:
			LogText("\t[ INVALID status callack %u ]", dwInternetStatus);
			break;
	}
}


////////////////////////////////////////////////////////////
// Function:  WinHttp_StressTest()
//
// Purpose:
////////////////////////////////////////////////////////////

BOOL
WinHttp_StressTest()
{
	BOOL bContinueStress = TRUE;

	wszVerb=L"POST";
	pPostData = "If you smelllllllll what THE ROCK is cooking??? <people's eyebrow>";
	dwPostDataLength = strlen(pPostData);

	nPort = INTERNET_DEFAULT_HTTPS_PORT;
	dwOpenRequestFlags = WINHTTP_FLAG_SECURE;

	wszProxy = L"xfluke";
	wszProxyUserName = L"xfluke\\proxyuser";
	wszProxyPassword = L"password";
	dwAccessType = WINHTTP_ACCESS_TYPE_NAMED_PROXY;


	//using this you can specify setcredentials or setoption for setting creds
	//also, 0->3 for the switch specifies which auth scheme to use
	LPSTR CredType = "SC";

	switch(0)
	{
	case 0: //basic
		wszHost = L"wiredbvt";
		wszUri = L"/api/Auth/Basic/echo-post-data.asp";
		wszUserName = L"ApiAuth";
		wszPassword = L"test1234!";
		break;
	case 1: //digest
		wszHost = L"kerby2";
		wszUri = L"/digest/echo-post-data.asp";
		wszUserName = L"authdigest";
		wszPassword = L"digest";
		break;
	case 2: //negotiate
		wszHost = L"kerby2";
		wszUri = L"/ie/negotiate/echo-post-data.asp";
		wszUserName = L"kerby2\\authnego";
		wszPassword = L"nego";
		break;
	case 3: //ntlm
		wszHost = L"clapton";
		wszUri = L"/test/ntlm/echo-post-data.asp";
		wszUserName = L"clapton\\ntlmtest";
		wszPassword = L"ntlm";
		break;
	}

	// ***********************************
	// ** WinHttpOpen
	// **

	LogText("WinHttpOpen: calling.");
	hOpen = WinHttpOpen
	(
		L"Stress Test",
		dwAccessType,
		wszProxy,
		NULL,
		WINHTTP_FLAG_ASYNC
	);

	if(hOpen == NULL)
	{
		LogText("WinHttpOpen failed with error %u.", GetLastError());
		goto Exit;
	}
	else
		LogText("WinHttpOpen: called.");

	iscCallback = WinHttpSetStatusCallback(
		hOpen,
		(WINHTTP_STATUS_CALLBACK)MyStatusCallback,
		WINHTTP_CALLBACK_FLAG_ALL_NOTIFICATIONS,
		NULL);

	// ***********************************
	// ** WinHttpConnect
	// **
	
	LogText("WinHttpConnect: calling.");	
	hConnect = WinHttpConnect
	(
		hOpen,
		wszHost,
		nPort,
		0
	);

	if(hConnect==NULL)
	{
		LogText("WinHttpConnect failed with error %u.", GetLastError());
		goto Exit;
	}
	else
		LogText("WinHttpConnect: called.");

	LogText("WinHttpOpenRequest: calling.");
	hRequest = WinHttpOpenRequest
	(
		hConnect,
		wszVerb,
		wszUri,
		NULL,
		NULL,
		NULL,
		dwOpenRequestFlags
	);

	if(hRequest==NULL)
	{
		LogText("WinHttpOpenRequest failed with error %u.", GetLastError());
		goto Exit;
	}
	else
		LogText("WinHttpOpenRequest: called.");


Resend:
/*
	if( Count++>10) // making sure that we don't have infinite looping
	{
		bContinueStress=FALSE;
		goto Exit;
	}
*/
	LogText("WinHttpSendRequest: calling.");
	// Send request.
	if(!WinHttpSendRequest
	(
		hRequest,					// request handle
		NULL,						// header string
		0,							// header length
		(PVOID) pPostData,			// post data
		dwPostDataLength,			// post data length
		dwPostDataLength*2,			// total post length
		g_dwContext					// flags
	))
	{
		LogText("WinHttpSendRequest failed with error %u.", GetLastError());
		if ( GetLastError() != ERROR_IO_PENDING )
			goto Exit;
	}
	else
		LogText("WinHttpSendRequest: called.");

	LogText("WinHttpReceiveResponse: calling.");
	if (!WinHttpReceiveResponse(hRequest, NULL))
	{
		LogText("WinHttpReceiveResponse failed with error %u.", GetLastError());
		if ( GetLastError() != ERROR_IO_PENDING )
			goto Exit;
	}
	else
	{
		LogText("WinHttpReceiveResponse: called.");
	}

	do
	{
try_again:
		LogText("WinHttpQueryDataAvailable: calling.");
		if (!WinHttpQueryDataAvailable(hRequest,&dwSize))
		{
			if (GetLastError()== ERROR_IO_PENDING)
			{
				nCounter = 0;
				
				while(GetLastError()==ERROR_IO_PENDING)
				{
					if (nCounter++==2000)
						break;
					LogText("WinHttpQueryDataAvailable: calling.");
					WinHttpQueryDataAvailable(hRequest,&dwSize);
					LogText("WinHttpQueryDataAvailable: called.");
				}
				goto try_again;
			}
			else
			{
				LogText("WinHttpQueryDataAvailable failed with error %u.", GetLastError());
				goto Exit;
			}
		}
		else
		{
			LogText("WinHttpQueryDataAvailable: called.");
			// Allocates a buffer of the size returned by WinHttpQueryDataAvailable
			lpszData = new char[dwSize+1];

			// Reads the data from the handle.
			LogText("WinHttpReadData: calling.");
			if(!WinHttpReadData(hRequest,(LPVOID)lpszData,dwSize,&dwDownloaded))
			{
				if (GetLastError()== ERROR_IO_PENDING)
				{
					nCounter = 0;
					
					while(GetLastError()==ERROR_IO_PENDING)
					{
						if (nCounter++==2000)
						{
							delete[] lpszData;
							break;
						}
						else
						{
							LogText("WinHttpReadData: calling.");
							WinHttpReadData(hRequest,(LPVOID)lpszData,dwSize,&dwDownloaded);
							LogText("WinHttpReadData: called.");
						}
					}
					goto keep_going;
				}
				else
				{
					LogText("WinHttpReadData failed with error %u.", GetLastError());
					delete[] lpszData;
					goto Exit;
				}	
			}
			else
			{
				LogText("WinHttpReadData: called.");
keep_going:
				delete[] lpszData;

				// Check the size of the remaining data.  If it is zero, break.
				if (dwDownloaded == 0)
					break;
			}
		}
	}while(1);

	LogText("WinHttpQueryHeaders: calling.");
	cbStatus = sizeof(dwStatus);
	if(!WinHttpQueryHeaders
	(
		hRequest,
		WINHTTP_QUERY_FLAG_NUMBER | WINHTTP_QUERY_STATUS_CODE,
		NULL,
		&dwStatus,
		&cbStatus,
		NULL
	))
		LogText("WinHttpQueryHeaders failed with error %u.", GetLastError());
	else
		LogText("WinHttpQueryHeaders: called.");

	switch( dwStatus )
	{
	case 200:
		LogText("Status = 200");
		break;
	case 401:
		LogText("Status = 401");
		if(strcmp(CredType, "SC"))
		{
			LogText("WinHttpQueryAuthSchemes: calling.");
			if(!WinHttpQueryAuthSchemes
			(
				hRequest,
				&dwOtherScheme,
				&dwAuthScheme,
				&dwAuthTargets
			))
			{
				LogText("WinHttpQueryAuthSchemes failed with error %u.", GetLastError());
				goto Exit;
			}
			else
				LogText("WinHttpQueryAuthSchemes: called.");

			LogText("WinHttpSetCredentials: calling.");
			if(!WinHttpSetCredentials
			(
				hRequest,
				dwAuthTargets,
				dwAuthScheme,
				wszUserName,
				wszPassword,
				(PVOID) NULL
			))
			{
				LogText("WinHttpSetCredentials failed with error %u.", GetLastError());
				goto Exit;
			}
			else
				LogText("WinHttpSetCredentials: called.");
		}
		else
		{
			LogText("WinHttpSetOption: calling.");
			if(!WinHttpSetOption
			(
				hRequest,
				WINHTTP_OPTION_USERNAME,
				(PVOID) wszUserName,
				wcslen(wszUserName)
			))
			{
				LogText("WinHttpSetOption failed with error %u.", GetLastError());
				goto Exit;
			}
			else
				LogText("WinHttpSetOption: called.");

			LogText("WinHttpSetOption: calling.");
			if(!WinHttpSetOption
			(
				hRequest,
				WINHTTP_OPTION_PASSWORD,
				(PVOID) wszPassword,
				wcslen(wszPassword)
			))
			{
				LogText("WinHttpSetOption failed with error %u.", GetLastError());
				goto Exit;
			}
			else
				LogText("WinHttpSetOption: called.");
		}
		goto Resend;
	break;

	case 407:
		LogText("Status = 407");
		if(strcmp(CredType, "SC"))
		{
			LogText("WinHttpQueryAuthSchemes: calling.");
			if(!WinHttpQueryAuthSchemes
			(
				hRequest,
				&dwOtherScheme,
				&dwAuthScheme,
				&dwAuthTargets
			))
			{
				LogText("WinHttpQueryAuthSchemes failed with error %u.", GetLastError());
				goto Exit;
			}
			else
				LogText("WinHttpQueryAuthSchemes: called.");

			LogText("WinHttpSetCredentials: calling.");
			if(!WinHttpSetCredentials
			(
				hRequest,
				dwAuthTargets,
				dwAuthScheme,
				wszProxyUserName,
				wszProxyPassword,
				(PVOID) NULL
			))
			{
				LogText("WinHttpSetCredentials failed with error %u.", GetLastError());
				goto Exit;
			}
			else
				LogText("WinHttpSetCredentials: called.");
		}
		else
		{
			LogText("WinHttpSetOption: calling.");
			if(!WinHttpSetOption
			(
				hRequest,
				WINHTTP_OPTION_PROXY_USERNAME,
				(PVOID) wszProxyUserName,
				wcslen(wszProxyUserName)
			))
			{
				LogText("WinHttpSetOption failed with error %u.", GetLastError());
				goto Exit;
			}
			else
				LogText("WinHttpSetOption: called.");

			LogText("WinHttpSetOption: calling.");
			if(!WinHttpSetOption
			(
				hRequest,
				WINHTTP_OPTION_PROXY_PASSWORD,
				(PVOID) wszProxyPassword,
				wcslen(wszProxyPassword)
			))
			{
				LogText("WinHttpSetOption failed with error %u.", GetLastError());
				goto Exit;
			}
			else
				LogText("WinHttpSetOption: called.");
		}

		goto Resend;
	default:
		LogText("Status = %u", dwStatus);
	break;

	} //end of switch (status code)

Exit:

	if( hRequest != NULL )
	{
		WinHttpCloseHandle(hRequest);
		hRequest = NULL;
	}

	if( hConnect != NULL )
	{
		WinHttpCloseHandle(hConnect);
		hConnect = NULL;
	}

	if( hOpen != NULL )
	{
		WinHttpCloseHandle(hOpen);
		hOpen = NULL;
	}


	return bContinueStress;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\stress\stressapps\asynchttppost-winhttpquerydataavailable\asynchttppost-winhttpquerydataavailable.cpp ===
//////////////////////////////////////////////////////////////////////
// File:  stressTest.cpp
//
// Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
// Purpose:
//		Sends a HTTP POST request asynchronously and then calls
//		WinHttpReceiveResponse and WinHttpQueryDataAvailable in a loop.
//
// History:
//	04/03/01	DennisCh	Created
//
//////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////
// Includes
//////////////////////////////////////////////////////////////////////
#include "stressMain.h"


//////////////////////////////////////////////////////////////////////
// Globals and constants
//////////////////////////////////////////////////////////////////////

// ************************************
// ************************************
// ** Fill in your test case name below
// ** 
LPSTR	g_szStressTestName = "HTTP POST then calls WinHttpQueryDataAvailable in a loop.";


// Foward function definitions
VOID CALLBACK MyStatusCallback(
    HINTERNET	hInternet,
    DWORD		dwContext,
    DWORD		dwInternetStatus,
    LPVOID		lpvStatusInformation,
    DWORD		dwStatusInformationLength
);


////////////////////////////////////////////////////////////
// Function:  WinHttp_StressTest()
//
// Purpose:
//	The stress test function. Insert your test code here.
//	Returning TRUE will cause main() to call this function again.
//	Otherwise, returning FALSE will cause the app to exit.
//
//	If you plan to loop within this function, be sure to 
//	use IsTimeToExitStress() as one of your exit conditions.
//
//	This must be done because the stressScheduler will notify
//	a this stress app when to exit based on the state of the
//	inherited event object that IsTimeToExitStress() checks for.
//	IsTimeToExitStress() will return TRUE when it's time to exit.
//
////////////////////////////////////////////////////////////
BOOL
WinHttp_StressTest()
{
	BOOL		bContinueStress = TRUE;
	HINTERNET	hOpen			= NULL;
	HINTERNET	hConnect		= NULL;
	HINTERNET	hRequest		= NULL;


	// ***********************
	// ** WinHttpOpen
	hOpen = WinHttpOpen(
		L"StressTest",
		WINHTTP_ACCESS_TYPE_NO_PROXY,
		NULL,
		NULL,
		WINHTTP_FLAG_ASYNC);

	if (!hOpen)
	{
		LogText("WinHttpOpen failed with error %u.", GetLastError());
		goto Exit;
	}


	// ***********************
	// ** WinHttpConnect
	hConnect = WinHttpConnect(
		hOpen,
		L"hairball",
		INTERNET_DEFAULT_HTTP_PORT,
		0);

	if (!hConnect)
	{
		LogText("WinHttpConnect failed with error %u.", GetLastError());
		goto Exit;
	}
		

	// ***********************
	// ** WinHttpOpenRequest
	hRequest = WinHttpOpenRequest(
		hConnect,
		L"GET",
		L"/",
		NULL,
		NULL,
		NULL,
		0);


	if (!hRequest)
	{
		LogText("WinHttpOpenRequest failed with error %u.", GetLastError());
		goto Exit;
	}


	DWORD dwIndex, dwContext, dwDataAvailable;

	// ***********************
	// ** WinHttpSendRequest
	dwContext = 0;
	if (!WinHttpSendRequest(hRequest, NULL, 0, NULL, 0, 0, dwContext))
		LogText("WinHttpSendRequest failed with error %u", GetLastError());


	for (dwIndex=0; (dwIndex < 100000); dwIndex++)
	{
		// ***********************
		// ** WinHttpReceiveResponse
		if (!WinHttpReceiveResponse(hRequest, NULL))
			LogText("WinHttpReceiveResponse failed with error %u", GetLastError());

		// ***********************
		// ** WinHttpQueryDataAvailable
		if (!WinHttpQueryDataAvailable(hRequest, &dwDataAvailable))
			LogText("WinHttpQueryDataAvailable failed with error %u", GetLastError());
	}

Exit:
	if (hOpen && !WinHttpCloseHandle(hOpen))
		LogText("WinHttpCloseHandle failed(hOpen) with error %u", GetLastError());

	if (hConnect && !WinHttpCloseHandle(hConnect))
		LogText("WinHttpCloseHandle(hConnect) failed with error %u", GetLastError());

	if (hRequest &&	!WinHttpCloseHandle(hRequest))
		LogText("WinHttpCloseHandle(hRequest) failed with error %u", GetLastError());

	return bContinueStress;
}


////////////////////////////////////////////////////////////
// Function:  MyStatusCallback(HINTERNET, DWORD, DWORD, LPVOID, DWORD)
//
// Purpose:
//		Status callback proc for WinHttp.
//
////////////////////////////////////////////////////////////
VOID CALLBACK MyStatusCallback(
    HINTERNET	hInternet,
    DWORD		dwContext,
    DWORD		dwInternetStatus,
    LPVOID		lpvStatusInformation,
    DWORD		dwStatusInformationLength
)
{
	switch(dwInternetStatus)
	{
		case WINHTTP_CALLBACK_STATUS_RESOLVING_NAME:
			LogText("\t[ WINHTTP_CALLBACK_STATUS_RESOLVING_NAME ]");
			break;
		case WINHTTP_CALLBACK_STATUS_NAME_RESOLVED:	
			LogText("\t[ WINHTTP_CALLBACK_STATUS_NAME_RESOLVED ]");
			break;
		case WINHTTP_CALLBACK_STATUS_CONNECTING_TO_SERVER:
			LogText("\t[ WINHTTP_CALLBACK_STATUS_CONNECTING_TO_SERVER ]");
			break;
		case WINHTTP_CALLBACK_STATUS_CONNECTED_TO_SERVER:
			LogText("\t[ WINHTTP_CALLBACK_STATUS_CONNECTED_TO_SERVER ]");
			break;
		case WINHTTP_CALLBACK_STATUS_SENDING_REQUEST:	
			LogText("\t[ WINHTTP_CALLBACK_STATUS_SENDING_REQUEST ]");
			break;
		case WINHTTP_CALLBACK_STATUS_REQUEST_SENT:	
			LogText("\t[ WINHTTP_CALLBACK_STATUS_REQUEST_SENT ]");
			break;
		case WINHTTP_CALLBACK_STATUS_RECEIVING_RESPONSE:
			LogText("\t[ WINHTTP_CALLBACK_STATUS_RECEIVING_RESPONSE ]");
			break;
		case WINHTTP_CALLBACK_STATUS_RESPONSE_RECEIVED:	
			LogText("\t[ WINHTTP_CALLBACK_STATUS_RESPONSE_RECEIVED ]");
			break;
		case WINHTTP_CALLBACK_STATUS_CLOSING_CONNECTION:
			LogText("\t[ WINHTTP_CALLBACK_STATUS_CLOSING_CONNECTION ]");
			break;
		case WINHTTP_CALLBACK_STATUS_CONNECTION_CLOSED:	
			LogText("\t[ WINHTTP_CALLBACK_STATUS_CONNECTION_CLOSED ]");
			break;
		case WINHTTP_CALLBACK_STATUS_HANDLE_CREATED:
			LogText("\t[ WINHTTP_CALLBACK_STATUS_HANDLE_CREATED ]");
			break;
		case WINHTTP_CALLBACK_STATUS_HANDLE_CLOSING:
			LogText("\t[ WINHTTP_CALLBACK_STATUS_HANDLE_CLOSING ]");
			break;
		case WINHTTP_CALLBACK_STATUS_DETECTING_PROXY:
			LogText("\t[ WINHTTP_CALLBACK_STATUS_DETECTING_PROXY ]");
			break;
		case WINHTTP_CALLBACK_STATUS_REDIRECT:
			LogText("\t[ WINHTTP_CALLBACK_STATUS_REDIRECT ]");
			break;
		case WINHTTP_CALLBACK_STATUS_INTERMEDIATE_RESPONSE:
			LogText("\t[ WINHTTP_CALLBACK_STATUS_INTERMEDIATE_RESPONSE ]");
			break;
		case WINHTTP_CALLBACK_STATUS_REQUEST_COMPLETE:
			LogText("\t[ WINHTTP_CALLBACK_STATUS_REQUEST_COMPLETE ]");
			break;
		default:
			LogText("\t[ INVALID status callack %u ]", dwInternetStatus);
			break;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\stress\stressapps\core\stressmain.cpp ===
//////////////////////////////////////////////////////////////////////
// File:  stressMain.cpp
//
// Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
// Purpose:
//		This is an empty template for WinHttp stressScheduler stress apps.
//		The stress test lives in WinHttp_StressTest() and will be called
//		repeatedly in the main function.
//
//		This process will inherit a named event handle from 
//		stressScheduler in the form: "ExitProcessEvent" + <PID of this process>.
//		When the stressScheduler sets the object state to signaled, then
//		the stress test application must exit immediately.
//
//		If this app is running without the stressScheduler, use the
//		"/s" switch to run the standalone mode. The app will exit when the user
//		sends a break message (CTRL-C).
//
//		This stress test will continue to run if:
//
//			When not using any switches:
//			- The "ExitProcessEvent" object inherited from stressScheduler is in the un-signaled state
//			- WinHttp_StressTest() returns true
//
//			When using the "/s" standalone switch:
//			- WinHttp_StressTest() returns true
//
// History:
//	03/30/01	DennisCh	Created
//
//////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////
// Includes
//////////////////////////////////////////////////////////////////////

// Project headers
#include "stressMain.h"


//////////////////////////////////////////////////////////////////////
// Globals and statics
//////////////////////////////////////////////////////////////////////

// ****************************
// ** The name of the stress test and your stress test function
// ** should be declared in a seperate file.
extern	LPSTR	g_szStressTestName;
extern	BOOL	WinHttp_StressTest();

// ****************************
// ** hande to the name exit event object inherited from the stressScheduler
HANDLE	g_hExitEvent		= NULL;

// ****************************
// ** FALSE = run with stressScheduler, TRUE = run without stressScheduler
BOOL	g_bStandAloneMode	= FALSE;


////////////////////////////////////////////////////////////
// Function:  LogText(DWORD, LPCSTR)
//
// Purpose:
//	Prints text.
//
////////////////////////////////////////////////////////////
VOID
LogText(
	LPCSTR	szLogText,
	...
)
{
    CHAR	szBuffer[1024] = {0};
    va_list	vaList;

	if (!szLogText)
		return;

    va_start( vaList, szLogText );
    _vsnprintf( szBuffer, sizeof(szBuffer), szLogText, vaList );

    printf("%s\n", szBuffer);

    va_end(vaList);
}


////////////////////////////////////////////////////////////
// Function:  GetExitEventHandle()
//
// Purpose:
//	This opens a named event object inherited from the stressScheduler.
//	The object is in the form: "ExitProcessEvent" + <PID of current process>
//	By default this is in the unsignaled state. When the stressScheduler
//	sets it to signaled, then it's time for the stress App to exit.
//
////////////////////////////////////////////////////////////
HANDLE
GetExitEventHandle()
{
	CHAR	szPID[32];
	CHAR	szExitProcessName[sizeof(EXIT_PROCESS_EVENT_NAME) + sizeof(szPID)];
	HANDLE	hExitEvent			= NULL;

	// if user used the "/S" switch, we run without the stressScheduler and exit when user
	// tells us to instead. No need to get inherited event object from stressScheduler
	if (g_bStandAloneMode)
		return NULL;

	// wait for the stressScheduler to create the event object before trying to obtain it.
	Sleep(4000);

	// Get the processID string
	_itoa(_getpid(), szPID, 10);

	// build ExitProcess event object name
	ZeroMemory(szExitProcessName, sizeof(szExitProcessName));
	strcpy(szExitProcessName, EXIT_PROCESS_EVENT_NAME);
	strcat(szExitProcessName, szPID);

	LogText("\n[ Opening inherited named event object \"%s\". ]", szExitProcessName);

	hExitEvent = OpenEvent(EVENT_ALL_ACCESS, FALSE, szExitProcessName);

	if (!hExitEvent)
		LogText("[ ERROR: OpenEvent() failed to open object \"%s\". GetLastError() = %u ]\n", szExitProcessName, GetLastError());
	else
		LogText("[ OpenEvent() opened object \"%s\". ] \n", szExitProcessName);

	return hExitEvent;
}


////////////////////////////////////////////////////////////
// Function:  IsTimeToExitStress()
//
// Purpose:
//	Returns TRUE if the exit event object is signaled or NULL. FALSE if not.
//	The object is in the form: "ExitProcessEvent" + <PID of current process>
//	By default this is in the unsignaled state. When the stressScheduler
//	sets it to signaled, then it's time for the stress App to exit.
//
////////////////////////////////////////////////////////////
BOOL
IsTimeToExitStress()
{
	BOOL bResult = FALSE;

	// if user used the "/S" switch, we run without the stressScheduler and exit when user
	// tells us to instead.
	if (g_bStandAloneMode)
		return FALSE;

	if (!g_hExitEvent)
	{
		bResult = TRUE;
		goto Exit;
	}

	if (WAIT_OBJECT_0 == WaitForSingleObject(g_hExitEvent, 0))
		bResult = TRUE;

Exit:
	return bResult;
}


////////////////////////////////////////////////////////////
// Function:  main(INT, LPSTR)
//
// Purpose:
//	Program entry point.
//
////////////////////////////////////////////////////////////
INT
__cdecl
main(
	INT		argc,
	LPSTR	argv[]
)
{
	DWORD	dwIndex		= 0;

	// **************************
	// **************************
	// ** Parse command line arguments
	// **
    if (argc >= 2)
    {
		// print out options
		if (0 == StrCmpI(argv[1], "/?") || 0 == StrCmpI(argv[1], "-?"))
		{
	        LogText("USAGE: '/S' to run in standalone mode with the stressScheduler.\n\n");
		    goto Exit;
		}

		// run in standalone mode without stressScheduler
		if (0 == StrCmpI(argv[1], "/S") || 0 == StrCmpI(argv[1], "-S"))
		{
			LogText("[ Running in standalone mode. \"/S\" switch used. ]\n\n");
			g_bStandAloneMode = TRUE;
		}
    }


	// **************************
	// **************************
	// ** open the exit event object inherited from WinHttpStressScheduler
	// **
	g_hExitEvent	= GetExitEventHandle();
	if (!g_bStandAloneMode && !g_hExitEvent)
		goto Exit;


	// **************************
	// **************************
	// ** run the stress test until stressScheduler tells us to exit or the stress app does
	// **
	while (!IsTimeToExitStress() && WinHttp_StressTest())
		LogText("[ Running stressExe \"%s\" iteration #%u ]\n", g_szStressTestName, ++dwIndex);

Exit:
	if (g_hExitEvent)
		CloseHandle(g_hExitEvent);

	LogText("[ Exiting test case \"%s\" ]", g_szStressTestName);

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\stress\stressapps\core\stressmain.h ===
//////////////////////////////////////////////////////////////////////
// File:  stressMain.h
//
// Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
// Purpose:
//		This is an empty template for WinHttp stressScheduler stress apps.
//		The stress test lives in WinHttp_StressTest() and will be called
//		repeatedly in the main function.
//
// History:
//	03/30/01	DennisCh	Created
//
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
// Constants
//////////////////////////////////////////////////////////////////////

#define	EXIT_PROCESS_EVENT_NAME	"ExitProcessEvent"
#define WIN32_LEAN_AND_MEAN 1


//////////////////////////////////////////////////////////////////////
// Includes
//////////////////////////////////////////////////////////////////////

// Win32 headers
#include <windows.h>
#include <winhttp.h>
#include <shlwapi.h>
#include <stdlib.h>
#include <stdio.h>
#include <process.h>


//////////////////////////////////////////////////////////////////////
// Globals
//////////////////////////////////////////////////////////////////////
extern BOOL	IsTimeToExitStress();
extern VOID	LogText(LPCSTR,	...);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\stress\stressscheduler\res\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//
#define IDI_MAIN_ICON                   101
#define IDR_POPUPMENU                   107
#define IDM_BEGIN_STRESS                40007
#define IDM_END_STRESS                  40008
#define IDM_EXIT                        40009
#define IDM_OPENSTRESSADMIN             40012
#define IDM_WINHTTP_HOME                40014

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        120
#define _APS_NEXT_COMMAND_VALUE         40015
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\stress\stressscheduler\src\memstats.h ===
///////////////////////////////////////////////////////////////////////////
// File:  MemStats.h
//
// Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
// Purpose:
//	MemStats.h: Helper functions that get's the system memory info.
//	Borrowed from EricI's memstats app.
//
// History:
//	03/21/01	DennisCh	Created
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_MEMSTATS_H__D91043CB_5CB3_47C9_944F_B9FAA9BD26C4__INCLUDED_)
#define AFX_MEMSTATS_H__D91043CB_5CB3_47C9_944F_B9FAA9BD26C4__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


//////////////////////////////////////////////////////////////////////
// Includes
//////////////////////////////////////////////////////////////////////

#define UNICODE
#define _UNICODE

//
// WIN32 headers
//
#include <windows.h>
#include <pdh.h>
#include <shlwapi.h>

//
// Project headers
//
#include "WinHttpStressScheduler.h"
#include "ServerCommands.h"


//////////////////////////////////////////////////////////////////////
// Constants
//////////////////////////////////////////////////////////////////////


// struct for process memory stats
#define PROCCOUNTERS    4
struct PROC_CNTRS {
	ULONG lPID;
	ULONG lPrivBytes;
	ULONG lHandles;
	ULONG lThreads;
};

// struct for system wide memory stats
#define MEMCOUNTERS     9
struct MEM_CNTRS {
    ULONG lCommittedBytes;
    ULONG lCommitLimit;
    ULONG lSystemCodeTotalBytes;
    ULONG lSystemDriverTotalBytes;
    ULONG lPoolNonpagedBytes;
    ULONG lPoolPagedBytes;
    ULONG lAvailableBytes;
    ULONG lCacheBytes;
    ULONG lFreeSystemPageTableEntries;
};


BOOL MemStats__SendSystemMemoryLog(LPSTR, DWORD, DWORD);


#endif // !defined(AFX_MEMSTATS_H__D91043CB_5CB3_47C9_944F_B9FAA9BD26C4__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\stress\stressapps\sync-http-get-random\stresstesttemplate.cpp ===
//////////////////////////////////////////////////////////////////////
// File:  stressTest.cpp
//
// Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
// Purpose:
//		Synchronous HTTP GET to http://nithins_bld/stability/random/default.asp
//		that redirects to a random internet URL.
//
// History:
//	04/06/01	DennisCh	Created
//
//////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////
// Includes
//////////////////////////////////////////////////////////////////////
#include "stressMain.h"


//////////////////////////////////////////////////////////////////////
// Globals and constants
//////////////////////////////////////////////////////////////////////

// ************************************
// ************************************
// ** Fill in your test case name below
// ** 
LPSTR	g_szStressTestName = "Synchronous HTTP GET to http://nithins_bld/stability/random/default.asp that redirects to a random internet URL.";


// Foward function definitions
VOID CALLBACK MyStatusCallback(
    HINTERNET	hInternet,
    DWORD		dwContext,
    DWORD		dwInternetStatus,
    LPVOID		lpvStatusInformation,
    DWORD		dwStatusInformationLength
);

DWORD g_dwContext = 0;
////////////////////////////////////////////////////////////
// Function:  WinHttp_StressTest()
//
// Purpose:
//	The stress test function. Insert your test code here.
//	Returning TRUE will cause main() to call this function again.
//	Otherwise, returning FALSE will cause the app to exit.
//
//	If you plan to loop within this function, be sure to 
//	use IsTimeToExitStress() as one of your exit conditions.
//
//	This must be done because the stressScheduler will notify
//	a this stress app when to exit based on the state of the
//	inherited event object that IsTimeToExitStress() checks for.
//	IsTimeToExitStress() will return TRUE when it's time to exit.
//
////////////////////////////////////////////////////////////
BOOL
WinHttp_StressTest()
{
	BOOL		bContinueStress = TRUE;
	HINTERNET	hOpen			= NULL;
	HINTERNET	hConnect		= NULL;
	HINTERNET	hRequest		= NULL;


	// ***********************
	// ** WinHttpOpen
	hOpen = WinHttpOpen(
		L"StressTest",
		WINHTTP_ACCESS_TYPE_NAMED_PROXY,
		L"itgproxy",
		L"<local>",
		0);

	if (!hOpen)
	{
		LogText("WinHttpOpen failed with error %u.", GetLastError());
		goto Exit;
	}


	// ***********************
	// ** WinHttpConnect
	hConnect = WinHttpConnect(
		hOpen,
		L"nithins_bld",
		INTERNET_DEFAULT_HTTP_PORT,
		0);

	if (!hConnect)
	{
		LogText("WinHttpConnect failed with error %u.", GetLastError());
		goto Exit;
	}
		

	// ***********************
	// ** WinHttpOpenRequest
	hRequest = WinHttpOpenRequest(
		hConnect,
		L"GET",
		L"/stability/random/default.asp",
		NULL,
		NULL,
		NULL,
		0);


	if (!hRequest)
	{
		LogText("WinHttpOpenRequest failed with error %u.", GetLastError());
		goto Exit;
	}


	DWORD dwContext, dwDataAvailable;

	// ***********************
	// ** WinHttpSendRequest
	dwContext		= 0;
	dwDataAvailable	= 0;

	if (!WinHttpSendRequest(hRequest, NULL, 0, NULL, 0, 0, g_dwContext++))
		LogText("WinHttpSendRequest failed with error %u", GetLastError());

	// ***********************
	// ** WinHttpReceiveResponse
	if (!WinHttpReceiveResponse(hRequest, NULL))
		LogText("WinHttpReceiveResponse failed with error %u", GetLastError());

	// ***********************
	// ** WinHttpQueryDataAvailable
	if (!WinHttpQueryDataAvailable(hRequest, &dwDataAvailable))
		LogText("WinHttpQueryDataAvailable failed with error %u", GetLastError());


	WCHAR	szBuffer[1024];
	DWORD	dwStatus, dwBytesRead, dwBytesTotal, dwBufferLength, dwIndex;

	// ***********************
	// ** WinHttpQueryOption
	dwBufferLength	= sizeof(szBuffer)/sizeof(WCHAR) - 1;
	if (!WinHttpQueryOption(hRequest, WINHTTP_OPTION_URL, szBuffer, &dwBufferLength))
		LogText("WinHttpQueryOption failed with error %u", GetLastError());
	else
		wprintf(L"Redirected to: \"%s\"\n", szBuffer);


	// ***********************
	// ** WinHttpQueryHeaders
	dwBufferLength	= sizeof(dwStatus);
	dwStatus		= 0;
	dwIndex			= 0;
	if (!WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_STATUS_CODE | WINHTTP_QUERY_FLAG_NUMBER, NULL, &dwStatus, &dwBufferLength, &dwIndex))
		LogText("WinHttpQueryHeaders failed with error %u", GetLastError());
	else
		LogText("Status = %u", dwStatus);


	// ***********************
	// ** WinHttpReadData
	dwBytesRead		= 0;
	dwBytesTotal	= 0;
	dwBufferLength	= sizeof(szBuffer) - 1;

	while (WinHttpReadData(hRequest, szBuffer, dwBufferLength, &dwBytesRead) && (dwBytesRead != 0))
		dwBytesTotal += dwBytesRead;

	LogText("WinHttpReadData: Got total of %u bytes.\n", dwBytesTotal);

Exit:
	if (hRequest &&	!WinHttpCloseHandle(hRequest))
		LogText("WinHttpCloseHandle(hRequest) failed with error %u", GetLastError());

	if (hConnect && !WinHttpCloseHandle(hConnect))
		LogText("WinHttpCloseHandle(hConnect) failed with error %u", GetLastError());

	if (hOpen && !WinHttpCloseHandle(hOpen))
		LogText("WinHttpCloseHandle failed(hOpen) with error %u", GetLastError());

	return bContinueStress;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\stress\stressscheduler\inc\dbghelp.h ===
/*++ BUILD Version: 0001     Increment this if a change has global effects

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    dbghelp.h

Abstract:

    This module defines the prototypes and constants required for the image
    help routines.

    Contains debugging support routines that are redistributable.

Revision History:

--*/

#ifndef _DBGHELP_
#define _DBGHELP_

#if _MSC_VER > 1020
#pragma once
#endif


#ifdef _WIN64
#ifndef _IMAGEHLP64
#define _IMAGEHLP64
#endif
#endif


#ifdef __cplusplus
extern "C" {
#endif

#ifdef _IMAGEHLP_SOURCE_
#define IMAGEAPI __stdcall
#else
#define IMAGEAPI DECLSPEC_IMPORT __stdcall
#endif

#define IMAGE_SEPARATION (64*1024)

typedef struct _LOADED_IMAGE {
    PSTR                  ModuleName;
    HANDLE                hFile;
    PUCHAR                MappedAddress;
#ifdef _IMAGEHLP64
    PIMAGE_NT_HEADERS64   FileHeader;
#else
    PIMAGE_NT_HEADERS32   FileHeader;
#endif
    PIMAGE_SECTION_HEADER LastRvaSection;
    ULONG                 NumberOfSections;
    PIMAGE_SECTION_HEADER Sections;
    ULONG                 Characteristics;
    BOOLEAN               fSystemImage;
    BOOLEAN               fDOSImage;
    LIST_ENTRY            Links;
    ULONG                 SizeOfImage;
} LOADED_IMAGE, *PLOADED_IMAGE;



HANDLE
IMAGEAPI
FindDebugInfoFile (
    PSTR FileName,
    PSTR SymbolPath,
    PSTR DebugFilePath
    );

typedef BOOL
(CALLBACK *PFIND_DEBUG_FILE_CALLBACK)(
    HANDLE FileHandle,
    PSTR FileName,
    PVOID CallerData
    );

HANDLE
IMAGEAPI
FindDebugInfoFileEx (
    PSTR FileName,
    PSTR SymbolPath,
    PSTR DebugFilePath,
    PFIND_DEBUG_FILE_CALLBACK Callback,
    PVOID CallerData
    );

typedef BOOL
(CALLBACK *PFINDFILEINPATHCALLBACK)(
    PSTR  filename,
    PVOID context
    );

BOOL
IMAGEAPI
SymFindFileInPath(
    HANDLE hprocess,
    LPSTR  SearchPath,
    LPSTR  FileName,
    PVOID  id,
    DWORD  two,
    DWORD  three,
    DWORD  flags,
    LPSTR  FilePath,
    PFINDFILEINPATHCALLBACK callback,
    PVOID  context
    );

// FindFileInPath exists only for backwards compatibility
// with a pre-release version documented in an MSDN release.
// You should use SymFindFileInPath if you want to maintain
// future compatibility.

BOOL
IMAGEAPI
FindFileInPath(
    HANDLE hprocess,
    LPSTR  SearchPath,
    LPSTR  FileName,
    PVOID  id,
    DWORD  two,
    DWORD  three,
    DWORD  flags,
    LPSTR  FilePath
    );

BOOL
IMAGEAPI
FindFileInSearchPath(
    HANDLE hprocess,
    LPSTR  SearchPath,
    LPSTR  FileName,
    DWORD  one,
    DWORD  two,
    DWORD  three,
    LPSTR  FilePath
    );

HANDLE
IMAGEAPI
FindExecutableImage(
    PSTR FileName,
    PSTR SymbolPath,
    PSTR ImageFilePath
    );

typedef BOOL
(CALLBACK *PFIND_EXE_FILE_CALLBACK)(
    HANDLE FileHandle,
    PSTR FileName,
    PVOID CallerData
    );

HANDLE
IMAGEAPI
FindExecutableImageEx(
    PSTR FileName,
    PSTR SymbolPath,
    PSTR ImageFilePath,
    PFIND_EXE_FILE_CALLBACK Callback,
    PVOID CallerData
    );

PIMAGE_NT_HEADERS
IMAGEAPI
ImageNtHeader (
    IN PVOID Base
    );

PVOID
IMAGEAPI
ImageDirectoryEntryToDataEx (
    IN PVOID Base,
    IN BOOLEAN MappedAsImage,
    IN USHORT DirectoryEntry,
    OUT PULONG Size,
    OUT PIMAGE_SECTION_HEADER *FoundHeader OPTIONAL
    );

PVOID
IMAGEAPI
ImageDirectoryEntryToData (
    IN PVOID Base,
    IN BOOLEAN MappedAsImage,
    IN USHORT DirectoryEntry,
    OUT PULONG Size
    );

PIMAGE_SECTION_HEADER
IMAGEAPI
ImageRvaToSection(
    IN PIMAGE_NT_HEADERS NtHeaders,
    IN PVOID Base,
    IN ULONG Rva
    );

PVOID
IMAGEAPI
ImageRvaToVa(
    IN PIMAGE_NT_HEADERS NtHeaders,
    IN PVOID Base,
    IN ULONG Rva,
    IN OUT PIMAGE_SECTION_HEADER *LastRvaSection
    );

// Symbol server exports

typedef BOOL (*PSYMBOLSERVERPROC)(LPCSTR, LPCSTR, PVOID, DWORD, DWORD, LPSTR);
typedef BOOL (*PSYMBOLSERVEROPENPROC)(VOID);
typedef BOOL (*PSYMBOLSERVERCLOSEPROC)(VOID);
typedef BOOL (*PSYMBOLSERVERSETOPTIONSPROC)(UINT_PTR, ULONG64);
typedef BOOL (CALLBACK *PSYMBOLSERVERCALLBACKPROC)(UINT_PTR action, ULONG64 data, ULONG64 context);
typedef UINT_PTR (*PSYMBOLSERVERGETOPTIONSPROC)();

#define SSRVOPT_CALLBACK  0x1
#define SSRVOPT_DWORD     0x2
#define SSRVOPT_DWORDPTR  0x4
#define SSRVOPT_GUIDPTR   0x8
#define SSRVOPT_RESET    ((ULONG_PTR)-1)

#define SSRVACTION_TRACE 1


#ifndef _WIN64
// This api won't be ported to Win64 - Fix your code.

typedef struct _IMAGE_DEBUG_INFORMATION {
    LIST_ENTRY List;
    DWORD ReservedSize;
    PVOID ReservedMappedBase;
    USHORT ReservedMachine;
    USHORT ReservedCharacteristics;
    DWORD ReservedCheckSum;
    DWORD ImageBase;
    DWORD SizeOfImage;

    DWORD ReservedNumberOfSections;
    PIMAGE_SECTION_HEADER ReservedSections;

    DWORD ReservedExportedNamesSize;
    PSTR ReservedExportedNames;

    DWORD ReservedNumberOfFunctionTableEntries;
    PIMAGE_FUNCTION_ENTRY ReservedFunctionTableEntries;
    DWORD ReservedLowestFunctionStartingAddress;
    DWORD ReservedHighestFunctionEndingAddress;

    DWORD ReservedNumberOfFpoTableEntries;
    PFPO_DATA ReservedFpoTableEntries;

    DWORD SizeOfCoffSymbols;
    PIMAGE_COFF_SYMBOLS_HEADER CoffSymbols;

    DWORD ReservedSizeOfCodeViewSymbols;
    PVOID ReservedCodeViewSymbols;

    PSTR ImageFilePath;
    PSTR ImageFileName;
    PSTR ReservedDebugFilePath;

    DWORD ReservedTimeDateStamp;

    BOOL  ReservedRomImage;
    PIMAGE_DEBUG_DIRECTORY ReservedDebugDirectory;
    DWORD ReservedNumberOfDebugDirectories;

    DWORD ReservedOriginalFunctionTableBaseAddress;

    DWORD Reserved[ 2 ];

} IMAGE_DEBUG_INFORMATION, *PIMAGE_DEBUG_INFORMATION;


PIMAGE_DEBUG_INFORMATION
IMAGEAPI
MapDebugInformation(
    HANDLE FileHandle,
    PSTR FileName,
    PSTR SymbolPath,
    DWORD ImageBase
    );

BOOL
IMAGEAPI
UnmapDebugInformation(
    PIMAGE_DEBUG_INFORMATION DebugInfo
    );

#endif

BOOL
IMAGEAPI
SearchTreeForFile(
    PSTR RootPath,
    PSTR InputPathName,
    PSTR OutputPathBuffer
    );

BOOL
IMAGEAPI
MakeSureDirectoryPathExists(
    PCSTR DirPath
    );

//
// UnDecorateSymbolName Flags
//

#define UNDNAME_COMPLETE                 (0x0000)  // Enable full undecoration
#define UNDNAME_NO_LEADING_UNDERSCORES   (0x0001)  // Remove leading underscores from MS extended keywords
#define UNDNAME_NO_MS_KEYWORDS           (0x0002)  // Disable expansion of MS extended keywords
#define UNDNAME_NO_FUNCTION_RETURNS      (0x0004)  // Disable expansion of return type for primary declaration
#define UNDNAME_NO_ALLOCATION_MODEL      (0x0008)  // Disable expansion of the declaration model
#define UNDNAME_NO_ALLOCATION_LANGUAGE   (0x0010)  // Disable expansion of the declaration language specifier
#define UNDNAME_NO_MS_THISTYPE           (0x0020)  // NYI Disable expansion of MS keywords on the 'this' type for primary declaration
#define UNDNAME_NO_CV_THISTYPE           (0x0040)  // NYI Disable expansion of CV modifiers on the 'this' type for primary declaration
#define UNDNAME_NO_THISTYPE              (0x0060)  // Disable all modifiers on the 'this' type
#define UNDNAME_NO_ACCESS_SPECIFIERS     (0x0080)  // Disable expansion of access specifiers for members
#define UNDNAME_NO_THROW_SIGNATURES      (0x0100)  // Disable expansion of 'throw-signatures' for functions and pointers to functions
#define UNDNAME_NO_MEMBER_TYPE           (0x0200)  // Disable expansion of 'static' or 'virtual'ness of members
#define UNDNAME_NO_RETURN_UDT_MODEL      (0x0400)  // Disable expansion of MS model for UDT returns
#define UNDNAME_32_BIT_DECODE            (0x0800)  // Undecorate 32-bit decorated names
#define UNDNAME_NAME_ONLY                (0x1000)  // Crack only the name for primary declaration;
                                                                                                   //  return just [scope::]name.  Does expand template params
#define UNDNAME_NO_ARGUMENTS             (0x2000)  // Don't undecorate arguments to function
#define UNDNAME_NO_SPECIAL_SYMS          (0x4000)  // Don't undecorate special names (v-table, vcall, vector xxx, metatype, etc)

DWORD
IMAGEAPI
WINAPI
UnDecorateSymbolName(
    PCSTR   DecoratedName,         // Name to undecorate
    PSTR    UnDecoratedName,       // If NULL, it will be allocated
    DWORD    UndecoratedLength,     // The maximym length
    DWORD    Flags                  // See above.
    );

//
// StackWalking API
//

typedef enum {
    AddrMode1616,
    AddrMode1632,
    AddrModeReal,
    AddrModeFlat
} ADDRESS_MODE;

typedef struct _tagADDRESS64 {
    DWORD64       Offset;
    WORD          Segment;
    ADDRESS_MODE  Mode;
} ADDRESS64, *LPADDRESS64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define ADDRESS ADDRESS64
#define LPADDRESS LPADDRESS64
#else
typedef struct _tagADDRESS {
    DWORD         Offset;
    WORD          Segment;
    ADDRESS_MODE  Mode;
} ADDRESS, *LPADDRESS;

__inline
void
Address32To64(
    LPADDRESS a32,
    LPADDRESS64 a64
    )
{
    a64->Offset = (ULONG64)(LONG64)(LONG)a32->Offset;
    a64->Segment = a32->Segment;
    a64->Mode = a32->Mode;
}

__inline
void
Address64To32(
    LPADDRESS64 a64,
    LPADDRESS a32
    )
{
    a32->Offset = (ULONG)a64->Offset;
    a32->Segment = a64->Segment;
    a32->Mode = a64->Mode;
}
#endif

//
// This structure is included in the STACKFRAME structure,
// and is used to trace through usermode callbacks in a thread's
// kernel stack.  The values must be copied by the kernel debugger
// from the DBGKD_GET_VERSION and WAIT_STATE_CHANGE packets.
//

//
// New KDHELP structure for 64 bit system support.
// This structure is preferred in new code.
//
typedef struct _KDHELP64 {

    //
    // address of kernel thread object, as provided in the
    // WAIT_STATE_CHANGE packet.
    //
    DWORD64   Thread;

    //
    // offset in thread object to pointer to the current callback frame
    // in kernel stack.
    //
    DWORD   ThCallbackStack;

    //
    // offset in thread object to pointer to the current callback backing
    // store frame in kernel stack.
    //
    DWORD   ThCallbackBStore;

    //
    // offsets to values in frame:
    //
    // address of next callback frame
    DWORD   NextCallback;

    // address of saved frame pointer (if applicable)
    DWORD   FramePointer;


    //
    // Address of the kernel function that calls out to user mode
    //
    DWORD64   KiCallUserMode;

    //
    // Address of the user mode dispatcher function
    //
    DWORD64   KeUserCallbackDispatcher;

    //
    // Lowest kernel mode address
    //
    DWORD64   SystemRangeStart;

    DWORD64  Reserved[8];

} KDHELP64, *PKDHELP64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define KDHELP KDHELP64
#define PKDHELP PKDHELP64
#else
typedef struct _KDHELP {

    //
    // address of kernel thread object, as provided in the
    // WAIT_STATE_CHANGE packet.
    //
    DWORD   Thread;

    //
    // offset in thread object to pointer to the current callback frame
    // in kernel stack.
    //
    DWORD   ThCallbackStack;

    //
    // offsets to values in frame:
    //
    // address of next callback frame
    DWORD   NextCallback;

    // address of saved frame pointer (if applicable)
    DWORD   FramePointer;

    //
    // Address of the kernel function that calls out to user mode
    //
    DWORD   KiCallUserMode;

    //
    // Address of the user mode dispatcher function
    //
    DWORD   KeUserCallbackDispatcher;

    //
    // Lowest kernel mode address
    //
    DWORD   SystemRangeStart;

    //
    // offset in thread object to pointer to the current callback backing
    // store frame in kernel stack.
    //
    DWORD   ThCallbackBStore;

    DWORD  Reserved[8];

} KDHELP, *PKDHELP;

__inline
void
KdHelp32To64(
    PKDHELP p32,
    PKDHELP64 p64
    )
{
    p64->Thread = p32->Thread;
    p64->ThCallbackStack = p32->ThCallbackStack;
    p64->NextCallback = p32->NextCallback;
    p64->FramePointer = p32->FramePointer;
    p64->KiCallUserMode = p32->KiCallUserMode;
    p64->KeUserCallbackDispatcher = p32->KeUserCallbackDispatcher;
    p64->SystemRangeStart = p32->SystemRangeStart;
}
#endif

typedef struct _tagSTACKFRAME64 {
    ADDRESS64   AddrPC;               // program counter
    ADDRESS64   AddrReturn;           // return address
    ADDRESS64   AddrFrame;            // frame pointer
    ADDRESS64   AddrStack;            // stack pointer
    ADDRESS64   AddrBStore;           // backing store pointer
    PVOID       FuncTableEntry;       // pointer to pdata/fpo or NULL
    DWORD64     Params[4];            // possible arguments to the function
    BOOL        Far;                  // WOW far call
    BOOL        Virtual;              // is this a virtual frame?
    DWORD64     Reserved[3];
    KDHELP64    KdHelp;
} STACKFRAME64, *LPSTACKFRAME64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define STACKFRAME STACKFRAME64
#define LPSTACKFRAME LPSTACKFRAME64
#else
typedef struct _tagSTACKFRAME {
    ADDRESS     AddrPC;               // program counter
    ADDRESS     AddrReturn;           // return address
    ADDRESS     AddrFrame;            // frame pointer
    ADDRESS     AddrStack;            // stack pointer
    PVOID       FuncTableEntry;       // pointer to pdata/fpo or NULL
    DWORD       Params[4];            // possible arguments to the function
    BOOL        Far;                  // WOW far call
    BOOL        Virtual;              // is this a virtual frame?
    DWORD       Reserved[3];
    KDHELP      KdHelp;
    ADDRESS     AddrBStore;           // backing store pointer
} STACKFRAME, *LPSTACKFRAME;
#endif


typedef
BOOL
(__stdcall *PREAD_PROCESS_MEMORY_ROUTINE64)(
    HANDLE      hProcess,
    DWORD64     qwBaseAddress,
    PVOID       lpBuffer,
    DWORD       nSize,
    LPDWORD     lpNumberOfBytesRead
    );

typedef
PVOID
(__stdcall *PFUNCTION_TABLE_ACCESS_ROUTINE64)(
    HANDLE  hProcess,
    DWORD64 AddrBase
    );

typedef
DWORD64
(__stdcall *PGET_MODULE_BASE_ROUTINE64)(
    HANDLE  hProcess,
    DWORD64 Address
    );

typedef
DWORD64
(__stdcall *PTRANSLATE_ADDRESS_ROUTINE64)(
    HANDLE    hProcess,
    HANDLE    hThread,
    LPADDRESS64 lpaddr
    );

BOOL
IMAGEAPI
StackWalk64(
    DWORD                             MachineType,
    HANDLE                            hProcess,
    HANDLE                            hThread,
    LPSTACKFRAME64                    StackFrame,
    PVOID                             ContextRecord,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemoryRoutine,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccessRoutine,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBaseRoutine,
    PTRANSLATE_ADDRESS_ROUTINE64      TranslateAddress
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)

#define PREAD_PROCESS_MEMORY_ROUTINE PREAD_PROCESS_MEMORY_ROUTINE64
#define PFUNCTION_TABLE_ACCESS_ROUTINE PFUNCTION_TABLE_ACCESS_ROUTINE64
#define PGET_MODULE_BASE_ROUTINE PGET_MODULE_BASE_ROUTINE64
#define PTRANSLATE_ADDRESS_ROUTINE PTRANSLATE_ADDRESS_ROUTINE64

#define StackWalk StackWalk64

#else

typedef
BOOL
(__stdcall *PREAD_PROCESS_MEMORY_ROUTINE)(
    HANDLE  hProcess,
    DWORD   lpBaseAddress,
    PVOID   lpBuffer,
    DWORD   nSize,
    PDWORD  lpNumberOfBytesRead
    );

typedef
PVOID
(__stdcall *PFUNCTION_TABLE_ACCESS_ROUTINE)(
    HANDLE  hProcess,
    DWORD   AddrBase
    );

typedef
DWORD
(__stdcall *PGET_MODULE_BASE_ROUTINE)(
    HANDLE  hProcess,
    DWORD   Address
    );

typedef
DWORD
(__stdcall *PTRANSLATE_ADDRESS_ROUTINE)(
    HANDLE    hProcess,
    HANDLE    hThread,
    LPADDRESS lpaddr
    );

BOOL
IMAGEAPI
StackWalk(
    DWORD                             MachineType,
    HANDLE                            hProcess,
    HANDLE                            hThread,
    LPSTACKFRAME                      StackFrame,
    PVOID                             ContextRecord,
    PREAD_PROCESS_MEMORY_ROUTINE      ReadMemoryRoutine,
    PFUNCTION_TABLE_ACCESS_ROUTINE    FunctionTableAccessRoutine,
    PGET_MODULE_BASE_ROUTINE          GetModuleBaseRoutine,
    PTRANSLATE_ADDRESS_ROUTINE        TranslateAddress
    );

#endif


#define API_VERSION_NUMBER 9

typedef struct API_VERSION {
    USHORT  MajorVersion;
    USHORT  MinorVersion;
    USHORT  Revision;
    USHORT  Reserved;
} API_VERSION, *LPAPI_VERSION;

LPAPI_VERSION
IMAGEAPI
ImagehlpApiVersion(
    VOID
    );

LPAPI_VERSION
IMAGEAPI
ImagehlpApiVersionEx(
    LPAPI_VERSION AppVersion
    );

DWORD
IMAGEAPI
GetTimestampForLoadedLibrary(
    HMODULE Module
    );

//
// typedefs for function pointers
//
typedef BOOL
(CALLBACK *PSYM_ENUMMODULES_CALLBACK64)(
    PSTR ModuleName,
    DWORD64 BaseOfDll,
    PVOID UserContext
    );

typedef BOOL
(CALLBACK *PSYM_ENUMSYMBOLS_CALLBACK64)(
    PSTR SymbolName,
    DWORD64 SymbolAddress,
    ULONG SymbolSize,
    PVOID UserContext
    );

typedef BOOL
(CALLBACK *PSYM_ENUMSYMBOLS_CALLBACK64W)(
    PWSTR SymbolName,
    DWORD64 SymbolAddress,
    ULONG SymbolSize,
    PVOID UserContext
    );

typedef BOOL
(CALLBACK *PENUMLOADED_MODULES_CALLBACK64)(
    PSTR ModuleName,
    DWORD64 ModuleBase,
    ULONG ModuleSize,
    PVOID UserContext
    );

typedef BOOL
(CALLBACK *PSYMBOL_REGISTERED_CALLBACK64)(
    HANDLE  hProcess,
    ULONG   ActionCode,
    ULONG64 CallbackData,
    ULONG64 UserContext
    );

typedef
PVOID
(CALLBACK *PSYMBOL_FUNCENTRY_CALLBACK)(
    HANDLE  hProcess,
    DWORD   AddrBase,
    PVOID   UserContext
    );

typedef
PVOID
(CALLBACK *PSYMBOL_FUNCENTRY_CALLBACK64)(
    HANDLE  hProcess,
    ULONG64 AddrBase,
    ULONG64 UserContext
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)

#define PSYM_ENUMMODULES_CALLBACK PSYM_ENUMMODULES_CALLBACK64
#define PSYM_ENUMSYMBOLS_CALLBACK PSYM_ENUMSYMBOLS_CALLBACK64
#define PSYM_ENUMSYMBOLS_CALLBACKW PSYM_ENUMSYMBOLS_CALLBACK64W
#define PENUMLOADED_MODULES_CALLBACK PENUMLOADED_MODULES_CALLBACK64
#define PSYMBOL_REGISTERED_CALLBACK PSYMBOL_REGISTERED_CALLBACK64
#define PSYMBOL_FUNCENTRY_CALLBACK PSYMBOL_FUNCENTRY_CALLBACK64

#else

typedef BOOL
(CALLBACK *PSYM_ENUMMODULES_CALLBACK)(
    PSTR  ModuleName,
    ULONG BaseOfDll,
    PVOID UserContext
    );

typedef BOOL
(CALLBACK *PSYM_ENUMSYMBOLS_CALLBACK)(
    PSTR  SymbolName,
    ULONG SymbolAddress,
    ULONG SymbolSize,
    PVOID UserContext
    );

typedef BOOL
(CALLBACK *PSYM_ENUMSYMBOLS_CALLBACKW)(
    PWSTR  SymbolName,
    ULONG SymbolAddress,
    ULONG SymbolSize,
    PVOID UserContext
    );

typedef BOOL
(CALLBACK *PENUMLOADED_MODULES_CALLBACK)(
    PSTR  ModuleName,
    ULONG ModuleBase,
    ULONG ModuleSize,
    PVOID UserContext
    );

typedef BOOL
(CALLBACK *PSYMBOL_REGISTERED_CALLBACK)(
    HANDLE  hProcess,
    ULONG   ActionCode,
    PVOID   CallbackData,
    PVOID   UserContext
    );

#endif


//
// symbol flags
//

#define SYMF_OMAP_GENERATED   0x00000001
#define SYMF_OMAP_MODIFIED    0x00000002
#ifndef _DBGHELP_USER_GENERATED_SYMBOLS_NOTSUPPORTED
#define SYMF_USER_GENERATED   0x00000004
#endif // !_DBGHELP_USER_GENERATED_SYMBOLS_NOTSUPPORTED
#define SYMF_REGISTER         0x00000008
#define SYMF_REGREL           0x00000010
#define SYMF_FRAMEREL         0x00000020
#define SYMF_PARAMETER        0x00000040
#define SYMF_LOCAL            0x00000080
//
// symbol type enumeration
//
typedef enum {
    SymNone = 0,
    SymCoff,
    SymCv,
    SymPdb,
    SymExport,
    SymDeferred,
    SymSym,       // .sym file
    SymDia,
    NumSymTypes
} SYM_TYPE;

//
// symbol data structure
//

typedef struct _IMAGEHLP_SYMBOL64 {
    DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_SYMBOL64)
    DWORD64                     Address;                // virtual address including dll base address
    DWORD                       Size;                   // estimated size of symbol, can be zero
    DWORD                       Flags;                  // info about the symbols, see the SYMF defines
    DWORD                       MaxNameLength;          // maximum size of symbol name in 'Name'
    CHAR                        Name[1];                // symbol name (null terminated string)
} IMAGEHLP_SYMBOL64, *PIMAGEHLP_SYMBOL64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define IMAGEHLP_SYMBOL IMAGEHLP_SYMBOL64
#define PIMAGEHLP_SYMBOL PIMAGEHLP_SYMBOL64
#else
typedef struct _IMAGEHLP_SYMBOL {
    DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_SYMBOL)
    DWORD                       Address;                // virtual address including dll base address
    DWORD                       Size;                   // estimated size of symbol, can be zero
    DWORD                       Flags;                  // info about the symbols, see the SYMF defines
    DWORD                       MaxNameLength;          // maximum size of symbol name in 'Name'
    CHAR                        Name[1];                // symbol name (null terminated string)
} IMAGEHLP_SYMBOL, *PIMAGEHLP_SYMBOL;
#endif

//
// module data structure
//

typedef struct _IMAGEHLP_MODULE64 {
    DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_MODULE64)
    DWORD64                     BaseOfImage;            // base load address of module
    DWORD                       ImageSize;              // virtual size of the loaded module
    DWORD                       TimeDateStamp;          // date/time stamp from pe header
    DWORD                       CheckSum;               // checksum from the pe header
    DWORD                       NumSyms;                // number of symbols in the symbol table
    SYM_TYPE                    SymType;                // type of symbols loaded
    CHAR                        ModuleName[32];         // module name
    CHAR                        ImageName[256];         // image name
    CHAR                        LoadedImageName[256];   // symbol file name
} IMAGEHLP_MODULE64, *PIMAGEHLP_MODULE64;

typedef struct _IMAGEHLP_MODULE64W {
    DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_MODULE64)
    DWORD64                     BaseOfImage;            // base load address of module
    DWORD                       ImageSize;              // virtual size of the loaded module
    DWORD                       TimeDateStamp;          // date/time stamp from pe header
    DWORD                       CheckSum;               // checksum from the pe header
    DWORD                       NumSyms;                // number of symbols in the symbol table
    SYM_TYPE                    SymType;                // type of symbols loaded
    WCHAR                       ModuleName[32];         // module name
    WCHAR                       ImageName[256];         // image name
    WCHAR                       LoadedImageName[256];   // symbol file name
} IMAGEHLP_MODULEW64, *PIMAGEHLP_MODULEW64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define IMAGEHLP_MODULE IMAGEHLP_MODULE64
#define PIMAGEHLP_MODULE PIMAGEHLP_MODULE64
#define IMAGEHLP_MODULEW IMAGEHLP_MODULEW64
#define PIMAGEHLP_MODULEW PIMAGEHLP_MODULEW64
#else
typedef struct _IMAGEHLP_MODULE {
    DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_MODULE)
    DWORD                       BaseOfImage;            // base load address of module
    DWORD                       ImageSize;              // virtual size of the loaded module
    DWORD                       TimeDateStamp;          // date/time stamp from pe header
    DWORD                       CheckSum;               // checksum from the pe header
    DWORD                       NumSyms;                // number of symbols in the symbol table
    SYM_TYPE                    SymType;                // type of symbols loaded
    CHAR                        ModuleName[32];         // module name
    CHAR                        ImageName[256];         // image name
    CHAR                        LoadedImageName[256];   // symbol file name
} IMAGEHLP_MODULE, *PIMAGEHLP_MODULE;

typedef struct _IMAGEHLP_MODULEW {
    DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_MODULE)
    DWORD                       BaseOfImage;            // base load address of module
    DWORD                       ImageSize;              // virtual size of the loaded module
    DWORD                       TimeDateStamp;          // date/time stamp from pe header
    DWORD                       CheckSum;               // checksum from the pe header
    DWORD                       NumSyms;                // number of symbols in the symbol table
    SYM_TYPE                    SymType;                // type of symbols loaded
    WCHAR                       ModuleName[32];         // module name
    WCHAR                       ImageName[256];         // image name
    WCHAR                       LoadedImageName[256];   // symbol file name
} IMAGEHLP_MODULEW, *PIMAGEHLP_MODULEW;
#endif

//
// source file line data structure
//

typedef struct _IMAGEHLP_LINE64 {
    DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_LINE64)
    PVOID                       Key;                    // internal
    DWORD                       LineNumber;             // line number in file
    PCHAR                       FileName;               // full filename
    DWORD64                     Address;                // first instruction of line
} IMAGEHLP_LINE64, *PIMAGEHLP_LINE64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define IMAGEHLP_LINE IMAGEHLP_LINE64
#define PIMAGEHLP_LINE PIMAGEHLP_LINE64
#else
typedef struct _IMAGEHLP_LINE {
    DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_LINE)
    PVOID                       Key;                    // internal
    DWORD                       LineNumber;             // line number in file
    PCHAR                       FileName;               // full filename
    DWORD                       Address;                // first instruction of line
} IMAGEHLP_LINE, *PIMAGEHLP_LINE;
#endif

//
// data structures used for registered symbol callbacks
//

#define CBA_DEFERRED_SYMBOL_LOAD_START          0x00000001
#define CBA_DEFERRED_SYMBOL_LOAD_COMPLETE       0x00000002
#define CBA_DEFERRED_SYMBOL_LOAD_FAILURE        0x00000003
#define CBA_SYMBOLS_UNLOADED                    0x00000004
#define CBA_DUPLICATE_SYMBOL                    0x00000005
#define CBA_READ_MEMORY                         0x00000006
#define CBA_DEFERRED_SYMBOL_LOAD_CANCEL         0x00000007
#define CBA_SET_OPTIONS                         0x00000008
#define CBA_DEBUG_INFO                          0x10000000

typedef struct _IMAGEHLP_CBA_READ_MEMORY {
    DWORD64   addr;                                     // address to read from
    PVOID     buf;                                      // buffer to read to
    DWORD     bytes;                                    // amount of bytes to read
    DWORD    *bytesread;                                // pointer to store amount of bytes read
} IMAGEHLP_CBA_READ_MEMORY, *PIMAGEHLP_CBA_READ_MEMORY;

typedef struct _IMAGEHLP_DEFERRED_SYMBOL_LOAD64 {
    DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_DEFERRED_SYMBOL_LOAD64)
    DWORD64                     BaseOfImage;            // base load address of module
    DWORD                       CheckSum;               // checksum from the pe header
    DWORD                       TimeDateStamp;          // date/time stamp from pe header
    CHAR                        FileName[MAX_PATH];     // symbols file or image name
    BOOLEAN                     Reparse;                // load failure reparse
} IMAGEHLP_DEFERRED_SYMBOL_LOAD64, *PIMAGEHLP_DEFERRED_SYMBOL_LOAD64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define IMAGEHLP_DEFERRED_SYMBOL_LOAD IMAGEHLP_DEFERRED_SYMBOL_LOAD64
#define PIMAGEHLP_DEFERRED_SYMBOL_LOAD PIMAGEHLP_DEFERRED_SYMBOL_LOAD64
#else
typedef struct _IMAGEHLP_DEFERRED_SYMBOL_LOAD {
    DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_DEFERRED_SYMBOL_LOAD)
    DWORD                       BaseOfImage;            // base load address of module
    DWORD                       CheckSum;               // checksum from the pe header
    DWORD                       TimeDateStamp;          // date/time stamp from pe header
    CHAR                        FileName[MAX_PATH];     // symbols file or image name
    BOOLEAN                     Reparse;                // load failure reparse
} IMAGEHLP_DEFERRED_SYMBOL_LOAD, *PIMAGEHLP_DEFERRED_SYMBOL_LOAD;
#endif

typedef struct _IMAGEHLP_DUPLICATE_SYMBOL64 {
    DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_DUPLICATE_SYMBOL64)
    DWORD                       NumberOfDups;           // number of duplicates in the Symbol array
    PIMAGEHLP_SYMBOL64          Symbol;                 // array of duplicate symbols
    DWORD                       SelectedSymbol;         // symbol selected (-1 to start)
} IMAGEHLP_DUPLICATE_SYMBOL64, *PIMAGEHLP_DUPLICATE_SYMBOL64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define IMAGEHLP_DUPLICATE_SYMBOL IMAGEHLP_DUPLICATE_SYMBOL64
#define PIMAGEHLP_DUPLICATE_SYMBOL PIMAGEHLP_DUPLICATE_SYMBOL64
#else
typedef struct _IMAGEHLP_DUPLICATE_SYMBOL {
    DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_DUPLICATE_SYMBOL)
    DWORD                       NumberOfDups;           // number of duplicates in the Symbol array
    PIMAGEHLP_SYMBOL            Symbol;                 // array of duplicate symbols
    DWORD                       SelectedSymbol;         // symbol selected (-1 to start)
} IMAGEHLP_DUPLICATE_SYMBOL, *PIMAGEHLP_DUPLICATE_SYMBOL;
#endif


//
// options that are set/returned by SymSetOptions() & SymGetOptions()
// these are used as a mask
//
#define SYMOPT_CASE_INSENSITIVE     0x00000001
#define SYMOPT_UNDNAME              0x00000002
#define SYMOPT_DEFERRED_LOADS       0x00000004
#define SYMOPT_NO_CPP               0x00000008
#define SYMOPT_LOAD_LINES           0x00000010
#define SYMOPT_OMAP_FIND_NEAREST    0x00000020
#define SYMOPT_LOAD_ANYTHING        0x00000040
#define SYMOPT_IGNORE_CVREC         0x00000080
#define SYMOPT_NO_UNQUALIFIED_LOADS 0x00000100
#define SYMOPT_FAIL_CRITICAL_ERRORS 0x00000200
#define SYMOPT_EXACT_SYMBOLS        0x00000400
#define SYMOPT_DEBUG                0x80000000


DWORD
IMAGEAPI
SymSetOptions(
    IN DWORD   SymOptions
    );

DWORD
IMAGEAPI
SymGetOptions(
    VOID
    );

BOOL
IMAGEAPI
SymCleanup(
    IN HANDLE hProcess
    );

BOOL
IMAGEAPI
SymEnumerateModules64(
    IN HANDLE                       hProcess,
    IN PSYM_ENUMMODULES_CALLBACK64  EnumModulesCallback,
    IN PVOID                        UserContext
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymEnumerateModules SymEnumerateModules64
#else
BOOL
IMAGEAPI
SymEnumerateModules(
    IN HANDLE                     hProcess,
    IN PSYM_ENUMMODULES_CALLBACK  EnumModulesCallback,
    IN PVOID                      UserContext
    );
#endif

BOOL
IMAGEAPI
SymEnumerateSymbols64(
    IN HANDLE                       hProcess,
    IN DWORD64                      BaseOfDll,
    IN PSYM_ENUMSYMBOLS_CALLBACK64  EnumSymbolsCallback,
    IN PVOID                        UserContext
    );

BOOL
IMAGEAPI
SymEnumerateSymbolsW64(
    IN HANDLE                       hProcess,
    IN DWORD64                      BaseOfDll,
    IN PSYM_ENUMSYMBOLS_CALLBACK64W EnumSymbolsCallback,
    IN PVOID                        UserContext
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymEnumerateSymbols SymEnumerateSymbols64
#define SymEnumerateSymbolsW SymEnumerateSymbolsW64
#else
BOOL
IMAGEAPI
SymEnumerateSymbols(
    IN HANDLE                     hProcess,
    IN DWORD                      BaseOfDll,
    IN PSYM_ENUMSYMBOLS_CALLBACK  EnumSymbolsCallback,
    IN PVOID                      UserContext
    );

BOOL
IMAGEAPI
SymEnumerateSymbolsW(
    IN HANDLE                       hProcess,
    IN DWORD                        BaseOfDll,
    IN PSYM_ENUMSYMBOLS_CALLBACKW   EnumSymbolsCallback,
    IN PVOID                        UserContext
    );
#endif

BOOL
IMAGEAPI
EnumerateLoadedModules64(
    IN HANDLE                           hProcess,
    IN PENUMLOADED_MODULES_CALLBACK64   EnumLoadedModulesCallback,
    IN PVOID                            UserContext
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define EnumerateLoadedModules EnumerateLoadedModules64
#else
BOOL
IMAGEAPI
EnumerateLoadedModules(
    IN HANDLE                         hProcess,
    IN PENUMLOADED_MODULES_CALLBACK   EnumLoadedModulesCallback,
    IN PVOID                          UserContext
    );
#endif

PVOID
IMAGEAPI
SymFunctionTableAccess64(
    HANDLE  hProcess,
    DWORD64 AddrBase
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymFunctionTableAccess SymFunctionTableAccess64
#else
PVOID
IMAGEAPI
SymFunctionTableAccess(
    HANDLE  hProcess,
    DWORD   AddrBase
    );
#endif

BOOL
IMAGEAPI
SymGetModuleInfo64(
    IN  HANDLE                  hProcess,
    IN  DWORD64                 qwAddr,
    OUT PIMAGEHLP_MODULE64      ModuleInfo
    );

BOOL
IMAGEAPI
SymGetModuleInfoW64(
    IN  HANDLE                  hProcess,
    IN  DWORD64                 qwAddr,
    OUT PIMAGEHLP_MODULEW64     ModuleInfo
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetModuleInfo   SymGetModuleInfo64
#define SymGetModuleInfoW  SymGetModuleInfoW64
#else
BOOL
IMAGEAPI
SymGetModuleInfo(
    IN  HANDLE              hProcess,
    IN  DWORD               dwAddr,
    OUT PIMAGEHLP_MODULE  ModuleInfo
    );

BOOL
IMAGEAPI
SymGetModuleInfoW(
    IN  HANDLE              hProcess,
    IN  DWORD               dwAddr,
    OUT PIMAGEHLP_MODULEW  ModuleInfo
    );
#endif

DWORD64
IMAGEAPI
SymGetModuleBase64(
    IN  HANDLE              hProcess,
    IN  DWORD64             qwAddr
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetModuleBase SymGetModuleBase64
#else
DWORD
IMAGEAPI
SymGetModuleBase(
    IN  HANDLE              hProcess,
    IN  DWORD               dwAddr
    );
#endif

BOOL
IMAGEAPI
SymGetSymFromAddr64(
    IN  HANDLE              hProcess,
    IN  DWORD64             qwAddr,
    OUT PDWORD64            pdwDisplacement,
    OUT PIMAGEHLP_SYMBOL64  Symbol
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetSymFromAddr SymGetSymFromAddr64
#else
BOOL
IMAGEAPI
SymGetSymFromAddr(
    IN  HANDLE            hProcess,
    IN  DWORD             dwAddr,
    OUT PDWORD            pdwDisplacement,
    OUT PIMAGEHLP_SYMBOL  Symbol
    );
#endif

BOOL
IMAGEAPI
SymGetSymFromName64(
    IN  HANDLE              hProcess,
    IN  PSTR                Name,
    OUT PIMAGEHLP_SYMBOL64  Symbol
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetSymFromName SymGetSymFromName64
#else
BOOL
IMAGEAPI
SymGetSymFromName(
    IN  HANDLE            hProcess,
    IN  PSTR              Name,
    OUT PIMAGEHLP_SYMBOL  Symbol
    );
#endif

BOOL
IMAGEAPI
SymGetSymNext64(
    IN     HANDLE              hProcess,
    IN OUT PIMAGEHLP_SYMBOL64  Symbol
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetSymNext SymGetSymNext64
#else
BOOL
IMAGEAPI
SymGetSymNext(
    IN     HANDLE            hProcess,
    IN OUT PIMAGEHLP_SYMBOL  Symbol
    );
#endif

BOOL
IMAGEAPI
SymGetSymPrev64(
    IN     HANDLE              hProcess,
    IN OUT PIMAGEHLP_SYMBOL64  Symbol
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetSymPrev SymGetSymPrev64
#else
BOOL
IMAGEAPI
SymGetSymPrev(
    IN     HANDLE            hProcess,
    IN OUT PIMAGEHLP_SYMBOL  Symbol
    );
#endif

BOOL
IMAGEAPI
SymGetLineFromAddr64(
    IN  HANDLE                  hProcess,
    IN  DWORD64                 qwAddr,
    OUT PDWORD                  pdwDisplacement,
    OUT PIMAGEHLP_LINE64        Line
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetLineFromAddr SymGetLineFromAddr64
#else
BOOL
IMAGEAPI
SymGetLineFromAddr(
    IN  HANDLE                hProcess,
    IN  DWORD                 dwAddr,
    OUT PDWORD                pdwDisplacement,
    OUT PIMAGEHLP_LINE        Line
    );
#endif

BOOL
IMAGEAPI
SymGetLineFromName64(
    IN     HANDLE               hProcess,
    IN     PSTR                 ModuleName,
    IN     PSTR                 FileName,
    IN     DWORD                dwLineNumber,
       OUT PLONG                plDisplacement,
    IN OUT PIMAGEHLP_LINE64     Line
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetLineFromName SymGetLineFromName64
#else
BOOL
IMAGEAPI
SymGetLineFromName(
    IN     HANDLE             hProcess,
    IN     PSTR               ModuleName,
    IN     PSTR               FileName,
    IN     DWORD              dwLineNumber,
       OUT PLONG              plDisplacement,
    IN OUT PIMAGEHLP_LINE     Line
    );
#endif

BOOL
IMAGEAPI
SymGetLineNext64(
    IN     HANDLE               hProcess,
    IN OUT PIMAGEHLP_LINE64     Line
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetLineNext SymGetLineNext64
#else
BOOL
IMAGEAPI
SymGetLineNext(
    IN     HANDLE             hProcess,
    IN OUT PIMAGEHLP_LINE     Line
    );
#endif

BOOL
IMAGEAPI
SymGetLinePrev64(
    IN     HANDLE               hProcess,
    IN OUT PIMAGEHLP_LINE64     Line
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetLinePrev SymGetLinePrev64
#else
BOOL
IMAGEAPI
SymGetLinePrev(
    IN     HANDLE             hProcess,
    IN OUT PIMAGEHLP_LINE     Line
    );
#endif

BOOL
IMAGEAPI
SymMatchFileName(
    IN  PSTR  FileName,
    IN  PSTR  Match,
    OUT PSTR *FileNameStop,
    OUT PSTR *MatchStop
    );

BOOL
IMAGEAPI
SymInitialize(
    IN HANDLE   hProcess,
    IN PSTR     UserSearchPath,
    IN BOOL     fInvadeProcess
    );

BOOL
IMAGEAPI
SymGetSearchPath(
    IN  HANDLE          hProcess,
    OUT PSTR            SearchPath,
    IN  DWORD           SearchPathLength
    );

BOOL
IMAGEAPI
SymSetSearchPath(
    IN HANDLE           hProcess,
    IN PSTR             SearchPath
    );

DWORD64
IMAGEAPI
SymLoadModule64(
    IN  HANDLE          hProcess,
    IN  HANDLE          hFile,
    IN  PSTR            ImageName,
    IN  PSTR            ModuleName,
    IN  DWORD64         BaseOfDll,
    IN  DWORD           SizeOfDll
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymLoadModule SymLoadModule64
#else
DWORD
IMAGEAPI
SymLoadModule(
    IN  HANDLE          hProcess,
    IN  HANDLE          hFile,
    IN  PSTR            ImageName,
    IN  PSTR            ModuleName,
    IN  DWORD           BaseOfDll,
    IN  DWORD           SizeOfDll
    );
#endif

BOOL
IMAGEAPI
SymUnloadModule64(
    IN  HANDLE          hProcess,
    IN  DWORD64         BaseOfDll
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymUnloadModule SymUnloadModule64
#else
BOOL
IMAGEAPI
SymUnloadModule(
    IN  HANDLE          hProcess,
    IN  DWORD           BaseOfDll
    );
#endif

BOOL
IMAGEAPI
SymUnDName64(
    IN  PIMAGEHLP_SYMBOL64 sym,               // Symbol to undecorate
    OUT PSTR               UnDecName,         // Buffer to store undecorated name in
    IN  DWORD              UnDecNameLength    // Size of the buffer
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymUnDName SymUnDName64
#else
BOOL
IMAGEAPI
SymUnDName(
    IN  PIMAGEHLP_SYMBOL sym,               // Symbol to undecorate
    OUT PSTR             UnDecName,         // Buffer to store undecorated name in
    IN  DWORD            UnDecNameLength    // Size of the buffer
    );
#endif

BOOL
IMAGEAPI
SymRegisterCallback64(
    IN HANDLE                        hProcess,
    IN PSYMBOL_REGISTERED_CALLBACK64 CallbackFunction,
    IN ULONG64                       UserContext
    );

BOOL
IMAGEAPI
SymRegisterFunctionEntryCallback64(
    IN HANDLE                       hProcess,
    IN PSYMBOL_FUNCENTRY_CALLBACK64 CallbackFunction,
    IN ULONG64                      UserContext
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymRegisterCallback SymRegisterCallback64
#define SymRegisterFunctionEntryCallback SymRegisterFunctionEntryCallback64
#else
BOOL
IMAGEAPI
SymRegisterCallback(
    IN HANDLE                      hProcess,
    IN PSYMBOL_REGISTERED_CALLBACK CallbackFunction,
    IN PVOID                       UserContext
    );

BOOL
IMAGEAPI
SymRegisterFunctionEntryCallback(
    IN HANDLE                     hProcess,
    IN PSYMBOL_FUNCENTRY_CALLBACK CallbackFunction,
    IN PVOID                      UserContext
    );
#endif


// Structure types
typedef enum IMAGEHLP_TYPES {
   IMAGEHLP_TYPEID_INDEX = 1,
   IMAGEHLP_TYPEID_NAME,
   IMAGEHLP_TYPEID_IMAGEHLP_SYMBOL,
   IMAGEHLP_TYPEID_IMAGEHLP_SYMBOL64,
   IMAGEHLP_TYPEID_MODULE_TYPE_INFO,
   IMAGEHLP_TYPEID_TYPE_ENUM_INFO,
   IMAGEHLP_TYPEID_ADDR,
   IMAGEHLP_TYPEID_ADDR_ENUM,
   IMAGEHLP_TYPEID_SYMBOL_SRC
} IMAGEHLP_TYPES;

typedef struct _IMAGEHLP_SYMBOL_SRC {
    DWORD sizeofstruct;
    DWORD type;
    char  file[MAX_PATH];
} IMAGEHLP_SYMBOL_SRC, *PIMAGEHLP_SYMBOL_SRC;

typedef struct _MODULE_TYPE_INFO { // AKA TYPTYP
    USHORT      dataLength;
    USHORT      leaf;
    BYTE        data[1];
} MODULE_TYPE_INFO, *PMODULE_TYPE_INFO;

#define IMAGEHLP_SYMBOL_INFO_VALUEPRESENT          1
#define IMAGEHLP_SYMBOL_INFO_REGISTER              SYMF_REGISTER        // 0x08
#define IMAGEHLP_SYMBOL_INFO_REGRELATIVE           SYMF_REGREL          // 0x10
#define IMAGEHLP_SYMBOL_INFO_FRAMERELATIVE         SYMF_FRAMEREL        // 0x20
#define IMAGEHLP_SYMBOL_INFO_PARAMETER             SYMF_PARAMETER       // 0x40
#define IMAGEHLP_SYMBOL_INFO_LOCAL                 SYMF_LOCAL           // 0x80

typedef struct _SYMBOL_INFO {
    ULONG       SizeOfStruct;
    ULONG       TypeIndex;        // Type Index of symbol
    ULONG64     Reserved[2];
    ULONG       Reserved2;
    ULONG       Size;
    ULONG64     ModBase;          // Base Address of module comtaining this symbol
    ULONG       Flags;
    ULONG64     Value;            // Value of symbol, ValuePresent should be 1
    ULONG64     Address;          // Address of symbol including base address of module
    ULONG       Register;         // register holding value or pointer to value
    ULONG       Scope;            // scope of the symbol
    ULONG       Tag;              // pdb classification
    ULONG       NameLen;          // Actual length of name
    ULONG       MaxNameLen;
    CHAR        Name[1];          // Name of symbol
} SYMBOL_INFO, *PSYMBOL_INFO;

typedef BOOL
(CALLBACK *PSYMBOL_TYPE_NAME_CALLBACK)(
    PSTR  MatchedName,
    ULONG typeIndex,
    PVOID CallerData
    );

typedef BOOL
(CALLBACK *PSYMBOL_TYPE_NAME_ADDR_CALLBACK)(
    PSTR    MatchedName,
    ULONG   typeIndex,
    ULONG64 symAddress,
    PVOID   CallerData
    );

typedef struct _IMAGEHLP_STACK_FRAME
{
    ULONG64 InstructionOffset;
    ULONG64 ReturnOffset;
    ULONG64 FrameOffset;
    ULONG64 StackOffset;
    ULONG64 BackingStoreOffset;
    ULONG64 FuncTableEntry;
    ULONG64 Params[4];
    ULONG64 Reserved[5];
    BOOL    Virtual;
    ULONG   Reserved2;
} IMAGEHLP_STACK_FRAME, *PIMAGEHLP_STACK_FRAME;

typedef VOID IMAGEHLP_CONTEXT, *PIMAGEHLP_CONTEXT;


ULONG
SymSetContext(
    HANDLE hProcess,
    PIMAGEHLP_STACK_FRAME StackFrame,
    PIMAGEHLP_CONTEXT Context
    );

//
// Full user-mode dump creation.
//

typedef BOOL (WINAPI *PDBGHELP_CREATE_USER_DUMP_CALLBACK)(
    DWORD       DataType,
    PVOID*      Data,
    LPDWORD     DataLength,
    PVOID       UserData
    );

BOOL
WINAPI
DbgHelpCreateUserDump(
    IN LPSTR                              FileName,
    IN PDBGHELP_CREATE_USER_DUMP_CALLBACK Callback,
    IN PVOID                              UserData
    );

BOOL
WINAPI
DbgHelpCreateUserDumpW(
    IN LPWSTR                             FileName,
    IN PDBGHELP_CREATE_USER_DUMP_CALLBACK Callback,
    IN PVOID                              UserData
    );

typedef BOOL
(CALLBACK *PSYM_ENUMERATESYMBOLS_CALLBACK)(
    PSYMBOL_INFO  pSymInfo,
    ULONG         SymbolSize,
    PVOID         UserContext
    );
BOOL
IMAGEAPI
SymFromAddr(
    IN  HANDLE              hProcess,
    IN  DWORD64             Address,
    OUT PDWORD64            Displacement,
    IN OUT PSYMBOL_INFO     Symbol
    );

BOOL
IMAGEAPI
SymFromName(
    IN  HANDLE              hProcess,
    IN  LPSTR               Name,
    OUT PSYMBOL_INFO        Symbol
    );

BOOL
IMAGEAPI
SymEnumSym(
    IN HANDLE                       hProcess,
    IN ULONG64                      BaseOfDll,
    IN PSYM_ENUMERATESYMBOLS_CALLBACK    EnumSymbolsCallback,
    IN PVOID                        UserContext
    );

BOOL
IMAGEAPI
SymEnumSymbols(
    IN HANDLE                       hProcess,
    IN ULONG64                      BaseOfDll,
    IN PCSTR                        Mask,
    IN PSYM_ENUMERATESYMBOLS_CALLBACK    EnumSymbolsCallback,
    IN PVOID                        UserContext
    );

typedef enum _IMAGEHLP_SYMBOL_TYPE_INFO {
    TI_GET_SYMTAG,
    TI_GET_SYMNAME,
    TI_GET_LENGTH,
    TI_GET_TYPE,
    TI_GET_TYPEID,
    TI_GET_BASETYPE,
    TI_GET_ARRAYINDEXTYPEID,
    TI_FINDCHILDREN,
    TI_GET_DATAKIND,
    TI_GET_ADDRESSOFFSET,
    TI_GET_OFFSET,
    TI_GET_VALUE,
    TI_GET_COUNT,
    TI_GET_CHILDRENCOUNT,
    TI_GET_BITPOSITION,
    TI_GET_VIRTUALBASECLASS,
    TI_GET_VIRTUALTABLESHAPEID,
    TI_GET_VIRTUALBASEPOINTEROFFSET,
    TI_GET_CLASSPARENTID,
    TI_GET_NESTED,
    TI_GET_SYMINDEX,
    TI_GET_LEXICALPARENT,
    TI_GET_ADDRESS,
} IMAGEHLP_SYMBOL_TYPE_INFO;

typedef struct _TI_FINDCHILDREN_PARAMS {
    ULONG Count;
    ULONG Start;
    ULONG ChildId[1];
} TI_FINDCHILDREN_PARAMS;

BOOL
IMAGEAPI
SymGetTypeInfo(
    IN  HANDLE          hProcess,
    IN  DWORD64         ModBase,
    IN  ULONG           TypeId,
    IN  IMAGEHLP_SYMBOL_TYPE_INFO GetType,
    OUT PVOID           pInfo
    );

typedef enum IMAGEHLP_ENUM_LISTS {
    IMG_ENUM_SYMBOLS,
    IMG_ENUM_LINES,
    IMG_ENUM_TABLES,
    IMG_ENUM_SEGMENTS,
} IMAGEHLP_ENUM_LISTS;

HRESULT
IMAGEAPI
SymGetNextEnumListMember(
    IN HANDLE               hProcess,
    IN DWORD64              ModBase,
    IN PVOID                pEnumList,
    IN IMAGEHLP_ENUM_LISTS  ListTag,
    OUT PVOID               pNext
    );

BOOL
IMAGEAPI
SymEnumTypes(
    IN HANDLE                       hProcess,
    IN ULONG64                      BaseOfDll,
    IN PSYM_ENUMERATESYMBOLS_CALLBACK    EnumSymbolsCallback,
    IN PVOID                        UserContext
    );

BOOL
IMAGEAPI
SymGetTypeFromName(
    IN  HANDLE              hProcess,
    IN  ULONG64             BaseOfDll,
    IN  LPSTR               Name,
    OUT PSYMBOL_INFO        Symbol
    );


#include <pshpack4.h>

#pragma warning(disable:4200) // Zero length array


#define MINIDUMP_SIGNATURE ('PMDM')
#define MINIDUMP_VERSION   (42899)
typedef DWORD RVA;
typedef ULONG64 RVA64;

typedef struct _MINIDUMP_LOCATION_DESCRIPTOR {
    ULONG32 DataSize;
    RVA Rva;
} MINIDUMP_LOCATION_DESCRIPTOR;

typedef struct _MINIDUMP_LOCATION_DESCRIPTOR64 {
    ULONG64 DataSize;
    RVA64 Rva;
} MINIDUMP_LOCATION_DESCRIPTOR64;


typedef struct _MINIDUMP_MEMORY_DESCRIPTOR {
    ULONG64 StartOfMemoryRange;
    MINIDUMP_LOCATION_DESCRIPTOR Memory;
} MINIDUMP_MEMORY_DESCRIPTOR, *PMINIDUMP_MEMORY_DESCRIPTOR;

// DESCRIPTOR64 is used for full-memory minidumps where
// all of the raw memory is laid out sequentially at the
// end of the dump.  There is no need for individual RVAs
// as the RVA is the base RVA plus the sum of the preceeding
// data blocks.
typedef struct _MINIDUMP_MEMORY_DESCRIPTOR64 {
    ULONG64 StartOfMemoryRange;
    ULONG64 DataSize;
} MINIDUMP_MEMORY_DESCRIPTOR64, *PMINIDUMP_MEMORY_DESCRIPTOR64;


typedef struct _MINIDUMP_HEADER {
    ULONG32 Signature;
    ULONG32 Version;
    ULONG32 NumberOfStreams;
    RVA StreamDirectoryRva;
    ULONG32 CheckSum;
    union {
        ULONG32 Reserved;
        ULONG32 TimeDateStamp;
    };
    ULONG64 Flags;
} MINIDUMP_HEADER, *PMINIDUMP_HEADER;

//
// The MINIDUMP_HEADER field StreamDirectoryRva points to 
// an array of MINIDUMP_DIRECTORY structures.
//

typedef struct _MINIDUMP_DIRECTORY {
    ULONG32 StreamType;
    MINIDUMP_LOCATION_DESCRIPTOR Location;
} MINIDUMP_DIRECTORY, *PMINIDUMP_DIRECTORY;


typedef struct _MINIDUMP_STRING {
    ULONG32 Length;         // Length in bytes of the string
    WCHAR   Buffer [0];     // Variable size buffer
} MINIDUMP_STRING, *PMINIDUMP_STRING;



//
// The MINIDUMP_DIRECTORY field StreamType may be one of the following types.
// Types will be added in the future, so if a program reading the minidump
// header encounters a stream type it does not understand it should ignore
// the data altogether. Any tag above LastReservedStream will not be used by
// the system and is reserved for program-specific information.
//

typedef enum _MINIDUMP_STREAM_TYPE {

    UnusedStream                = 0,
    ReservedStream0             = 1,
    ReservedStream1             = 2,
    ThreadListStream            = 3,
    ModuleListStream            = 4,
    MemoryListStream            = 5,
    ExceptionStream             = 6,
    SystemInfoStream            = 7,
    ThreadExListStream          = 8,
    Memory64ListStream          = 9,
    CommentStreamA              = 10,
    CommentStreamW              = 11,
    HandleDataStream            = 12,

    LastReservedStream          = 0xffff

} MINIDUMP_STREAM_TYPE;


//
// The minidump system information contains processor and
// Operating System specific information.
// 
    
typedef struct _MINIDUMP_SYSTEM_INFO {

    //
    // ProcessorArchitecture, ProcessorLevel and ProcessorRevision are all
    // taken from the SYSTEM_INFO structure obtained by GetSystemInfo( ).
    //
    
    USHORT ProcessorArchitecture;
    USHORT ProcessorLevel;
    USHORT ProcessorRevision;

    USHORT Reserved0;              // Reserved for future use. Must be zero.

    //
    // MajorVersion, MinorVersion, BuildNumber, PlatformId and
    // CSDVersion are all taken from the OSVERSIONINFO structure
    // returned by GetVersionEx( ).
    //
    
    ULONG32 MajorVersion;
    ULONG32 MinorVersion;
    ULONG32 BuildNumber;
    ULONG32 PlatformId;

    //
    // RVA to a CSDVersion string in the string table.
    //
    
    RVA CSDVersionRva;

    ULONG32 Reserved1;             // Reserved for future use.

    //
    // CPU information is obtained from one of two places.
    //
    //  1) On x86 computers, CPU_INFORMATION is obtained from the CPUID
    //     instruction. You must use the X86 portion of the union for X86
    //     computers.
    //
    //  2) On non-x86 architectures, CPU_INFORMATION is obtained by calling
    //     IsProcessorFeatureSupported().
    //
    
    union _CPU_INFORMATION {

        //
        // X86 platforms use CPUID function to obtain processor information.
        //
        
        struct {

            //
            // CPUID Subfunction 0, register EAX (VendorId [0]),
            // EBX (VendorId [1]) and ECX (VendorId [2]).
            //
            
            ULONG32 VendorId [ 3 ];
            
            //
            // CPUID Subfunction 1, register EAX
            //
            
            ULONG32 VersionInformation;

            //
            // CPUID Subfunction 1, register EDX
            //
            
            ULONG32 FeatureInformation;
            

            //
            // CPUID, Subfunction 80000001, register EBX. This will only
            // be obtained if the vendor id is "AuthenticAMD".
            //
            
            ULONG32 AMDExtendedCpuFeatures;
    
        } X86CpuInfo;

        //
        // Non-x86 platforms use processor feature flags.
        //
        
        struct {

            ULONG64 ProcessorFeatures [ 2 ];
            
        } OtherCpuInfo;
        
    } Cpu;

} MINIDUMP_SYSTEM_INFO, *PMINIDUMP_SYSTEM_INFO;

typedef union _CPU_INFORMATION CPU_INFORMATION, *PCPU_INFORMATION;


//
// The minidump thread contains standard thread
// information plus an RVA to the memory for this 
// thread and an RVA to the CONTEXT structure for
// this thread.
//


//
// ThreadId must be 4 bytes on all architectures.
//

C_ASSERT (sizeof ( ((PPROCESS_INFORMATION)0)->dwThreadId ) == 4);

typedef struct _MINIDUMP_THREAD {
    ULONG32 ThreadId;
    ULONG32 SuspendCount;
    ULONG32 PriorityClass;
    ULONG32 Priority;
    ULONG64 Teb;
    MINIDUMP_MEMORY_DESCRIPTOR Stack;
    MINIDUMP_LOCATION_DESCRIPTOR ThreadContext;
} MINIDUMP_THREAD, *PMINIDUMP_THREAD;

//
// The thread list is a container of threads.
//

typedef struct _MINIDUMP_THREAD_LIST {
    ULONG32 NumberOfThreads;
    MINIDUMP_THREAD Threads [0];
} MINIDUMP_THREAD_LIST, *PMINIDUMP_THREAD_LIST;


typedef struct _MINIDUMP_THREAD_EX {
    ULONG32 ThreadId;
    ULONG32 SuspendCount;
    ULONG32 PriorityClass;
    ULONG32 Priority;
    ULONG64 Teb;
    MINIDUMP_MEMORY_DESCRIPTOR Stack;
    MINIDUMP_LOCATION_DESCRIPTOR ThreadContext;
    MINIDUMP_MEMORY_DESCRIPTOR BackingStore;
} MINIDUMP_THREAD_EX, *PMINIDUMP_THREAD_EX;

//
// The thread list is a container of threads.
//

typedef struct _MINIDUMP_THREAD_EX_LIST {
    ULONG32 NumberOfThreads;
    MINIDUMP_THREAD_EX Threads [0];
} MINIDUMP_THREAD_EX_LIST, *PMINIDUMP_THREAD_EX_LIST;


//
// The MINIDUMP_EXCEPTION is the same as EXCEPTION on Win64.
//

typedef struct _MINIDUMP_EXCEPTION  {
    ULONG32 ExceptionCode;
    ULONG32 ExceptionFlags;
    ULONG64 ExceptionRecord;
    ULONG64 ExceptionAddress;
    ULONG32 NumberParameters;
    ULONG32 __unusedAlignment;
    ULONG64 ExceptionInformation [ EXCEPTION_MAXIMUM_PARAMETERS ];
} MINIDUMP_EXCEPTION, *PMINIDUMP_EXCEPTION;


//
// The exception information stream contains the id of the thread that caused
// the exception (ThreadId), the exception record for the exception
// (ExceptionRecord) and an RVA to the thread context where the exception
// occured.
//

typedef struct MINIDUMP_EXCEPTION_STREAM {
    ULONG32 ThreadId;
    ULONG32  __alignment;
    MINIDUMP_EXCEPTION ExceptionRecord;
    MINIDUMP_LOCATION_DESCRIPTOR ThreadContext;
} MINIDUMP_EXCEPTION_STREAM, *PMINIDUMP_EXCEPTION_STREAM;


//
// The MINIDUMP_MODULE contains information about a
// a specific module. It includes the CheckSum and
// the TimeDateStamp for the module so the module
// can be reloaded during the analysis phase.
//

typedef struct _MINIDUMP_MODULE {
    ULONG64 BaseOfImage;
    ULONG32 SizeOfImage;
    ULONG32 CheckSum;
    ULONG32 TimeDateStamp;
    RVA ModuleNameRva;
    VS_FIXEDFILEINFO VersionInfo;
    MINIDUMP_LOCATION_DESCRIPTOR CvRecord;
    MINIDUMP_LOCATION_DESCRIPTOR MiscRecord;
    ULONG64 Reserved0;                          // Reserved for future use.
    ULONG64 Reserved1;                          // Reserved for future use.
} MINIDUMP_MODULE, *PMINIDUMP_MODULE;   


//
// The minidump module list is a container for modules.
//

typedef struct _MINIDUMP_MODULE_LIST {
    ULONG32 NumberOfModules;
    MINIDUMP_MODULE Modules [ 0 ];
} MINIDUMP_MODULE_LIST, *PMINIDUMP_MODULE_LIST;


//
// Memory Ranges
//

typedef struct _MINIDUMP_MEMORY_LIST {
    ULONG32 NumberOfMemoryRanges;
    MINIDUMP_MEMORY_DESCRIPTOR MemoryRanges [0];
} MINIDUMP_MEMORY_LIST, *PMINIDUMP_MEMORY_LIST;

typedef struct _MINIDUMP_MEMORY64_LIST {
    ULONG64 NumberOfMemoryRanges;
    RVA64 BaseRva;
    MINIDUMP_MEMORY_DESCRIPTOR64 MemoryRanges [0];
} MINIDUMP_MEMORY64_LIST, *PMINIDUMP_MEMORY64_LIST;


//
// Support for user supplied exception information.
//

typedef struct _MINIDUMP_EXCEPTION_INFORMATION {
    DWORD ThreadId;
    PEXCEPTION_POINTERS ExceptionPointers;
    BOOL ClientPointers;
} MINIDUMP_EXCEPTION_INFORMATION, *PMINIDUMP_EXCEPTION_INFORMATION;


//
// Support for capturing system handle state at the time of the dump.
//

typedef struct _MINIDUMP_HANDLE_DESCRIPTOR {
    ULONG64 Handle;
    RVA TypeNameRva;
    RVA ObjectNameRva;
    ULONG Attributes;
    ULONG GrantedAccess;
    ULONG HandleCount;
    ULONG PointerCount;
} MINIDUMP_HANDLE_DESCRIPTOR, *PMINIDUMP_HANDLE_DESCRIPTOR;

typedef struct _MINIDUMP_HANDLE_DATA_STREAM {
    ULONG SizeOfHeader;
    ULONG SizeOfDescriptor;
    ULONG NumberOfDescriptors;
    ULONG Reserved;
} MINIDUMP_HANDLE_DATA_STREAM, *PMINIDUMP_HANDLE_DATA_STREAM;


//
// Support for arbitrary user-defined information.
//

typedef struct _MINIDUMP_USER_RECORD {
    ULONG32 Type;
    MINIDUMP_LOCATION_DESCRIPTOR Memory;
} MINIDUMP_USER_RECORD, *PMINIDUMP_USER_RECORD;


typedef struct _MINIDUMP_USER_STREAM {
    ULONG32 Type;
    ULONG BufferSize;
    PVOID Buffer;

} MINIDUMP_USER_STREAM, *PMINIDUMP_USER_STREAM;


typedef struct _MINIDUMP_USER_STREAM_INFORMATION {
    ULONG UserStreamCount;
    PMINIDUMP_USER_STREAM UserStreamArray;
} MINIDUMP_USER_STREAM_INFORMATION, *PMINIDUMP_USER_STREAM_INFORMATION;

//
// Callback support.
//

typedef enum _MINIDUMP_CALLBACK_TYPE {
    ModuleCallback,
    ThreadCallback,
    ThreadExCallback
} MINIDUMP_CALLBACK_TYPE;


typedef struct _MINIDUMP_THREAD_CALLBACK {
    ULONG ThreadId;
    HANDLE ThreadHandle;
    CONTEXT Context;
    ULONG SizeOfContext;
    ULONG64 StackBase;
    ULONG64 StackEnd;
} MINIDUMP_THREAD_CALLBACK, *PMINIDUMP_THREAD_CALLBACK;


typedef struct _MINIDUMP_THREAD_EX_CALLBACK {
    ULONG ThreadId;
    HANDLE ThreadHandle;
    CONTEXT Context;
    ULONG SizeOfContext;
    ULONG64 StackBase;
    ULONG64 StackEnd;
    ULONG64 BackingStoreBase;
    ULONG64 BackingStoreEnd;
} MINIDUMP_THREAD_EX_CALLBACK, *PMINIDUMP_THREAD_EX_CALLBACK;


typedef enum _THREAD_WRITE_FLAGS {
    ThreadWriteThread            = 0x0001,
    ThreadWriteStack             = 0x0002,
    ThreadWriteContext           = 0x0004,
    ThreadWriteBackingStore      = 0x0008,
    ThreadWriteInstructionWindow = 0x0010
} THREAD_WRITE_FLAGS;

typedef struct _MINIDUMP_MODULE_CALLBACK {
    PWCHAR FullPath;
    ULONG64 BaseOfImage;
    ULONG SizeOfImage;
    ULONG CheckSum;
    ULONG TimeDateStamp;
    VS_FIXEDFILEINFO VersionInfo;
    PVOID CvRecord; 
    ULONG SizeOfCvRecord;
    PVOID MiscRecord;
    ULONG SizeOfMiscRecord;
} MINIDUMP_MODULE_CALLBACK, *PMINIDUMP_MODULE_CALLBACK;


typedef enum _MODULE_WRITE_FLAGS {
    ModuleWriteModule       = 0x0001,
    ModuleWriteDataSeg      = 0x0002,
    ModuleWriteMiscRecord   = 0x0004
} MODULE_WRITE_FLAGS;


typedef struct _MINIDUMP_CALLBACK_INPUT {
    ULONG ProcessId;
    HANDLE ProcessHandle;
    ULONG CallbackType;
    union {
        MINIDUMP_THREAD_CALLBACK Thread;
        MINIDUMP_THREAD_EX_CALLBACK ThreadEx;
        MINIDUMP_MODULE_CALLBACK Module;
    };
} MINIDUMP_CALLBACK_INPUT, *PMINIDUMP_CALLBACK_INPUT;

typedef struct _MINIDUMP_CALLBACK_OUTPUT {
    union {
        ULONG ModuleWriteFlags;
        ULONG ThreadWriteFlags;
    };
} MINIDUMP_CALLBACK_OUTPUT, *PMINIDUMP_CALLBACK_OUTPUT;

        
//
// A normal minidump contains just the information
// necessary to capture stack traces for all of the
// existing threads in a process.
//
// A minidump with data segments includes all of the data
// sections from loaded modules in order to capture
// global variable contents.  This can make the dump much
// larger if many modules have global data.
//
// A minidump with full memory includes all of the accessible
// memory in the process and can be very large.  A minidump
// with full memory always has the raw memory data at the end
// of the dump so that the initial structures in the dump can
// be mapped directly without having to include the raw
// memory information.
//

typedef enum _MINIDUMP_TYPE {
    MiniDumpNormal         = 0x0000,
    MiniDumpWithDataSegs   = 0x0001,
    MiniDumpWithFullMemory = 0x0002,
    MiniDumpWithHandleData = 0x0004,
} MINIDUMP_TYPE;


//
// The minidump callback should modify the FieldsToWrite parameter to reflect
// what portions of the specified thread or module should be written to the
// file.
//

typedef
BOOL
(WINAPI * MINIDUMP_CALLBACK_ROUTINE) (
    IN PVOID CallbackParam,
    IN CONST PMINIDUMP_CALLBACK_INPUT CallbackInput,
    IN OUT PMINIDUMP_CALLBACK_OUTPUT CallbackOutput
    );

typedef struct _MINIDUMP_CALLBACK_INFORMATION {
    MINIDUMP_CALLBACK_ROUTINE CallbackRoutine;
    PVOID CallbackParam;
} MINIDUMP_CALLBACK_INFORMATION, *PMINIDUMP_CALLBACK_INFORMATION;



//++
//
// PVOID
// RVA_TO_ADDR(
//     PVOID Mapping,
//     ULONG Rva
//     )
//
// Routine Description:
//
//     Map an RVA that is contained within a mapped file to it's associated
//     flat address.
//
// Arguments:
//
//     Mapping - Base address of mapped file containing the RVA.
//
//     Rva - An Rva to fixup.
//
// Return Values:
//
//     A pointer to the desired data.
//
//--

#define RVA_TO_ADDR(Mapping,Rva) ((PVOID)(((ULONG_PTR) (Mapping)) + (Rva)))

BOOL
WINAPI
MiniDumpWriteDump(
    IN HANDLE hProcess,
    IN DWORD ProcessId,
    IN HANDLE hFile,
    IN MINIDUMP_TYPE DumpType,
    IN CONST PMINIDUMP_EXCEPTION_INFORMATION ExceptionParam, OPTIONAL
    IN CONST PMINIDUMP_USER_STREAM_INFORMATION UserStreamParam, OPTIONAL
    IN CONST PMINIDUMP_CALLBACK_INFORMATION CallbackParam OPTIONAL
    );

BOOL
WINAPI
MiniDumpReadDumpStream(
    IN PVOID BaseOfDump,
    IN ULONG StreamNumber,
    OUT PMINIDUMP_DIRECTORY * Dir, OPTIONAL
    OUT PVOID * StreamPointer, OPTIONAL
    OUT ULONG * StreamSize OPTIONAL
    );

#include <poppack.h>

#ifdef __cplusplus
}
#endif


#endif // _DBGHELP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\stress\stressapps\asyncwebcrawler\utils.cpp ===
// utility/miscellaneous functions for the crawler test app

#include "crawler.h"

WCHAR*
__ansitowide(const char* psz)
{
  WCHAR* wide = NULL;
  int    len  = 0L;

  if( psz )
  {
    len = strlen(psz);

    if( len )
    {
      wide = new WCHAR[len+1];

      if( !wide )
        return NULL;

      wide[len] = L'\0';

      MultiByteToWideChar(
        CP_ACP, 0,
        psz,  len,
        wide, len
        );
    }
  }

  return wide;
}

CHAR*
__widetoansi(const WCHAR* pwsz)
{
  CHAR* ansi = NULL;
  int   len  = 0L;
  BOOL  def  = FALSE;

  if( pwsz )
  {
    len = wcslen(pwsz);

    if( len )
    {
      ansi = new CHAR[len+1];

      if( !ansi )
        return NULL;

      ansi[len] = '\0';

      WideCharToMultiByte(
        CP_ACP, 0,
        pwsz, len,
        ansi, len,
        "?", &def
        );
    }
  }

  return ansi;
}

int
DataDumpFormat(LPSTR buffer, LPBYTE data, DWORD len)
{
  static char spaces[] = "                                               ";

  DWORD n      = 0L;
  DWORD bytes  = 0L;
  DWORD offset = 0L;
  DWORD byte   = 0L;
  CHAR  ch;

  bytes  = min(len, 16);
  offset = wsprintfA(buffer, "[tid=%#0.8x] %08x  ", GetCurrentThreadId(), data);

  for(n=0; n<bytes; n++)
  {
    byte    = data[n] & 0xFF;

    offset += wsprintfA(
                buffer+offset,
                ((n & 15) == 7 ? "%02.2x-" : "%02.2x "),
                byte                
                );
  }

  memcpy(buffer+offset, spaces, (16-bytes) * 3 + 2);
  offset += (16-bytes) * 3 + 2;

  for(n=0; n<bytes; n++)
  {
    ch = data[n];
    buffer[offset + n] =  (((ch < 32) || (ch > 127)) || ch == '%') ? '.' : ch;
  }

  buffer[offset + n] = '\0';

  return bytes;
}


void
DataDump(LPBYTE data, DWORD len)
{
  DWORD n      = 0L;
  DWORD offset = 0L;
  CHAR* buf    = NULL;

  buf = new CHAR[256];

    while( len )
    {
      n = DataDumpFormat(buf, data, len);

      printf("%s\r\n", buf);

      data += n;
      len  -= n;
    }

  delete [] buf;
}


LPSTR
MapErrorToString(int error)
{
  switch(error)
  {
    CASE_OF(ERROR_WINHTTP_OUT_OF_HANDLES);
    CASE_OF(ERROR_WINHTTP_TIMEOUT);
    CASE_OF(ERROR_WINHTTP_INTERNAL_ERROR);
    CASE_OF(ERROR_WINHTTP_INVALID_URL);
    CASE_OF(ERROR_WINHTTP_UNRECOGNIZED_SCHEME);
    CASE_OF(ERROR_WINHTTP_NAME_NOT_RESOLVED);
    CASE_OF(ERROR_WINHTTP_INVALID_OPTION);
    CASE_OF(ERROR_WINHTTP_OPTION_NOT_SETTABLE);
    CASE_OF(ERROR_WINHTTP_SHUTDOWN);
    CASE_OF(ERROR_WINHTTP_LOGIN_FAILURE);
    CASE_OF(ERROR_WINHTTP_OPERATION_CANCELLED);
    CASE_OF(ERROR_WINHTTP_INCORRECT_HANDLE_TYPE);
    CASE_OF(ERROR_WINHTTP_INCORRECT_HANDLE_STATE);
    CASE_OF(ERROR_WINHTTP_CANNOT_CONNECT);
    CASE_OF(ERROR_WINHTTP_CONNECTION_ERROR);
    CASE_OF(ERROR_WINHTTP_RESEND_REQUEST);
    CASE_OF(ERROR_WINHTTP_CLIENT_AUTH_CERT_NEEDED);
    CASE_OF(ERROR_WINHTTP_HEADER_NOT_FOUND);
    CASE_OF(ERROR_WINHTTP_INVALID_SERVER_RESPONSE);
    CASE_OF(ERROR_WINHTTP_INVALID_QUERY_REQUEST);
    CASE_OF(ERROR_WINHTTP_HEADER_ALREADY_EXISTS);
    CASE_OF(ERROR_WINHTTP_REDIRECT_FAILED);
    CASE_OF(ERROR_WINHTTP_NOT_INITIALIZED);
    CASE_OF(ERROR_WINHTTP_SECURE_FAILURE);

    CASE_OF(ERROR_SUCCESS);
    CASE_OF(ERROR_INVALID_FUNCTION);
    CASE_OF(ERROR_FILE_NOT_FOUND);
    CASE_OF(ERROR_PATH_NOT_FOUND);
    CASE_OF(ERROR_TOO_MANY_OPEN_FILES);
    CASE_OF(ERROR_ACCESS_DENIED);
    CASE_OF(ERROR_INVALID_HANDLE);
    CASE_OF(ERROR_ARENA_TRASHED);
    CASE_OF(ERROR_NOT_ENOUGH_MEMORY);
    CASE_OF(ERROR_INVALID_BLOCK);
    CASE_OF(ERROR_BAD_ENVIRONMENT);
    CASE_OF(ERROR_BAD_FORMAT);
    CASE_OF(ERROR_INVALID_ACCESS);
    CASE_OF(ERROR_INVALID_DATA);
    CASE_OF(ERROR_OUTOFMEMORY);
    CASE_OF(ERROR_INVALID_DRIVE);
    CASE_OF(ERROR_CURRENT_DIRECTORY);
    CASE_OF(ERROR_NOT_SAME_DEVICE);
    CASE_OF(ERROR_NO_MORE_FILES);
    CASE_OF(ERROR_WRITE_PROTECT);
    CASE_OF(ERROR_BAD_UNIT);
    CASE_OF(ERROR_NOT_READY);
    CASE_OF(ERROR_BAD_COMMAND);
    CASE_OF(ERROR_CRC);
    CASE_OF(ERROR_BAD_LENGTH);
    CASE_OF(ERROR_SEEK);
    CASE_OF(ERROR_NOT_DOS_DISK);
    CASE_OF(ERROR_SECTOR_NOT_FOUND);
    CASE_OF(ERROR_OUT_OF_PAPER);
    CASE_OF(ERROR_WRITE_FAULT);
    CASE_OF(ERROR_READ_FAULT);
    CASE_OF(ERROR_GEN_FAILURE);
    CASE_OF(ERROR_SHARING_VIOLATION);
    CASE_OF(ERROR_LOCK_VIOLATION);
    CASE_OF(ERROR_WRONG_DISK);
    CASE_OF(ERROR_SHARING_BUFFER_EXCEEDED);
    CASE_OF(ERROR_HANDLE_EOF);
    CASE_OF(ERROR_HANDLE_DISK_FULL);
    CASE_OF(ERROR_NOT_SUPPORTED);
    CASE_OF(ERROR_REM_NOT_LIST);
    CASE_OF(ERROR_DUP_NAME);
    CASE_OF(ERROR_BAD_NETPATH);
    CASE_OF(ERROR_NETWORK_BUSY);
    CASE_OF(ERROR_DEV_NOT_EXIST);
    CASE_OF(ERROR_TOO_MANY_CMDS);
    CASE_OF(ERROR_ADAP_HDW_ERR);
    CASE_OF(ERROR_BAD_NET_RESP);
    CASE_OF(ERROR_UNEXP_NET_ERR);
    CASE_OF(ERROR_BAD_REM_ADAP);
    CASE_OF(ERROR_PRINTQ_FULL);
    CASE_OF(ERROR_NO_SPOOL_SPACE);
    CASE_OF(ERROR_PRINT_CANCELLED);
    CASE_OF(ERROR_NETNAME_DELETED);
    CASE_OF(ERROR_NETWORK_ACCESS_DENIED);
    CASE_OF(ERROR_BAD_DEV_TYPE);
    CASE_OF(ERROR_BAD_NET_NAME);
    CASE_OF(ERROR_TOO_MANY_NAMES);
    CASE_OF(ERROR_TOO_MANY_SESS);
    CASE_OF(ERROR_SHARING_PAUSED);
    CASE_OF(ERROR_REQ_NOT_ACCEP);
    CASE_OF(ERROR_REDIR_PAUSED);
    CASE_OF(ERROR_FILE_EXISTS);
    CASE_OF(ERROR_CANNOT_MAKE);
    CASE_OF(ERROR_FAIL_I24);
    CASE_OF(ERROR_OUT_OF_STRUCTURES);
    CASE_OF(ERROR_ALREADY_ASSIGNED);
    CASE_OF(ERROR_INVALID_PASSWORD);
    CASE_OF(ERROR_INVALID_PARAMETER);
    CASE_OF(ERROR_NET_WRITE_FAULT);
    CASE_OF(ERROR_NO_PROC_SLOTS);
    CASE_OF(ERROR_TOO_MANY_SEMAPHORES);
    CASE_OF(ERROR_EXCL_SEM_ALREADY_OWNED);
    CASE_OF(ERROR_SEM_IS_SET);
    CASE_OF(ERROR_TOO_MANY_SEM_REQUESTS);
    CASE_OF(ERROR_INVALID_AT_INTERRUPT_TIME);
    CASE_OF(ERROR_SEM_OWNER_DIED);
    CASE_OF(ERROR_SEM_USER_LIMIT);
    CASE_OF(ERROR_DISK_CHANGE);
    CASE_OF(ERROR_DRIVE_LOCKED);
    CASE_OF(ERROR_BROKEN_PIPE);
    CASE_OF(ERROR_OPEN_FAILED);
    CASE_OF(ERROR_BUFFER_OVERFLOW);
    CASE_OF(ERROR_DISK_FULL);
    CASE_OF(ERROR_NO_MORE_SEARCH_HANDLES);
    CASE_OF(ERROR_INVALID_TARGET_HANDLE);
    CASE_OF(ERROR_INVALID_CATEGORY);
    CASE_OF(ERROR_INVALID_VERIFY_SWITCH);
    CASE_OF(ERROR_BAD_DRIVER_LEVEL);
    CASE_OF(ERROR_CALL_NOT_IMPLEMENTED);
    CASE_OF(ERROR_SEM_TIMEOUT);
    CASE_OF(ERROR_INSUFFICIENT_BUFFER);
    CASE_OF(ERROR_INVALID_NAME);
    CASE_OF(ERROR_INVALID_LEVEL);
    CASE_OF(ERROR_NO_VOLUME_LABEL);
    CASE_OF(ERROR_MOD_NOT_FOUND);
    CASE_OF(ERROR_PROC_NOT_FOUND);
    CASE_OF(ERROR_WAIT_NO_CHILDREN);
    CASE_OF(ERROR_CHILD_NOT_COMPLETE);
    CASE_OF(ERROR_DIRECT_ACCESS_HANDLE);
    CASE_OF(ERROR_NEGATIVE_SEEK);
    CASE_OF(ERROR_SEEK_ON_DEVICE);
    CASE_OF(ERROR_DIR_NOT_ROOT);
    CASE_OF(ERROR_DIR_NOT_EMPTY);
    CASE_OF(ERROR_PATH_BUSY);
    CASE_OF(ERROR_SYSTEM_TRACE);
    CASE_OF(ERROR_INVALID_EVENT_COUNT);
    CASE_OF(ERROR_TOO_MANY_MUXWAITERS);
    CASE_OF(ERROR_INVALID_LIST_FORMAT);
    CASE_OF(ERROR_BAD_ARGUMENTS);
    CASE_OF(ERROR_BAD_PATHNAME);
    CASE_OF(ERROR_BUSY);
    CASE_OF(ERROR_CANCEL_VIOLATION);
    CASE_OF(ERROR_ALREADY_EXISTS);
    CASE_OF(ERROR_FILENAME_EXCED_RANGE);
    CASE_OF(ERROR_LOCKED);
    CASE_OF(ERROR_NESTING_NOT_ALLOWED);
    CASE_OF(ERROR_BAD_PIPE);
    CASE_OF(ERROR_PIPE_BUSY);
    CASE_OF(ERROR_NO_DATA);
    CASE_OF(ERROR_PIPE_NOT_CONNECTED);
    CASE_OF(ERROR_MORE_DATA);
    CASE_OF(ERROR_NO_MORE_ITEMS);
    CASE_OF(ERROR_NOT_OWNER);
    CASE_OF(ERROR_PARTIAL_COPY);
    CASE_OF(ERROR_MR_MID_NOT_FOUND);
    CASE_OF(ERROR_INVALID_ADDRESS);
    CASE_OF(ERROR_PIPE_CONNECTED);
    CASE_OF(ERROR_PIPE_LISTENING);
    CASE_OF(ERROR_OPERATION_ABORTED);
    CASE_OF(ERROR_IO_INCOMPLETE);
    CASE_OF(ERROR_IO_PENDING);
    CASE_OF(ERROR_NOACCESS);
    CASE_OF(ERROR_STACK_OVERFLOW);
    CASE_OF(ERROR_INVALID_FLAGS);
    CASE_OF(ERROR_NO_TOKEN);
    CASE_OF(ERROR_BADDB);
    CASE_OF(ERROR_BADKEY);
    CASE_OF(ERROR_CANTOPEN);
    CASE_OF(ERROR_CANTREAD);
    CASE_OF(ERROR_CANTWRITE);
    CASE_OF(ERROR_REGISTRY_RECOVERED);
    CASE_OF(ERROR_REGISTRY_CORRUPT);
    CASE_OF(ERROR_REGISTRY_IO_FAILED);
    CASE_OF(ERROR_NOT_REGISTRY_FILE);
    CASE_OF(ERROR_KEY_DELETED);
    CASE_OF(ERROR_CIRCULAR_DEPENDENCY);
    CASE_OF(ERROR_SERVICE_NOT_ACTIVE);
    CASE_OF(ERROR_DLL_INIT_FAILED);
    CASE_OF(ERROR_CANCELLED);
    CASE_OF(ERROR_BAD_USERNAME);
    CASE_OF(ERROR_LOGON_FAILURE);

    CASE_OF(WAIT_FAILED);
    CASE_OF(WAIT_TIMEOUT);
    CASE_OF(WAIT_IO_COMPLETION);

    CASE_OF(EXCEPTION_ACCESS_VIOLATION);
    CASE_OF(EXCEPTION_DATATYPE_MISALIGNMENT);
    CASE_OF(EXCEPTION_BREAKPOINT);
    CASE_OF(EXCEPTION_SINGLE_STEP);
    CASE_OF(EXCEPTION_ARRAY_BOUNDS_EXCEEDED);
    CASE_OF(EXCEPTION_FLT_DENORMAL_OPERAND);
    CASE_OF(EXCEPTION_FLT_DIVIDE_BY_ZERO);
    CASE_OF(EXCEPTION_FLT_INEXACT_RESULT);
    CASE_OF(EXCEPTION_FLT_INVALID_OPERATION);
    CASE_OF(EXCEPTION_FLT_OVERFLOW);
    CASE_OF(EXCEPTION_FLT_STACK_CHECK);
    CASE_OF(EXCEPTION_FLT_UNDERFLOW);
    CASE_OF(EXCEPTION_INT_DIVIDE_BY_ZERO);
    CASE_OF(EXCEPTION_INT_OVERFLOW);
    CASE_OF(EXCEPTION_PRIV_INSTRUCTION);
    CASE_OF(EXCEPTION_IN_PAGE_ERROR);
    CASE_OF(EXCEPTION_ILLEGAL_INSTRUCTION);
    CASE_OF(EXCEPTION_NONCONTINUABLE_EXCEPTION);
    CASE_OF(EXCEPTION_STACK_OVERFLOW);
    CASE_OF(EXCEPTION_INVALID_DISPOSITION);
    CASE_OF(EXCEPTION_GUARD_PAGE);
    CASE_OF(EXCEPTION_INVALID_HANDLE);

    CASE_OF(RPC_S_INVALID_STRING_BINDING);
    CASE_OF(RPC_S_WRONG_KIND_OF_BINDING);
    CASE_OF(RPC_S_INVALID_BINDING);
    CASE_OF(RPC_S_PROTSEQ_NOT_SUPPORTED);
    CASE_OF(RPC_S_INVALID_RPC_PROTSEQ);
    CASE_OF(RPC_S_INVALID_STRING_UUID);
    CASE_OF(RPC_S_INVALID_ENDPOINT_FORMAT);
    CASE_OF(RPC_S_INVALID_NET_ADDR);
    CASE_OF(RPC_S_NO_ENDPOINT_FOUND);
    CASE_OF(RPC_S_INVALID_TIMEOUT);
    CASE_OF(RPC_S_OBJECT_NOT_FOUND);
    CASE_OF(RPC_S_ALREADY_REGISTERED);
    CASE_OF(RPC_S_TYPE_ALREADY_REGISTERED);
    CASE_OF(RPC_S_ALREADY_LISTENING);
    CASE_OF(RPC_S_NO_PROTSEQS_REGISTERED);
    CASE_OF(RPC_S_NOT_LISTENING);
    CASE_OF(RPC_S_UNKNOWN_MGR_TYPE);
    CASE_OF(RPC_S_UNKNOWN_IF);
    CASE_OF(RPC_S_NO_BINDINGS);
    CASE_OF(RPC_S_NO_PROTSEQS);
    CASE_OF(RPC_S_CANT_CREATE_ENDPOINT);
    CASE_OF(RPC_S_OUT_OF_RESOURCES);
    CASE_OF(RPC_S_SERVER_UNAVAILABLE);
    CASE_OF(RPC_S_SERVER_TOO_BUSY);
    CASE_OF(RPC_S_INVALID_NETWORK_OPTIONS);
    CASE_OF(RPC_S_NO_CALL_ACTIVE);
    CASE_OF(RPC_S_CALL_FAILED);
    CASE_OF(RPC_S_CALL_FAILED_DNE);
    CASE_OF(RPC_S_PROTOCOL_ERROR);
    CASE_OF(RPC_S_UNSUPPORTED_TRANS_SYN);
    CASE_OF(RPC_S_UNSUPPORTED_TYPE);
    CASE_OF(RPC_S_INVALID_TAG);
    CASE_OF(RPC_S_INVALID_BOUND);
    CASE_OF(RPC_S_NO_ENTRY_NAME);
    CASE_OF(RPC_S_INVALID_NAME_SYNTAX);
    CASE_OF(RPC_S_UNSUPPORTED_NAME_SYNTAX);
    CASE_OF(RPC_S_UUID_NO_ADDRESS);
    CASE_OF(RPC_S_DUPLICATE_ENDPOINT);
    CASE_OF(RPC_S_UNKNOWN_AUTHN_TYPE);
    CASE_OF(RPC_S_MAX_CALLS_TOO_SMALL);
    CASE_OF(RPC_S_STRING_TOO_LONG);
    CASE_OF(RPC_S_PROTSEQ_NOT_FOUND);
    CASE_OF(RPC_S_PROCNUM_OUT_OF_RANGE);
    CASE_OF(RPC_S_BINDING_HAS_NO_AUTH);
    CASE_OF(RPC_S_UNKNOWN_AUTHN_SERVICE);
    CASE_OF(RPC_S_UNKNOWN_AUTHN_LEVEL);
    CASE_OF(RPC_S_INVALID_AUTH_IDENTITY);
    CASE_OF(RPC_S_UNKNOWN_AUTHZ_SERVICE);
    CASE_OF(EPT_S_INVALID_ENTRY);
    CASE_OF(EPT_S_CANT_PERFORM_OP);
    CASE_OF(EPT_S_NOT_REGISTERED);
    CASE_OF(RPC_S_NOTHING_TO_EXPORT);
    CASE_OF(RPC_S_INCOMPLETE_NAME);
    CASE_OF(RPC_S_INVALID_VERS_OPTION);
    CASE_OF(RPC_S_NO_MORE_MEMBERS);
    CASE_OF(RPC_S_NOT_ALL_OBJS_UNEXPORTED);
    CASE_OF(RPC_S_INTERFACE_NOT_FOUND);
    CASE_OF(RPC_S_ENTRY_ALREADY_EXISTS);
    CASE_OF(RPC_S_ENTRY_NOT_FOUND);
    CASE_OF(RPC_S_NAME_SERVICE_UNAVAILABLE);
    CASE_OF(RPC_S_INVALID_NAF_ID);
    CASE_OF(RPC_S_CANNOT_SUPPORT);
    CASE_OF(RPC_S_NO_CONTEXT_AVAILABLE);
    CASE_OF(RPC_S_INTERNAL_ERROR);
    CASE_OF(RPC_S_ZERO_DIVIDE);
    CASE_OF(RPC_S_ADDRESS_ERROR);
    CASE_OF(RPC_S_FP_DIV_ZERO);
    CASE_OF(RPC_S_FP_UNDERFLOW);
    CASE_OF(RPC_S_FP_OVERFLOW);
    CASE_OF(RPC_X_NO_MORE_ENTRIES);
    CASE_OF(RPC_X_SS_CHAR_TRANS_OPEN_FAIL);
    CASE_OF(RPC_X_SS_CHAR_TRANS_SHORT_FILE);
    CASE_OF(RPC_X_SS_IN_NULL_CONTEXT);
    CASE_OF(RPC_X_SS_CONTEXT_DAMAGED);
    CASE_OF(RPC_X_SS_HANDLES_MISMATCH);
    CASE_OF(RPC_X_SS_CANNOT_GET_CALL_HANDLE);
    CASE_OF(RPC_X_NULL_REF_POINTER);
    CASE_OF(RPC_X_ENUM_VALUE_OUT_OF_RANGE);
    CASE_OF(RPC_X_BYTE_COUNT_TOO_SMALL);
    CASE_OF(RPC_X_BAD_STUB_DATA);

    CASE_OF(WSAEINTR);
    CASE_OF(WSAEBADF);
    CASE_OF(WSAEACCES);
    CASE_OF(WSAEFAULT);
    CASE_OF(WSAEINVAL);
    CASE_OF(WSAEMFILE);
    CASE_OF(WSAEWOULDBLOCK);
    CASE_OF(WSAEINPROGRESS);
    CASE_OF(WSAEALREADY);
    CASE_OF(WSAENOTSOCK);
    CASE_OF(WSAEDESTADDRREQ);
    CASE_OF(WSAEMSGSIZE);
    CASE_OF(WSAEPROTOTYPE);
    CASE_OF(WSAENOPROTOOPT);
    CASE_OF(WSAEPROTONOSUPPORT);
    CASE_OF(WSAESOCKTNOSUPPORT);
    CASE_OF(WSAEOPNOTSUPP);
    CASE_OF(WSAEPFNOSUPPORT);
    CASE_OF(WSAEAFNOSUPPORT);
    CASE_OF(WSAEADDRINUSE);
    CASE_OF(WSAEADDRNOTAVAIL);
    CASE_OF(WSAENETDOWN);
    CASE_OF(WSAENETUNREACH);
    CASE_OF(WSAENETRESET);
    CASE_OF(WSAECONNABORTED);
    CASE_OF(WSAECONNRESET);
    CASE_OF(WSAENOBUFS);
    CASE_OF(WSAEISCONN);
    CASE_OF(WSAENOTCONN);
    CASE_OF(WSAESHUTDOWN);
    CASE_OF(WSAETOOMANYREFS);
    CASE_OF(WSAETIMEDOUT);
    CASE_OF(WSAECONNREFUSED);
    CASE_OF(WSAELOOP);
    CASE_OF(WSAENAMETOOLONG);
    CASE_OF(WSAEHOSTDOWN);
    CASE_OF(WSAEHOSTUNREACH);
    CASE_OF(WSAENOTEMPTY);
    CASE_OF(WSAEPROCLIM);
    CASE_OF(WSAEUSERS);
    CASE_OF(WSAEDQUOT);
    CASE_OF(WSAESTALE);
    CASE_OF(WSAEREMOTE);
    CASE_OF(WSAEDISCON);
    CASE_OF(WSASYSNOTREADY);
    CASE_OF(WSAVERNOTSUPPORTED);
    CASE_OF(WSANOTINITIALISED);
    CASE_OF(WSAHOST_NOT_FOUND);
    CASE_OF(WSATRY_AGAIN);
    CASE_OF(WSANO_RECOVERY);
    CASE_OF(WSANO_DATA);

    default : return "?";
  }
}

LPSTR
MapCallbackToString(DWORD callback)
{
  switch(callback)
  {
    CASE_OF(WINHTTP_CALLBACK_STATUS_RESOLVING_NAME);
    CASE_OF(WINHTTP_CALLBACK_STATUS_NAME_RESOLVED);
    CASE_OF(WINHTTP_CALLBACK_STATUS_CONNECTING_TO_SERVER);
    CASE_OF(WINHTTP_CALLBACK_STATUS_CONNECTED_TO_SERVER);
    CASE_OF(WINHTTP_CALLBACK_STATUS_SENDING_REQUEST);
    CASE_OF(WINHTTP_CALLBACK_STATUS_REQUEST_SENT);
    CASE_OF(WINHTTP_CALLBACK_STATUS_RECEIVING_RESPONSE);
    CASE_OF(WINHTTP_CALLBACK_STATUS_RESPONSE_RECEIVED);
    CASE_OF(WINHTTP_CALLBACK_STATUS_CLOSING_CONNECTION);
    CASE_OF(WINHTTP_CALLBACK_STATUS_CONNECTION_CLOSED);
    CASE_OF(WINHTTP_CALLBACK_STATUS_HANDLE_CREATED);
    CASE_OF(WINHTTP_CALLBACK_STATUS_HANDLE_CLOSING);
    CASE_OF(WINHTTP_CALLBACK_STATUS_DETECTING_PROXY);
    CASE_OF(WINHTTP_CALLBACK_STATUS_REQUEST_COMPLETE);
    CASE_OF(WINHTTP_CALLBACK_STATUS_REDIRECT);
    CASE_OF(WINHTTP_CALLBACK_STATUS_INTERMEDIATE_RESPONSE);
    CASE_OF(WINHTTP_CALLBACK_STATUS_SECURE_FAILURE);
    CASE_OF(WINHTTP_CALLBACK_STATUS_HEADERS_AVAILABLE);
    CASE_OF(WINHTTP_CALLBACK_STATUS_DATA_AVAILABLE);
    CASE_OF(WINHTTP_CALLBACK_STATUS_READ_COMPLETE);
    CASE_OF(WINHTTP_CALLBACK_STATUS_WRITE_COMPLETE);
    CASE_OF(WINHTTP_CALLBACK_STATUS_REQUEST_ERROR);
    CASE_OF(WINHTTP_CALLBACK_STATUS_SENDREQUEST_COMPLETE);
  }

  return "unknown callback";
}

LPSTR
MapAsyncErrorToString(DWORD error)
{
  switch(error)
  {
    CASE_OF(API_RECEIVE_RESPONSE);
    CASE_OF(API_QUERY_DATA_AVAILABLE);
    CASE_OF(API_READ_DATA);
    CASE_OF(API_WRITE_DATA);
    CASE_OF(API_SEND_REQUEST);
    CASE_OF(API_UNKNOWN);
  }

  return MapErrorToString((INT)error);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\stress\stressscheduler\inc\debugger.h ===
#ifndef DEBUGGER_H
#define DEBUGGER_H

#define UNICODE
#define _UNICODE

#include <stdio.h>
#include <windows.h>
#include <tchar.h>
#include <dbghelp.h>

//Flags used for the call back function
//Used as input for call back

//Exceptions
#define DEBUGGER_FIRST_CHANCE_EXCEPTION		0x00000001
#define DEBUGGER_SECOND_CHANCE_EXCEPTION	0x00000002

//Other
#define DEBUGGER_FAILED_ATTACH				0x00000000
#define DEBUGGER_CREATE_THREAD				0x00000004
#define DEBUGGER_CREATE_PROCESS				0x00000008
#define DEBUGGER_EXIT_THREAD				0x00000010
#define DEBUGGER_EXIT_PROCESS				0x00000020
#define DEBUGGER_LOAD_DLL					0x00000040
#define DEBUGGER_UNLOAD_DLL					0x00000080
#define DEBUGGER_OUTPUT_DEBUG_STRING		0x00000100
#define DEBUGGER_RIP_EVENT					0x00000200

//Used as output for call back
#define DEBUGGER_CONTINUE_NORMAL			0x00100000
#define DEBUGGER_CONTINUE_UNHANDLED			0x00200000
#define DEBUGGER_CONTINUE_STOP_DEBUGGING	0x00400000

//Used for CreateMiniDump
#define DEBUGGER_CREATE_MINI_DUMP			0x00010000
#define DEBUGGER_CREATE_FULL_MINI_DUMP		0x00020000


//////////////////////////////////////////////////////////////////////////////////////////
//The call back function that will be passed into the constructor.
//
//	Parameters:
//		DWORD dwFlags	-- Flags that define what the debugger is reporting.  See above for definitions.
//		LPVOID lpIn		-- An object that the debugger passes back.  BUGBUG: Document what is passed back for each event.
//		LPTSTR lpszFutureString		-- For future use.
//		LPVOID lpFuturePointer		-- For future use.
//
//	Return Value:
//		The call back is expected to return one of the flags marked for output above.
///////////////////////////////////////////////////////////////////////////////////////////
//DWORD (*_pfnCallback)(DWORD dwFlags, LPVOID lpIn, LPTSTR lpszFutureString, LPVOID lpFuturePointer);


//////////////////////////////////////////////////////////////////////////////////////////
// Structures used internally in the Debugger Class
//////////////////////////////////////////////////////////////////////////////////////////
struct THREAD_HANDLE_ID
{
	HANDLE		hThread;
	DWORD		dwThreadID;
	DWORD_PTR	pNext;
};
///////////////////////////////////////////////////////////////////////////////////////////
//Debugger Class
//	Constructor take a dwPID (process pid) and a pointer to a callback function.
//
//	public functions:
//
//		BOOL __cdecl Go()			--	Attaches to the process and starts the debuging.
//		BOOL __cdecl CreateMiniDump	--	Creates a mini or full user dump of the process.
//		BOOL __cdecl IsActive		--	Returns true if the debugger is attached and running.
//
///////////////////////////////////////////////////////////////////////////////////////////
class Debugger
{
	public:
		Debugger(DWORD dwPID, LPVOID pfnCallback);

		Debugger::Debugger(	LPTSTR lptszProgram, 
							DWORD dwCreateProcessFlags, 
							LPSTARTUPINFO lpStartupInfo, 
							PROCESS_INFORMATION* pProcessInfo, 
							VOID *pfnCallback);

		~Debugger();

		HANDLE __cdecl Go();

		BOOL __cdecl Debugger::CreateMiniDump(LPTSTR lptszDumpFile, LPTSTR lptszComment, DWORD dwType);

		BOOL __cdecl IsActive() { return _bDebuggerActive; }


	private:
		//Private Functions
		friend DWORD WINAPI DebugProcess(LPVOID lpParameter);
		friend BOOL __cdecl DebugString(Debugger *debuggerObject, LPTSTR lptszDebugString);

		VOID __cdecl Initialize(DWORD dwPID, VOID *pfnCallback);
		VOID __cdecl Debugger::Initialize(DWORD dwPid);
		
		VOID __cdecl EnableDebugPrivileges();
		BOOL __cdecl InitTokenAdjustmentFunctions(HMODULE *phAdvapi32);

		HANDLE __cdecl GetThreadHandleFromThreadIDList(THREAD_HANDLE_ID *pNewThreadHandleIDStruct);
		HANDLE __cdecl GetThreadHandleFromThreadID(DWORD dwThreadID);
		VOID __cdecl AddNodeToThreadHandleIDList(THREAD_HANDLE_ID *pNewThreadHandleIDStruct);
		VOID __cdecl CleanUpThreadHandleIDList();

		//NT Only Functions
		BOOL (WINAPI *g_lpfnOpenProcessToken)(HANDLE,DWORD,PHANDLE);
		BOOL (WINAPI *g_lpfnLookupPrivilegeValueA)(LPCTSTR,LPCTSTR,PLUID);
		BOOL (WINAPI *g_lpfnAdjustTokenPrivileges)(HANDLE,BOOL,PTOKEN_PRIVILEGES,DWORD,PTOKEN_PRIVILEGES,PDWORD);


		//Private Variables
		DWORD_PTR				_pThreadInfoList;				//linked list of thread information
		THREAD_HANDLE_ID*		_pThreadHandleIDStruct;			//used for storing thread info in linked list
		LPDEBUG_EVENT			_lpDebugEvent;					//current debug event
		BOOL					_bFirstDebugBreak;				//ignores the first break point set by DebugActiveProcess
		DWORD					_dwDebugAction;					//specifies what to do when a debug even occurs
		DWORD					_dwPID;							//pid of process being debugged
		HANDLE					_hProcess;						//handle of proces being debugged
		HANDLE					_hThread;						//current thread
		CONTEXT					_Context;						//last set context
		DWORD					_dwDebugThreadID;				//thread id of the debugger
		HANDLE					_hDebugThreadHandle;			//handle to the debugger thread
		BOOL					_bDebuggerActive;				//flag to determine whether the debugger is active

		LPTSTR					_lptszProgram;					//program to run
		DWORD					_dwCreateProcessFlags;			//flags to use for CreateProcess
		LPSTARTUPINFO			_lpStartupInfo;					//startup info for CreateProcess
		PROCESS_INFORMATION*	_pProcessInfo;					//process info for CreateProcess
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\stress\stressapps\template\stresstesttemplate.cpp ===
//////////////////////////////////////////////////////////////////////
// File:  stressTest.cpp
//
// Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
// Purpose:
//		<Description>
//
// History:
//	mm/dd/yy	<alias>		Created
//
//////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////
// Includes
//////////////////////////////////////////////////////////////////////
#include "stressMain.h"


//////////////////////////////////////////////////////////////////////
// Globals and constants
//////////////////////////////////////////////////////////////////////

// ************************************
// ************************************
// ** Fill in your test case name below
// ** 
LPSTR	g_szStressTestName = "<Your Test Case Name>";


// Foward function definitions
VOID CALLBACK MyStatusCallback(
    HINTERNET	hInternet,
    DWORD		dwContext,
    DWORD		dwInternetStatus,
    LPVOID		lpvStatusInformation,
    DWORD		dwStatusInformationLength
);


////////////////////////////////////////////////////////////
// Function:  WinHttp_StressTest()
//
// Purpose:
//	The stress test function. Insert your test code here.
//	Returning TRUE will cause main() to call this function again.
//	Otherwise, returning FALSE will cause the app to exit.
//
//	If you plan to loop within this function, be sure to 
//	use IsTimeToExitStress() as one of your exit conditions.
//
//	This must be done because the stressScheduler will notify
//	a this stress app when to exit based on the state of the
//	inherited event object that IsTimeToExitStress() checks for.
//	IsTimeToExitStress() will return TRUE when it's time to exit.
//
////////////////////////////////////////////////////////////
BOOL
WinHttp_StressTest()
{
	BOOL		bContinueStress = TRUE;

	// ************************************
	// ************************************
	// ** Add you test case code here
	// ** 

Exit:
	return bContinueStress;
}


////////////////////////////////////////////////////////////
// Function:  MyStatusCallback(HINTERNET, DWORD, DWORD, LPVOID, DWORD)
//
// Purpose:
//		Status callback proc for WinHttp.
//
////////////////////////////////////////////////////////////
VOID CALLBACK MyStatusCallback(
    HINTERNET	hInternet,
    DWORD		dwContext,
    DWORD		dwInternetStatus,
    LPVOID		lpvStatusInformation,
    DWORD		dwStatusInformationLength
)
{
	switch(dwInternetStatus)
	{
		case WINHTTP_CALLBACK_STATUS_RESOLVING_NAME:
			LogText("\t[ WINHTTP_CALLBACK_STATUS_RESOLVING_NAME ]");
			break;
		case WINHTTP_CALLBACK_STATUS_NAME_RESOLVED:	
			LogText("\t[ WINHTTP_CALLBACK_STATUS_NAME_RESOLVED ]");
			break;
		case WINHTTP_CALLBACK_STATUS_CONNECTING_TO_SERVER:
			LogText("\t[ WINHTTP_CALLBACK_STATUS_CONNECTING_TO_SERVER ]");
			break;
		case WINHTTP_CALLBACK_STATUS_CONNECTED_TO_SERVER:
			LogText("\t[ WINHTTP_CALLBACK_STATUS_CONNECTED_TO_SERVER ]");
			break;
		case WINHTTP_CALLBACK_STATUS_SENDING_REQUEST:	
			LogText("\t[ WINHTTP_CALLBACK_STATUS_SENDING_REQUEST ]");
			break;
		case WINHTTP_CALLBACK_STATUS_REQUEST_SENT:	
			LogText("\t[ WINHTTP_CALLBACK_STATUS_REQUEST_SENT ]");
			break;
		case WINHTTP_CALLBACK_STATUS_RECEIVING_RESPONSE:
			LogText("\t[ WINHTTP_CALLBACK_STATUS_RECEIVING_RESPONSE ]");
			break;
		case WINHTTP_CALLBACK_STATUS_RESPONSE_RECEIVED:	
			LogText("\t[ WINHTTP_CALLBACK_STATUS_RESPONSE_RECEIVED ]");
			break;
		case WINHTTP_CALLBACK_STATUS_CLOSING_CONNECTION:
			LogText("\t[ WINHTTP_CALLBACK_STATUS_CLOSING_CONNECTION ]");
			break;
		case WINHTTP_CALLBACK_STATUS_CONNECTION_CLOSED:	
			LogText("\t[ WINHTTP_CALLBACK_STATUS_CONNECTION_CLOSED ]");
			break;
		case WINHTTP_CALLBACK_STATUS_HANDLE_CREATED:
			LogText("\t[ WINHTTP_CALLBACK_STATUS_HANDLE_CREATED ]");
			break;
		case WINHTTP_CALLBACK_STATUS_HANDLE_CLOSING:
			LogText("\t[ WINHTTP_CALLBACK_STATUS_HANDLE_CLOSING ]");
			break;
		case WINHTTP_CALLBACK_STATUS_DETECTING_PROXY:
			LogText("\t[ WINHTTP_CALLBACK_STATUS_DETECTING_PROXY ]");
			break;
		case WINHTTP_CALLBACK_STATUS_REDIRECT:
			LogText("\t[ WINHTTP_CALLBACK_STATUS_REDIRECT ]");
			break;
		case WINHTTP_CALLBACK_STATUS_INTERMEDIATE_RESPONSE:
			LogText("\t[ WINHTTP_CALLBACK_STATUS_INTERMEDIATE_RESPONSE ]");
			break;
		case WINHTTP_CALLBACK_STATUS_REQUEST_COMPLETE:
			LogText("\t[ WINHTTP_CALLBACK_STATUS_REQUEST_COMPLETE ]");
			break;
		default:
			LogText("\t[ INVALID status callack %u ]", dwInternetStatus);
			break;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\stress\stressscheduler\src\memstats.cpp ===
///////////////////////////////////////////////////////////////////////////
// File:  MemStats.cpp
//
// Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
// Purpose:
//	MemStats.cpp: Helper functions that get's the system memory info.
//	Borrowed from EricI's memstats app.
//
// History:
//	03/21/01	DennisCh	Created
//
//////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////
// Includes
//////////////////////////////////////////////////////////////////////


//
// WIN32 headers
//

//
// Project headers
//
#include "MemStats.h"
#include "NetworkTools.h"


//////////////////////////////////////////////////////////////////////
//
// Globals and statics
//
//////////////////////////////////////////////////////////////////////

PDH_STATUS (WINAPI *g_lpfnPdhOpenQuery)(LPCSTR, DWORD_PTR, HQUERY *);
PDH_STATUS (WINAPI *g_lpfnPdhAddCounter)(HQUERY, LPCSTR, DWORD_PTR, HCOUNTER *);
PDH_STATUS (WINAPI *g_lpfnPdhCollectQueryData)(HQUERY);
PDH_STATUS (WINAPI *g_lpfnPdhGetFormattedCounterValue)(HCOUNTER, DWORD, LPDWORD, PPDH_FMT_COUNTERVALUE);
PDH_STATUS (WINAPI *g_lpfnPdhRemoveCounter)(HCOUNTER);
PDH_STATUS (WINAPI *g_lpfnPdhCloseQuery)(HQUERY);


////////////////////////////////////////////////////////////////////////////
//
BOOL InitPdhLibrary(HMODULE *phPdhLib)
{ 
    BOOL    bRet = FALSE;

    *phPdhLib = LoadLibrary(_T("pdh.dll"));

    if(!*phPdhLib)
    {
        goto exit;
    }

	if(!(g_lpfnPdhOpenQuery = (PDH_STATUS (WINAPI *)(LPCSTR, DWORD_PTR, HQUERY *))GetProcAddress(*phPdhLib,"PdhOpenQueryA") ))
	{
		// LogString(LOG_BOTH,"missing export: PdhOpenQueryA\n");
		goto exit;
	}
	if(!(g_lpfnPdhAddCounter = (PDH_STATUS (WINAPI *)(HQUERY, LPCSTR, DWORD_PTR, HCOUNTER *))GetProcAddress(*phPdhLib,"PdhAddCounterA") ))
	{
		// LogString(LOG_BOTH,"missing export: PdhAddCounterA\n");
		goto exit;
	}
	if(!(g_lpfnPdhCollectQueryData = (PDH_STATUS (WINAPI *)(HQUERY))GetProcAddress(*phPdhLib,"PdhCollectQueryData") ))
	{
		// LogString(LOG_BOTH,"missing export: PdhCollectQueryData\n");
		goto exit;
	}
	if(!(g_lpfnPdhGetFormattedCounterValue = (PDH_STATUS (WINAPI *)(HCOUNTER, DWORD, LPDWORD, PPDH_FMT_COUNTERVALUE))GetProcAddress(*phPdhLib,"PdhGetFormattedCounterValue") ))
	{
		// LogString(LOG_BOTH,"missing export: PdhGetFormattedCounterValue\n");
		goto exit;
	}
	if(!(g_lpfnPdhRemoveCounter = (PDH_STATUS (WINAPI *)(HCOUNTER))GetProcAddress(*phPdhLib,"PdhRemoveCounter") ))
	{
		// LogString(LOG_BOTH,"missing export: PdhRemoveCounter\n");
		goto exit;
	}
	if(!(g_lpfnPdhCloseQuery = (PDH_STATUS (WINAPI *)(HQUERY))GetProcAddress(*phPdhLib,"PdhCloseQuery") ))
	{
		// LogString(LOG_BOTH,"missing export: PdhCloseQuery\n");
		goto exit;
	}
	
    bRet = TRUE;

exit:

    return bRet;
}


////////////////////////////////////////////////////////////
// Function:  EnableDebugPrivileges()
//
// Purpose:
//	Allows access to all processes.
//
////////////////////////////////////////////////////////////
void EnableDebugPrivileges()
{
    PTOKEN_PRIVILEGES   NewPrivileges   = NULL;
    HANDLE              hToken          = NULL;
    BYTE                OldPriv[1024];
    PBYTE               pbOldPriv;
    ULONG               cbNeeded;
    LUID                LuidPrivilege;


  //
    // Make sure we have access to adjust and to get the old token privileges
    //
    if(!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken)) 
    {
        // LogString(LOG_BOTH,"OpenProcessToken failed in EnableDebugPrivileges");
        goto exit;
    }

    cbNeeded = 0;

    //
    // Initialize the privilege adjustment structure
    //
	LookupPrivilegeValue(NULL,SE_DEBUG_NAME,&LuidPrivilege );

    NewPrivileges = (PTOKEN_PRIVILEGES)LocalAlloc(LMEM_ZEROINIT,sizeof(TOKEN_PRIVILEGES) + (1 - ANYSIZE_ARRAY) * sizeof(LUID_AND_ATTRIBUTES));
 
    if(!NewPrivileges) 
    {
        //  LogString(LOG_BOTH,"LocalAlloc failed in EnableDebugPrivileges");
        goto exit;
    }

    NewPrivileges->PrivilegeCount = 1;
    NewPrivileges->Privileges[0].Luid = LuidPrivilege;
    NewPrivileges->Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    pbOldPriv = OldPriv;

    //
    // Enable the privilege
    //
    if(!AdjustTokenPrivileges(hToken,FALSE,NewPrivileges,1024,(PTOKEN_PRIVILEGES)pbOldPriv,&cbNeeded))
    {
        // LogString(LOG_BOTH,"AdjustTokenPrivileges #1 failed in EnableDebugPrivileges");

        //
        // If the stack was too small to hold the privileges then allocate off the heap
        //
        if(GetLastError() == ERROR_INSUFFICIENT_BUFFER)
        {
            pbOldPriv = (PBYTE) LocalAlloc(LMEM_FIXED, cbNeeded);

            if(!pbOldPriv) 
            {
                // LogString(LOG_BOTH,"LocalAlloc failed in EnableDebugPrivileges");
                goto exit;
            }

            if(!AdjustTokenPrivileges(hToken,FALSE,NewPrivileges,cbNeeded,(PTOKEN_PRIVILEGES)pbOldPriv, &cbNeeded ))
                // LogString(LOG_BOTH,"AdjustTokenPrivileges #2 failed in EnableDebugPrivileges");

            LocalFree(pbOldPriv);
        }
    }


exit:

    if(NewPrivileges)
        LocalFree(NewPrivileges);

    if(hToken)
        CloseHandle(hToken);

    return;
}


////////////////////////////////////////////////////////////
// Function:  GetProcCntrs(PROC_CNTRS, INT, CHAR)
//
// Purpose:
//	Gets and returns the memory info for a given process.
//
////////////////////////////////////////////////////////////
BOOL
GetProcCntrs(
	PROC_CNTRS	*pProcCntrs,	// [OUT]	process memory counters
	INT			nIndex,			// [IN]		The index of the process if there's more than one.
	CHAR		*szProcess		// [IN]		Name of the process. ex "iexplore", "explorer"
)
{
	BOOL						bRet = FALSE;
	INT							n;
	HQUERY						hQuery = 0;
    HCOUNTER					aryHCounter [PROCCOUNTERS] = {0};
	PDH_FMT_COUNTERVALUE		cntVal;
	CHAR						myProcessCntrs[PROCCOUNTERS][1024];
	DWORD						dwPathSize = MAX_PATH;

	sprintf(myProcessCntrs[0],"\\Process(%s#%d)\\ID Process",szProcess,nIndex);
	sprintf(myProcessCntrs[1],"\\Process(%s#%d)\\Private bytes",szProcess,nIndex);
	sprintf(myProcessCntrs[2],"\\Process(%s#%d)\\Handle count",szProcess,nIndex);
	sprintf(myProcessCntrs[3],"\\Process(%s#%d)\\Thread count",szProcess,nIndex);


	if(!(ERROR_SUCCESS == g_lpfnPdhOpenQuery(0, 0, &hQuery)))
	   goto exit;

	for (n = 0; n < PROCCOUNTERS; n++) 
	{ 
		if(!(ERROR_SUCCESS == g_lpfnPdhAddCounter(hQuery,  myProcessCntrs[n], 0, &aryHCounter[n])))
			goto exit;
	}

	if(!(ERROR_SUCCESS == g_lpfnPdhCollectQueryData(hQuery)))
		goto exit;

	for (n=0; n < PROCCOUNTERS; n++) 
	{ 
		if(!(ERROR_SUCCESS == g_lpfnPdhGetFormattedCounterValue (aryHCounter[n],PDH_FMT_LONG,0,&cntVal)))
			goto exit;
        *((ULONG*)pProcCntrs+n) = cntVal.longValue;
	} 

	bRet = TRUE;

exit:
	for(n=0;n<PROCCOUNTERS;n++)
		if(aryHCounter[n])
			g_lpfnPdhRemoveCounter(aryHCounter[n]);

	if(hQuery)
		g_lpfnPdhCloseQuery(hQuery);

	return bRet;
}


////////////////////////////////////////////////////////////
// Function:  GetInfoForPID(PROC_CNTRS, ULONG, CHAR)
//
// Purpose:
//	Gets and returns the memory info for a given process.
//	We do this by going through every process with the same
//	name and comparing the PIDs.
//
////////////////////////////////////////////////////////////
BOOL
GetInfoForPID(
	PROC_CNTRS	*pc,		// [OUT]	Process memory counters for the PID
	ULONG		lPID,		// [IN]		PID for the process to query
	CHAR		*szProcess	// [IN]		Process name of the PID to query. ex. "explore", "iexplore". Don't include the extension
)
{
	BOOL	bRet = TRUE;
	INT		n = 0;
	
	while(bRet)
	{
		bRet = GetProcCntrs(pc,n,szProcess);
		if(lPID == pc->lPID)
			break;

		n++;
	}

	return bRet;
}



////////////////////////////////////////////////////////////
// Function:  GetMemoryCounters(MEM_CNTRS)
//
// Purpose:
//	Gets and returns the memory info for the system.
//
////////////////////////////////////////////////////////////
BOOL
GetMemoryCounters(
	MEM_CNTRS *pMemCounters	// [OUT] Memory counters for the current machine
)
{
	BOOL						bRet                        = FALSE;
	HQUERY						hQuery                      = 0;
    HCOUNTER					aryHCounter[MEMCOUNTERS]    = {0};
	DWORD						dwPathSize                  = MAX_PATH;
	int							n;
	PDH_FMT_COUNTERVALUE		cntVal;
	char						szAryMemoryCntrs[MEMCOUNTERS][1024];

	sprintf(szAryMemoryCntrs[0],"\\Memory\\Committed Bytes");
	sprintf(szAryMemoryCntrs[1],"\\Memory\\Commit Limit");
	sprintf(szAryMemoryCntrs[2],"\\Memory\\System Code Total Bytes");
	sprintf(szAryMemoryCntrs[3],"\\Memory\\System Driver Total Bytes");
	sprintf(szAryMemoryCntrs[4],"\\Memory\\Pool Nonpaged Bytes");
	sprintf(szAryMemoryCntrs[5],"\\Memory\\Pool Paged Bytes");
	sprintf(szAryMemoryCntrs[6],"\\Memory\\Available Bytes");
	sprintf(szAryMemoryCntrs[7],"\\Memory\\Cache Bytes");
	sprintf(szAryMemoryCntrs[8],"\\Memory\\Free System Page Table Entries");


	if(!(ERROR_SUCCESS == g_lpfnPdhOpenQuery (0, 0, &hQuery)))
	   goto exit;

	for (n = 0; n < MEMCOUNTERS; n++) 
	{ 
		if(!(ERROR_SUCCESS == g_lpfnPdhAddCounter (hQuery,  szAryMemoryCntrs[n], 0, &aryHCounter[n])))
        {
			goto exit;
        }
	}

	if(!(ERROR_SUCCESS == g_lpfnPdhCollectQueryData(hQuery)))
		goto exit;

	for (n=0; n < MEMCOUNTERS; n++) 
	{ 
		if(!(ERROR_SUCCESS == g_lpfnPdhGetFormattedCounterValue (aryHCounter[n],PDH_FMT_LONG,0,&cntVal)))
        {
			goto exit;
        }
        *((ULONG*)pMemCounters+n) = cntVal.longValue;
	} 

	bRet = TRUE;

exit:
	for(n=0;n<MEMCOUNTERS;n++)
    {
		if(aryHCounter[n])
        {
			g_lpfnPdhRemoveCounter(aryHCounter[n]);
        }
    }

	if(hQuery)
		g_lpfnPdhCloseQuery(hQuery);

	return bRet;
}


////////////////////////////////////////////////////////////
// Function:  GetAvailableSystemDriveSpace(long)
//
// Purpose:
//	Gets and returns the disk space available on the system drive.
//
////////////////////////////////////////////////////////////
BOOL 
GetAvailableSystemDriveSpace(
	long	*lAvail		// [OUT] Buffer containing the space on the system drive
)
{
    BOOL                bRet    = FALSE;
    char                szSystemPath[MAX_PATH];
    ULARGE_INTEGER      FreeBytesAvailable;         // bytes available to caller
    ULARGE_INTEGER      TotalNumberOfBytes;         // bytes on disk
    ULARGE_INTEGER      TotalNumberOfFreeBytes;     // free bytes on disk
    int                 i;
    DWORD               dwFoo = 0;

    if(!GetSystemDirectoryA(szSystemPath,sizeof(szSystemPath)))
    {
        goto exit;
    }

    //We only want the drive letter
    for(i=0; i<1+lstrlenA(szSystemPath); i++)
    {
        if(szSystemPath[i] == 0)
        {
            goto exit;
        }

        if(szSystemPath[i] == '\\')
        {
            szSystemPath[i+1] = 0;
            break;
        }
    }

    if(GetDiskFreeSpaceExA(szSystemPath,&FreeBytesAvailable,&TotalNumberOfBytes,&TotalNumberOfFreeBytes))
    {
        *lAvail = __int32(TotalNumberOfFreeBytes.QuadPart / 1024 / 1000);
        bRet = TRUE;
    }

exit:
    return bRet;
}


////////////////////////////////////////////////////////////
// Function:  MemStats__SendSystemMemoryLog(LPSTR, DWORD, DWORD)
//
// Purpose:
//	Sends a memory log to the Command Server.
//	Sends the stressInstance ID and client machine name as part of the POST request.
//
////////////////////////////////////////////////////////////
BOOL
MemStats__SendSystemMemoryLog(
	LPSTR szExeName,			// [IN] Name of the process. ex. "explorer", "iexplorer". No extension.
	DWORD dwPID,				// [IN] PID for the above process
	DWORD dwStressInstanceID	// [IN] The stress instanceID
)
{
    BOOL            bResult				= TRUE;
    MEM_CNTRS       mc					= {0};
    long			lAvailDriveSpace	= 0;
	HMODULE         hPdhLib				= NULL;
	DWORD			dwPostDataSize		= MAX_PATH*10;
	DWORD			dwDataFieldSize		= 100;
	LPSTR			szPostData			= NULL;
	LPSTR			szDataField			= NULL;
	LPSTR			szFileName			= NULL;
	PROC_CNTRS		pc;

	szPostData			= new CHAR[dwPostDataSize];
	szDataField			= new CHAR[dwDataFieldSize];
	szFileName			= new CHAR[MAX_PATH];
	if (!szPostData || !szDataField || !szFileName)
		goto Exit;

	// Remove the extension from the filename if there is one
	ZeroMemory(szFileName, MAX_PATH);
	strncpy(szFileName, szExeName, MAX_PATH);
	PathRemoveExtensionA(szFileName);


	ZeroMemory(szPostData,	dwPostDataSize);
	ZeroMemory(szDataField,	dwDataFieldSize);


	// *** !!! need this because NetworkTools__SendLog(...) sends szPost data as fieldname "LogText="
	// so we need an & to delimit memory info fields from "real" log text.
	strcat(szPostData, "&");

	// *************************
	// *************************
	// ** Get process info
	// **
    if(!InitPdhLibrary(&hPdhLib))
	{
		OutputDebugString(_T("MemStats__SendSystemMemoryLog: Could not load PDH.DLL. Exiting..."));
		bResult = FALSE;
        goto Exit;
	}


	EnableDebugPrivileges();

	if (szFileName && GetInfoForPID(&pc, dwPID, szFileName))
	{
		sprintf(szDataField, FIELDNAME__STRESSEXE_HANDLECOUNT,		pc.lHandles);
		strcat(szPostData, szDataField);
		strcat(szPostData, "&");

		sprintf(szDataField, FIELDNAME__STRESSEXE_THREADCOUNT,		pc.lThreads);
		strcat(szPostData, szDataField);
		strcat(szPostData, "&");

		sprintf(szDataField, FIELDNAME__STRESSEXE_PRIVATEBYTES,		pc.lPrivBytes);
		strcat(szPostData, szDataField);
		strcat(szPostData, "&");
	}

	// *************************
	// *************************
	// ** Get system memory info
	// **
	if (GetMemoryCounters(&mc))
    {
		sprintf(szDataField, FIELDNAME__MEMORY_COMMITTEDPAGEFILETOTAL,		mc.lCommittedBytes/1024);
		strcat(szPostData, szDataField);
		strcat(szPostData, "&");

		sprintf(szDataField, FIELDNAME__MEMORY_AVAILABLEPAGEFILETOTAL,		(mc.lCommitLimit - mc.lCommittedBytes)/1024);
		strcat(szPostData, szDataField);
		strcat(szPostData, "&");
		
		sprintf(szDataField, FIELDNAME__MEMORY_SYSTEMCODETOTAL,				mc.lSystemCodeTotalBytes/1024);
		strcat(szPostData, szDataField);
		strcat(szPostData, "&");
		
		sprintf(szDataField, FIELDNAME__MEMORY_SYSTEMDRIVERTOTAL,			mc.lSystemDriverTotalBytes/1024);
		strcat(szPostData, szDataField);
		strcat(szPostData, "&");
		
		sprintf(szDataField, FIELDNAME__MEMORY_NONPAGEDPOOLTOTAL,			mc.lPoolNonpagedBytes/1024);
		strcat(szPostData, szDataField);
		strcat(szPostData, "&");
		
		sprintf(szDataField, FIELDNAME__MEMORY_PAGEDPOOLTOTAL,				mc.lPoolPagedBytes/1024);
		strcat(szPostData, szDataField);
		strcat(szPostData, "&");
		
		sprintf(szDataField, FIELDNAME__MEMORY_PHYSICAL_MEMORY_AVAILABLE,	mc.lAvailableBytes/1024);
		strcat(szPostData, szDataField);
		strcat(szPostData, "&");
		
		sprintf(szDataField, FIELDNAME__MEMORY_SYSTEMCACHETOTAL,			mc.lCacheBytes/1024);
		strcat(szPostData, szDataField);
		strcat(szPostData, "&");
		
		sprintf(szDataField, FIELDNAME__MEMORY_FREESYSTEM_PAGETABLE_ENTRIES,mc.lFreeSystemPageTableEntries);
		strcat(szPostData, szDataField);
		strcat(szPostData, "&");
    }


	// *************************
	// *************************
	// ** Get disk space info
	// **
    if (GetAvailableSystemDriveSpace(&lAvailDriveSpace))
	{
		sprintf(szDataField, FIELDNAME__MEMORY_DISK_SPACE_AVAILABLE, lAvailDriveSpace);
		strcat(szPostData, szDataField);
		strcat(szPostData, "&");
	}

	NetworkTools__SendLog(FIELDNAME__LOGTYPE_MEMORY_INFORMATION, szPostData, NULL, dwStressInstanceID);


Exit:
	if(hPdhLib)
        FreeLibrary(hPdhLib);

	if (szPostData)
		delete [] szPostData;

	if (szDataField)
		delete [] szDataField;

	if (szFileName)
		delete [] szFileName;

    return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\stress\stressscheduler\src\servercommands.cpp ===
///////////////////////////////////////////////////////////////////////////
// File:  WinHttpStressScheduler.cpp
//
// Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
// Purpose:
//	ServerCommands.cpp: implementation of the ServerCommands class.
//	This class is used to retrieve and act on command from the server.
//
// History:
//	02/08/01	DennisCh	Created
//
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
// Includes
//////////////////////////////////////////////////////////////////////

//
// WIN32 headers
//

//
// Project headers
//
#include "ServerCommands.h"
#include "NetworkTools.h"


//////////////////////////////////////////////////////////////////////
// Globals and statics
//////////////////////////////////////////////////////////////////////

HANDLE				g_hQueryServerForCommands;	// Handle for the thread that queries the server for commands
CRITICAL_SECTION	g_csServerCommandsVars;		// For protecting CommandServer private member vars. Used in the QueryServerForCommands_ThreadProc.

extern ServerCommands g_objServerCommands;		// Declared in WinHttpStressScheduler.cpp


////////////////////////////////////////////////////////////
// Function:  QueryServerForCommands_ThreadProc(LPVOID)
//
// Purpose:
//	This method sends a request to the command server for instructions
//	and saves them in the public vars of ServerCommands.
//
////////////////////////////////////////////////////////////
DWORD
WINAPI
QueryServerForCommands_ThreadProc(
	LPVOID lpParam	// [IN] thread proc param
)
{
	BOOL			bResult		= TRUE;
	HINTERNET		hRoot		= NULL;
	HINTERNET		hSession	= NULL;
	HINTERNET		hRequest	= NULL;
	URL_COMPONENTSW	urlComponents;

	DWORD	dwStressInstanceID;
	DWORD	dwPageHeapCommandIndex,
			dwUMDHCommandIndex,
			dwStressPDBIndex,
			dwStressSYMIndex,
			dwStressMemDmpPathIndex,
			dwStressInstanceIDIndex;
	LPTSTR	szPageheapCommand,
			szUMDHCommand,
			szStressPDB_URL,
			szStressSYM_URL,
			szStressMemDmpPath,
			szStressInstanceID;
	LPSTR	szPost;

	szPost				= NULL;
	szPageheapCommand	= NULL;
	szUMDHCommand		= NULL;
	szStressPDB_URL		= NULL;
	szStressSYM_URL		= NULL;
	szStressMemDmpPath	= NULL;
	szStressInstanceID	= NULL;


	// Allocate space for URL components
	ZeroMemory(&urlComponents, sizeof(urlComponents));

	__try
	{
		urlComponents.dwSchemeLength	= MAX_PATH;
		urlComponents.lpszScheme		= new TCHAR[MAX_PATH];

		urlComponents.dwHostNameLength  = MAX_PATH;
		urlComponents.lpszHostName		= new TCHAR[MAX_PATH];

		urlComponents.dwUrlPathLength	= MAX_PATH;
		urlComponents.lpszUrlPath		= new TCHAR[MAX_PATH];

		urlComponents.dwExtraInfoLength = MAX_PATH;
		urlComponents.lpszExtraInfo		= new TCHAR[MAX_PATH];
		
		urlComponents.dwUserNameLength	= MAX_PATH;
		urlComponents.lpszUserName		= new TCHAR[MAX_PATH];

		urlComponents.dwPasswordLength	= MAX_PATH;
		urlComponents.lpszPassword		= new TCHAR[MAX_PATH];
		
		urlComponents.nPort				= 0;

		urlComponents.dwStructSize		= sizeof(URL_COMPONENTSW);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		goto Exit;
	}

	if (!urlComponents.lpszScheme	|| !urlComponents.lpszHostName	||
		!urlComponents.lpszUrlPath	|| !urlComponents.lpszExtraInfo	||
		!urlComponents.lpszUserName	|| !urlComponents.lpszPassword)
	{
		goto Exit;
	}

	// crack the Command Server URL to be used later
	if (!WinHttpCrackUrl(
			g_objServerCommands.Get_CommandServerURL(),
			_tcslen(g_objServerCommands.Get_CommandServerURL()),
			ICU_ESCAPE,
			&urlComponents)
		)
	{
		bResult = FALSE;
		goto Exit;
	}

	hRoot = WinHttpOpen(
		STRESS_SCHEDULER_USER_AGENT,
		WINHTTP_ACCESS_TYPE_NO_PROXY,
		NULL,
		NULL,
		0);

	if (!hRoot)
	{
		bResult = FALSE;
		goto Exit;
	}

	hSession = WinHttpConnect(
		hRoot,
		urlComponents.lpszHostName,
		// If the URL in urlComponents uses standard HTTP or HTTPS ports then use INTERNET_DEFAULT_PORT. Otherwise use the non-standard port gleaned from the URL.
		((urlComponents.nPort == 80) || (urlComponents.nPort == 443)) ? INTERNET_DEFAULT_PORT : urlComponents.nPort,
		0);
	
	if (!hSession)
	{
		bResult = FALSE;
		goto Exit;
	}


	// Build a full URL with path and querystring
	TCHAR szFullPath[MAX_PATH*2];

	ZeroMemory(szFullPath, sizeof(szFullPath));
	_tcsncpy(szFullPath, urlComponents.lpszUrlPath, urlComponents.dwUrlPathLength);
	//szFullPath[urlComponents.dwUrlPathLength] = _T('\0');
	_tcsncat(szFullPath, urlComponents.lpszExtraInfo, urlComponents.dwExtraInfoLength);

	hRequest = WinHttpOpenRequest(
		hSession,
		_T("POST"),
		szFullPath,
		NULL,
		NULL,
		NULL,
		// if the URL in urlComponents uses HTTPS then pass in WINHTTP_FLAG_SECURE to this param. Otherwise, 0.
		(0 == _tcsnicmp(urlComponents.lpszScheme, _T("https"), 5)) ? WINHTTP_FLAG_SECURE : 0);

	if (!hRequest)
	{
		bResult = FALSE;
		goto Exit;
	}


	// Set reasonable timeouts just in case
	if (!WinHttpSetTimeouts(hRequest, 5000, 5000, 5000, 5000))
	{
		bResult = FALSE;
		goto Exit;
	}

	// Get the computer name and send it in a POST request
	__try
	{
		szPost			= new CHAR[MAX_PATH*2];
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		szPost = NULL;
		goto Exit;
	}

	if (!szPost)
		goto Exit;

	ZeroMemory(szPost, MAX_PATH*2);
	sprintf(szPost, "%s%u", FIELDNAME__CLIENT_ID, g_objServerCommands.Get_ClientID());

	bResult = WinHttpSendRequest(
		hRequest,
		_T("Content-Type: application/x-www-form-urlencoded"),
		-1L, 
		szPost,
		strlen(szPost),
		strlen(szPost),
		0);

	if (szPost)
	{
		delete [] szPost;
		szPost	= NULL;
	}


	if (!WinHttpReceiveResponse(hRequest, NULL))
	{
		bResult = FALSE;
		goto Exit;
	}



	TCHAR	szBuffer[MAX_URL];
	DWORD	dwBufferSize, dwIndex;


	// get all command headers that we're interested in.
	// make sure there are no pending operations on member vars (pServerCommands->Set_* functions)
	EnterCriticalSection(&g_csServerCommandsVars);


	// *********************************
	// **** COMMANDHEADER__EXIT: Exit if header is present, else continue.
	dwIndex			= 0;
	dwBufferSize	= MAX_URL;
	ZeroMemory(szBuffer, sizeof(szBuffer));
	if (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM, COMMANDHEADER__EXIT, szBuffer, &dwBufferSize, &dwIndex))
		g_objServerCommands.Set_ExitStress(TRUE);
	else
		g_objServerCommands.Set_ExitStress(FALSE);


	// *********************************
	// **** COMMANDHEADER__WINHTTP_DLL_URL: valid values: Valid URL
	dwIndex			= 0;
	dwBufferSize	= MAX_URL;
	ZeroMemory(szBuffer, sizeof(szBuffer));
	if (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM, COMMANDHEADER__WINHTTP_DLL_URL, szBuffer, &dwBufferSize, &dwIndex))
		g_objServerCommands.Set_WinHttpDllURL(szBuffer, dwBufferSize);
	else
		bResult = FALSE;


	// *********************************
	// **** COMMANDHEADER__WINHTTP_PDB_URL: valid values: Valid URL
	dwIndex			= 0;
	dwBufferSize	= MAX_URL;
	ZeroMemory(szBuffer, sizeof(szBuffer));
	if (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM, COMMANDHEADER__WINHTTP_PDB_URL, szBuffer, &dwBufferSize, &dwIndex))
		g_objServerCommands.Set_WinHttpPDBURL(szBuffer, dwBufferSize);
	else
		bResult = FALSE;


	// *********************************
	// **** COMMANDHEADER__WINHTTP_SYM_URL: valid values: Valid URL
	dwIndex			= 0;
	dwBufferSize	= MAX_URL;
	ZeroMemory(szBuffer, sizeof(szBuffer));
	if (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM, COMMANDHEADER__WINHTTP_SYM_URL, szBuffer, &dwBufferSize, &dwIndex))
		g_objServerCommands.Set_WinHttpSYMURL(szBuffer, dwBufferSize);
	else
		bResult = FALSE;


	// *********************************
	// **** COMMANDHEADER__COMMANDSERVER_URL: valid values: Valid URL
	dwIndex			= 0;
	dwBufferSize	= MAX_URL;
	ZeroMemory(szBuffer, sizeof(szBuffer));
	if (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM, COMMANDHEADER__COMMANDSERVER_URL, szBuffer, &dwBufferSize, &dwIndex))
		g_objServerCommands.Set_CommandServerURL(szBuffer, dwBufferSize);
	else
		bResult = FALSE;


	// *********************************
	// **** COMMANDHEADER__BEGIN_TIME_HOUR: valid values: Valid string from 0-23
	dwIndex			= 0;
	dwBufferSize	= MAX_URL;
	ZeroMemory(szBuffer, sizeof(szBuffer));
	if (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM, COMMANDHEADER__BEGIN_TIME_HOUR, szBuffer, &dwBufferSize, &dwIndex))
		g_objServerCommands.Set_TimeStressBegins(szBuffer, NULL);
	else
		bResult = FALSE;


	// *********************************
	// **** COMMANDHEADER__BEGIN_TIME_MINUTE: valid values: Valid string from 0-59
	dwIndex			= 0;
	dwBufferSize	= MAX_URL;
	ZeroMemory(szBuffer, sizeof(szBuffer));
	if (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM, COMMANDHEADER__BEGIN_TIME_MINUTE, szBuffer, &dwBufferSize, &dwIndex))
		g_objServerCommands.Set_TimeStressBegins(NULL, szBuffer);
	else
		bResult = FALSE;


	// *********************************
	// **** COMMANDHEADER__END_TIME_HOUR: valid values: Valid string from 0-23
	dwIndex			= 0;
	dwBufferSize	= MAX_URL;
	ZeroMemory(szBuffer, sizeof(szBuffer));
	if (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM, COMMANDHEADER__END_TIME_HOUR, szBuffer, &dwBufferSize, &dwIndex))
		g_objServerCommands.Set_TimeStressEnds(szBuffer, NULL);
	else
		bResult = FALSE;


	// *********************************
	// **** COMMANDHEADER__END_TIME_MINUTE: valid values: Valid string from 0-59
	dwIndex			= 0;
	dwBufferSize	= MAX_URL;
	ZeroMemory(szBuffer, sizeof(szBuffer));
	if (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM, COMMANDHEADER__END_TIME_MINUTE, szBuffer, &dwBufferSize, &dwIndex))
		g_objServerCommands.Set_TimeStressEnds(NULL, szBuffer);
	else
		bResult = FALSE;


	// *********************************
	// **** COMMANDHEADER__RUN_FOREVER: valid values: doesn't matter. As long as header is present it gets sent
	dwIndex			= 0;
	dwBufferSize	= MAX_URL;
	ZeroMemory(szBuffer, sizeof(szBuffer));
	if (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM, COMMANDHEADER__RUN_FOREVER, szBuffer, &dwBufferSize, &dwIndex))
		g_objServerCommands.Set_RunForever(TRUE);


	// *********************************
	// **** COMMANDHEADER__DO_NOT_RUN_FOREVER: valid values: doesn't matter. As long as header is present it gets sent
	dwIndex			= 0;
	dwBufferSize	= MAX_URL;
	ZeroMemory(szBuffer, sizeof(szBuffer));
	if (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM, COMMANDHEADER__DO_NOT_RUN_FOREVER, szBuffer, &dwBufferSize, &dwIndex))
		g_objServerCommands.Set_RunForever(FALSE);


	// *********************************
	// **** COMMANDHEADER__UPDATE_INTERVAL: valid values: Valid string in INTERNET_RFC1123 format
	DWORD			dwTimeOut;
	dwTimeOut		= 0;
	dwIndex			= 0;
	dwBufferSize	= sizeof(DWORD);
	ZeroMemory(szBuffer, sizeof(szBuffer));
	if (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM | WINHTTP_QUERY_FLAG_NUMBER, COMMANDHEADER__UPDATE_INTERVAL, &dwTimeOut, &dwBufferSize, &dwIndex))
		g_objServerCommands.Set_CommandServerUpdateInterval(dwTimeOut);
	else
		bResult = FALSE;



	// *********************************
	// *********************************
	// **** Query commands for building stress Instance objects
	// ****
	// **** COMMANDHEADER__STRESS_EXE_URL: valid values: Valid URL
	__try
	{
		szPageheapCommand	= new TCHAR[MAX_PATH];
		szUMDHCommand		= new TCHAR[MAX_PATH];
		szStressPDB_URL		= new TCHAR[MAX_STRESS_URL];
		szStressSYM_URL		= new TCHAR[MAX_STRESS_URL];
		szStressMemDmpPath	= new TCHAR[MAX_PATH];
		szStressInstanceID	= new TCHAR[MAX_PATH];
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		goto Exit;
	}

	if (!szPageheapCommand	|| !szUMDHCommand	||
		!szStressPDB_URL	|| !szStressSYM_URL	||
		!szStressMemDmpPath	|| !szStressInstanceID)
	{
		goto Exit;
	}

	if (!g_objServerCommands.IsStressRunning())
	{
		// free all old StressExeURLs first - we're replacing it with new URLs anyway
		g_objServerCommands.Clear_StressExeURLs();

		dwIndex					= 0;
		dwStressInstanceIDIndex	= 0;
		dwPageHeapCommandIndex	= 0;
		dwUMDHCommandIndex		= 0;
		dwStressPDBIndex		= 0;
		dwStressSYMIndex		= 0;
		dwStressMemDmpPathIndex	= 0;
		dwBufferSize			= MAX_URL;
		ZeroMemory(szBuffer, sizeof(szBuffer));

		while (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM, COMMANDHEADER__STRESS_EXE_URL, szBuffer, &dwBufferSize, &dwIndex))
		{
			// *************************************
			// *************************************
			// ** COMMANDHEADER__MEMORY_DUMP_PATH: A valid path
			ZeroMemory(szStressMemDmpPath, MAX_PATH);
			dwBufferSize	= MAX_PATH;
			WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM, COMMANDHEADER__MEMORY_DUMP_PATH, szStressMemDmpPath, &dwBufferSize, &dwStressMemDmpPathIndex);


			// *************************************
			// *************************************
			// ** Get COMMANDHEADER__STRESS_PDB_URL if there is one
			// **
			ZeroMemory(szStressPDB_URL, MAX_STRESS_URL);
			dwBufferSize	= MAX_STRESS_URL;
			WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM, COMMANDHEADER__STRESS_PDB_URL, szStressPDB_URL, &dwBufferSize, &dwStressPDBIndex);


			// *************************************
			// *************************************
			// ** Get COMMANDHEADER__STRESS_SYM_URL if there is one
			// **
			ZeroMemory(szStressSYM_URL, MAX_STRESS_URL);
			dwBufferSize	= MAX_STRESS_URL;
			WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM, COMMANDHEADER__STRESS_SYM_URL, szStressSYM_URL, &dwBufferSize, &dwStressSYMIndex);


			// *************************************
			// *************************************
			// ** Get COMMANDHEADER__STRESS_EXE_PAGEHEAP if there is one
			// **
			ZeroMemory(szPageheapCommand, MAX_PATH);
			dwBufferSize	= MAX_PATH;
			WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM, COMMANDHEADER__STRESS_EXE_PAGEHEAP, szPageheapCommand, &dwBufferSize, &dwPageHeapCommandIndex);

			// *************************************
			// *************************************
			// ** Get COMMANDHEADER__STRESS_EXE_UMDH if there is one
			// **
			ZeroMemory(szUMDHCommand, MAX_PATH);
			dwBufferSize	= MAX_PATH;
			WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM, COMMANDHEADER__STRESS_EXE_UMDH, szUMDHCommand, &dwBufferSize, &dwUMDHCommandIndex);
			

			// *************************************
			// *************************************
			// ** Get COMMANDHEADER__STRESS_EXE_INSTANCEID
			// For each COMMANDHEADER__STRESS_EXE_URL, there must be an index for the stress instance from the StressADMIN DB table.
			// This identifies the stressinstance run. The test case (stressinstance) WILL NOT be added and run without an ID number.
			ZeroMemory(szStressInstanceID, MAX_PATH);
			dwBufferSize	= MAX_PATH;

			if (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM, COMMANDHEADER__STRESS_EXE_INSTANCEID, szStressInstanceID, &dwBufferSize, &dwStressInstanceIDIndex))
			{
				// convert header ID string to a DWORD
				dwStressInstanceID = _ttol(szStressInstanceID);

				// only add valid stressInstances with valid ID's
				if (0 < dwStressInstanceID)
				{
					g_objServerCommands.Create_StressInstance(
						dwStressInstanceID,
						szPageheapCommand,
						szUMDHCommand,
						szStressPDB_URL,
						szStressSYM_URL,
						szStressMemDmpPath,
						szBuffer);

					dwBufferSize = MAX_URL;
					ZeroMemory(szBuffer, MAX_URL);
				}
			}
		}
	}


	// *********************************
	// **** COMMANDHEADER__ABORT: Abort the stress instance running specified by this header.
	dwIndex			= 0;
	dwBufferSize	= MAX_URL;
	ZeroMemory(szBuffer, sizeof(szBuffer));
	while (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_CUSTOM, COMMANDHEADER__ABORT, szBuffer, &dwBufferSize, &dwIndex))
		g_objServerCommands.AbortStressInstance(_ttol(szBuffer));


Exit:
	LeaveCriticalSection(&g_csServerCommandsVars);

	if (hRequest)
		WinHttpCloseHandle(hRequest);

	if (hSession)
		WinHttpCloseHandle(hSession);

	if (hRoot)
		WinHttpCloseHandle(hRoot);

	// free memory if allocs succeeded
	if (urlComponents.lpszScheme)
		delete [] urlComponents.lpszScheme;

	if (urlComponents.lpszHostName)
		delete [] urlComponents.lpszHostName;

	if (urlComponents.lpszUrlPath)
		delete [] urlComponents.lpszUrlPath;

	if (urlComponents.lpszExtraInfo)
		delete [] urlComponents.lpszExtraInfo;

	if (urlComponents.lpszUserName)
		delete [] urlComponents.lpszUserName;

	if (urlComponents.lpszPassword)
		delete [] urlComponents.lpszPassword;

	// more to go
	if (szPageheapCommand)
		delete [] szPageheapCommand;

	if (szUMDHCommand)
		delete [] szUMDHCommand;

	if (szStressPDB_URL)
		delete [] szStressPDB_URL;

	if (szStressSYM_URL)
		delete [] szStressSYM_URL;

	if (szStressMemDmpPath)
		delete [] szStressMemDmpPath;

	if (szStressInstanceID)
		delete [] szStressInstanceID;

	if (szPost)
		delete [] szPost;
	
	ExitThread(bResult);
}




// *******************************************************************
// *******************************************************************
// ****
// **** ServerCommands class member functions
// ****

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

ServerCommands::ServerCommands()
{
	m_dwCommandServerUpdateInternval	= STRESS_COMMAND_SERVER_UPDATE_INTERVAL;
	m_bExit								= FALSE;
	m_dwStressInstanceIterator			= NULL;
	g_hQueryServerForCommands			= NULL;

	m_szCommandServerURL				= new TCHAR[MAX_STRESS_URL];
	m_szWinHttpDLL_DownloadURL			= new TCHAR[MAX_STRESS_URL];
	m_szWinHttpPDB_DownloadURL			= new TCHAR[MAX_STRESS_URL];
	m_szWinHttpSYM_DownloadURL			= new TCHAR[MAX_STRESS_URL];
	m_szWinHttpDLL_FileName				= new TCHAR[MAX_PATH];
	m_szStressSchedulerCurrentDirectory	= new TCHAR[MAX_PATH];
	m_szClientMachineName				= new CHAR[MAX_PATH];

	ZeroMemory(m_szCommandServerURL,				MAX_STRESS_URL);
	ZeroMemory(m_szWinHttpDLL_DownloadURL,			MAX_STRESS_URL);
	ZeroMemory(m_szWinHttpPDB_DownloadURL,			MAX_STRESS_URL);
	ZeroMemory(m_szWinHttpSYM_DownloadURL,			MAX_STRESS_URL);
	ZeroMemory(m_szWinHttpDLL_FileName,				MAX_PATH);
	ZeroMemory(m_szStressSchedulerCurrentDirectory, MAX_PATH);
	ZeroMemory(m_szClientMachineName,				MAX_PATH);

	// initilize start/end times to -1 so we know that
	// there are not valid time and we'll skip the Begin/End stress time check
	// until we get real values from the command server
	m_iTimeStressBeginsHour		= -1;
	m_iTimeStressBeginsMinute	= -1;
	m_iTimeStressEndsHour		= -1;
	m_iTimeStressEndsMinute		= -1;
	m_bRunForever				= 0;

	m_dwClientID				= 0;


	// Set default URLs
	wcsncpy(m_szCommandServerURL, STRESS_COMMAND_SERVER_URL, sizeof(STRESS_COMMAND_SERVER_URL));

	// Get the current working directory
	GetCurrentDirectory(MAX_PATH, m_szStressSchedulerCurrentDirectory);

	// Get the client's machine name
	GetEnvironmentVariableA("COMPUTERNAME", m_szClientMachineName, MAX_PATH);

	InitializeCriticalSection(&g_csServerCommandsVars);
}


ServerCommands::~ServerCommands()
{
	DWORD	dwThreadExitCode	= 0;

	// Shut down QueryServer thread
	GetExitCodeThread(g_hQueryServerForCommands, &dwThreadExitCode);

	if (STILL_ACTIVE == dwThreadExitCode)
		WaitForSingleObject(g_hQueryServerForCommands, INFINITE);

	// free allocated memory for URLs
	Clear_StressExeURLs();

	// Free our handles
	CloseHandle(g_hQueryServerForCommands);
	DeleteCriticalSection(&g_csServerCommandsVars);


	if (m_szCommandServerURL)
		delete [] m_szCommandServerURL;

	if (m_szWinHttpDLL_DownloadURL)
		delete [] m_szWinHttpDLL_DownloadURL;

	if (m_szWinHttpPDB_DownloadURL)
		delete [] m_szWinHttpPDB_DownloadURL;

	if (m_szWinHttpSYM_DownloadURL)
		delete [] m_szWinHttpSYM_DownloadURL;

	if (m_szWinHttpDLL_FileName)
		delete [] m_szWinHttpDLL_FileName;

	if (m_szStressSchedulerCurrentDirectory)
		delete [] m_szStressSchedulerCurrentDirectory;

	if (m_szClientMachineName)
		delete [] m_szClientMachineName;
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::GetCurrentWorkingDirectory()
//
// Purpose:
//	Returns string containing the current working directory for
//	this application.
//
////////////////////////////////////////////////////////////
LPTSTR
ServerCommands::Get_CurrentWorkingDirectory()
{
	return m_szStressSchedulerCurrentDirectory;
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::Get_ClientMachineName()
//
// Purpose:
//	Returns string containing the machine's NETBIOS name
//
////////////////////////////////////////////////////////////
LPSTR
ServerCommands::Get_ClientMachineName()
{
	return m_szClientMachineName;
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::QueryServerForCommands()
//
// Purpose:
//	This method sends a request to the command server for instructions
//	and saves them in our private vars. 
//
////////////////////////////////////////////////////////////
ServerCommands::QueryServerForCommands()
{
	BOOL	bResult				= TRUE;
	DWORD	dwThreadID			= 0;
	DWORD	dwTimeOut			= 0;
	DWORD	dwThreadExitCode	= 0;

	// See if thread is still active before spinning off a new one
	GetExitCodeThread(g_hQueryServerForCommands, &dwThreadExitCode);

	if (STILL_ACTIVE == dwThreadExitCode)
	{
		// wait for existing thread to finish
		dwTimeOut = 0;
		dwTimeOut = WaitForSingleObject(g_hQueryServerForCommands, 500);

		if (WAIT_TIMEOUT == dwTimeOut)
			bResult = FALSE;
	}
	else
	{
		// free handle for previous thread
		CloseHandle(g_hQueryServerForCommands);

		// spin off thread to query server
		g_hQueryServerForCommands = NULL;
		g_hQueryServerForCommands = CreateThread(NULL, 0, QueryServerForCommands_ThreadProc, (LPVOID) this, 0, &dwThreadID);

		if (!g_hQueryServerForCommands)
			bResult = FALSE;
	}

	return bResult;
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::Download_WinHttpDLL()
//
// Purpose:
//	Downloads the test DLL and symbols to the c:\winhttpstress\stressEXE dir
//	if this fails then we try to regsvr "winhttp5.dll" in the system search
//	path. If that fails, then we fail. We want ANY version of winhttp available on
//	the system for use since we may not want to download a new version for every test.
//
////////////////////////////////////////////////////////////
BOOL ServerCommands::Download_WinHttpDLL()
{
	BOOL		bResult				= TRUE;
	LPTSTR		szSymbolFileName	= NULL;
	LPTSTR		szBuffer			= NULL;
	DWORD		dwBufferSize		= MAX_PATH * 8;
	HINSTANCE	hLib				= NULL;


	szSymbolFileName	= new TCHAR[MAX_PATH];
	szBuffer			= new TCHAR[dwBufferSize];

	if (!szSymbolFileName || !szBuffer)
		goto Exit;

	// ************************
	// ************************
	// ** download the file to stressExe directory
	// **
	_tcscpy(szBuffer, m_szStressSchedulerCurrentDirectory);
	_tcscat(szBuffer, _T("\\"));
	_tcscat(szBuffer, STRESSINSTANCE_STRESS_EXE_DOWNLOAD_DIR);

	// download DLL if needed
	if (_tcsclen(m_szWinHttpDLL_DownloadURL) > 0)
		bResult = 
			NetworkTools__URLDownloadToFile(
			m_szWinHttpDLL_DownloadURL,
			szBuffer,
			m_szWinHttpDLL_FileName);

	if (bResult)
	{
		// download PDB file if needed
		if (_tcsclen(m_szWinHttpPDB_DownloadURL) > 0)
		{
			NetworkTools__GetFileNameFromURL(m_szWinHttpPDB_DownloadURL, szSymbolFileName, MAX_PATH);

			if (!NetworkTools__URLDownloadToFile(m_szWinHttpPDB_DownloadURL, szBuffer, szSymbolFileName))
				NetworkTools__SendLog(FIELDNAME__LOGTYPE_ERROR, "PDB symbol file failed to downloaded.", NULL, 0);
		}


		// download sym file if needed
		if (_tcsclen(m_szWinHttpSYM_DownloadURL) > 0)
		{
			NetworkTools__GetFileNameFromURL(m_szWinHttpSYM_DownloadURL, szSymbolFileName, MAX_PATH);

			if (!NetworkTools__URLDownloadToFile(m_szWinHttpSYM_DownloadURL, szBuffer, szSymbolFileName))
				NetworkTools__SendLog(FIELDNAME__LOGTYPE_ERROR, "SYM symbol file failed to downloaded.", NULL, 0);
		}
	}

	// if failed to download DLL, it's probably in use. We'll try to regsvr32 it anyways if it's there.

	// ************************
	// ************************
	// ** regsvr32'ed the dll just downloaded in the stressExe dir
	// **
	_tcscat(szBuffer, _T("\\"));
	_tcscat(szBuffer, m_szWinHttpDLL_FileName);
	hLib = LoadLibrary(szBuffer);

	if (hLib < (HINSTANCE)HINSTANCE_ERROR)
	{
		// unable to load the DLL - so we try to load it the version from the system path
		hLib = LoadLibrary(_T("winhttp5.dll"));

		// if that doesn't exist then we fail since winhttp5.dll can be loaded by the stressApp
		if (hLib < (HINSTANCE)HINSTANCE_ERROR)
		{
			bResult = FALSE;
			goto Exit;
		}
	}

	// **********************
	// **********************
	// ** Register the DLL
	typedef VOID (CALLBACK* LPFNDLLFUNC1)();
	LPFNDLLFUNC1 lpDllEntryPoint;

	// Find the entry point.
	(FARPROC&)lpDllEntryPoint = GetProcAddress(hLib, "DllRegisterServer");

	if (lpDllEntryPoint != NULL)
		(*lpDllEntryPoint)();
	else
	{
		//unable to locate entry point - regsvr failed
		bResult = FALSE;
	}


Exit:
	// unload library only if valid
	if (hLib && (hLib >= (HINSTANCE)HINSTANCE_ERROR))
		FreeLibrary(hLib);

	if (bResult)
		NetworkTools__SendLog(FIELDNAME__LOGTYPE_INFORMATION, "winhttp5 DLL and symbols downloaded and registered successfully.", NULL, 0);
	else
		NetworkTools__SendLog(FIELDNAME__LOGTYPE_ERROR, "winhttp5 DLL or symbols failed to download or register successfully.", NULL, 0);

	if (szSymbolFileName)
		delete [] szSymbolFileName;

	if (szBuffer)
		delete [] szBuffer;

	return bResult;
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::Set_RunForever(BOOL)
//
// Purpose:
//	Pass in TRUE to run forever ignoring begin/end time, FALSE not to.
//
// Called by: QueryServerForCommands_ThreadProc
//
////////////////////////////////////////////////////////////
VOID
ServerCommands::Set_RunForever(
	BOOL bRunForever	// [IN] TRUE to run forever ignoring begin/end time, FALSE not to.
)
{
	m_bRunForever = bRunForever;
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::Set_ExitStress(BOOL)
//
// Purpose:
//	Pass in TRUE to exit stress as soon as possible and FALSE
//	not to.
//
// Called by: QueryServerForCommands_ThreadProc
//
////////////////////////////////////////////////////////////
VOID
ServerCommands::Set_ExitStress(
	BOOL bExitStress	// [IN] TRUE to exit stress, FALSE not to.
)
{
	m_bExit = bExitStress;
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::Set_WinHttpDllURL(LPTSTR, DWORD)
//
// Purpose:
//	Pass in an URL and its size and to get the WinHttp DLL from.
//
// Called by: QueryServerForCommands_ThreadProc
//
////////////////////////////////////////////////////////////
VOID
ServerCommands::Set_WinHttpDllURL(
	LPTSTR szBuffer,	// [IN] string buffer containing URL to the WINHTTP DLL
	DWORD dwBufferSize	// [IN] size of the szBuffer in TCHARs
)
{
	_tcscpy(m_szWinHttpDLL_DownloadURL, szBuffer);

	// Get the full DLL filename from the URL
	NetworkTools__GetFileNameFromURL(m_szWinHttpDLL_DownloadURL, m_szWinHttpDLL_FileName, MAX_PATH);
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::Set_WinHttpPDBURL(LPTSTR, DWORD)
//
// Purpose:
//	Pass in an URL and its size and to get the WinHttp PDB file from.
//
// Called by: QueryServerForCommands_ThreadProc
//
////////////////////////////////////////////////////////////
VOID
ServerCommands::Set_WinHttpPDBURL(
	LPTSTR szBuffer,	// [IN] string buffer containing URL to the WINHTTP DLL
	DWORD dwBufferSize	// [IN] size of the szBuffer in TCHARs
)
{
	_tcscpy(m_szWinHttpPDB_DownloadURL, szBuffer);
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::Set_WinHttpSYMURL(LPTSTR, DWORD)
//
// Purpose:
//	Pass in an URL and its size and to get the WinHttp SYM file from.
//
// Called by: QueryServerForCommands_ThreadProc
//
////////////////////////////////////////////////////////////
VOID
ServerCommands::Set_WinHttpSYMURL(
	LPTSTR szBuffer,	// [IN] string buffer containing URL to the WINHTTP DLL
	DWORD dwBufferSize	// [IN] size of the szBuffer in TCHARs
)
{
	_tcscpy(m_szWinHttpSYM_DownloadURL, szBuffer);
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::Set_CommandServerURL(LPTSTR)
//
// Purpose:
//	Pass in a timeout value in milliseconds to query the 
//	Command Server for commands.
//
// Called by: QueryServerForCommands_ThreadProc
//
////////////////////////////////////////////////////////////
VOID
ServerCommands::Set_CommandServerURL(
	LPTSTR szBuffer,	// [IN] string buffer containing URL to the WINHTTP DLL
	DWORD dwBufferSize	// [IN] size of the szBuffer in TCHARs
)
{
	_tcscpy(m_szCommandServerURL, szBuffer);
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::Set_CommandServerUpdateInterval(DWORD)
//
// Purpose:
//	Pass in a timeout value in milliseconds to query the 
//	Command Server for commands.
//
// Called by: QueryServerForCommands_ThreadProc
//
////////////////////////////////////////////////////////////
VOID
ServerCommands::Set_CommandServerUpdateInterval(
	DWORD dwUpdateInterval	// [IN] time to wait before pinging the Command Server in milliseconds
)
{
	// server update interval must be at least greater than the minimum timeout
	if (STRESS_COMMAND_SERVER_MINIMUM_UPDATE_INTERVAL < dwUpdateInterval &&
		STRESS_COMMAND_SERVER_MAXIMUM_UPDATE_INTERVAL > dwUpdateInterval)
		m_dwCommandServerUpdateInternval = dwUpdateInterval;
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::Set_TimeStressBegins(DWORD, DWORD)
//
// Purpose:
//	Pass in a time string to begin stress in 24 hour time.
//	Takes two parameters to set the hour and minute. A parameter
//	will be ignored if NULL.
//
// Called by: QueryServerForCommands_ThreadProc
//
////////////////////////////////////////////////////////////
VOID
ServerCommands::Set_TimeStressBegins(
	LPTSTR szHour,	// [IN] 0-23 parameter ignored if < 0
	LPTSTR szMinute	// [IN] 0-59 parameter ignored if < 0
)
{
	if (szHour)
		m_iTimeStressBeginsHour = _ttoi(szHour);

	if (szMinute)
		m_iTimeStressBeginsMinute = _ttoi(szMinute);
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::Set_TimeStressEnds(DWORD, DWORD)
//
// Purpose:
//	Pass in a time string to end stress in 24 hour time.
//	Takes two parameters to set the hour and minute. A parameter
//	will be ignored if NULL.
//
// Called by: QueryServerForCommands_ThreadProc
//
////////////////////////////////////////////////////////////
VOID
ServerCommands::Set_TimeStressEnds(
	LPTSTR szHour,	// [IN] 0-23 parameter ignored if < 0
	LPTSTR szMinute	// [IN] 0-59 parameter ignored if < 0
)
{
	if (szHour)
		m_iTimeStressEndsHour = _ttoi(szHour);

	if (szMinute)
		m_iTimeStressEndsMinute = _ttoi(szMinute);
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::Create_StressInstance(LPTSTR)
//
// Purpose:
//	Pass in an URL and its size and it will be added to the 
//  m_arStressInstanceList list. There is no limit on the number of
//	URLs that can be added.
//
// Called by: QueryServerForCommands_ThreadProc
//
////////////////////////////////////////////////////////////
VOID
ServerCommands::Create_StressInstance(
	DWORD	dwStressInstanceID,	// [IN] ID from the stressAdmin DB identifying this stressInstance
	LPTSTR	szPageHeapCommand,	// [IN] string buffer containing the pageheap command line
	LPTSTR	szUMDHCommand,		// [IN] string buffer containing the UMDH command line
	LPTSTR	szPDB_URL,			// [IN] string buffer containing URL to the stress EXE's PDB file
	LPTSTR	szSYM_URL,			// [IN] string buffer containing URL to the stress EXE's SYM file
	LPTSTR	szMemDumpPath,		// [IN] string buffer containing path to create memory dump files
	LPTSTR	szEXE_URL			// [IN] string buffer containing URL to the stress EXE
)
{
	PSTRESSINSTANCE pStressInstance = NULL;

	// verify params just in case
	if (!szEXE_URL)
		return;

	// allocate memory for the object and put it in the list if successful
	__try
	{
		pStressInstance = new StressInstance;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		pStressInstance = NULL;
	}

	if (!pStressInstance)
		return;

	pStressInstance->Set_UMDHCommands(szUMDHCommand);
	pStressInstance->Set_PageHeapCommands(szPageHeapCommand);
	pStressInstance->Set_StressExeID(dwStressInstanceID);
	pStressInstance->Set_StressExeURL(szEXE_URL);
	pStressInstance->Set_StressExeMemoryDumpPath(szMemDumpPath);
	pStressInstance->Set_StressExePdbURL(szPDB_URL);
	pStressInstance->Set_StressExeSymURL(szSYM_URL);

	m_arStressInstanceList.push_back(pStressInstance);
	m_dwStressInstanceIterator = m_arStressInstanceList.begin();
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::Clear_StressExeURLs()
//
// Purpose:
//	Frees memory from the m_arStressExeList vector.
//
// Called by: QueryServerForCommands_ThreadProc and ~ServerCommands
//
////////////////////////////////////////////////////////////
VOID
ServerCommands::Clear_StressExeURLs()
{
	// don't want to delete StressInstances if it's still running
	if (IsStressRunning())
		return;

	StressInstance *pStressInstance = NULL;

	for (int iIndex=0; iIndex < m_arStressInstanceList.size(); iIndex++)
	{
		pStressInstance = m_arStressInstanceList[iIndex];
		m_arStressInstanceList.erase(&m_arStressInstanceList[iIndex]);

		if (pStressInstance)
		{
			__try
			{
				delete pStressInstance;
			}
			__except(EXCEPTION_EXECUTE_HANDLER)
			{
				// oh well, we tried...
				pStressInstance = NULL;
			}
		}
	}

	m_dwStressInstanceIterator = NULL;
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::Get_CommandServerUpdateInterval()
//
// Purpose:
//	Returns the current setting for the Command Server Update
//	interval.
//
////////////////////////////////////////////////////////////
DWORD
ServerCommands::Get_CommandServerUpdateInterval()
{
	if (STRESS_COMMAND_SERVER_MINIMUM_UPDATE_INTERVAL < m_dwCommandServerUpdateInternval &&
		STRESS_COMMAND_SERVER_MAXIMUM_UPDATE_INTERVAL > m_dwCommandServerUpdateInternval)
		return m_dwCommandServerUpdateInternval;
	else
		return STRESS_COMMAND_SERVER_UPDATE_INTERVAL;
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::BeginStress()
//
// Purpose:
//	Queries for commands then starts the StressInstance objects.
//
////////////////////////////////////////////////////////////
void
ServerCommands::BeginStress()
{
	EnterCriticalSection(&g_csServerCommandsVars);

	if (!m_arStressInstanceList.empty() && !IsStressRunning())
	{
		// LOGLOG: Stress is beginning
		NetworkTools__SendLog(FIELDNAME__LOGTYPE_BEGIN_STRESS, "Stress is beginning.", NULL, NULL);

		// first download and regsvr32 the winhttp dll and symbols
		Download_WinHttpDLL();

		for(int iIndex = 0; iIndex < m_arStressInstanceList.size(); iIndex++)
			m_arStressInstanceList[iIndex]->Begin();
	}
	else
	{
		// ping Command Server for list of stress EXE URLs.
		QueryServerForCommands();
	}

	LeaveCriticalSection(&g_csServerCommandsVars);
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::EndStress()
//
// Purpose:
//	Ends stress and posts the results to the Command Server.
//
////////////////////////////////////////////////////////////
VOID
ServerCommands::EndStress()
{
	EnterCriticalSection(&g_csServerCommandsVars);

	if (!m_arStressInstanceList.empty())
	{
		if (IsStressRunning())
		{
			// LOGLOG: Stress is ending
			NetworkTools__SendLog(FIELDNAME__LOGTYPE_END_STRESS, "Stress is ending.", NULL, NULL);
		}

		for (int iIndex = 0; iIndex <  m_arStressInstanceList.size(); iIndex++)
			m_arStressInstanceList[iIndex]->End();

		// Remove the stress objects that already finished
		Clear_StressExeURLs();
	}

	LeaveCriticalSection(&g_csServerCommandsVars);
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::AbortStressInstance(DWORD)
//
// Purpose:
//	Aborts a all stress instances that recieved a server abort message.
//
// Called in:
//	QueryServerForCommands_ThreadProc
//
////////////////////////////////////////////////////////////
VOID
ServerCommands::AbortStressInstance(DWORD dwAbortID)
{
	// EnterCriticalSection(&g_csServerCommandsVars);

	if (!m_arStressInstanceList.empty())
	{
		for (int iIndex = 0; iIndex <  m_arStressInstanceList.size(); iIndex++)
		{
			if (m_arStressInstanceList[iIndex]->Get_ID() == dwAbortID)
				m_arStressInstanceList[iIndex]->End();
		}
	}

	//LeaveCriticalSection(&g_csServerCommandsVars);
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::IsStressRunning()
//
// Purpose:
//	Returns TRUE if any of the stressinstances is running. FALSE if not.
//
////////////////////////////////////////////////////////////
BOOL
ServerCommands::IsStressRunning()
{
	BOOL bIsRunning = FALSE;

	EnterCriticalSection(&g_csServerCommandsVars);

	if (!m_arStressInstanceList.empty())
	{
		for (int iIndex = 0; iIndex < m_arStressInstanceList.size(); iIndex++)
		{
			if (m_arStressInstanceList[iIndex]->IsRunning(STRESSINSTANCE_STRESS_EXE_CLOSE_TIMEOUT))
				bIsRunning = TRUE;
		}
	}

	LeaveCriticalSection(&g_csServerCommandsVars);

	return bIsRunning;
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::IsTimeToBeginStress()
//
// Purpose:
//	TRUE if it's time to begin stress based on the time returned
//	from the Command Server. Will return TRUE if m_sysTimeStressBegins
//	is current or in the future. FALSE if not.
//
////////////////////////////////////////////////////////////
BOOL
ServerCommands::IsTimeToBeginStress()
{
	SYSTEMTIME	stCurrent, stBeginStress, stEndStress;
	FILETIME	ftCurrent, ftBeginStress, ftEndStress;
	BOOL		bResult = FALSE;

	EnterCriticalSection(&g_csServerCommandsVars);

	// always run stress now if server tells us to
	if (m_bRunForever)
	{
		bResult = TRUE;
		goto Exit;
	}


	// check to see if valid time values have been received. If not, then we always fail.
	if (
		m_iTimeStressBeginsHour < 0 || m_iTimeStressBeginsMinute < 0 ||
		m_iTimeStressEndsHour < 0 || m_iTimeStressEndsMinute < 0
		)
	{
		bResult = FALSE;
		goto Exit;
	}

	GetLocalTime(&stCurrent);
	GetLocalTime(&stBeginStress);
	GetLocalTime(&stEndStress);

	// use the hour and minute time that we got from the command server
	stBeginStress.wHour		= m_iTimeStressBeginsHour;
	stBeginStress.wMinute	= m_iTimeStressBeginsMinute;

	stEndStress.wHour		= m_iTimeStressEndsHour;
	stEndStress.wMinute		= m_iTimeStressEndsMinute;

	// convert to file time so we can compare
	SystemTimeToFileTime(&stCurrent, &ftCurrent);
	SystemTimeToFileTime(&stBeginStress, &ftBeginStress);
	SystemTimeToFileTime(&stEndStress, &ftEndStress);


	// If EndTime < BeginTime, then it means stress is running for
	// over a day so we have to add 24 hours to the end time.
	ULARGE_INTEGER	ulEndStress;
	ULONGLONG		ullNanoSecondsInAFreakingDay;

	ulEndStress.LowPart		= ftEndStress.dwLowDateTime;
	ulEndStress.HighPart	= ftEndStress.dwHighDateTime;

	// stress runs across two days so we wrap around one day
	ullNanoSecondsInAFreakingDay = 24 * 60;		// minutes in a day
	ullNanoSecondsInAFreakingDay *= 60;			// seconds in a day
	ullNanoSecondsInAFreakingDay *= 1000000000;	// number of nanoseconds in a day. 10^9 NS in a second
	ullNanoSecondsInAFreakingDay /= 100;		// The FILETIME structure is a 64-bit value representing the number of 100-nanosecond intervals since January 1, 1601. 

	if (m_iTimeStressEndsHour < m_iTimeStressBeginsHour) 
	{
		// ********************
		// ********************
		// ** increase by 24 hours
		// **

		ulEndStress.QuadPart		 += ullNanoSecondsInAFreakingDay;

		// copy back to the original EndStress Date/Time
		ftEndStress.dwHighDateTime	= ulEndStress.HighPart;
		ftEndStress.dwLowDateTime	= ulEndStress.LowPart;

		FileTimeToSystemTime(&ftEndStress, &stEndStress);
	}
	else
	{
		// stress runs in the same day
		if ((m_iTimeStressEndsHour == m_iTimeStressBeginsHour) &&
			(m_iTimeStressEndsMinute <= m_iTimeStressBeginsMinute))
		{
			// if 7:30 to 7:20 - we wrap around one day.
			ulEndStress.QuadPart	+= ullNanoSecondsInAFreakingDay;

			// copy back to the original EndStress Date/Time
			ftEndStress.dwHighDateTime	= ulEndStress.HighPart;
			ftEndStress.dwLowDateTime	= ulEndStress.LowPart;

			FileTimeToSystemTime(&ftEndStress, &stEndStress);
		}
	}


	// Begin stress if:
	// (BeginTime <= CurrentTime <= EndTime)
	if ((0 <= CompareFileTime(&ftCurrent, &ftBeginStress)) && (0 <= CompareFileTime(&ftEndStress, &ftCurrent)))
		bResult = TRUE;
	else
		bResult = FALSE;

Exit:
	LeaveCriticalSection(&g_csServerCommandsVars);

	return bResult;
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::IsTimeToExitStress()
//
// Purpose:
//	TRUE if it's time to end stress based on the COMMANDHEADER__EXIT headers
//	from the Command Server exists. FALSE if not.
//
////////////////////////////////////////////////////////////
BOOL
ServerCommands::IsTimeToExitStress()
{
	return m_bExit;
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::Get_CommandServerURL()
//
// Purpose:
//	Returns the Command Server URL.
//
////////////////////////////////////////////////////////////
LPTSTR
ServerCommands::Get_CommandServerURL()
{
	return m_szCommandServerURL;
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::Get_NumberOfStressInstances()
//
// Purpose:
//	Returns the number of stressInstances running or pending.
//
////////////////////////////////////////////////////////////
DWORD
ServerCommands::Get_NumberOfStressInstances()
{
	return m_arStressInstanceList.size();
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::Get_TestDllFileName()
//
// Purpose:
//	Returns the name of the test DLL. ex. "winhttp5.dll"
//
////////////////////////////////////////////////////////////
LPTSTR
ServerCommands::Get_TestDllFileName()
{
	// m_szWinHttpDLL_FileName can be NULL in the case that a test DLL is not downloaded

	if (0 < _tcslen(m_szWinHttpDLL_FileName))
		return m_szWinHttpDLL_FileName;
	else
		return _T("winhttp5.dll");
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::Get_ClientID()
//
// Purpose:
//	Returns the client ID of the machine if registered. Zero if unsuccessful.
//
////////////////////////////////////////////////////////////
DWORD
ServerCommands::Get_ClientID()
{
	DWORD	dwBufferSize		= sizeof(m_dwClientID);
	LPSTR	szPostData			= NULL;
	LPSTR	szUserAlias			= NULL;
	LPSTR	szUserDomain		= NULL;
	DWORD	dwUserAliasSize		= MAX_PATH * 2;
	DWORD	dwPostDomainSize	= MAX_PATH * 2;
	DWORD	dwPostDataSize		= sizeof(POSTSTRING__GET_CLIENT_ID) + dwUserAliasSize + dwPostDomainSize;

	// query for the clientID only if we don't already have it
	if (m_dwClientID <= 0)
	{
		szPostData		= new CHAR[dwPostDataSize];
		szUserAlias		= new CHAR[dwUserAliasSize];
		szUserDomain	= new CHAR[dwPostDomainSize];

		if (!szPostData || !szUserAlias || !szUserDomain)
			goto Exit;

		ZeroMemory(szPostData, dwPostDataSize);
		ZeroMemory(szUserAlias, dwUserAliasSize);
		ZeroMemory(szUserDomain, dwPostDomainSize);

		// *********************
		// *********************
		// ** Stuff user info into POST string
		GetEnvironmentVariableA("USERNAME",		szUserAlias,	dwUserAliasSize-1);
		GetEnvironmentVariableA("USERDOMAIN",	szUserDomain,	dwPostDomainSize-1);

		sprintf(szPostData, POSTSTRING__GET_CLIENT_ID, Get_ClientMachineName(), szUserAlias, szUserDomain);

		if (!NetworkTools__GetHeaderValue(
				STRESS_COMMAND_SERVER_URL,
				szPostData,
				COMMANDHEADER__CLIENT_ID,
				WINHTTP_QUERY_CUSTOM | WINHTTP_QUERY_FLAG_NUMBER,
				&m_dwClientID,
				&dwBufferSize))
		{
			m_dwClientID = 0;
		}
	}

Exit:
	if (szPostData)
		delete [] szPostData;

	if (szUserAlias)
		delete [] szUserAlias;

	if (szUserDomain)
		delete [] szUserDomain;

	return m_dwClientID;
}


////////////////////////////////////////////////////////////
// Function:  ServerCommands::RegisterClient()
//
// Purpose:
//	Sends the command server the system info on this client.
//	This lets the command server know that this client is alive.
//
//	NOTE: This only works in NT because we query
//	environment vars not present in Win9x
//
////////////////////////////////////////////////////////////
BOOL
ServerCommands::RegisterClient()
{
	OSVERSIONINFOA	osInfo;
	BOOL			bResult		= FALSE;
	DWORD			dwPostSize	= 5000;
	DWORD			dwTempSize	= MAX_PATH;
	DWORD			dwSizeSoFar	= 0;	// size of string written to szTemp so far.
	LPSTR			szPost		= NULL;
	LPSTR			szTemp		= NULL;


	szPost		= new CHAR[dwPostSize];
	szTemp		= new CHAR[dwTempSize];

	if (!szPost || !szTemp)
		goto Exit;

	ZeroMemory(szTemp, dwTempSize);
	ZeroMemory(szPost, dwPostSize);

	// *********************
	// *********************
	// ** Get windows version info
	osInfo.dwOSVersionInfoSize = sizeof(osInfo);
	if (!GetVersionExA(&osInfo))
		goto Exit;

	dwSizeSoFar += GetEnvironmentVariableA("OS", szTemp, dwTempSize);
	dwSizeSoFar += sizeof(FIELDNAME__OS_PLATFORM);
	strcat(szPost, FIELDNAME__OS_PLATFORM);
	strcat(szPost, szTemp);

	strcat(szPost, "&" FIELDNAME__OS_BUILD);
	strcat(szPost, _itoa(osInfo.dwBuildNumber, szTemp, 10));

	strcat(szPost, "&" FIELDNAME__OS_MAJORVERSION);
	strcat(szPost, _itoa(osInfo.dwMajorVersion, szTemp, 10));

	strcat(szPost, "&" FIELDNAME__OS_MINORVERSION);
	strcat(szPost, _itoa(osInfo.dwMinorVersion, szTemp, 10));

	strcat(szPost, "&" FIELDNAME__OS_EXTRAINFO);
	strcat(szPost, osInfo.szCSDVersion);


	// *********************
	// *********************
	// ** Get processor info
	GetEnvironmentVariableA("PROCESSOR_ARCHITECTURE", szTemp, dwTempSize);
	strcat(szPost, "&" FIELDNAME__SYSTEMINFO_PROCSSSOR_ARCHITECTURE);
	strcat(szPost, szTemp);

	GetEnvironmentVariableA("PROCESSOR_IDENTIFIER", szTemp, dwTempSize);
	strcat(szPost, "&" FIELDNAME__SYSTEMINFO_PROCSSSOR_ID);
	strcat(szPost, szTemp);

	GetEnvironmentVariableA("PROCESSOR_LEVEL", szTemp, dwTempSize);
	strcat(szPost, "&" FIELDNAME__SYSTEMINFO_PROCSSSOR_LEVEL);
	strcat(szPost, szTemp);

	GetEnvironmentVariableA("PROCESSOR_REVISION", szTemp, dwTempSize);
	strcat(szPost, "&" FIELDNAME__SYSTEMINFO_PROCSSSOR_REVISION);
	strcat(szPost, szTemp);

	GetEnvironmentVariableA("NUMBER_OF_PROCESSORS", szTemp, dwTempSize);
	strcat(szPost, "&" FIELDNAME__SYSTEMINFO_PROCSSSOR_NUMBER_OF);
	strcat(szPost, szTemp);


	// *********************
	// *********************
	// ** Get user info
	GetEnvironmentVariableA("USERNAME", szTemp, dwTempSize);
	strcat(szPost, "&" FIELDNAME__USERINFO_USERALIAS);
	strcat(szPost, szTemp);

	GetEnvironmentVariableA("USERDOMAIN", szTemp, dwTempSize);
	strcat(szPost, "&" FIELDNAME__USERINFO_USERDOMAIN);
	strcat(szPost, szTemp);

	// BUGBUG: someone needs to resolve the user alias to the real full name of the user
	// FIELDNAME__USERINFO_FULLNAME


	// get the client's machine name
	strcat(szPost, "&" FIELDNAME__USERINFO_MACHINENAME);
	strcat(szPost, m_szClientMachineName);


	// Let the Command Server know that this client is alive
	bResult = NetworkTools__POSTResponse(STRESS_COMMAND_SERVER_REGISTERCLIENT_URL, szPost, NULL);

	// LOGLOG: stressScheduler has started
	bResult = NetworkTools__SendLog(FIELDNAME__LOGTYPE_START_UP, "WinHttpStressScheduler has started.", NULL, NULL);


Exit:
	if (szPost)
		delete [] szPost;

	if (szTemp)
		delete [] szTemp;

	return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\stress\stressscheduler\src\networktools.h ===
///////////////////////////////////////////////////////////////////////////
// File:  NetworkTools.h
//
// Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
// Purpose:
//	NetworkTools.h: Helper functions that send/receive data.
//
// History:
//	02/22/01	DennisCh	Created
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_NETWORKTOOLS_H__4243AA4D_B243_4A0E_B729_243F260FC4F4__INCLUDED_)
#define AFX_NETWORKTOOLS_H__4243AA4D_B243_4A0E_B729_243F260FC4F4__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


//////////////////////////////////////////////////////////////////////
// Includes
//////////////////////////////////////////////////////////////////////

//
// WIN32 headers
//
#define UNICODE
#define _UNICODE

#include <stdio.h>
#include <windows.h>
#include <tchar.h>
#include <winhttp.h>
#include <shlwapi.h>

//
// Project headers
//


//////////////////////////////////////////////////////////////////////
// Constants
//////////////////////////////////////////////////////////////////////

#define		DEBUGGER_TOOLS_PATH		_T("c:\\debuggers\\")

BOOL	NetworkTools__CopyFile(LPCTSTR, LPCTSTR);
BOOL	NetworkTools__GetDllVersion(LPTSTR, LPTSTR, LPSTR, DWORD);
BOOL	NetworkTools__GetFileNameFromURL(LPTSTR, LPTSTR, DWORD);
BOOL	NetworkTools__GetHeaderValue(LPTSTR, LPSTR, LPTSTR, DWORD, LPVOID, LPDWORD);
BOOL	NetworkTools__LogDumpFileInfo(LPTSTR, DWORD);
BOOL	NetworkTools__PageHeap(BOOL, LPCTSTR, LPCTSTR);
BOOL	NetworkTools__POSTResponse(LPTSTR, LPSTR, LPTSTR);
BOOL	NetworkTools__SendLog(LPSTR, LPSTR, LPTSTR, DWORD);
BOOL	NetworkTools__UMDH(BOOL, LPCTSTR, LPCTSTR, LPCTSTR, DWORD);
BOOL	NetworkTools__URLDownloadToFile(LPCTSTR, LPCTSTR, LPCTSTR);


#endif // !defined(AFX_NETWORKTOOLS_H__4243AA4D_B243_4A0E_B729_243F260FC4F4__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\stress\stressscheduler\src\winhttpstressscheduler.cpp ===
///////////////////////////////////////////////////////////////////////////
// File:  WinHttpStressScheduler.cpp
//
// Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
// Purpose:
//	Global interfaces for the WinHttpStressScheduler project.
//
// History:
//	02/05/01	DennisCh	Created
///////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////
//
// Includes
//
//////////////////////////////////////////////////////////////////////

//
// Win32 headers
//

//
// Project headers
//
#include "WinHttpStressScheduler.h"
#include "ServerCommands.h"
#include "NetworkTools.h"


//////////////////////////////////////////////////////////////////////
//
// Globals and statics
//
//////////////////////////////////////////////////////////////////////

HINSTANCE		g_hInstance;
HWND			g_hWnd;

ServerCommands	g_objServerCommands;

// used to cache the current update interval for resetting the timer as needed
DWORD			g_dwCurrentUpdateInterval;

// handle to a named mutex. Used to detect duplicate instances of stressScheduler
HANDLE			g_hInstanceMutex = NULL;


// Forward function definitions
LRESULT	CALLBACK	MainWndProc(HWND, UINT, WPARAM, LPARAM);
BOOL				OS_IsSupported();
BOOL				Show_IconShortCutMenu();
BOOL				StressSchedulerIsAlreadyRunning(BOOL);
BOOL				SystemTray_UpdateIcon(HWND hwnd, DWORD dwMessage, UINT uID, HICON hIcon, PSTR pszTip);


////////////////////////////////////////////////////////////
// Function:  WinMain( HINSTANCE, HINSTANCE, LPWSTR, int )
//
// Purpose:
//	This is the entry-point into WinHttpStressScheduler.
//
// Called by:
//	[System]
////////////////////////////////////////////////////////////
int
WINAPI
WinMain
(
   HINSTANCE	hInstance,		// [IN] handle to the process instance
   HINSTANCE	hPrecInstance,	// [IN] handle to the previous instance
   LPTSTR		lpCmdLine,		// [IN] command line
   int			nShowCmd		// [IN] show command
)
{
	MSG				msg;
	WNDCLASSEX		wndClass;

	// Detect duplicate instances of stressScheduler and create named mutex to detect future instances if unique
	if (StressSchedulerIsAlreadyRunning(TRUE))
		return FALSE;

	wndClass.cbSize			= sizeof(WNDCLASSEX); 
	wndClass.style			= CS_HREDRAW | CS_VREDRAW;
	wndClass.lpfnWndProc	= MainWndProc;
	wndClass.cbClsExtra		= 0;
	wndClass.cbWndExtra		= 0;
	wndClass.hInstance		= hInstance;
	wndClass.hIcon			= NULL;
	wndClass.hCursor		= NULL;
	wndClass.hbrBackground	= NULL;
	wndClass.lpszMenuName	= NULL;
	wndClass.lpszClassName	= WINHTTP_STRESS_SCHEDULER__NAME;
	wndClass.hIconSm		= NULL;

	RegisterClassEx(&wndClass);

	// cache our hInstance
	g_hInstance = hInstance;

    // Create window. 
	g_hWnd = NULL;
    g_hWnd = CreateWindow( 
        WINHTTP_STRESS_SCHEDULER__NAME,
        NULL,
        WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT,
        0,
        CW_USEDEFAULT,
        0,
        NULL,
        NULL,
        hInstance,
        NULL);

	if (!g_hWnd)
		return FALSE;

	// Verify that we're running a supported version of Windows
	if (!OS_IsSupported())
		return FALSE;

	// Add icon to the system tray icon
	if (!SystemTray_UpdateIcon(g_hWnd, NIM_ADD, 0, LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_MAIN_ICON)), WINHTTP_STRESS_SCHEDULER__NAME))
		return FALSE;

	// *********************
	// ** Tell the client that we are alive and also send system info
	g_objServerCommands.RegisterClient();

	// *********************
	// ** Get the clientID for this machine so we can get commands for it later
	g_objServerCommands.Get_ClientID();


	// Create timer to ping the Command Server for commands
	g_dwCurrentUpdateInterval	= g_objServerCommands.Get_CommandServerUpdateInterval();
	SetTimer(g_hWnd, IDT_QUERY_COMMAND_SERVER, g_dwCurrentUpdateInterval, (TIMERPROC) NULL);

	// Message loop
	while (GetMessage(&msg, NULL, 0, 0))
	{
		TranslateMessage(&msg);
		DispatchMessage(&msg);
	}

	// remove the icon from the system tray
	if (WM_QUIT == msg.message)
		SystemTray_UpdateIcon(g_hWnd, NIM_DELETE, 0, NULL, NULL);

	// LOGLOG: stressScheduler has exited
	//NetworkTools__SendLog(FIELDNAME__LOGTYPE_EXIT, "WinHttpStressScheduler has exited.", NULL, NULL);

	// Close mutex handle
	StressSchedulerIsAlreadyRunning(FALSE);

	return msg.wParam;
}


////////////////////////////////////////////////////////////
// Function:  MainWndProc( HWND, UINT, WPARAM, LPARAM)
//
// Purpose:
//	Window callback procedure for UI.
//
// Called by:
//	WinMain
////////////////////////////////////////////////////////////
LRESULT
CALLBACK
MainWndProc
(
	HWND	hwnd,	// [IN] Handle to current window
	UINT	iMsg,	// [IN] Incoming message
	WPARAM	wParam,	// [IN] Parameter
	LPARAM	lParam	// [IN] Parameter
)
{
	switch (iMsg)
	{
		case MYWM_NOTIFYICON:
			// Notifications sent for the System Tray icon
			switch (lParam)
			{
				case WM_LBUTTONDOWN:

				case WM_RBUTTONDOWN:
					Show_IconShortCutMenu();
					return 0;

				default:
					break;
			}
			return 0;

		case WM_COMMAND:

			// User clicked on the popup menu
			switch (LOWORD(wParam))
			{
				case IDM_BEGIN_STRESS:
					// begin stress only if it's time to
					if (g_objServerCommands.IsTimeToBeginStress())
						g_objServerCommands.BeginStress();
					else
						g_objServerCommands.QueryServerForCommands();
				break;

				case IDM_END_STRESS:
					// end stress only if it's time to.
					if (!g_objServerCommands.IsTimeToBeginStress())
						g_objServerCommands.EndStress();
				break;

				case IDM_WINHTTP_HOME:
					ShellExecute(g_hWnd, "open", WINHTTP_WINHTTP_HOME_URL, NULL, NULL, SW_SHOW);
				break;

				case IDM_OPENSTRESSADMIN:
					// Open a IE window to configure-client.asp. needs to send a clientID
					DWORD	dwURLSize;
					LPSTR	szURL;

					dwURLSize	= sizeof(WINHTTP_STRESSADMIN_URL) + MAX_PATH;
					szURL		= NULL;
					szURL		= new CHAR[dwURLSize];

					if (!szURL)
						return 0;

					ZeroMemory(szURL, dwURLSize);
					sprintf(szURL, WINHTTP_STRESSADMIN_URL, g_objServerCommands.Get_ClientID());
					ShellExecute(g_hWnd, "open", szURL, NULL, NULL, SW_SHOW);

					if (szURL)
						delete [] szURL;
				break;

				case IDM_EXIT:
					g_objServerCommands.EndStress();
					PostQuitMessage(0);
				break;
			}
			return 0;

		case WM_TIMER:
			switch (wParam)
			{
				case IDT_QUERY_COMMAND_SERVER:
					// Query the server for commands
					g_objServerCommands.QueryServerForCommands();

					if (g_dwCurrentUpdateInterval != g_objServerCommands.Get_CommandServerUpdateInterval())
					{
						// cache the new update interval
						g_dwCurrentUpdateInterval = g_objServerCommands.Get_CommandServerUpdateInterval();

						// Update the timer timeout
						KillTimer(g_hWnd, IDT_QUERY_COMMAND_SERVER);
						SetTimer(
							g_hWnd,
							IDT_QUERY_COMMAND_SERVER,
							g_dwCurrentUpdateInterval,
							(TIMERPROC) NULL);
					}

					// ***************************
					// ***************************
					// ** Act accordingly based on Command Server messages
					// **

					// *********************************
					// ** EXIT stressScheduler
					if (g_objServerCommands.IsTimeToExitStress())
					{
						g_objServerCommands.EndStress();

						// quit stressScehduler
						PostQuitMessage(0);
						return 0;
					}

					// *********************************
					// ** BEGIN/END stress
					// Begin/end stress if it's time
					if (g_objServerCommands.IsTimeToBeginStress())
						g_objServerCommands.BeginStress();
					else
						g_objServerCommands.EndStress();

					return 0;

				break;
			}
			return 0;

		case WM_CREATE:
			return 0;

		case WM_DESTROY:
			return 0;

		default:
			return DefWindowProc (hwnd, iMsg, wParam, lParam);
	}
}



////////////////////////////////////////////////////////////
// Function:  SystemTray_UpdateIcon(HWND hDlg, DWORD dwMessage, UINT uID, WORD wIconResource, PSTR pszTip)
//
// Purpose:
//	This add/modifies/removes an icon from the system tray.
//
// Called by:
//	WinMain
////////////////////////////////////////////////////////////
BOOL
SystemTray_UpdateIcon(
	HWND hwnd,			// [IN] handle to the window object
	DWORD dwMessage,	// [IN] option to apply to the icon
	UINT uID,			// [IN] ID of the icon
	HICON hIcon,		// [IN] handle to an icon if we're loading one
	PSTR pszTip			// [IN] string containing the tool tip text
)
{
    BOOL			bSuccess;
	NOTIFYICONDATA	tnd;

	tnd.cbSize				= sizeof(NOTIFYICONDATA);
	tnd.hWnd				= hwnd;
	tnd.uID					= uID;
	tnd.uFlags				= NIF_MESSAGE | NIF_ICON | NIF_TIP;
	tnd.uCallbackMessage	= MYWM_NOTIFYICON;
	tnd.hIcon				= hIcon;

	if (pszTip)
		lstrcpyn(tnd.szTip, pszTip, sizeof(tnd.szTip));
	else
		tnd.szTip[0] = '\0';

	bSuccess = Shell_NotifyIcon(dwMessage, &tnd);

	if (hIcon)
		DestroyIcon(hIcon);

	return bSuccess;
}



////////////////////////////////////////////////////////////
// Function:  Show_IconShortCutMenu()
//
// Purpose:
//	This will show the popup menu at the position of the mouse
//	pointer.
//
// Called by:
//	MainWndProc
////////////////////////////////////////////////////////////
BOOL
Show_IconShortCutMenu()
{
	POINT		ptMouse;
	HMENU		hPopUpMenu	= NULL;
	HMENU		hMenu		= NULL;
	// MENUINFO	menuInfo;
	BOOL		bResult		= FALSE;

	// Get the current mouse position
	if (0 != GetCursorPos(&ptMouse))
	{
		// show the popup menu
		hMenu = LoadMenu(g_hInstance, MAKEINTRESOURCE(IDR_POPUPMENU));
		if (!hMenu)
			return FALSE;

		hPopUpMenu	= GetSubMenu(hMenu, 0);
		if (!hPopUpMenu)
			return FALSE;

		/*
		// Make the menu go away after mouseover
		ZeroMemory(&menuInfo, sizeof(MENUINFO));
		menuInfo.cbSize		= sizeof(MENUINFO);
		menuInfo.fMask		= MIM_APPLYTOSUBMENUS | MIM_STYLE;
		menuInfo.dwStyle	= MNS_AUTODISMISS;

		BOOL temp = SetMenuInfo(hPopUpMenu, &menuInfo);
		*/

		bResult = 
			TrackPopupMenuEx(
			hPopUpMenu,
			TPM_RIGHTALIGN | TPM_BOTTOMALIGN,
			ptMouse.x,
			ptMouse.y,
			g_hWnd,
			NULL);
	}

	DestroyMenu(hMenu);
	DestroyMenu(hPopUpMenu);

	return bResult;
}


////////////////////////////////////////////////////////////
// Function:  OS_IsSupported()
//
// Purpose:
//	Returns TRUE if this APP is supported in the OS and FALSE if not.
//	As of now, winhttp is only supported on NT platforms. NT4, Win2k, and WinXP.
//
// Called by:
//	MainWndProc
////////////////////////////////////////////////////////////
BOOL
OS_IsSupported()
{
	BOOL			bSupported = TRUE;
	OSVERSIONINFO	osVI;

	osVI.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

	if (GetVersionEx(&osVI))
	{
		if (VER_PLATFORM_WIN32_NT == osVI.dwPlatformId)
			bSupported = TRUE;
		else
			bSupported = FALSE;
	}
	else
		bSupported = FALSE;

	return bSupported;
}


////////////////////////////////////////////////////////////
// Function:  SchedulerIsAlreadyRunning(BOOL)
//
// Purpose:
//	Returns TRUE if there is another instance of stressScheduler running.
//	When the param bCreateMutex is set to TRUE, then we create the mutex, else
//	we close one named WINHTTP_STRESS_SCHEDULER_MUTEX that already exists. 
//
// Called by:
//	MainWndProc
////////////////////////////////////////////////////////////
BOOL
StressSchedulerIsAlreadyRunning(BOOL bCreateMutex)
{
	if (!bCreateMutex && g_hInstanceMutex)
	{
		CloseHandle(g_hInstanceMutex);
		return FALSE;
	}

	g_hInstanceMutex = CreateMutex(NULL, FALSE, WINHTTP_STRESS_SCHEDULER_MUTEX);

	if (ERROR_ALREADY_EXISTS == GetLastError())
		return TRUE;
	else
		return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\stress\stressscheduler\src\stressinstance.cpp ===
//////////////////////////////////////////////////////////////////////
// File:  StressInstance.cpp
//
// Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
// Purpose:
//	StressInstance.cpp: interface for the StressInstance class.
//	This class is used spawn and monitor instances of the stressEXE app
//
// History:
//	02/15/01	DennisCh	Created
//
//////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////
//
// Includes
//
//////////////////////////////////////////////////////////////////////

//
// Win32 headers
//

//
// Project headers
//
#include "StressInstance.h"
#include "ServerCommands.h"
#include "NetworkTools.h"
#include "MemStats.h"
#include "debugger.h"

//////////////////////////////////////////////////////////////////////
//
// Globals and statics
//
//////////////////////////////////////////////////////////////////////

extern ServerCommands	g_objServerCommands;	// Declared in WinHttpStressScheduler.cpp
extern HWND				g_hWnd;					// Declared in WinHttpStressScheduler.cpp

// Forward function definitions

VOID
CALLBACK
StressExe_TimerProc(
	HWND hwnd,         // [IN] handle to window
	UINT uMsg,         // [IN] WM_TIMER message
	UINT_PTR idEvent,  // [IN] timer identifier
	DWORD dwTime       // [IN] current system time
);

DWORD
DebuggerCallbackProc(
	DWORD	dwFlags,
	LPVOID	lpIn,
	LPTSTR	lpszFutureString,
	LPVOID	lpFuturePointer
);


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////


StressInstance::StressInstance()
{
	m_szStressExe_URL					= new TCHAR[MAX_STRESS_URL];
	m_szStressExe_PDB_URL				= new TCHAR[MAX_STRESS_URL];
	m_szStressExe_SYM_URL				= new TCHAR[MAX_STRESS_URL];
	m_szStressExe_FilePath				= new TCHAR[MAX_STRESS_URL];
	m_szStressExe_FileName				= new TCHAR[MAX_STRESS_URL];
	m_szStressExe_FilePathAndName		= new TCHAR[MAX_STRESS_URL];
	m_szStressExe_PageHeapCommandLine	= new TCHAR[MAX_PATH];
	m_szStressExe_UMDHCommandLine		= new TCHAR[MAX_PATH];
	m_szStressExe_MemDumpPath			= new TCHAR[MAX_PATH];

	if (!m_szStressExe_URL ||
		!m_szStressExe_PDB_URL ||
		!m_szStressExe_SYM_URL ||
		!m_szStressExe_FilePath	||
		!m_szStressExe_FilePathAndName ||
		!m_szStressExe_PageHeapCommandLine ||
		!m_szStressExe_UMDHCommandLine ||
		!m_szStressExe_MemDumpPath)
	{
		throw;
	}

	ZeroMemory(m_szStressExe_URL,					MAX_STRESS_URL);
	ZeroMemory(m_szStressExe_PDB_URL,				MAX_STRESS_URL);
	ZeroMemory(m_szStressExe_SYM_URL,				MAX_STRESS_URL);
	ZeroMemory(m_szStressExe_FilePath,				MAX_STRESS_URL);
	ZeroMemory(m_szStressExe_FileName,				MAX_STRESS_URL);
	ZeroMemory(m_szStressExe_FilePathAndName,		MAX_STRESS_URL);
	ZeroMemory(m_szStressExe_PageHeapCommandLine,	MAX_PATH);
	ZeroMemory(m_szStressExe_UMDHCommandLine,		MAX_PATH);
	ZeroMemory(m_szStressExe_MemDumpPath,			MAX_PATH);
	
	ZeroMemory(&m_piStressExeProcess, sizeof(PROCESS_INFORMATION));

	m_hStressExe_ProcessExitEvent	= NULL;
	m_uiStressExeTimerID			= 0;

	m_dwStressInstanceRunID			= 0;

	m_objDebugger	= NULL;
}


StressInstance::~StressInstance()
{
	// End any running tests
	if (IsRunning(STRESSINSTANCE_STRESS_EXE_CLOSE_TIMEOUT))
		StressInstance::End();

	// ******************************
	// ******************************
	// ** End the stressExe monitoring timerproc
	if (m_uiStressExeTimerID)
		KillTimer(NULL, m_uiStressExeTimerID);

	if (m_szStressExe_URL)
		delete [] m_szStressExe_URL;

	if (m_szStressExe_PDB_URL)
		delete [] m_szStressExe_PDB_URL;

	if (m_szStressExe_SYM_URL)
		delete [] m_szStressExe_SYM_URL;

	if (m_szStressExe_FilePath)
		delete [] m_szStressExe_FilePath;

	if (m_szStressExe_FileName)
		delete [] m_szStressExe_FileName;

	if (m_szStressExe_FilePathAndName)
		delete [] m_szStressExe_FilePathAndName;

	if (m_szStressExe_PageHeapCommandLine)
		delete [] m_szStressExe_PageHeapCommandLine;

	if (m_szStressExe_UMDHCommandLine)
		delete [] m_szStressExe_UMDHCommandLine;

	if (m_szStressExe_MemDumpPath)
		delete [] m_szStressExe_MemDumpPath;
	

	m_szStressExe_URL					= NULL;
	m_szStressExe_PDB_URL				= NULL;
	m_szStressExe_SYM_URL				= NULL;
	m_szStressExe_FilePath				= NULL;
	m_szStressExe_FileName				= NULL;
	m_szStressExe_FilePathAndName		= NULL;
	m_szStressExe_PageHeapCommandLine	= NULL;
	m_szStressExe_UMDHCommandLine		= NULL;
	m_szStressExe_MemDumpPath			= NULL;

	// close stressExe process handles
	if (m_piStressExeProcess.hThread)
		CloseHandle(m_piStressExeProcess.hThread);

	if (m_piStressExeProcess.hProcess)
		CloseHandle(m_piStressExeProcess.hProcess);

	if (m_hStressExe_ProcessExitEvent)
		CloseHandle(m_hStressExe_ProcessExitEvent);

	m_piStressExeProcess.hThread	= NULL;
	m_piStressExeProcess.hProcess	= NULL;
	m_hStressExe_ProcessExitEvent	= NULL;

	// free debugger object
	if (m_objDebugger)
	{
		delete m_objDebugger;
		m_objDebugger = NULL;
	}
}


////////////////////////////////////////////////////////////
// Function:  StressInstance::Begin()
//
// Purpose:
//	This method begins stress by downloading the stress EXE from
//	m_szStressExe_URL and starts it in CDB.
//
////////////////////////////////////////////////////////////
BOOL
StressInstance::Begin()
{
	BOOL					bResult					= TRUE;
	LPTSTR					szCommandLine			= NULL;
	LPTSTR					szFileNameAndPath		= NULL;
	LPTSTR					szExitProcessName		= NULL;
	LPTSTR					szPID					= NULL;
	DWORD					dwCommandLineSize		= MAX_STRESS_URL*4;
	DWORD					dwFileNameAndPathSize	= MAX_STRESS_URL*2;
	LPSTARTUPINFO			pStartUpInfo			= NULL;
	PSECURITY_DESCRIPTOR	pSD						= NULL;
	SECURITY_ATTRIBUTES		securityAttributes;


	// don't start if stress is already running or we don't have a FileName or Path.
	if (IsRunning(5000) ||
		0 >= _tcslen(m_szStressExe_FilePath) ||
		0 >= _tcslen(m_szStressExe_FileName))
		goto Exit;


	szCommandLine			= new TCHAR[MAX_STRESS_URL*4];
	szFileNameAndPath		= new TCHAR[MAX_STRESS_URL*2];
	pStartUpInfo			= new STARTUPINFO;

	if (!szCommandLine || !szFileNameAndPath || !pStartUpInfo)
		goto Exit;


	// Notify the Command Server that this stressinstance is beginning
	NetworkTools__SendLog(FIELDNAME__LOGTYPE_BEGIN, "This stressInstance is beginning.", NULL, Get_ID());

	// cache the stressInstanceRunID
	m_dwStressInstanceRunID = Get_StressInstanceRunID();

	// If we can't obtain this ID, this means the command server is down.
	// m_dwStressInstanceRunID is used only when logging a DMP file to LOR. Try again then if we can't get it now. 
	if (m_dwStressInstanceRunID <= 0)
		NetworkTools__SendLog(FIELDNAME__LOGTYPE_ERROR, "StressInstance::Begin() - Could not obtain stressInstanceRunID!", NULL, Get_ID());


	// ********************************
	// ********************************
	// ** Download the stressExe and symbols.
	// **
	if (!DownloadStressExe())
	{
		bResult = FALSE;
		goto Exit;
	}


	// ********************************
	// ********************************
	// ** Enable pageheap if needed
	// **
	if (0 < _tcsclen(m_szStressExe_PageHeapCommandLine))
	{
		if (!NetworkTools__PageHeap(TRUE, m_szStressExe_FileName, m_szStressExe_PageHeapCommandLine))
		{
			NetworkTools__SendLog(FIELDNAME__LOGTYPE_ERROR, "Pageheap failed when trying to enable.", NULL, Get_ID());
			bResult = FALSE;
			// goto Exit; don't need to exit when pageheap fails
		}
		else
			NetworkTools__SendLog(FIELDNAME__LOGTYPE_SUCCESS, "Pageheap successfully enabled.", NULL, Get_ID());
	}


	// ********************************
	// ********************************
	// ** Create the stressExe process
	// **

	// build command line for CreateProcess of our stress app
	ZeroMemory(szCommandLine, dwCommandLineSize);
	_stprintf(szCommandLine, STRESSINSTANCE_DEBUG_COMMANDLINE, m_szStressExe_FilePathAndName);

	// startupInfo
	ZeroMemory(pStartUpInfo, sizeof(STARTUPINFO));
	pStartUpInfo->cb				= sizeof(STARTUPINFO);
	pStartUpInfo->dwFillAttribute	= FOREGROUND_INTENSITY | FOREGROUND_GREEN | FOREGROUND_RED | BACKGROUND_RED | BACKGROUND_GREEN | BACKGROUND_BLUE;
	pStartUpInfo->dwFlags			= STARTF_USESHOWWINDOW | STARTF_USEFILLATTRIBUTE;
	pStartUpInfo->wShowWindow		= SW_MINIMIZE;


	// Create the stressExe process
	bResult =
	CreateProcess(
		NULL,
		m_szStressExe_FilePathAndName,
		NULL, 
		NULL,
		TRUE,
		CREATE_NEW_CONSOLE | CREATE_SEPARATE_WOW_VDM | NORMAL_PRIORITY_CLASS | CREATE_NEW_PROCESS_GROUP | CREATE_SUSPENDED,
		NULL,
		m_szStressExe_FilePath,
		pStartUpInfo,
		&m_piStressExeProcess);

	if (!bResult)
	{
		// stressExe failed to start 
		goto Exit;
	}


	// ********************************
	// ********************************
	// ** Attach debugger to the process only if there isn't one
	// **

	// remove debugger if there is one
	if (m_objDebugger)
	{
		delete m_objDebugger;
		m_objDebugger = NULL;
	}

	ResumeThread(m_piStressExeProcess.hThread);
	Sleep(1000);

	// attach new debugger
	m_objDebugger = new Debugger(m_piStressExeProcess.dwProcessId, DebuggerCallbackProc, (LPVOID)this);
	m_objDebugger->Go();

	
	// ********************************
	// ********************************
	// ** Initialize dynamically named event objects.
	// ** Set object access to ALL.
	// **

	// Create event object that'll be inherited by the stressExe process.
	// StressScheduler will signal when it's time to close stressExe.
	pSD = new SECURITY_DESCRIPTOR;

	if (!pSD)
		goto Exit;


	// Set a NULL security descriptor. This gives full access to handles when inherited
	InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION);
	SetSecurityDescriptorDacl(pSD, TRUE, (PACL) NULL, FALSE);

	securityAttributes.bInheritHandle		= TRUE;
	securityAttributes.lpSecurityDescriptor	= pSD;
	securityAttributes.nLength				= sizeof(securityAttributes);


	// The named event object names have the PID of the process appended to the end of the constants
	// These strings are also created in the stressExe dynamically.
	szExitProcessName		= new TCHAR[MAX_PATH];
	szPID					= new TCHAR[16];

	if (!szExitProcessName || !szPID)
		goto Exit;


	// Get the processID string
	_itot(m_piStressExeProcess.dwProcessId, szPID, 10);

	// build ExitProcess event object name
	_tcscpy(szExitProcessName, STRESSINSTANCE_STRESS_EXE_EVENT_EXITPROCESS);
	_tcscat(szExitProcessName, szPID);

	if (m_hStressExe_ProcessExitEvent)
		CloseHandle(m_hStressExe_ProcessExitEvent);

	// this event is sent by us to stressExe when we want it to exit
	// Signaled = tell stressExe to exit; Not-Signaled = stressExe can continue running
	m_hStressExe_ProcessExitEvent = CreateEvent(
		&securityAttributes,
		FALSE,	// manual reset
		FALSE,
		szExitProcessName);


	// ********************************
	// ********************************
	// ** Begin the stressExe memory monitoring timerproc
	// **
	if (m_uiStressExeTimerID)
	{
		// there shouldn't be a timer already going. If so, nuke it.
		KillTimer(NULL, m_uiStressExeTimerID);
		m_uiStressExeTimerID = 0;
	}

	// create a new timer object and pass in the stressinstance pointer so we can use it later
	m_uiStressExeTimerID =
	SetTimer(
		g_hWnd,
		(UINT_PTR) this,
		STRESSINSTANCE_MONITOR_EXE_TIME,
		(TIMERPROC) StressExe_TimerProc);


	// Notify the Command Server that stress has started
	NetworkTools__SendLog(FIELDNAME__LOGTYPE_RUNNING, "This stressInstance has successfully started and is running.", NULL, Get_ID());

Exit:
	if (szCommandLine)
		delete [] szCommandLine;

	if (szFileNameAndPath)
		delete [] szFileNameAndPath;

	if (pStartUpInfo)
		delete [] pStartUpInfo;

	if (szExitProcessName)
		delete [] szExitProcessName;

	if (szPID)
		delete [] szPID;

	if (pSD)
		delete [] pSD;

	return bResult;
}


////////////////////////////////////////////////////////////
// Function:  StressInstance::End()
//
// Purpose:
//	This method ends stress by sending a message. If it doesn't
//	exit then we wait 30 seconds before detaching the debugger,
//	which will end the process.
//
////////////////////////////////////////////////////////////
VOID
StressInstance::End()
{
	// ******************************
	// ******************************
	// ** End the stressExe monitoring timerproc
	if (m_uiStressExeTimerID)
		KillTimer(NULL, m_uiStressExeTimerID);


	// ******************************
	// ******************************
	// ** Tell stressExe to shut down.
	SetEvent(m_hStressExe_ProcessExitEvent);

	// give time for the stressExe to exit
	/*
	if (IsRunning(STRESSINSTANCE_STRESS_EXE_CLOSE_TIMEOUT))
		Sleep(2000);
	*/


	// close stressExe process handles
	if (m_piStressExeProcess.hThread)
		CloseHandle(m_piStressExeProcess.hThread);

	if (m_piStressExeProcess.hProcess)
		CloseHandle(m_piStressExeProcess.hProcess);

	if (m_hStressExe_ProcessExitEvent)
		CloseHandle(m_hStressExe_ProcessExitEvent);

	m_piStressExeProcess.hThread	= NULL;
	m_piStressExeProcess.hProcess	= NULL;
	m_hStressExe_ProcessExitEvent	= NULL;


	// ********************************
	// ********************************
	// ** Detach the debugger object
	// **

	// detaching the debugger will (read: should) stop the stressExe
	if (m_objDebugger)
	{
		// ********************************
		// ********************************
		// ** Disable pageheap if needed
		// **
		NetworkTools__PageHeap(FALSE, m_szStressExe_FileName, NULL);

		// let the Command Server know that stressExe has ended
		// we send the message here because ServerCommands.cpp calls this too - even when
		// there isn't a running test case.
		// When the debugger object is valid, then we send the message - because it ensures that Begin() was called.
		NetworkTools__SendLog(FIELDNAME__LOGTYPE_END, "This stressInstance has ended.", NULL, Get_ID());

		delete m_objDebugger;
		m_objDebugger	= NULL;
	}

	ZeroMemory(&m_piStressExeProcess, sizeof(PROCESS_INFORMATION));
}


////////////////////////////////////////////////////////////
// Function:  StressInstance::Get_StressExeID()
//
// Purpose:
//	Returns the stress instance's ID receivedfrom the server
//
////////////////////////////////////////////////////////////
DWORD
StressInstance::Get_ID()
{
	return m_dwStressInstance_ID;
}


////////////////////////////////////////////////////////////
// Function:  StressInstance::Get_StressInstanceRunID()
//
// Purpose:
//	Gets the stressInstanceRunID generated by the DB that we
//	cache as soon as this instance starts.
//
////////////////////////////////////////////////////////////
DWORD
StressInstance::Get_StressInstanceRunID()
{
	DWORD	dwBufferSize		= sizeof(m_dwStressInstanceRunID);
	LPSTR	szPostData			= NULL;
	DWORD	dwPostDataSize		= sizeof(POSTSTRING__GET_CLIENT_ID) + MAX_PATH;

	// query for the clientID only if we don't already have it
	if (m_dwStressInstanceRunID <= 0)
	{
		szPostData		= new CHAR[dwPostDataSize];

		if (!szPostData)
			goto Exit;

		ZeroMemory(szPostData, dwPostDataSize);

		// *********************
		// *********************
		// ** Stuff user info into POST string
		sprintf(szPostData, POSTSTRING__GET_STRESSINSTANCERUN_ID, g_objServerCommands.Get_ClientID(), Get_ID());

		if (!NetworkTools__GetHeaderValue(
				STRESS_COMMAND_SERVER_URL,
				szPostData,
				COMMANDHEADER__STRESSINSTANCE_RUN_ID,
				WINHTTP_QUERY_CUSTOM | WINHTTP_QUERY_FLAG_NUMBER,
				&m_dwStressInstanceRunID,
				&dwBufferSize))
		{
			m_dwStressInstanceRunID = 0;
		}
	}

Exit:
	if (szPostData)
		delete [] szPostData;

	return m_dwStressInstanceRunID;
}



////////////////////////////////////////////////////////////
// Function:  StressInstance::Get_StressExeMemoryDumpPath()
//
// Purpose:
//	Sets the URL of the memory dump path
//
////////////////////////////////////////////////////////////
LPTSTR
StressInstance::Get_StressExeMemoryDumpPath()
{
	return m_szStressExe_MemDumpPath;
}


////////////////////////////////////////////////////////////
// Function:  StressInstance::Set_StressExeMemoryDumpPath()
//
// Purpose:
//	Sets the URL of the memory dump path
//
////////////////////////////////////////////////////////////
VOID
StressInstance::Set_StressExeMemoryDumpPath(
	LPTSTR szPath
)
{
	_tcsncpy(m_szStressExe_MemDumpPath, szPath, MAX_PATH);
}


////////////////////////////////////////////////////////////
// Function:  StressInstance::Set_StressExeURL(LPTSTR)
//
// Purpose:
//	Sets the URL to download the stress EXE for this object.
//
////////////////////////////////////////////////////////////
VOID
StressInstance::Set_StressExeURL(
	LPTSTR szBuffer	// [IN] Buffer containing the URL to download the stressExe app
)
{
	if (!szBuffer || (0 >= _tcslen(szBuffer)))
		return;

	_tcscpy(m_szStressExe_URL, szBuffer);

	// Set the stressExe's filename
	NetworkTools__GetFileNameFromURL(m_szStressExe_URL, m_szStressExe_FileName, MAX_STRESS_URL);

	// Set the stressExe's default path to download to with trailing slash
	GetCurrentDirectory(MAX_STRESS_URL, m_szStressExe_FilePath);
	_tcscat(m_szStressExe_FilePath, _T("\\") STRESSINSTANCE_STRESS_EXE_DOWNLOAD_DIR _T("\\"));

	// Set the full stressExe path + exe
	_tcscpy(m_szStressExe_FilePathAndName, m_szStressExe_FilePath);
	_tcscat(m_szStressExe_FilePathAndName, m_szStressExe_FileName);
}


////////////////////////////////////////////////////////////
// Function:  StressInstance::Set_StressExePdbURL(LPTSTR)
//
// Purpose:
//	Sets the URL to download the stress EXE's PDB file.
//
////////////////////////////////////////////////////////////
VOID
StressInstance::Set_StressExePdbURL(
	LPTSTR szBuffer	// [IN] Buffer containing the URL
)
{
	if (!szBuffer || (0 >= _tcslen(szBuffer)))
		return;

	_tcscpy(m_szStressExe_PDB_URL, szBuffer);
}


////////////////////////////////////////////////////////////
// Function:  StressInstance::Set_StressExeSymURL(LPTSTR)
//
// Purpose:
//	Sets the URL to download the stress EXE's SYM file.
//
////////////////////////////////////////////////////////////
VOID
StressInstance::Set_StressExeSymURL(
	LPTSTR szBuffer	// [IN] Buffer containing the URL
)
{
	if (!szBuffer || (0 >= _tcslen(szBuffer)))
		return;

	_tcscpy(m_szStressExe_SYM_URL, szBuffer);
}


////////////////////////////////////////////////////////////
// Function:  StressInstance::Set_StressExeID(DWORD)
//
// Purpose:
//	Sets the URL to download the stress EXE for this object.
//
////////////////////////////////////////////////////////////
VOID
StressInstance::Set_StressExeID(
	DWORD dwID	// [IN] ID from the stressAdmin DB uniquely identifying this stress EXE. 
)
{
	m_dwStressInstance_ID = dwID;
}


////////////////////////////////////////////////////////////
// Function:  StressInstance::Set_PageHeapCommands(LPCTSTR)
//
// Purpose:
//	Sets the pageheap command line.
//
////////////////////////////////////////////////////////////
VOID
StressInstance::Set_PageHeapCommands(
	LPCTSTR szCommandLine	// [IN] Extra command line params for pageheap.
)
{
	ZeroMemory(m_szStressExe_PageHeapCommandLine, MAX_PATH);
	_tcsncpy(m_szStressExe_PageHeapCommandLine, szCommandLine, MAX_PATH-1);
}


////////////////////////////////////////////////////////////
// Function:  StressInstance::Set_UMDHCommands(LPCTSTR)
//
// Purpose:
//	Sets the UMDH command line.
//
////////////////////////////////////////////////////////////
VOID
StressInstance::Set_UMDHCommands(
	LPCTSTR szCommandLine	// [IN] Extra command line params for UMDH.
)
{
	ZeroMemory(m_szStressExe_UMDHCommandLine, MAX_PATH);
	_tcsncpy(m_szStressExe_UMDHCommandLine, szCommandLine, MAX_PATH-1);
}


////////////////////////////////////////////////////////////
// Function:  StressInstance::DownloadStressExe()
//
// Purpose:
//	Downloads the stressExe app to the local machine.
//	We create a directory "stressExe" and put the file there. For example,
//	"http://hairball/files/stress1.exe" will be put in "stressExe\stress1.exe"
//	on the local machine. If the file is already there, it'll try to overwrite it.
//
////////////////////////////////////////////////////////////
BOOL
StressInstance::DownloadStressExe()
{
	BOOL	bResult		= TRUE;
	LPTSTR	szFileName	= NULL;

	szFileName	= new TCHAR[MAX_PATH];
	if (!szFileName)
		goto Exit;

	// Download the stressExe file
	if (!NetworkTools__URLDownloadToFile(m_szStressExe_URL, STRESSINSTANCE_STRESS_EXE_DOWNLOAD_DIR, m_szStressExe_FileName))
	{
		NetworkTools__SendLog(FIELDNAME__LOGTYPE_ERROR, "stress EXE file failed to downloaded.", NULL, Get_ID());
		bResult = FALSE;
	}

	// Download PDB symbol file if there is one
	if (NetworkTools__GetFileNameFromURL(m_szStressExe_PDB_URL, szFileName, MAX_PATH))
	{
		if (!NetworkTools__URLDownloadToFile(m_szStressExe_PDB_URL, STRESSINSTANCE_STRESS_EXE_DOWNLOAD_DIR, szFileName))
			NetworkTools__SendLog(FIELDNAME__LOGTYPE_ERROR, "stress PDB file failed to download.", NULL, Get_ID());
	}

	// Download SYM symbol file if there is one
	if (NetworkTools__GetFileNameFromURL(m_szStressExe_SYM_URL, szFileName, MAX_PATH))
	{
		if (!NetworkTools__URLDownloadToFile(m_szStressExe_SYM_URL, STRESSINSTANCE_STRESS_EXE_DOWNLOAD_DIR, szFileName))
			NetworkTools__SendLog(FIELDNAME__LOGTYPE_ERROR, "stress SYM file failed downloaded.", NULL, Get_ID());
	}

Exit:
	if (szFileName)
		delete [] szFileName;

	return bResult;
}


////////////////////////////////////////////////////////////
// Function:  StressInstance::IsRunning()
//
// Purpose:
//	Returns TRUE if this stressinstance is running. FALSE if not.
//
////////////////////////////////////////////////////////////
BOOL
StressInstance::IsRunning(
	DWORD	dwTimeOut	// [in] time to wait
)
{
	BOOL	bResult		= FALSE;
	HANDLE	hStressExe	= NULL;

	hStressExe = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, m_piStressExeProcess.dwProcessId);

	if (!hStressExe)
		bResult = FALSE;
	else
	{
		bResult = TRUE;
		CloseHandle(hStressExe);
	}

	return bResult;
}


////////////////////////////////////////////////////////////
// Function:  StressExe_TimerProc(HWND, UINT, UINT_PTR, DWORD)
//
// Purpose:
//	When this is called, we will check on the status of the
//	stressExe process send the command server it's memory info
//
////////////////////////////////////////////////////////////
VOID
CALLBACK
StressExe_TimerProc(
	HWND		hwnd,     // [IN] handle to window - should be NULL since we didn't specify one
	UINT		uMsg,     // [IN] WM_TIMER message
	UINT_PTR	idEvent,  // [IN] timer identifier - contains the pointer for the current StressInstance object
	DWORD		dwTime    // [IN] current system time
)
{
	// build directory to copy dump file
	LPSTR	szExeName = NULL;

	// make sure stress Instance object is valid
	StressInstance *pStressInstance = (StressInstance*) idEvent;

	if (!pStressInstance || IsBadCodePtr((FARPROC) pStressInstance))
		goto Exit;


	szExeName = new CHAR[MAX_STRESS_URL];
	if (!szExeName)
		goto Exit;


	// ***********************************
	// ***********************************
	// ** Check that the stressExe is still running. If it isn't end this instance.
	// **
	if (!pStressInstance->IsRunning(STRESSINSTANCE_STRESS_EXE_CLOSE_TIMEOUT))
	{
		NetworkTools__SendLog(FIELDNAME__LOGTYPE_INFORMATION, "This stress instance has exited prematurely.", NULL, pStressInstance->Get_ID());
		pStressInstance->End();
		goto Exit;
	}


	ZeroMemory(szExeName, MAX_STRESS_URL); 

	// ******************************
	// ** Remove the file extension of the stressExe name and send the system and process
	// ** memory log to the command server
	WideCharToMultiByte(
		CP_ACP,
		NULL,
		pStressInstance->m_szStressExe_FileName,
		-1,
		szExeName,
		MAX_STRESS_URL,
		NULL,
		NULL);

	MemStats__SendSystemMemoryLog(szExeName, pStressInstance->m_piStressExeProcess.dwProcessId, pStressInstance->Get_ID());

Exit:
	if (szExeName)
		delete [] szExeName;

	return;
}


////////////////////////////////////////////////////////////
// Function:  DebuggerCallbackProc(DWORD, LPVOID, LPTSTR, LPVOID)
//
// Purpose:
//	Creates a memory dump on second change exceptions
//
////////////////////////////////////////////////////////////
DWORD
DebuggerCallbackProc(
	DWORD	dwFlags,
	LPVOID	lpIn,
	LPTSTR	lpszFutureString,
	LPVOID	lpContext
)
{
	//test callback for debugger lib
	DWORD			dwContinue			= 0;
	LPSTR			szASCIIPath			= NULL;
	LPTSTR			szPath				= NULL;
	LPTSTR			szNum				= NULL;
	LPTSTR			szMachineName		= NULL;
	StressInstance	*pStressInstance	= (StressInstance*) lpContext;


	// ***********************************
	// ***********************************
	// ** Check that the stressExe is still running. Make sure lpFuturePointer (pointer to stressInstance that faulted) is valid
	// **
	if (!pStressInstance || !pStressInstance->IsRunning(STRESSINSTANCE_STRESS_EXE_CLOSE_TIMEOUT))
	{
		dwContinue = DEBUGGER_CONTINUE_STOP_DEBUGGING;
		goto Exit;
	}


	switch (dwFlags)
	{
		case DEBUGGER_FIRST_CHANCE_EXCEPTION:
			NetworkTools__SendLog(FIELDNAME__LOGTYPE_INFORMATION, "FIRST_CHANCE_EXCEPTION detected.", NULL, pStressInstance->Get_ID());
			//must use this to pass on first chance exceptions to the system
			dwContinue = DEBUGGER_CONTINUE_UNHANDLED;
			break;

		case DEBUGGER_SECOND_CHANCE_EXCEPTION:
			NetworkTools__SendLog(FIELDNAME__LOGTYPE_INFORMATION, "SECOND_CHANCE_EXCEPTION detected.", NULL, pStressInstance->Get_ID());

			// build directory to copy dump file
			DWORD	dwPathSize;

			dwPathSize		= MAX_PATH * 5;

			szASCIIPath		= new CHAR[dwPathSize];
			szPath			= new TCHAR[dwPathSize];
			szNum			= new TCHAR[100];
			szMachineName	= new TCHAR[MAX_PATH];

			if (!szASCIIPath || !szPath || !szNum || !szMachineName)
				goto Exit;


			// ******************************
			// create the directory STRESSINSTANCE_MEMORY_DUMP_PATH\<MachineName>
			//
			MultiByteToWideChar(
				CP_ACP,
				MB_PRECOMPOSED,
				g_objServerCommands.Get_ClientMachineName(),
				-1,
				szMachineName,
				MAX_PATH);

			// ******************************
			// ******************************
			// ** if the server sent a vaild path then use it, else use the default memory dump path
			// ** NOTE: we expect the dump path to already have a trailing slash.
			if (0 < _tcslen(pStressInstance->Get_StressExeMemoryDumpPath()))
				_tcscpy(szPath, pStressInstance->Get_StressExeMemoryDumpPath());
			else
				_tcscpy(szPath, STRESSINSTANCE_DEFAULT_MEMORY_DUMP_PATH);

			// add the machine name to the end of the directory
			_tcscat(szPath, szMachineName);

			CreateDirectory(szPath, NULL);

			// ******************************
			// create the filename in form "<stressExeFileName>-<stressInstanceID>-<PID>.dmp"
			_tcscat(szPath, _T("\\"));

			_tcscat(szPath, pStressInstance->m_szStressExe_FileName);
			_tcscat(szPath, _T("-"));

			_itot(pStressInstance->m_piStressExeProcess.dwProcessId, szNum, 10);
			_tcscat(szPath, szNum);
			_tcscat(szPath, _T("-"));

			_itot(pStressInstance->Get_StressInstanceRunID(), szNum, 10);
			_tcscat(szPath, szNum);
			_tcscat(szPath, _T(".dmp"));

			pStressInstance->m_objDebugger->CreateMiniDump(szPath, _T("This is a full user dump created by debugger.lib"), DEBUGGER_CREATE_FULL_MINI_DUMP);


			// ******************************
			// ** Convert to ansi so we can post it to the command server
			ZeroMemory(szASCIIPath, dwPathSize);
			WideCharToMultiByte(
				CP_ACP,
				NULL,
				szPath,
				-1,
				szASCIIPath,
				dwPathSize,
				NULL,
				NULL);

			// let the Command Server know a dump file was created
			NetworkTools__SendLog(FIELDNAME__LOGTYPE_DUMPFILE_CREATED, szASCIIPath, NULL, pStressInstance->Get_ID());


			// ******************************
			// ** Let the LOR server know that a DMP file was created so it can debug it
			NetworkTools__LogDumpFileInfo(szPath, pStressInstance->Get_StressInstanceRunID());

			// stop the debugger
			dwContinue = DEBUGGER_CONTINUE_STOP_DEBUGGING;
			break;

		case DEBUGGER_EXIT_PROCESS:
			dwContinue = DEBUGGER_CONTINUE_STOP_DEBUGGING;
			break;

		default:
			// let the Command Server know a dump file was created
			break;
	}


Exit:

	if (szASCIIPath)
		delete [] szASCIIPath;

	if (szPath)
		delete [] szPath;

	if (szNum)
		delete [] szNum;

	if (szMachineName)
		delete [] szMachineName;

	return dwContinue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\stress\stressscheduler\src\winhttpstressscheduler.h ===
///////////////////////////////////////////////////////////////////////////
// File:  WinHttpStressScheduler.h
//
// Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
// Purpose:
//	Global types and interfaces for the WinHttpStressScheduler project.
//
// History:
//	02/01/01	DennisCh	Created
///////////////////////////////////////////////////////////////////////////


#if !defined INC__WINHTTPSTRESSSCHEDULER_H
	#define  INC__WINHTTPSTRESSSCHEDULER_H


//////////////////////////////////////////////////////////////////////
// Constants
//////////////////////////////////////////////////////////////////////
#define _UNICODE

#define WINHTTP_STRESS_SCHEDULER__NAME	"WinHttp stressScheduler"
#define WINHTTP_WINHTTP_HOME_URL		"http://winhttp"
#define WINHTTP_STRESSADMIN_URL			"http://winhttp/stressAdmin/configure-client.asp?" FIELDNAME__CLIENT_ID "%u"

// used to notify the tray icon
#define MYWM_NOTIFYICON	(WM_APP+100)

#define WINHTTP_STRESS_SCHEDULER_MUTEX	"WinHttpStressScheduler"


//////////////////////////////////////////////////////////////////////
// Includes
//////////////////////////////////////////////////////////////////////

//
// WIN32 headers
//
#include <windows.h>
#include <tchar.h>

//
// Project headers
//
#include "res\resource.h"

#endif // defined INC__WINHTTPSTRESSSCHEDULER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\stress\stressscheduler\src\networktools.cpp ===
//////////////////////////////////////////////////////////////////////
// File:  NetworkTools.cpp
//
// Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
// Purpose:
//	NetworkTools.cpp: Helper functions that send/receive data.
//
// History:
//	02/22/01	DennisCh	Created
//
//////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////
//
// Includes
//
//////////////////////////////////////////////////////////////////////

//
// Project headers
//
#include "NetworkTools.h"
#include "ServerCommands.h"

//
// Win32 headers
//


//////////////////////////////////////////////////////////////////////
//
// Globals and statics
//
//////////////////////////////////////////////////////////////////////
extern ServerCommands	g_objServerCommands;	// Declared in WinHttpStressScheduler.cpp
extern HWND				g_hWnd;					// Declared in WinHttpStressScheduler.cpp


////////////////////////////////////////////////////////////
// Function:  NetworkTools__GetFileNameFromURL(LPTSTR)
//
// Purpose:
//	Returns the filename requested from an URL without a querystring.
//	For example, if szURL="http://dennisch/files/test.exe" we return "test.exe"
//
////////////////////////////////////////////////////////////
BOOL
NetworkTools__GetFileNameFromURL(
	LPTSTR	szURL,			// [IN]		Full URL containing the file
	LPTSTR	szBuffer,		// [OUT]	Buffer to store the filename from the URL
	DWORD	dwBufferSize	// [IN]		Size of buffer szFileName
)
{
	TCHAR	*pLastSlash;
	INT		iCharToLookFor;

	if (0 >= _tcslen(szURL))
		return FALSE;

	ZeroMemory(szBuffer, dwBufferSize);

	pLastSlash		= NULL;
	iCharToLookFor	= _T('/');

	// get the last instance of '/'
	pLastSlash = _tcsrchr(szURL, iCharToLookFor);

	// skip the last '/'
	pLastSlash++;

	if (!pLastSlash)
		return FALSE;

	// copy the filename.extension to the buffer
	_tcscpy(szBuffer, pLastSlash);

	return TRUE;
}


////////////////////////////////////////////////////////////
// Function:  NetworkTools__POSTResponse(LPTSTR, LPTSTR, LPTSTR)
//
// Purpose:
//	Sends a message to the Command Server results page 
//	via header/headervalue and/or POST data.
//
////////////////////////////////////////////////////////////
BOOL
NetworkTools__POSTResponse(
	LPTSTR	szURL,		// [IN] string containing URL to POST to
	LPSTR	szPostData,	// [IN] string containing POST data to send. can be NULL
	LPTSTR	szHeader	// [IN] string containing header(s) to send. can be NULL
)
{
	BOOL			bResult		= TRUE;
	HINTERNET		hRoot		= NULL;
	HINTERNET		hSession	= NULL;
	HINTERNET		hRequest	= NULL;
	URL_COMPONENTSW	urlComponents;


	// Allocate space for URL components
	ZeroMemory(&urlComponents, sizeof(urlComponents));

	urlComponents.dwSchemeLength	= MAX_PATH;
	urlComponents.lpszScheme		= new TCHAR[MAX_PATH];

	urlComponents.dwHostNameLength  = MAX_PATH;
	urlComponents.lpszHostName		= new TCHAR[MAX_PATH];

	urlComponents.dwUrlPathLength	= MAX_PATH;
	urlComponents.lpszUrlPath		= new TCHAR[MAX_PATH];

	urlComponents.dwExtraInfoLength = MAX_PATH;
	urlComponents.lpszExtraInfo		= new TCHAR[MAX_PATH];
	
	urlComponents.dwUserNameLength	= MAX_PATH;
	urlComponents.lpszUserName		= new TCHAR[MAX_PATH];

	urlComponents.dwPasswordLength	= MAX_PATH;
	urlComponents.lpszPassword		= new TCHAR[MAX_PATH];
	
	urlComponents.nPort				= 0;

	urlComponents.dwStructSize		= sizeof(URL_COMPONENTSW);

	if (!urlComponents.lpszScheme	|| !urlComponents.lpszHostName	||
		!urlComponents.lpszUrlPath	|| !urlComponents.lpszExtraInfo	||
		!urlComponents.lpszUserName	|| !urlComponents.lpszPassword)
	{
		goto Exit;
	}


	// crack the Command Server URL to be used later
	if (!WinHttpCrackUrl(
			szURL,
			_tcslen(szURL),
			ICU_ESCAPE,
			&urlComponents)
		)
	{
		bResult = FALSE;
		goto Exit;
	}

	hRoot = WinHttpOpen(
		STRESS_SCHEDULER_USER_AGENT,
		WINHTTP_ACCESS_TYPE_NO_PROXY,
		NULL,
		NULL,
		0);

	if (!hRoot)
	{
		bResult = FALSE;
		goto Exit;
	}

	hSession = WinHttpConnect(
		hRoot,
		urlComponents.lpszHostName,
		// If the URL in urlComponents uses standard HTTP or HTTPS ports then use INTERNET_DEFAULT_PORT. Otherwise use the non-standard port gleaned from the URL.
		((urlComponents.nPort == 80) || (urlComponents.nPort == 443)) ? INTERNET_DEFAULT_PORT : urlComponents.nPort,
		0);
	
	if (!hSession)
	{
		bResult = FALSE;
		goto Exit;
	}


	// Build a full URL with path and querystring
	TCHAR szFullPath[MAX_PATH*2];

	_tcsncpy(szFullPath, urlComponents.lpszUrlPath, urlComponents.dwUrlPathLength);
	szFullPath[urlComponents.dwUrlPathLength] = _T('\0');
	_tcsncat(szFullPath, urlComponents.lpszExtraInfo, urlComponents.dwExtraInfoLength);

	hRequest = WinHttpOpenRequest(
		hSession,
		_T("POST"),
		szFullPath,
		NULL,
		NULL,
		NULL,
		// if the URL in urlComponents uses HTTPS then pass in WINHTTP_FLAG_SECURE to this param. Otherwise, 0.
		(0 == _tcsnicmp(urlComponents.lpszScheme, _T("https"), 5)) ? WINHTTP_FLAG_SECURE : 0);

	if (!hRequest)
	{
		bResult = FALSE;
		goto Exit;
	}


	// Set reasonable timeouts just in case
	if (!WinHttpSetTimeouts(hRequest, 5000, 5000, 5000, 5000))
	{
		bResult = FALSE;
		goto Exit;
	}

	// Set result header if not NULL
	if (szHeader)
	{
		if (!WinHttpAddRequestHeaders(
				hRequest,
				szHeader,
				_tcsclen(szHeader),
				WINHTTP_ADDREQ_FLAG_ADD))
		{
			bResult = FALSE;
			goto Exit;
		}
	}


	bResult = WinHttpSendRequest(
		hRequest,
		_T("Content-Type: application/x-www-form-urlencoded"),
		-1L, 
		szPostData,
		strlen(szPostData),
		strlen(szPostData),
		0);

	if (!WinHttpReceiveResponse(hRequest, NULL))
	{
		bResult = FALSE;
		goto Exit;
	}


Exit:
	if (hRequest)
		WinHttpCloseHandle(hRequest);

	if (hSession)
		WinHttpCloseHandle(hSession);

	if (hRoot)
		WinHttpCloseHandle(hRoot);

	if (urlComponents.lpszScheme)
		delete [] urlComponents.lpszScheme;

	if (urlComponents.lpszHostName)
		delete [] urlComponents.lpszHostName;

	if (urlComponents.lpszUrlPath)
		delete [] urlComponents.lpszUrlPath;

	if (urlComponents.lpszExtraInfo)
		delete [] urlComponents.lpszExtraInfo;

	if (urlComponents.lpszPassword)
		delete [] urlComponents.lpszPassword;

	if (urlComponents.lpszUserName)
		delete [] urlComponents.lpszUserName;

	return bResult;
}


////////////////////////////////////////////////////////////
// Function:  NetworkTools__URLDownloadToFile(LPCTSTR, LPCTSTR, LPCTSTR)
//
// Purpose:
//	Downloads a file pointed to by the URL. Returns TRUE if succesfully downloaded.
//  FALSE if not. If the file is in use (ERROR_SHARING_VIOLATION) then we'll
//	return TRUE because the file is already on the system and is valid.
//
////////////////////////////////////////////////////////////
BOOL
NetworkTools__URLDownloadToFile(
LPCTSTR szURL,			// [IN] Fully qualified URL pointing to the file to download
LPCTSTR szTargetDir,	// [IN] A relative path to the directory to put szTargetFile in. If NULL, then it'll be put in the app's current dir.
LPCTSTR szTargetFile	// [IN] Name of the file to download to. Can be NULL. File will be placed in szTargetDir. If it already exists, then we'll try to overwrite it.
)
{
	HANDLE			hFile		= NULL;
	BOOL			bResult		= TRUE;
	HINTERNET		hRoot		= NULL;
	HINTERNET		hSession	= NULL;
	HINTERNET		hRequest	= NULL;
	URL_COMPONENTSW	urlComponents;
	LPVOID			lpBuffer	= NULL;
	DWORD			dwBytesToRead, dwBytesRead;


	// Allocate space for URL components
	ZeroMemory(&urlComponents, sizeof(urlComponents));

	urlComponents.dwSchemeLength	= MAX_PATH;
	urlComponents.lpszScheme		= new TCHAR[MAX_PATH];

	urlComponents.dwHostNameLength  = MAX_PATH;
	urlComponents.lpszHostName		= new TCHAR[MAX_PATH];

	urlComponents.dwUrlPathLength	= MAX_PATH;
	urlComponents.lpszUrlPath		= new TCHAR[MAX_PATH];

	urlComponents.dwExtraInfoLength = MAX_PATH;
	urlComponents.lpszExtraInfo		= new TCHAR[MAX_PATH];
	
	urlComponents.dwUserNameLength	= MAX_PATH;
	urlComponents.lpszUserName		= new TCHAR[MAX_PATH];

	urlComponents.dwPasswordLength	= MAX_PATH;
	urlComponents.lpszPassword		= new TCHAR[MAX_PATH];
	
	urlComponents.nPort				= 0;

	urlComponents.dwStructSize		= sizeof(URL_COMPONENTSW);


	if (!urlComponents.lpszScheme	|| !urlComponents.lpszHostName	||
		!urlComponents.lpszUrlPath	|| !urlComponents.lpszExtraInfo	||
		!urlComponents.lpszUserName	|| !urlComponents.lpszPassword)
	{
		goto Exit;
	}

	// crack the Command Server URL to be used later
	if (!WinHttpCrackUrl(
			szURL,
			_tcslen(szURL),
			ICU_ESCAPE,
			&urlComponents)
		)
	{
		bResult = FALSE;
		goto Exit;
	}

	hRoot = WinHttpOpen(
		STRESS_SCHEDULER_USER_AGENT,
		WINHTTP_ACCESS_TYPE_NO_PROXY,
		NULL,
		NULL,
		0);

	if (!hRoot)
	{
		bResult = FALSE;
		goto Exit;
	}

	hSession = WinHttpConnect(
		hRoot,
		urlComponents.lpszHostName,
		// If the URL in urlComponents uses standard HTTP or HTTPS ports then use INTERNET_DEFAULT_PORT. Otherwise use the non-standard port gleaned from the URL.
		((urlComponents.nPort == 80) || (urlComponents.nPort == 443)) ? INTERNET_DEFAULT_PORT : urlComponents.nPort,
		0);
	
	if (!hSession)
	{
		bResult = FALSE;
		goto Exit;
	}


	// Build a full URL with path and querystring
	TCHAR szFullPath[MAX_PATH*2];

	_tcsncpy(szFullPath, urlComponents.lpszUrlPath, urlComponents.dwUrlPathLength);
	szFullPath[urlComponents.dwUrlPathLength] = _T('\0');
	_tcsncat(szFullPath, urlComponents.lpszExtraInfo, urlComponents.dwExtraInfoLength);

	hRequest = WinHttpOpenRequest(
		hSession,
		_T("GET"),
		szFullPath,
		NULL,
		NULL,
		NULL,
		// if the URL in urlComponents uses HTTPS then pass in WINHTTP_FLAG_SECURE to this param. Otherwise, 0.
		(0 == _tcsnicmp(urlComponents.lpszScheme, _T("https"), 5)) ? WINHTTP_FLAG_SECURE : 0);

	if (!hRequest)
	{
		bResult = FALSE;
		goto Exit;
	}


	// Set reasonable timeouts just in case
	if (!WinHttpSetTimeouts(hRequest, 5000, 5000, 5000, 5000))
	{
		bResult = FALSE;
		goto Exit;
	}


	bResult = WinHttpSendRequest(
		hRequest,
		NULL,
		0, 
		NULL,
		0,
		0,
		0);

	if (!WinHttpReceiveResponse(hRequest, NULL))
	{
		bResult = FALSE;
		goto Exit;
	}


	// **********************************
	// **********************************
	// ** WinHttpQueryHeaders - make sure status is 200 before writing the file to disk.
	// **

	DWORD dwStatus, dwBufferSize;

	dwStatus		= 0;
	dwBufferSize	= sizeof(DWORD);
	if (!WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_STATUS_CODE | WINHTTP_QUERY_FLAG_NUMBER , NULL, &dwStatus, &dwBufferSize, NULL) ||
		(dwStatus != 200)
		)
	{
		OutputDebugString(_T("ERROR: NetworkTools__URLDownloadToFile: WinHttpQueryHeaders failed or dwStatus != 200"));

		bResult = FALSE;
		goto Exit;
	}


	// **********************************
	// **********************************
	// ** Get the filename and extenstion
	// ** from the URL
	// **
	TCHAR	szFileName[MAX_PATH];		// name of the new file to write to. will be created in szCurrentDir

	ZeroMemory(szFileName, sizeof(szFileName));

	// check to see if the user provided a filename to write to
	if (szTargetFile)
		_tcsncpy(szFileName, szTargetFile, MAX_PATH);
	else
	{
		// user did not specify a filename to write to, so we use the original one from the URL
		if (!NetworkTools__GetFileNameFromURL(urlComponents.lpszUrlPath, szFileName, sizeof(szFileName)))
		{
			bResult = FALSE;
			goto Exit;
		}
	}


	// **********************************
	// **********************************
	// ** Create the directory where the file will reside and set it as the current directory
	// **
	
	// if user specified NULL, then we put the file in the current dir.
	// else we set the current directory as the one specified
	if (szTargetDir)
	{
		// create the dir. don't care if it fails because it already exists...
		CreateDirectory(szTargetDir, NULL);
		SetCurrentDirectory(szTargetDir);
	}


	// create the file to download to.
	hFile = CreateFile(
		// if the user doesn't specify the filename to write to, use the one from the URL
		szFileName,
		GENERIC_WRITE,
		0,
		NULL,
		CREATE_ALWAYS,
		FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH,
		NULL);


	if ((hFile == INVALID_HANDLE_VALUE) || !hFile)
	{
		// We won't return FALSE if the file is in use. This means the file is valid.
		if (ERROR_SHARING_VIOLATION == GetLastError())
		{
			// File is in use that means winhttp is ok. we'll stress the old version
			bResult = TRUE;
			goto Exit;
		}
		else
		{
			bResult = FALSE;
			goto Exit;
		}
	}

	// **********************************
	// **********************************
	// ** Read data from net to file.
	// **
	// read 64K chunks at a time
	lpBuffer		= new LPVOID[65536];

	if (!lpBuffer)
		goto Exit;

	ZeroMemory(lpBuffer, 65536);
	dwBytesToRead	= 65536;
	dwBytesRead		= 65536;

	while (WinHttpReadData(hRequest, lpBuffer, dwBytesToRead, &dwBytesRead) && (0 != dwBytesRead))
	{
		WriteFile(hFile, lpBuffer, dwBytesRead, &dwBytesRead, NULL);

		dwBytesRead = 0;
		ZeroMemory(lpBuffer, 65536);
	}

Exit:
	if (hRequest)
		WinHttpCloseHandle(hRequest);

	if (hSession)
		WinHttpCloseHandle(hSession);

	if (hRoot)
		WinHttpCloseHandle(hRoot);

	if (hFile && (hFile != INVALID_HANDLE_VALUE))
		CloseHandle(hFile);

	if (lpBuffer)
		delete [] lpBuffer;

	// restore the current directory from the one that we created the new file in.
	SetCurrentDirectory(g_objServerCommands.Get_CurrentWorkingDirectory());

	delete [] urlComponents.lpszScheme;
	delete [] urlComponents.lpszHostName;
	delete [] urlComponents.lpszUrlPath;
	delete [] urlComponents.lpszExtraInfo;
	delete [] urlComponents.lpszPassword;
	delete [] urlComponents.lpszUserName;

	return bResult;
}


////////////////////////////////////////////////////////////
// Function:  NetworkTools__CopyFile(LPCTSTR, LPCTSTR)
//
// Purpose:
//	Wrapper for CopyFile. Copies file szSource to szDestination.
//	We'll always overwite the file if it already exists.
//
////////////////////////////////////////////////////////////
BOOL
NetworkTools__CopyFile(
	LPCTSTR szSource,
	LPCTSTR szDestination
)
{
	BOOL bResult = TRUE;
	
	if (!szSource || !szDestination)
	{
		bResult = FALSE;
		goto Exit;
	}

	bResult = CopyFile(szSource, szDestination, TRUE);

Exit:
	return bResult;
}


////////////////////////////////////////////////////////////
// Function:  NetworkTools__PageHeap(BOOL, LPCTSTR)
//
// Purpose:
//	Enables/Disables pageheap.
//
////////////////////////////////////////////////////////////
BOOL
NetworkTools__PageHeap(
	BOOL	bEnable,		// [IN] Enables/Disables pageheap.
	LPCTSTR	szAppName,		// [IN] The executable to enable or disable.
	LPCTSTR	szCommandLine	// [IN] Command line for pageheap.
)
{
	BOOL		bResult		= TRUE;
	HINSTANCE	hExe		= NULL;
	LPTSTR		szPHCommand = NULL;

	szPHCommand = new TCHAR[MAX_PATH];

	if (!szPHCommand)
		return FALSE;


	if (bEnable)
	{
		hExe = ShellExecute(g_hWnd, _T("open"), _T("pageheap.exe"), szCommandLine, NULL, SW_SHOWMINIMIZED);
	}
	else
	{
		ZeroMemory(szPHCommand, MAX_PATH);
		_tcscpy(szPHCommand, _T("/disable "));
		_tcscat(szPHCommand, szAppName);
		hExe = ShellExecute(g_hWnd, _T("open"), _T("pageheap.exe"), szPHCommand, NULL, SW_SHOWMINIMIZED);
	}

	// Error if HINSTANCE <= 32.
	if (32 >= (INT) hExe)
		bResult = FALSE;

	if (szPHCommand)
		delete [] szPHCommand;

	return bResult;
}


////////////////////////////////////////////////////////////
// Function:  NetworkTools__UMDH(LPCTSTR, DWORD, LPCTSTR)
//
// Purpose:
//	Enables/Disables UMDH.
//
////////////////////////////////////////////////////////////
BOOL
NetworkTools__UMDH(
	BOOL	bEnable,		// [IN] Enables/Disables UMDH.
	LPCTSTR	szAppName,		// [IN] The executable to dump.
	LPCTSTR	szCommandLine,	// [IN] Command line for UMDH.
	LPCTSTR szLogFile,		// [IN] Logfile to create
	DWORD	dwPID			// [IN] The PID of the process to dump
)
{
	BOOL		bResult		= TRUE;
	HINSTANCE	hExe		= NULL;
	LPTSTR		szCommand	= NULL;

	szCommand = new TCHAR[MAX_PATH];

	// build command line and run: "GFLAGS -i <stressExe name> +ust"
	ZeroMemory(szCommand, MAX_PATH);
	_tcscpy(szCommand, _T("-i "));
	_tcscat(szCommand, szAppName);
	_tcscat(szCommand, _T(" +ust"));
	hExe = ShellExecute(g_hWnd, _T("open"), DEBUGGER_TOOLS_PATH _T("gflags.exe"), szCommand, NULL, SW_SHOWMINIMIZED);


	// build the UMDH command line
	ZeroMemory(szCommand, MAX_PATH);
	_tcscpy(szCommand, _T("-f:stuff.log"));

	hExe = ShellExecute(g_hWnd, _T("open"), DEBUGGER_TOOLS_PATH _T("umdh.exe"), szCommand, NULL, SW_SHOWMINIMIZED);

	// Error if HINSTANCE <= 32.
	if (32 >= (INT) hExe)
		bResult = FALSE;

	if (szCommand)
		delete [] szCommand;

	return bResult;
}


////////////////////////////////////////////////////////////
// Function:  NetworkTools__SendLog(LPSTR, LPSTR, LPTSTR, DWORD)
//
// Purpose:
//	Sends a log to the Command Server. Takes the log type string and log string.
//	Sends the stressInstance ID and client machine name as part of the POST request.
//	If this is a general message, then the stressInstanceID should be set to zero. Otherwise
//	if and ID is supplied, then stressAdmin will log this to the stressInstanceLog table.
//	You can also add headers too.
//
////////////////////////////////////////////////////////////
BOOL
NetworkTools__SendLog(
	LPSTR	szLogType,
	LPSTR	szLogText,
	LPTSTR	szExtraHeaders,
	DWORD	dwStressInstanceID
)
{
	BOOL	bResult				= TRUE;
	LPSTR	szPostLogData		= NULL;
	CHAR	szStressInstanceID[10];
	LPSTR	szDllVersion		= NULL;
	LPSTR	szNumber			= NULL;
	DWORD	dwPostLogDataSize	= 0;

	szDllVersion	= new CHAR[MAX_PATH];
	szNumber		= new CHAR[10];

	if (!szDllVersion || !szNumber)
		goto Exit;

	if (!szLogType || !szLogText || !g_objServerCommands.Get_ClientMachineName())
	{
		OutputDebugStringA("NetworkTools__SendLog: ERROR: szLogType, szLogText, or g_objServerCommands.Get_ClientMachineName() is NULL.");
		bResult = FALSE;
		goto Exit;
	}

	dwPostLogDataSize	=	sizeof(FIELDNAME__STRESSINSTANCE_ID) + MAX_PATH;
	dwPostLogDataSize	+=	sizeof(FIELDNAME__LOG_TEXT) + strlen(szLogText);
	dwPostLogDataSize	+=	sizeof(FIELDNAME__USERINFO_MACHINENAME) + strlen(g_objServerCommands.Get_ClientMachineName());
	dwPostLogDataSize	+=	strlen(szLogType);
	dwPostLogDataSize	+=	sizeof(FIELDNAME__TESTINFO_TEST_DLL_VERSION) + MAX_PATH;

	szPostLogData		= new CHAR[dwPostLogDataSize];
	if (!szPostLogData)
		goto Exit;

	ZeroMemory(szPostLogData, dwPostLogDataSize);

	// ***************************
	// ** add the client's machine name
	strcpy(szPostLogData, FIELDNAME__USERINFO_MACHINENAME);
	strcat(szPostLogData, g_objServerCommands.Get_ClientMachineName());


	// ***************************
	// ** add the stressInstance ID if valid
	if (0 < dwStressInstanceID)
	{
		strcat(szPostLogData, "&" FIELDNAME__STRESSINSTANCE_ID);
		strcat(szPostLogData, _itoa(dwStressInstanceID, szStressInstanceID, 10));
	}


	// ***************************
	// ** add the log type data
	strcat(szPostLogData, "&");
	strcat(szPostLogData, szLogType);


	// ***************************
	// ** add the test dll version info
	if (
		g_objServerCommands.Get_TestDllFileName() &&
		NetworkTools__GetDllVersion(g_objServerCommands.Get_TestDllFileName(), g_objServerCommands.Get_CurrentWorkingDirectory(), szDllVersion, MAX_PATH)
		)
	{
		strcat(szPostLogData, "&" FIELDNAME__TESTINFO_TEST_DLL_VERSION);
		strcat(szPostLogData, szDllVersion);
	}


	// ***************************
	// ** add the log text data
	strcat(szPostLogData, "&" FIELDNAME__LOG_TEXT);
	strcat(szPostLogData, szLogText);


	// ***************************
	// ** Send the data
	bResult = NetworkTools__POSTResponse(STRESS_COMMAND_SERVER_LOGURL, szPostLogData, szExtraHeaders);
	OutputDebugStringA(szPostLogData);

Exit:
	if (szPostLogData)
		delete [] szPostLogData;

	if (szDllVersion)
		delete [] szDllVersion;

	if (szNumber)
		delete [] szNumber;

	return bResult;
}


////////////////////////////////////////////////////////////
// Function:  NetworkTools__GetHeaderValue(LPTSTR, LPTSTR, DWORD, LPVOID, DWORD)
//
// Purpose:
//	Sends a POST to an URL and retrieves a header for that URL.
//	This is used in getting numeric ID's such as clientID and stressInstanceRunID.
//
////////////////////////////////////////////////////////////
BOOL
NetworkTools__GetHeaderValue(
	LPTSTR	szURL,			// [IN]			The command server URL to get commands from
	LPSTR	szPostData,		// [IN]			string containing POST data to send. can be NULL
	LPTSTR	szHeaderName,	// [IN]			Name of the header to get the value for
	DWORD	dwInfoLevel,	// [IN]			Flags to pass to WinHttpQueryHeaders
	LPVOID	lpBuffer,		// [OUT]		Buffer to put the header value in
	LPDWORD	lpdwBufferSize	// [IN][OUT]	Size of the buffer. Returns # of bytes read.
)
{
	BOOL			bResult		= TRUE;
	HINTERNET		hRoot		= NULL;
	HINTERNET		hSession	= NULL;
	HINTERNET		hRequest	= NULL;
	URL_COMPONENTSW	urlComponents;


	// Allocate space for URL components
	ZeroMemory(&urlComponents, sizeof(urlComponents));

	urlComponents.dwSchemeLength	= MAX_PATH;
	urlComponents.lpszScheme		= new TCHAR[MAX_PATH];

	urlComponents.dwHostNameLength  = MAX_PATH;
	urlComponents.lpszHostName		= new TCHAR[MAX_PATH];

	urlComponents.dwUrlPathLength	= MAX_PATH;
	urlComponents.lpszUrlPath		= new TCHAR[MAX_PATH];

	urlComponents.dwExtraInfoLength = MAX_PATH;
	urlComponents.lpszExtraInfo		= new TCHAR[MAX_PATH];
	
	urlComponents.dwUserNameLength	= MAX_PATH;
	urlComponents.lpszUserName		= new TCHAR[MAX_PATH];

	urlComponents.dwPasswordLength	= MAX_PATH;
	urlComponents.lpszPassword		= new TCHAR[MAX_PATH];
	
	urlComponents.nPort				= 0;

	urlComponents.dwStructSize		= sizeof(URL_COMPONENTSW);


	if (!urlComponents.lpszScheme	|| !urlComponents.lpszHostName	||
		!urlComponents.lpszUrlPath	|| !urlComponents.lpszExtraInfo	||
		!urlComponents.lpszUserName	|| !urlComponents.lpszPassword)
	{
		goto Exit;
	}


	// crack the Command Server URL to be used later
	if (!WinHttpCrackUrl(
			szURL,
			_tcslen(szURL),
			ICU_ESCAPE,
			&urlComponents)
		)
	{
		bResult = FALSE;
		goto Exit;
	}

	hRoot = WinHttpOpen(
		STRESS_SCHEDULER_USER_AGENT,
		WINHTTP_ACCESS_TYPE_NO_PROXY,
		NULL,
		NULL,
		0);

	if (!hRoot)
	{
		bResult = FALSE;
		goto Exit;
	}

	hSession = WinHttpConnect(
		hRoot,
		urlComponents.lpszHostName,
		// If the URL in urlComponents uses standard HTTP or HTTPS ports then use INTERNET_DEFAULT_PORT. Otherwise use the non-standard port gleaned from the URL.
		((urlComponents.nPort == 80) || (urlComponents.nPort == 443)) ? INTERNET_DEFAULT_PORT : urlComponents.nPort,
		0);
	
	if (!hSession)
	{
		bResult = FALSE;
		goto Exit;
	}


	// Build a full URL with path and querystring
	TCHAR szFullPath[MAX_PATH*2];

	_tcsncpy(szFullPath, urlComponents.lpszUrlPath, urlComponents.dwUrlPathLength);
	szFullPath[urlComponents.dwUrlPathLength] = _T('\0');
	_tcsncat(szFullPath, urlComponents.lpszExtraInfo, urlComponents.dwExtraInfoLength);

	hRequest = WinHttpOpenRequest(
		hSession,
		_T("POST"),
		szFullPath,
		NULL,
		NULL,
		NULL,
		// if the URL in urlComponents uses HTTPS then pass in WINHTTP_FLAG_SECURE to this param. Otherwise, 0.
		(0 == _tcsnicmp(urlComponents.lpszScheme, _T("https"), 5)) ? WINHTTP_FLAG_SECURE : 0);

	if (!hRequest)
	{
		bResult = FALSE;
		goto Exit;
	}


	// Set reasonable timeouts just in case
	if (!WinHttpSetTimeouts(hRequest, 5000, 5000, 5000, 5000))
	{
		bResult = FALSE;
		goto Exit;
	}

	bResult = WinHttpSendRequest(
		hRequest,
		_T("Content-Type: application/x-www-form-urlencoded"),
		-1L, 
		szPostData,
		strlen(szPostData),
		strlen(szPostData),
		0);

	if (!WinHttpReceiveResponse(hRequest, NULL))
	{
		bResult = FALSE;
		goto Exit;
	}


	// ***************************
	// ** WinHttpQueryHeaders - get the first instance of the header the client requested
	DWORD dwIndex;

	dwIndex = 0;
	if (!WinHttpQueryHeaders(hRequest, dwInfoLevel, szHeaderName, lpBuffer, lpdwBufferSize, &dwIndex))
		bResult = FALSE;

Exit:
	if (hRequest)
		WinHttpCloseHandle(hRequest);

	if (hSession)
		WinHttpCloseHandle(hSession);

	if (hRoot)
		WinHttpCloseHandle(hRoot);

	if (urlComponents.lpszScheme)
		delete [] urlComponents.lpszScheme;

	if (urlComponents.lpszHostName)
		delete [] urlComponents.lpszHostName;

	if (urlComponents.lpszUrlPath)
		delete [] urlComponents.lpszUrlPath;

	if (urlComponents.lpszExtraInfo)
		delete [] urlComponents.lpszExtraInfo;

	if (urlComponents.lpszPassword)
		delete [] urlComponents.lpszPassword;

	if (urlComponents.lpszUserName)
		delete [] urlComponents.lpszUserName;

	return bResult;
}



////////////////////////////////////////////////////////////
// Function:  NetworkTools__GetDllVersion(LPTSTR, LPSTR, DWORD)
//
// Purpose:
//	Takes a DLL name and return the version as an ASCII string.
//	Looks the stressExe directory then in the system search path since
//	that's the version the stress app will be using.
//
////////////////////////////////////////////////////////////
BOOL
NetworkTools__GetDllVersion(
	LPTSTR	lpszDllName,
	LPTSTR	lpszDllPath,
	LPSTR	szVersionBuffer,
	DWORD	dwVersionBufferSize
)
{
	BOOL	bResult			= TRUE;
	DWORD	dwHandle;
	DWORD	dwVersionSize;
	LPSTR	szVersionInfo	= NULL;
	LPSTR	szVersionOutput	= NULL;
	LPTSTR	szTargetDLL		= NULL;
	UINT	uiLength;

	szTargetDLL = new TCHAR[MAX_PATH * 5 + 1 + sizeof(STRESSINSTANCE_STRESS_EXE_DOWNLOAD_DIR) + 1 + MAX_PATH];
	if (!szTargetDLL)
		goto Exit;

	ZeroMemory(szVersionBuffer, dwVersionBufferSize);
	ZeroMemory(szTargetDLL, MAX_PATH * 5);

	// all stressExe's run in c:\winhttpstress\stresexe so check that dir for winhttp5.dll first
	_tcscpy(szTargetDLL, lpszDllPath);
	_tcscat(szTargetDLL, _T("\\"));
	_tcscat(szTargetDLL, STRESSINSTANCE_STRESS_EXE_DOWNLOAD_DIR);
	_tcscat(szTargetDLL, _T("\\"));
	_tcscat(szTargetDLL, lpszDllName);

	dwVersionSize	= GetFileVersionInfoSize(szTargetDLL, &dwHandle);
	
	// try to get the path+dll name that was supplied
	if (0 >= dwVersionSize)
	{
		// DLL doesn't exit in that path so just do the DLL name and it'll use the system search path be default
		_tcscpy(szTargetDLL, lpszDllName);
		dwVersionSize	= GetFileVersionInfoSize(szTargetDLL, &dwHandle);

		if (0 >= dwVersionSize)
		{
			bResult = FALSE;
			goto Exit;
		}
	}

	// allocate new buffer for the query
	szVersionInfo = new CHAR[dwVersionSize];
	if (!szVersionInfo)
		goto Exit;


	ZeroMemory(szVersionInfo, dwVersionSize);
	if (!GetFileVersionInfo(szTargetDLL, NULL, dwVersionSize, szVersionInfo))
	{
		bResult = FALSE;
		goto Exit;
	}


	// *****************************
	// ** build the version info query string

	struct LANGANDCODEPAGE {
	  WORD wLanguage;
	  WORD wCodePage;
	} *lpTranslate;


	CHAR szVersionQuery[200];
	ZeroMemory(szVersionQuery, 200);

	// Read the list of languages and code pages.
	VerQueryValueA(szVersionInfo, 
				  "\\VarFileInfo\\Translation",
				  (LPVOID*)&lpTranslate,
				  &uiLength);

	// build the ver info query string that contains the language bits
	sprintf(szVersionQuery, "\\StringFileInfo\\%04x%04x\\ProductVersion", lpTranslate->wLanguage, lpTranslate->wCodePage);


	// *****************************
	// ** Get the version and copy to buffer
	uiLength = 0;
	if (!VerQueryValueA(szVersionInfo, szVersionQuery, (VOID **) &szVersionOutput, &uiLength))
	{
		bResult = FALSE;
		goto Exit;
	}

	// copy the version info string to the buffer
	strncpy(szVersionBuffer, (LPSTR) szVersionOutput, dwVersionBufferSize-1);


Exit:
	if (szTargetDLL)
		delete [] szTargetDLL;

	if (szVersionInfo)
		delete [] szVersionInfo;

	return bResult;
}



////////////////////////////////////////////////////////////
// Function:  NetworkTools__LogDumpFileInfo(LPTSTR, DWORD)
//
// Purpose:
//	Takes a string containing memory dump path name stressInstanceID
//	to log to the database. For now, we use LorAgent that does this for us.
//	It logs to their database.
//
//	The file "loragent.exe", "lordll.dll", and "stressme.ini" must be present
//	in the current directory, else we copy the files from \\control\stressme
//
////////////////////////////////////////////////////////////
BOOL
NetworkTools__LogDumpFileInfo(
	LPTSTR	szMemoryDumpPath,		// [IN] String containing memory dump path
	DWORD	dwStressInstanceRunID	// [IN] StressInstanceRunID
)
{
	BOOL		bResult				= TRUE;
	HINSTANCE	hExe				= NULL;
	LPTSTR		szCommandLine		= NULL;
	DWORD		dwCommandLineSize	= 0;

	if (!szMemoryDumpPath)
	{
		bResult = FALSE;
		goto Exit;
	}

	
	//	copy the "loragent.exe", "lordll.dll", and "stressme.ini" from \\control\stressme to current directory where stressScheduler lives
	NetworkTools__CopyFile(STRESSINSTANCE_LORAGENT_FILES_PATH _T("loragent.exe"),	_T("loragent.exe"));
	NetworkTools__CopyFile(STRESSINSTANCE_LORAGENT_FILES_PATH _T("lordll.dll"),		_T("lordll.dll"));
	NetworkTools__CopyFile(STRESSINSTANCE_LORAGENT_FILES_PATH _T("stressme.ini"),	_T("stressme.ini"));


	// build command line string
	dwCommandLineSize	= sizeof(STRESSINSTANCE_LOG_DUMP_COMMANDLINE) + _tcsclen(szMemoryDumpPath) + MAX_PATH;
	szCommandLine		= new TCHAR[dwCommandLineSize];

	if (!szCommandLine)
		goto Exit;

	ZeroMemory(szCommandLine, dwCommandLineSize);
	_stprintf(szCommandLine, STRESSINSTANCE_LOG_DUMP_COMMANDLINE, szMemoryDumpPath, dwStressInstanceRunID);

	hExe = ShellExecute(g_hWnd, _T("open"), _T("loragent.exe"), szCommandLine, NULL, SW_SHOWMINIMIZED);

	// wait for logging to complete before returning
	Sleep(4000);

	// Error if HINSTANCE <= 32.
	if (32 >= (INT) hExe)
		bResult = FALSE;

Exit:
	if (szCommandLine)
		delete [] szCommandLine;

	return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\stress\stressscheduler\src\stressinstance.h ===
//////////////////////////////////////////////////////////////////////
// File:  StressInstance.h
//
// Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
// Purpose:
//	StressInstance.h: interface for the StressInstance class.
//	This class is used spawn and monitor instances of the stressEXE app.
//
// History:
//	02/15/01	DennisCh	Created
//
//////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////
// Includes
//////////////////////////////////////////////////////////////////////

//
// WIN32 headers
//
#define UNICODE
#define _UNICODE

#include <stdio.h>
#include <windows.h>
#include <tchar.h>
#include <winhttp.h>

//
// Project headers
//
#include <debugger.h>

//////////////////////////////////////////////////////////////////////
// Constants
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_STRESSINSTANCE_H__806226FB_2170_4FE3_ACCA_EF8952E6A524__INCLUDED_)
#define AFX_STRESSINSTANCE_H__806226FB_2170_4FE3_ACCA_EF8952E6A524__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


#define	RESPONSE_HEADER__STRESS_BEGIN			_T("WinHttpStress_Begin: Begin Stress")
#define	RESPONSE_HEADER__STRESS_END				_T("WinHttpStress_End: End Stress")


// ***************************
// ** max string URL length
#define MAX_STRESS_URL							MAX_PATH * 2


// ***************************
// ** time to check the stress exe in milliseconds
#define STRESSINSTANCE_MONITOR_EXE_TIME			600000	// 10 minutes

// ***************************
// ** Command line CreateProcess will use.
#define STRESSINSTANCE_DEBUG_COMMANDLINE		_T("\"%s\"")

// ***************************
// ** Command line CreateProcess will use for logging memory dump file info
/*
//	loragent switches
//				/d uncpathdumpfilename
//				/k kill switch 
//				/a addinfo1|addinfo2
//				/m WinHTTP Debug
//
//	Parameters we use:
//		/d <DUMP_FILE_PATH> /a <StressInstanceRunID>
*/
#define STRESSINSTANCE_LOG_DUMP_COMMANDLINE		_T("/d %s /a %u /m WinHttp_Stress")


// path to get loragent.exe, lordll.dll, and stressme.ini
// these files are used to enable dump file logging and auto-debugging of crashes
#define STRESSINSTANCE_LORAGENT_FILES_PATH		_T("\\\\control\\stressme\\")


// ***************************
// ** Memory dump path
#define	STRESSINSTANCE_DEFAULT_MEMORY_DUMP_PATH	_T("\\\\mildew\\stress\\")

// ***************************
// ** relative path to the directory where the stressExe files will be downloaded to.
#define STRESSINSTANCE_STRESS_EXE_DOWNLOAD_DIR	_T("stressExe")

// ***************************
// ** Time to wait for stressExe to close after telling it
#define STRESSINSTANCE_STRESS_EXE_CLOSE_TIMEOUT	100

// ***************************
// ** Cross process event object names. We append the PID of the process to the end to prevent name collisions.
#define STRESSINSTANCE_STRESS_EXE_EVENT_EXITPROCESS			_T("ExitProcessEvent")


class StressInstance  
{
public:
				StressInstance();
	virtual		~StressInstance();

	BOOL		Begin();
	VOID		End();
	BOOL		IsRunning(DWORD);

	DWORD		Get_ID();
	LPTSTR		Get_StressExeMemoryDumpPath();
	DWORD		Get_StressInstanceRunID();

	VOID		Set_StressExeMemoryDumpPath(LPTSTR);
	VOID		Set_StressExeURL(LPTSTR);
	VOID		Set_StressExePdbURL(LPTSTR);
	VOID		Set_StressExeSymURL(LPTSTR);
	VOID		Set_StressExeID(DWORD);
	VOID		Set_PageHeapCommands(LPCTSTR);
	VOID		Set_UMDHCommands(LPCTSTR);

	BOOL		DownloadStressExe();

				// This is the timer callback proc that monitors the stressExe process.
	friend		VOID CALLBACK StressExe_TimerProc(HWND, UINT, UINT_PTR, DWORD);

				// This is the timer callback proc for the debugger object
	friend		DWORD DebuggerCallbackProc(DWORD, LPVOID, LPTSTR, LPVOID);

private:
	LPTSTR		m_szStressExe_URL;					// URL to the stress app
	LPTSTR		m_szStressExe_PDB_URL;				// URL to the stress app's pdb file
	LPTSTR		m_szStressExe_SYM_URL;				// URL to the stress app's sym file
	LPTSTR		m_szStressExe_FilePath;				// Local relative path of the downloaded stress EXE
	LPTSTR		m_szStressExe_FileName;				// Local filename of the downloaded stress EXE
	LPTSTR		m_szStressExe_FilePathAndName;		// Path and filename to the local stressExe downloaded
	LPTSTR		m_szStressExe_PageHeapCommandLine;	// Command line params when enabling pageheap.
	LPTSTR		m_szStressExe_UMDHCommandLine;		// Command line params when enabling UMDH.

	DWORD		m_dwStressInstance_ID;				// ID from the stressAdmin DB uniquely identifying this test case.
	DWORD		m_dwStressInstanceRunID;			// the stressInstanceRunID generated by the DB that we cache as soon as this instance starts.

	LPTSTR		m_szStressExe_MemDumpPath;			// path that the minidump will dump to

	Debugger	*m_objDebugger;						// the debughelp debugger object

	PROCESS_INFORMATION 	m_piStressExeProcess;	// stuct containing info on the stressExe process
	HANDLE					m_hStressExe_ProcessExitEvent;	// Cross process event we send stressExe to tell it to exit

	UINT_PTR				m_uiStressExeTimerID;	// ID for the timer that monitors the stressExe when it's spawned
};


#endif // !defined(AFX_STRESSINSTANCE_H__806226FB_2170_4FE3_ACCA_EF8952E6A524__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\stressexe\stresstesttemplate\stressmain.cpp ===
//////////////////////////////////////////////////////////////////////
// File:  stressMain.cpp
//
// Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
// Purpose:
//		This is an empty template for WinHttp stressScheduler stress apps.
//		The stress test lives in WinHttp_StressTest() and will be called
//		repeatedly in the main function.
//
//		This process will inherit a named event handle from 
//		stressScheduler in the form: "ExitProcessEvent" + <PID of this process>.
//		When the stressScheduler sets the object state to signaled, then
//		the stress test application must exit immediately.
//
//		If this app is running without the stressScheduler, use the
//		"/s" switch to run the standalone mode. The app will exit when the user
//		sends a break message (CTRL-C).
//
//		This stress test will continue to run if:
//
//			When not using any switches:
//			- The "ExitProcessEvent" object inherited from stressScheduler is in the un-signaled state
//			- WinHttp_StressTest() returns true
//
//			When using the "/s" standalone switch:
//			- WinHttp_StressTest() returns true
//
// History:
//	03/30/01	DennisCh	Created
//
//////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////
// Includes
//////////////////////////////////////////////////////////////////////

// Project headers
#include "stressMain.h"


//////////////////////////////////////////////////////////////////////
// Globals and statics
//////////////////////////////////////////////////////////////////////

// ****************************
// ** The name of the stress test and your stress test function
// ** should be declared in a seperate file.
extern	LPSTR	g_szStressTestName;
extern	BOOL	WinHttp_StressTest();

// ****************************
// ** hande to the name exit event object inherited from the stressScheduler
HANDLE	g_hExitEvent		= NULL;

// ****************************
// ** FALSE = run with stressScheduler, TRUE = run without stressScheduler
BOOL	g_bStandAloneMode	= FALSE;


////////////////////////////////////////////////////////////
// Function:  LogText(DWORD, LPCSTR)
//
// Purpose:
//	Prints text.
//
////////////////////////////////////////////////////////////
VOID
LogText(
	LPCSTR	szLogText,
	...
)
{
    CHAR	szBuffer[1024] = {0};
    va_list	vaList;

	if (!szLogText)
		return;

    va_start( vaList, szLogText );
    _vsnprintf( szBuffer, sizeof(szBuffer), szLogText, vaList );

    printf("%s\n", szBuffer);

    va_end(vaList);
}


////////////////////////////////////////////////////////////
// Function:  GetExitEventHandle()
//
// Purpose:
//	This opens a named event object inherited from the stressScheduler.
//	The object is in the form: "ExitProcessEvent" + <PID of current process>
//	By default this is in the unsignaled state. When the stressScheduler
//	sets it to signaled, then it's time for the stress App to exit.
//
////////////////////////////////////////////////////////////
HANDLE
GetExitEventHandle()
{
	CHAR	szPID[32];
	CHAR	szExitProcessName[sizeof(EXIT_PROCESS_EVENT_NAME) + sizeof(szPID)];
	HANDLE	hExitEvent			= NULL;

	// if user used the "/S" switch, we run without the stressScheduler and exit when user
	// tells us to instead. No need to get inherited event object from stressScheduler
	if (g_bStandAloneMode)
		return NULL;

	// wait for the stressScheduler to create the event object before trying to obtain it.
	Sleep(4000);

	// Get the processID string
	_itoa(_getpid(), szPID, 10);

	// build ExitProcess event object name
	ZeroMemory(szExitProcessName, sizeof(szExitProcessName));
	strcpy(szExitProcessName, EXIT_PROCESS_EVENT_NAME);
	strcat(szExitProcessName, szPID);

	LogText("\n[ Opening inherited named event object \"%s\". ]", szExitProcessName);

	hExitEvent = OpenEvent(EVENT_ALL_ACCESS, FALSE, szExitProcessName);

	if (!hExitEvent)
		LogText("[ ERROR: OpenEvent() failed to open object \"%s\". GetLastError() = %u ]\n", szExitProcessName, GetLastError());
	else
		LogText("[ OpenEvent() opened object \"%s\". ] \n", szExitProcessName);

	return hExitEvent;
}


////////////////////////////////////////////////////////////
// Function:  IsTimeToExitStress()
//
// Purpose:
//	Returns TRUE if the exit event object is signaled or NULL. FALSE if not.
//	The object is in the form: "ExitProcessEvent" + <PID of current process>
//	By default this is in the unsignaled state. When the stressScheduler
//	sets it to signaled, then it's time for the stress App to exit.
//
////////////////////////////////////////////////////////////
BOOL
IsTimeToExitStress()
{
	BOOL bResult = FALSE;

	// if user used the "/S" switch, we run without the stressScheduler and exit when user
	// tells us to instead.
	if (g_bStandAloneMode)
		return FALSE;

	if (!g_hExitEvent)
	{
		bResult = TRUE;
		goto Exit;
	}

	if (WAIT_OBJECT_0 == WaitForSingleObject(g_hExitEvent, 0))
		bResult = TRUE;

Exit:
	return bResult;
}


////////////////////////////////////////////////////////////
// Function:  main(INT, LPSTR)
//
// Purpose:
//	Program entry point.
//
////////////////////////////////////////////////////////////
INT
main(
	INT		argc,
	LPSTR	argv[]
)
{
	DWORD	dwIndex		= 0;

	// **************************
	// **************************
	// ** Parse command line arguments
	// **
    if (argc >= 2)
    {
		// print out options
		if (0 == stricmp(argv[1], "/?") || 0 == stricmp(argv[1], "-?"))
		{
	        LogText("USAGE: '/S' to run in standalone mode with the stressScheduler.\n\n");
		    goto Exit;
		}

		// run in standalone mode without stressScheduler
		if (0 == stricmp(argv[1], "/S") || 0 == stricmp(argv[1], "-S"))
		{
			LogText("[ Running in standalone mode. \"/S\" switch used. ]\n\n");
			g_bStandAloneMode = TRUE;
		}
    }


	// **************************
	// **************************
	// ** open the exit event object inherited from WinHttpStressScheduler
	// **
	g_hExitEvent	= GetExitEventHandle();
	if (!g_bStandAloneMode && !g_hExitEvent)
		goto Exit;


	// **************************
	// **************************
	// ** run the stress test until stressScheduler tells us to exit or the stress app does
	// **
	while (!IsTimeToExitStress() && WinHttp_StressTest())
		LogText("[ Running stressExe \"%s\" iteration #%u ]\n", g_szStressTestName, ++dwIndex);

Exit:
	if (g_hExitEvent)
		CloseHandle(g_hExitEvent);

	LogText("[ Exiting test case \"%s\" ]", g_szStressTestName);

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\stress\stressscheduler\src\servercommands.h ===
//////////////////////////////////////////////////////////////////////
// File:  WinHttpStressScheduler.h
//
// Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
// Purpose:
//	ServerCommands.h: interface for the ServerCommands class.
//	This class is used to retrieve and act on command from the server.
//
// History:
//	02/08/01	DennisCh	Created
//
//////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////
// Includes
//////////////////////////////////////////////////////////////////////

//
// WIN32 headers
//
#define UNICODE
#define _UNICODE

#include <stdio.h>
#include <shlwapi.h>
#include <windows.h>
#include <tchar.h>
#include <winhttp.h>
#include <vector>

//
// Project headers
//
#include "StressInstance.h"


//////////////////////////////////////////////////////////////////////
// Constants
//////////////////////////////////////////////////////////////////////
#if !defined(AFX_SERVERCOMMANDS_H__6B84102D_2F79_4FE0_A936_ED4F043AC75E__INCLUDED_)
#define AFX_SERVERCOMMANDS_H__6B84102D_2F79_4FE0_A936_ED4F043AC75E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRESS_SCHEDULER_USER_AGENT						_T("WinHttp Stress Scheduler")

#define STRESS_COMMAND_SERVER_URL						_T("http://winhttp/stressAdmin/stressCommand.asp")

// When we first start up, we report our client stats and post them to this page to let the server know that we're alive
#define STRESS_COMMAND_SERVER_REGISTERCLIENT_URL		_T("http://winhttp/stressAdmin/registerClient.asp")
#define STRESS_COMMAND_SERVER_LOGURL					_T("http://winhttp/stressAdmin/logStress.asp")

#define STRESS_COMMAND_SERVER_UPDATE_INTERVAL			10000		// 10 second default timeout
#define STRESS_COMMAND_SERVER_MINIMUM_UPDATE_INTERVAL	2000		// 2 second minimum timeout. Don't want to flood the network.
#define STRESS_COMMAND_SERVER_MAXIMUM_UPDATE_INTERVAL	300000		// 5 minute maximum timeout. Don't want to lose you!


#define MAX_URL											MAX_PATH * 2

// Timer related definitions
#define IDT_QUERY_COMMAND_SERVER						1			// timer identifier for pinging the command server


// List of URLs for the stress EXE's that we need to download
using namespace std;

typedef StressInstance			*PSTRESSINSTANCE;
typedef vector<PSTRESSINSTANCE>	PSTRESSINSTANCE_LIST;

// *****************************************************
// *****************************************************
// *** List of headers that the command server can send us.
// *** 
#define COMMANDHEADER__EXIT						_T("WinHttpStress_Exit")					// valid values: None. If the header is present, then assume we want to exit.
#define COMMANDHEADER__WINHTTP_DLL_URL			_T("WinHttpStress_WinHttpDllURL")			// valid values: Valid URL
#define COMMANDHEADER__WINHTTP_PDB_URL			_T("WinHttpStress_WinHttpPDBURL")			// valid values: Valid URL
#define COMMANDHEADER__WINHTTP_SYM_URL			_T("WinHttpStress_WinHttpSYMURL")			// valid values: Valid URL
#define COMMANDHEADER__ABORT					_T("WinHttpStress_Abort")					// valid values: ID of a stressInstance from the DB that needs to be aborted
#define COMMANDHEADER__MEMORY_DUMP_PATH			_T("WinHttpStress_MemoryDumpPath")			// valid values: Valid path
#define COMMANDHEADER__STRESS_EXE_URL			_T("WinHttpStress_StressExeURL")			// valid values: Valid URL
#define COMMANDHEADER__STRESS_PDB_URL			_T("WinHttpStress_StressPDBURL")			// valid values: Valid URL
#define COMMANDHEADER__STRESS_SYM_URL			_T("WinHttpStress_StressSYMURL")			// valid values: Valid URL
#define COMMANDHEADER__STRESS_EXE_INSTANCEID	_T("WinHttpStress_StressExeInstanceID")		// valid values: Valid ID from the stressAdmin DB table identifying the stressInstance. This is how stressScheduler tells stressAdmin the status of each stressInstance.
#define COMMANDHEADER__STRESS_EXE_PAGEHEAP		_T("WinHttpStress_PageHeapCommand")			// valid values: pageheap command line. will not use pageheap if missing
#define COMMANDHEADER__STRESS_EXE_UMDH			_T("WinHttpStress_UMDHCommand")				// valid values: UMDH command line. will not use UMDH if missing
#define COMMANDHEADER__COMMANDSERVER_URL		_T("WinHttpStress_CommandServerURL")		// valid values: Valid URL
#define COMMANDHEADER__BEGIN_TIME_HOUR			_T("WinHttpStress_BeginTimeHour")			// valid values: 0-23
#define COMMANDHEADER__BEGIN_TIME_MINUTE		_T("WinHttpStress_BeginTimeMinute")			// valid values: 0-59
#define COMMANDHEADER__END_TIME_HOUR			_T("WinHttpStress_EndTimeHour")				// valid values: 0-23
#define COMMANDHEADER__END_TIME_MINUTE			_T("WinHttpStress_EndTimeMinute")			// valid values: 0-59
#define COMMANDHEADER__RUN_FOREVER				_T("WinHttpStress_RunForever")				// valid values: 0 or 1
#define COMMANDHEADER__DO_NOT_RUN_FOREVER		_T("WinHttpStress_DoNotRunForever")			// valid values: 0 or 1
#define COMMANDHEADER__UPDATE_INTERVAL			_T("WinHttpStress_UpdateInterval")			// valid values: Time to wait to ping the command server in milliseconds.
#define COMMANDHEADER__STRESSINSTANCE_RUN_ID	_T("WinHttpStress_StressInstanceRunID")		// valid values: A numeric ID
#define COMMANDHEADER__CLIENT_ID				_T("WinHttpStress_ClientID")				// valid values: A numeric ID


// *****************************************************
// *****************************************************
// *** List of form names and values that we send back to the command server
// *** 

// **********************
// ** Logging POST fields
#define FIELDNAME__LOGTYPE						"LogType="
#define FIELDNAME__LOGTYPE_INFORMATION			FIELDNAME__LOGTYPE "INFORMATION"
#define FIELDNAME__LOGTYPE_START_UP				FIELDNAME__LOGTYPE "STRESS_SCHEDULER_START_UP"
#define FIELDNAME__LOGTYPE_EXIT					FIELDNAME__LOGTYPE "STRESS_SCHEDULER_EXIT"
#define FIELDNAME__LOGTYPE_MEMORY_INFORMATION	FIELDNAME__LOGTYPE "MEMORY_INFORMATION"
#define FIELDNAME__LOGTYPE_DUMPFILE_CREATED		FIELDNAME__LOGTYPE "DUMP_FILE_CREATED"
#define FIELDNAME__LOGTYPE_ERROR				FIELDNAME__LOGTYPE "ERROR"
#define FIELDNAME__LOGTYPE_SUCCESS				FIELDNAME__LOGTYPE "SUCCESS"
#define FIELDNAME__LOGTYPE_BEGIN_STRESS			FIELDNAME__LOGTYPE "BEGIN_STRESS"
#define FIELDNAME__LOGTYPE_END_STRESS			FIELDNAME__LOGTYPE "END_STRESS"
#define FIELDNAME__LOGTYPE_BEGIN				FIELDNAME__LOGTYPE "BEGIN_STRESS_INSTANCE"
#define FIELDNAME__LOGTYPE_RUNNING				FIELDNAME__LOGTYPE "ISRUNNING_STRESS_INSTANCE"
#define FIELDNAME__LOGTYPE_END					FIELDNAME__LOGTYPE "END_STRESS_INSTANCE"

#define FIELDNAME__LOG_TEXT				"LogText="
#define FIELDNAME__STRESSINSTANCE_ID	"StressInstanceID="


// **********************
// ** System information for registering the client POST fields.

// StressExe process return values
#define FIELDNAME__STRESSEXE_PRIVATEBYTES		"StressExe_PrivateBytes=%d"
#define FIELDNAME__STRESSEXE_HANDLECOUNT		"StressExe_HandleCount=%d"
#define FIELDNAME__STRESSEXE_THREADCOUNT		"StressExe_ThreadCount=%d"

// System Memory Info
#define FIELDNAME__MEMORY_HANDLES						"System_Handles=%d"
#define FIELDNAME__MEMORY_THREADS						"System_Threads=%d"
#define FIELDNAME__MEMORY_VMSIZE						"System_VMSize=%d"
#define FIELDNAME__MEMORY_COMMITTEDPAGEFILETOTAL		"System_CommittedPageFileTotal=%d"
#define FIELDNAME__MEMORY_AVAILABLEPAGEFILETOTAL		"System_AvailablePageFileTotal=%d"
#define FIELDNAME__MEMORY_SYSTEMCODETOTAL				"System_SystemCodeTotal=%d"
#define FIELDNAME__MEMORY_SYSTEMDRIVERTOTAL				"System_SystemDriverTotal=%d"
#define FIELDNAME__MEMORY_NONPAGEDPOOLTOTAL				"System_NonPagedPoolTotal=%d"
#define FIELDNAME__MEMORY_PAGEDPOOLTOTAL				"System_PagedPoolTotal=%d"
#define FIELDNAME__MEMORY_PHYSICAL_MEMORY_AVAILABLE		"System_PhysicalMemoryAvailable=%d"
#define FIELDNAME__MEMORY_SYSTEMCACHETOTAL				"System_SystemCacheTotal=%d"
#define FIELDNAME__MEMORY_FREESYSTEM_PAGETABLE_ENTRIES	"System_FreeSystemPageTableEntries=%d"
#define FIELDNAME__MEMORY_DISK_SPACE_AVAILABLE			"System_DiskSpaceAvailable=%d"

// Processor Info
#define FIELDNAME__SYSTEMINFO_PROCSSSOR_ARCHITECTURE	"StressExeSystemInfo_ProcessorArchitecture="
#define FIELDNAME__SYSTEMINFO_PROCSSSOR_ID				"StressExeSystemInfo_ProcessorID="
#define FIELDNAME__SYSTEMINFO_PROCSSSOR_LEVEL			"StressExeSystemInfo_ProcessorLevel="
#define FIELDNAME__SYSTEMINFO_PROCSSSOR_REVISION		"StressExeSystemInfo_ProcessorRevision="
#define FIELDNAME__SYSTEMINFO_PROCSSSOR_NUMBER_OF		"StressExeSystemInfo_ProcessorNumberOf="

// OS Info
#define FIELDNAME__OS_PLATFORM		"StressExeOSInfo_Platform="
#define FIELDNAME__OS_BUILD			"StressExeOSInfo_Build="
#define FIELDNAME__OS_MAJORVERSION	"StressExeOSInfo_MajorVersion="
#define FIELDNAME__OS_MINORVERSION	"StressExeOSInfo_MinorVersion="
#define FIELDNAME__OS_EXTRAINFO		"StressExeOSInfo_ExtraInfo="

// User Info
#define FIELDNAME__USERINFO_USERALIAS		"StressExeUserInfo_Alias="
#define FIELDNAME__USERINFO_USERDOMAIN		"StressExeUserInfo_Domain="
#define FIELDNAME__USERINFO_FULLNAME		"StressExeUserInfo_FullName="
#define FIELDNAME__USERINFO_MACHINENAME		"StressExeUserInfo_MachineName="

// Test info
#define FIELDNAME__TESTINFO_TEST_DLL_VERSION	"StressExeTestInfo_TestDLLVersion="

// ID's
#define FIELDNAME__CLIENT_ID					"ClientID="
#define FIELDNAME__STRESSEXE_ID					"StressExeID="
#define FIELDNAME__STRESSINSTANCE_ID			"StressInstanceID="

// DataBase ID Query POST fields
#define	POSTSTRING__GET_STRESSINSTANCERUN_ID	"option=GetStressInstanceRunID&"	FIELDNAME__CLIENT_ID			"%u&" FIELDNAME__STRESSINSTANCE_ID "%u"
#define	POSTSTRING__GET_CLIENT_ID				"option=GetClientID&"				FIELDNAME__USERINFO_MACHINENAME "%s&" FIELDNAME__USERINFO_USERALIAS "%s&" FIELDNAME__USERINFO_USERDOMAIN "%s"



class ServerCommands  
{
public:

	// *****************************************************
	// *****************************************************
	// ** Public ServerCommands methods
	// ** 
			ServerCommands();
	virtual	~ServerCommands();

	BOOL	QueryServerForCommands();

	BOOL	IsStressRunning();
	BOOL	IsTimeToBeginStress();
	BOOL	IsTimeToExitStress();

	BOOL	Download_WinHttpDLL();

	VOID	Clear_StressExeURLs();

	DWORD	Get_ClientID();
	LPSTR	Get_ClientMachineName();
	DWORD	Get_CommandServerUpdateInterval();
	LPTSTR	Get_CommandServerURL();
	LPTSTR	Get_CurrentWorkingDirectory();
	DWORD	Get_NumberOfStressInstances();
	LPTSTR	Get_TestDllFileName();

	VOID	Create_StressInstance(DWORD, LPTSTR, LPTSTR, LPTSTR, LPTSTR, LPTSTR, LPTSTR);

	BOOL	RegisterClient();

	VOID	Set_WinHttpDllURL(LPTSTR, DWORD);
	VOID	Set_WinHttpPDBURL(LPTSTR, DWORD);
	VOID	Set_WinHttpSYMURL(LPTSTR, DWORD);
	VOID	Set_CommandServerURL(LPTSTR, DWORD);
	VOID	Set_CommandServerUpdateInterval(DWORD);
	VOID	Set_TimeStressBegins(LPTSTR, LPTSTR);
	VOID	Set_TimeStressEnds(LPTSTR, LPTSTR);
	VOID	Set_RunForever(BOOL);
	VOID	Set_ExitStress(BOOL);

	VOID	BeginStress();
	VOID	EndStress();
	VOID	AbortStressInstance(DWORD);


private:
	// *****************************************************
	// *****************************************************
	// ** These vars contain commands(headers) from the command server
	// **
	LPTSTR		m_szCommandServerURL;					// Command server URL to request commands from

	DWORD		m_dwCommandServerUpdateInternval;		// Time to wait to ping the server for commands in milliseconds.
	DWORD		m_dwClientID;							// a unique identifier generated by the DataBase given a MACHINENAME and DOMAIN\USERNAME pair

	LPTSTR		m_szWinHttpDLL_DownloadURL;				// Where to get the latest WinHttp from
	LPTSTR		m_szWinHttpPDB_DownloadURL;				// Where winhttp's PDB symbol file from
	LPTSTR		m_szWinHttpSYM_DownloadURL;				// Where winhttp's SYM symbol file from
	LPTSTR		m_szWinHttpDLL_FileName;				// Filename of the WinHttp DLL.

	LPSTR		m_szClientMachineName;					// Computer name of the client
	LPTSTR		m_szStressSchedulerCurrentDirectory;	// stressScheduler's current directory.

	INT			m_iTimeStressBeginsHour;				// 0-23
	INT			m_iTimeStressBeginsMinute;				// 0-59
	INT			m_iTimeStressEndsHour;					// 0-23
	INT			m_iTimeStressEndsMinute;				// 0-59

	BOOL		m_bRunForever;							// 1 to run stress until stopped and 0 to rely on begin/end times

	BOOL		m_bExit;								// Quit signal from server to exit the app
	BOOL		m_bStressHasStarted;					// TRUE = started; FALSE = inactive

	PSTRESSINSTANCE_LIST			m_arStressInstanceList;		// List of URLs for the stress EXEs to download
	PSTRESSINSTANCE_LIST::iterator	m_dwStressInstanceIterator;	// Iterator for m_arszStressExeList
};

#endif // !defined(AFX_SERVERCOMMANDS_H__6B84102D_2F79_4FE0_A936_ED4F043AC75E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\stressexe\authsecureproxystress\authsecureproxystress.cpp ===
//////////////////////////////////////////////////////////////////////
// File:  AuthSecureProxyStress.cpp
//
// Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
// Purpose:
//		This file contains your implementation of the stress test function
//		WinHttp_StressTest() that is called in stressMain.cpp.
//
//		Steps:
//			- Set your test case name in g_szStressTestName.
//			- Add your test code to WinHttp_StressTest(). 
//
// History:
//	04/02/01	adamb	Created
//
//////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////
// Includes
//////////////////////////////////////////////////////////////////////
#include "stressMain.h"

//////////////////////////////////////////////////////////////////////
// Globals and constants
//////////////////////////////////////////////////////////////////////

// ************************************
// ************************************
// ** Fill in your test case name below
// ** 
LPSTR	g_szStressTestName = "AuthSecureProxy Stressor";

//yup, they're all global
BOOL bPost = FALSE;
CHAR HttpType[10] = "HTTP";
BOOL bViaProxy = FALSE;
CHAR CredType[5] = "SC";

BOOL RunStress(BOOL bPost,CHAR HttpType[],BOOL bViaProxy,CHAR CredType[],int Scheme);

////////////////////////////////////////////////////////////
// Function:  WinHttp_StressTest()
//
// Purpose:
//	goes through all the ways of sending a request and 
//  picks one of those, then uses it in a request
//
//  yes, it does check for the signal before starting
//  runstress (one test per call).
////////////////////////////////////////////////////////////

BOOL
WinHttp_StressTest()
{
	for(int i=0; i<2; i++)
	{
		if(i==0)
			bPost = FALSE;
		else
			bPost = TRUE;
		for(int j=0; j<2; j++)
		{
			if(j==0)
				strcpy(HttpType, "HTTPS");
			else
				strcpy(HttpType, "HTTP");
			for(int k=0; k<2; k++)
			{
				if(k==0)
					bViaProxy = FALSE;
				else
					bViaProxy = TRUE;
				for(int l=0; l<2; l++)
				{
					if(l==0)
						strcpy(CredType, "SC");
					else
						strcpy(CredType, "SO");
					for(int m=0; m<4; m++)
					{
						if(!IsTimeToExitStress())
							RunStress(bPost,HttpType,bViaProxy,CredType,m);
						else
							return FALSE;
					}
				}
			}
		}
	}

	return TRUE;
}

////////////////////////////////////////////////////////////
// Function:  RunStress()
//
// Purpose:
//  this actually runs the tests given certain inputs.
//  this is called from WinHttp_StressTest.
//
////////////////////////////////////////////////////////////
	
BOOL RunStress(BOOL bPost,CHAR HttpType[],BOOL bViaProxy,CHAR CredType[],int Scheme)
{
	BOOL bContinueStress = TRUE;

	HINTERNET hOpen = NULL;
	HINTERNET hConnect = NULL;
	HINTERNET hRequest = NULL;

	DWORD	Count = 0, dwAccessType = WINHTTP_ACCESS_TYPE_NO_PROXY,
			dwAuthScheme=0,dwAuthTargets=0,dwOtherScheme=0,dwOpenRequestFlags=0,
			dwStatus=0, cbStatus=0;

	LPWSTR	wszHost=NULL, wszUri=NULL, wszUserName=NULL, wszPassword=NULL,
			wszProxy = NULL, wszProxyUserName = NULL, wszProxyPassword = NULL,
			wszVerb=L"GET";

	INTERNET_PORT	nPort = INTERNET_DEFAULT_HTTP_PORT;

	LPSTR	pPostData = NULL;
	DWORD	dwPostDataLength = 0;

	if(bPost)
	{
		wszVerb=L"POST";
		pPostData = "If you smelllllllll what THE ROCK is cooking??? <people's eyebrow>";
		dwPostDataLength = strlen(pPostData);
	}

	if(strcmp(HttpType, "HTTPS"))
	{
		nPort = INTERNET_DEFAULT_HTTPS_PORT;
		dwOpenRequestFlags = WINHTTP_FLAG_SECURE;
	}

	//if going via proxy, then ntlm/nego aren't valid, unless going over https
	if(bViaProxy && ((Scheme == 0 || Scheme == 1) || strcmp(HttpType, "HTTPS")) )
	{
		wszProxy = L"xfluke";
		wszProxyUserName = L"xfluke\\proxyuser";
		wszProxyPassword = L"password";
		dwAccessType = WINHTTP_ACCESS_TYPE_NAMED_PROXY;
	}

	switch(Scheme)
	{
	case 0: //basic
		wszHost = L"wiredbvt";
		wszUri = L"/api/Auth/Basic/echo-post-data.asp";
		wszUserName = L"ApiAuth";
		wszPassword = L"test1234!";
		break;
	case 1: //digest
		wszHost = L"kerby2";
		wszUri = L"/digest/echo-post-data.asp";
		wszUserName = L"authdigest";
		wszPassword = L"digest";
		break;
	case 2: //negotiate
		wszHost = L"kerby2";
		wszUri = L"/ie/negotiate/echo-post-data.asp";
		wszUserName = L"kerby2\\authnego";
		wszPassword = L"nego";
		break;
	case 3: //ntlm
		wszHost = L"clapton";
		wszUri = L"/test/ntlm/echo-post-data.asp";
		wszUserName = L"clapton\\ntlmtest";
		wszPassword = L"ntlm";
		break;
	}

	LogText("Post: %u, Proxy: %u, %s, %s, Scheme: %u", bPost, bViaProxy, HttpType, CredType, Scheme);

	// ***********************************
	// ** WinHttpOpen
	// **

	hOpen = WinHttpOpen
	(
		L"Stress Test",
		dwAccessType,
		wszProxy,
		NULL,
		0
	);

	if(hOpen == NULL)
	{
		LogText("WinHttpOpen failed with error %u.", GetLastError());
		goto Exit;
	}

	// ***********************************
	// ** WinHttpConnect
	// **
	
	hConnect = WinHttpConnect
	(
		hOpen,
		wszHost,
		nPort,
		0
	);

	if(hConnect==NULL)
	{
		LogText("WinHttpConnect failed with error %u.", GetLastError());
		goto Exit;
	}

	hRequest = WinHttpOpenRequest
	(
		hConnect,
		wszVerb,
		wszUri,
		NULL,
		NULL,
		NULL,
		dwOpenRequestFlags
	);

	if(hRequest==NULL)
	{
		LogText("WinHttpOpenRequest failed with error %u.", GetLastError());
		goto Exit;
	}


Resend:

	if( Count++>3) // making sure that we don't have infinite looping
	{
		bContinueStress=FALSE;
		goto Exit;
	}

	// Send request.
	if(!WinHttpSendRequest
	(
		hRequest,					// request handle
		NULL,						// header string
		0,							// header length
		(PVOID) pPostData,			// post data
		dwPostDataLength,			// post data length
		dwPostDataLength,			// total post length
		0							// flags
	))
	{
		LogText("WinHttpSendRequest failed with error %u.", GetLastError());
		goto Exit;
	}

	if (!WinHttpReceiveResponse(hRequest, NULL))
	{
		LogText("WinHttpReceiveResponse failed with error %u.", GetLastError());
		goto Exit;
	}

	cbStatus = sizeof(dwStatus);
	WinHttpQueryHeaders
	(
		hRequest,
		WINHTTP_QUERY_FLAG_NUMBER | WINHTTP_QUERY_STATUS_CODE,
		NULL,
		&dwStatus,
		&cbStatus,
		NULL
	);

	switch( dwStatus )
	{
	case 200:
		break;
	case 401:
		if(strcmp(CredType, "SC"))
		{
			if(!WinHttpQueryAuthSchemes
			(
				hRequest,
				&dwOtherScheme,
				&dwAuthScheme,
				&dwAuthTargets
			))
			{
				LogText("WinHttpQueryAuthSchemes failed with error %u.", GetLastError());
				goto Exit;
			}

			if(!WinHttpSetCredentials
			(
				hRequest,
				dwAuthTargets,
				dwAuthScheme,
				wszUserName,
				wszPassword,
				(PVOID) NULL
			))
			{
				LogText("WinHttpSetCredentials failed with error %u.", GetLastError());
				goto Exit;
			}
		}
		else
		{
			if(!WinHttpSetOption
			(
				hRequest,
				WINHTTP_OPTION_USERNAME,
				(PVOID) wszUserName,
				wcslen(wszUserName)
			))
			{
				LogText("WinHttpSetOption failed with error %u.", GetLastError());
				goto Exit;
			}

			if(!WinHttpSetOption
			(
				hRequest,
				WINHTTP_OPTION_PASSWORD,
				(PVOID) wszPassword,
				wcslen(wszPassword)
			))
			{
				LogText("WinHttpSetOption failed with error %u.", GetLastError());
				goto Exit;
			}
		}
		goto Resend;
	break;

	case 407:
		if(strcmp(CredType, "SC"))
		{
			if(!WinHttpQueryAuthSchemes
			(
				hRequest,
				&dwOtherScheme,
				&dwAuthScheme,
				&dwAuthTargets
			))
			{
				LogText("WinHttpQueryAuthSchemes failed with error %u.", GetLastError());
				goto Exit;
			}

			if(!WinHttpSetCredentials
			(
				hRequest,
				dwAuthTargets,
				dwAuthScheme,
				wszProxyUserName,
				wszProxyPassword,
				(PVOID) NULL
			))
			{
				LogText("WinHttpSetCredentials failed with error %u.", GetLastError());
				goto Exit;
			}
		}
		else
		{
			if(!WinHttpSetOption
			(
				hRequest,
				WINHTTP_OPTION_PROXY_USERNAME,
				(PVOID) wszProxyUserName,
				wcslen(wszProxyUserName)
			))
			{
				LogText("WinHttpSetOption failed with error %u.", GetLastError());
				goto Exit;
			}

			if(!WinHttpSetOption
			(
				hRequest,
				WINHTTP_OPTION_PROXY_PASSWORD,
				(PVOID) wszProxyPassword,
				wcslen(wszProxyPassword)
			))
			{
				LogText("WinHttpSetOption failed with error %u.", GetLastError());
				goto Exit;
			}
		}

		goto Resend;
	break;

	} //end of switch (status code)

Exit:

	if( hRequest != NULL )
	{
		WinHttpCloseHandle(hRequest);
		hRequest = NULL;
	}

	if( hConnect != NULL )
	{
		WinHttpCloseHandle(hConnect);
		hConnect = NULL;
	}

	if( hOpen != NULL )
	{
		WinHttpCloseHandle(hOpen);
		hOpen = NULL;
	}


	return bContinueStress;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\w3spoof\common\int_guids.c ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    int_guids.c

Abstract:

    Non-MIDL generated GUIDs used by internal COM calls
    
Author:

    Paul M Midgen (pmidge) 28-August-2000

Revision History:

    28-August-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifdef __cplusplus
extern "C" {
#endif

// {42965D97-C33A-4bc7-A101-54E4EC19ED10}
const IID IID_IConfig = 
{
  0x42965d97,
  0xc33a,
  0x4bc7,
  { 0xa1, 0x1, 0x54, 0xe4, 0xec, 0x19, 0xed, 0x10 }
};

// {8E4A89E3-18C9-482b-B2EC-89D1DF06C46E}
const IID IID_IW3Spoof =
{
  0x8e4a89e3,
  0x18c9,
  0x482b,
  { 0xb2, 0xec, 0x89, 0xd1, 0xdf, 0x6, 0xc4, 0x6e }
};

const IID IID_IW3SpoofEvents =
{
  0x64896c1c,
  0x7757,
  0x4858,
  { 0xbd, 0x08, 0x70, 0x7c, 0xd3, 0x4c, 0x1b, 0xc4 }
};

// {8BACDCBC-94AA-4401-95C6-894D7B54ACF5}
const IID IID_IThreadPool =
{
  0x8bacdcbc,
  0x94aa,
  0x4401,
  { 0x95, 0xc6, 0x89, 0x4d, 0x7b, 0x54, 0xac, 0xf5 }
};

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\w3spoof\w3spoof.inc ===
!IF 0

Copyright (c) 1994  Microsoft Corporation

Module Name:

    w3spoof.inc

Abstract:

    Common makefile contents for w3spoof project

!ENDIF

!IFNDEF SDKINC
SDKINC=$(SDK_INC_PATH)
!ENDIF

!IFDEF LIBDIR
!ERROR LIBDIR already defined - choose new name
!ENDIF

LIBDIR=..\lib\$(_OBJ_DIR)
W3SPOOFINC=..\inc

#
# if TARGETPATH is not defined (in the paths that build libraries) then this
# is the default target path
#
!IFNDEF TARGETPATH
TARGETPATH=$(LIBDIR)
TARGETTYPE=LIBRARY
!ENDIF

#
# what it is that we're building
#
MAJORCOMP=w3spoof

USE_NOLIBS=1
#USE_LIBCMT=0
NO_NTDLL=1
#NO_BINPLACE=0
BINPLACE_PLACEFILE=..\binplace.txt

#
# Linker flags
#
WIN32_WINNT_VERSION=0x0500
#WIN32_WIN95_VERSION=0x0400

#
# compiler warning flags
#
MSC_WARNING_LEVEL=/W3 /WX

#
# compiler definitions
#
C_DEFINES=$(C_DEFINES) -DWIN32

CLEANINF = cleaninf.exe $(CLEANINF_FLAGS)

#
# Set debugging level
#
!IF "$(NTDEBUG)" != "" && "$(NTDEBUG)" != "retail" && "$(NTDEBUG)" != "ntsdnodbg"
C_DEFINES=$(C_DEFINES) -D_DEBUG
!ENDIF

!IF "$(__FULL_DEBUG__)" != "" && "$(__RELEASE_DEBUG__)" == ""
C_DEFINES=$(C_DEFINES) -D__FULL_DEBUG__
!IF "$(__DBG_TO_CONSOLE__)" == "1"
C_DEFINES=$(C_DEFINES) -D__DBG_TO_CONSOLE__
!ENDIF
!ENDIF

!IF "$(__RELEASE_DEBUG__)" != "" && "$(__FULL_DEBUG__)" == ""
C_DEFINES=$(C_DEFINES) -D__RELEASE_DEBUG__
!ENDIF


!IFNDEF W3SPOOF_PCH
PRECOMPILED_OPTION=/Fp..\inc\$(_OBJ_DIR)\*\common.pch /Yucommon.h
PRECOMPILED_CXX=1
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\w3spoof\common\stores.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    stores.cxx

Abstract:

    Implementations of objects deriving from the hashtable & list ADTs that
    are used for stores of various data.
    
Author:

    Paul M Midgen (pmidge) 14-November-2000


Revision History:

    14-November-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"


VOID VariantKiller(LPVOID* ppv)
{
  VARIANT** ppvr = (VARIANT**) ppv;

  VariantClear(*ppvr);
  SAFEDELETE(*ppvr);
}


VOID PropertyBagKiller(LPVOID* ppv)
{
  PPROPERTYBAG* ppbag = (PPROPERTYBAG*) ppv;

  SAFETERMINATE((*ppbag));
}


VOID BSTRKiller(LPVOID* ppv)
{
  BSTR bstr = (BSTR) *ppv;
  SysFreeString(bstr);
}


void CHeaderList::GetHash(LPSTR id, LPDWORD lpHash)
{
  *lpHash = ::GetHash(id);
}


void CStringMap::GetHashAndBucket(LPWSTR id, LPDWORD lpHash, LPDWORD lpBucket)
{
  DWORD hash = GetHash(id);

  *lpHash   = hash;
  *lpBucket = hash % 100;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\w3spoof\common\debug.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    debug.cpp

Abstract:

    Debug logging routines for W3spoof project.
    
Author:

    Paul M Midgen (pmidge) 15-May-2000


Revision History:

    15-May-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"


/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  MapIIDToString()

  WHAT    : maps an IID to its string id. if the IID is unknown we
            emit a '?'.

  ARGS    : hr - the IID code to map

  RETURNS : pointer to the IID's string name

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
LPSTR
MapIIDToString(REFIID riid)
{
  //
  // standard IIDs
  //
  CASE_IID(riid, IID_NULL);
  CASE_IID(riid, IID_IUnknown);
  CASE_IID(riid, IID_IClassFactory);
  CASE_IID(riid, IID_IDispatch);
  CASE_IID(riid, IID_IConnectionPointContainer);
  CASE_IID(riid, IID_IConnectionPoint);
  CASE_IID(riid, IID_IMarshal);
  CASE_IID(riid, IID_IStdMarshalInfo);
  CASE_IID(riid, IID_IExternalConnection);
  CASE_IID(riid, IID_IObjectWithSite);
  CASE_IID(riid, IID_IActiveScriptSite);
  CASE_IID(riid, IID_IProvideClassInfo);
  CASE_IID(riid, IID_IActiveScriptSiteInterruptPoll);
  CASE_IID(riid, IID_IActiveScriptSiteDebug);
//  CASE_IID(riid, IID_ICanHandleException); // dispex.h?
//  CASE_IID(riid, IID_IDispatchEx); // dispex.h?

  CASE_IID(riid, IID_IServiceProvider);

  //
  // app-defined IIDs
  //
  CASE_IID(riid, IID_IConfig);
  CASE_IID(riid, IID_IThreadPool);
  CASE_IID(riid, IID_IW3Spoof);
  CASE_IID(riid, IID_IW3SpoofClientSupport);
  CASE_IID(riid, IID_IW3SpoofEvents);
  CASE_IID(riid, IID_ISession);
  CASE_IID(riid, IID_ISocket);
  CASE_IID(riid, IID_IHeaders);
  CASE_IID(riid, IID_IEntity);
  CASE_IID(riid, IID_IUrl);
  CASE_IID(riid, IID_IRequest);
  CASE_IID(riid, IID_IResponse);
  CASE_IID(riid, IID_IW3SpoofRuntime);
  CASE_IID(riid, IID_IW3SpoofPropertyBag);
  CASE_IID(riid, IID_IW3SpoofFile);

  return "?";
}

LPSTR
MapIOTYPEToString(IOTYPE iot)
{
  switch(iot)
  {
    CASE_OF(IOCT_CONNECT);
    CASE_OF(IOCT_RECV);
    CASE_OF(IOCT_SEND);
    CASE_OF(IOCT_DUMMY);

    default : return "?";
  }
}

LPSTR
MapScriptDispidToString(SCRIPTDISPID sd)
{
  switch(sd)
  {
    CASE_OF(Global);
    CASE_OF(OnConnect);
    CASE_OF(OnDataAvailable);
    CASE_OF(OnRequest);
    CASE_OF(OnResponse);
    CASE_OF(OnClose);

    default : return "?";
  }
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  MapHResultToString()

  WHAT    : maps an HRESULT to its string id. if the HRESULT is unknown we
            emit a '?'.

  ARGS    : hr - the HRESULT code to map

  RETURNS : pointer to the HRESULT's string name

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
LPSTR
MapHResultToString(HRESULT hr)
{
  switch(hr)
  {
    CASE_OF(S_OK);
    CASE_OF(E_NOINTERFACE);
    CASE_OF(E_POINTER);
    CASE_OF(E_UNEXPECTED);
    CASE_OF(E_INVALIDARG);
    CASE_OF(E_OUTOFMEMORY);
    CASE_OF(E_FAIL);
    CASE_OF(E_NOTIMPL);
    CASE_OF(E_PENDING);
    CASE_OF(E_ACCESSDENIED);
    CASE_OF(CLASS_E_NOAGGREGATION);
    CASE_OF(TYPE_E_IOERROR);
    CASE_OF(TYPE_E_REGISTRYACCESS);
    CASE_OF(TYPE_E_INVALIDSTATE);
    CASE_OF(TYPE_E_BUFFERTOOSMALL);
    CASE_OF(TYPE_E_FIELDNOTFOUND);
    CASE_OF(TYPE_E_ELEMENTNOTFOUND);
    CASE_OF(TYPE_E_AMBIGUOUSNAME);
    CASE_OF(TYPE_E_UNKNOWNLCID);
    CASE_OF(TYPE_E_BADMODULEKIND);
    CASE_OF(TYPE_E_CANTLOADLIBRARY);
    CASE_OF(TYPE_E_INCONSISTENTPROPFUNCS);
    CASE_OF(CONNECT_E_NOCONNECTION);
    CASE_OF(CONNECT_E_ADVISELIMIT);
    CASE_OF(CO_E_OBJNOTREG);
    CASE_OF(DISP_E_BADPARAMCOUNT);
    CASE_OF(DISP_E_BADVARTYPE);
    CASE_OF(DISP_E_EXCEPTION);
    CASE_OF(DISP_E_MEMBERNOTFOUND);
    CASE_OF(DISP_E_NONAMEDARGS);
    CASE_OF(DISP_E_OVERFLOW);
    CASE_OF(DISP_E_PARAMNOTFOUND);
    CASE_OF(DISP_E_TYPEMISMATCH);
    CASE_OF(DISP_E_UNKNOWNINTERFACE);
    CASE_OF(DISP_E_UNKNOWNLCID);
    CASE_OF(DISP_E_PARAMNOTOPTIONAL);
    CASE_OF(DISP_E_UNKNOWNNAME);

    default : return "?";
  }
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  MapStateToString()

  WHAT    : maps a STATE value to a string. if the state is unknown we
            emit a '?'.

  ARGS    : st - the STATE to map

  RETURNS : pointer to the STATE's string name

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
LPSTR
MapStateToString(STATE st)
{
  switch(st)
  {
    CASE_OF(ST_CREATED);
    CASE_OF(ST_OPENING);
    CASE_OF(ST_OPEN);
    CASE_OF(ST_CLOSING);
    CASE_OF(ST_CLOSED);
    CASE_OF(ST_ERROR);

    default : return "?";
  }
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  MapIoStateToString()

  WHAT    : maps a SERVERSTATE value to a string. if the state is unknown we
            emit a '?'.

  ARGS    : st - the SERVERSTATE to map

  RETURNS : pointer to the SERVERSTATE's string name

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
LPSTR
MapStateToString(SERVERSTATE st)
{
  switch(st)
  {
    CASE_OF(SS_START_STATE);
    CASE_OF(SS_SOCKET_CONNECTED);
    CASE_OF(SS_REQUEST_PENDING);
    CASE_OF(SS_REQUEST_COMPLETE);
    CASE_OF(SS_RESPONSE_PENDING);
    CASE_OF(SS_RESPONSE_COMPLETE);
    CASE_OF(SS_SOCKET_DISCONNECTED);

    default : return "?";
  }
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  MapStateToString()

  WHAT    : maps a script engine state to a string for the log file.

  ARGS    : st - the state

  RETURNS : string representation of the state

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
LPSTR
MapStateToString(SCRIPTSTATE st)
{
  switch(st)
  {
    CASE_OF(SCRIPTSTATE_UNINITIALIZED);
    CASE_OF(SCRIPTSTATE_INITIALIZED);
    CASE_OF(SCRIPTSTATE_STARTED);
    CASE_OF(SCRIPTSTATE_CONNECTED);
    CASE_OF(SCRIPTSTATE_DISCONNECTED);
    CASE_OF(SCRIPTSTATE_CLOSED);

    default : return "?";
  }
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  MapTPOToString()

  WHAT    : maps a TPO_* (thread pool option) value to a string. if the option
            is unknown we emit a '?'.

  ARGS    : option - the option to map

  RETURNS : pointer to the options's string name

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
LPSTR
MapTPOToString(DWORD option)
{
  switch(option)
  {
    CASE_OF(TPO_MAX_POOL_THREADS);
    CASE_OF(TPO_MAX_ACTIVE_THREADS);
    CASE_OF(TPO_SERVER_LISTEN_PORT);

    default : return "?";
  }
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  MapErrorToString()

  WHAT    : maps an error code to its string id. if the error is unknown we
            emit a '?'.

  ARGS    : error - the error code to map

  RETURNS : pointer to the error code's string name

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
LPSTR
MapErrorToString(int error)
{
  switch(error)
  {
    CASE_OF(ERROR_SUCCESS);
    CASE_OF(ERROR_INVALID_FUNCTION);
    CASE_OF(ERROR_FILE_NOT_FOUND);
    CASE_OF(ERROR_PATH_NOT_FOUND);
    CASE_OF(ERROR_TOO_MANY_OPEN_FILES);
    CASE_OF(ERROR_ACCESS_DENIED);
    CASE_OF(ERROR_INVALID_HANDLE);
    CASE_OF(ERROR_ARENA_TRASHED);
    CASE_OF(ERROR_NOT_ENOUGH_MEMORY);
    CASE_OF(ERROR_INVALID_BLOCK);
    CASE_OF(ERROR_BAD_ENVIRONMENT);
    CASE_OF(ERROR_BAD_FORMAT);
    CASE_OF(ERROR_INVALID_ACCESS);
    CASE_OF(ERROR_INVALID_DATA);
    CASE_OF(ERROR_OUTOFMEMORY);
    CASE_OF(ERROR_INVALID_DRIVE);
    CASE_OF(ERROR_CURRENT_DIRECTORY);
    CASE_OF(ERROR_NOT_SAME_DEVICE);
    CASE_OF(ERROR_NO_MORE_FILES);
    CASE_OF(ERROR_WRITE_PROTECT);
    CASE_OF(ERROR_BAD_UNIT);
    CASE_OF(ERROR_NOT_READY);
    CASE_OF(ERROR_BAD_COMMAND);
    CASE_OF(ERROR_CRC);
    CASE_OF(ERROR_BAD_LENGTH);
    CASE_OF(ERROR_SEEK);
    CASE_OF(ERROR_NOT_DOS_DISK);
    CASE_OF(ERROR_SECTOR_NOT_FOUND);
    CASE_OF(ERROR_OUT_OF_PAPER);
    CASE_OF(ERROR_WRITE_FAULT);
    CASE_OF(ERROR_READ_FAULT);
    CASE_OF(ERROR_GEN_FAILURE);
    CASE_OF(ERROR_SHARING_VIOLATION);
    CASE_OF(ERROR_LOCK_VIOLATION);
    CASE_OF(ERROR_WRONG_DISK);
    CASE_OF(ERROR_SHARING_BUFFER_EXCEEDED);
    CASE_OF(ERROR_HANDLE_EOF);
    CASE_OF(ERROR_HANDLE_DISK_FULL);
    CASE_OF(ERROR_NOT_SUPPORTED);
    CASE_OF(ERROR_REM_NOT_LIST);
    CASE_OF(ERROR_DUP_NAME);
    CASE_OF(ERROR_BAD_NETPATH);
    CASE_OF(ERROR_NETWORK_BUSY);
    CASE_OF(ERROR_DEV_NOT_EXIST);
    CASE_OF(ERROR_TOO_MANY_CMDS);
    CASE_OF(ERROR_ADAP_HDW_ERR);
    CASE_OF(ERROR_BAD_NET_RESP);
    CASE_OF(ERROR_UNEXP_NET_ERR);
    CASE_OF(ERROR_BAD_REM_ADAP);
    CASE_OF(ERROR_PRINTQ_FULL);
    CASE_OF(ERROR_NO_SPOOL_SPACE);
    CASE_OF(ERROR_PRINT_CANCELLED);
    CASE_OF(ERROR_NETNAME_DELETED);
    CASE_OF(ERROR_NETWORK_ACCESS_DENIED);
    CASE_OF(ERROR_BAD_DEV_TYPE);
    CASE_OF(ERROR_BAD_NET_NAME);
    CASE_OF(ERROR_TOO_MANY_NAMES);
    CASE_OF(ERROR_TOO_MANY_SESS);
    CASE_OF(ERROR_SHARING_PAUSED);
    CASE_OF(ERROR_REQ_NOT_ACCEP);
    CASE_OF(ERROR_REDIR_PAUSED);
    CASE_OF(ERROR_FILE_EXISTS);
    CASE_OF(ERROR_CANNOT_MAKE);
    CASE_OF(ERROR_FAIL_I24);
    CASE_OF(ERROR_OUT_OF_STRUCTURES);
    CASE_OF(ERROR_ALREADY_ASSIGNED);
    CASE_OF(ERROR_INVALID_PASSWORD);
    CASE_OF(ERROR_INVALID_PARAMETER);
    CASE_OF(ERROR_NET_WRITE_FAULT);
    CASE_OF(ERROR_NO_PROC_SLOTS);
    CASE_OF(ERROR_TOO_MANY_SEMAPHORES);
    CASE_OF(ERROR_EXCL_SEM_ALREADY_OWNED);
    CASE_OF(ERROR_SEM_IS_SET);
    CASE_OF(ERROR_TOO_MANY_SEM_REQUESTS);
    CASE_OF(ERROR_INVALID_AT_INTERRUPT_TIME);
    CASE_OF(ERROR_SEM_OWNER_DIED);
    CASE_OF(ERROR_SEM_USER_LIMIT);
    CASE_OF(ERROR_DISK_CHANGE);
    CASE_OF(ERROR_DRIVE_LOCKED);
    CASE_OF(ERROR_BROKEN_PIPE);
    CASE_OF(ERROR_OPEN_FAILED);
    CASE_OF(ERROR_BUFFER_OVERFLOW);
    CASE_OF(ERROR_DISK_FULL);
    CASE_OF(ERROR_NO_MORE_SEARCH_HANDLES);
    CASE_OF(ERROR_INVALID_TARGET_HANDLE);
    CASE_OF(ERROR_INVALID_CATEGORY);
    CASE_OF(ERROR_INVALID_VERIFY_SWITCH);
    CASE_OF(ERROR_BAD_DRIVER_LEVEL);
    CASE_OF(ERROR_CALL_NOT_IMPLEMENTED);
    CASE_OF(ERROR_SEM_TIMEOUT);
    CASE_OF(ERROR_INSUFFICIENT_BUFFER);
    CASE_OF(ERROR_INVALID_NAME);
    CASE_OF(ERROR_INVALID_LEVEL);
    CASE_OF(ERROR_NO_VOLUME_LABEL);
    CASE_OF(ERROR_MOD_NOT_FOUND);
    CASE_OF(ERROR_PROC_NOT_FOUND);
    CASE_OF(ERROR_WAIT_NO_CHILDREN);
    CASE_OF(ERROR_CHILD_NOT_COMPLETE);
    CASE_OF(ERROR_DIRECT_ACCESS_HANDLE);
    CASE_OF(ERROR_NEGATIVE_SEEK);
    CASE_OF(ERROR_SEEK_ON_DEVICE);
    CASE_OF(ERROR_DIR_NOT_ROOT);
    CASE_OF(ERROR_DIR_NOT_EMPTY);
    CASE_OF(ERROR_PATH_BUSY);
    CASE_OF(ERROR_SYSTEM_TRACE);
    CASE_OF(ERROR_INVALID_EVENT_COUNT);
    CASE_OF(ERROR_TOO_MANY_MUXWAITERS);
    CASE_OF(ERROR_INVALID_LIST_FORMAT);
    CASE_OF(ERROR_BAD_ARGUMENTS);
    CASE_OF(ERROR_BAD_PATHNAME);
    CASE_OF(ERROR_BUSY);
    CASE_OF(ERROR_CANCEL_VIOLATION);
    CASE_OF(ERROR_ALREADY_EXISTS);
    CASE_OF(ERROR_FILENAME_EXCED_RANGE);
    CASE_OF(ERROR_LOCKED);
    CASE_OF(ERROR_NESTING_NOT_ALLOWED);
    CASE_OF(ERROR_BAD_PIPE);
    CASE_OF(ERROR_PIPE_BUSY);
    CASE_OF(ERROR_NO_DATA);
    CASE_OF(ERROR_PIPE_NOT_CONNECTED);
    CASE_OF(ERROR_MORE_DATA);
    CASE_OF(ERROR_NO_MORE_ITEMS);
    CASE_OF(ERROR_NOT_OWNER);
    CASE_OF(ERROR_PARTIAL_COPY);
    CASE_OF(ERROR_MR_MID_NOT_FOUND);
    CASE_OF(ERROR_INVALID_ADDRESS);
    CASE_OF(ERROR_PIPE_CONNECTED);
    CASE_OF(ERROR_PIPE_LISTENING);
    CASE_OF(ERROR_OPERATION_ABORTED);
    CASE_OF(ERROR_IO_INCOMPLETE);
    CASE_OF(ERROR_IO_PENDING);
    CASE_OF(ERROR_NOACCESS);
    CASE_OF(ERROR_STACK_OVERFLOW);
    CASE_OF(ERROR_INVALID_FLAGS);
    CASE_OF(ERROR_NO_TOKEN);
    CASE_OF(ERROR_BADDB);
    CASE_OF(ERROR_BADKEY);
    CASE_OF(ERROR_CANTOPEN);
    CASE_OF(ERROR_CANTREAD);
    CASE_OF(ERROR_CANTWRITE);
    CASE_OF(ERROR_REGISTRY_RECOVERED);
    CASE_OF(ERROR_REGISTRY_CORRUPT);
    CASE_OF(ERROR_REGISTRY_IO_FAILED);
    CASE_OF(ERROR_NOT_REGISTRY_FILE);
    CASE_OF(ERROR_KEY_DELETED);
    CASE_OF(ERROR_CIRCULAR_DEPENDENCY);
    CASE_OF(ERROR_SERVICE_NOT_ACTIVE);
    CASE_OF(ERROR_DLL_INIT_FAILED);
    CASE_OF(ERROR_CANCELLED);
    CASE_OF(ERROR_BAD_USERNAME);
    CASE_OF(ERROR_LOGON_FAILURE);

    CASE_OF(WAIT_FAILED);
    CASE_OF(WAIT_TIMEOUT);
    CASE_OF(WAIT_IO_COMPLETION);

    CASE_OF(RPC_S_INVALID_STRING_BINDING);
    CASE_OF(RPC_S_WRONG_KIND_OF_BINDING);
    CASE_OF(RPC_S_INVALID_BINDING);
    CASE_OF(RPC_S_PROTSEQ_NOT_SUPPORTED);
    CASE_OF(RPC_S_INVALID_RPC_PROTSEQ);
    CASE_OF(RPC_S_INVALID_STRING_UUID);
    CASE_OF(RPC_S_INVALID_ENDPOINT_FORMAT);
    CASE_OF(RPC_S_INVALID_NET_ADDR);
    CASE_OF(RPC_S_NO_ENDPOINT_FOUND);
    CASE_OF(RPC_S_INVALID_TIMEOUT);
    CASE_OF(RPC_S_OBJECT_NOT_FOUND);
    CASE_OF(RPC_S_ALREADY_REGISTERED);
    CASE_OF(RPC_S_TYPE_ALREADY_REGISTERED);
    CASE_OF(RPC_S_ALREADY_LISTENING);
    CASE_OF(RPC_S_NO_PROTSEQS_REGISTERED);
    CASE_OF(RPC_S_NOT_LISTENING);
    CASE_OF(RPC_S_UNKNOWN_MGR_TYPE);
    CASE_OF(RPC_S_UNKNOWN_IF);
    CASE_OF(RPC_S_NO_BINDINGS);
    CASE_OF(RPC_S_NO_PROTSEQS);
    CASE_OF(RPC_S_CANT_CREATE_ENDPOINT);
    CASE_OF(RPC_S_OUT_OF_RESOURCES);
    CASE_OF(RPC_S_SERVER_UNAVAILABLE);
    CASE_OF(RPC_S_SERVER_TOO_BUSY);
    CASE_OF(RPC_S_INVALID_NETWORK_OPTIONS);
    CASE_OF(RPC_S_NO_CALL_ACTIVE);
    CASE_OF(RPC_S_CALL_FAILED);
    CASE_OF(RPC_S_CALL_FAILED_DNE);
    CASE_OF(RPC_S_PROTOCOL_ERROR);
    CASE_OF(RPC_S_UNSUPPORTED_TRANS_SYN);
    CASE_OF(RPC_S_UNSUPPORTED_TYPE);
    CASE_OF(RPC_S_INVALID_TAG);
    CASE_OF(RPC_S_INVALID_BOUND);
    CASE_OF(RPC_S_NO_ENTRY_NAME);
    CASE_OF(RPC_S_INVALID_NAME_SYNTAX);
    CASE_OF(RPC_S_UNSUPPORTED_NAME_SYNTAX);
    CASE_OF(RPC_S_UUID_NO_ADDRESS);
    CASE_OF(RPC_S_DUPLICATE_ENDPOINT);
    CASE_OF(RPC_S_UNKNOWN_AUTHN_TYPE);
    CASE_OF(RPC_S_MAX_CALLS_TOO_SMALL);
    CASE_OF(RPC_S_STRING_TOO_LONG);
    CASE_OF(RPC_S_PROTSEQ_NOT_FOUND);
    CASE_OF(RPC_S_PROCNUM_OUT_OF_RANGE);
    CASE_OF(RPC_S_BINDING_HAS_NO_AUTH);
    CASE_OF(RPC_S_UNKNOWN_AUTHN_SERVICE);
    CASE_OF(RPC_S_UNKNOWN_AUTHN_LEVEL);
    CASE_OF(RPC_S_INVALID_AUTH_IDENTITY);
    CASE_OF(RPC_S_UNKNOWN_AUTHZ_SERVICE);
    CASE_OF(EPT_S_INVALID_ENTRY);
    CASE_OF(EPT_S_CANT_PERFORM_OP);
    CASE_OF(EPT_S_NOT_REGISTERED);
    CASE_OF(RPC_S_NOTHING_TO_EXPORT);
    CASE_OF(RPC_S_INCOMPLETE_NAME);
    CASE_OF(RPC_S_INVALID_VERS_OPTION);
    CASE_OF(RPC_S_NO_MORE_MEMBERS);
    CASE_OF(RPC_S_NOT_ALL_OBJS_UNEXPORTED);
    CASE_OF(RPC_S_INTERFACE_NOT_FOUND);
    CASE_OF(RPC_S_ENTRY_ALREADY_EXISTS);
    CASE_OF(RPC_S_ENTRY_NOT_FOUND);
    CASE_OF(RPC_S_NAME_SERVICE_UNAVAILABLE);
    CASE_OF(RPC_S_INVALID_NAF_ID);
    CASE_OF(RPC_S_CANNOT_SUPPORT);
    CASE_OF(RPC_S_NO_CONTEXT_AVAILABLE);
    CASE_OF(RPC_S_INTERNAL_ERROR);
    CASE_OF(RPC_S_ZERO_DIVIDE);
    CASE_OF(RPC_S_ADDRESS_ERROR);
    CASE_OF(RPC_S_FP_DIV_ZERO);
    CASE_OF(RPC_S_FP_UNDERFLOW);
    CASE_OF(RPC_S_FP_OVERFLOW);
    CASE_OF(RPC_X_NO_MORE_ENTRIES);
    CASE_OF(RPC_X_SS_CHAR_TRANS_OPEN_FAIL);
    CASE_OF(RPC_X_SS_CHAR_TRANS_SHORT_FILE);
    CASE_OF(RPC_X_SS_IN_NULL_CONTEXT);
    CASE_OF(RPC_X_SS_CONTEXT_DAMAGED);
    CASE_OF(RPC_X_SS_HANDLES_MISMATCH);
    CASE_OF(RPC_X_SS_CANNOT_GET_CALL_HANDLE);
    CASE_OF(RPC_X_NULL_REF_POINTER);
    CASE_OF(RPC_X_ENUM_VALUE_OUT_OF_RANGE);
    CASE_OF(RPC_X_BYTE_COUNT_TOO_SMALL);
    CASE_OF(RPC_X_BAD_STUB_DATA);

    CASE_OF(WSAEINTR);
    CASE_OF(WSAEBADF);
    CASE_OF(WSAEACCES);
    CASE_OF(WSAEFAULT);
    CASE_OF(WSAEINVAL);
    CASE_OF(WSAEMFILE);
    CASE_OF(WSAEWOULDBLOCK);
    CASE_OF(WSAEINPROGRESS);
    CASE_OF(WSAEALREADY);
    CASE_OF(WSAENOTSOCK);
    CASE_OF(WSAEDESTADDRREQ);
    CASE_OF(WSAEMSGSIZE);
    CASE_OF(WSAEPROTOTYPE);
    CASE_OF(WSAENOPROTOOPT);
    CASE_OF(WSAEPROTONOSUPPORT);
    CASE_OF(WSAESOCKTNOSUPPORT);
    CASE_OF(WSAEOPNOTSUPP);
    CASE_OF(WSAEPFNOSUPPORT);
    CASE_OF(WSAEAFNOSUPPORT);
    CASE_OF(WSAEADDRINUSE);
    CASE_OF(WSAEADDRNOTAVAIL);
    CASE_OF(WSAENETDOWN);
    CASE_OF(WSAENETUNREACH);
    CASE_OF(WSAENETRESET);
    CASE_OF(WSAECONNABORTED);
    CASE_OF(WSAECONNRESET);
    CASE_OF(WSAENOBUFS);
    CASE_OF(WSAEISCONN);
    CASE_OF(WSAENOTCONN);
    CASE_OF(WSAESHUTDOWN);
    CASE_OF(WSAETOOMANYREFS);
    CASE_OF(WSAETIMEDOUT);
    CASE_OF(WSAECONNREFUSED);
    CASE_OF(WSAELOOP);
    CASE_OF(WSAENAMETOOLONG);
    CASE_OF(WSAEHOSTDOWN);
    CASE_OF(WSAEHOSTUNREACH);
    CASE_OF(WSAENOTEMPTY);
    CASE_OF(WSAEPROCLIM);
    CASE_OF(WSAEUSERS);
    CASE_OF(WSAEDQUOT);
    CASE_OF(WSAESTALE);
    CASE_OF(WSAEREMOTE);
    CASE_OF(WSAEDISCON);
    CASE_OF(WSASYSNOTREADY);
    CASE_OF(WSAVERNOTSUPPORTED);
    CASE_OF(WSANOTINITIALISED);
    CASE_OF(WSAHOST_NOT_FOUND);
    CASE_OF(WSATRY_AGAIN);
    CASE_OF(WSANO_RECOVERY);
    CASE_OF(WSANO_DATA);

    CASE_OF(ERROR_FAILURE);
    CASE_OF(ERROR_INVALID_STATE);

    default : return "?";
  }
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  MapDispidToString()

  WHAT    : maps a dispid to a string for the log file.

  ARGS    : dispid - the dispid

  RETURNS : string representation of the dispid

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
LPSTR
MapDispidToString(DISPID dispid)
{
  switch(dispid)
  {
    // special dispids
    CASE_OF(DISPID_VALUE);
    CASE_OF(DISPID_NEWENUM);
    CASE_OF(DISPID_EVALUATE);
    CASE_OF(DISPID_PROPERTYPUT);
    CASE_OF(DISPID_CONSTRUCTOR);
    CASE_OF(DISPID_DESTRUCTOR);
    CASE_OF(DISPID_UNKNOWN);
    CASE_OF(DISPID_COLLECT);

    // internal OM dispids
    CASE_OF(DISPID_SESSION_SOCKET);
    CASE_OF(DISPID_SESSION_REQUEST);
    CASE_OF(DISPID_SESSION_RESPONSE);
    CASE_OF(DISPID_SESSION_GETPROPERTYBAG);
    CASE_OF(DISPID_SESSION_KEEPALIVE);

    CASE_OF(DISPID_SOCKET_PARENT);
    CASE_OF(DISPID_SOCKET_SEND);
    CASE_OF(DISPID_SOCKET_RECV);
    CASE_OF(DISPID_SOCKET_OPTION);
    CASE_OF(DISPID_SOCKET_CLOSE);
    CASE_OF(DISPID_SOCKET_RESOLVE);
    CASE_OF(DISPID_SOCKET_LOCALNAME);
    CASE_OF(DISPID_SOCKET_LOCALADDRESS);
    CASE_OF(DISPID_SOCKET_LOCALPORT);
    CASE_OF(DISPID_SOCKET_REMOTENAME);
    CASE_OF(DISPID_SOCKET_REMOTEADDRESS);
    CASE_OF(DISPID_SOCKET_REMOTEPORT);

    CASE_OF(DISPID_HEADERS_PARENT);
    CASE_OF(DISPID_HEADERS_GET);
    CASE_OF(DISPID_HEADERS_SET);
    CASE_OF(DISPID_HEADERS_GETHEADER);
    CASE_OF(DISPID_HEADERS_SETHEADER);

    CASE_OF(DISPID_ENTITY_PARENT);
    CASE_OF(DISPID_ENTITY_GET);
    CASE_OF(DISPID_ENTITY_SET);
    CASE_OF(DISPID_ENTITY_COMPRESS);
    CASE_OF(DISPID_ENTITY_DECOMPRESS);

    CASE_OF(DISPID_URL_PARENT);
    CASE_OF(DISPID_URL_ENCODING);
    CASE_OF(DISPID_URL_SCHEME);
    CASE_OF(DISPID_URL_SERVER);
    CASE_OF(DISPID_URL_PORT);
    CASE_OF(DISPID_URL_PATH);
    CASE_OF(DISPID_URL_RESOURCE);
    CASE_OF(DISPID_URL_QUERY);
    CASE_OF(DISPID_URL_FRAGMENT);
    CASE_OF(DISPID_URL_ESCAPE);
    CASE_OF(DISPID_URL_UNESCAPE);
    CASE_OF(DISPID_URL_SET);
    CASE_OF(DISPID_URL_GET);

    CASE_OF(DISPID_REQUEST_PARENT);
    CASE_OF(DISPID_REQUEST_HEADERS);
    CASE_OF(DISPID_REQUEST_ENTITY);
    CASE_OF(DISPID_REQUEST_URL);
    CASE_OF(DISPID_REQUEST_VERB);
    CASE_OF(DISPID_REQUEST_HTTPVERSION);

    CASE_OF(DISPID_RESPONSE_PARENT);
    CASE_OF(DISPID_RESPONSE_HEADERS);
    CASE_OF(DISPID_RESPONSE_ENTITY);
    CASE_OF(DISPID_RESPONSE_STATUSCODE);
    CASE_OF(DISPID_RESPONSE_STATUSTEXT);

    CASE_OF(DISPID_W3SPOOF_REGISTERCLIENT);
    CASE_OF(DISPID_W3SPOOF_REVOKECLIENT);

    // internal runtime dispids
    CASE_OF(DISPID_RUNTIME_GETFILE);

    CASE_OF(DISPID_FILE_OPEN);
    CASE_OF(DISPID_FILE_CLOSE);
    CASE_OF(DISPID_FILE_WRITE);
    CASE_OF(DISPID_FILE_WRITELINE);
    CASE_OF(DISPID_FILE_WRITEBLANKLINE);
    CASE_OF(DISPID_FILE_READ);
    CASE_OF(DISPID_FILE_READALL);
    CASE_OF(DISPID_FILE_ATTRIBUTES);
    CASE_OF(DISPID_FILE_SIZE);
    CASE_OF(DISPID_FILE_TYPE);
    CASE_OF(DISPID_FILE_DATELASTMODIFIED);

    CASE_OF(DISPID_PROPERTYBAG_GET);
    CASE_OF(DISPID_PROPERTYBAG_SET);
    CASE_OF(DISPID_PROPERTYBAG_EXPIRES);
    CASE_OF(DISPID_PROPERTYBAG_FLUSH);

    default : return "?";
  }
}

LPSTR
MapVariantTypeToString(VARIANT* pvar)
{
  if( pvar )
  {
    switch( V_VT(pvar) )
    {
      CASE_OF(VT_ARRAY | VT_UI1);
      CASE_OF(VT_EMPTY);
      CASE_OF(VT_NULL);
      CASE_OF(VT_I2);
      CASE_OF(VT_I4);
      CASE_OF(VT_R4);
      CASE_OF(VT_R8);
      CASE_OF(VT_CY);
      CASE_OF(VT_DATE);
      CASE_OF(VT_BSTR);
      CASE_OF(VT_DISPATCH);
      CASE_OF(VT_ERROR);
      CASE_OF(VT_BOOL);
      CASE_OF(VT_VARIANT);
      CASE_OF(VT_DECIMAL);
      CASE_OF(VT_RECORD);
      CASE_OF(VT_UNKNOWN);
      CASE_OF(VT_I1);
      CASE_OF(VT_UI1);
      CASE_OF(VT_UI2);
      CASE_OF(VT_UI4);
      CASE_OF(VT_INT);
      CASE_OF(VT_UINT);
      CASE_OF(VT_ARRAY);
      CASE_OF(VT_BYREF);

      default : return "?";
    }
  }
  else
  {
    return "?";
  }
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  MapInvokeFlagsToString()

  WHAT    : maps invoke flags to a string for the log file.

  ARGS    : flags - the invoke flags

  RETURNS : string representation of the flags

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
LPSTR
MapInvokeFlagsToString(WORD flags)
{
  return "NOT_IMPLEMENTED";
}


#ifdef _DEBUG

#define DEBUG_DEFAULT_DBGFILE L"W3SPOOF.LOG"
#define DEBUG_LOGFILE_MUTEX   L"W3Spoof_LogFile_Mutex"

//
// globals
//

DWORD    g_dwTlsIndex        = 0L;
DWORD    g_dwDebugFlags      = DBG_NO_DEBUG;
HANDLE   g_hDebugLogFile     = NULL;
HANDLE   g_mtxDebugLogFile   = NULL;
LPCWSTR  g_wszDebugFlags     = L"debugflags";
MEMUSAGE g_memusage          = {0};

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  DebugInitialize()

  WHAT    : initializes the debugging support for the application. allocates
            thread-local storage and opens a log file if necessary.

            on failure, the function sets the DBG_NO_DEBUG flag so other
            debug functions won't do anything to get us in trouble.

  ARGS    : none
  RETURNS : nothing

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void
DebugInitialize( void )
{
  LPDWORD pdw   = NULL;

  DebugMemInitialize();

  if( GetRegValue(g_wszDebugFlags, REG_DWORD, (void**) &pdw) )
  {
    g_dwDebugFlags = *pdw;
    delete pdw;
  }
  else
  {
    g_dwDebugFlags = DEBUG_DEFAULT_FLAGS;
  }

  if( DBG_THROWDBGALERT & g_dwDebugFlags )
    DebugThrowDbgAlert();

  if( !(g_dwDebugFlags & DBG_NO_DEBUG) )
  {
    //
    // allocate a TLS slot or else we can't
    // do call tracing
    //

    if( (g_dwTlsIndex = TlsAlloc()) == 0xFFFFFFFF )
      goto no_debug;

    //
    // if logging to file is enabled, open the log file
    // and create a mutex for log dumps, disable debug
    // logging on error
    //

    if( g_dwDebugFlags & DBG_TO_FILE )
    {
      if(
        !( _opendebugfile() &&
           (g_mtxDebugLogFile = CreateMutex(NULL, FALSE, DEBUG_LOGFILE_MUTEX))
         )
        )
        goto no_debug;
    }

    //
    // print the log banner
    //

    char* time = _gettimestamp();

    _debugout(
      NULL,
      TRUE,
      FALSE,
      "\r\nDebug W3SPOOF.EXE started at %s with flags: %x\r\n\r\n",
      time,
      g_dwDebugFlags
      );

    delete [] time;
    return;
  }
  else
  {
    DebugMemTerminate();
  }

no_debug:
  g_dwDebugFlags = DBG_NO_DEBUG;
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  DebugTerminate()

  WHAT    : terminates debugging support for the application. 

  ARGS    : none
  RETURNS : nothing.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void
DebugTerminate( void )
{
  if( !(g_dwDebugFlags & DBG_NO_DEBUG) )
  {
    DebugMemTerminate();

    if( g_dwTlsIndex )
        TlsFree(g_dwTlsIndex);

    if( (g_dwDebugFlags & DBG_TO_FILE) && g_hDebugLogFile )
    {
      _closedebugfile();
      CloseHandle(g_mtxDebugLogFile);
      g_mtxDebugLogFile = NULL;
    }
  }
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  DebugMemInitialize()

  WHAT    : Initializes memory allocation tracking for the app.

  ARGS    : none.
  RETURNS : nothing.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void
DebugMemInitialize(void)
{
  InitializeCriticalSection(&g_memusage.lock);
  g_memusage.total = 0;
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  DebugMemTerminate()

  WHAT    : Terminates memory allocation tracking and prints the final line
            in the logfile indicating how many bytes of memory were unallocated
            at process termination.

  ARGS    : none.
  RETURNS : nothing.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void
DebugMemTerminate(void)
{
  if( g_dwDebugFlags & DBG_MEM )
    DebugTrace("*** unallocated memory: %d bytes", g_memusage.total);

  DeleteCriticalSection(&g_memusage.lock);
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  DebugMemAlloc()

  WHAT    : Increments our allocation tracking value by the number of bytes
            a given allocation maps to on the process heap.

  ARGS    : pv - pointer to allocated memory.

  RETURNS : nothing.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void
DebugMemAlloc(void* pv)
{
  EnterCriticalSection(&g_memusage.lock);

    g_memusage.total += HeapSize(GetProcessHeap(), 0, pv);

  LeaveCriticalSection(&g_memusage.lock);
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  DebugMemFree()

  WHAT    : Decrements our allocation tracking value by the number of bytes an
            allocation uses on the heap.

  ARGS    : pv - pointer to allocated memory.

  RETURNS : nothing.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void
DebugMemFree(void* pv)
{
  EnterCriticalSection(&g_memusage.lock);

    g_memusage.total -= HeapSize(GetProcessHeap(), 0, pv);    

  LeaveCriticalSection(&g_memusage.lock);
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  DebugThrowDbgAlert()

  WHAT    : Throws an alert dialog displaying the process PID so a debugger
            can be attached.

  ARGS    : none.
  RETURNS : nothing.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void
DebugThrowDbgAlert(void)
{
  char buf[256];

  wsprintfA(
    buf,
    "pid=%d",
    GetCurrentProcessId()
    );

  MessageBoxA(NULL, buf, "Attach Debugger!", MB_OK | MB_ICONSTOP | MB_SERVICE_NOTIFICATION);
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  DebugEnter()

  WHAT    : called on api entry. prints a log entry resembling the following:

              CalledFunctionName(param1=value, etc.)

  ARGS    : category - the debugging category for the logged function
            rt       - lets us know what type the function returns
            function - the logged function's name
            format   - user-supplied format string containing function args
            ...      - optional parameter list

  RETURNS : nothing

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void
DebugEnter(int category, RETTYPE rt, LPCSTR function, const char* format, ...)
{
  LPTHREADINFO pti = NULL;
  LPCALLINFO   pci = NULL;

  if( !(g_dwDebugFlags & DBG_NO_DEBUG) )
  {
    pti = GetThreadInfo();
    pci = SetCallInfo(pti, category, rt, function);

    if( g_dwDebugFlags & category )
    {
      char*   buffer = new char[1024];
      va_list arg_list;

      pti->depth++;

      if( buffer )
      {
        //
        // if the user passed an arglist & some values,
        // we'll plug it in to the function entry listing
        // in the log. otherwise we just print empty parens
        //

        if( format )
        {
          va_start(arg_list, format);
          wvsprintfA(buffer, format, arg_list);

            _debugout(pti, FALSE, FALSE, "%s(%s)", function, buffer);

          va_end(arg_list);
        }
        else
        {
          _debugout(pti, FALSE, FALSE, "%s()", function);
        }
    
        delete [] buffer;
      }
    }
  }
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  DebugLeave()

  WHAT    : prints a log entry for the logged function displaying the return
            value.
            
  ARGS    : retval - the value the logged function will return
  RETURNS : nothing.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void
DebugLeave(int retval)
{
  LPTHREADINFO pti = NULL;
  LPCALLINFO   pci = NULL;

  if( !(g_dwDebugFlags & DBG_NO_DEBUG) )
  {
    pti = GetThreadInfo();
    pci = GetCallInfo(pti);

    if( g_dwDebugFlags & pci->category )
    {
      char* buffer = FormatCallReturnString(pci, retval);

      _debugout(pti, FALSE, FALSE, buffer);
      pti->depth--;
      delete [] buffer;
    }

    DeleteCallInfo(pci);
  }
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  DebugTrace()

  WHAT    : prints a generic output line with the usual timestamp & thread id,
            etc.

  ARGS    : format - user-supplied format string
            ...    - optional parameter list

  RETURNS : nothing

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void
DebugTrace(const char* format, ...)
{
  va_list arg_list;
  char    buf[1024];

  if( !(g_dwDebugFlags & DBG_NO_DEBUG) )
  {
    va_start(arg_list, format);

      wvsprintfA(buf, format, arg_list);
      _debugout(GetThreadInfo(), FALSE, TRUE, buf);

    va_end(arg_list);
  }
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  DebugAssert()

  WHAT    : logs asserts to the selected outputs but doesn't break execution.

  ARGS    : condition - the stringized failure condition.
            file      - the file containing the assert
            line      - the line of code that asserted

  RETURNS : nothing

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void
DebugAssert(LPSTR condition, LPSTR file, int line)
{
  LPTHREADINFO pti = GetThreadInfo();
  LPCALLINFO   pci = NULL;

  _debugout(
    pti,
    TRUE,
    FALSE,
    "\r\n\r\n\t*******************************************\r\n" \
    "\t ASSERTION FAILED: \"%s\"\r\n" \
    "\t  %s (line %d)\r\n",
    condition,
    file,
    line
    );

  for(pci = pti->stack; pci; pci = pci->next)
  {
    _debugout(pti, TRUE, FALSE, "\t   %s", pci->fname);
  }

  _debugout(pti, TRUE, FALSE, "\r\n\t*******************************************\r\n");
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  DebugDataDump*()

  WHAT    : functions to dump a data buffer to the log file.

  ARGS    : title - a legend for the dump
            data  - the buffer
            len   - number of interesting bytes in the buffer

  RETURNS : nothing

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void
DebugDataDump(LPSTR title, LPBYTE data, DWORD len)
{
  DWORD n      = 0L;
  DWORD offset = 0L;
  CHAR* buf    = NULL;

  DebugTrace("%s (%#x bytes @ %#x)", title, len, data);

  buf = new CHAR[256];

    while( len )
    {
      n = DebugDataDumpFormat(buf, data, len);

      DebugTrace(buf);

      data += n;
      len  -= n;
    }

  delete [] buf;
}

int
DebugDataDumpFormat(LPSTR buffer, LPBYTE data, DWORD len)
{
  //
  // note - plagiarized from similar code in wininet.
  //

  static char spaces[] = "                                               ";

  DWORD n      = 0L;
  DWORD bytes  = 0L;
  DWORD offset = 0L;
  DWORD byte   = 0L;
  CHAR  ch;

  bytes  = min(len, 16);
  offset = wsprintfA(buffer, "%08x  ", data);

  for(n=0; n<bytes; n++)
  {
    byte    = data[n] & 0xFF;

    offset += wsprintfA(
                buffer+offset,
                ((n & 15) == 7 ? "%02.2x-" : "%02.2x "),
                byte                
                );
  }

  memcpy(buffer+offset, spaces, (16-bytes) * 3 + 2);
  offset += (16-bytes) * 3 + 2;

  for(n=0; n<bytes; n++)
  {
    ch = data[n];
    buffer[offset + n] =  (((ch < 32) || (ch > 127)) || ch == '%') ? '.' : ch;
  }

  buffer[offset + n] = '\0';

  return bytes;
}


/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  AcquireDebugFileLock()

  WHAT    : synchronizes access to the log file handle.

  ARGS    : none
  RETURNS : nothing

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void
AcquireDebugFileLock(void)
{
  WaitForSingleObject(g_mtxDebugLogFile, INFINITE);
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  ReleaseDebugFileLock()

  WHAT    : releases a thread's lock on the log file handle

  ARGS    : none
  RETURNS : nothing

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void
ReleaseDebugFileLock(void)
{
  ReleaseMutex(g_mtxDebugLogFile);
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  GetThreadInfo()

  WHAT    : extracts a THREADINFO struct from TLS. if one does not exist,
            this function allocates one and returns it.

  ARGS    : none
  RETURNS : pointer to a THREADINFO struct.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
LPTHREADINFO
GetThreadInfo(void)
{
  LPTHREADINFO pti = (LPTHREADINFO) TlsGetValue(g_dwTlsIndex);

    if( !pti )
    {
      pti = new THREADINFO;

      pti->threadid  = GetCurrentThreadId();
      pti->threadcat = 0;
      pti->depth     = 0;
      pti->stack     = NULL;

      TlsSetValue(g_dwTlsIndex, (LPVOID) pti);
    }

  return pti;
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  SetCallInfo()

  WHAT    : allocates and pushes a CALLINFO struct onto the thread's internal
            call list.

  ARGS    : pti      - pointer to the thread's THREADINFO struct
            category - the debug category associated with the logged function
            rt       - return type used by the logged function
            function - the function name

  RETURNS : pointer to a newly allocated CALLINFO struct

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
LPCALLINFO
SetCallInfo(LPTHREADINFO pti, DWORD category, RETTYPE rt, LPCSTR function)
{
  LPCALLINFO pci   = NULL;
  LPCALLINFO plast = NULL;

  //
  // walk the call stack to the last item,
  // store the next-to-last position
  //

  for( pci = pti->stack; pci; pci = pci->next )
  {
    plast = pci;
  }

  if( !pci )
  {
    pci = new CALLINFO;

    //
    // if this is the first call on this thread, set the thread
    // category id. this makes logging more understandable by
    // remembering where a thread was first created and what it
    // was used for. the old method changed the caller id based
    // on the function category, which was dumb.
    //

    if( !pti->threadcat )
      pti->threadcat = category;

    pci->category = category;
    pci->fname    = function;
    pci->rettype  = rt;
    pci->last     = plast;
    pci->next     = NULL;

    //
    // if this is the first element, insert it
    // at the head of the list, otherwise
    // link up with the last element
    //

    if( !pti->stack )
    {
      pti->stack = pci;
    }
    else
    {
      plast->next = pci;
    }
  }

  return pci;
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  GetCallInfo()

  WHAT    : retrieves the last THREADINFO struct from the threads call trace
            list.

  ARGS    : pti - pointer to the THREADINFO struct whose call list you want

  RETURNS : pointer to a CALLINFO struct

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
LPCALLINFO
GetCallInfo(LPTHREADINFO pti)
{
  LPCALLINFO pci = NULL;

  if( pti->stack )
  {
    for( pci = pti->stack; pci->next; pci = pci->next );
  }

  return pci;
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  DeleteCallInfo()

  WHAT    : pops the specified CALLINFO struct off the thread's call list and
            deletes it. if we just popped & deleted the last call record, then
            delete the thread's THREADINFO struct.

  ARGS    : pci - the CALLINFO struct you wish to delete

  RETURNS : nothing

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void
DeleteCallInfo(LPCALLINFO pci)
{
  LPTHREADINFO pti = GetThreadInfo();

  //
  // if the call record we're dealing with isn't the top of the stack
  // then fix up the stack pointers
  //
  // if the current call record is the last then delete the THREADINFO
  // for this thread and NULL the TLS value
  //

  if( pci->last )
  {
    pci->last->next = NULL;
  }
  else
  {
    delete pti;
    TlsSetValue(g_dwTlsIndex, NULL);
  }

  //
  // for all cases, free the call record
  //

  delete pci;
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  FormatCallReturnString()

  WHAT    : examines the returning function's return type and formats a string
            containing the return value. in the case of known error codes, we
            include a string representation of the error (e.g. ERROR_SUCCESS).

  ARGS    : pci    - pointer to the CALLINFO struct for the returning function
            retval - the function's return value

  RETURNS : formatted character buffer

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
LPSTR
FormatCallReturnString(LPCALLINFO pci, int retval)
{
  char* buffer = new char[256];
  int   offset = 0;

  if( buffer )
  {
    offset = wsprintfA(
               buffer,
               "%s() returned ",
               pci->fname
               );

    switch( pci->rettype )
    {
      case rt_void :
        {
          wsprintfA(buffer+offset, "<void>");
        }
        break;

      case rt_bool :
        {
          wsprintfA(buffer+offset, "%s", (retval ? "TRUE" : "FALSE"));
        }
        break;

      case rt_dword :
        {
          wsprintfA(buffer+offset, "%d [%s]", retval, MapErrorToString(retval));
        }
        break;

      case rt_hresult :
        {
          wsprintfA(buffer+offset, "%x [%s]", retval, MapHResultToString(retval));
        }
        break;

      case rt_string :
        {
          wsprintfA(buffer+offset, "%.16s", (LPSTR)retval);
        }
        break;

      default:
        {
          wsprintfA(buffer+offset, "?");
        }
    }
  }

  return buffer;
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  MapCategoryToString()

  WHAT    : maps a debug category to a string for the log file.

  ARGS    : category - the category id

  RETURNS : string representation of the category id

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
LPSTR
MapCategoryToString(int category)
{
  switch(category)
  {
    case DBG_APP : return "app";
    case DBG_WORKER : return "---";

    default : return "???";
  }
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  MapCompKeyToString()

  WHAT    : maps a completion key to a string for the log file.

  ARGS    : key - the completion key

  RETURNS : string representation of the completion key

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
LPSTR
MapCompKeyToString(int key)
{
  switch(key)
  {
    CASE_OF(CK_INVALID_KEY);
    CASE_OF(CK_NEW_CONNECTION);
    CASE_OF(CK_NORMAL);
    CASE_OF(CK_CANCEL_IO);
    CASE_OF(CK_TERMINATE_THREAD);

    default :
      {
        return "*** WARNING: Unrecognized completion key!! ***";
      }
  }
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  _debugout()

  WHAT    : the debug output workhorse. sloppy as jello in the Texas sun and
            i don't care.

  ARGS    : pti    - THREADINFO pointer
            fRaw   - skip debug info formatting
            fTrace - flag that causes us to do in-function indenting
            format - printf format string
            ...    - arglist

  RETURNS : nothing  

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void
_debugout(LPTHREADINFO pti, BOOL fRaw, BOOL fTrace, const char* format, ...)
{
  int        offset = 0;
  char*      buffer = new char[2048];
  va_list    arg_list;

  if( !buffer )
    goto quit;

    //
    // check if the user wants verbose debug info
    //

    if( !fRaw )
    {
      if( DBG_TIMESTAMP & g_dwDebugFlags )
      {
        char* timestamp = _gettimestamp();

        offset = wsprintfA(buffer, "%s ", timestamp);
        delete [] timestamp;
      }

      if( DBG_THREAD_INFO & g_dwDebugFlags )
      {
        offset += wsprintfA(buffer+offset, "%0.8x:%0.3d ", pti->threadid, pti->depth);
      }

      if( DBG_CALL_INFO & g_dwDebugFlags )
      {
        //
        // 260500 pmidge
        // changed this to use the thread category id instead of the caller's id.
        //

        offset += wsprintfA(buffer+offset, "<%s> ", MapCategoryToString(pti->threadcat));
      }

      if( DBG_NEST_CALLS & g_dwDebugFlags )
      {
        char* whitespace = _getwhitespace(
                              (fTrace ? pti->depth+1 : pti->depth)
                              );

        offset += wsprintfA(buffer+offset, "%s", whitespace);
        delete [] whitespace;
      }
    }


    //
    // plug in caller's goo if present
    //

    if( format )
    {
      va_start(arg_list, format);
      
        offset += wvsprintfA(buffer+offset, format, arg_list);
        wsprintfA(buffer+offset, "\r\n");
      
      va_end(arg_list);
    }


    //
    // dump to selected outputs
    //

    //
    // BUGBUG: this app only runs on W2K, need to
    //         investigate WMI support
    //

    if( DBG_TO_FILE & g_dwDebugFlags )
    {
      DWORD dw = 0;
    
      AcquireDebugFileLock();

        WriteFile(
          g_hDebugLogFile,
          buffer,
          strlen(buffer),
          &dw,
          NULL
          );
      
      ReleaseDebugFileLock();
    }

    if( DBG_TO_DEBUGGER & g_dwDebugFlags )
      OutputDebugStringA(buffer);

quit:
  delete [] buffer;
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  _gettimestamp( void )

  WHAT    : gets the current time, formats it, and returns it to the caller.
            the caller MUST free the return value when done.

  ARGS    : none
  RETURNS : pointer to formatted time string

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
char*
_gettimestamp( void )
{
  SYSTEMTIME st;
  char*      buffer = new char[256];
  
  if( buffer )
  {
    GetLocalTime(&st);

    wsprintfA(
      buffer,
      "%0.2d:%0.2d:%0.2d.%0.3d",
      st.wHour,
      st.wMinute,
      st.wSecond,
      st.wMilliseconds
      );
  }

  return buffer;
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  _getwhitespace( int spaces )

  WHAT    : used to insert a number of spaces for indenting. caller must
            free return value.

  ARGS    : spaces - number of spaces to insert
  
  RETURNS : pointer to character buffer filled with spaces

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
char*
_getwhitespace(int spaces)
{
  char* buffer = new char[(spaces * 2) + 1];

  if( buffer )
  {
    memset(buffer, ' ', (spaces * 2));
    buffer[(spaces * 2)] = '\0';
  }

  return buffer;
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  _opendebugfile( void )

  WHAT    : opens the debug log file. will stomp previous logs instead of
            appending.

  ARGS    : none

  RETURNS : true or false based on whether the file was opened.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
BOOL
_opendebugfile(void)
{
  if( !g_hDebugLogFile )
  {
    g_hDebugLogFile = CreateFile(
                        DEBUG_DEFAULT_DBGFILE,
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ,
                        NULL,
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );
  }
  
  return (g_hDebugLogFile ? TRUE : FALSE);
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  _closedebugfile( void )

  WHAT    : closes the debug log file.
  ARGS    : none
  RETURNS : nothing

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void
_closedebugfile(void)
{
  SAFECLOSE(g_hDebugLogFile);
}

#endif /* _DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\w3spoof\common\registry.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    registry.cpp

Abstract:

    Registry functions.
    
Author:

    Paul M Midgen (pmidge) 23-May-2000


Revision History:

    23-May-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"
//#include "registry.h"

LPCWSTR g_wszAppRootKeyName = L"Software\\W3Spoof";

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  GetRegValue()

  WHAT      : Reads the value of a REG_DWORD or REG_SZ registry value. The
              caller must free the value returned through ppvData.

  ARGS      : szValueName - the value to look up
              dwType      - can be REG_SZ or REG_DWORD
              ppvData     - address of a pointer to initialize to the data
                            read from the registry

  RETURNS   : True if the lookup succeeded, false if there was an error. The
              caller can call GetLastError() to determine the type of error.
              Possible values returned by GetLastError() are:

              ERROR_NOT_ENOUGH_MEMORY - failed to allocate storage for the
                                        requested key

              ERROR_INVALID_PARAMETER - unsupported type in dwType

              If registry lookups fail we set last error to the retcode
              from the registry api we called.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
BOOL
GetRegValue(LPCWSTR wszValueName, DWORD dwType, LPVOID* ppvData)
{
  BOOL   bStatus   = FALSE;
  DWORD  dwRet     = 0L;
  LPBYTE lpData    = NULL;
  DWORD  cbData    = 0L;
  HKEY   hkAppRoot = _GetRootKey(TRUE);

  switch( dwType )
  {
    case REG_DWORD :
      {
        cbData = sizeof(DWORD);
        lpData = new BYTE[cbData];

        if( !lpData )
        {
          SetLastError(ERROR_NOT_ENOUGH_MEMORY);
          goto quit;
        }
      }
      break;

    case REG_SZ :
      {
        // get required buffer size
        dwRet = RegQueryValueEx(
                  hkAppRoot, wszValueName, 0L,
                  &dwType, lpData, &cbData
                  );

          if( dwRet )
          {
            //DEBUG_TRACE(REGISTRY, ("requested key (%s) doesn't exist", szValueName));
            SetLastError(dwRet);
            goto quit;
          }

        lpData = new BYTE[cbData];

          if( !lpData )
          {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto quit;
          }
      }
      break;

    default :
      {
        DEBUG_TRACE(REGISTRY, ("requested type not supported"));
        SetLastError(ERROR_INVALID_PARAMETER);
        goto quit;
      }
      break;
  }

  //
  // do the lookup
  //
  dwRet = RegQueryValueEx(
            hkAppRoot, wszValueName, 0L,
            &dwType, lpData, &cbData
            );
    
    if( dwRet )
    {
      delete [] lpData;
      SetLastError(dwRet);
      goto quit;
    }

  bStatus  = TRUE;
  *ppvData = (LPVOID) lpData;

#ifdef _DEBUG
    if( bStatus )
    {
      switch( dwType )
      {
        case REG_DWORD :
          DEBUG_TRACE(REGISTRY, ("lpData: %d; cbData: %d", (DWORD)*lpData, cbData));
          break;

        case REG_SZ :
          DEBUG_TRACE(REGISTRY, ("lpdata: %s; cbData: %d", (LPSTR)lpData, cbData));
          break;
      }
    }
#endif

quit:

  return bStatus;
}


/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  SetRegValue()

  WHAT      : Writes a value under the application registry key.

  ARGS      : szValueName - the name of the regkey to write to
              dwType      - type of the regkey to write
              pvData      - regkey data
              dwSize      - bytecount of data to write

  RETURNS   : True if the write succeeded, false if otherwise.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
BOOL
SetRegValue(LPCWSTR wszValueName, DWORD dwType, LPVOID pvData, DWORD dwSize)
{
  BOOL  bStatus   = FALSE;
  DWORD dwRet     = 0L;
  HKEY  hkAppRoot = _GetRootKey(TRUE);

#ifdef _DEBUG
    switch( dwType )
    {
      case REG_DWORD :
        DEBUG_TRACE(REGISTRY, ("pvData: %d; dwSize: %d", (DWORD)*((LPDWORD)pvData), dwSize));
        break;

      case REG_SZ :
        DEBUG_TRACE(REGISTRY, ("pvData: %s; dwSize: %d", (LPSTR)pvData, dwSize));
        break;
    }
#endif

    if( !dwSize && pvData )
      dwSize = strlen((LPSTR)pvData);

    dwRet = RegSetValueEx(
              hkAppRoot, wszValueName, 0L,
              dwType, (LPBYTE)pvData, dwSize
              );

    if( dwRet != ERROR_SUCCESS )
      SetLastError(dwRet);
    else
      bStatus = TRUE;      

  return bStatus;
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  _GetRootKey()

  WHAT      : Creates/opens the root key used by the app. Remembers the key
              handle across calls, and can be called to release the key handle.

  ARGS      : fOpen - if true, open the regkey, if false, close it.

  RETURNS   : regkey handle.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
HKEY _GetRootKey(BOOL fOpen)
{
  DWORD       disp = 0;
  DWORD       ret  = 0;
  static HKEY root = NULL;

  if( fOpen )
  {
    if( !root )
    {
      ret = RegCreateKeyEx(
              HKEY_CURRENT_USER,
              g_wszAppRootKeyName,
              0,
              NULL,
              REG_OPTION_NON_VOLATILE,
              KEY_ALL_ACCESS,
              NULL,
              &root,
              &disp
              );
    }
  }
  else
  {
    if( root )
    {
      RegCloseKey(root);
      root = NULL;
    }
  }

  return root;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\w3spoof\common\mem.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 1999  Microsoft Corporation

Module Name:

    mem.cpp

Abstract:

    Replacements for operators new & delete.

    Routines implemented in this module:

      _InitMem()
      operator new
      operator delete

    These routines delegate to HeapAlloc/HeapFree, and party on the process
    heap. This helps overcome the problem of using general-purpose allocation
    functions as well as using new/delete to deal with C++ objects.
    
    Rudimentary allocation tracking is enabled in debug builds that
    allows us to see (via the last line in the log file) how much memory
    went unallocated at process termination. This doesn't take into account
    kernel, gdi, or user objects.

    Memory deallocation routines are "safe" in the sense that you can pass
    NULL pointers (invalid pointers aren't detected).

Author:

    Paul M Midgen (pmidge) 01-June-2000


Revision History:

    01-June-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"
//#include "mem.h"

HANDLE g_hProcessHeap = NULL;

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  _InitMem()

  WHAT    : Sets the global process heap handle call this before any
            allocations occur or you'll fault. Pretty simple.

  ARGS    : none.
  RETURNS : nothing

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void _InitMem(void)
{
  g_hProcessHeap = GetProcessHeap();
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  operator new

  WHAT    : Replaces the global operator new. Same usage semantics. Allocates
            objects, makes implicit calls to their constructors.

  ARGS    : size - size in bytes of the object to be allocated. the compiler
                   pushes this argument on the stack automagically.

  RETURNS : void pointer to allocated memory.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void* __cdecl operator new(size_t size)
{
  void* pv = NULL;

  if( !g_hProcessHeap )
    _InitMem();
  
    pv = HeapAlloc(g_hProcessHeap, HEAP_ZERO_MEMORY, size);
    DEBUG_ALLOC(pv);

  return pv;
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  operator delete

  WHAT    : Replaces the global operator delete. Same usage semantics. Deletes
            objects, makes implicit call to their destructors.

  ARGS    : pv - pointer to object to be freed. same compiler magic as with
                 operator new.

  RETURNS : nothing.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void __cdecl operator delete(void* pv)
{
  if( !g_hProcessHeap )
    _InitMem();

  if( pv )
  {
    DEBUG_FREE(pv);
    HeapFree(g_hProcessHeap, 0, pv);
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\w3spoof\inc\common.h ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 1999  Microsoft Corporation

Module Name:

    common.h

Abstract:

    Common includes used in the project. This file is built into a PCH.
    
Author:

    Paul M Midgen (pmidge) 15-May-2000


Revision History:

    15-May-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#ifndef _COMMON_H_
#define _COMMON_H_

#define _WIN32_WINNT 0x0500
#define _UNICODE
#define UNICODE

//
// OS includes
//

#if defined(__cplusplus)
extern "C" {
#endif

#include <windows.h>
#include <shellapi.h>
#include <advpub.h>
#include <oleauto.h>
#include <objbase.h>
#include <ocidl.h>
#include <olectl.h>
#include <activscp.h>
#include <activdbg.h>
#include <winsock2.h>
#include <mswsock.h>
#include <winhttp.h>
#include <httprequest.h>
#include <commctrl.h>

#if defined(__cplusplus)
}
#endif


//
// w3spoof includes
//

#pragma warning( disable : 4100 ) // unreferenced formal parameter

#include <resources.h>
#include <mem.h>
#include <utils.h>
#include <debug.h>
#include <hashtable.h>
#include <linklist.h>
#include <stores.h>
#include <dispids.h>
#include <om_ifaces.h> // generated
#include <w3srt.h>
#include <int_ifaces.h>
#include <registry.h>
#include <om.h>
#include <w3sobj.h>

#endif /* _COMMON_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\w3spoof\common\utils.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    utils.cxx

Abstract:

    Utility functions.
    
Author:

    Paul M Midgen (pmidge) 12-October-2000


Revision History:

    12-October-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

#ifdef __cplusplus
extern "C" {
#endif

const IID IID_IWinHttpRequest =
{
  0x06f29373,
  0x5c5a,
  0x4b54,
  {0xb0,0x25,0x6e,0xf1,0xbf,0x8a,0xbf,0x0e}
};

#ifdef __cplusplus
}
#endif

//-----------------------------------------------------------------------------
// file retrieval
//-----------------------------------------------------------------------------
BOOL
__PathIsUNC(LPCWSTR path)
{
  BOOL   bIsUNC   = FALSE;
  WCHAR* embedded = NULL;

  // is the path a UNC share? e.g. \\foo\bar\baz.htm
  if( wcsstr(path, L"\\\\") )
  {
    embedded = wcsstr(path, L"\\");

    if( embedded && (wcslen(embedded) > 1) )
    {
      bIsUNC = TRUE;
    }
  }
  else // how about a filesystem path, e.g. z:\foo\bar.htm
  {
    embedded = wcsstr(path, L":");

    if( embedded && ((embedded-1) == path) )
    {
      bIsUNC = TRUE;
    }
  }

  return bIsUNC;
}

BOOL
__PathIsURL(LPCWSTR path)
{
  BOOL bIsURL = FALSE;

  if( wcsstr(path, L"http") )
  {
    bIsURL = TRUE;
  }

  return bIsURL;
}

BOOL
GetFile(LPCWSTR path, HANDLE* phUNC, IWinHttpRequest** ppWHR, DWORD mode, BOOL* bReadOnly)
{
  DEBUG_ENTER((
    DBG_UTILS,
    rt_bool,
    "GetFile",
    "path=%S; phUNC=%#x; ppWHR=%#x; mode=%#x; bReadOnly=%#x",
    path,
    phUNC,
    ppWHR,
    mode,
    bReadOnly
    ));

  BOOL bSuccess = FALSE;

  if( path )
  {
    if( phUNC )
    {
      *phUNC = __OpenFile(path, mode, bReadOnly);

      if( *phUNC != INVALID_HANDLE_VALUE )
      {
        bSuccess = TRUE;
      }
    }
    else if( ppWHR )
    {
      *ppWHR = __OpenUrl(path);

      if( *ppWHR )
      {
        *bReadOnly = TRUE;
        bSuccess   = TRUE;
      }
    }
  }

  DEBUG_LEAVE(bSuccess);
  return bSuccess;
}

HANDLE
__OpenFile(LPCWSTR path, DWORD mode, BOOL* bReadOnly)
{
  HANDLE hFile = INVALID_HANDLE_VALUE;
  DWORD  flags = GENERIC_READ | GENERIC_WRITE;

retry:

  hFile = CreateFile(
            path,
            flags,
            FILE_SHARE_READ,
            NULL,
            mode,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );

  if( hFile == INVALID_HANDLE_VALUE )
  {
    if( GetLastError() == ERROR_ACCESS_DENIED )
    {
      if( flags == (GENERIC_READ | GENERIC_WRITE) )
      {
        DEBUG_TRACE(UTILS, ("read/write open attempt failed, retrying for read-only access"));

        flags      = GENERIC_READ;
        *bReadOnly = TRUE;
        goto retry;
      }
    }

    DEBUG_TRACE(UTILS, ("error opening %S: %s", path, MapErrorToString(GetLastError())));
  }
  else
  {
    DEBUG_TRACE(UTILS, ("file opened"));
  }

  return hFile;
}

IWinHttpRequest*
__OpenUrl(LPCWSTR url)
{
  HRESULT          hr         = S_OK;
  IWinHttpRequest* pWHR       = NULL;
  BSTR             bstrVerb   = SysAllocString(L"GET");
  BSTR             bstrUrl    = SysAllocString(url);
  LONG             status     = 0L;
  CLSID            clsid;

  NEWVARIANT(var);
  NEWVARIANT(async);

  V_VT(&async)   = VT_BOOL;
  V_BOOL(&async) = FALSE;

  hr = CLSIDFromProgID(L"WinHttp.WinHttpRequest.5", &clsid);

    if( FAILED(hr) )
    {
      DEBUG_TRACE(UTILS, ("failed to get WinHttpRequest CLSID from registry (%s)", MapHResultToString(hr)));
      goto quit;
    }

  hr = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, IID_IWinHttpRequest, (void**) &pWHR);

    if( FAILED(hr) )
    {
      DEBUG_TRACE(UTILS, ("CoCreateInstance for IID_IWinHttpRequest failed (%s)", MapHResultToString(hr)));
      goto quit;
    }

  hr = pWHR->SetProxy(HTTPREQUEST_PROXYSETTING_PRECONFIG, var, var);

    if( FAILED(hr) )
    {
      DEBUG_TRACE(UTILS, ("failed to set proxy (%s)", MapHResultToString(hr)));
      goto quit;
    }

  hr = pWHR->Open(bstrVerb, bstrUrl, async);

    if( FAILED(hr) )
    {
      DEBUG_TRACE(UTILS, ("failed to open %S (%s)", bstrUrl, MapHResultToString(hr)));
      goto quit;
    }

  hr = pWHR->Send(var);

    if( FAILED(hr) )
    {
      DEBUG_TRACE(UTILS, ("failed to send request (%s)", MapHResultToString(hr)));
      goto quit;
    }

  hr = pWHR->get_Status(&status);

    if( SUCCEEDED(hr) )
    {
      DEBUG_TRACE(UTILS, ("response status %d", status));
      hr = (status == 200) ? S_OK : E_FAIL;
    }
    else
    {
      DEBUG_TRACE(UTILS, ("failed to get response status (%s)", MapHResultToString(hr)));
    }

quit:

  if( FAILED(hr) )
  {
    SAFERELEASE(pWHR);
  }

  SAFEDELETEBSTR(bstrVerb);
  SAFEDELETEBSTR(bstrUrl);
  VariantClear(&var);
  VariantClear(&async);

  return pWHR;
}

//-----------------------------------------------------------------------------
// general utility functions
//-----------------------------------------------------------------------------
HRESULT
GetTypeInfoFromName(LPCOLESTR name, ITypeLib* ptl, ITypeInfo** ppti)
{
  DEBUG_ENTER((
    DBG_UTILS,
    rt_hresult,
    "GetTypeInfoFromName",
    "name=%.16S; ptl=%#x; ppti=%#x",
    name,
    ptl,
    ppti
    ));

  HRESULT  hr     = S_OK;
  BOOL     bFound = FALSE;
  USHORT   cf     = 1L;
  ULONG    hash   = 0L;
  LONG     id     = 0L;
  LPOLESTR pstr   = NULL;

  if( !name || ! ptl )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  if( !ppti )
  {
    hr = E_POINTER;
    goto quit;
  }

  *ppti = NULL;
  pstr  = __wstrdup(name);

    ptl->IsName(pstr, 0L, &bFound);

      if( !bFound )
      {
        hr = TYPE_E_ELEMENTNOTFOUND;
        goto quit;
      }

    hash = LHashValOfNameSys(
             SYS_WIN32,
             MAKELCID(MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL), SORT_DEFAULT),
             pstr
             );

    hr = ptl->FindName(pstr, hash, ppti, &id, &cf);

    DEBUG_TRACE(UTILS, ("find name: pti=%#x; cf=%d", *ppti, cf));

quit:

  SAFEDELETEBUF(pstr);

  DEBUG_LEAVE(hr);
  return hr;
}

BOOL
GetJScriptCLSID(LPCLSID pclsid)
{
  DEBUG_ENTER((
    DBG_UTILS,
    rt_bool,
    "GetJScriptCLSID",
    "pclsid=%#x",
    pclsid
    ));

  BOOL   ret = FALSE;
  HKEY   hk  = NULL;
  LPBYTE buf = NULL;
  DWORD  cb  = 0L;
  DWORD  rt  = REG_SZ;

  if( RegOpenKey(HKEY_CLASSES_ROOT, L"JScript\\CLSID", &hk) == ERROR_SUCCESS )
  {
    if( RegQueryValueEx(hk, L"", NULL, &rt, NULL, &cb) == ERROR_SUCCESS )
    {
      buf = new BYTE[cb];

        RegQueryValueEx(hk, L"", NULL, &rt, buf, &cb);
        CLSIDFromString((LPOLESTR) buf, pclsid);
        ret = TRUE;

      SAFEDELETEBUF(buf);
    }
  }

  DEBUG_LEAVE(ret);
  return ret;
}

void
ParseSocketInfo(PIOCTX pi)
{
  PSOCKADDR_IN pLocal    = NULL;
  PSOCKADDR_IN pRemote   = NULL;
  int          cbLocal   = 0;
  int          cbRemote  = 0;
  char*        buf       = NULL;
  int          len       = 0;
  int          error     = 0;

  GetAcceptExSockaddrs(
    pi->sockbuf, 0,
    SOCKADDRBUFSIZE,
    SOCKADDRBUFSIZE,
    (PSOCKADDR*) &pLocal,  &cbLocal,
    (PSOCKADDR*) &pRemote, &cbRemote
    );

  pi->local  = new HOSTINFO;
  pi->remote = new HOSTINFO;

  GetHostname(pLocal->sin_addr, &pi->local->name);
  pi->local->addr = __strdup(inet_ntoa(pLocal->sin_addr));
  pi->local->port = ntohs(pLocal->sin_port);

  GetHostname(pRemote->sin_addr, &pi->remote->name);
  pi->remote->addr = __strdup(inet_ntoa(pRemote->sin_addr));
  pi->remote->port = ntohs(pRemote->sin_port);

  if( !pi->remote->name )
  {
    pi->remote->name = __strdup(pi->remote->addr);
  }

  len = strlen(pi->remote->name)+7; // ":" plus 5 port digits and a null
  buf = new char[len]; 

  strncpy(buf, pi->remote->name, len);
  strncat(buf, ":", sizeof(char));
  _itoa(pi->remote->port, (buf+strlen(buf)), 10);

  pi->clientid = __ansitowide(buf);

  SAFEDELETEBUF(buf);
}

void
GetHostname(struct in_addr ip, LPSTR* ppsz)
{
  HOSTENT* ph = NULL;

  ph = gethostbyaddr(
         (char*) &ip,
         sizeof(struct in_addr),
         AF_INET
         );

  if( ph )
  {
    *ppsz = __strdup(ph->h_name);
  }
  else
  {
    *ppsz = NULL;
  }
}

DISPID
GetDispidFromName(PDISPIDTABLEENTRY pdt, DWORD cEntries, LPWSTR name)
{
  DWORD  n      = 0L;
  DWORD  hash   = GetHash(name);
  DISPID dispid = DISPID_UNKNOWN;

  while( n < cEntries )
  {
    if( pdt[n].hash != hash )
    {
      ++n;
    }
    else
    {
      dispid = pdt[n].dispid;
      break;
    }
  }

  DEBUG_TRACE(DISPATCH, ("hash %#x is %s", hash, MapDispidToString(dispid)));
  return dispid;
}

void
AddRichErrorInfo(EXCEPINFO* pei, LPWSTR source, LPWSTR description, HRESULT error)
{
  if( pei )
  {
    pei->bstrSource      = __widetobstr((source ? source : L"unknown source"));
    pei->bstrDescription = __widetobstr((description ? description : L"no description"));
    pei->scode           = error;
  }
}

DWORD
GetHash(LPWSTR name)
{
  DWORD hash   = 0L;
  DWORD n      = 0L;
  DWORD len    = 0L;
  LPSTR string = NULL;

  string = __widetoansi(name);

  if( string )
  {
    _strlwr(string);

    for(n=0, len=strlen(string); n<=len; n++)
    {
      hash += __toascii(string[len-n]) * ((10<<n)^n);
    }

    DEBUG_TRACE(DISPATCH, ("name=%s; hash=%#x", string, hash));
  }

  SAFEDELETEBUF(string);
  return hash;
}

DWORD
GetHash(LPSTR name)
{
  DWORD hash   = 0L;
  DWORD n      = 0L;
  DWORD len    = 0L;
  LPSTR string = NULL;

  string = __strdup(name);

  if( string )
  {
    _strlwr(string);

    for(n=0, len=strlen(string); n<=len; n++)
    {
      hash += __toascii(string[len-n]) * ((10<<n)^n);
    }

    DEBUG_TRACE(DISPATCH, ("name=%s; hash=%#x", string, hash));
  }

  SAFEDELETEBUF(string);
  return hash;
}

HRESULT
ProcessVariant(VARIANT* pvar, LPBYTE* ppbuf, LPDWORD pcbuf, LPDWORD pbytes)
{
  DEBUG_ENTER((
    DBG_UTILS,
    rt_hresult,
    "ProcessVariant",
    "pvar=%#x; ppbuf=%#x; pcbuf=%#x; pbytes=%#x",
    pvar,
    ppbuf,
    pcbuf,
    pbytes
    ));
  
  HRESULT hr      = S_OK;
  LPBYTE  pbyte   = NULL;
  DWORD   len     = NULL;
  BOOL    bAlloc  = FALSE;
  BOOL    bBypass = FALSE;

  if( !ppbuf || !pcbuf )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  //
  // if the caller wants us to allocate storage, we don't need
  // the pbytes parameter. otherwise, we do in case the caller
  // needs to resize their buffer.
  //
  if( ((*ppbuf) && *pcbuf != 0) && !pbytes )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  if( !(*ppbuf) && *pcbuf == 0 )
  {
    DEBUG_TRACE(UTILS, ("will allocate storage for variant data"));
    bAlloc = TRUE;
  }

  DEBUG_TRACE(
    RUNTIME,
    ("variant type is %s", MapVariantTypeToString(pvar))
    );

    switch( V_VT(pvar) )
    {
      case VT_BSTR :
        {
          pbyte = (LPBYTE) __widetoansi(V_BSTR(pvar));
          len   = strlen((LPSTR) pbyte);
        }
        break;

      case VT_ARRAY | VT_UI1 :
        {
          SAFEARRAY* psa  = V_ARRAY(pvar);
          LPBYTE     ptmp = NULL;

          hr = SafeArrayAccessData(psa, (void**) &ptmp);

          if( SUCCEEDED(hr) )
          {
            SafeArrayGetUBound(psa, 1, (long*) &len);

              pbyte = new BYTE[len];
              memcpy(pbyte, ptmp, len);

            SafeArrayUnaccessData(psa);
          }
        }
        break;

      case VT_UNKNOWN :
        {
          hr      = ProcessObject(pvar->punkVal, ppbuf, pcbuf, pbytes);
          bBypass = TRUE;
        }
        break;

      case VT_DISPATCH :
        {
          IUnknown* punk = NULL;
          
            if( SUCCEEDED(pvar->pdispVal->QueryInterface(IID_IUnknown, (void**) &punk)) )
            {
              hr      = ProcessObject(punk, ppbuf, pcbuf, pbytes);
              bBypass = TRUE;
            }
            
          SAFERELEASE(punk);
        }
        break;

      default :
        {
          hr = E_INVALIDARG;
        }
    }

  //
  // bBypass is set when we make a call into ProcessObject(), which
  // always calls back into us to handle the unpacked non-object-type
  // variant. in that nested call the buffers & length variables are
  // set, so we bypass those operations when the outer call unwinds.
  //
  if( SUCCEEDED(hr) && !bBypass )
  {
    if( bAlloc )
    {
      *ppbuf  = pbyte;
      *pcbuf  = len;
    }
    else
    {
      if( *pcbuf >= len )
      {
        memcpy(*ppbuf, pbyte, len);
        *pbytes = len;
      }
      else
      {
        hr     = E_OUTOFMEMORY;
        *pcbuf = len;
      }
      
      SAFEDELETEBUF(pbyte);
    }
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}

//
// WARNING: do not modify these values. use disphash.exe to generate
//          new values.
//
#define CLASS_HASH_URL     0x0000417f
#define CLASS_HASH_ENTITY  0x000213d4
#define CLASS_HASH_HEADERS 0x000401cd

HRESULT
ProcessObject(IUnknown* punk, LPBYTE* ppbuf, LPDWORD pcbuf, LPDWORD pbytes)
{
  DEBUG_ENTER((
    DBG_UTILS,
    rt_hresult,
    "ProcessObject",
    "punk=%#x",
    punk
    ));
  
  HRESULT            hr    = E_FAIL;
  IProvideClassInfo* pci   = NULL;
  IW3SpoofFile*      pfile = NULL;

  // first try to use class information to determine what was
  // passed in. all om objects support this method.

  //
  // BUGBUG: potential failure case is when objects are "torn off" from
  //         their parents (e.g. persisted through the runtime property bag).
  //         in that scenario the objects lose site information and therefore
  //         aren't able to look up their typeinfo. fix is to cache typeinfo
  //         during object creation.
  //
  //         workitem filed IEv6 #21277
  //
  hr = punk->QueryInterface(IID_IProvideClassInfo, (void**) &pci);

    if( SUCCEEDED(hr) )
    {
      ITypeInfo* pti      = NULL;
      IEntity*   pentity  = NULL;
      IHeaders*  pheaders = NULL;
      IUrl*      purl     = NULL;
      BSTR       name     = NULL;
      NEWVARIANT(tmp);
      
      if( SUCCEEDED(pci->GetClassInfo(&pti)) )
      {
        pti->GetDocumentation(MEMBERID_NIL, &name, NULL, NULL, NULL);

        DEBUG_TRACE(SOCKET, ("processing an %S object", name));

          switch( GetHash(name) )
          {
            case CLASS_HASH_URL :
              {
                if( SUCCEEDED(punk->QueryInterface(IID_IUrl, (void**) &purl)) )
                {
                  if( SUCCEEDED(purl->Get(&V_BSTR(&tmp))) )
                  {
                    V_VT(&tmp) = VT_BSTR;
                    hr         = ProcessVariant(&tmp, ppbuf, pcbuf, pbytes);
                  }
                }
              }
              break;

            case CLASS_HASH_HEADERS :
              {
                if( SUCCEEDED(punk->QueryInterface(IID_IHeaders, (void**) &pheaders)) )
                {
                  if( SUCCEEDED(pheaders->Get(&V_BSTR(&tmp))) )
                  {
                    V_VT(&tmp) = VT_BSTR;
                    hr         = ProcessVariant(&tmp, ppbuf, pcbuf, pbytes);
                  }
                }
              }
              break;

            case CLASS_HASH_ENTITY :
              {
                if( SUCCEEDED(punk->QueryInterface(IID_IEntity, (void**) &pentity)) )
                {
                  if( SUCCEEDED(pentity->Get(&tmp)) )
                  {
                    hr = ProcessVariant(&tmp, ppbuf, pcbuf, pbytes);
                  }
                }
              }
              break;
          }

        SAFERELEASE(pti);
        SAFERELEASE(purl);
        SAFERELEASE(pentity);
        SAFERELEASE(pheaders);
        SAFEDELETEBSTR(name);
        VariantClear(&tmp);
      }

      SAFERELEASE(pci);

      if( SUCCEEDED(hr) )
      {
        goto quit;
      }
    }

  // try IW3SpoofFile...
  hr = punk->QueryInterface(IID_IW3SpoofFile, (void**) &pfile);

    if( SUCCEEDED(hr) )
    {
      NEWVARIANT(tmp);

      DEBUG_TRACE(SOCKET, ("processing an IW3SpoofFile object"));

      hr = pfile->ReadAll(&tmp);

        if( SUCCEEDED(hr) )
        {
          hr = ProcessVariant(&tmp, ppbuf, pcbuf, pbytes);
        }
      
      SAFERELEASE(pfile);
      VariantClear(&tmp);
    }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}

HRESULT
ValidateDispatchArgs(REFIID riid, DISPPARAMS* pdp, VARIANT* pvr, UINT* pae)
{
  HRESULT hr = S_OK;

    if( !IsEqualIID(riid, IID_NULL) )
    {
      hr = DISP_E_UNKNOWNINTERFACE;
      goto quit;
    }

    if( !pdp )
    {
      hr = E_INVALIDARG;
      goto quit;
    }

    if( pae )
    {
      *pae = 0;
    }

    if( pvr )
    {
      VariantInit(pvr);
    }

quit:

  return hr;
}

HRESULT
ValidateInvokeFlags(WORD flags, WORD accesstype, BOOL bNotMethod)
{
  HRESULT hr = S_OK;

    if( (flags & ~(DISPATCH_METHOD | DISPATCH_PROPERTYGET | DISPATCH_PROPERTYPUT)) )
    {
      hr = E_INVALIDARG;
    }
    else
    {
      if( bNotMethod )
      {
        if( flags & DISPATCH_METHOD )
        {
          hr = E_NOINTERFACE;
        }
        else
        {
          if( (flags & DISPATCH_PROPERTYPUT) && !(accesstype & DISPATCH_PROPERTYPUT) )
          {
            hr = E_ACCESSDENIED;
          }
          else
          {
            if( !(flags & accesstype) )
            {
              hr = E_FAIL;
            }
          }
        }
      }
      else
      {
        if( flags & ~(DISPATCH_METHOD | DISPATCH_PROPERTYGET) )
        {
          hr = E_NOINTERFACE;
        }
      }
    }

  return hr;
}

HRESULT
ValidateArgCount(DISPPARAMS* pdp, DWORD needed, BOOL bHasOptionalArgs, DWORD optional)
{
  HRESULT hr = S_OK;

    if( bHasOptionalArgs )
    {
      if( (pdp->cArgs > needed+optional) || (pdp->cArgs < needed) )
      {
        hr = DISP_E_BADPARAMCOUNT;
      }
    }
    else
    {
      if( (!needed && pdp->cArgs) || (needed < pdp->cArgs) )
      {
        hr = DISP_E_BADPARAMCOUNT;
      }
      else
      {
        hr = (pdp->cArgs == needed) ? S_OK : DISP_E_PARAMNOTOPTIONAL;
      }
    }

  return hr;
}

HRESULT
HandleDispatchError(LPWSTR id, EXCEPINFO* pei, HRESULT hr)
{
  LPWSTR msg = NULL;

  switch( hr )
  {
    case E_POINTER      : msg = L"a return pointer parameter was missing";                  break;
    case E_ACCESSDENIED : msg = L"attempt to modify object failed because it is read-only"; break;
    case E_FAIL         : msg = L"an unhandled error occurred";                             break;
    case E_INVALIDARG   : msg = L"an argument passed to a property or method was invalid";  break;
    case E_NOINTERFACE  : msg = L"a property or method was accessed incorrectly";           break;
    default             : return hr;
  }

  AddRichErrorInfo(pei, id, msg, hr);

  return DISP_E_EXCEPTION;
}

//-----------------------------------------------------------------------------
// string & type manipulation
//-----------------------------------------------------------------------------
char*
__strdup(const char* src)
{
  int   n   = 0;
  char* dup = NULL;

  if( src )
  {
    n   = strlen(src)+1;
    dup = new char[n];
    strncpy(dup, src, n);
  }

  return dup;
}

char*
__strndup(const char* src, int len)
{
  char* dup = NULL;

  if( src )
  {
    dup      = new char[len+1];
    dup[len] = '\0';
    strncpy(dup, src, len);
  }

  return dup;
}

WCHAR*
__wstrdup(const WCHAR* src)
{
  int    n   = 0;
  WCHAR* dup = NULL;

  if( src )
  {
    n   = wcslen(src)+1;
    dup = new WCHAR[n];
    wcsncpy(dup, src, n);
  }

  return dup;
}

WCHAR*
__wstrndup(const WCHAR* src, int len)
{
  WCHAR* dup = NULL;

  if( src )
  {
    dup      = new WCHAR[len+1];
    dup[len] = L'\0';
    wcsncpy(dup, src, len);
  }

  return dup;
}

WCHAR*
__ansitowide(const char* psz)
{
  WCHAR* wide = NULL;
  int    len  = 0L;

  if( psz )
  {
    len  = strlen(psz);

    if( len )
    {
      ++len;
      wide = new WCHAR[len];

      MultiByteToWideChar(
        CP_ACP,
        0,
        psz,
        len,
        wide,
        len
        );
    }
  }

  return wide;
}

CHAR*
__widetoansi(const WCHAR* pwsz)
{
  CHAR* ansi = NULL;
  int   len  = 0L;
  BOOL  def  = FALSE;

  if( pwsz )
  {
    len  = wcslen(pwsz);

    if( len )
    {
      ++len;
      ansi = new CHAR[len];

      WideCharToMultiByte(
        CP_ACP,
        0,
        pwsz,
        len,
        ansi,
        len,
        "?",
        &def
        );
    }
  }

  return ansi;
}

BSTR
__ansitobstr(LPCSTR src)
{
  BSTR   ret = NULL;
  LPWSTR wsz = NULL;

  if( src )
  {
    wsz = __ansitowide(src);
    ret = SysAllocString(wsz);
    SAFEDELETEBUF(wsz);
  }

  return ret;
}

BSTR
__widetobstr(LPCWSTR wsrc)
{
  return (wsrc ? SysAllocString(wsrc) : NULL);
}

BOOL
__isempty(VARIANT var)
{
  BOOL isempty = FALSE;

  if(
      ((V_VT(&var) == VT_EMPTY) || (V_VT(&var) == VT_NULL) || (V_VT(&var) == VT_ERROR)) ||
      ((V_VT(&var) == VT_BSTR) && (SysStringLen(V_BSTR(&var)) == 0))
    )
  {
    isempty = TRUE;
  }

  return isempty;
}

// private
char hex2char(char* hex)
{
  register char digit;
  
    digit  = (hex[0] >= 'A' ? ((hex[0] & 0xdf) - 'A')+10 : (hex[0] - '0'));
    digit *= 16;
    digit += (hex[1] >= 'A' ? ((hex[1] & 0xdf) - 'A')+10 : (hex[1] - '0'));

  return(digit);
}

char*
__unescape(char* str)
{
  register int x;
  register int y;
  char*        str2;

  str2 = __strdup(str);

  if( str2 )
  {    
    for(x=0, y=0; str2[y]; ++x, ++y)
    {
      if((str2[x] = str2[y]) == '%')
      {
        str2[x] = hex2char(&str2[y+1]);
        y += 2;
      }
    }
    
    str2[x] = '\0';
  }

  return str2;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\w3spoof\exe\entry.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    entry.c

Abstract:

    Implements the WinMain() application entry point.
    
Author:

    Paul M Midgen (pmidge) 07-June-2000


Revision History:

    07-June-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

void _SetCurrentDirectory(void);
BOOL Initialize(void);
void Terminate(void);

int
WINAPI
WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR szCmdLine, int iCmdShow)
{
  _SetCurrentDirectory();

  DEBUG_INITIALIZE();

  DEBUG_ENTER((
    DBG_APP,
    rt_dword,
    "WinMain",
    "hInstance=%#x; hPrevInstance=%#x; cmdline=%s; cmdshow=%d",
    hInstance,
    hPrevInstance,
    szCmdLine,
    iCmdShow
    ));

  DWORD       dwRet = ERROR_SUCCESS;
  HRESULT     hr    = S_OK;
  CFactory*   pcf   = NULL;
  IW3Spoof*   pw3s  = NULL;

    if( Initialize() )
    {
      hr = CFactory::Create(&pcf);

        if( FAILED(hr) )
        {
          DEBUG_TRACE(APP, ("failed to create class factory"));
          goto quit;
        }

      hr = pcf->CreateInstance(NULL, IID_IW3Spoof, (void**) &pw3s);

        if( FAILED(hr) )
        {
          DEBUG_TRACE(APP, ("failed to create w3spoof interface"));
          goto quit;
        }

      if( szCmdLine && strstr(szCmdLine, "register") )
      {
        goto quit;
      }

      pcf->Activate();
      pw3s->WaitForUnload();
    }
    else
    {
      DEBUG_TRACE(APP, ("application init failed."));
    }

quit:

  DEBUG_TRACE(APP, ("starting final cleanup"));

  SAFETERMINATE(pcf);    
  SAFERELEASE(pw3s);

  Terminate();

  DEBUG_LEAVE(dwRet);
  DEBUG_TERMINATE();
  return dwRet;
}


void
_SetCurrentDirectory(void)
{
  WCHAR path[MAX_PATH+1];

  memset((void*) path, 0L, MAX_PATH+1);

  if( GetModuleFileName(NULL, path, MAX_PATH) )
  {
    *(wcsrchr(path, L'\\')) = L'\0';
    SetCurrentDirectory(path);
  }
}


BOOL
Initialize(void)
{
  BOOL    bRet  = TRUE;
  DWORD   dwRet = ERROR_SUCCESS;
  HRESULT hr    = S_OK;
  WSADATA wsd   = {0};

  hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    if( SUCCEEDED(hr) )
    {
      if( (dwRet = WSAStartup(0x0202, &wsd)) != ERROR_SUCCESS )
      {
        DEBUG_TRACE(APP, ("WSAStartup failed: %d [%s]", dwRet, MapErrorToString(dwRet)));
        bRet = FALSE;
      }
      else
      {
        DEBUG_DUMPWSOCKSTATS(wsd);
      }
    }
    else
    {
      DEBUG_TRACE(APP, ("CoInitialize failed: %d [%s]", hr, MapHResultToString(hr)));
      bRet = FALSE;
    }

  return bRet;
}


void
Terminate(void)
{
  _GetRootKey(FALSE);
  WSACleanup();
  CoUninitialize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\w3spoof\inc\pch.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 1999  Microsoft Corporation

Module Name:

    pch.cxx

Abstract:

    Need this so the precompiled header will, umm, compile.
    
Author:

    Paul M Midgen (pmidge) 24-July-2000


Revision History:

    24-July-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

void foobar(void);

void foobar(void)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\w3spoof\inc\dispids.h ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    dispids.h

Abstract:

    W3Spoof automation interface dispids.
    
Author:

    Paul M Midgen (pmidge) 11-July-2000


Revision History:

    11-July-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#ifndef __DISPIDS_H__
#define __DISPIDS_H__

#define DISPID_SESSION_BASE             0x00000001
#define DISPID_SOCKET_BASE              0x00000100
#define DISPID_HEADERS_BASE             0x00000200
#define DISPID_ENTITY_BASE              0x00000300
#define DISPID_URL_BASE                 0x00000400
#define DISPID_REQUEST_BASE             0x00000500
#define DISPID_RESPONSE_BASE            0x00000600
#define DISPID_W3SPOOF_BASE             0x00000800

#define DISPID_SESSION_SOCKET           (DISPID_SESSION_BASE + 1)
#define DISPID_SESSION_REQUEST          (DISPID_SESSION_BASE + 2)
#define DISPID_SESSION_RESPONSE         (DISPID_SESSION_BASE + 3)
#define DISPID_SESSION_GETPROPERTYBAG   (DISPID_SESSION_BASE + 4)
#define DISPID_SESSION_KEEPALIVE        (DISPID_SESSION_BASE + 5)

#define DISPID_SOCKET_PARENT            (DISPID_SOCKET_BASE + 1)
#define DISPID_SOCKET_SEND              (DISPID_SOCKET_BASE + 2)
#define DISPID_SOCKET_RECV              (DISPID_SOCKET_BASE + 3)
#define DISPID_SOCKET_OPTION            (DISPID_SOCKET_BASE + 4)
#define DISPID_SOCKET_CLOSE             (DISPID_SOCKET_BASE + 5)
#define DISPID_SOCKET_RESOLVE           (DISPID_SOCKET_BASE + 6)
#define DISPID_SOCKET_LOCALNAME         (DISPID_SOCKET_BASE + 7)
#define DISPID_SOCKET_LOCALADDRESS      (DISPID_SOCKET_BASE + 8)
#define DISPID_SOCKET_LOCALPORT         (DISPID_SOCKET_BASE + 9)
#define DISPID_SOCKET_REMOTENAME        (DISPID_SOCKET_BASE + 10)
#define DISPID_SOCKET_REMOTEADDRESS     (DISPID_SOCKET_BASE + 11)
#define DISPID_SOCKET_REMOTEPORT        (DISPID_SOCKET_BASE + 12)

#define DISPID_HEADERS_PARENT           (DISPID_HEADERS_BASE + 1)
#define DISPID_HEADERS_SET              (DISPID_HEADERS_BASE + 2)
#define DISPID_HEADERS_GET              (DISPID_HEADERS_BASE + 3)
#define DISPID_HEADERS_GETHEADER        (DISPID_HEADERS_BASE + 4)
#define DISPID_HEADERS_SETHEADER        (DISPID_HEADERS_BASE + 5)

#define DISPID_ENTITY_PARENT            (DISPID_ENTITY_BASE + 1)
#define DISPID_ENTITY_GET               (DISPID_ENTITY_BASE + 2)
#define DISPID_ENTITY_SET               (DISPID_ENTITY_BASE + 3)
#define DISPID_ENTITY_COMPRESS          (DISPID_ENTITY_BASE + 4)
#define DISPID_ENTITY_DECOMPRESS        (DISPID_ENTITY_BASE + 5)
#define DISPID_ENTITY_LENGTH            (DISPID_ENTITY_BASE + 6)

#define DISPID_URL_PARENT               (DISPID_URL_BASE + 1)
#define DISPID_URL_ENCODING             (DISPID_URL_BASE + 2)
#define DISPID_URL_SCHEME               (DISPID_URL_BASE + 3)
#define DISPID_URL_SERVER               (DISPID_URL_BASE + 4)
#define DISPID_URL_PORT                 (DISPID_URL_BASE + 5)
#define DISPID_URL_PATH                 (DISPID_URL_BASE + 6)
#define DISPID_URL_RESOURCE             (DISPID_URL_BASE + 7)
#define DISPID_URL_QUERY                (DISPID_URL_BASE + 8)
#define DISPID_URL_FRAGMENT             (DISPID_URL_BASE + 9)
#define DISPID_URL_ESCAPE               (DISPID_URL_BASE + 10)
#define DISPID_URL_UNESCAPE             (DISPID_URL_BASE + 11)
#define DISPID_URL_SET                  (DISPID_URL_BASE + 12)
#define DISPID_URL_GET                  (DISPID_URL_BASE + 13)

#define DISPID_REQUEST_PARENT           (DISPID_REQUEST_BASE + 1)
#define DISPID_REQUEST_HEADERS          (DISPID_REQUEST_BASE + 2)
#define DISPID_REQUEST_ENTITY           (DISPID_REQUEST_BASE + 3)
#define DISPID_REQUEST_URL              (DISPID_REQUEST_BASE + 4)
#define DISPID_REQUEST_VERB             (DISPID_REQUEST_BASE + 5)
#define DISPID_REQUEST_HTTPVERSION      (DISPID_REQUEST_BASE + 6)

#define DISPID_RESPONSE_PARENT          (DISPID_RESPONSE_BASE + 1)
#define DISPID_RESPONSE_HEADERS         (DISPID_RESPONSE_BASE + 2)
#define DISPID_RESPONSE_ENTITY          (DISPID_RESPONSE_BASE + 3)
#define DISPID_RESPONSE_STATUSCODE      (DISPID_RESPONSE_BASE + 4)
#define DISPID_RESPONSE_STATUSTEXT      (DISPID_RESPONSE_BASE + 5)

#define DISPID_W3SPOOF_REGISTERCLIENT   (DISPID_W3SPOOF_BASE + 1)
#define DISPID_W3SPOOF_REVOKECLIENT     (DISPID_W3SPOOF_BASE + 2)

#endif /* __DISPIDS_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\w3spoof\inc\hashtable.h ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    hashtable.cxx

Abstract:

    Simple hash table implementation.


Author:

    Paul M Midgen (pmidge) 14-August-2000


Revision History:

    14-August-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include <common.h>

/*++===========================================================================

    An array is separated into N buckets that     +---+
    each contain a pointer to a binary search     | 0 |------> O
    tree. The tree's nodes are indexed by a       +---+       / \
    DWORD identifier to enable speedy traversals. | 1 |      O   O
    The array buckets are indexed by the values   +---+     / \   \
    generated by the hashing function supplied    | 2 |    O   O   O
    by a derived class.                           +---+        
                                                  | N |

    Clients derive a class from the hashtable ADT and specialize it for a 
    given data type. Any data type can be used. The only function the client
    must implement is the GetHashAndBucket function, and their class must
    provide the number of buckets the ADT needs to support. This is usually
    some number that is modulo'd against the generated hashes to yield the
    bucket number.

===========================================================================--*/

#define HT_COMPARE_LARGER  0x00000001
#define HT_COMPARE_SMALLER 0x00000002
#define HT_COMPARE_EQUAL   0x00000003

#define HT_TREE_ROOT       0x00000004
#define HT_TREE_RHSUBTREE  0x00000005
#define HT_TREE_LHSUBTREE  0x00000006

typedef struct _NODE
{
  DWORD  hash;
  DWORD  bucket;
  LPVOID data;
  _NODE* parent;
  _NODE* rh_child;
  _NODE* lh_child;
  BOOL   isLeft;
}
NODE, *PNODE;

typedef VOID (*PFNCLEARFUNC)(LPVOID* ppv);

template <class T> class CHashTable
{
  public:
    CHashTable(DWORD buckets)
    {
      pfnClear  = NULL;
      cBuckets  = buckets;
      arBuckets = new PNODE[buckets];
      InitializeCriticalSection(&csTable);
    }

   ~CHashTable()
    {
      SAFEDELETEBUF(arBuckets);
      DeleteCriticalSection(&csTable);
    }

    virtual void GetHashAndBucket(T id, LPDWORD lpHash, LPDWORD lpBucket) =0;

    DWORD Insert(T id, LPVOID pv);
    DWORD Get(T id, LPVOID* ppv);
    DWORD Delete(T id, LPVOID* ppv);

    void  Clear(void);
    void  SetClearFunction(PFNCLEARFUNC pfn) { pfnClear = pfn; }

  private:
    void  _Get(DWORD hash, PNODE& proot, PNODE& pnode);
    DWORD _Insert(PNODE& proot, PNODE pnew);
    void  _Remove(DWORD hash, PNODE& proot, PNODE& pnode);

    PNODE _NewNode(T id, LPVOID pv);
    DWORD _CompareNodes(DWORD hash_target, DWORD hash_tree);

    BOOL  _HasChildren(PNODE pnode);
    void  _PostTraverseAndDelete(PNODE proot);
    void  _Lock(void)   { EnterCriticalSection(&csTable); }
    void  _Unlock(void) { LeaveCriticalSection(&csTable); }

    PNODE*       arBuckets;
    DWORD        cBuckets;
    CRITSEC      csTable;
    PFNCLEARFUNC pfnClear;
};

typedef class CHashTable<LPWSTR> WSZHASHTBL;

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

template <class T> DWORD CHashTable<T>::Insert(T id, LPVOID pv)
{
  DWORD ret = ERROR_SUCCESS;
  PNODE pn  = _NewNode(id, pv);

  _Lock();

    if( pn )
    {
      ret = _Insert(arBuckets[pn->bucket], pn);
    }
    else
    {
      ret = ERROR_OUTOFMEMORY;
    }

  _Unlock();

  return ret;
}

template <class T> DWORD CHashTable<T>::Get(T id, LPVOID* ppv)
{
  DWORD ret    = ERROR_SUCCESS;
  DWORD hash   = 0L;
  DWORD bucket = 0L;
  PNODE pnode  = NULL;

  GetHashAndBucket(id, &hash, &bucket);

  _Lock();

    _Get(hash, arBuckets[bucket], pnode);

    if( pnode )
    {
      *ppv = (void*) pnode->data;
    }
    else
    {
      *ppv = NULL;
      ret  = ERROR_NOT_FOUND;
    }

  _Unlock();

  return ret;
}

template <class T> DWORD CHashTable<T>::Delete(T id, LPVOID* ppv)
{
  DWORD ret   = ERROR_SUCCESS;
  DWORD hash   = 0L;
  DWORD bucket = 0L;
  PNODE pnode = NULL;

  GetHashAndBucket(id, &hash, &bucket);

  _Lock();

    _Remove(hash, arBuckets[bucket], pnode);

    if( pnode )
    {
      if( ppv )
      {
        *ppv = pnode->data;
      }
      else
      {
        if( pfnClear )
        {
          pfnClear(&pnode->data);
        }
      }

      delete pnode;
    }
    else
    {
      ret = ERROR_NOT_FOUND;

      if( ppv )
      {
        *ppv = NULL;
      }
    }

  _Unlock();

  return ret;
}

template <class T> void CHashTable<T>::Clear(void)
{
  _Lock();

    for(DWORD n=0; n < cBuckets; n++)
    {
      if( arBuckets[n] )
      {
        _PostTraverseAndDelete(arBuckets[n]);
        arBuckets[n] = NULL;
      }
    }

  _Unlock();
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

template <class T> DWORD CHashTable<T>::_Insert(PNODE& proot, PNODE pnew)
{
  DWORD ret = ERROR_SUCCESS;

  if( pnew )
  {
    if( !proot )
    {
      proot = pnew;
    }
    else
    {
      switch( _CompareNodes(pnew->hash, proot->hash) )
      {
        case HT_COMPARE_SMALLER :
          {
            pnew->isLeft = TRUE;
            pnew->parent = proot;
            ret = _Insert(proot->lh_child, pnew);
          }
          break;

        case HT_COMPARE_LARGER :
          {
            pnew->isLeft = FALSE;
            pnew->parent = proot;
            ret = _Insert(proot->rh_child, pnew);
          }
          break;

        case HT_COMPARE_EQUAL :
          {
            if( pfnClear )
            {
              pfnClear(&proot->data);
            }

            ret         = ERROR_DUP_NAME;
            proot->data = pnew->data;
            delete pnew;
          }
          break;
      }
    }
  }

  return ret;
}

template <class T> void CHashTable<T>::_Get(DWORD hash, PNODE& proot, PNODE& pnode)
{
  if( proot )
  {
    switch( _CompareNodes(hash, proot->hash) )
    {
      case HT_COMPARE_SMALLER :
        {
          _Get(hash, proot->lh_child, pnode);
        }
        break;

      case HT_COMPARE_LARGER :
        {
          _Get(hash, proot->rh_child, pnode);
        }
        break;

      case HT_COMPARE_EQUAL :
        {
          pnode = proot;
        }
        break;
    }
  }
  else
  {
    pnode = NULL;
  }
}

template <class T> void CHashTable<T>::_Remove(DWORD hash, PNODE& proot, PNODE& pnode)
{
  if( proot )
  {
    switch( _CompareNodes(hash, proot->hash) )
    {
      case HT_COMPARE_SMALLER :
        {
          _Remove(hash, proot->lh_child, pnode);
        }
        break;

      case HT_COMPARE_LARGER :
        {
          _Remove(hash, proot->rh_child, pnode);
        }
        break;

      case HT_COMPARE_EQUAL :
        {
          pnode = proot;

          //
          // if proot has no parent it is the tree's root node
          //
          //   - if it has children, promote the left child to root
          //     and insert the right child in the new tree. after
          //     inserting, make sure the new root has no parent.
          //
          //   - if it has no children the tree is empty, set the root
          //     to null
          //

          if( !proot->parent )
          {
            if( _HasChildren(proot) )
            {
              proot = proot->lh_child;
              _Insert(proot, pnode->rh_child);
              proot->parent = NULL;
            }
            else
            {
              proot = NULL;
            }
          }
          else
          {
            if( proot->isLeft )
            {
              proot->parent->lh_child = NULL;
            }
            else
            {
              proot->parent->rh_child = NULL;
            }

            _Insert(pnode->parent, pnode->lh_child);
            _Insert(pnode->parent, pnode->rh_child);
          }
        }
        break;
    }
  }
  else
  {
    pnode = NULL;
  }
}

template <class T> void CHashTable<T>::_PostTraverseAndDelete(PNODE proot)
{
  if( proot )
  {
    _PostTraverseAndDelete(proot->lh_child);
    _PostTraverseAndDelete(proot->rh_child);

    if( pfnClear )
    {
      pfnClear(&proot->data);
    }

    delete proot;
    proot = NULL;
  }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

template <class T> DWORD CHashTable<T>::_CompareNodes(DWORD hash_target, DWORD hash_tree)
{
  if( hash_target == hash_tree )
  {
    return HT_COMPARE_EQUAL;
  }
  else if( hash_target < hash_tree )
  {
    return HT_COMPARE_SMALLER;
  }
  else
  {
    return HT_COMPARE_LARGER;
  }
}

template <class T> PNODE CHashTable<T>::_NewNode(T id, LPVOID pv)
{
  PNODE pn = new NODE;

  if( pn )
  {
    GetHashAndBucket(id, &pn->hash, &pn->bucket);
    pn->data = pv;
  }

  return pn;
}

template <class T> BOOL CHashTable<T>::_HasChildren(PNODE pnode)
{
  if( pnode )
  {
    return (pnode->lh_child || pnode->rh_child);
  }
  else
  {
    return FALSE;
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\w3spoof\inc\debug.h ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    debug.h

Abstract:

    Debug logging routines for W3spoof project.
    
Author:

    Paul M Midgen (pmidge) 15-May-2000


Revision History:

    15-May-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#ifndef __DEBUG_H__
#define __DEBUG_H__

#include "common.h"

//
// always build this stuff.
//
#define CASE_OF(constant) case constant: return # constant
#define CASE_OF_MUTATE(val, name) case val: return # name
#define CASE_IID(riid, iid) if(IsEqualIID(riid, iid)) return # iid

LPSTR MapDispidToString(DISPID dispid);
LPSTR MapScriptDispidToString(SCRIPTDISPID sd);
LPSTR MapIOTYPEToString(IOTYPE iot);
LPSTR MapErrorToString(int error);
LPSTR MapTPOToString(DWORD option);
LPSTR MapHResultToString(HRESULT hr);
LPSTR MapStateToString(STATE st);
LPSTR MapStateToString(SERVERSTATE st);
LPSTR MapStateToString(SCRIPTSTATE st);
LPSTR MapIIDToString(REFIID riid);
LPSTR MapInvokeFlagsToString(WORD flags);
LPSTR MapVariantTypeToString(VARIANT* pvar);

int DebugDataDumpFormat(LPSTR buffer, LPBYTE data, DWORD len);

#ifdef _DEBUG

//
// manifests
//

#if defined(__DBG_TO_CONSOLE__)
#define OUTPUT_FLAGS DBG_TO_DEBUGGER
#else
#define OUTPUT_FLAGS DBG_TO_FILE
#endif

#if defined(__FULL_DEBUG__)
#define DEBUG_DEFAULT_FLAGS ( \
                             DBG_MEM          \
                           | DBG_REFCOUNT     \
                           | DBG_W3SOBJ       \
                           | DBG_FACTORY      \
                           | DBG_W3SUI        \
                           | DBG_APP          \
                           | DBG_RUNTIME      \
                           | DBG_WORKER       \
                           | DBG_SESSION      \
                           | DBG_SOCKET       \
                           | DBG_REQUEST      \
                           | DBG_RESPONSE     \
                           | DBG_URL          \
                           | DBG_ENTITY       \
                           | DBG_HEADERS      \
                           | DBG_UTILS        \
                           | DBG_THREAD_INFO  \
                           | DBG_CALL_INFO    \
                           | DBG_CALL_DEPTH   \
                           | DBG_TIMESTAMP    \
                           | DBG_NEST_CALLS   \
                           | OUTPUT_FLAGS)
#elif defined(__RELEASE_DEBUG__)
#define DEBUG_DEFAULT_FLAGS ( \
                             DBG_RUNTIME      \
                           | DBG_SESSION      \
                           | DBG_SOCKET       \
                           | DBG_REQUEST      \
                           | DBG_RESPONSE     \
                           | DBG_URL          \
                           | DBG_ENTITY       \
                           | DBG_HEADERS      \
                           | DBG_UTILS        \
                           | DBG_THREAD_INFO  \
                           | DBG_CALL_INFO    \
                           | DBG_CALL_DEPTH   \
                           | DBG_TIMESTAMP    \
                           | DBG_NEST_CALLS   \
                           | OUTPUT_FLAGS)
#else
#define DEBUG_DEFAULT_FLAGS ( \
                             DBG_MEM          \
                           | DBG_W3SOBJ       \
                           | DBG_RUNTIME      \
                           | DBG_WORKER       \
                           | DBG_SESSION      \
                           | DBG_SOCKET       \
                           | DBG_REQUEST      \
                           | DBG_RESPONSE     \
                           | DBG_URL          \
                           | DBG_ENTITY       \
                           | DBG_HEADERS      \
                           | DBG_UTILS        \
                           | DBG_THREAD_INFO  \
                           | DBG_CALL_INFO    \
                           | DBG_CALL_DEPTH   \
                           | DBG_TIMESTAMP    \
                           | DBG_NEST_CALLS   \
                           | OUTPUT_FLAGS)
#endif

// category flags
#define DBG_APP           0x00000001
#define DBG_WORKER        0x00000002
#define DBG_REGISTRY      0x00000004
#define DBG_MEM           0x00000008
#define DBG_W3SOBJ        0x00000010
#define DBG_REFCOUNT      0x00000020
#define DBG_FACTORY       0x00000040
#define DBG_W3SUI         0x00000080
#define DBG_SESSION       0x00000100
#define DBG_UTILS         0x00000200
#define DBG_SOCKET        0x00000400
#define DBG_REQUEST       0x00000800
#define DBG_RUNTIME       0x00001000
#define DBG_URL           0x00002000
#define DBG_ENTITY        0x00004000
#define DBG_HEADERS       0x00008000
#define DBG_RESPONSE      0x00010000
#define DBG_DISPATCH      0x00020000

// control flags
#define DBG_THROWDBGALERT 0x00800000
#define DBG_THREAD_INFO   0x01000000
#define DBG_CALL_DEPTH    0x02000000 // remove
#define DBG_TIMESTAMP     0x04000000
#define DBG_NEST_CALLS    0x08000000
#define DBG_TO_FILE       0x10000000
#define DBG_TO_DEBUGGER   0x20000000
#define DBG_CALL_INFO     0x40000000
#define DBG_NO_DEBUG      0x80000000

//
// types
//

typedef struct _memusage
{
  CRITICAL_SECTION lock;
  DWORD            total;
  MEMORYSTATUS     status;
}
MEMUSAGE, *PMEMUSAGE;

typedef enum _rettype
{
  rt_void,
  rt_bool,
  rt_dword,
  rt_hresult,
  rt_string
}
RETTYPE, *LPRETTYPE;

typedef struct _callinfo
{
  struct _callinfo* next;
  struct _callinfo* last;
  DWORD             category;
  LPCSTR            fname;
  RETTYPE           rettype;
}
CALLINFO, *LPCALLINFO;

typedef struct _threadinfo
{
  DWORD      threadid;
  DWORD      threadcat;
  DWORD      depth;
  LPCALLINFO stack;
}
THREADINFO, *LPTHREADINFO;

//
// prototypes
//

void DebugInitialize(void);
void DebugTerminate(void);

void DebugMemInitialize(void);
void DebugMemTerminate(void);
void DebugMemAlloc(void* pv);
void DebugMemFree(void* pv);

void DebugEnter(int category, RETTYPE rt, LPCSTR function, const char* format, ...);
void DebugLeave(int retval);
void DebugTrace(const char* format, ...);
void DebugAssert(LPSTR condition, LPSTR file, int line);

void DebugDataDump(LPSTR title, LPBYTE data, DWORD len);

void DebugThrowDbgAlert(void);

void AcquireDebugFileLock(void);
void ReleaseDebugFileLock(void);

LPTHREADINFO GetThreadInfo(void);

LPCALLINFO   SetCallInfo(LPTHREADINFO pti, DWORD category, RETTYPE rt, LPCSTR function);
LPCALLINFO   GetCallInfo(LPTHREADINFO pti);
void         DeleteCallInfo(LPCALLINFO pci);

LPSTR        FormatCallReturnString(LPCALLINFO pci, int retval);
LPSTR        MapCategoryToString(int category);
LPSTR        MapCompKeyToString(int key);

void  _debugout(LPTHREADINFO pti, BOOL fRaw, BOOL fTrace, const char* format, ...);
char* _gettimestamp(void);
char* _getwhitespace(int spaces);
BOOL  _opendebugfile(void);
void  _closedebugfile(void);

//
// macros
//
#define DEBUG_INITIALIZE() DebugInitialize()
#define DEBUG_TERMINATE()  DebugTerminate()

#define DEBUG_ENTER(parameters) \
              DebugEnter parameters

#define DEBUG_LEAVE(retval) \
              DebugLeave(retval)

#define DEBUG_ALLOC(block) \
              DebugMemAlloc(block)

#define DEBUG_FREE(block) \
              DebugMemFree(block)

extern DWORD g_dwDebugFlags;

#define DEBUG_TRACE(category, parameters) \
              if( DBG_##category & g_dwDebugFlags ) \
                DebugTrace parameters

#define DEBUG_DATA_DUMP(category, parameters) \
              if(DBG_##category & g_dwDebugFlags ) \
                DebugDataDump parameters

#define DEBUG_ADDREF(objname, refcount) \
              if( DBG_REFCOUNT & g_dwDebugFlags ) \
                DebugTrace("%s [%#x] addref: %d", objname, this, refcount)

#define DEBUG_RELEASE(objname, refcount) \
              if( DBG_REFCOUNT & g_dwDebugFlags ) \
                DebugTrace("%s [%#x] release: %d", objname, this, refcount)

#define DEBUG_FINALRELEASE(objname) \
              if( DBG_REFCOUNT & g_dwDebugFlags ) \
                DebugTrace("%s [%#x] final release!", objname, this)

#define DEBUG_DUMPWSOCKSTATS(wsd) \
              if( DBG_APP & g_dwDebugFlags ) \
                DebugTrace(\
                  "%s (v%d.%d in use) is %s",\
                  wsd.szDescription,\
                  (wsd.wVersion & 0x00FF),\
                  ((wsd.wVersion & 0xFF00) >> 8),\
                  wsd.szSystemStatus)


#define DEBUG_ASSERT(condition) \
          if( !(condition) ) \
            DebugAssert(#condition, __FILE__, __LINE__)

#else

// we will get rebuked for the bogus 
// arglists in the debug macros
#pragma warning( disable : 4002 )
#pragma warning( disable : 4003 )

#define DEBUG_ASSERT(x, y, z)
#define DEBUG_INITIALIZE()
#define DEBUG_TERMINATE()
#define DEBUG_ALLOC(x)
#define DEBUG_FREE(x)
#define DEBUG_ENTER(x)
#define DEBUG_LEAVE(x)
#define DEBUG_TRACE(x)
#define DEBUG_ADDREF(x)
#define DEBUG_RELEASE(x)
#define DEBUG_FINALRELEASE(x)
#define DEBUG_DUMPWSOCKSTATS(x)
#define DEBUG_DATA_DUMP(X)

#endif /* _DEBUG */
#endif /* __DEBUG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\w3spoof\inc\int_ifaces.h ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    int_ifaces.h

Abstract:

    Non-MIDL generated interface declarations for internal COM interfaces.
    
Author:

    Paul M Midgen (pmidge) 28-August-2000

Revision History:

    28-August-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
#ifndef __INT_IFACES_H__
#define __INT_IFACES_H__

#ifdef __cplusplus
extern "C" {
#endif

extern const IID IID_IConfig;
extern const IID IID_IW3Spoof;
extern const IID IID_IThreadPool;
extern const IID IID_IW3SpoofEvents;

interface IConfig : public IUnknown
{
  virtual HRESULT __stdcall SetOption(DWORD dwOption, LPDWORD lpdwValue)          PURE;
  virtual HRESULT __stdcall GetOption(DWORD dwOption, LPDWORD lpdwValue)          PURE;
};

interface IW3Spoof : public IConfig
{
  virtual HRESULT __stdcall GetRuntime(IW3SpoofRuntime** pprt)                    PURE;
  virtual HRESULT __stdcall GetTypeLibrary(ITypeLib** pptl)                       PURE;
  virtual HRESULT __stdcall GetScriptEngine(IActiveScript** ppas)                 PURE;
  virtual HRESULT __stdcall GetScriptPath(LPWSTR client, LPWSTR* path)            PURE;
  virtual HRESULT __stdcall Notify(LPWSTR clientid, PSESSIONOBJ pso, STATE state) PURE;
  virtual HRESULT __stdcall WaitForUnload(void)                                   PURE;
  virtual HRESULT __stdcall Terminate(void)                                       PURE;
};

interface IThreadPool : public IUnknown
{
  virtual HRESULT __stdcall GetStatus(PIOCTX* ppioc, LPBOOL pbQuit)               PURE;
  virtual HRESULT __stdcall GetSession(LPWSTR clientid, PSESSIONOBJ* ppso)        PURE;
  virtual HRESULT __stdcall Register(SOCKET s)                                    PURE;
};

interface IW3SpoofEvents : public IUnknown
{
  virtual HRESULT __stdcall OnSessionOpen(LPWSTR clientid)                        PURE;
  virtual HRESULT __stdcall OnSessionStateChange(LPWSTR clientid, STATE state)    PURE;
  virtual HRESULT __stdcall OnSessionClose(LPWSTR clientid)                       PURE;
};

#ifdef __cplusplus
}
#endif

#endif /* __INT_IFACES_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\w3spoof\inc\linklist.h ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    linklist.h

Abstract:

    Linked list template class.


Author:

    Paul M Midgen (pmidge) 14-November-2000


Revision History:

    14-November-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include <common.h>

typedef struct _ITEM
{
  LPVOID        value;
  struct _ITEM* next;
}
ITEM, *PITEM;

typedef struct _LINK
{
  DWORD         hash;
  PITEM         item;
  DWORD         items;
  struct _LINK* next;
}
LINK, *PLINK;

typedef VOID (*PFNCLEARFUNC)(LPVOID* ppv);

template <class T, class V> class CLinkedList
{
  public:
    CLinkedList()
    {
      m_pfnClear = NULL;
      m_List     = NULL;
      m_cList    = 0L;
      InitializeCriticalSection(&m_csList);
    }

   ~CLinkedList()
    {
      DeleteCriticalSection(&m_csList);
    }

    HRESULT Insert(T id, V value);
    HRESULT Get(T id, V* pvalue);
    HRESULT Delete(T id);
    HRESULT Collection(T id, V* collection, LPDWORD items);
    void    Clear(void);

    void SetClearFunction(PFNCLEARFUNC pfn) { m_pfnClear = pfn; }

    virtual void GetHash(T id, LPDWORD lpHash) =0;

  private:
    void _NewLink(T id, V value, PLINK* pplink);
    void _NewItem(LPVOID pv, PITEM* ppitem);
    void _InsertItem(PITEM proot, PITEM item);
    void _DeleteItems(PITEM proot);
    void _DeleteList(PLINK proot);
    void _Lock(void)   { EnterCriticalSection(&m_csList); }
    void _Unlock(void) { LeaveCriticalSection(&m_csList); }

    PLINK        m_List;
    DWORD        m_cList;
    CRITSEC      m_csList;
    PFNCLEARFUNC m_pfnClear;
};

typedef class CLinkedList<LPSTR, BSTR> HTTPHEADERLIST;

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

template <class T, class V> HRESULT CLinkedList<T, V>::Insert(T id, V value)
{
  HRESULT hr        = S_OK;
  BOOL    bContinue = TRUE;
  PLINK   link      = m_List;
  PLINK   insert    = NULL;

  _NewLink(id, value, &insert);

  if( !insert )
  {
    hr = E_OUTOFMEMORY;
    goto quit;
  }

  _Lock();

    if( link )
    {
      while( bContinue )
      {
        if( link->hash == insert->hash )
        {
          _InsertItem(link->item, insert->item);

          link->items += 1;
          bContinue    = FALSE;

          delete insert;
        }
        else
        {
          if( link->next )
          {
            link = link->next;
          }
          else
          {
            link->next  = insert;
            m_cList    += 1;
            bContinue   = FALSE;
          }
        }
      }
    }
    else
    {
      m_List   = insert;
      m_cList += 1; 
    }

  _Unlock();

quit:

  return hr;
}

template <class T, class V> HRESULT CLinkedList<T, V>::Get(T id, V* pvalue)
{
  HRESULT hr     = S_OK;
  BOOL    bFound = FALSE;
  DWORD   hash   = 0L;
  PLINK   link   = m_List;

  GetHash(id, &hash);

  if( !pvalue )
  {
    hr = E_POINTER;
    goto quit;
  }

  _Lock();

    while( !bFound && link )
    {
      if( link->hash == hash )
      {
        *pvalue = (V) link->item->value;
        bFound  = TRUE;
      }
      else
      {
        link = link->next;
      }
    }

    if( !bFound )
    {
      *pvalue = NULL;
      hr      = E_FAIL;
    }

  _Unlock();

quit:

  return hr;
}

template <class T, class V> HRESULT CLinkedList<T, V>::Delete(T id)
{
  HRESULT hr        = S_OK;
  BOOL    bContinue = TRUE;
  DWORD   hash      = 0L;
  PLINK   link      = m_List;
  PLINK   last      = m_List;

  GetHash(id, &hash);

  _Lock();

    while( bContinue && link )
    {
      if( link->hash == hash )
      {
        _DeleteItems(link->item);

        m_List      = (m_List == link) ? m_List->next : m_List;
        m_cList    -= 1;   
        last->next  = link->next;
        bContinue   = FALSE;

        delete link;
      }
      else
      {
        last = link;
        link = link->next;
      }
    }

    if( bContinue )
    {
      hr = E_FAIL;
    }

  _Unlock();

  return hr;
}

template <class T, class V> HRESULT CLinkedList<T, V>::Collection(T id, V* collection, LPDWORD items)
{
  //
  // TODO: implementation
  //

  return S_OK;
}

template <class T, class V> void CLinkedList<T, V>::Clear(void)
{
  _Lock();

    _DeleteList(m_List);
    m_List  = NULL;
    m_cList = 0L;

  _Unlock();
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

template <class T, class V> void CLinkedList<T, V>::_NewLink(T id, V value, PLINK* pplink)
{
  PLINK plink = new LINK;

  GetHash(id, &plink->hash);
  _NewItem((void*) value, &plink->item);

  plink->items = 1;
  plink->next  = NULL;

  *pplink = plink;
}

template <class T, class V> void CLinkedList<T, V>::_NewItem(LPVOID pv, PITEM* ppitem)
{
  PITEM pitem = new ITEM;

  pitem->value = pv;
  pitem->next  = NULL;

  *ppitem = pitem;
}

template <class T, class V> void CLinkedList<T, V>::_InsertItem(PITEM proot, PITEM item)
{
  while( proot->next )
    proot = proot->next;

  proot->next = item;
}

template <class T, class V> void CLinkedList<T, V>::_DeleteItems(PITEM proot)
{
  if( proot )
  {
    if( m_pfnClear )
    {
      m_pfnClear((void**) &proot->value);
    }

    _DeleteItems(proot->next);
    delete proot;
  }
}

template <class T, class V> void CLinkedList<T, V>::_DeleteList(PLINK proot)
{
  if( proot )
  {
    _DeleteList(proot->next);
    _DeleteItems(proot->item);
    delete proot;
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\w3spoof\inc\mem.h ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 1999  Microsoft Corporation

Module Name:

    mem.h

Abstract:

    Internal memory allocation/deallocation routines.
    
Author:

    Paul M Midgen (pmidge) 01-June-2000


Revision History:

    01-June-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#ifndef __MEM_H__
#define __MEM_H__

#include "common.h"

void  _InitMem(void);

void* __cdecl operator new(size_t size);
void  __cdecl operator delete(void* pv);

#endif /* __MEM_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\w3spoof\inc\registry.h ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    registry.h

Abstract:

    Registry functions
    
Author:

    Paul M Midgen (pmidge) 23-May-2000


Revision History:

    23-May-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#ifndef _REGISTRY_H_
#define _REGISTRY_H_

#include "common.h"

HKEY _GetRootKey(BOOL fOpen);

BOOL SetRegValue(LPCWSTR wszValueName, DWORD dwType, LPVOID pvData, DWORD dwSize);
BOOL GetRegValue(LPCWSTR wszValueName, DWORD dwType, LPVOID* ppvData);

#endif /* _REGISTRY_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\w3spoof\inc\om.h ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 1999  Microsoft Corporation

Module Name:

    om.h

Abstract:

    Object declarations for object model components.
    
Author:

    Paul M Midgen (pmidge) 13-October-2000


Revision History:

    13-October-2000 pmidge
        Created on Friday the 13th!!

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#ifndef __OM_H__
#define __OM_H__

#include "common.h"

class CSession : public ISession,
                 public IProvideClassInfo,
                 public IActiveScriptSite
{
  public:
    DECLAREIUNKNOWN();
    DECLAREIDISPATCH();
    DECLAREIPROVIDECLASSINFO();

  public:
    // ISession
    HRESULT __stdcall get_Socket(IDispatch** ppdisp);
    HRESULT __stdcall get_Request(IDispatch** ppdisp);
    HRESULT __stdcall get_Response(IDispatch** ppdisp);
    HRESULT __stdcall get_KeepAlive(VARIANT* IsKA);
    HRESULT __stdcall GetPropertyBag(VARIANT Name, IDispatch** ppdisp);

    // IActiveScriptSite
    HRESULT __stdcall GetLCID(LCID* plcid);

    HRESULT __stdcall GetItemInfo(
                        LPCOLESTR pstrName,
                        DWORD dwReturnMask,
                        IUnknown** ppunk,
                        ITypeInfo** ppti
                        );

    HRESULT __stdcall GetDocVersionString(BSTR* pbstrVersion);
    HRESULT __stdcall OnScriptTerminate(const VARIANT* pvarResult, const EXCEPINFO* pei);
    HRESULT __stdcall OnStateChange(SCRIPTSTATE ss);
    HRESULT __stdcall OnScriptError(IActiveScriptError* piase);
    HRESULT __stdcall OnEnterScript(void);
    HRESULT __stdcall OnLeaveScript(void);

    // CSession
    CSession();
   ~CSession();

    HRESULT Run(PIOCTX pioc);
    HRESULT Terminate(void);

    static HRESULT Create(PIOCTX pioc, IW3Spoof* pw3s);

  private:
    HRESULT          _Initialize(PIOCTX pioc, IW3Spoof* pw3s);
    HRESULT          _InitScriptEngine(void);
    HRESULT          _LoadScript(void);
    HRESULT          _SetScriptSite(BOOL bClone);
    HRESULT          _ResetScriptEngine(void);
    HRESULT          _LoadScriptDispids(void);
    HRESULT          _InitSocketObject(PIOCTX pioc);
    HRESULT          _InitRequestObject(void);
    void             _SetKeepAlive(PIOCTX pioc);
    void             _SetObjectState(STATE state);
    BOOL             _SetNextServerState(SERVERSTATE state);
    void             _Lock(void);
    void             _Unlock(void);

    LONG             m_cRefs;
    LPWSTR           m_wszClient;
    LPWSTR           m_wszClientId;
    BOOL             m_bIsKeepAlive;
    SCRIPTDISPID     m_CurrentHandler;
    LCID             m_lcid;
    PSOCKETOBJ       m_socketobj;
    PREQUESTOBJ      m_requestobj;
    PRESPONSEOBJ     m_responseobj;
    ITypeLib*        m_ptl;
    IW3Spoof*        m_pw3s;
    IActiveScript*   m_pas;
    IDispatch*       m_psd;
    DISPID           m_arHandlerDispids[SCRIPTHANDLERS];
    CRITSEC          m_lock;
    STATE            m_objstate;
};


class CSocket : public ISocket,
                public IProvideClassInfo,
                public IObjectWithSite
{
  public:
    DECLAREIUNKNOWN();
    DECLAREIDISPATCH();
    DECLAREIPROVIDECLASSINFO();
    DECLAREIOBJECTWITHSITE();

  public:
    // ISocket
    HRESULT __stdcall Send(VARIANT Data);
    HRESULT __stdcall Recv(VARIANT *Data);
    HRESULT __stdcall Close(VARIANT Method);
    HRESULT __stdcall Resolve(BSTR Host, BSTR *Address);

    HRESULT __stdcall get_Parent(IDispatch** ppdisp);
    HRESULT __stdcall get_LocalName(BSTR *Name);
    HRESULT __stdcall get_LocalAddress(BSTR *Address);
    HRESULT __stdcall get_LocalPort(VARIANT *Port);
    HRESULT __stdcall get_RemoteName(BSTR *Name);
    HRESULT __stdcall get_RemoteAddress(BSTR *Address);
    HRESULT __stdcall get_RemotePort(VARIANT *Port);

    HRESULT __stdcall get_Option(BSTR Option, VARIANT *Value);
    HRESULT __stdcall put_Option(BSTR Option, VARIANT Value);

    // CSocket
    CSocket();
   ~CSocket();

    HRESULT     Run(PIOCTX pioc);
    HRESULT     Terminate(void);
    SERVERSTATE GetServerState(void);
    void        SetServerState(SERVERSTATE ss);

    static HRESULT Create(PIOCTX pioc, PSOCKETOBJ* ppsocketobj);

    friend class CSession;

  protected:
    void        GetSendBuffer(WSABUF** ppwb);
    void        GetRecvBuffer(WSABUF** ppwb);
    DWORD       GetBytesSent(void);
    DWORD       GetBytesReceived(void);

  private:
    HRESULT     _Initialize(PIOCTX pioc);
    void        _SetObjectState(STATE state);
    BOOL        _ResizeBuffer(PIOCTX pioc, DWORD len);
    HRESULT     _Send(PIOCTX pioc);
    HRESULT     _Recv(PIOCTX pioc);
    BOOL        _Flush(void);
    HRESULT     _TestWinsockError(void);

    LONG        m_cRefs;
    SOCKET      m_socket;
    PHOSTINFO   m_local;
    PHOSTINFO   m_remote;
    PIOCTX      m_rcvd;
    PIOCTX      m_sent;
    IUnknown*   m_pSite;
    LPWSTR      m_wszClientId;
    SERVERSTATE m_serverstate;
    STATE       m_objstate;
};


class CRequest : public IRequest,
                 public IProvideClassInfo,
                 public IObjectWithSite
{
  public:
    DECLAREIUNKNOWN();
    DECLAREIDISPATCH();
    DECLAREIPROVIDECLASSINFO();
    DECLAREIOBJECTWITHSITE();

  public:
    // IRequest
    HRESULT __stdcall get_Parent(IDispatch **ppdisp);
    HRESULT __stdcall get_Headers(IDispatch **ppdisp);
    HRESULT __stdcall get_Entity(IDispatch **ppdisp);
    HRESULT __stdcall get_Url(IDispatch **ppdisp);
    HRESULT __stdcall get_Verb(BSTR *Verb);
    HRESULT __stdcall get_HttpVersion(BSTR *HttpVersion);

    // CRequest
    CRequest();
   ~CRequest();

    void Terminate(void);

    static HRESULT Create(CHAR* request, DWORD len, PREQUESTOBJ* ppreq);

  private:
    HRESULT     _Initialize(CHAR* request, DWORD len);
    void        _Cleanup(void);
    HRESULT     _SiteMemberObjects(void);
    BOOL        _CrackRequest(LPSTR request, DWORD len, LPSTR* reqline, LPSTR* headers, LPSTR* entity, LPDWORD contentlength);
    LPSTR*      _CrackRequestLine(CHAR* buf, DWORD len);

    LONG        m_cRefs;
    IUnknown*   m_pSite;
    LPWSTR      m_wszVerb;
    LPWSTR      m_wszHTTPVersion;
    PURLOBJ     m_urlobj;
    PHEADERSOBJ m_headersobj;
    PENTITYOBJ  m_entityobj;
};


class CResponse : public IResponse,
                  public IProvideClassInfo,
                  public IObjectWithSite
{
  public:
    DECLAREIUNKNOWN();
    DECLAREIDISPATCH();
    DECLAREIPROVIDECLASSINFO();
    DECLAREIOBJECTWITHSITE();

  public:
    // IResponse
    HRESULT __stdcall get_Parent(IDispatch **ppdisp);
    HRESULT __stdcall get_Headers(IDispatch **ppdisp);
    HRESULT __stdcall putref_Headers(IDispatch **ppdisp);
    HRESULT __stdcall get_Entity(IDispatch **ppdisp);
    HRESULT __stdcall putref_Entity(IDispatch **ppdisp);
    HRESULT __stdcall get_StatusCode(VARIANT *Code);
    HRESULT __stdcall put_StatusCode(VARIANT StatusCode);
    HRESULT __stdcall get_StatusText(BSTR *StatusText);
    HRESULT __stdcall put_StatusText(BSTR StatusText);
    
    // CResponse
    CResponse();
   ~CResponse();

    HRESULT Terminate(void);

    static HRESULT Create(CHAR* response, DWORD len, PRESPONSEOBJ* ppresponse);

  private:
    HRESULT     _Initialize(CHAR* response, DWORD len);

    LONG        m_cRefs;
    IUnknown*   m_pSite;
    PHEADERSOBJ m_headersobj;
    PENTITYOBJ  m_entityobj;
};


class CUrl : public IUrl,
             public IProvideClassInfo,
             public IObjectWithSite
{
  public:
    DECLAREIUNKNOWN();
    DECLAREIDISPATCH();
    DECLAREIPROVIDECLASSINFO();
    DECLAREIOBJECTWITHSITE();

  public:
    // IUrl
    HRESULT __stdcall get_Parent(IDispatch **ppdisp);
    HRESULT __stdcall get_Encoding(BSTR *Encoding);    
    HRESULT __stdcall get_Scheme(BSTR *Scheme);
    HRESULT __stdcall put_Scheme(BSTR Scheme);    
    HRESULT __stdcall get_Server(BSTR *Server);    
    HRESULT __stdcall put_Server(BSTR Server);    
    HRESULT __stdcall get_Port(VARIANT *Port);    
    HRESULT __stdcall put_Port(VARIANT Port);    
    HRESULT __stdcall get_Path(BSTR *Path);    
    HRESULT __stdcall put_Path(BSTR Path);    
    HRESULT __stdcall get_Resource(BSTR *Resource);    
    HRESULT __stdcall put_Resource(BSTR Resource);    
    HRESULT __stdcall get_Query(BSTR *Query);    
    HRESULT __stdcall put_Query(BSTR Query);    
    HRESULT __stdcall get_Fragment(BSTR *Fragment);    
    HRESULT __stdcall put_Fragment(BSTR Fragment);    
    HRESULT __stdcall Escape(BSTR *Url);    
    HRESULT __stdcall Unescape(BSTR *Url);    
    HRESULT __stdcall Set(BSTR Url);
    HRESULT __stdcall Get(BSTR *Url);

    // CUrl
    CUrl();
   ~CUrl();

    static HRESULT Create(CHAR* url, BOOL bReadOnly, PURLOBJ* ppurl);

    void Terminate(void);

  private:
    HRESULT    _Initialize(CHAR* url, BOOL bReadOnly);
    void       _Cleanup(void);

    LONG       m_cRefs;
    IUnknown*  m_pSite;
    ITypeInfo* m_pti;
    BOOL       m_bReadOnly;
    BOOL       m_bEscaped;
    LPSTR      m_szOriginalUrl;
    LPSTR      m_szUnescapedUrl;
    LPWSTR     m_wszUrl;
    LPWSTR     m_wszScheme;
    USHORT     m_usPort;
    LPWSTR     m_wszServer;
    LPWSTR     m_wszPath;
    LPWSTR     m_wszResource;
    LPWSTR     m_wszQuery;
    LPWSTR     m_wszFragment;
};


class CHeaders : public IHeaders,
                 public IProvideClassInfo,
                 public IObjectWithSite
{
  public:
    DECLAREIUNKNOWN();
    DECLAREIDISPATCH();
    DECLAREIPROVIDECLASSINFO();
    DECLAREIOBJECTWITHSITE();

  public:
    // IHeaders
    HRESULT __stdcall get_Parent(IDispatch **ppdisp);
    HRESULT __stdcall Get(BSTR *Headers);
    HRESULT __stdcall Set(VARIANT *Headers);
    HRESULT __stdcall GetHeader(BSTR Header, VARIANT *Value);
    HRESULT __stdcall SetHeader(BSTR Header, VARIANT *Value);

    // CHeaders
    CHeaders();
   ~CHeaders();

    static HRESULT Create(CHAR* headers, BOOL bReadOnly, PHEADERSOBJ* ppheaders);

    void Terminate(void);

  private:
    HRESULT     _Initialize(CHAR* headers, BOOL bReadOnly);
    HRESULT     _ParseHeaders(CHAR* headers);
    void        _Cleanup(void);

    LONG        m_cRefs;
    IUnknown*   m_pSite;
    ITypeInfo*  m_pti;
    BOOL        m_bReadOnly;
    CHAR*       m_pchHeaders;
    PHEADERLIST m_headerlist;
}; 


class CEntity : public IEntity,
                public IProvideClassInfo,
                public IObjectWithSite
{
  public:
    DECLAREIUNKNOWN();
    DECLAREIDISPATCH();
    DECLAREIPROVIDECLASSINFO();
    DECLAREIOBJECTWITHSITE();

  public:
    // IEntity
    HRESULT __stdcall get_Parent(IDispatch **ppdisp);
    HRESULT __stdcall get_Length(VARIANT *Length);
    HRESULT __stdcall Get(VARIANT *Entity);
    HRESULT __stdcall Set(VARIANT Entity);
    HRESULT __stdcall Compress(BSTR Method);
    HRESULT __stdcall Decompress(VARIANT Method);

    // CEntity
    CEntity();
   ~CEntity();

    static HRESULT Create(LPBYTE data, DWORD length, BOOL bReadOnly, PENTITYOBJ* ppentity);

    void Terminate(void);

  private:
    HRESULT    _Initialize(LPBYTE data, DWORD length, BOOL bReadOnly);
    void       _Cleanup(void);

    LONG       m_cRefs;
    IUnknown*  m_pSite;
    ITypeInfo* m_pti;    
    BOOL       m_bReadOnly;
    LPBYTE     m_pbData;
    DWORD      m_cData;
};

#endif /* __OM_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\w3spoof\inc\stores.h ===
#include "common.h"

typedef class CStringMap  STRINGMAP;
typedef class CStringMap* PSTRINGMAP;
typedef class CHeaderList  HEADERLIST;
typedef class CHeaderList* PHEADERLIST;

VOID VariantKiller(LPVOID* ppv);
VOID PropertyBagKiller(LPVOID* ppv);
VOID BSTRKiller(LPVOID* ppv);

class CStringMap : public WSZHASHTBL
{
  public:
    CStringMap() : WSZHASHTBL(100) {}
   ~CStringMap() {}

    void GetHashAndBucket(LPWSTR id, LPDWORD lpHash, LPDWORD lpBucket);
};


class CHeaderList : public HTTPHEADERLIST
{
  public:
    CHeaderList() {}
   ~CHeaderList() {}

    void GetHash(LPSTR id, LPDWORD lpHash);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\w3spoof\inc\resources.h ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    resources.h

Abstract:

    Defines and other global manifests used in the W3Spoof project.
    
Author:

    Paul M Midgen (pmidge) 13-August-2000


Revision History:

    13-August-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#ifndef __RESOURCES_H__
#define __RESOURCES_H__

#define SHELLMESSAGE_W3SICON (WM_USER+12387)

#define INITIAL_DATA_BUFFER_SIZE 4096

#define SOCKET_CLOSE_ABORTIVE    0
#define SOCKET_CLOSE_GRACEFUL    1

#define CK_INVALID_KEY           0xFFFFFFFF
#define CK_NEW_CONNECTION        0x00000000
#define CK_NORMAL                0x00000001
#define CK_CANCEL_IO             0x00000002
#define CK_TERMINATE_THREAD      0x00000003

#define TPO_MAX_POOL_THREADS     0x00000001
#define TPO_MAX_ACTIVE_THREADS   0x00000002
#define TPO_SERVER_LISTEN_PORT   0x00000003
#define TPO_CONDITIONAL_ACCEPT   0x00000004

#define ERROR_FAILURE            0xFFFFF666

typedef DWORD (WINAPI *THREADFUNC)(LPVOID lpv);

#define DECLAREIUNKNOWN() \
    HRESULT __stdcall QueryInterface(REFIID riid, void** ppv); \
    ULONG   __stdcall AddRef(void); \
    ULONG   __stdcall Release(void); 

#define DECLAREIDISPATCH() \
    HRESULT __stdcall GetTypeInfoCount(UINT* pctinfo);  \
    HRESULT __stdcall GetTypeInfo(UINT index, LCID lcid, ITypeInfo** ppti); \
    HRESULT __stdcall GetIDsOfNames(REFIID riid, LPOLESTR* arNames, UINT cNames, LCID lcid, DISPID* arDispId); \
    HRESULT __stdcall Invoke(DISPID dispid, REFIID riid, LCID lcid, WORD flags, DISPPARAMS* pdp, VARIANT* pvr, EXCEPINFO* pei, UINT* pae);

#define DECLAREIPROVIDECLASSINFO() \
  HRESULT __stdcall GetClassInfo(ITypeInfo** ppti);

#define DECLAREIOBJECTWITHSITE() \
    HRESULT __stdcall SetSite(IUnknown* pUnkSite); \
    HRESULT __stdcall GetSite(REFIID riid, void** ppvSite);

#define SAFECLOSE(x) if((x!=INVALID_HANDLE_VALUE) && (x!=NULL)) { CloseHandle(x); x=NULL; }
#define SAFECLOSESOCKET(x) if(x!=INVALID_SOCKET) { closesocket(x); x=INVALID_SOCKET; }
#define SAFEDELETE(x) if(x) { delete x; x=NULL; }
#define SAFEDELETEBUF(x) if(DWORD(x)) {delete [] x; x=NULL;}
#define SAFERELEASE(x) if(x) { x->Release(); x=NULL; }
#define SAFETERMINATE(x) if(x) { x->Terminate(); }
#define SAFEDELETEBSTR(x) if(x) { SysFreeString(x); x=NULL; }
#define VALIDSOCKET(x) ((x!=INVALID_SOCKET) ? TRUE : FALSE)
#define VALIDDISPID(x) ((x!=DISPID_UNKNOWN) ? TRUE : FALSE)
#define SOCKADDRBUFSIZE (sizeof(SOCKADDR_IN)+16)
#define NEWVARIANT(x) VARIANT x; VariantInit(&x);
#define GETIOCTX(x) (x ? ((PIOCTX)((DWORD_PTR)x - sizeof(DWORD_PTR))) : NULL)

//
// forward decls
//

class CW3Spoof;

//
// typedefs
//

typedef class IOCTX*                 PIOCTX;
typedef class CSession               SESSIONOBJ;
typedef class CSession*              PSESSIONOBJ;
typedef class CSocket                SOCKETOBJ;
typedef class CSocket*               PSOCKETOBJ;
typedef class CRequest               REQUESTOBJ;
typedef class CRequest*              PREQUESTOBJ;
typedef class CResponse              RESPONSEOBJ;
typedef class CResponse*             PRESPONSEOBJ;
typedef class CUrl                   URLOBJ;
typedef class CUrl*                  PURLOBJ;
typedef class CHeaders               HEADERSOBJ;
typedef class CHeaders*              PHEADERSOBJ;
typedef class CEntity                ENTITYOBJ;
typedef class CEntity*               PENTITYOBJ;
typedef struct sockaddr_in           SOCKADDR_IN;
typedef struct sockaddr_in*          PSOCKADDR_IN;
typedef CRITICAL_SECTION             CRITSEC;
typedef LPCRITICAL_SECTION           PCRITSEC;
typedef BY_HANDLE_FILE_INFORMATION   BHFI;
typedef LPBY_HANDLE_FILE_INFORMATION LPBHFI;
typedef URL_COMPONENTSW              URLCOMP;
typedef LPURL_COMPONENTSW            PURLCOMP;

typedef struct _HOSTINFO
{
  char*   name;
  char*   addr;
  u_short port;
}
HOSTINFO, *PHOSTINFO;

typedef enum _state
{
  ST_CREATED,
  ST_OPENING,
  ST_OPEN,
  ST_CLOSING,
  ST_CLOSED,
  ST_ERROR
}
STATE, *PSTATE;

typedef enum _serverstate
{
  SS_START_STATE      = 0,
  SS_SOCKET_CONNECTED,
  SS_REQUEST_PENDING,
  SS_REQUEST_COMPLETE,
  SS_RESPONSE_PENDING,
  SS_RESPONSE_COMPLETE,
  SS_SOCKET_DISCONNECTED
}
SERVERSTATE, *PSERVERSTATE;

#define SCRIPTHANDLERS 5

typedef enum _tagScriptDispid
{
  Global    = -1,
  OnConnect = 0,
  OnDataAvailable,
  OnRequest,
  OnResponse,
  OnClose
}
SCRIPTDISPID, *PSCRIPTDISPID;

typedef enum _tagIOTYPE
{
  IOCT_CONNECT = 0,
  IOCT_RECV,
  IOCT_SEND,
  IOCT_DUMMY
}
IOTYPE, *PIOTYPE;

typedef struct _dispidtableentry
{
  DWORD  hash;
  DISPID dispid;
  LPWSTR name;
}
DISPIDTABLEENTRY, *PDISPIDTABLEENTRY;

#endif /* __RESOURCES_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\w3spoof\inc\utils.h ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 1999  Microsoft Corporation

Module Name:

    utils.h

Abstract:

    Utility functions.
    
Author:

    Paul M Midgen (pmidge) 12-January-2001


Revision History:

    12-January-2001 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#ifndef _UTILS_H_
#define _UTILS_H_

// file retrieval
BOOL             GetFile(LPCWSTR path, HANDLE* phUNC, IWinHttpRequest** ppWHR, DWORD mode, BOOL* bReadOnly);
BOOL             __PathIsUNC(LPCWSTR path);
BOOL             __PathIsURL(LPCWSTR path);
IWinHttpRequest* __OpenUrl(LPCWSTR url);
HANDLE           __OpenFile(LPCWSTR path, DWORD mode, BOOL* bReadOnly);

// oleautomation/scripting
BOOL    GetJScriptCLSID(LPCLSID pclsid);
HRESULT GetTypeInfoFromName(LPCOLESTR name, ITypeLib* ptl, ITypeInfo** ppti);
DISPID  GetDispidFromName(PDISPIDTABLEENTRY pdt, DWORD cEntries, LPWSTR name);
void    AddRichErrorInfo(EXCEPINFO* pei, LPWSTR source, LPWSTR description, HRESULT error);
DWORD   GetHash(LPWSTR name);
DWORD   GetHash(LPSTR name);
HRESULT ProcessVariant(VARIANT* pvar, LPBYTE* ppbuf, LPDWORD pcbuf, LPDWORD pbytes);
HRESULT ProcessObject(IUnknown* punk, LPBYTE* ppbuf, LPDWORD pcbuf, LPDWORD pbytes);
HRESULT ValidateDispatchArgs(REFIID riid, DISPPARAMS* pdp, VARIANT* pvr, UINT* pae);
HRESULT ValidateInvokeFlags(WORD flags, WORD accesstype, BOOL bNotMethod);
HRESULT ValidateArgCount(DISPPARAMS* pdp, DWORD needed, BOOL bHasOptionalArgs, DWORD optional);
HRESULT HandleDispatchError(LPWSTR id, EXCEPINFO* pei, HRESULT hr);

// winsock
void ParseSocketInfo(PIOCTX pi);
void GetHostname(struct in_addr ip, LPSTR* ppsz);

// string & type manipulation
char*  __strndup(const char* src, int len);
char*  __strdup(const char* src);
WCHAR* __wstrndup(const WCHAR* src, int len);
WCHAR* __wstrdup(const WCHAR* src);
CHAR*  __widetoansi(const WCHAR* pwsz);
WCHAR* __ansitowide(const char* psz);
BOOL   __isempty(VARIANT var);
BSTR   __ansitobstr(LPCSTR src);
BSTR   __widetobstr(LPCWSTR wsrc);
char*  __unescape(char* str);

#endif /* _UTILS_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\w3spoof\inc\w3sobj.h ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    w3sobj.h

Abstract:

    Header for the W3Spoof class & related functions, etc.
    
Author:

    Paul M Midgen (pmidge) 07-June-2000


Revision History:

    07-June-2000 pmidge
        Created

    17-July-2000 pmidge
        Added class factory & IW3Spoof interface.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#ifndef _W3SOBJ_H_
#define _W3SOBJ_H_

#include "common.h"

class IOCTX
{
  public:
    IOCTX(IOTYPE iot, SOCKET s);
   ~IOCTX();

    IOTYPE Type(void);
    BOOL   AllocateWSABuffer(DWORD size, LPVOID pv);
    void   FreeWSABuffer(void);
    BOOL   ResizeWSABuffer(DWORD size);
    void   DisableIoCompletion(void);
    void   AddRef(void);
    void   Release(void);

  public:
    PIOCTX      pthis;
    OVERLAPPED  overlapped;
    SOCKET      socket;
    LPVOID      sockbuf;
    PHOSTINFO   local;
    PHOSTINFO   remote;
    LPWSTR      clientid;
    WSABUF*     pwsa;
    DWORD       bufsize;
    PSESSIONOBJ session;
    DWORD       bytes;
    DWORD       flags;
    DWORD       error;

  private:
    LONG       _cRefs;
    IOTYPE     _iot;
};

DWORD WINAPI ThreadFunc(LPVOID lpv);

class CW3Spoof : public IW3Spoof,
                 public IThreadPool,
                 public IW3SpoofClientSupport,
                 public IExternalConnection,
                 public IConnectionPointContainer
{
  public:
    DECLAREIUNKNOWN();

    // IConfig
    HRESULT __stdcall SetOption(DWORD dwOption, LPDWORD lpdwValue);
    HRESULT __stdcall GetOption(DWORD dwOption, LPDWORD lpdwValue);

    //
    // IW3Spoof
    //
    HRESULT __stdcall GetRuntime(IW3SpoofRuntime** pprt);
    HRESULT __stdcall GetTypeLibrary(ITypeLib** pptl);
    HRESULT __stdcall GetScriptEngine(IActiveScript** ppas);
    HRESULT __stdcall GetScriptPath(LPWSTR client, LPWSTR* path);
    HRESULT __stdcall Notify(LPWSTR clientid, PSESSIONOBJ pso, STATE state);
    HRESULT __stdcall WaitForUnload(void);
    HRESULT __stdcall Terminate(void);

    //
    // IThreadPool
    //
    HRESULT __stdcall GetStatus(PIOCTX* ppioc, LPBOOL pbQuit);
    HRESULT __stdcall GetSession(LPWSTR clientid, PSESSIONOBJ* ppso);
    HRESULT __stdcall Register(SOCKET s);

    DECLAREIDISPATCH();

    //
    // IW3SpoofClientSupport
    //
    HRESULT __stdcall RegisterClient(BSTR Client, BSTR ScriptPath);
    HRESULT __stdcall RevokeClient(BSTR Client);

    //
    // IExternalConnection
    //
    DWORD __stdcall AddConnection(DWORD type, DWORD reserved);
    DWORD __stdcall ReleaseConnection(DWORD type, DWORD reserved, BOOL bCloseIfLast);

    //
    // IConnectionPointContainer
    //
    HRESULT __stdcall EnumConnectionPoints(IEnumConnectionPoints** ppEnum);
    HRESULT __stdcall FindConnectionPoint(REFIID riid, IConnectionPoint** ppCP);

    //
    // Class methods
    //
    CW3Spoof();
   ~CW3Spoof();

    static HRESULT Create(IW3Spoof** ppw3s);

  private:
    DWORD            _Initialize(void);
    void             _LoadRegDefaults(void);
    BOOL             _InitializeThreads(void);
    void             _TerminateThreads(void);

    DWORD            _QueueAccept(void);
    BOOL             _CompleteAccept(PIOCTX pioc);
    BOOL             _DisconnectSocket(PIOCTX pioc, BOOL fNBGC);
    void             _SetState(STATE st);


  private:
    LONG             m_cRefs;
    LONG             m_cExtRefs;
    HANDLE           m_evtServerUnload;
    STATE            m_state;
    PRUNTIME         m_prt;
    ITypeLib*        m_ptl;
    IActiveScript*   m_pas;
    PSTRINGMAP       m_clientmap;
    PSTRINGMAP       m_sessionmap;
    DWORD            m_dwPoolSize;
    DWORD            m_dwMaxActiveThreads;
    USHORT           m_usServerPort;
    LPHANDLE         m_arThreads;
    SOCKET           m_sListen;
    HANDLE           m_hIOCP;
    LONG             m_AcceptQueueStatus;
    LONG             m_MaxQueuedAccepts;
    LONG             m_PendingAccepts;

  public:
    //
    // connection point object
    //
    class CW3SpoofEventsCP : public IConnectionPoint
    {
      public:
        //
        // IUnknown
        //
        HRESULT __stdcall QueryInterface(REFIID riid, void** ppv);
        ULONG   __stdcall AddRef(void);
        ULONG   __stdcall Release(void);

        //
        // IConnectionPoint
        //
        HRESULT __stdcall GetConnectionInterface(IID* pIID);
        HRESULT __stdcall GetConnectionPointContainer(IConnectionPointContainer** ppCPC);
        HRESULT __stdcall Advise(IUnknown* punkSink, LPDWORD pdwCookie);
        HRESULT __stdcall Unadvise(DWORD dwCookie);
        HRESULT __stdcall EnumConnections(IEnumConnections** ppEnum);

        //
        // object methods
        //
        CW3SpoofEventsCP()
        {
          m_cRefs        = 0L;
          m_cConnections = 0L;
          m_dwCookie     = 0L;
          m_pSite        = NULL;
          m_pSink        = NULL;
        }

       ~CW3SpoofEventsCP() {}

        void FireOnSessionOpen(LPWSTR clientid)
        {
          if(m_pSink)
          {
            m_pSink->OnSessionOpen(clientid);
          }
        }

        void FireOnSessionStateChange(LPWSTR clientid, STATE state)
        {
          if(m_pSink)
          {
            m_pSink->OnSessionStateChange(clientid, state);
          }
        }

        void FireOnSessionClose(LPWSTR clientid)
        {
          if(m_pSink)
          {
            m_pSink->OnSessionClose(clientid);
          }
        }

        void SetSite(IW3Spoof* pSite)
        {
          m_pSite = pSite;
        }

      private:
        LONG            m_cRefs;
        DWORD           m_cConnections;
        DWORD           m_dwCookie;
        IW3Spoof*       m_pSite;
        IW3SpoofEvents* m_pSink;
    };

    friend class CW3SpoofEventsCP;

  private:
    CW3SpoofEventsCP m_CP;
};

class CFactory : public IClassFactory
{
  public:
    //
    // IUnknown
    //
    HRESULT __stdcall QueryInterface(REFIID riid, void** ppv);
    ULONG   __stdcall AddRef(void);
    ULONG   __stdcall Release(void);

    //
    // IClassFactory
    //
    HRESULT __stdcall CreateInstance(IUnknown* pContainer, REFIID riid, void** ppv);
    HRESULT __stdcall LockServer(BOOL fLock);

    //
    // Class methods
    //
    CFactory();
   ~CFactory();

    static HRESULT Create(CFactory** ppCF);
    HRESULT Activate(void);
    HRESULT Terminate(void);

  private:
    HRESULT   _RegisterTypeLibrary(BOOL fMode);
    HRESULT   _RegisterServer(BOOL fMode);
    HRESULT   _RegisterClassFactory(BOOL fMode);
    IW3Spoof* m_pw3s;
    DWORD     m_dwCookie;
    LONG      m_cRefs;
    LONG      m_cLocks;
};

#endif /* _W3SOBJ_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\w3spoof\om\entity\dispatch.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    dispatch.cxx

Abstract:

    Implements the IDispatch interface for the Entity object.
    
Author:

    Paul M Midgen (pmidge) 13-November-2000


Revision History:

    13-November-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

//
// WARNING: do not modify these values. use disphash.exe to generate
//          new values.
//
DISPIDTABLEENTRY g_EntityDisptable[] =
{
  0x00021b1c,   DISPID_ENTITY_PARENT,       L"parent",
  0x00003b7b,   DISPID_ENTITY_GET,          L"get",
  0x00003f5f,   DISPID_ENTITY_SET,          L"set",
  0x00083673,   DISPID_ENTITY_COMPRESS,     L"compress",
  0x001fc1e8,   DISPID_ENTITY_DECOMPRESS,   L"decompress",
  0x0002142e,   DISPID_ENTITY_LENGTH,       L"length"
};

DWORD g_cEntityDisptable = (sizeof(g_EntityDisptable) / sizeof(DISPIDTABLEENTRY));


//-----------------------------------------------------------------------------
// IDispatch
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CEntity::GetTypeInfoCount(UINT* pctinfo)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "CEntity::GetTypeInfoCount",
    "this=%#x; pctinfo=%#x",
    this,
    pctinfo
    ));

  HRESULT hr = S_OK;

    if( !pctinfo )
    {
      hr = E_POINTER;
    }
    else
    {
      *pctinfo = 1;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CEntity::GetTypeInfo(UINT index, LCID lcid, ITypeInfo** ppti)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "CEntity::GetTypeInfo",
    "this=%#x; index=%#x; lcid=%#x; ppti=%#x",
    this,
    index,
    lcid,
    ppti
    ));

  HRESULT hr = S_OK;

  if( !ppti )
  {
    hr = E_POINTER;
  }
  else
  {
    if( index != 0 )
    {
      hr    = DISP_E_BADINDEX;
      *ppti = NULL;
    }
    else
    {
      hr = GetClassInfo(ppti);
    }
  }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CEntity::GetIDsOfNames(REFIID riid, LPOLESTR* arNames, UINT cNames, LCID lcid, DISPID* arDispId)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "CEntity::GetIDsOfNames",
    "this=%#x; riid=%s; arNames=%#x; cNames=%d; lcid=%#x; arDispId=%#x",
    this,
    MapIIDToString(riid),
    arNames,
    cNames,
    lcid,
    arDispId
    ));

  HRESULT hr = S_OK;
  UINT    n  = 0L;

  if( !IsEqualIID(riid, IID_NULL) )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  while( n < cNames )
  {
    arDispId[n] = GetDispidFromName(g_EntityDisptable, g_cEntityDisptable, arNames[n]);
    ++n;
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CEntity::Invoke(DISPID dispid, REFIID riid, LCID lcid, WORD flags, DISPPARAMS* pdp, VARIANT* pvr, EXCEPINFO* pei, UINT* pae)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "CEntity::Invoke",
    "this=%#x; dispid=%s; riid=%s; lcid=%#x; flags=%#x; pdp=%#x; pvr=%#x; pei=%#x; pae=%#x",
    this,
    MapDispidToString(dispid),
    MapIIDToString(riid),
    lcid,
    flags,
    pdp, pvr,
    pei, pae
    ));

  HRESULT hr = S_OK;

  hr = ValidateDispatchArgs(riid, pdp, pvr, pae);

    if( FAILED(hr) )
      goto quit;

  switch( dispid )
  {
    case DISPID_ENTITY_PARENT :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_PROPERTYGET, TRUE);

        if( SUCCEEDED(hr) )
        {
          V_VT(pvr) = VT_DISPATCH;
          hr        = get_Parent(&V_DISPATCH(pvr));
        }
      }
      break;

    case DISPID_ENTITY_LENGTH :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_PROPERTYGET, TRUE);

        if( SUCCEEDED(hr) )
        {
          hr = get_Length(pvr);
        }
      }
      break;

    case DISPID_ENTITY_GET :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, FALSE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 0, FALSE, 0);

          if( SUCCEEDED(hr) )
          {
            if( pvr )
            {
              hr = Get(pvr);
            }
          }
        }
      }
      break;

    case DISPID_ENTITY_SET :
      {
        NEWVARIANT(entity);

        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, FALSE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 1, FALSE, 0);

          if( SUCCEEDED(hr) )
          {
            VariantCopy(&entity, &pdp->rgvarg[0]);
            
              hr = Set(entity);

            VariantClear(&entity);
          }
        }
      }
      break;

    case DISPID_ENTITY_COMPRESS :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, FALSE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 1, FALSE, 0);

          if( SUCCEEDED(hr) )
          {
            hr = Compress(V_BSTR(&pdp->rgvarg[0]));
          }
        }
      }
      break;

    case DISPID_ENTITY_DECOMPRESS :
      {
        NEWVARIANT(method);

        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, FALSE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 1, FALSE, 0);

          if( SUCCEEDED(hr) )
          {
            VariantCopy(&method, &pdp->rgvarg[0]);
            
              hr = Decompress(method);
              
            VariantClear(&method);
          }
        }
      }
      break;
   
    default : hr = DISP_E_MEMBERNOTFOUND;
  }

quit:

  if( FAILED(hr) )
  {
    hr = HandleDispatchError(L"entity object", pei, hr);
  }

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\w3spoof\om\entity\entity.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    entity.cxx

Abstract:

    Implements the Entity object.
    
Author:

    Paul M Midgen (pmidge) 13-November-2000


Revision History:

    13-November-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

LPWSTR g_wszEntityObjectName = L"entity";

//-----------------------------------------------------------------------------
// CEntity methods
//-----------------------------------------------------------------------------
CEntity::CEntity():
  m_cRefs(1),
  m_pSite(NULL),
  m_pti(NULL),
  m_pbData(NULL),
  m_cData(0)
{
  DEBUG_TRACE(ENTITY, ("CEntity [%#x] created", this));
}


CEntity::~CEntity()
{
  DEBUG_TRACE(ENTITY, ("CEntity [%#x] deleted", this));
}


HRESULT
CEntity::Create(LPBYTE data, DWORD length, BOOL bReadOnly, PENTITYOBJ* ppentity)
{
  DEBUG_ENTER((
    DBG_ENTITY,
    rt_hresult,
    "CEntity::Create",
    "data=%#x; length=%d; bReadOnly=%d; ppentity=%#x",
    data,
    length,
    bReadOnly,
    ppentity
    ));

  HRESULT    hr  = S_OK;
  PENTITYOBJ peo = NULL;

  if( !ppentity )
  {
    hr = E_POINTER;
    goto quit;
  }
  
  if( peo = new ENTITYOBJ )
  {
    if( SUCCEEDED(peo->_Initialize(data, length, bReadOnly)) )
    {
      *ppentity = peo;
    }
    else
    {
      delete peo;
      *ppentity = NULL;
      hr        = E_FAIL;
    }
  }
  else
  {
    hr = E_OUTOFMEMORY;
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
CEntity::_Initialize(LPBYTE data, DWORD length, BOOL bReadOnly)
{
  DEBUG_ENTER((
    DBG_ENTITY,
    rt_hresult,
    "CEntity::_Initialize",
    "this=%#x; data=%#x; length=%d; bReadOnly=%d",
    this,
    data,
    length,
    bReadOnly
    ));

  HRESULT hr = S_OK;

    m_bReadOnly = bReadOnly;
    m_cData     = length;

    if( m_cData )
    {
      m_pbData = new BYTE[m_cData];
      memcpy(m_pbData, data, m_cData);
    }
  
  DEBUG_LEAVE(hr);
  return hr;
}


void
CEntity::_Cleanup(void)
{
  DEBUG_TRACE(ENTITY, ("CEntity [%#x] cleaning up", this));

  m_cData = 0L;
  SAFEDELETEBUF(m_pbData);
}


void
CEntity::Terminate(void)
{
  DEBUG_TRACE(ENTITY, ("CEntity [%#x] terminating", this));

  m_bReadOnly = FALSE;
  SAFERELEASE(m_pSite);
  Release();
}


//-----------------------------------------------------------------------------
// IUnknown
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CEntity::QueryInterface(REFIID riid, void** ppv)
{
  DEBUG_ENTER((
    DBG_REFCOUNT,
    rt_hresult,
    "CEntity::QueryInterface",
    "this=%#x; riid=%s; ppv=%#x",
    this,
    MapIIDToString(riid),
    ppv
    ));

  HRESULT hr = S_OK;

  if( !ppv )
  {
    hr = E_POINTER;
    goto quit;
  }

    if(
      IsEqualIID(riid, IID_IUnknown)  ||
      IsEqualIID(riid, IID_IDispatch) ||
      IsEqualIID(riid, IID_IEntity)
      )
    {
      *ppv = static_cast<IEntity*>(this);
    }
    else if( IsEqualIID(riid, IID_IProvideClassInfo) )
    {
      *ppv = static_cast<IProvideClassInfo*>(this);
    }
    else if( IsEqualIID(riid, IID_IObjectWithSite) )
    {
      *ppv = static_cast<IObjectWithSite*>(this);
    }
    else
    {
      *ppv = NULL;
      hr   = E_NOINTERFACE;
    }

  if( SUCCEEDED(hr) )
  {
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


ULONG
__stdcall
CEntity::AddRef(void)
{
  InterlockedIncrement(&m_cRefs);
  DEBUG_ADDREF("CEntity", m_cRefs);
  return m_cRefs;
}


ULONG
__stdcall
CEntity::Release(void)
{
  InterlockedDecrement(&m_cRefs);
  DEBUG_RELEASE("CEntity", m_cRefs);

  if( m_cRefs == 0 )
  {
    DEBUG_FINALRELEASE("CEntity");
    _Cleanup();
    SAFERELEASE(m_pti);
    delete this;
    return 0;
  }

  return m_cRefs;
}


//-----------------------------------------------------------------------------
// IProvideClassInfo
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CEntity::GetClassInfo(ITypeInfo** ppti)
{
  DEBUG_ENTER((
    DBG_ENTITY,
    rt_hresult,
    "CEntity::GetClassInfo",
    "this=%#x; ppti=%#x",
    this,
    ppti
    ));

  HRESULT hr = S_OK;


  if( ppti )
  {
    m_pti->AddRef();
    *ppti = m_pti;
  }
  else
  {
    hr = E_POINTER;
  }

  DEBUG_LEAVE(hr);
  return hr;
}


//-----------------------------------------------------------------------------
// IObjectWithSite
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CEntity::SetSite(IUnknown* pUnkSite)
{
  DEBUG_ENTER((
    DBG_ENTITY,
    rt_hresult,
    "CEntity::SetSite",
    "this=%#x; pUnkSite=%#x",
    this,
    pUnkSite
    ));

  HRESULT            hr         = S_OK;
  IActiveScriptSite* pias       = NULL;
  IObjectWithSite*   pcontainer = NULL;

    if( !pUnkSite )
    {
      hr = E_INVALIDARG;
    }
    else
    {
      SAFERELEASE(m_pSite);
      SAFERELEASE(m_pti);

      m_pSite = pUnkSite;
      m_pSite->AddRef();

      hr = m_pSite->QueryInterface(IID_IObjectWithSite, (void**) &pcontainer);

      if( SUCCEEDED(hr) )
      {
        hr = pcontainer->GetSite(IID_IActiveScriptSite, (void**) &pias);

        if( SUCCEEDED(hr) )
        {
          hr = pias->GetItemInfo(
                       g_wszEntityObjectName,
                       SCRIPTINFO_ITYPEINFO,
                       NULL,
                       &m_pti
                       );
        }
      }
    }

  SAFERELEASE(pcontainer);
  SAFERELEASE(pias);

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CEntity::GetSite(REFIID riid, void** ppvSite)
{
  DEBUG_ENTER((
    DBG_ENTITY,
    rt_hresult,
    "CEntity::GetSite",
    "this=%#x; riid=%s; ppvSite=%#x",
    this,
    MapIIDToString(riid),
    ppvSite
    ));

  HRESULT hr = S_OK;

    if( !ppvSite )
    {
      hr = E_POINTER;
    }
    else
    {
      if( m_pSite )
      {
        hr = m_pSite->QueryInterface(riid, ppvSite);
      }
    }

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\w3spoof\om\om.inc ===
!IF 0

Copyright (c) 1994  Microsoft Corporation

Module Name:

    w3spoof.inc

Abstract:

    Common makefile contents for w3spoof project

!ENDIF

!IFNDEF SDKINC
SDKINC=$(SDK_INC_PATH)
!ENDIF

!IFDEF LIBDIR
!ERROR LIBDIR already defined - choose new name
!ENDIF

LIBDIR=..\..\lib\$(_OBJ_DIR)
W3SPOOFINC=..\..\inc

#
# if TARGETPATH is not defined (in the paths that build libraries) then this
# is the default target path
#
!IFNDEF TARGETPATH
TARGETPATH=$(LIBDIR)
TARGETTYPE=LIBRARY
!ENDIF

#
# what it is that we're building
#
MAJORCOMP=w3spoof

USE_NOLIBS=1
#USE_LIBCMT=0
NO_NTDLL=1
#NO_BINPLACE=0
BINPLACE_PLACEFILE=..\..\binplace.txt

#
# Linker flags
#
WIN32_WINNT_VERSION=0x0500
#WIN32_WIN95_VERSION=0x0400

#
# compiler warning flags
#
MSC_WARNING_LEVEL=/W3 /WX

#
# compiler definitions
#
C_DEFINES=$(C_DEFINES) -DWIN32

CLEANINF = cleaninf.exe $(CLEANINF_FLAGS)

#
# Set debugging level
#
!IF "$(NTDEBUG)" != "" && "$(NTDEBUG)" != "retail" && "$(NTDEBUG)" != "ntsdnodbg"
C_DEFINES=$(C_DEFINES) -D_DEBUG
!ENDIF

!IF "$(__FULL_DEBUG__)" != "" && "$(__RELEASE_DEBUG__)" == ""
C_DEFINES=$(C_DEFINES) -D__FULL_DEBUG__
!IF "$(__DBG_TO_CONSOLE__)" == "1"
C_DEFINES=$(C_DEFINES) -D__DBG_TO_CONSOLE__
!ENDIF
!ENDIF

!IF "$(__RELEASE_DEBUG__)" != "" && "$(__FULL_DEBUG__)" == ""
C_DEFINES=$(C_DEFINES) -D__RELEASE_DEBUG__
!ENDIF


!IFNDEF W3SPOOF_PCH
PRECOMPILED_OPTION=/Fp..\..\inc\$(_OBJ_DIR)\*\common.pch /Yucommon.h
PRECOMPILED_CXX=1
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\w3spoof\inc\w3srt.h ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 1999  Microsoft Corporation

Module Name:

    w3srt.h

Abstract:

    Object declarations for the W3Spoof runtime environment.
    
Author:

    Paul M Midgen (pmidge) 03-November-2000


Revision History:

    03-November-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#ifndef __W3SRT_H__
#define __W3SRT_H__

#include "common.h"

typedef class CW3SRuntime      RUNTIME;
typedef class CW3SRuntime*     PRUNTIME;
typedef class CW3SPropertyBag  PROPERTYBAG;
typedef class CW3SPropertyBag* PPROPERTYBAG;
typedef class CW3SFile         FILEOBJ;
typedef class CW3SFile*        PFILEOBJ;

#define DISPID_RUNTIME_BASE          0x10000000
#define DISPID_PROPERTYBAG_BASE      0x20000000
#define DISPID_FILE_BASE             0x30000000

#define DISPID_RUNTIME_GETFILE       (DISPID_RUNTIME_BASE + 1)

#define DISPID_PROPERTYBAG_GET       (DISPID_PROPERTYBAG_BASE + 1)
#define DISPID_PROPERTYBAG_SET       (DISPID_PROPERTYBAG_BASE + 2)
#define DISPID_PROPERTYBAG_EXPIRES   (DISPID_PROPERTYBAG_BASE + 3)
#define DISPID_PROPERTYBAG_FLUSH     (DISPID_PROPERTYBAG_BASE + 4)

#define DISPID_FILE_OPEN             (DISPID_FILE_BASE + 1)
#define DISPID_FILE_CLOSE            (DISPID_FILE_BASE + 2)
#define DISPID_FILE_WRITE            (DISPID_FILE_BASE + 3)
#define DISPID_FILE_WRITELINE        (DISPID_FILE_BASE + 4)
#define DISPID_FILE_WRITEBLANKLINE   (DISPID_FILE_BASE + 5)
#define DISPID_FILE_READ             (DISPID_FILE_BASE + 6)
#define DISPID_FILE_READALL          (DISPID_FILE_BASE + 7)
#define DISPID_FILE_ATTRIBUTES       (DISPID_FILE_BASE + 8)
#define DISPID_FILE_SIZE             (DISPID_FILE_BASE + 9)
#define DISPID_FILE_TYPE             (DISPID_FILE_BASE + 10)
#define DISPID_FILE_DATELASTMODIFIED (DISPID_FILE_BASE + 11)

#ifdef __cplusplus
extern "C" {
#endif

extern const IID IID_IW3SpoofRuntime;
extern const IID IID_IW3SpoofPropertyBag;
extern const IID IID_IW3SpoofFile;
  
//-----------------------------------------------------------------------------
// W3Spoof Runtime Interface Declarations
//-----------------------------------------------------------------------------
interface IW3SpoofPropertyBag : public IDispatch
{
  virtual HRESULT __stdcall Get(
                              /*[in]*/          BSTR Name,
                              /*[out, retval]*/ VARIANT* Value
                              ) PURE;

  virtual HRESULT __stdcall Set(
                              /*[in]*/           BSTR Name,
                              /*[in, optional]*/ VARIANT Value
                              ) PURE;

  virtual HRESULT __stdcall get_Expires(
                              /*[propget]*/
                              /*[out, retval]*/ VARIANT* Expiry
                              ) PURE;

  virtual HRESULT __stdcall put_Expires(
                              /*[propput]*/
                              /*[in, optional]*/ VARIANT Expiry
                              ) PURE;

  virtual HRESULT __stdcall Flush(void) PURE;
};


interface IW3SpoofFile : public IDispatch
{
  virtual HRESULT __stdcall Open(
                              /*[in]*/           BSTR     Filename,
                              /*[in, optional]*/ VARIANT  Mode,
                              /*[out, retval]*/  VARIANT* Success
                              ) PURE;

  virtual HRESULT __stdcall Close(void) PURE;

  virtual HRESULT __stdcall Write(
                              /*[in]*/          VARIANT  Data,
                              /*[out, retval]*/ VARIANT* Success
                              ) PURE;

  virtual HRESULT __stdcall WriteLine(
                              /*[in]*/          BSTR     Line,
                              /*[out, retval]*/ VARIANT* Success
                              ) PURE;

  virtual HRESULT __stdcall WriteBlankLine(
                              /*[out, retval]*/ VARIANT* Success
                              ) PURE;

  virtual HRESULT __stdcall Read(
                              /*[in]*/          VARIANT  Bytes,
                              /*[out, retval]*/ VARIANT* Data
                              ) PURE;

  virtual HRESULT __stdcall ReadAll(
                              /*[out, retval]*/ VARIANT* Data
                              ) PURE;

  virtual HRESULT __stdcall Attributes(
                              /*[out, retval]*/ VARIANT* Attributes
                              ) PURE;

  virtual HRESULT __stdcall Size(
                              /*[out, retval]*/ VARIANT* Size
                              ) PURE;

  virtual HRESULT __stdcall Type(
                              /*[out, retval]*/ VARIANT* Type
                              ) PURE;

  virtual HRESULT __stdcall DateLastModified(
                              /*[out, retval]*/ VARIANT* Date
                              ) PURE;
};


interface IW3SpoofRuntime : public IUnknown
{
  virtual HRESULT __stdcall GetFile(IDispatch** ppdisp) PURE;
  virtual HRESULT __stdcall GetPropertyBag(BSTR Name, IW3SpoofPropertyBag** ppbag) PURE;
};

#ifdef __cplusplus
}
#endif

//-----------------------------------------------------------------------------
// W3Spoof Runtime Object Declarations
//-----------------------------------------------------------------------------
class CW3SRuntime : public IW3SpoofRuntime,
                    public IDispatch
{
  public:
    DECLAREIUNKNOWN();
    DECLAREIDISPATCH();

  public:
    // IW3SpoofRuntime
    HRESULT __stdcall GetFile(IDispatch** ppdisp);
    HRESULT __stdcall GetPropertyBag(BSTR Name, IW3SpoofPropertyBag** ppbag);

    CW3SRuntime();
   ~CW3SRuntime();

    HRESULT Terminate(void);

    static HRESULT Create(PRUNTIME* pprt);

  private:
    HRESULT    _Initialize(void);

    LONG       m_cRefs;
    PSTRINGMAP m_propertybags;
};


class CW3SPropertyBag : public IW3SpoofPropertyBag
{
  public :
    DECLAREIUNKNOWN();
    DECLAREIDISPATCH();

  public:
    HRESULT __stdcall Get(BSTR Name, VARIANT* Value);
    HRESULT __stdcall Set(BSTR Name, VARIANT Value);
    HRESULT __stdcall get_Expires(VARIANT* Expiry);
    HRESULT __stdcall put_Expires(VARIANT Expiry);
    HRESULT __stdcall Flush(void);

    CW3SPropertyBag();
   ~CW3SPropertyBag();

    HRESULT GetBagName(LPWSTR* ppwsz);
    HRESULT Terminate(void);

    static HRESULT Create(LPWSTR name, PPROPERTYBAG* ppbag);

  private:
    HRESULT    _Initialize(LPWSTR name);
    void       _Reset(void);
    BOOL       _IsStale(void);

    LONG       m_cRefs;
    LPWSTR     m_name;
    BOOL       m_stale;
    DWORD      m_expiry;
    DWORD      m_created;
    PSTRINGMAP m_propertybag;
};

class CW3SFile : public IW3SpoofFile
{
  public:
    DECLAREIUNKNOWN();
    DECLAREIDISPATCH();

  public:
    HRESULT __stdcall Open(BSTR Filename, VARIANT Mode, VARIANT* Success);
    HRESULT __stdcall Close(void);
    HRESULT __stdcall Write(VARIANT Data, VARIANT* Success);
    HRESULT __stdcall WriteLine(BSTR Line, VARIANT* Success);
    HRESULT __stdcall WriteBlankLine(VARIANT* Success);
    HRESULT __stdcall Read(VARIANT Bytes, VARIANT* Data);
    HRESULT __stdcall ReadAll(VARIANT* Data);
    HRESULT __stdcall Attributes(VARIANT* Attributes);
    HRESULT __stdcall Size(VARIANT* Size);
    HRESULT __stdcall Type(VARIANT* Type);
    HRESULT __stdcall DateLastModified(VARIANT* Date);

    CW3SFile();
   ~CW3SFile();

    static HRESULT Create(IW3SpoofFile** ppw3sf);
  
  private:
    void             _Cleanup(void);
    BOOL             _CacheHttpResponse(void);

    LONG             m_cRefs;
    BOOL             m_bFileOpened;
    BOOL             m_bReadOnly;
    BOOL             m_bAsciiData;
    BOOL             m_bHttpResponseCached;
    HANDLE           m_hFile;
    IWinHttpRequest* m_pWHR;
    VARIANT          m_vHttpResponse;
    DWORD            m_cHttpBytesRead;
    BHFI             m_bhfi;
};

#endif /* __W3SRT_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\w3spoof\om\entity\methods.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    methods.cxx

Abstract:

    Implements methods part of the Entity object's dual interface.
    
Author:

    Paul M Midgen (pmidge) 13-November-2000


Revision History:

    13-November-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

HRESULT
__stdcall
CEntity::get_Parent(IDispatch **ppdisp)
{
  DEBUG_ENTER((
    DBG_ENTITY,
    rt_hresult,
    "CEntity::get_Parent",
    "this=%#x; ppdisp=%#x",
    this,
    ppdisp
    ));

  HRESULT hr = S_OK;

    if( ppdisp )
    {
      if( m_pSite )
      {
        hr = m_pSite->QueryInterface(IID_IDispatch, (void**) ppdisp);
      }
      else
      {
        *ppdisp = NULL;
        hr      = E_UNEXPECTED;
      }
    }
    else
    {
      hr = E_POINTER;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CEntity::get_Length(VARIANT *Length)
{
  DEBUG_ENTER((
    DBG_ENTITY,
    rt_hresult,
    "CEntity::get_Length",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

    if( Length )
    {
      V_VT(Length)  = VT_UI4;
      V_UI4(Length) = m_cData;
    }
    else
    {
      hr = E_POINTER;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CEntity::Get(VARIANT *Entity)
{
  DEBUG_ENTER((
    DBG_ENTITY,
    rt_hresult,
    "CEntity::Get",
    "this=%#x",
    this
    ));

  HRESULT    hr  = S_OK;
  SAFEARRAY* psa = NULL;

  if( !Entity )
  {
    hr = E_POINTER;
  }
  else
  {
    if( m_cData )
    {
      DEBUG_DATA_DUMP(ENTITY, ("entity body", m_pbData, m_cData));

      psa = SafeArrayCreateVector(VT_UI1, 1, m_cData);

      if( psa )
      {
        memcpy((LPBYTE) psa->pvData, m_pbData, m_cData);

        V_VT(Entity)    = VT_ARRAY | VT_UI1;
        V_ARRAY(Entity) = psa;
      }
      else
      {
        hr = E_FAIL;
      }
    }
    else
    {
      V_VT(Entity) = VT_NULL;
    }
  }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CEntity::Set(VARIANT Entity)
{
  DEBUG_ENTER((
    DBG_ENTITY,
    rt_hresult,
    "CEntity::Set",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

    if( !m_bReadOnly )
    {
      _Cleanup();

      if( !__isempty(Entity) )
      {
        hr = ProcessVariant(&Entity, &m_pbData, &m_cData, NULL);
      }
    }
    else
    {
      hr = E_ACCESSDENIED;
    }
  
  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CEntity::Compress(BSTR Method)
{
  DEBUG_ENTER((
    DBG_ENTITY,
    rt_hresult,
    "CEntity::Compress",
    "this=%#x",
    this
    ));

  HRESULT hr = E_NOTIMPL;

  //
  // TODO: implementation
  //

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CEntity::Decompress(VARIANT Method)
{
  DEBUG_ENTER((
    DBG_ENTITY,
    rt_hresult,
    "CEntity::Decompress",
    "this=%#x",
    this
    ));

  HRESULT hr = E_NOTIMPL;

  //
  // TODO: implementation
  //

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\w3spoof\om\headers\dispatch.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    dispatch.cxx

Abstract:

    Implements the IDispatch interface for the Headers object.
    
Author:

    Paul M Midgen (pmidge) 13-November-2000


Revision History:

    13-November-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

//
// WARNING: do not modify these values. use disphash.exe to generate
//          new values.
//
DISPIDTABLEENTRY g_HeadersDisptable[] =
{
  0x00021b1c,   DISPID_HEADERS_PARENT,      L"parent",
  0x00003f5f,   DISPID_HEADERS_SET,         L"set",
  0x00003b7b,   DISPID_HEADERS_GET,         L"get",
  0x00104b18,   DISPID_HEADERS_GETHEADER,   L"getheader",
  0x00113b84,   DISPID_HEADERS_SETHEADER,   L"setheader"
};

DWORD g_cHeadersDisptable = (sizeof(g_HeadersDisptable) / sizeof(DISPIDTABLEENTRY));


//-----------------------------------------------------------------------------
// IDispatch
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CHeaders::GetTypeInfoCount(UINT* pctinfo)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "CHeaders::GetTypeInfoCount",
    "this=%#x; pctinfo=%#x",
    this,
    pctinfo
    ));

  HRESULT hr = S_OK;

    if( !pctinfo )
    {
      hr = E_POINTER;
    }
    else
    {
      *pctinfo = 1;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CHeaders::GetTypeInfo(UINT index, LCID lcid, ITypeInfo** ppti)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "CHeaders::GetTypeInfo",
    "this=%#x; index=%#x; lcid=%#x; ppti=%#x",
    this,
    index,
    lcid,
    ppti
    ));

  HRESULT hr   = S_OK;

  if( !ppti )
  {
    hr = E_POINTER;
  }
  else
  {
    if( index != 0 )
    {
      hr    = DISP_E_BADINDEX;
      *ppti = NULL;
    }
    else
    {
      hr = GetClassInfo(ppti);
    }
  }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CHeaders::GetIDsOfNames(REFIID riid, LPOLESTR* arNames, UINT cNames, LCID lcid, DISPID* arDispId)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "CHeaders::GetIDsOfNames",
    "this=%#x; riid=%s; arNames=%#x; cNames=%d; lcid=%#x; arDispId=%#x",
    this,
    MapIIDToString(riid),
    arNames,
    cNames,
    lcid,
    arDispId
    ));

  HRESULT hr = S_OK;
  UINT    n  = 0L;

  if( !IsEqualIID(riid, IID_NULL) )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  while( n < cNames )
  {
    arDispId[n] = GetDispidFromName(g_HeadersDisptable, g_cHeadersDisptable, arNames[n]);
    ++n;
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CHeaders::Invoke(DISPID dispid, REFIID riid, LCID lcid, WORD flags, DISPPARAMS* pdp, VARIANT* pvr, EXCEPINFO* pei, UINT* pae)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "CHeaders::Invoke",
    "this=%#x; dispid=%s; riid=%s; lcid=%#x; flags=%#x; pdp=%#x; pvr=%#x; pei=%#x; pae=%#x",
    this,
    MapDispidToString(dispid),
    MapIIDToString(riid),
    lcid,
    flags,
    pdp, pvr,
    pei, pae
    ));

  HRESULT hr = S_OK;

  hr = ValidateDispatchArgs(riid, pdp, pvr, pae);

    if( FAILED(hr) )
      goto quit;

  switch( dispid )
  {
    case DISPID_HEADERS_PARENT :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_PROPERTYGET, TRUE);

        if( SUCCEEDED(hr) )
        {
          if( pvr )
          {
            V_VT(pvr) = VT_DISPATCH;
            hr        = get_Parent(&V_DISPATCH(pvr));
          }
        }
      }
      break;

    case DISPID_HEADERS_SET :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, FALSE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 1, FALSE, 0);

          if( SUCCEEDED(hr) )
          {
            hr = Set(&pdp->rgvarg[0]);
          }
        }
      }
      break;

    case DISPID_HEADERS_GET :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, FALSE);

        if( SUCCEEDED(hr) )
        {
          if( pvr )
          {
            V_VT(pvr) = VT_BSTR;
            hr        = Get(&V_BSTR(pvr));
          }
        }
      }
      break;

    case DISPID_HEADERS_GETHEADER :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, FALSE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 1, FALSE, 0);

          if( SUCCEEDED(hr) )
          {
            if( pvr )
            {
              hr = GetHeader(
                     V_BSTR(&pdp->rgvarg[0]),
                     pvr
                     );
            }
          }
        }
      }
      break;

    case DISPID_HEADERS_SETHEADER :
      {
        NEWVARIANT(name);
        NEWVARIANT(value);

        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, FALSE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 1, TRUE, 1);

          if( SUCCEEDED(hr) )
          {
            hr = DispGetParam(pdp, 0, VT_BSTR, &name, pae);
            
            if( SUCCEEDED(hr) )
            {
              hr = DispGetParam(pdp, 1, VT_BSTR, &value, pae);
              
              hr = SetHeader(
                     V_BSTR(&name),
                     (SUCCEEDED(hr) ? &value : NULL)
                     );
            }

            VariantClear(&name);
            VariantClear(&value);
          }
        }
      }
      break;

    default : hr = DISP_E_MEMBERNOTFOUND;
  }

quit:

  if( FAILED(hr) )
  {
    hr = HandleDispatchError(L"headers object", pei, hr);
  }

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\w3spoof\om\headers\methods.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    methods.cxx

Abstract:

    Implements methods part of the Headers object's dual interface.
    
Author:

    Paul M Midgen (pmidge) 13-November-2000


Revision History:

    13-November-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

HRESULT
__stdcall
CHeaders::get_Parent(IDispatch **ppdisp)
{
  DEBUG_ENTER((
    DBG_HEADERS,
    rt_hresult,
    "CHeaders::get_Parent",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

    if( !ppdisp )
    {
      hr = E_POINTER;
    }
    else
    {
      if( m_pSite )
      {
        hr = m_pSite->QueryInterface(IID_IDispatch, (void**) ppdisp);
      }
      else
      {
        *ppdisp = NULL;
        hr      = E_UNEXPECTED;
      }
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CHeaders::Get(BSTR *Headers)
{
  DEBUG_ENTER((
    DBG_HEADERS,
    rt_hresult,
    "CHeaders::Get",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

    if( !Headers )
    {
      hr = E_POINTER;
    }
    else
    {
      *Headers = __ansitobstr(m_pchHeaders);
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CHeaders::Set(VARIANT *Headers)
{
  DEBUG_ENTER((
    DBG_HEADERS,
    rt_hresult,
    "CHeaders::Set",
    "this=%#x",
    this
    ));

  HRESULT hr  = S_OK;
  LPSTR   tmp = NULL;

    if( !m_bReadOnly )
    {
      m_headerlist->Clear();

      if( Headers )
      {
        tmp = __widetoansi(V_BSTR(Headers));
        hr  = _ParseHeaders(tmp);
      }
    }
    else
    {
      hr = E_ACCESSDENIED;
    }

  SAFEDELETEBUF(tmp);

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CHeaders::GetHeader(BSTR Header, VARIANT *Value)
{
  DEBUG_ENTER((
    DBG_HEADERS,
    rt_hresult,
    "CHeaders::GetHeader",
    "this=%#x; header=%S",
    this,
    Header
    ));

  HRESULT hr    = S_OK;
  LPSTR   name  = NULL;
  BSTR    value = NULL;

  if( !Header )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  if( !Value )
  {
    hr = E_POINTER;
    goto quit;
  }

  //
  // TODO: collection support using SAFEARRAYs
  //

  name = __widetoansi(Header);
  hr   = m_headerlist->Get(name, &value);

  if( SUCCEEDED(hr) )
  {
    DEBUG_TRACE(HEADERS, ("found: %S", value));

    V_VT(Value)   = VT_BSTR;
    V_BSTR(Value) = SysAllocString(value);
  }
  else
  {
    DEBUG_TRACE(HEADERS, ("not found"));

    V_VT(Value) = VT_NULL;
    hr          = S_OK;
  }

  SAFEDELETEBUF(name);

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CHeaders::SetHeader(BSTR Header, VARIANT *Value)
{
  DEBUG_ENTER((
    DBG_HEADERS,
    rt_hresult,
    "CHeaders::SetHeader",
    "this=%#x; header=%S",
    this,
    Header
    ));

  HRESULT hr   = S_OK;
  LPSTR   name = NULL;

  if( !Header )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  if( !m_bReadOnly )
  {
    name = __widetoansi(Header);

      if( !Value || __isempty(*Value) )
      {
        m_headerlist->Delete(name);
      }
      else
      {
        m_headerlist->Insert(name, __widetobstr(V_BSTR(Value)));
      }

    SAFEDELETEBUF(name);
  }
  else
  {
    hr = E_ACCESSDENIED;
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\w3spoof\om\headers\headers.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    headers.cxx

Abstract:

    Implements the Headers object.
    
Author:

    Paul M Midgen (pmidge) 13-November-2000


Revision History:

    13-November-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

LPWSTR g_wszHeadersObjectName = L"headers";

//-----------------------------------------------------------------------------
// CHeaders methods
//-----------------------------------------------------------------------------
CHeaders::CHeaders():
  m_cRefs(1),
  m_pSite(NULL),
  m_pti(NULL),
  m_bReadOnly(FALSE),
  m_headerlist(NULL),
  m_pchHeaders(NULL)
{
  DEBUG_TRACE(HEADERS, ("CHeaders [%#x] created", this));
}


CHeaders::~CHeaders()
{
  DEBUG_TRACE(HEADERS, ("CHeaders [%#x] deleted", this));
}


HRESULT
CHeaders::Create(CHAR* headers, BOOL bReadOnly, PHEADERSOBJ* ppheaders)
{
  DEBUG_ENTER((
    DBG_HEADERS,
    rt_hresult,
    "CHeaders::Create",
    "headers=%#x; bReadOnly=%d; ppheaders=%#x",
    headers,
    bReadOnly,
    ppheaders
    ));

  HRESULT     hr  = S_OK;
  PHEADERSOBJ pho = NULL;

  if( !headers )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  if( !ppheaders )
  {
    hr = E_POINTER;
    goto quit;
  }
  
  if( pho = new HEADERSOBJ )
  {
    if( SUCCEEDED(pho->_Initialize(headers, bReadOnly)) )
    {
      *ppheaders = pho;
    }
    else
    {
      delete pho;
      *ppheaders = NULL;
      hr         = E_FAIL;
    }
  }
  else
  {
    hr = E_OUTOFMEMORY;
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
CHeaders::_Initialize(CHAR* headers, BOOL bReadOnly)
{
  DEBUG_ENTER((
    DBG_HEADERS,
    rt_hresult,
    "CHeaders::_Initialize",
    "this=%#x; headers=%#x; bReadOnly=%d",
    this,
    headers,
    bReadOnly
    ));

  HRESULT hr = S_OK;

  if( !headers )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  m_bReadOnly  = bReadOnly;
  m_headerlist = new HEADERLIST;

  m_headerlist->SetClearFunction(BSTRKiller);

  hr = _ParseHeaders(headers);

quit:
  
  DEBUG_LEAVE(hr);
  return hr;
}


void
CHeaders::_Cleanup(void)
{
  DEBUG_TRACE(HEADERS, ("CHeaders [%#x] cleaning up", this));

  m_headerlist->Clear();
  SAFEDELETE(m_headerlist);
  SAFEDELETEBUF(m_pchHeaders);
}


void
CHeaders::Terminate(void)
{
  DEBUG_TRACE(HEADERS, ("CHeaders [%#x] terminating", this));

  m_bReadOnly = FALSE;
  SAFERELEASE(m_pSite);
  Release();
}


HRESULT
CHeaders::_ParseHeaders(CHAR* headers)
{
  DEBUG_ENTER((
    DBG_HEADERS,
    rt_hresult,
    "CHeaders::_ParseHeaders",
    "this=%#x; headers=%#x",
    this,
    headers
    ));

  HRESULT hr    = S_OK;
  LPSTR   name  = NULL;
  LPSTR   value = NULL;

  if( headers )
  {
    m_pchHeaders = __strdup(headers);
  }
  else
  {
    DEBUG_TRACE(HEADERS, ("no headers present"));
    hr = E_FAIL;
    goto quit;
  }

  name = strtok(headers, ":");

  while( name )
  {
    value = strtok(NULL, "\r\n");

    if( value )
    {
      value += (value[0] == ' ') ? 1 : 0;

      m_headerlist->Insert(name, __ansitobstr(value));
      name = strtok(NULL, ":\r\n");
    }
    else
    {
      // this is an error condition?

      name = NULL;
    }
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


//-----------------------------------------------------------------------------
// IUnknown
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CHeaders::QueryInterface(REFIID riid, void** ppv)
{
  DEBUG_ENTER((
    DBG_REFCOUNT,
    rt_hresult,
    "CHeaders::QueryInterface",
    "this=%#x; riid=%s; ppv=%#x",
    this,
    MapIIDToString(riid),
    ppv
    ));

  HRESULT hr = S_OK;

  if( !ppv )
  {
    hr = E_POINTER;
    goto quit;
  }

    if(
      IsEqualIID(riid, IID_IUnknown)  ||
      IsEqualIID(riid, IID_IDispatch) ||
      IsEqualIID(riid, IID_IHeaders)
      )
    {
      *ppv = static_cast<IHeaders*>(this);
    }
    else if( IsEqualIID(riid, IID_IProvideClassInfo) )
    {
      *ppv = static_cast<IProvideClassInfo*>(this);
    }
    else if( IsEqualIID(riid, IID_IObjectWithSite) )
    {
      *ppv = static_cast<IObjectWithSite*>(this);
    }
    else
    {
      *ppv = NULL;
      hr   = E_NOINTERFACE;
    }

  if( SUCCEEDED(hr) )
  {
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


ULONG
__stdcall
CHeaders::AddRef(void)
{
  InterlockedIncrement(&m_cRefs);
  DEBUG_ADDREF("CHeaders", m_cRefs);
  return m_cRefs;
}


ULONG
__stdcall
CHeaders::Release(void)
{
  InterlockedDecrement(&m_cRefs);
  DEBUG_RELEASE("CHeaders", m_cRefs);

  if( m_cRefs == 0 )
  {
    DEBUG_FINALRELEASE("CHeaders");
    _Cleanup();
    SAFERELEASE(m_pti);
    delete this;
    return 0;
  }

  return m_cRefs;
}


//-----------------------------------------------------------------------------
// IProvideClassInfo
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CHeaders::GetClassInfo(ITypeInfo** ppti)
{
  DEBUG_ENTER((
    DBG_HEADERS,
    rt_hresult,
    "CHeaders::GetClassInfo",
    "this=%#x; ppti=%#x",
    this,
    ppti
    ));

  HRESULT hr = S_OK;

    if( ppti )
    {
      m_pti->AddRef();
      *ppti = m_pti;
    }
    else
    {
      hr = E_POINTER;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


//-----------------------------------------------------------------------------
// IObjectWithSite
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CHeaders::SetSite(IUnknown* pUnkSite)
{
  DEBUG_ENTER((
    DBG_HEADERS,
    rt_hresult,
    "CHeaders::SetSite",
    "this=%#x; pUnkSite=%#x",
    this,
    pUnkSite
    ));

  HRESULT            hr         = S_OK;
  IActiveScriptSite* pias       = NULL;
  IObjectWithSite*   pcontainer = NULL;

    if( !pUnkSite )
    {
      hr = E_INVALIDARG;
    }
    else
    {
      SAFERELEASE(m_pSite);
      SAFERELEASE(m_pti);

      m_pSite = pUnkSite;
      m_pSite->AddRef();

      hr = m_pSite->QueryInterface(IID_IObjectWithSite, (void**) &pcontainer);

      if( SUCCEEDED(hr) )
      {
        hr = pcontainer->GetSite(IID_IActiveScriptSite, (void**) &pias);

        if( SUCCEEDED(hr) )
        {
          hr = pias->GetItemInfo(
                       g_wszHeadersObjectName,
                       SCRIPTINFO_ITYPEINFO,
                       NULL,
                       &m_pti
                       );
        }
      }
    }

  SAFERELEASE(pcontainer);
  SAFERELEASE(pias);

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CHeaders::GetSite(REFIID riid, void** ppvSite)
{
  DEBUG_ENTER((
    DBG_HEADERS,
    rt_hresult,
    "CHeaders::GetSite",
    "this=%#x; riid=%s; ppvSite=%#x",
    this,
    MapIIDToString(riid),
    ppvSite
    ));

  HRESULT hr = S_OK;

    if( !ppvSite )
    {
      hr = E_POINTER;
    }
    else
    {
      hr = m_pSite->QueryInterface(riid, ppvSite);
    }

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\w3spoof\om\request\methods.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    methods.cxx

Abstract:

    Implements methods part of the Request object's dual interface.
    
Author:

    Paul M Midgen (pmidge) 03-November-2000


Revision History:

    03-November-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

HRESULT
__stdcall
CRequest::get_Parent(IDispatch **ppdisp)
{
  DEBUG_ENTER((
    DBG_REQUEST,
    rt_hresult,
    "CRequest::get_Parent",
    "this=%#x; ppdisp=%#x",
    this,
    ppdisp
    ));

  HRESULT hr = S_OK;

    if( !ppdisp )
    {
      hr = E_POINTER;
    }
    else
    {
      if( m_pSite )
      {
        hr = m_pSite->QueryInterface(IID_IDispatch, (void**) ppdisp);
      }
      else
      {
        *ppdisp = NULL;
        hr      = E_UNEXPECTED;
      }
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CRequest::get_Headers(IDispatch **ppdisp)
{
  DEBUG_ENTER((
    DBG_REQUEST,
    rt_hresult,
    "CRequest::get_Headers",
    "this=%#x; ppdisp=%#x",
    this,
    ppdisp
    ));

  HRESULT hr = S_OK;

    if( !ppdisp )
    {
      hr = E_POINTER;
    }
    else
    {
      if( m_headersobj )
      {
        hr = m_headersobj->QueryInterface(IID_IDispatch, (void**) ppdisp);
      }
      else
      {
        *ppdisp = NULL;
        hr      = E_UNEXPECTED;
      }
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CRequest::get_Entity(IDispatch **ppdisp)
{
  DEBUG_ENTER((
    DBG_REQUEST,
    rt_hresult,
    "CRequest::get_Entity",
    "this=%#x; ppdisp=%#x",
    this,
    ppdisp
    ));

  HRESULT hr = S_OK;

    if( !ppdisp )
    {
      hr = E_POINTER;
    }
    else
    {
      if( m_entityobj )
      {
        hr = m_entityobj->QueryInterface(IID_IDispatch, (void**) ppdisp);
      }
      else
      {
        *ppdisp = NULL;
        hr      = E_UNEXPECTED;
      }
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CRequest::get_Url(IDispatch **ppdisp)
{
  DEBUG_ENTER((
    DBG_REQUEST,
    rt_hresult,
    "CRequest::get_Url",
    "this=%#x; ppdisp=%#x",
    this,
    ppdisp
    ));

  HRESULT hr = S_OK;

    if( !ppdisp )
    {
      hr = E_POINTER;
    }
    else
    {
      if( m_urlobj )
      {
        hr = m_urlobj->QueryInterface(IID_IDispatch, (void**) ppdisp);
      }
      else
      {
        *ppdisp = NULL;
        hr      = E_UNEXPECTED;
      }
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CRequest::get_Verb(BSTR *Verb)
{
  DEBUG_ENTER((
    DBG_REQUEST,
    rt_hresult,
    "CRequest::get_Verb",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

    if( !Verb )
    {
      hr = E_POINTER;
    }
    else
    {
      *Verb = __widetobstr(m_wszVerb);
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CRequest::get_HttpVersion(BSTR *HttpVersion)
{
  DEBUG_ENTER((
    DBG_REQUEST,
    rt_hresult,
    "CRequest::get_HttpVersion",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

    if( !HttpVersion )
    {
      hr = E_POINTER;
    }
    else
    {
      *HttpVersion = __widetobstr(m_wszHTTPVersion);
    }

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\w3spoof\om\request\request.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    request.cxx

Abstract:

    Implements the Request object.
    
Author:

    Paul M Midgen (pmidge) 03-November-2000


Revision History:

    03-November-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

LPWSTR g_wszRequestObjectName = L"request";

//-----------------------------------------------------------------------------
// CRequest methods
//-----------------------------------------------------------------------------
CRequest::CRequest():
  m_cRefs(1),
  m_pSite(NULL),
  m_wszVerb(NULL),
  m_wszHTTPVersion(NULL),
  m_urlobj(NULL),
  m_headersobj(NULL),
  m_entityobj(NULL)
{
  DEBUG_TRACE(REQUEST, ("CRequest [%#x] created", this));
}


CRequest::~CRequest()
{
  DEBUG_TRACE(REQUEST, ("CRequest [%#x] deleted", this));
}


HRESULT
CRequest::Create(CHAR* request, DWORD len, PREQUESTOBJ* ppreq)
{
  DEBUG_ENTER((
    DBG_REQUEST,
    rt_hresult,
    "CRequest::Create",
    "request=%#x; len=%d; ppreq=%#x",
    request,
    len,
    ppreq
    ));

  HRESULT     hr  = S_OK;
  PREQUESTOBJ pro = NULL;

  if( !request || (len == 0) )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  if( !ppreq )
  {
    hr = E_POINTER;
    goto quit;
  }
  
  if( pro = new REQUESTOBJ )
  {
    if( SUCCEEDED(pro->_Initialize(request, len)) )
    {
      *ppreq = pro;
    }
    else
    {
      delete pro;
      *ppreq = NULL;
      hr     = E_FAIL;
    }
  }
  else
  {
    hr = E_OUTOFMEMORY;
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
CRequest::_Initialize(CHAR* request, DWORD len)
{
  DEBUG_ENTER((
    DBG_REQUEST,
    rt_hresult,
    "CRequest::_Initialize",
    "this=%#x; request=%#x; len=%d",
    this,
    request,
    len
    ));

  HRESULT hr            = S_OK;
  BOOL    bCracked      = FALSE;
  LPSTR*  arParts       = NULL;
  LPSTR   reqline       = NULL;
  LPSTR   headers       = NULL;
  LPSTR   entity        = NULL;
  DWORD   contentlength = 0L;


  bCracked = _CrackRequest(request, len, &reqline, &headers, &entity, &contentlength);

    if( !bCracked )
    {
      DEBUG_TRACE(REQUEST, ("failed to crack request data"));
      hr = E_FAIL;
      goto quit;
    }

  arParts = _CrackRequestLine(reqline, len);

    if( !arParts )
    {
      DEBUG_TRACE(REQUEST, ("failed to crack the request line"));
      hr = E_FAIL;
      goto quit;
    }
    else
    {
      m_wszVerb        = __ansitowide(arParts[0]);
      m_wszHTTPVersion = __ansitowide(arParts[2]);
    }

  hr = URLOBJ::Create(arParts[1], TRUE, &m_urlobj);

    if( FAILED(hr) )
    {
      DEBUG_TRACE(REQUEST, ("failed to create url object"));
      goto quit;
    }

  hr = HEADERSOBJ::Create(headers, TRUE, &m_headersobj);

    if( FAILED(hr) )
    {
      DEBUG_TRACE(REQUEST, ("failed to create headers object"));
      goto quit;
    }

  if( entity && contentlength )
  {
    hr = ENTITYOBJ::Create((LPBYTE) entity, contentlength, TRUE, &m_entityobj);
    
    if( FAILED(hr) )
    {
      DEBUG_TRACE(REQUEST, ("no entity object was created"));
      hr = S_OK;
    }
  }

quit:

  SAFEDELETEBUF(arParts);

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
CRequest::_SiteMemberObjects(void)
{
  HRESULT          hr    = NULL;
  IObjectWithSite* piows = NULL;

  if( m_urlobj )
  {
    hr = m_urlobj->QueryInterface(IID_IObjectWithSite, (void**) &piows);

      if( SUCCEEDED(hr) )
      {
        piows->SetSite(dynamic_cast<IRequest*>(this));
        SAFERELEASE(piows);
      }
      else
      {
        goto quit;
      }
  }

  if( m_headersobj )
  {
    hr = m_headersobj->QueryInterface(IID_IObjectWithSite, (void**) &piows);

    if( SUCCEEDED(hr) )
    {
      piows->SetSite(dynamic_cast<IRequest*>(this));
      SAFERELEASE(piows);
    }
    else
    {
      goto quit;
    }
  }

  if( m_entityobj )
  {
    hr = m_entityobj->QueryInterface(IID_IObjectWithSite, (void**) &piows);

    if( SUCCEEDED(hr) )
    {
      piows->SetSite(dynamic_cast<IRequest*>(this));
      SAFERELEASE(piows);
    }
  }

quit:

  return hr;
}


void
CRequest::_Cleanup(void)
{
  DEBUG_TRACE(REQUEST, ("CRequest [%#x] cleaning up", this));

  SAFEDELETEBUF(m_wszVerb);
  SAFEDELETEBUF(m_wszHTTPVersion);
}


void
CRequest::Terminate(void)
{
  DEBUG_TRACE(REQUEST, ("CRequest [%#x] terminating", this));

  SAFERELEASE(m_pSite);
  SAFETERMINATE(m_urlobj);
  SAFETERMINATE(m_headersobj);
  SAFETERMINATE(m_entityobj);
  Release();
}


BOOL
CRequest::_CrackRequest(LPSTR request, DWORD len, LPSTR* reqline, LPSTR* headers, LPSTR* entity, LPDWORD contentlength)
//
// what: null delimits the three major chunks of a request
//
// input: request       - the request buffer
//        len           - the length of the request buffer
//        reqline       - [out] the request line
//        headers       - [out] the header blob
//        entity        - [out] the entity blob
//        contentlength - [out] length of the entity blob
//
// returns: true if the request was processed, false if the request was empty
//
// request format: reqline CRLF headers CRLF CRLF entity
//
{
  BOOL  bCracked  = TRUE;
  LPSTR token     = NULL;
  DWORD bytesleft = 0L;

  if( request )
  {
    *reqline = request;
    token    = strstr(request, "\r\n");
    
    // get the request line, there MUST be one of these.
    if( token )
    {
      memset(token, '\0', 2);
      token       += 2;
      bytesleft    = len - (token-request);
      
      // get the request headers, they MUST exist.
      if( bytesleft )
      {
        *headers = token;
        token    = strstr(token, "\r\n\r\n");
      
        if( token )
        {
          // delimit the header blob and see if there's an entity...
          // there needn't be an entity for this function to succeed.
          memset(token, '\0', 4);
          token       += 4;
          bytesleft    = len - (token-request);

          *contentlength = bytesleft;

          if( bytesleft )
          {
            *entity = token;
          }
        }
      }
      else
      {
        DEBUG_TRACE(REQUEST, ("couldn\'t find the request headers!"));
        bCracked = FALSE;
      }
    }
    else
    {
      DEBUG_TRACE(REQUEST, ("couldn\'t find the request line!"));
      bCracked = FALSE;
    }
  }
  else
  {
    DEBUG_TRACE(REQUEST, ("can\'t crack empty request"));
    bCracked = FALSE;
  }

  return bCracked;
}


LPSTR*
CRequest::_CrackRequestLine(CHAR* buf, DWORD len)
//
// what: cracks the http request line from a buffered request
//
// input: buf - the request buffer
//        len - the length of the buffer, not the data
//
// returns: array of three string pointers to the null-delimited pieces
//
//          index 0 : verb
//          index 1 : url
//          index 2 : version
//
// request line format: verb SP url SP version CRLF
//
{
  LPSTR* arParts  = NULL;
  LPSTR  delim    = " \r\n";
  LPSTR  token    = NULL;
  BOOL   bCracked = FALSE;

  token = strtok(buf, delim);

  if( token )
  {
    arParts    = new LPSTR[3];
    arParts[0] = token;

    token = strtok(NULL, delim);

    if( token )
    {
      arParts[1] = token;
      token      = strtok(NULL, delim);

      if( token )
      {
        arParts[2] = token;
        bCracked   = TRUE;
      }
    }
  }

  if( !bCracked )
  {
    DEBUG_TRACE(REQUEST, ("failed to crack the request line!"));
    SAFEDELETEBUF(arParts);
  }

  return arParts;
}

//-----------------------------------------------------------------------------
// IUnknown
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CRequest::QueryInterface(REFIID riid, void** ppv)
{
  DEBUG_ENTER((
    DBG_REFCOUNT,
    rt_hresult,
    "CRequest::QueryInterface",
    "this=%#x; riid=%s; ppv=%#x",
    this,
    MapIIDToString(riid),
    ppv
    ));

  HRESULT hr = S_OK;

  if( !ppv )
  {
    hr = E_POINTER;
    goto quit;
  }

    if(
      IsEqualIID(riid, IID_IUnknown)  ||
      IsEqualIID(riid, IID_IDispatch) ||
      IsEqualIID(riid, IID_IRequest)
      )
    {
      *ppv = static_cast<IRequest*>(this);
    }
    else if( IsEqualIID(riid, IID_IObjectWithSite) )
    {
      *ppv = static_cast<IObjectWithSite*>(this);
    }
    else
    {
      *ppv = NULL;
      hr   = E_NOINTERFACE;
    }

  if( SUCCEEDED(hr) )
  {
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


ULONG
__stdcall
CRequest::AddRef(void)
{
  InterlockedIncrement(&m_cRefs);
  DEBUG_ADDREF("CRequest", m_cRefs);
  return m_cRefs;
}


ULONG
__stdcall
CRequest::Release(void)
{
  InterlockedDecrement(&m_cRefs);
  DEBUG_RELEASE("CRequest", m_cRefs);

  if( m_cRefs == 0 )
  {
    DEBUG_FINALRELEASE("CRequest");
    _Cleanup();
    delete this;
    return 0;
  }

  return m_cRefs;
}


//-----------------------------------------------------------------------------
// IProvideClassInfo
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CRequest::GetClassInfo(ITypeInfo** ppti)
{
  DEBUG_ENTER((
    DBG_REQUEST,
    rt_hresult,
    "CRequest::GetClassInfo",
    "this=%#x; ppti=%#x",
    this,
    ppti
    ));

  HRESULT            hr   = S_OK;
  IActiveScriptSite* pias = NULL;

  if( ppti )
  {
    if( m_pSite )
    {
      hr = m_pSite->QueryInterface(IID_IActiveScriptSite, (void**) &pias);

      if( SUCCEEDED(hr) )
      {
        hr = pias->GetItemInfo(
                     g_wszRequestObjectName,
                     SCRIPTINFO_ITYPEINFO,
                     NULL,
                     ppti
                     );
      }
    }
    else
    {
      hr = E_FAIL;
    }
  }
  else
  {
    hr = E_POINTER;
  }

  SAFERELEASE(pias);

  DEBUG_LEAVE(hr);
  return hr;
}


//-----------------------------------------------------------------------------
// IObjectWithSite
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CRequest::SetSite(IUnknown* pUnkSite)
{
  DEBUG_ENTER((
    DBG_REQUEST,
    rt_hresult,
    "CRequest::SetSite",
    "this=%#x; pUnkSite=%#x",
    this,
    pUnkSite
    ));

  HRESULT hr = S_OK;

    if( !pUnkSite )
    {
      hr = E_INVALIDARG;
    }
    else
    {
      SAFERELEASE(m_pSite);

      m_pSite = pUnkSite;
      m_pSite->AddRef();

      _SiteMemberObjects();
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CRequest::GetSite(REFIID riid, void** ppvSite)
{
  DEBUG_ENTER((
    DBG_REQUEST,
    rt_hresult,
    "CRequest::GetSite",
    "this=%#x; riid=%s; ppvSite=%#x",
    this,
    MapIIDToString(riid),
    ppvSite
    ));

  HRESULT hr = S_OK;

    if( !ppvSite )
    {
      hr = E_POINTER;
    }
    else
    {
      if( m_pSite )
      {
        hr = m_pSite->QueryInterface(riid, ppvSite);
      }
      else
      {
        hr = E_FAIL;
      }
    }

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\w3spoof\om\request\dispatch.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    dispatch.cxx

Abstract:

    Implements the IDispatch interface for the Request object.
    
Author:

    Paul M Midgen (pmidge) 03-November-2000


Revision History:

    03-November-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

//
// WARNING: do not modify these values. use disphash.exe to generate
//          new values.
//
DISPIDTABLEENTRY g_RequestDisptable[] =
{
  0x00021b1c,   DISPID_REQUEST_PARENT,      L"parent",
  0x000401cd,   DISPID_REQUEST_HEADERS,     L"headers",
  0x000213d4,   DISPID_REQUEST_ENTITY,      L"entity",
  0x0000417f,   DISPID_REQUEST_URL,         L"url",
  0x00008715,   DISPID_REQUEST_VERB,        L"verb",
  0x00448859,   DISPID_REQUEST_HTTPVERSION, L"httpversion"
};

DWORD g_cRequestDisptable = (sizeof(g_RequestDisptable) / sizeof(DISPIDTABLEENTRY));


//-----------------------------------------------------------------------------
// IDispatch
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CRequest::GetTypeInfoCount(UINT* pctinfo)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "CRequest::GetTypeInfoCount",
    "this=%#x; pctinfo=%#x",
    this,
    pctinfo
    ));

  HRESULT hr = S_OK;

    if( !pctinfo )
    {
      hr = E_POINTER;
    }
    else
    {
      *pctinfo = 1;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CRequest::GetTypeInfo(UINT index, LCID lcid, ITypeInfo** ppti)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "CRequest::GetTypeInfo",
    "this=%#x; index=%#x; lcid=%#x; ppti=%#x",
    this,
    index,
    lcid,
    ppti
    ));

  HRESULT hr = S_OK;

  if( !ppti )
  {
    hr = E_POINTER;
  }
  else
  {
    if( index != 0 )
    {
      hr    = DISP_E_BADINDEX;
      *ppti = NULL;
    }
    else
    {
      hr = GetClassInfo(ppti);
    }
  }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CRequest::GetIDsOfNames(REFIID riid, LPOLESTR* arNames, UINT cNames, LCID lcid, DISPID* arDispId)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "CRequest::GetIDsOfNames",
    "this=%#x; riid=%s; arNames=%#x; cNames=%d; lcid=%#x; arDispId=%#x",
    this,
    MapIIDToString(riid),
    arNames,
    cNames,
    lcid,
    arDispId
    ));

  HRESULT hr = S_OK;
  UINT    n  = 0L;

  if( !IsEqualIID(riid, IID_NULL) )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  while( n < cNames )
  {
    arDispId[n] = GetDispidFromName(g_RequestDisptable, g_cRequestDisptable, arNames[n]);
    ++n;
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CRequest::Invoke(DISPID dispid, REFIID riid, LCID lcid, WORD flags, DISPPARAMS* pdp, VARIANT* pvr, EXCEPINFO* pei, UINT* pae)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "CRequest::Invoke",
    "this=%#x; dispid=%s; riid=%s; lcid=%#x; flags=%#x; pdp=%#x; pvr=%#x; pei=%#x; pae=%#x",
    this,
    MapDispidToString(dispid),
    MapIIDToString(riid),
    lcid,
    flags,
    pdp, pvr,
    pei, pae
    ));

  HRESULT hr = S_OK;

  // make sure there aren't any bits set we don't understand
  if( flags & ~(DISPATCH_METHOD | DISPATCH_PROPERTYGET | DISPATCH_PROPERTYPUT) )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  if( !IsEqualIID(riid, IID_NULL) )
  {
    hr = DISP_E_UNKNOWNINTERFACE;
    goto quit;
  }

  if( !pdp )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  if( pae )
  {
    *pae = 0;
  }

  if( pvr )
  {
    VariantInit(pvr);
  }

  switch( dispid )
  {
    case DISPID_VALUE :
      {
        V_VT(pvr) = VT_DISPATCH;
        hr        = QueryInterface(IID_IDispatch, (void**) &V_DISPATCH(pvr));
      }
      break;

    case DISPID_REQUEST_PARENT :
      {
        V_VT(pvr) = VT_DISPATCH;
        hr        = get_Parent(&V_DISPATCH(pvr));

        if( hr == E_UNEXPECTED )
        {
          V_VT(pvr) = VT_NULL;
          hr        = S_OK;
        }
      }
      break;

    case DISPID_REQUEST_HEADERS :
      {
        V_VT(pvr) = VT_DISPATCH;
        hr        = get_Headers(&V_DISPATCH(pvr));

        if( hr == E_UNEXPECTED )
        {
          V_VT(pvr) = VT_NULL;
          hr        = S_OK;
        }
      }
      break;

    case DISPID_REQUEST_ENTITY :
      {
        V_VT(pvr) = VT_DISPATCH;
        hr        = get_Entity(&V_DISPATCH(pvr));

        if( hr == E_UNEXPECTED )
        {
          V_VT(pvr) = VT_NULL;
          hr        = S_OK;
        }
      }
      break;

    case DISPID_REQUEST_URL :
      {
        V_VT(pvr) = VT_DISPATCH;
        hr        = get_Url(&V_DISPATCH(pvr));

        if( hr == E_UNEXPECTED )
        {
          V_VT(pvr) = VT_NULL;
          hr        = S_OK;
        }
      }
      break;

    case DISPID_REQUEST_VERB :
      {
        V_VT(pvr) = VT_BSTR;
        hr        = get_Verb(&V_BSTR(pvr));
      }
      break;

    case DISPID_REQUEST_HTTPVERSION :
      {
        V_VT(pvr) = VT_BSTR;
        hr        = get_HttpVersion(&V_BSTR(pvr));
      }
      break;

    default :
    {
      hr = DISP_E_MEMBERNOTFOUND;
    }
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\w3spoof\om\response\dispatch.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    dispatch.cxx

Abstract:

    Implements the IDispatch interface for the Response object.
    
Author:

    Paul M Midgen (pmidge) 13-November-2000


Revision History:

    13-November-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

//
// WARNING: do not modify these values. use disphash.exe to generate
//          new values.
//
DISPIDTABLEENTRY g_ResponseDisptable[] =
{
  0x00021b1c,   DISPID_RESPONSE_PARENT,       L"parent",
  0x000401cd,   DISPID_RESPONSE_HEADERS,      L"headers",
  0x000213d4,   DISPID_RESPONSE_ENTITY,       L"entity",
  0x00235a1d,   DISPID_RESPONSE_STATUSCODE,   L"statuscode",
  0x00236646,   DISPID_RESPONSE_STATUSTEXT,   L"statustext"
};

DWORD g_cResponseDisptable = (sizeof(g_ResponseDisptable) / sizeof(DISPIDTABLEENTRY));


//-----------------------------------------------------------------------------
// IDispatch
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CResponse::GetTypeInfoCount(UINT* pctinfo)
{
  DEBUG_ENTER((
    DBG_RESPONSE,
    rt_hresult,
    "CResponse::GetTypeInfoCount",
    "this=%#x; pctinfo=%#x",
    this,
    pctinfo
    ));

  HRESULT hr = S_OK;

    if( !pctinfo )
    {
      hr = E_POINTER;
    }
    else
    {
      *pctinfo = 1;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CResponse::GetTypeInfo(UINT index, LCID lcid, ITypeInfo** ppti)
{
  DEBUG_ENTER((
    DBG_RESPONSE,
    rt_hresult,
    "CResponse::GetTypeInfo",
    "this=%#x; index=%#x; lcid=%#x; ppti=%#x",
    this,
    index,
    lcid,
    ppti
    ));

  HRESULT hr   = S_OK;

  if( !ppti )
  {
    hr = E_POINTER;
  }
  else
  {
    if( index != 0 )
    {
      hr    = DISP_E_BADINDEX;
      *ppti = NULL;
    }
    else
    {
      hr = GetClassInfo(ppti);
    }
  }

  if( FAILED(hr) )
  {
    *ppti = NULL;        
  }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CResponse::GetIDsOfNames(REFIID riid, LPOLESTR* arNames, UINT cNames, LCID lcid, DISPID* arDispId)
{
  DEBUG_ENTER((
    DBG_RESPONSE,
    rt_hresult,
    "CResponse::GetIDsOfNames",
    "this=%#x; riid=%s; arNames=%#x; cNames=%d; lcid=%#x; arDispId=%#x",
    this,
    MapIIDToString(riid),
    arNames,
    cNames,
    lcid,
    arDispId
    ));

  HRESULT hr = S_OK;
  UINT    n  = 0L;

  if( !IsEqualIID(riid, IID_NULL) )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  while( n < cNames )
  {
    arDispId[n] = GetDispidFromName(g_ResponseDisptable, g_cResponseDisptable, arNames[n]);
    ++n;
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CResponse::Invoke(DISPID dispid, REFIID riid, LCID lcid, WORD flags, DISPPARAMS* pdp, VARIANT* pvr, EXCEPINFO* pei, UINT* pae)
{
  DEBUG_ENTER((
    DBG_RESPONSE,
    rt_hresult,
    "CResponse::Invoke",
    "this=%#x; dispid=%s; riid=%s; lcid=%#x; flags=%#x; pdp=%#x; pvr=%#x; pei=%#x; pae=%#x",
    this,
    MapDispidToString(dispid),
    MapIIDToString(riid),
    lcid,
    flags,
    pdp, pvr,
    pei, pae
    ));

  HRESULT hr = S_OK;

  // make sure there aren't any bits set we don't understand
  if( flags & ~(DISPATCH_METHOD | DISPATCH_PROPERTYGET | DISPATCH_PROPERTYPUT) )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  if( !IsEqualIID(riid, IID_NULL) )
  {
    hr = DISP_E_UNKNOWNINTERFACE;
    goto quit;
  }

  if( !pdp )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  if( pae )
  {
    *pae = 0;
  }

  if( pvr )
  {
    VariantInit(pvr);
  }

  switch( dispid )
  {
    case DISPID_VALUE :
      {
        V_VT(pvr) = VT_DISPATCH;
        hr        = QueryInterface(IID_IDispatch, (void**) &V_DISPATCH(pvr));
      }
      break;

    case DISPID_RESPONSE_PARENT :
      {
        V_VT(pvr) = VT_DISPATCH;
        hr        = get_Parent(&V_DISPATCH(pvr));
      }
      break;

    //
    // TODO: implementation
    //
    
    default :
      {
        hr = DISP_E_MEMBERNOTFOUND;
      }
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\w3spoof\om\session\dispatch.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    dispatch.cxx

Abstract:

    Implements the IDispatch interface for the session object.
    
Author:

    Paul M Midgen (pmidge) 10-October-2000


Revision History:

    10-October-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

//
// WARNING: do not modify these values. use disphash.exe to generate
//          new values.
//
DISPIDTABLEENTRY g_SessionDisptable[] =
{
  0x00022b50,   DISPID_SESSION_SOCKET,         L"socket",
  0x00045386,   DISPID_SESSION_REQUEST,        L"request",
  0x0008a9a2,   DISPID_SESSION_RESPONSE,       L"response",
  0x020e7138,   DISPID_SESSION_GETPROPERTYBAG, L"getpropertybag",
  0x00106953,   DISPID_SESSION_KEEPALIVE,      L"keepalive"
};

DWORD g_cSessionDisptable = (sizeof(g_SessionDisptable) / sizeof(DISPIDTABLEENTRY));


HRESULT
__stdcall
CSession::GetTypeInfoCount(UINT* pctinfo)
{
  DEBUG_ENTER((
    DBG_SESSION,
    rt_hresult,
    "CSession::GetTypeInfoCount",
    "this=%#x; pctinfo=%#x",
    this,
    pctinfo
    ));

  HRESULT hr = S_OK;

    if( !pctinfo )
    {
      hr = E_POINTER;
    }
    else
    {
      *pctinfo = 1;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CSession::GetTypeInfo(UINT index, LCID lcid, ITypeInfo** ppti)
{
  DEBUG_ENTER((
    DBG_SESSION,
    rt_hresult,
    "CSession::GetTypeInfo",
    "this=%#x; index=%d; lcid=%#x; ppti=%#x",
    this,
    index,
    (LONG) lcid,
    ppti
    ));

  HRESULT hr = S_OK;

    if( !ppti )
    {
      hr = E_POINTER;
    }
    else
    {
      *ppti = NULL;

      if( index != 0 )
      {
        hr = DISP_E_BADINDEX;
      }
      else
      {
        hr = m_ptl->QueryInterface(IID_ITypeInfo, (void**) ppti);
      }
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CSession::GetIDsOfNames(REFIID riid, LPOLESTR* arNames, UINT cNames, LCID lcid, DISPID* arDispId)
{
  DEBUG_ENTER((
    DBG_SESSION,
    rt_hresult,
    "CSession::GetIDsOfNames",
    "this=%#x; riid=%s; arNames=%#x; cNames=%d; lcid=%#x; arDispId=%#x",
    this,
    MapIIDToString(riid),
    arNames,
    cNames,
    lcid,
    arDispId
    ));

  HRESULT hr = S_OK;
  UINT    n  = 0L;

  if( !IsEqualIID(riid, IID_NULL) )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  while( n < cNames )
  {
    arDispId[n] = GetDispidFromName(g_SessionDisptable, g_cSessionDisptable, arNames[n]);
    ++n;
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CSession::Invoke(DISPID dispid, REFIID riid, LCID lcid, WORD flags, DISPPARAMS* pdp, VARIANT* pvr, EXCEPINFO* pei, UINT* pae)
{
  DEBUG_ENTER((
    DBG_SESSION,
    rt_hresult,
    "CSession::Invoke",
    "this=%#x; dispid=%s; riid=%s; lcid=%#x; flags=%#x; pdp=%#x; pvr=%#x; pei=%#x; pae=%#x",
    this,
    MapDispidToString(dispid),
    MapIIDToString(riid),
    lcid, flags,
    pdp, pvr,
    pei, pae
    ));

  HRESULT hr = S_OK;

  hr = ValidateDispatchArgs(riid, pdp, pvr, pae);

    if( FAILED(hr) )
      goto quit;

  switch( dispid )
  {
    case DISPID_SESSION_SOCKET :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_PROPERTYGET, TRUE);

        if( SUCCEEDED(hr) )
        {
          V_VT(pvr) = VT_DISPATCH;
          hr        = get_Socket(&V_DISPATCH(pvr));
        }
      }
      break;

    case DISPID_SESSION_REQUEST :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_PROPERTYGET, TRUE);

        if( SUCCEEDED(hr) )
        {
          V_VT(pvr) = VT_DISPATCH;
          hr        = get_Request(&V_DISPATCH(pvr));
        }
      }
      break;

    case DISPID_SESSION_RESPONSE :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_PROPERTYGET, TRUE);

        if( SUCCEEDED(hr) )
        {
          V_VT(pvr) = VT_DISPATCH;
          hr        = get_Response(&V_DISPATCH(pvr));
        }
      }
      break;

    case DISPID_SESSION_GETPROPERTYBAG :
      {
        NEWVARIANT(name);

        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, FALSE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 0, TRUE, 1);

          if( SUCCEEDED(hr) )
          {
            hr = DispGetParam(pdp, 0, VT_BSTR, &name, pae);

              if( FAILED(hr) )
              {
                V_VT(&name)   = VT_BSTR;
                V_BSTR(&name) = SysAllocString(L"default");
                pae           = 0;
              }
              
            V_VT(pvr) = VT_DISPATCH;
            hr        = GetPropertyBag(name, &V_DISPATCH(pvr));

            VariantClear(&name);
          }
        }
      }
      break;

    case DISPID_SESSION_KEEPALIVE :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_PROPERTYGET, TRUE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 0, FALSE, 0);

          if( SUCCEEDED(hr) )
          {
            hr = get_KeepAlive(pvr);
          }
        }
      }
      break;

    default : hr = DISP_E_MEMBERNOTFOUND;
  }

quit:

  if( FAILED(hr) )
  {
    hr = HandleDispatchError(L"session object", pei, hr);
  }

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\w3spoof\om\response\response.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    response.cxx

Abstract:

    Implements the Response object.
    
Author:

    Paul M Midgen (pmidge) 13-November-2000


Revision History:

    13-November-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

LPWSTR g_wszResponseObjectName = L"response";

//-----------------------------------------------------------------------------
// CResponse methods
//-----------------------------------------------------------------------------
CResponse::CResponse():
  m_cRefs(1),
  m_pSite(NULL)
{
  DEBUG_TRACE(RESPONSE, ("CResponse created: %#x", this));
}


CResponse::~CResponse()
{
  //
  // TODO: implementation
  //

  DEBUG_TRACE(RESPONSE, ("CResponse deleted: %#x", this));
}


HRESULT
CResponse::Create(CHAR* response, DWORD len, PRESPONSEOBJ* ppresponse)
{
  DEBUG_ENTER((
    DBG_RESPONSE,
    rt_hresult,
    "CResponse::Create",
    "response=%#x; ppresponse=%#x",
    response,
    ppresponse
    ));

  HRESULT      hr  = S_OK;
  PRESPONSEOBJ pro = NULL;

  if( !response )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  if( !ppresponse )
  {
    hr = E_POINTER;
    goto quit;
  }
  
  if( pro = new RESPONSEOBJ )
  {
    if( SUCCEEDED(pro->_Initialize(response, len)) )
    {
      *ppresponse = pro;
    }
    else
    {
      delete pro;
      *ppresponse = NULL;
      hr          = E_FAIL;
    }
  }
  else
  {
    hr = E_OUTOFMEMORY;
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
CResponse::_Initialize(CHAR* response, DWORD len)
{
  DEBUG_ENTER((
    DBG_RESPONSE,
    rt_hresult,
    "CResponse::_Initialize",
    "this=%#x; response=%#x",
    this,
    response
    ));

  HRESULT hr = S_OK;

  //
  // TODO: implementation
  //
  
  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
CResponse::Terminate(void)
{
  DEBUG_ENTER((
    DBG_RESPONSE,
    rt_hresult,
    "CResponse::Terminate",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  //
  // TODO: implementation
  //

  SAFERELEASE(m_pSite);
  Release();
 
  DEBUG_LEAVE(hr);
  return hr;
}


//-----------------------------------------------------------------------------
// IUnknown
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CResponse::QueryInterface(REFIID riid, void** ppv)
{
  DEBUG_ENTER((
    DBG_REFCOUNT,
    rt_hresult,
    "CResponse::QueryInterface",
    "this=%#x; riid=%s; ppv=%#x",
    this,
    MapIIDToString(riid),
    ppv
    ));

  HRESULT hr = S_OK;

  if( !ppv )
  {
    hr = E_POINTER;
    goto quit;
  }

    if(
      IsEqualIID(riid, IID_IUnknown)  ||
      IsEqualIID(riid, IID_IDispatch) ||
      IsEqualIID(riid, IID_IResponse)
      )
    {
      *ppv = static_cast<IResponse*>(this);
    }
    else if( IsEqualIID(riid, IID_IObjectWithSite) )
    {
      *ppv = static_cast<IObjectWithSite*>(this);
    }
    else
    {
      *ppv = NULL;
      hr   = E_NOINTERFACE;
    }

  if( SUCCEEDED(hr) )
  {
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


ULONG
__stdcall
CResponse::AddRef(void)
{
  InterlockedIncrement(&m_cRefs);
  DEBUG_ADDREF("CResponse", m_cRefs);
  return m_cRefs;
}


ULONG
__stdcall
CResponse::Release(void)
{
  InterlockedDecrement(&m_cRefs);
  DEBUG_RELEASE("CResponse", m_cRefs);

  if( m_cRefs == 0 )
  {
    DEBUG_FINALRELEASE("CResponse");
    delete this;
    return 0;
  }

  return m_cRefs;
}


//-----------------------------------------------------------------------------
// IProvideClassInfo
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CResponse::GetClassInfo(ITypeInfo** ppti)
{
  DEBUG_ENTER((
    DBG_RESPONSE,
    rt_hresult,
    "CResponse::GetClassInfo",
    "this=%#x; ppti=%#x",
    this,
    ppti
    ));

  HRESULT            hr   = S_OK;
  IActiveScriptSite* pias = NULL;
  IObjectWithSite*   pcnt = NULL;
  IObjectWithSite*   pssn = NULL;

  if( ppti )
  {
    hr = m_pSite->QueryInterface(IID_IObjectWithSite, (void**) &pcnt);

    if( SUCCEEDED(hr) )
    {
      hr = pcnt->QueryInterface(IID_IObjectWithSite, (void**) &pssn);

      if( SUCCEEDED(hr) )
      {
        hr = pssn->QueryInterface(IID_IActiveScriptSite, (void**) &pias);

        if( SUCCEEDED(hr) )
        {
          hr = pias->GetItemInfo(
                       g_wszResponseObjectName,
                       SCRIPTINFO_ITYPEINFO,
                       NULL,
                       ppti
                       );
        }
      }
    }
  }
  else
  {
    hr = E_POINTER;
  }

  SAFERELEASE(pcnt);
  SAFERELEASE(pssn);
  SAFERELEASE(pias);

  DEBUG_LEAVE(hr);
  return hr;
}


//-----------------------------------------------------------------------------
// IObjectWithSite
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CResponse::SetSite(IUnknown* pUnkSite)
{
  DEBUG_ENTER((
    DBG_RESPONSE,
    rt_hresult,
    "CResponse::SetSite",
    "this=%#x; pUnkSite=%#x",
    this,
    pUnkSite
    ));

  HRESULT hr = S_OK;

    if( !pUnkSite )
    {
      hr = E_INVALIDARG;
    }
    else
    {
      SAFERELEASE(m_pSite);

      m_pSite = pUnkSite;
      m_pSite->AddRef();
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CResponse::GetSite(REFIID riid, void** ppvSite)
{
  DEBUG_ENTER((
    DBG_RESPONSE,
    rt_hresult,
    "CResponse::GetSite",
    "this=%#x; riid=%s; ppvSite=%#x",
    this,
    MapIIDToString(riid),
    ppvSite
    ));

  HRESULT hr = S_OK;

    if( !ppvSite )
    {
      hr = E_POINTER;
    }
    else
    {
      hr = m_pSite->QueryInterface(riid, ppvSite);
    }

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\w3spoof\om\response\methods.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    methods.cxx

Abstract:

    Implements methods part of the Response object's dual interface.
    
Author:

    Paul M Midgen (pmidge) 13-November-2000


Revision History:

    13-November-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

HRESULT
__stdcall
CResponse::get_Parent(IDispatch **ppdisp)
{
  DEBUG_ENTER((
    DBG_RESPONSE,
    rt_hresult,
    "CResponse::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CResponse::get_Headers(IDispatch **ppdisp)
{
  DEBUG_ENTER((
    DBG_RESPONSE,
    rt_hresult,
    "CResponse::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CResponse::putref_Headers(IDispatch **ppdisp)
{
  DEBUG_ENTER((
    DBG_RESPONSE,
    rt_hresult,
    "CResponse::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CResponse::get_Entity(IDispatch **ppdisp)
{
  DEBUG_ENTER((
    DBG_RESPONSE,
    rt_hresult,
    "CResponse::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CResponse::putref_Entity(IDispatch **ppdisp)
{
  DEBUG_ENTER((
    DBG_RESPONSE,
    rt_hresult,
    "CResponse::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CResponse::get_StatusCode(VARIANT *Code)
{
  DEBUG_ENTER((
    DBG_RESPONSE,
    rt_hresult,
    "CResponse::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CResponse::put_StatusCode(VARIANT StatusCode)
{
  DEBUG_ENTER((
    DBG_RESPONSE,
    rt_hresult,
    "CResponse::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CResponse::get_StatusText(BSTR *StatusText)
{
  DEBUG_ENTER((
    DBG_RESPONSE,
    rt_hresult,
    "CResponse::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CResponse::put_StatusText(BSTR StatusText)
{
  DEBUG_ENTER((
    DBG_RESPONSE,
    rt_hresult,
    "CResponse::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\w3spoof\om\session\methods.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    methods.cxx

Abstract:

    Implements methods part of the Session object's dual interface.
    
Author:

    Paul M Midgen (pmidge) 24-October-2000


Revision History:

    24-October-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

HRESULT
__stdcall
CSession::get_Socket(IDispatch** ppdisp)
{
  DEBUG_ENTER((
    DBG_SESSION,
    rt_hresult,
    "CSession::get_Socket",
    "this=%#x; ppdisp=%#x",
    this,
    ppdisp
    ));

  HRESULT hr = S_OK;

    if( !ppdisp )
    {
      hr = E_POINTER;
    }
    else
    {
      *ppdisp = NULL;

      if( m_socketobj )
      {
        hr = m_socketobj->QueryInterface(IID_IDispatch, (void**) ppdisp);
      }
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CSession::get_Request(IDispatch** ppdisp)
{
  DEBUG_ENTER((
    DBG_SESSION,
    rt_hresult,
    "CSession::get_Request",
    "this=%#x; ppdisp=%#x",
    this,
    ppdisp
    ));

  HRESULT hr = S_OK;

    if( !ppdisp )
    {
      hr = E_POINTER;
    }
    else
    {
      *ppdisp = NULL;

      if( m_requestobj )
      {
        hr = m_requestobj->QueryInterface(IID_IDispatch, (void**) ppdisp);
      }
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CSession::get_Response(IDispatch** ppdisp)
{
  DEBUG_ENTER((
    DBG_SESSION,
    rt_hresult,
    "CSession::get_Response",
    "this=%#x; ppdisp=%#x",
    this,
    ppdisp
    ));

  HRESULT hr = S_OK;

    if( !ppdisp )
    {
      hr = E_POINTER;
    }
    else
    {
      *ppdisp = NULL;
      //hr = m_responseobj->QueryInterface(IID_IDispatch, (void**) ppdisp);
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CSession::GetPropertyBag(VARIANT Name, IDispatch** ppdisp)
{
  DEBUG_ENTER((
    DBG_SESSION,
    rt_hresult,
    "CSession::GetPropertyBag",
    "this=%#x; name=%S; ppdisp=%#x",
    this,
    V_BSTR(&Name),
    ppdisp
    ));

  HRESULT              hr      = S_OK;
  BSTR                 bagname = NULL;
  WCHAR*               buf     = NULL;
  DWORD                len     = 0L;
  IW3SpoofRuntime*     prt     = NULL;
  IW3SpoofPropertyBag* pbag    = NULL;

    if( !ppdisp )
    {
      hr = E_POINTER;
    }
    else
    {
      hr = m_pw3s->GetRuntime(&prt);

        if( SUCCEEDED(hr) )
        {
          //
          // "Name" is passed in by the script, something like "foo" or whatever. We
          //  combine that string with the client name and stuff the result in
          //  "bagname". This is how we avoid name collisions between different clients
          // running the same script.
          //

          len = (SysStringLen(V_BSTR(&Name)) + wcslen(m_wszClient))+2; // : & NULL
          buf = new WCHAR[len];

          wsprintfW(buf, L"%s:%s", m_wszClient, V_BSTR(&Name));
      
          bagname = __widetobstr(buf);
          hr      = prt->GetPropertyBag(bagname, &pbag);

          if( SUCCEEDED(hr) )
          {
            hr = pbag->QueryInterface(IID_IDispatch, (void**) ppdisp);
          }
        }

      SysFreeString(bagname);
      SAFEDELETEBUF(buf);
      SAFERELEASE(prt);
      SAFERELEASE(pbag);
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CSession::get_KeepAlive(VARIANT* IsKA)
{
  DEBUG_ENTER((
    DBG_SESSION,
    rt_hresult,
    "CSession::get_KeepAlive",
    "this=%#x; IsKA=%#x",
    this,
    IsKA
    ));

  HRESULT hr = S_OK;

    if( !IsKA )
    {
      hr = E_POINTER;
    }
    else
    {
      V_VT(IsKA)   = VT_BOOL;
      V_BOOL(IsKA) = m_bIsKeepAlive ? VARIANT_TRUE : VARIANT_FALSE;
    }

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\w3spoof\om\session\session.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    session.cxx

Abstract:

    Implements the session object.
    
Author:

    Paul M Midgen (pmidge) 10-October-2000


Revision History:

    10-October-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

extern LPWSTR g_wszRuntimeObjectName;

LPWSTR g_wszSessionObjectName = L"session";
LPWSTR g_arHandlerNames[]     =
{
  L"OnConnect",
  L"OnDataAvailable",
  L"OnRequest",
  L"OnResponse",
  L"OnClose"
};

//-----------------------------------------------------------------------------
// CSession methods
//-----------------------------------------------------------------------------
CSession::CSession():
  m_cRefs(1),
  m_wszClient(NULL),
  m_wszClientId(NULL),
  m_bIsKeepAlive(TRUE),
  m_CurrentHandler(Global),
  m_ptl(NULL),
  m_pw3s(NULL),
  m_pas(NULL),
  m_psd(NULL),
  m_lcid(0),
  m_socketobj(NULL),
  m_requestobj(NULL),
  m_responseobj(NULL),
  m_objstate(ST_CREATED)
{
  DEBUG_TRACE(SESSION, ("CSession created: %#x", this));
}


CSession::~CSession()
{
  DEBUG_TRACE(SESSION, ("CSession deleted: %#x", this));
  DEBUG_ASSERT((m_objstate == ST_CLOSED));
}


HRESULT
CSession::Create(PIOCTX pioc, IW3Spoof* pw3s)
{
  DEBUG_ENTER((
    DBG_SESSION,
    rt_hresult,
    "CSession::Create",
    "pioc=%#x; pw3s=%#x",
    pioc,
    pw3s
    ));

  HRESULT   hr   = S_OK;
  CSession* pssn = NULL;

  if( !(pioc && pw3s) )
  {
    hr = E_INVALIDARG;
  }
  else
  {
    if( pssn = new SESSIONOBJ )
    {
      if( SUCCEEDED(pssn->_Initialize(pioc, pw3s)) )
      {
        pioc->session = pssn;
      }
      else
      {
        DEBUG_TRACE(SESSION, ("ERROR! nuking uninitialized session object"));
        pssn->_SetObjectState(ST_ERROR);
        pssn->Terminate();
        hr = E_FAIL;
      }
    }
    else
    {
      hr = E_OUTOFMEMORY;
    }
  }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
CSession::_Initialize(PIOCTX pioc, IW3Spoof* pw3s)
{
  DEBUG_ENTER((
    DBG_SESSION,
    rt_hresult,
    "CSession::_Initialize",
    "this=%#x; pioc=%#x; pw3s=%#x",
    this,
    pioc,
    pw3s
    ));

  HRESULT hr = S_OK;

  if( m_objstate == ST_CREATED )
  {
    InitializeCriticalSection(&m_lock);

    m_wszClient   = __ansitowide(pioc->remote->name);
    m_wszClientId = __wstrdup(pioc->clientid);
    m_lcid        = GetThreadLocale();
    m_pw3s        = pw3s;
    m_pw3s->AddRef();

    _SetObjectState(ST_OPENING);

      hr = m_pw3s->GetTypeLibrary(&m_ptl);

        if( FAILED(hr) )
          goto quit;

      hr = _InitSocketObject(pioc);

        if( FAILED(hr) )
          goto quit;

      hr = m_pw3s->GetScriptEngine(&m_pas);

        if( FAILED(hr) )
          goto quit;

      hr = _SetScriptSite(FALSE);

        if( FAILED(hr) )
          goto quit;

      hr = _InitScriptEngine();

        if( FAILED(hr) )
          goto quit;

      hr = _LoadScript();

        if( FAILED(hr) )
          goto quit;
        
      hr = _LoadScriptDispids();

        if( FAILED(hr) )
          goto quit;

    _SetObjectState(ST_OPEN);
    _SetNextServerState(SS_START_STATE);
  }
  else
  {
    hr = E_UNEXPECTED;
  } 

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
CSession::Terminate(void)
{
  DEBUG_ENTER((
    DBG_SESSION,
    rt_hresult,
    "CSession::Terminate",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  _SetObjectState(ST_CLOSING);

    m_pas->Close();
    SAFERELEASE(m_psd);
    SAFERELEASE(m_pas);
    SAFERELEASE(m_ptl);

    SAFEDELETEBUF(m_wszClient);
 
    SAFETERMINATE(m_requestobj);
    m_requestobj = NULL;

    //SAFETERMINATE(m_responseobj);
    // m_responseobj = NULL;

    SAFETERMINATE(m_socketobj);
    m_socketobj = NULL;

    _Unlock();
    DeleteCriticalSection(&m_lock);

  //
  // once this call and the implicit notification to the w3spoof object completes,
  // the session is an orphan. this is the point of no return.
  //
  _SetObjectState(ST_CLOSED);

  SAFEDELETEBUF(m_wszClientId);
  SAFERELEASE(m_pw3s);

  //
  // one bogus case that will result in this assert popping is when multiple
  // outstanding references to the script engine are held in this process. the
  // way the script engine does garbage collection will usually result in a couple
  // of 'dead' sessions lying about for a while. they all get cleaned up when the
  // final ref to the script engine server is released.
  //
  DEBUG_ASSERT((m_cRefs == 1));

  Release();

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
CSession::Run(PIOCTX pioc)
//
// Session FSM
//
// This is the session object FSM. Worker threads 'run' each server OM through this function.
// When this function returns the server should be in a state where i/o is completing asynchronously.
// All other states are optimized to be handled without the OM relinquishing the worker thread.
//
// Only one thread at a time can run a given OM, so we lock the OM when the FSM is entered.
//
// Anywhere you see 'goto next_state', you're in a non-default state transition handler. This is an
// optimized case where we immediately process the pending state instead of waiting for a completion
// event to trigger an FSM call. These cases are caused by the user calling socket.send, recv or close
// from script.
//
// Script-based socket I/O calls don't generate completions. In the event the call would overlap, we
// wait because asynchronous script coding would make a seemingly simple task unnecessarily hard.
//
{
  DEBUG_ENTER((
    DBG_SESSION,
    rt_hresult,
    "CSession::Run",
    "this=%#x; pioc=%#x",
    this,
    pioc
    ));

  HRESULT     hr     = S_OK;
  SERVERSTATE st     = SS_START_STATE;
  UINT        argerr = 0L;
  DISPPARAMS  dp     = {0};
  NEWVARIANT(vr);

  _Lock();

    // if an io error occurred when we dequeued from the thread pool,
    // the io context's error field will be set.
    if( pioc->error != ERROR_SUCCESS )
    {
      DEBUG_TRACE(SESSION, ("session fsm detected error %s", MapErrorToString(pioc->error)));

      switch( pioc->error )
      {
        case ERROR_NETNAME_DELETED :
          {
            DEBUG_TRACE(SESSION, ("client dropped connection"));
            _SetNextServerState(SS_SOCKET_DISCONNECTED);
          }
          break;

        case ERROR_OPERATION_ABORTED :
          {
            DEBUG_TRACE(SESSION, ("pending io (%s) aborted", MapIOTYPEToString(pioc->Type())));
            _SetNextServerState(SS_SOCKET_DISCONNECTED);
          }
          break;

        default :
          {
            DEBUG_TRACE(SESSION, ("error not handled"));
            _SetNextServerState(SS_SOCKET_DISCONNECTED);
          }
      }
    }

    _SetScriptSite(TRUE);

next_state:

    st = m_socketobj->GetServerState();
    DEBUG_TRACE(SESSION, ("executing server state %s", MapStateToString(st)));

    switch( st )
    {
      case SS_SOCKET_CONNECTED :
        {
          //===========================================
          // state   : SS_SOCKET_CONNECTED
          //
          // follows : new connections only
          //
          // next    : default  - SS_REQUEST_PENDING
          //           on send  - SS_RESPONSE_COMPLETE
          //           on recv  - SS_REQUEST_COMPLETE
          //           on close - SS_SOCKET_DISCONNECTED
          //===========================================
          m_CurrentHandler = OnConnect;

          if( VALIDDISPID(m_arHandlerDispids[m_CurrentHandler]) )
          {
            hr = m_psd->Invoke(
                          m_arHandlerDispids[m_CurrentHandler],
                          IID_NULL, m_lcid,
                          DISPATCH_METHOD,
                          &dp, &vr, NULL, &argerr
                          );

            if( FAILED(hr) )
            {
              DEBUG_TRACE(SESSION, ("aborting fsm due to script error"));
              goto terminate;
            }
          }

          if( !_SetNextServerState(SS_SOCKET_CONNECTED) )
          {
            goto next_state;
          }
          else
          {
            PIOCTX pioc = new IOCTX(IOCT_RECV, INVALID_SOCKET);

            if( pioc )
            {
              pioc->clientid = m_wszClientId;
              pioc->session  = this;
              hr             = m_socketobj->Run(pioc);
            }
            else
            {
              DEBUG_TRACE(SESSION, ("terminating due to low-memory condition"));
              hr = E_OUTOFMEMORY;
              goto terminate;
            }
          }
        }
        break;

      case SS_REQUEST_PENDING :
        {
          //===========================================
          // state   : SS_REQUEST_PENDING
          //
          // follows : default  - SS_SOCKET_CONNECTED
          //           other    - SS_RESPONSE_COMPLETE
          //
          // next    : default  - SS_REQUEST_COMPLETE
          //           on send  - SS_RESPONSE_COMPLETE
          //           on recv  - SS_REQUEST_COMPLETE
          //           on close - SS_SOCKET_DISCONNECTED
          //===========================================
          m_CurrentHandler = OnDataAvailable;

          if( VALIDDISPID(m_arHandlerDispids[m_CurrentHandler]) )
          {
            hr = m_psd->Invoke(
                          m_arHandlerDispids[m_CurrentHandler],
                          IID_NULL, m_lcid,
                          DISPATCH_METHOD,
                          &dp, &vr, NULL, &argerr
                          );

            if( FAILED(hr) )
            {
              DEBUG_TRACE(SESSION, ("aborting fsm due to script error"));
              goto terminate;
            }
          }

          if( !_SetNextServerState(SS_REQUEST_PENDING) )
          {
            goto next_state;  
          }
        }

      case SS_REQUEST_COMPLETE :
        {
          //===========================================
          // state   : SS_REQUEST_COMPLETE
          //
          // follows : default  - SS_REQUEST_PENDING
          //           other    - SS_SOCKET_CONNECTED
          //
          // next    : default  - SS_RESPONSE_PENDING
          //           on send  - SS_RESPONSE_COMPLETE
          //           on recv  - disallowed
          //           on close - SS_SOCKET_DISCONNECTED
          //===========================================

          _SetKeepAlive(pioc);

          hr               = _InitRequestObject();
          m_CurrentHandler = OnRequest;

          if( SUCCEEDED(hr) )
          {
            if( VALIDDISPID(m_arHandlerDispids[m_CurrentHandler]) )
            {
              hr = m_psd->Invoke(
                            m_arHandlerDispids[m_CurrentHandler],
                            IID_NULL, m_lcid,
                            DISPATCH_METHOD,
                            &dp, &vr, NULL, &argerr
                            );

              if( FAILED(hr) )
              {
                DEBUG_TRACE(SESSION, ("aborting fsm due to script error"));
                goto terminate;
              }
            }
          }

          if( !_SetNextServerState(SS_REQUEST_COMPLETE) )
          {
            goto next_state;
          }
        }

      case SS_RESPONSE_PENDING :
        {
          //===========================================
          // state   : SS_RESPONSE_PENDING
          //
          // follows : default  - SS_REQUEST_COMPLETE
          //           other    - SS_SOCKET_CONNECTED
          //
          // next    : default  - SS_RESPONSE_COMPLETE
          //           on send  - SS_RESPONSE_COMPLETE
          //           on recv  - disallowed
          //           on close - SS_SOCKET_DISCONNECTED
          //===========================================

          //
          // TODO: create response object
          //

          m_CurrentHandler = OnResponse;

          if( VALIDDISPID(m_arHandlerDispids[m_CurrentHandler]) )
          {
            hr = m_psd->Invoke(
                          m_arHandlerDispids[m_CurrentHandler],
                          IID_NULL, m_lcid,
                          DISPATCH_METHOD,
                          &dp, &vr, NULL, &argerr
                          );

            if( FAILED(hr) )
            {
              DEBUG_TRACE(SESSION, ("aborting fsm due to script error"));
              goto terminate;
            }
          }

          if( !_SetNextServerState(SS_RESPONSE_PENDING) )
          {
            goto next_state;
          }
          else
          {
            //
            // TODO: stuff default response info into an io context
            //       and send it, queueing a send, then bail.
            //
            hr = m_socketobj->Run(NULL);
          }
        }
        break;

      case SS_RESPONSE_COMPLETE :
        {
          if( m_bIsKeepAlive )
          {
            PIOCTX pioc = new IOCTX(IOCT_RECV, INVALID_SOCKET);

            if( pioc )
            {
              _SetNextServerState(SS_RESPONSE_COMPLETE);

              pioc->clientid = m_wszClientId;
              pioc->session  = this;
              hr             = m_socketobj->Run(pioc);
            }
            else
            {
              DEBUG_TRACE(SESSION, ("terminating due to low-memory condition"));
              hr = E_OUTOFMEMORY;
              goto terminate;
            }
          }
          else
          {
            _SetNextServerState(SS_SOCKET_DISCONNECTED);
            goto next_state;
          }
        }
        break;

      case SS_SOCKET_DISCONNECTED :
        {
          m_CurrentHandler = OnClose;

          if( VALIDDISPID(m_arHandlerDispids[m_CurrentHandler]) )
          {
            hr = m_psd->Invoke(
                          m_arHandlerDispids[m_CurrentHandler],
                          IID_NULL, m_lcid,
                          DISPATCH_METHOD,
                          &dp, &vr, NULL, &argerr
                          );
          }
          
          goto terminate;
        }
        break;
    }

    _ResetScriptEngine();

  _Unlock();

quit:
  
  DEBUG_LEAVE(hr);
  return hr;

terminate: 

  Terminate();
  goto quit;
}


HRESULT
CSession::_InitSocketObject(PIOCTX pioc)
{
  DEBUG_ENTER((
    DBG_REQUEST,
    rt_hresult,
    "CSession::_InitSocketObject",
    "this=%#x; pioc=%#x",
    this,
    pioc
    ));

  HRESULT          hr    = S_OK;
  IObjectWithSite* piows = NULL;

    if( SUCCEEDED(SOCKETOBJ::Create(pioc, &m_socketobj)) )
    {
      m_socketobj->QueryInterface(
                     IID_IObjectWithSite,
                     (void**) &piows
                     );
      
      piows->SetSite(dynamic_cast<ISession*>(this));
    }
    else
    {
      DEBUG_TRACE(SESSION, ("failed to create socket object"));
      hr = E_FAIL;
    }

  SAFERELEASE(piows);

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
CSession::_InitRequestObject(void)
{
  DEBUG_ENTER((
    DBG_REQUEST,
    rt_hresult,
    "CSession::_InitRequestObject",
    "this=%#x",
    this
    ));

  HRESULT          hr    = S_OK;
  WSABUF*          pwb   = NULL;
  IObjectWithSite* piows = NULL;

  // terminate previous request object, if there is one
  SAFETERMINATE(m_requestobj);
  m_requestobj = NULL;

  m_socketobj->GetRecvBuffer(&pwb);
  
    if( SUCCEEDED(REQUESTOBJ::Create(pwb->buf, m_socketobj->GetBytesReceived(), &m_requestobj)) )
    {
      m_requestobj->QueryInterface(
                      IID_IObjectWithSite,
                      (void**) &piows
                      );
      
      piows->SetSite(dynamic_cast<ISession*>(this));
    }
    else
    {
      DEBUG_TRACE(SESSION, ("failed to create request object"));
      hr = E_FAIL;
    }

  SAFERELEASE(piows);

  DEBUG_LEAVE(hr);
  return hr;
}


BOOL
CSession::_SetNextServerState(SERVERSTATE state)
{
  SERVERSTATE s_current = m_socketobj->GetServerState();
  SERVERSTATE s_new;

  if( state == SS_SOCKET_DISCONNECTED )
  {
    m_socketobj->SetServerState(state);
    return TRUE;
  }

  if( s_current == state )
  {
    switch( state )
    {
      case SS_START_STATE :
        {
          s_new = SS_SOCKET_CONNECTED;          
        }
        break;

      case SS_SOCKET_CONNECTED :
        {
          s_new = SS_REQUEST_PENDING;          
        }
        break;

      case SS_REQUEST_PENDING :
        {
          s_new = SS_REQUEST_COMPLETE;          
        }
        break;

      case SS_REQUEST_COMPLETE :
        {
          s_new = SS_RESPONSE_PENDING;          
        }
        break;

      case SS_RESPONSE_PENDING :
        {
          s_new = SS_RESPONSE_COMPLETE;
        }
        break;

      case SS_RESPONSE_COMPLETE :
        {
          s_new = SS_REQUEST_PENDING;          
        }
        break;
    }

    m_socketobj->SetServerState(s_new);
    return TRUE;
  }

  return FALSE;
}


HRESULT
CSession::_InitScriptEngine(void)
{
  DEBUG_ENTER((
    DBG_SESSION,
    rt_hresult,
    "CSession::_InitScriptEngine",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  hr = m_pas->AddNamedItem(
         g_wszSessionObjectName,
         SCRIPTITEM_ISPERSISTENT | SCRIPTITEM_ISVISIBLE
         );

    if( FAILED(hr) )
      goto quit;

  hr = m_pas->AddNamedItem(
         g_wszRuntimeObjectName,
         SCRIPTITEM_ISPERSISTENT | SCRIPTITEM_ISVISIBLE | SCRIPTITEM_GLOBALMEMBERS
         );

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
CSession::_LoadScript(void)
{
  DEBUG_ENTER((
    DBG_SESSION,
    rt_hresult,
    "CSession::_LoadScript",
    "this=%#x",
    this
    ));

  HRESULT             hr         = S_OK;
  LPWSTR              scriptpath = NULL;
  IActiveScriptParse* parse      = NULL;
  IW3SpoofFile*       pw3sf      = NULL;
  EXCEPINFO           excepinfo;
  NEWVARIANT(scriptdata);
  
  hr = m_pw3s->GetScriptPath(m_wszClient, &scriptpath);

    if( FAILED(hr) )
      goto quit;

  if( SUCCEEDED(FILEOBJ::Create(&pw3sf)) )
  {
    BSTR path = __widetobstr(scriptpath);
    NEWVARIANT(mode);

    V_VT(&mode)  = VT_UI4;
    V_UI4(&mode) = OPEN_EXISTING;

    if( SUCCEEDED(pw3sf->Open(path, mode, NULL)) )
    {
      if( FAILED(pw3sf->ReadAll(&scriptdata)) )
      {
        hr = E_FAIL;
      }

      pw3sf->Close();
    }
    else
    {
      hr = E_FAIL;
    }

    SysFreeString(path);
    VariantClear(&mode);
  }
  
    if( FAILED(hr) )
      goto quit;

  hr = m_pas->QueryInterface(IID_IActiveScriptParse, (void**) &parse);

    if( FAILED(hr) )
      goto quit;

  hr = parse->ParseScriptText(
               V_BSTR(&scriptdata),
               NULL,
               NULL,
               NULL,
               (DWORD) this,
               0,
               SCRIPTTEXT_ISPERSISTENT | SCRIPTTEXT_ISVISIBLE,
               NULL,
               &excepinfo
               );
  
    if( FAILED(hr) )
      goto quit;

  hr = m_pas->SetScriptState(SCRIPTSTATE_STARTED);

    if( FAILED(hr) )
    {
      DEBUG_TRACE(SESSION, ("error starting script engine, probably a script error: %s", MapHResultToString(hr)));
      goto quit;
    }

quit:

  SAFERELEASE(pw3sf);
  SAFERELEASE(parse);
  VariantClear(&scriptdata);

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
CSession::_LoadScriptDispids(void)
{
  DEBUG_ENTER((
    DBG_SESSION,
    rt_hresult,
    "_LoadScriptDispids",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  SAFERELEASE(m_psd);

  hr = m_pas->GetScriptDispatch(NULL, &m_psd);

    if( FAILED(hr) )
    {
      DEBUG_TRACE(SESSION, ("error getting script dispatch"));
      goto quit;
    }

  for(DWORD n=0; n<SCRIPTHANDLERS; n++)
  {
    hr = m_psd->GetIDsOfNames(
                  IID_NULL,
                  &g_arHandlerNames[n], 1,
                  m_lcid,
                  &m_arHandlerDispids[n]
                  );

    if( SUCCEEDED(hr) )
    {
      DEBUG_TRACE(SESSION, ("found %S handler", g_arHandlerNames[n]));
    }
  }

  // fix up the error code. since we made it this far, the only thing
  // to have gone wrong is that a handler wasn't found. spoof can run
  // with no handlers implemented so this isn't a bad thing to ignore.
  hr = S_OK;

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
CSession::_SetScriptSite(BOOL bClone)
{
  DEBUG_ENTER((
    DBG_SESSION,
    rt_hresult,
    "_SetScriptSite",
    "this=%#x; bClone=%d",
    this,
    bClone
    ));

  HRESULT hr = S_OK;

  DEBUG_TRACE(SESSION, ("setting script site"));
  hr = m_pas->SetScriptSite(dynamic_cast<IActiveScriptSite*>(this));
    
  if( bClone )
  {
    DEBUG_TRACE(SESSION, ("starting cloned engine"));
    hr = m_pas->SetScriptState(SCRIPTSTATE_STARTED);
    hr = _LoadScriptDispids();
  }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
CSession::_ResetScriptEngine(void)
{
  DEBUG_ENTER((
    DBG_SESSION,
    rt_hresult,
    "_ResetScriptEngine",
    "this=%#x",
    this
    ));

  HRESULT        hr  = S_OK;
  IActiveScript* pas = NULL;

  if( m_pas )
  {
    hr = m_pas->Clone(&pas);

    if( SUCCEEDED(hr) )
    {
      hr = m_pas->Close();

      if( SUCCEEDED(hr) )
      {
        SAFERELEASE(m_pas);
        m_pas            = pas;
        m_CurrentHandler = Global;
      }
    }
  }

  DEBUG_LEAVE(hr);
  return hr;
}


void
CSession::_SetObjectState(STATE state)
{
  if( m_objstate != ST_ERROR )
  {
    DEBUG_TRACE(SESSION, ("session object state now %s", MapStateToString(state)));
    m_objstate = state;
    m_pw3s->Notify(m_wszClientId, this, state);
  }
}


void
CSession::_SetKeepAlive(PIOCTX pioc)
{
  DEBUG_ENTER((
    DBG_SESSION,
    rt_void,
    "_SetKeepAlive",
    "this=%#x; pioc=%#x",
    this,
    pioc
    ));

  LPSTR term = strstr(pioc->pwsa->buf, "\r\n\r\n");
  LPSTR tmp  = NULL;

  //
  // keep-alive decision is based on:
  //
  // if http/1.0 && connection: keep-alive then k-a.
  // if http/1.0 && !(connection: keep-alive) then !k-a.
  // if http/1.1 && connection: keep-alive then k-a.
  // if http/1.1 && connection: close then !k-a.
  // if http/1.1 && !(connection) then k-a.
  //

  if( term )
  {
    term[0] = '\0';
    tmp     = __strdup(pioc->pwsa->buf);
    term[0] = '\r';
    
    if( tmp )
    {
      _strlwr(tmp);

      if( strstr(tmp, "connection") )
      {
        m_bIsKeepAlive = strstr(tmp, "keep-alive") ? TRUE : FALSE;
      }
      else
      {
        m_bIsKeepAlive = strstr(tmp, "http/1.1") ? TRUE : FALSE;
      }
    }
  }

  DEBUG_TRACE(
    SESSION,
    ("session is %s", m_bIsKeepAlive ? "keep alive" : "not keep alive")
    );

  SAFEDELETEBUF(tmp);
  DEBUG_LEAVE(0);
}


void
CSession::_Lock(void)
{
  if( m_objstate != ST_CLOSED )
  {
    EnterCriticalSection(&m_lock);
    DEBUG_TRACE(SESSION, ("session [%#x] locked", this));
    return;
  }

  DEBUG_TRACE(SESSION, ("attempt to lock session in ST_CLOSED!!"));
}


void
CSession::_Unlock(void)
{
  if( m_objstate != ST_CLOSED )
  {
    DEBUG_TRACE(SESSION, ("session [%#x] unlocked", this));
    LeaveCriticalSection(&m_lock);
    return;
  }

  DEBUG_TRACE(SESSION, ("attempt to lock session in ST_CLOSED!!"));
}


//-----------------------------------------------------------------------------
// IUnknown
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CSession::QueryInterface(REFIID riid, void** ppv)
{
  DEBUG_ENTER((
    DBG_REFCOUNT,
    rt_hresult,
    "CSession::QueryInterface",
    "this=%#x; riid=%s; ppv=%#x",
    this,
    MapIIDToString(riid),
    ppv
    ));

  HRESULT hr = S_OK;

  if( !ppv )
  {
    hr = E_POINTER;
    goto quit;
  }

  if( !((m_objstate >= ST_OPENING) && (m_objstate <= ST_CLOSING)) )
  {
    *ppv = NULL;
    hr   = E_FAIL;
    goto quit;
  }

    if(
      IsEqualIID(riid, IID_IUnknown) ||
      IsEqualIID(riid, IID_IDispatch) ||
      IsEqualIID(riid, IID_ISession)
      )
    {
      *ppv = static_cast<ISession*>(this);
    }
    else if( IsEqualIID(riid, IID_IProvideClassInfo) )
    {
      *ppv = static_cast<IProvideClassInfo*>(this);
    }
    else if( IsEqualIID(riid, IID_IActiveScriptSite) )
    {
      *ppv = static_cast<IActiveScriptSite*>(this);
    }
    else
    {
      *ppv = NULL;
      hr   = E_NOINTERFACE;
    }

  if( SUCCEEDED(hr) )
  {
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


ULONG
__stdcall
CSession::AddRef(void)
{
  InterlockedIncrement(&m_cRefs);
  DEBUG_ADDREF("CSession", m_cRefs);
  return m_cRefs;
}


ULONG
__stdcall
CSession::Release(void)
{
  InterlockedDecrement(&m_cRefs);
  DEBUG_RELEASE("CSession", m_cRefs);

  if( m_cRefs == 0 )
  {
    DEBUG_FINALRELEASE("CSession");
    delete this;
    return 0;
  }

  return m_cRefs;
}


//-----------------------------------------------------------------------------
// IProvideClassInfo
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CSession::GetClassInfo(ITypeInfo** ppti)
{
  DEBUG_ENTER((
    DBG_SESSION,
    rt_hresult,
    "CSession::GetClassInfo",
    "this=%#x; ppti=%#x",
    this,
    ppti
    ));

  HRESULT hr = S_OK;

    if( ppti )
    {
      hr = GetTypeInfoFromName(g_wszSessionObjectName, m_ptl, ppti);
    }
    else
    {
      hr = E_POINTER;
    }

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\w3spoof\om\url\dispatch.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    dispatch.cxx

Abstract:

    Implements the IDispatch interface for the Url object.
    
Author:

    Paul M Midgen (pmidge) 10-November-2000


Revision History:

    10-November-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

//
// WARNING: do not modify these values. use disphash.exe to generate
//          new values.
//
DISPIDTABLEENTRY g_UrlDisptable[] =
{
  0x00021b1c,   DISPID_URL_PARENT,      L"parent",
  0x00082181,   DISPID_URL_ENCODING,    L"encoding",
  0x00021d6b,   DISPID_URL_SCHEME,      L"scheme",
  0x00022ba1,   DISPID_URL_SERVER,      L"server",
  0x000087f5,   DISPID_URL_PORT,        L"port",
  0x000082c3,   DISPID_URL_PATH,        L"path",
  0x0008aae1,   DISPID_URL_RESOURCE,    L"resource",
  0x000117c9,   DISPID_URL_QUERY,       L"query",
  0x000835fa,   DISPID_URL_FRAGMENT,    L"fragment",
  0x00020a65,   DISPID_URL_ESCAPE,      L"escape",
  0x0008c90f,   DISPID_URL_UNESCAPE,    L"unescape",
  0x00003f5f,   DISPID_URL_SET,         L"set",
  0x00003b7b,   DISPID_URL_GET,         L"get"
};

DWORD g_cUrlDisptable = (sizeof(g_UrlDisptable) / sizeof(DISPIDTABLEENTRY));

//-----------------------------------------------------------------------------
// IDispatch
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CUrl::GetTypeInfoCount(UINT* pctinfo)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "CUrl::GetTypeInfoCount",
    "this=%#x; pctinfo=%#x",
    this,
    pctinfo
    ));

  HRESULT hr = S_OK;

    if( !pctinfo )
    {
      hr = E_POINTER;
    }
    else
    {
      *pctinfo = 1;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CUrl::GetTypeInfo(UINT index, LCID lcid, ITypeInfo** ppti)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "CUrl::GetTypeInfo",
    "this=%#x; index=%#x; lcid=%#x; ppti=%#x",
    this,
    index,
    lcid,
    ppti
    ));

  HRESULT hr   = S_OK;

  if( !ppti )
  {
    hr = E_POINTER;
  }
  else
  {
    if( index != 0 )
    {
      hr    = DISP_E_BADINDEX;
      *ppti = NULL;
    }
    else
    {
      hr = GetClassInfo(ppti);
    }
  }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CUrl::GetIDsOfNames(REFIID riid, LPOLESTR* arNames, UINT cNames, LCID lcid, DISPID* arDispId)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "CUrl::GetIDsOfNames",
    "this=%#x; riid=%s; arNames=%#x; cNames=%d; lcid=%#x; arDispId=%#x",
    this,
    MapIIDToString(riid),
    arNames,
    cNames,
    lcid,
    arDispId
    ));

  HRESULT hr = S_OK;
  UINT    n  = 0L;

  if( !IsEqualIID(riid, IID_NULL) )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  while( n < cNames )
  {
    arDispId[n] = GetDispidFromName(g_UrlDisptable, g_cUrlDisptable, arNames[n]);
    ++n;
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CUrl::Invoke(DISPID dispid, REFIID riid, LCID lcid, WORD flags, DISPPARAMS* pdp, VARIANT* pvr, EXCEPINFO* pei, UINT* pae)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "CUrl::Invoke",
    "this=%#x; dispid=%s; riid=%s; lcid=%#x; flags=%#x; pdp=%#x; pvr=%#x; pei=%#x; pae=%#x",
    this,
    MapDispidToString(dispid),
    MapIIDToString(riid),
    lcid,
    flags,
    pdp, pvr,
    pei, pae
    ));

  HRESULT hr = S_OK;

  hr = ValidateDispatchArgs(riid, pdp, pvr, pae);

    if( FAILED(hr) )
      goto quit;

  switch( dispid )
  {
    case DISPID_URL_PARENT :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_PROPERTYGET, TRUE);

        if( SUCCEEDED(hr) )
        {
          V_VT(pvr) = VT_DISPATCH;
          hr        = get_Parent(&V_DISPATCH(pvr));
        }
      }
      break;

    case DISPID_URL_ENCODING :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_PROPERTYGET, TRUE);

        if( SUCCEEDED(hr) )
        {
          V_VT(pvr) = VT_BSTR;
          hr        = get_Encoding(&V_BSTR(pvr));
        }
      }
      break;

    case DISPID_URL_SCHEME :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_PROPERTYPUT | DISPATCH_PROPERTYGET, TRUE);

        if( SUCCEEDED(hr) )
        {
          if( flags & DISPATCH_PROPERTYPUT )
          {
            hr = ValidateArgCount(pdp, 1, FALSE, 0);

            if( SUCCEEDED(hr) )
            {
              hr = put_Scheme(
                     V_BSTR(&pdp->rgvarg[0])
                     );
            }
          }

          if( (flags & DISPATCH_PROPERTYGET) && SUCCEEDED(hr) )
          {
            V_VT(pvr) = VT_BSTR;
            hr        = get_Scheme(
                          &V_BSTR(pvr)
                          );
          }
        }
      }
      break;

    case DISPID_URL_SERVER :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_PROPERTYPUT | DISPATCH_PROPERTYGET, TRUE);

        if( SUCCEEDED(hr) )
        {
          if( flags & DISPATCH_PROPERTYPUT )
          {
            hr = ValidateArgCount(pdp, 1, FALSE, 0);

            if( SUCCEEDED(hr) )
            {
              hr = put_Server(
                     V_BSTR(&pdp->rgvarg[0])
                     );
            }
          }

          if( (flags & DISPATCH_PROPERTYGET) && SUCCEEDED(hr) )
          {
            V_VT(pvr) = VT_BSTR;
            hr        = get_Server(
                          &V_BSTR(pvr)
                          );
          }
        }
      }
      break;

    case DISPID_URL_PORT :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_PROPERTYPUT | DISPATCH_PROPERTYGET, TRUE);

        if( SUCCEEDED(hr) )
        {
          if( flags & DISPATCH_PROPERTYPUT )
          {
            hr = ValidateArgCount(pdp, 1, FALSE, 0);

            if( SUCCEEDED(hr) )
            {
              hr = put_Port(pdp->rgvarg[0]);
            }
          }

          if( (flags & DISPATCH_PROPERTYGET) && SUCCEEDED(hr) )
          {
            V_VT(pvr) = VT_UI2;
            hr        = get_Port(pvr);
          }
        }
      }
      break;

    case DISPID_URL_PATH :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_PROPERTYPUT | DISPATCH_PROPERTYGET, TRUE);

        if( SUCCEEDED(hr) )
        {
          if( flags & DISPATCH_PROPERTYPUT )
          {
            hr = ValidateArgCount(pdp, 1, FALSE, 0);

            if( SUCCEEDED(hr) )
            {
              hr = put_Path(
                     V_BSTR(&pdp->rgvarg[0])
                     );
            }
          }

          if( (flags & DISPATCH_PROPERTYGET) && SUCCEEDED(hr) )
          {
            V_VT(pvr) = VT_BSTR;
            hr        = get_Path(
                          &V_BSTR(pvr)
                          );
          }
        }
      }
      break;

    case DISPID_URL_RESOURCE :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_PROPERTYPUT | DISPATCH_PROPERTYGET, TRUE);

        if( SUCCEEDED(hr) )
        {
          if( flags & DISPATCH_PROPERTYPUT )
          {
            hr = ValidateArgCount(pdp, 1, FALSE, 0);

            if( SUCCEEDED(hr) )
            {
              hr = put_Resource(
                     V_BSTR(&pdp->rgvarg[0])
                     );
            }
          }

          if( (flags & DISPATCH_PROPERTYGET) && SUCCEEDED(hr) )
          {
            V_VT(pvr) = VT_BSTR;
            hr        = get_Resource(
                          &V_BSTR(pvr)
                          );
          }
        }
      }
      break;

    case DISPID_URL_QUERY :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_PROPERTYPUT | DISPATCH_PROPERTYGET, TRUE);

        if( SUCCEEDED(hr) )
        {
          if( flags & DISPATCH_PROPERTYPUT )
          {
            hr = ValidateArgCount(pdp, 1, FALSE, 0);

            if( SUCCEEDED(hr) )
            {
              hr = put_Query(
                     V_BSTR(&pdp->rgvarg[0])
                     );
            }
          }

          if( (flags & DISPATCH_PROPERTYGET) && SUCCEEDED(hr) )
          {
            V_VT(pvr) = VT_BSTR;
            hr        = get_Query(
                          &V_BSTR(pvr)
                          );
          }
        }
      }
      break;

    case DISPID_URL_FRAGMENT :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_PROPERTYPUT | DISPATCH_PROPERTYGET, TRUE);

        if( SUCCEEDED(hr) )
        {
          if( flags & DISPATCH_PROPERTYPUT )
          {
            hr = ValidateArgCount(pdp, 1, FALSE, 0);

            if( SUCCEEDED(hr) )
            {
              hr = put_Fragment(
                     V_BSTR(&pdp->rgvarg[0])
                     );
            }
          }

          if( (flags & DISPATCH_PROPERTYGET) && SUCCEEDED(hr) )
          {
            V_VT(pvr) = VT_BSTR;
            hr        = get_Fragment(
                          &V_BSTR(pvr)
                          );
          }
        }
      }
      break;

    case DISPID_URL_GET :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, FALSE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 0, FALSE, 0);

          if( SUCCEEDED(hr) )
          {
            if( pvr )
            {
              V_VT(pvr) = VT_BSTR;
              hr        = Get(&V_BSTR(pvr));
            }
          }
        }
      }
      break;

    case DISPID_URL_SET :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, FALSE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 1, FALSE, 0);

          if( SUCCEEDED(hr) )
          {
            hr = Set(
                   V_BSTR(&pdp->rgvarg[0])
                   );
          }
        }
      }
      break;

    case DISPID_URL_ESCAPE :
    case DISPID_URL_UNESCAPE :
      {
        hr = E_NOTIMPL;
      }
      break;

    default : hr = DISP_E_MEMBERNOTFOUND;
  }

quit:

  if( FAILED(hr) )
  {
    hr = HandleDispatchError(L"url object", pei, hr);
  }

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\w3spoof\om\url\methods.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    methods.cxx

Abstract:

    Implements methods part of the Url object's dual interface.
    
Author:

    Paul M Midgen (pmidge) 10-November-2000


Revision History:

    10-November-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

HRESULT
__stdcall
CUrl::get_Parent(IDispatch **ppdisp)
{
  DEBUG_ENTER((
    DBG_URL,
    rt_hresult,
    "CUrl::get_Parent",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

    if( m_pSite )
    {
      hr = m_pSite->QueryInterface(IID_IDispatch, (void**) ppdisp);
    }
    else
    {
      hr = E_UNEXPECTED;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CUrl::get_Encoding(BSTR *Encoding)
{
  DEBUG_ENTER((
    DBG_URL,
    rt_hresult,
    "CUrl::get_Encoding",
    "this=%#x",
    this
    ));

  HRESULT hr = E_NOTIMPL;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CUrl::get_Scheme(BSTR *Scheme)
{
  DEBUG_ENTER((
    DBG_URL,
    rt_hresult,
    "CUrl::get_Scheme",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

    if( Scheme )
    {
      *Scheme = __widetobstr(m_wszScheme);
    }
    else
    {
      hr = E_POINTER;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CUrl::put_Scheme(BSTR Scheme)
{
  DEBUG_ENTER((
    DBG_URL,
    rt_hresult,
    "CUrl::put_Scheme",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

    if( !m_bReadOnly )
    {
      SAFEDELETEBUF(m_wszScheme);

      m_wszScheme = __wstrdup(Scheme);
    }
    else
    {
      hr = E_ACCESSDENIED;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CUrl::get_Server(BSTR *Server)
{
  DEBUG_ENTER((
    DBG_URL,
    rt_hresult,
    "CUrl::get_Server",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

    if( Server )
    {
      *Server = __widetobstr(m_wszServer);
    }
    else
    {
      hr = E_POINTER;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CUrl::put_Server(BSTR Server)
{
  DEBUG_ENTER((
    DBG_URL,
    rt_hresult,
    "CUrl::put_Server",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

    if( !m_bReadOnly )
    {
      SAFEDELETEBUF(m_wszServer);

      m_wszServer = __wstrdup(Server);
    }
    else
    {
      hr = E_ACCESSDENIED;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CUrl::get_Port(VARIANT *Port)
{
  DEBUG_ENTER((
    DBG_URL,
    rt_hresult,
    "CUrl::get_Port",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

    if( Port )
    {
      V_UI2(Port) = m_usPort;
    }
    else
    {
      hr = E_POINTER;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CUrl::put_Port(VARIANT Port)
{
  DEBUG_ENTER((
    DBG_URL,
    rt_hresult,
    "CUrl::put_Port",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

    if( !m_bReadOnly )
    {
      m_usPort = V_UI2(&Port);
    }
    else
    {
      hr = E_ACCESSDENIED;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CUrl::get_Path(BSTR *Path)
{
  DEBUG_ENTER((
    DBG_URL,
    rt_hresult,
    "CUrl::get_Path",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

    if( Path )
    {
      *Path = __widetobstr(m_wszPath);
    }
    else
    {
      hr = E_POINTER;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CUrl::put_Path(BSTR Path)
{
  DEBUG_ENTER((
    DBG_URL,
    rt_hresult,
    "CUrl::put_Path",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

    if( !m_bReadOnly )
    {
      SAFEDELETEBUF(m_wszPath);

      m_wszPath = __wstrdup(Path);
    }
    else
    {
      hr = E_ACCESSDENIED;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CUrl::get_Resource(BSTR *Resource)
{
  DEBUG_ENTER((
    DBG_URL,
    rt_hresult,
    "CUrl::get_Resource",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

    if( Resource )
    {
      *Resource = __widetobstr(m_wszResource);
    }
    else
    {
      hr = E_POINTER;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CUrl::put_Resource(BSTR Resource)
{
  DEBUG_ENTER((
    DBG_URL,
    rt_hresult,
    "CUrl::put_Resource",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

    if( !m_bReadOnly )
    {
      SAFEDELETEBUF(m_wszResource);

      m_wszResource = __wstrdup(Resource);
    }
    else
    {
      hr = E_ACCESSDENIED;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CUrl::get_Query(BSTR *Query)
{
  DEBUG_ENTER((
    DBG_URL,
    rt_hresult,
    "CUrl::get_Query",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

    if( Query )
    {
      *Query = __widetobstr(m_wszQuery);
    }
    else
    {
      hr = E_POINTER;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CUrl::put_Query(BSTR Query)
{
  DEBUG_ENTER((
    DBG_URL,
    rt_hresult,
    "CUrl::put_Query",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

    if( !m_bReadOnly )
    {
      SAFEDELETEBUF(m_wszQuery);

      m_wszQuery = __wstrdup(Query);
    }
    else
    {
      hr = E_ACCESSDENIED;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CUrl::get_Fragment(BSTR *Fragment)
{
  DEBUG_ENTER((
    DBG_URL,
    rt_hresult,
    "CUrl::get_Fragment",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

    if( Fragment )
    {
      *Fragment = __widetobstr(m_wszFragment);
    }
    else
    {
      hr = E_POINTER;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CUrl::put_Fragment(BSTR Fragment)
{
  DEBUG_ENTER((
    DBG_URL,
    rt_hresult,
    "CUrl::put_Fragment",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

    if( !m_bReadOnly )
    {
      SAFEDELETEBUF(m_wszFragment);

      m_wszFragment = __wstrdup(Fragment);
    }
    else
    {
      hr = E_ACCESSDENIED;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CUrl::Escape(BSTR *Url)
{
  DEBUG_ENTER((
    DBG_URL,
    rt_hresult,
    "CUrl::Escape",
    "this=%#x",
    this
    ));

  HRESULT hr = E_NOTIMPL;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CUrl::Unescape(BSTR *Url)
{
  DEBUG_ENTER((
    DBG_URL,
    rt_hresult,
    "CUrl::Unescape",
    "this=%#x",
    this
    ));

  HRESULT hr = E_NOTIMPL;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CUrl::Set(BSTR Url)
{
  DEBUG_ENTER((
    DBG_URL,
    rt_hresult,
    "CUrl::Set",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

    if( !m_bReadOnly )
    {
      LPSTR szUrl;

      _Cleanup();

      szUrl = __widetoansi(Url);
      hr    = _Initialize(szUrl, FALSE);

      SAFEDELETEBUF(szUrl);
    }
    else
    {
      hr = E_ACCESSDENIED;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CUrl::Get(BSTR* Url)
{
  DEBUG_ENTER((
    DBG_URL,
    rt_hresult,
    "CUrl::Get",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

    if( Url )
    {
      *Url = __widetobstr(m_wszUrl);
    }
    else
    {
      hr = E_POINTER;
    }

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\w3spoof\om\socket\dispatch.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    dispatch.cxx

Abstract:

    Implements the IDispatch interface for the socket object.
    
Author:

    Paul M Midgen (pmidge) 23-October-2000


Revision History:

    23-October-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

// from socket.cxx
extern LPWSTR g_wszSocketObjectName;


//
// WARNING: do not modify these values. use disphash.exe to generate
//          new values.
//
DISPIDTABLEENTRY g_SocketDisptable[] =
{
  0x00021b1c,   DISPID_SOCKET_PARENT,           L"parent",
  0x000084ab,   DISPID_SOCKET_SEND,             L"send",
  0x000083b3,   DISPID_SOCKET_RECV,             L"recv",
  0x00022de1,   DISPID_SOCKET_OPTION,           L"option",
  0x00010203,   DISPID_SOCKET_CLOSE,            L"close",
  0x000453c0,   DISPID_SOCKET_RESOLVE,          L"resolve",
  0x0010bcf1,   DISPID_SOCKET_LOCALNAME,        L"localname",
  0x00857183,   DISPID_SOCKET_LOCALADDRESS,     L"localaddress",
  0x0010c4d0,   DISPID_SOCKET_LOCALPORT,        L"localport",
  0x00225479,   DISPID_SOCKET_REMOTENAME,       L"remotename",
  0x01120dce,   DISPID_SOCKET_REMOTEADDRESS,    L"remoteaddress",
  0x00225c58,   DISPID_SOCKET_REMOTEPORT,       L"remoteport"
};

DWORD g_cSocketDisptable = (sizeof(g_SocketDisptable) / sizeof(DISPIDTABLEENTRY));


//-----------------------------------------------------------------------------
// IDispatch
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CSocket::GetTypeInfoCount(UINT* pctinfo)
{
  DEBUG_ENTER((
    DBG_SOCKET,
    rt_hresult,
    "CSocket::GetTypeInfoCount",
    "this=%#x; pctinfo=%#x",
    this,
    pctinfo
    ));

  HRESULT hr = S_OK;

    if( !pctinfo )
    {
      hr = E_POINTER;
    }
    else
    {
      *pctinfo = 1;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CSocket::GetTypeInfo(UINT index, LCID lcid, ITypeInfo** ppti)
{
  DEBUG_ENTER((
    DBG_SOCKET,
    rt_hresult,
    "CSocket::GetTypeInfo",
    "this=%#x; index=%#x; lcid=%#x; ppti=%#x",
    this,
    index,
    lcid,
    ppti
    ));

  HRESULT            hr   = S_OK;
  IActiveScriptSite* pias = NULL;

  if( !ppti )
  {
    hr = E_POINTER;
  }
  else
  {
    if( index != 0 )
    {
      hr = DISP_E_BADINDEX;
    }
    else
    {
      m_pSite->QueryInterface(IID_IActiveScriptSite, (void**) &pias);

      hr = pias->GetItemInfo(
             g_wszSocketObjectName,
             SCRIPTINFO_ITYPEINFO,
             NULL,
             ppti
             );
    }
  }

  if( FAILED(hr) )
  {
    *ppti = NULL;
  }

  SAFERELEASE(pias);

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CSocket::GetIDsOfNames(REFIID riid, LPOLESTR* arNames, UINT cNames, LCID lcid, DISPID* arDispId)
{
  DEBUG_ENTER((
    DBG_SOCKET,
    rt_hresult,
    "CSocket::GetIDsOfNames",
    "this=%#x; riid=%s; arNames=%#x; cNames=%d; lcid=%#x; arDispId=%#x",
    this,
    MapIIDToString(riid),
    arNames,
    cNames,
    lcid,
    arDispId
    ));

  HRESULT hr = S_OK;
  UINT    n  = 0L;

  if( !IsEqualIID(riid, IID_NULL) )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  while( n < cNames )
  {
    arDispId[n] = GetDispidFromName(g_SocketDisptable, g_cSocketDisptable, arNames[n]);
    ++n;
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CSocket::Invoke(DISPID dispid, REFIID riid, LCID lcid, WORD flags, DISPPARAMS* pdp, VARIANT* pvr, EXCEPINFO* pei, UINT* pae)
{
  DEBUG_ENTER((
    DBG_SOCKET,
    rt_hresult,
    "CSocket::Invoke",
    "this=%#x; dispid=%s; riid=%s; lcid=%#x; flags=%#x; pdp=%#x; pvr=%#x; pei=%#x; pae=%#x",
    this,
    MapDispidToString(dispid),
    MapIIDToString(riid),
    lcid,
    flags,
    pdp, pvr,
    pei, pae
    ));

  HRESULT hr = S_OK;

  hr = ValidateDispatchArgs(riid, pdp, pvr, pae);

    if( FAILED(hr) )
      goto quit;

  switch( dispid )
  {
    case DISPID_SOCKET_PARENT :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_PROPERTYGET, TRUE);

        if( SUCCEEDED(hr) )
        {
          V_VT(pvr) = VT_DISPATCH;
          hr        = get_Parent(&V_DISPATCH(pvr));
        }
      }
      break;

    case DISPID_SOCKET_SEND :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, FALSE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 1, FALSE, 0);

          if( SUCCEEDED(hr) )
          {
            hr = Send(pdp->rgvarg[0]);
          }
        }
      }
      break;

    case DISPID_SOCKET_RECV :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, FALSE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 0, FALSE, 0);

          if( SUCCEEDED(hr) )
          {
            hr = Recv(pvr);
          }
        }
      }
      break;
    
    case DISPID_SOCKET_CLOSE :
      {
        NEWVARIANT(method);

        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, FALSE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 0, TRUE, 1);

          if( SUCCEEDED(hr) )
          {
            hr = DispGetParam(pdp, 0, VT_BOOL, &method, pae);

              if( FAILED(hr) )
              {
                V_VT(&method)   = VT_BOOL;
                V_BOOL(&method) = TRUE;
                pae             = 0;
              }
              
            hr = Close(method);
            VariantClear(&method);
          }
        }
      }
      break;

    case DISPID_SOCKET_RESOLVE :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, FALSE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 1, FALSE, 0);

          if( SUCCEEDED(hr) )
          {
            if( pvr )
            {
              V_VT(pvr) = VT_BSTR;
              hr        = Resolve(V_BSTR(&pdp->rgvarg[0]), &V_BSTR(pvr));
            }
          }
        }
      }
      break;

    case DISPID_SOCKET_LOCALNAME :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_PROPERTYGET, TRUE);

        if( SUCCEEDED(hr) )
        {
          V_VT(pvr) = VT_BSTR;
          hr        = get_LocalName(&V_BSTR(pvr));
        }
      }
      break;

    case DISPID_SOCKET_LOCALADDRESS :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_PROPERTYGET, TRUE);

        if( SUCCEEDED(hr) )
        {
          V_VT(pvr) = VT_BSTR;
          hr        = get_LocalAddress(&V_BSTR(pvr));
        }
      }
      break;

    case DISPID_SOCKET_LOCALPORT :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_PROPERTYGET, TRUE);

        if( SUCCEEDED(hr) )
        {
          hr = get_LocalPort(pvr);
        }
      }
      break;

    case DISPID_SOCKET_REMOTENAME :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_PROPERTYGET, TRUE);

        if( SUCCEEDED(hr) )
        {
          V_VT(pvr) = VT_BSTR;
          hr        = get_RemoteName(&V_BSTR(pvr));
        }
      }
      break;

    case DISPID_SOCKET_REMOTEADDRESS :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_PROPERTYGET, TRUE);

        if( SUCCEEDED(hr) )
        {
          V_VT(pvr) = VT_BSTR;
          hr        = get_RemoteAddress(&V_BSTR(pvr));
        }
      }
      break;

    case DISPID_SOCKET_REMOTEPORT :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_PROPERTYGET, TRUE);

        if( SUCCEEDED(hr) )
        {
          hr = get_RemotePort(pvr);
        }
      }
      break;

    case DISPID_SOCKET_OPTION :
      {
        hr = E_NOTIMPL;
      }
      break;

    default : hr = DISP_E_MEMBERNOTFOUND;
  }

quit:

  if( FAILED(hr) )
  {
    hr = HandleDispatchError(L"socket object", pei, hr);
  }

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\w3spoof\om\socket\socket.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    Socket.cxx

Abstract:

    Implements the Socket object.
    
Author:

    Paul M Midgen (pmidge) 23-October-2000


Revision History:

    23-October-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

LPWSTR g_wszSocketObjectName = L"socket";


//-----------------------------------------------------------------------------
// CSocket methods
//-----------------------------------------------------------------------------
CSocket::CSocket():
  m_cRefs(1),
  m_socket(INVALID_SOCKET),
  m_local(NULL),
  m_remote(NULL),
  m_rcvd(NULL),
  m_sent(NULL),
  m_pSite(NULL),
  m_wszClientId(NULL),
  m_serverstate(SS_START_STATE),
  m_objstate(ST_CREATED)
{
  DEBUG_TRACE(SOCKET, ("CSocket created: %#x", this));
}


CSocket::~CSocket()
{
  DEBUG_TRACE(SOCKET, ("CSocket deleted: %#x", this));
  DEBUG_ASSERT((m_objstate == ST_CLOSED));
}


HRESULT
CSocket::Create(PIOCTX pioc, PSOCKETOBJ* ppsocketobj)
{
  DEBUG_ENTER((
    DBG_SOCKET,
    rt_hresult,
    "CSocket::Create",
    "pioc=%#x; ppsocketobj=%#x",
    pioc,
    ppsocketobj
    ));

  HRESULT    hr  = S_OK;
  PSOCKETOBJ pso = NULL;

  if( !pioc )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  if( !ppsocketobj )
  {
    hr = E_POINTER;
    goto quit;
  }
  
  if( pso = new SOCKETOBJ )
  {
    if( SUCCEEDED(pso->_Initialize(pioc)) )
    {
      *ppsocketobj = pso;
    }
    else
    {
      delete pso;
      *ppsocketobj = NULL;
      hr           = E_FAIL;
    }
  }
  else
  {
    hr = E_OUTOFMEMORY;
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
CSocket::_Initialize(PIOCTX pioc)
{
  DEBUG_ENTER((
    DBG_SOCKET,
    rt_hresult,
    "CSocket::_Initialize",
    "this=%#x; pioc=%#x",
    this,
    pioc
    ));

  HRESULT hr = S_OK;

  m_socket      = pioc->socket;
  m_local       = pioc->local;
  m_remote      = pioc->remote;
  m_wszClientId = __wstrdup(pioc->clientid);

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
CSocket::Terminate(void)
{
  DEBUG_ENTER((
    DBG_SOCKET,
    rt_hresult,
    "CSocket::Terminate",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  _SetObjectState(ST_CLOSING);

    if( m_socket != INVALID_SOCKET )
    {
      shutdown(m_socket, SD_SEND);
      closesocket(m_socket);
    }

    SAFERELEASE(m_pSite);

    if( m_sent )
    {
      m_sent->FreeWSABuffer();
      m_sent->Release();
      m_sent = NULL;
    }

    if( m_rcvd )
    {
      m_rcvd->FreeWSABuffer();
      m_rcvd->Release();
      m_rcvd = NULL;
    }

    SAFEDELETEBUF(m_local->name);
    SAFEDELETEBUF(m_local->addr);
    SAFEDELETEBUF(m_remote->name);
    SAFEDELETEBUF(m_remote->addr);
    SAFEDELETE(m_local);
    SAFEDELETE(m_remote);
    SAFEDELETEBUF(m_wszClientId);

  _SetObjectState(ST_CLOSED);

  Release();

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
CSocket::Run(PIOCTX pioc)
{
  DEBUG_ENTER((
    DBG_SOCKET,
    rt_hresult,
    "CSocket::Run",
    "this=%#x; pioc=%#x",
    this,
    pioc
    ));

  HRESULT hr = S_OK;

  DEBUG_TRACE(
    SOCKET,
    ("processing %s in server state %s", MapIOTYPEToString(pioc->Type()), MapStateToString(m_serverstate))
    );

    switch( m_serverstate )
    {
      case SS_REQUEST_PENDING :
        {
          hr = _Recv(pioc);
        }
        break;

      case SS_RESPONSE_PENDING :
        {
          hr = _Send(pioc);
        }
        break;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
CSocket::_Send(PIOCTX pioc)
{
  DEBUG_ENTER((
    DBG_SOCKET,
    rt_hresult,
    "CSocket::_Send",
    "this=%#x; pioc=%#x",
    this,
    pioc
    ));

  HRESULT hr  = S_OK;
  DWORD   ret = ERROR_SUCCESS;

  if( m_objstate != ST_OPEN )
  {
    hr = E_UNEXPECTED;
    goto quit;
  }

  if( pioc->Type() != IOCT_SEND )
  {
    DEBUG_TRACE(SOCKET, ("io context has incorrect type, send aborted! [%s]", MapIOTYPEToString(pioc->Type())));
    hr = E_UNEXPECTED;
    goto quit;
  }

  if( m_serverstate == SS_SOCKET_CONNECTED || m_serverstate == SS_REQUEST_PENDING )
  {
    if( !_Flush() )
    {
      DEBUG_TRACE(SOCKET, ("network error detected during socket flush"));
      hr = E_FAIL;
      goto quit;
    }
  }

  DEBUG_DATA_DUMP(
    SOCKET,
    ("sending data", (LPBYTE) pioc->pwsa->buf, pioc->pwsa->len)
    );

  ret = WSASend(
          m_socket,
          pioc->pwsa, 1,
          &pioc->bytes,
          pioc->flags,
          &pioc->overlapped,
          NULL
          );

  if( ret == SOCKET_ERROR )
  {
    hr = _TestWinsockError();

    switch( hr )
    {
      case E_PENDING :
        {
          DEBUG_TRACE(SOCKET, ("send completing async"));
        }
        break;

      default :
        {
          DEBUG_TRACE(SOCKET, ("unrecoverable socket error occurred"));
          SetServerState(SS_SOCKET_DISCONNECTED);
        }
    }
  }
  else
  {
    DEBUG_TRACE(SOCKET, ("sent %d bytes", pioc->bytes));
  }

quit:

  if( SUCCEEDED(hr) || hr == E_PENDING )
  {
    if( m_sent )
    {
      m_sent->FreeWSABuffer();
      SAFERELEASE(m_sent);
    }

    m_sent = pioc;
    m_sent->AddRef();
  }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
CSocket::_Recv(PIOCTX pioc)
{
  DEBUG_ENTER((
    DBG_SOCKET,
    rt_hresult,
    "CSocket::_Recv",
    "this=%#x; pioc=%#x",
    this,
    pioc
    ));

  HRESULT hr  = S_OK;
  DWORD   ret = ERROR_SUCCESS;

  if( m_objstate != ST_OPEN || m_serverstate == SS_SOCKET_DISCONNECTED )
  {
    hr = E_UNEXPECTED;
    goto quit;
  }

  if( pioc->Type() != IOCT_RECV )
  {
    DEBUG_TRACE(SOCKET, ("io context has incorrect type, recv aborted! [%s]", MapIOTYPEToString(pioc->Type())));
    hr = E_UNEXPECTED;
    goto quit;
  }

  if( !pioc->AllocateWSABuffer(4096, NULL) )
  {
    hr = E_OUTOFMEMORY;
    goto quit;
  }

retry:

  ret = WSARecv(
          m_socket,
          pioc->pwsa, 1,
          &pioc->bytes,
          &pioc->flags,
          &pioc->overlapped,
          NULL
          );

  if( ret == SOCKET_ERROR )
  {
    hr = _TestWinsockError();

    switch( hr )
    {
      case E_PENDING :
        {
          DEBUG_TRACE(SOCKET, ("recv completing async"));
        }
        break;

      case E_OUTOFMEMORY :
        {
          if( _ResizeBuffer(pioc, pioc->bufsize*2) )
          {
            goto retry;
          }
          else
          {
            DEBUG_TRACE(SOCKET, ("error resizing receive buffer"));
          }
        }
        break;

      default :
        {
          DEBUG_TRACE(SOCKET, ("unrecoverable socket error occurred"));
          SetServerState(SS_SOCKET_DISCONNECTED);
        }
    }
  }
  else
  {
    if( pioc->bytes == 0 )
    {
      DEBUG_TRACE(SOCKET, ("detected socket close"));
      SetServerState(SS_SOCKET_DISCONNECTED);
      hr = E_FAIL;
    }
    else
    {
      DEBUG_DATA_DUMP(
        SOCKET,
        ("received data", (LPBYTE) pioc->pwsa->buf, pioc->bytes)
        );
    }

    DEBUG_TRACE(SOCKET, ("received %d bytes", pioc->bytes));
  }
      
quit:

  if( SUCCEEDED(hr) || hr == E_PENDING )
  {
    if( m_rcvd )
    {
      m_rcvd->FreeWSABuffer();
      SAFERELEASE(m_rcvd);
    }

    m_rcvd = pioc;
    m_rcvd->AddRef();
  }

  DEBUG_LEAVE(hr);
  return hr;
}


BOOL
CSocket::_Flush(void)
{
  DEBUG_ENTER((
    DBG_SOCKET,
    rt_bool,
    "CSocket::_Flush",
    "this=%#x",
    this
    ));

  BOOL   bContinue = TRUE;
  DWORD  ret       = ERROR_SUCCESS;
  PIOCTX pioc      = new IOCTX(IOCT_DUMMY, INVALID_SOCKET);

  if( !pioc || !pioc->AllocateWSABuffer(4096, NULL) )
  {
    bContinue = FALSE;
    goto quit;
  }

retry:

  ret = recv(m_socket, pioc->pwsa->buf, pioc->pwsa->len, 0);

  if( ret == SOCKET_ERROR )
  {
    switch( _TestWinsockError() )
    {
      case E_OUTOFMEMORY :
        {
          if( _ResizeBuffer(pioc, pioc->bufsize*2) )
          {
            goto retry;
          }
          else
          {
            DEBUG_TRACE(SOCKET, ("error resizing flush buffer"));
            bContinue = FALSE;
          }
        }
        break;

      default :
        {
          DEBUG_TRACE(SOCKET, ("unrecoverable socket error occurred"));
          bContinue = FALSE;
          SetServerState(SS_SOCKET_DISCONNECTED);
        }
    }
  }

  if( bContinue )
  {
    DEBUG_TRACE(SOCKET, ("flushed %d bytes", pioc->bytes));
  }

quit:

  pioc->FreeWSABuffer();
  SAFERELEASE(pioc);

  DEBUG_LEAVE(bContinue);
  return bContinue;
}


HRESULT
CSocket::_TestWinsockError(void)
{
  HRESULT hr    = S_OK;
  DWORD   error = WSAGetLastError();

  switch( error )
  {
    case WSA_IO_PENDING :
      {
        hr = E_PENDING;
      }
      break;

    case WSAEMSGSIZE :
      {
        hr = E_OUTOFMEMORY;
      }
      break;

    default :
      {
        DEBUG_TRACE(SOCKET, ("socket error: %d [%s]", error, MapErrorToString(error)));
        hr = E_FAIL;
      }
  }

  return hr;
}


BOOL
CSocket::_ResizeBuffer(PIOCTX pioc, DWORD len)
{
  DEBUG_TRACE(
    SOCKET,
    ("resizing buffer %#x from %#x to %#x bytes", pioc->pwsa->buf, pioc->pwsa->len, len)
    );

  return pioc->ResizeWSABuffer(len);
}


SERVERSTATE
CSocket::GetServerState(void)
{
  return m_serverstate;
}


void
CSocket::SetServerState(SERVERSTATE ss)
{
  DEBUG_TRACE(SOCKET, ("new server state %s", MapStateToString(ss)));
  m_serverstate = ss;
}


void
CSocket::GetSendBuffer(WSABUF** ppwb)
{
  *ppwb = m_sent ? m_sent->pwsa : NULL;
}


void
CSocket::GetRecvBuffer(WSABUF** ppwb)
{
  *ppwb = m_rcvd ? m_rcvd->pwsa : NULL;
}


DWORD
CSocket::GetBytesSent(void)
{
  if( m_sent )
  {
    return m_sent->bytes;
  }
  else
  {
    return 0;
  }
}


DWORD
CSocket::GetBytesReceived(void)
{
  if( m_rcvd )
  {
    return m_rcvd->bytes;
  }
  else
  {
    return 0;
  }
}


void
CSocket::_SetObjectState(STATE state)
{
  if( m_objstate != ST_ERROR )
  {
    DEBUG_TRACE(SOCKET, ("socket object state now %s", MapStateToString(state)));
    m_objstate = state;
  }
}


//-----------------------------------------------------------------------------
// IUnknown
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CSocket::QueryInterface(REFIID riid, void** ppv)
{
  DEBUG_ENTER((
    DBG_REFCOUNT,
    rt_hresult,
    "CSocket::QueryInterface",
    "this=%#x; riid=%s; ppv=%#x",
    this,
    MapIIDToString(riid),
    ppv
    ));

  HRESULT hr = S_OK;

  if( !ppv )
  {
    hr = E_POINTER;
    goto quit;
  }

    if(
      IsEqualIID(riid, IID_IUnknown) ||
      IsEqualIID(riid, IID_IDispatch) ||
      IsEqualIID(riid, IID_ISocket)
      )
    {
      *ppv = static_cast<ISocket*>(this);
    }
    else if( IsEqualIID(riid, IID_IObjectWithSite) )
    {
      *ppv = static_cast<IObjectWithSite*>(this);
    }
    else
    {
      *ppv = NULL;
      hr   = E_NOINTERFACE;
    }

  if( SUCCEEDED(hr) )
  {
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


ULONG
__stdcall
CSocket::AddRef(void)
{
  InterlockedIncrement(&m_cRefs);
  DEBUG_ADDREF("CSocket", m_cRefs);
  return m_cRefs;
}


ULONG
__stdcall
CSocket::Release(void)
{
  InterlockedDecrement(&m_cRefs);
  DEBUG_RELEASE("CSocket", m_cRefs);

  if( m_cRefs == 0 )
  {
    DEBUG_FINALRELEASE("CSocket");
    delete this;
    return 0;
  }

  return m_cRefs;
}


//-----------------------------------------------------------------------------
// IProvideClassInfo
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CSocket::GetClassInfo(ITypeInfo** ppti)
{
  DEBUG_ENTER((
    DBG_SOCKET,
    rt_hresult,
    "CSocket::GetClassInfo",
    "this=%#x; ppti=%#x",
    this,
    ppti
    ));

  HRESULT            hr   = S_OK;
  IActiveScriptSite* pias = NULL;

    if( ppti )
    {
      hr = m_pSite->QueryInterface(IID_IActiveScriptSite, (void**) &pias);

      if( SUCCEEDED(hr) )
      {
        hr = pias->GetItemInfo(
                     g_wszSocketObjectName,
                     SCRIPTINFO_ITYPEINFO,
                     NULL,
                     ppti
                     );
      }
    }
    else
    {
      hr = E_POINTER;
    }

  SAFERELEASE(pias);

  DEBUG_LEAVE(hr);
  return hr;
}


//-----------------------------------------------------------------------------
// IObjectWithSite
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CSocket::SetSite(IUnknown* pUnkSite)
{
  DEBUG_ENTER((
    DBG_SOCKET,
    rt_hresult,
    "CSocket::SetSite",
    "this=%#x; pUnkSite=%#x",
    this,
    pUnkSite
    ));

  HRESULT hr = S_OK;

    if( !pUnkSite )
    {
      hr = E_POINTER;
    }
    else
    {
      SAFERELEASE(m_pSite);

      m_pSite = pUnkSite;
      m_pSite->AddRef();
      _SetObjectState(ST_OPEN);
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CSocket::GetSite(REFIID riid, void** ppvSite)
{
  DEBUG_ENTER((
    DBG_SOCKET,
    rt_hresult,
    "CSocket::GetSite",
    "this=%#x; riid=%s; ppvSite=%#x",
    this,
    MapIIDToString(riid),
    ppvSite
    ));

  HRESULT hr = S_OK;

    if( !ppvSite )
    {
      hr = E_POINTER;
    }
    else
    {
      hr = m_pSite->QueryInterface(riid, ppvSite);
    }

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\w3spoof\om\session\scriptsite.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    scriptsite.cxx

Abstract:

    Implements the IActiveScriptSite interface for the session object.
    
Author:

    Paul M Midgen (pmidge) 10-October-2000


Revision History:

    10-October-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

extern LPWSTR g_wszRuntimeObjectName;

//-----------------------------------------------------------------------------
// IActiveScriptSite
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CSession::GetLCID(LCID* plcid)
{
  DEBUG_ENTER((
    DBG_SESSION,
    rt_hresult,
    "CSession::GetLCID",
    "this=%#x; plcid=%#x",
    this,
    plcid
    ));

  HRESULT hr = S_OK;

    if( !plcid )
    {
      hr = E_POINTER;
    }
    else
    {
      *plcid = MAKELCID(
                MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
                SORT_DEFAULT
                );
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CSession::GetItemInfo(LPCOLESTR pstrName, DWORD dwReturnMask, IUnknown** ppunk, ITypeInfo** ppti)
{
  DEBUG_ENTER((
    DBG_SESSION,
    rt_hresult,
    "CSession::GetItemInfo",
    "this=%#x; name=%S; retmask=%#x; ppunk=%#x; ppti=%#x",
    this,
    pstrName,
    dwReturnMask,
    ppunk,
    ppti
    ));

  HRESULT hr = S_OK;

  if( !pstrName )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

    if( dwReturnMask & SCRIPTINFO_IUNKNOWN )
    {
      if( !_wcsicmp(pstrName, g_wszRuntimeObjectName) )
      {
        IW3SpoofRuntime* pw3srt = NULL;

          if( SUCCEEDED(m_pw3s->GetRuntime(&pw3srt)) )
          {
            hr = pw3srt->QueryInterface(IID_IUnknown, (void**) ppunk);
          }
          else
          {
            hr     = E_FAIL;
            *ppunk = NULL;
          }

        SAFERELEASE(pw3srt);
      }
      else
      {
        hr = QueryInterface(IID_IUnknown, (void**) ppunk);
      }
    }
    else if( dwReturnMask & SCRIPTINFO_ITYPEINFO )
    {
      hr = GetTypeInfoFromName(pstrName, m_ptl, ppti);

      if( FAILED(hr) )
      {
        *ppti = NULL;
      }
    }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CSession::GetDocVersionString(BSTR* pbstrVersion)
{
  DEBUG_TRACE(SESSION, ("NOTIMPL: IActiveScriptSite::GetDocVersionString()"));
  return E_NOTIMPL;
}


HRESULT
__stdcall
CSession::OnScriptTerminate(const VARIANT* pvarResult, const EXCEPINFO* pei)
{
  DEBUG_TRACE(SESSION, ("NOTIMPL: IActiveScriptSite::OnScriptTerminate()"));
  return E_NOTIMPL;
}


HRESULT
__stdcall
CSession::OnStateChange(SCRIPTSTATE ss)
{
  DEBUG_TRACE(SESSION, ("new script state %s", MapStateToString(ss)));
  return S_OK;
}


HRESULT
__stdcall
CSession::OnScriptError(IActiveScriptError* piase)
{
  DEBUG_ENTER((
    DBG_SESSION,
    rt_hresult,
    "CSession::OnScriptError",
    "this=%#x; piase=%#x",
    this,
    piase
    ));
  
  HRESULT   hr     = S_OK;
  DWORD     n      = 0L;
  DWORD     cookie = 0L;
  ULONG     line   = 0L;
  LONG      pos    = 0L;
  BSTR      bstr   = SysAllocStringLen(NULL, 256);
  WCHAR*    tmp    = NULL;
  EXCEPINFO ex;

    if( FAILED(piase->GetSourceLineText(&bstr)) )
    {
      SysFreeString(bstr);
      bstr = SysAllocString(L"source not available");
    }
    else
    {
      for(wcstok(bstr, L"\n"); n<line; n++)
      {
        tmp = wcstok(NULL, L"\n");
      }
    }

    piase->GetExceptionInfo(&ex);
    piase->GetSourcePosition(&cookie, &line, &pos);

    ++line;

    DEBUG_TRACE(SESSION, ("********* SCRIPT ERROR *********"));
    DEBUG_TRACE(SESSION, (" session: %x", cookie));
    DEBUG_TRACE(SESSION, (" line # : %d", line));
    DEBUG_TRACE(SESSION, (" char # : %d", pos));
    DEBUG_TRACE(SESSION, (" source : %S", ex.bstrSource));
    DEBUG_TRACE(SESSION, (" error  : %S", ex.bstrDescription));
    DEBUG_TRACE(SESSION, (" hresult: 0x%0.8X [%s]", ex.scode, MapHResultToString(ex.scode)));
    DEBUG_TRACE(SESSION, (" code   : %S", tmp ? tmp : bstr));
    DEBUG_TRACE(SESSION, ("********************************"));

    if( m_socketobj )
    {
      WCHAR*   buf    = new WCHAR[4096];
      LPWSTR   script = NULL;
      ISocket* ps     = NULL;

      m_pw3s->GetScriptPath(m_wszClient, &script);

      wsprintfW(
        buf,
        L"HTTP/1.1 500 Server Error\r\nContent-Type: text/html\r\nConnection: close\r\n\r\n" \
        L"<HTML><BODY style=\"font-family:courier new;\">\r\n" \
        L"<B>W3Spoof Script Error</B>\r\n" \
        L"<XMP>\r\n" \
        L"session: %#x\r\n" \
        L"handler: %S\r\n" \
        L"client : %s\r\n" \
        L"file   : %s\r\n" \
        L"error  : %s (%s)\r\n" \
        L"hresult: 0x%0.8X [%S]\r\n" \
        L"line # : %d\r\n" \
        L"char # : %d\r\n" \
        L"code   : %s\r\n" \
        L"</XMP>\r\n" \
        L"</BODY></HTML>",
        cookie,
        MapScriptDispidToString(m_CurrentHandler),
        m_wszClientId,
        script,
        ex.bstrSource,
        ex.bstrDescription,
        ex.scode,
        MapHResultToString(ex.scode),
        line,
        pos,
        tmp ? tmp : bstr
        );

      NEWVARIANT(error);

      V_VT(&error)   = VT_BSTR;
      V_BSTR(&error) = __widetobstr(buf);

      m_socketobj->QueryInterface(IID_ISocket, (void**) &ps);

      ps->Send(error);

      VariantClear(&error);
      SAFERELEASE(ps);
      SAFEDELETEBUF(buf);
    }    

  SysFreeString(bstr);

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CSession::OnEnterScript(void)
{
  DEBUG_TRACE(SESSION, ("****** ENTER %s HANDLER ******", MapScriptDispidToString(m_CurrentHandler)));
  return E_NOTIMPL;
}


HRESULT
__stdcall
CSession::OnLeaveScript(void)
{
  DEBUG_TRACE(SESSION, ("****** LEAVE %s HANDLER ******", MapScriptDispidToString(m_CurrentHandler)));
  return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\w3spoof\om\socket\methods.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    methods.cxx

Abstract:

    Implements methods part of the Socket object's dual interface.
    
Author:

    Paul M Midgen (pmidge) 24-October-2000


Revision History:

    24-October-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

HRESULT
__stdcall
CSocket::Send(VARIANT Data)
{
  DEBUG_ENTER((
    DBG_SOCKET,
    rt_hresult,
    "CSocket::Send",
    "this=%#x",
    this
    ));

  HRESULT hr   = S_OK;
  DWORD   ret  = 0L;
  PIOCTX  pioc = new IOCTX(IOCT_SEND, INVALID_SOCKET);

  if( m_serverstate == SS_SOCKET_DISCONNECTED )
  {
    DEBUG_TRACE(SOCKET, ("ERROR! Attempt to send after socket disconnect!"));
    hr = E_UNEXPECTED;
    goto quit;
  }

  if( !pioc )
  {
    hr = E_OUTOFMEMORY;
    goto quit;
  }

  if( !__isempty(Data) )
  {
    if( !pioc->AllocateWSABuffer(0, NULL) )
    {
      hr = E_OUTOFMEMORY;
      goto quit;
    }

    pioc->clientid = m_wszClientId;

    hr = ProcessVariant(
           &Data,
           (LPBYTE*) &pioc->pwsa->buf,
           &pioc->pwsa->len,
           NULL
           );

      if( FAILED(hr) )
      {
        DEBUG_TRACE(SOCKET, ("failed to convert input to sendable data"));
        goto quit;
      }

    // we want this call to appear to complete synchronously
    pioc->DisableIoCompletion();

    hr = _Send(pioc);

    if( hr == E_PENDING )
    {
      DWORD flags = 0L;

      ret = WSAGetOverlappedResult(
              m_socket,
              &pioc->overlapped,
              &pioc->bytes,
              TRUE,
              &flags
              );

      hr = ret ? S_OK : E_FAIL;
    }

    if( SUCCEEDED(hr) )
    {
      SetServerState(SS_RESPONSE_COMPLETE);
    }
    else
    {
      if( _TestWinsockError() == E_FAIL )
      {
        DEBUG_TRACE(SOCKET, ("detected socket close"));
        SetServerState(SS_SOCKET_DISCONNECTED);
      }
    }
  }

quit:

  SAFERELEASE(pioc);

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CSocket::Recv(VARIANT *Data)
{
  DEBUG_ENTER((
    DBG_SOCKET,
    rt_hresult,
    "CSocket::Recv",
    "this=%#x",
    this
    ));

  HRESULT    hr   = S_OK;
  BOOL       ret  = TRUE;
  PIOCTX     pioc = new IOCTX(IOCT_RECV, INVALID_SOCKET);
  SAFEARRAY* psa  = NULL;

  if( (m_serverstate == SS_REQUEST_COMPLETE || m_serverstate == SS_RESPONSE_PENDING) )
  {
    DEBUG_TRACE(SOCKET, ("ERROR! Attempt to receive in invalid state!"));
    hr = E_UNEXPECTED;
    goto quit;
  }

  if( m_serverstate == SS_SOCKET_DISCONNECTED )
  {
    DEBUG_TRACE(SOCKET, ("ERROR! Attempt to receive after socket disconnect!"));
    hr = E_UNEXPECTED;
    goto quit;
  }

  // we want this call to appear to complete synchronously
  pioc->DisableIoCompletion();

  hr = _Recv(pioc);

  if( hr == E_PENDING )
  {
    DWORD flags = 0L;

    ret = WSAGetOverlappedResult(
            m_socket,
            &pioc->overlapped,
            &pioc->bytes,
            TRUE,
            &flags
            );

    hr = ret ? S_OK : E_FAIL;
  }

  if( SUCCEEDED(hr) )
  {
    psa = SafeArrayCreateVector(VT_UI1, 1, pioc->bytes);

    if( psa )
    {
      memcpy(
        (LPBYTE) psa->pvData,
        pioc->pwsa->buf,
        pioc->bytes
        );

      V_VT(Data)    = VT_ARRAY | VT_UI1;
      V_ARRAY(Data) = psa;

      SetServerState(SS_REQUEST_COMPLETE);
    }
    else
    {
      DEBUG_TRACE(SOCKET, ("ERROR! Failed to create safearray!"));
      hr = E_FAIL;
    }
  }
  else
  {
    if( _TestWinsockError() == E_FAIL )
    {
      DEBUG_TRACE(SOCKET, ("detected socket close"));
      SetServerState(SS_SOCKET_DISCONNECTED);
    }
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CSocket::Close(VARIANT Method)
{
  DEBUG_ENTER((
    DBG_SOCKET,
    rt_hresult,
    "CSocket::Close",
    "this=%#x",
    this
    ));

  HRESULT hr   = S_OK;
  BOOL    mode = Method.boolVal;

    if( !mode )
    {
      struct linger _linger = {1, 0};

      setsockopt(
        m_socket,
        SOL_SOCKET, SO_LINGER,
        (char*) &_linger, sizeof(struct linger)
        );
    }
    else
    {
      shutdown(m_socket, SD_SEND);
    }
  
    closesocket(m_socket);

    m_socket = INVALID_SOCKET;

    SetServerState(SS_SOCKET_DISCONNECTED);

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CSocket::Resolve(BSTR Host, BSTR *Address)
{
  DEBUG_ENTER((
    DBG_SOCKET,
    rt_hresult,
    "CSocket::Resolve",
    "this=%#x",
    this
    ));

  HRESULT  hr   = S_OK;
  LPSTR    host = NULL;
  HOSTENT* ph   = NULL;
  in_addr  in   = {0};

  host = __widetoansi(Host);

  DEBUG_TRACE(SOCKET, ("resolving hostname \"%s\"", host));
  ph   = gethostbyname(host);

    if( ph )
    {
      in.s_addr = *((ULONG*) ph->h_addr_list[0]);
      DEBUG_TRACE(SOCKET, ("ip address: %s", inet_ntoa(in)));
      *Address  = __ansitobstr(inet_ntoa(in));
    }
    else
    {
      DEBUG_TRACE(SOCKET, ("resolution failed"));
      *Address = NULL;
    }

  SAFEDELETEBUF(host);

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT 
__stdcall
CSocket::get_Parent(IDispatch** ppdisp)
{
  DEBUG_ENTER((
    DBG_SOCKET,
    rt_hresult,
    "CSocket::get_Parent",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

    if( !ppdisp )
    {
      hr = E_POINTER;
    }
    else
    {
      hr = m_pSite->QueryInterface(IID_IDispatch, (void**) ppdisp);
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CSocket::get_LocalName(BSTR *Name)
{
  DEBUG_ENTER((
    DBG_SOCKET,
    rt_hresult,
    "CSocket::get_LocalName",
    "this=%#x",
    this
    ));

  HRESULT hr  = S_OK;
  LPWSTR  wsz = NULL;

    if( !Name )
    {
      hr = E_POINTER;
    }
    else
    {
      wsz   = __ansitowide(m_local->name);
      *Name = SysAllocString(wsz);
    }

  SAFEDELETEBUF(wsz);

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CSocket::get_LocalAddress(BSTR *Address)
{
  DEBUG_ENTER((
    DBG_SOCKET,
    rt_hresult,
    "CSocket::get_LocalAddress",
    "this=%#x",
    this
    ));

  HRESULT hr  = S_OK;
  LPWSTR  wsz = NULL;

    if( !Address )
    {
      hr = E_POINTER;
    }
    else
    {
      wsz      = __ansitowide(m_local->addr);
      *Address = SysAllocString(wsz);
    }

  SAFEDELETEBUF(wsz);

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CSocket::get_LocalPort(VARIANT *Port)
{
  DEBUG_ENTER((
    DBG_SOCKET,
    rt_hresult,
    "CSocket::get_LocalPort",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

    if( !Port )
    {
      hr = E_POINTER;
    }
    else
    {
      V_VT(Port)  = VT_UI2;
      V_UI2(Port) = m_local->port;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CSocket::get_RemoteName(BSTR *Name)
{
  DEBUG_ENTER((
    DBG_SOCKET,
    rt_hresult,
    "CSocket::get_RemoteName",
    "this=%#x",
    this
    ));

  HRESULT hr  = S_OK;
  LPWSTR  wsz = NULL;

    if( !Name )
    {
      hr = E_POINTER;
    }
    else
    {
      wsz   = __ansitowide(m_remote->name);
      *Name = SysAllocString(wsz);
    }

  SAFEDELETEBUF(wsz);

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CSocket::get_RemoteAddress(BSTR *Address)
{
  DEBUG_ENTER((
    DBG_SOCKET,
    rt_hresult,
    "CSocket::get_RemoteAddress",
    "this=%#x",
    this
    ));

  HRESULT hr  = S_OK;
  LPWSTR  wsz = NULL;

    if( !Address )
    {
      hr = E_POINTER;
    }
    else
    {
      wsz      = __ansitowide(m_remote->addr);
      *Address = SysAllocString(wsz);
    }

  SAFEDELETEBUF(wsz);

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CSocket::get_RemotePort(VARIANT *Port)
{
  DEBUG_ENTER((
    DBG_SOCKET,
    rt_hresult,
    "CSocket::get_RemotePort",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

    if( !Port )
    {
      hr = E_POINTER;
    }
    else
    {
      V_VT(Port)  = VT_UI2;
      V_UI2(Port) = m_remote->port;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CSocket::get_Option(BSTR Option, VARIANT *Value)
{
  DEBUG_ENTER((
    DBG_SOCKET,
    rt_hresult,
    "CSocket::get_Option",
    "this=%#x",
    this
    ));

  HRESULT hr = E_NOTIMPL;
  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CSocket::put_Option(BSTR Option, VARIANT Value)
{
  DEBUG_ENTER((
    DBG_SOCKET,
    rt_hresult,
    "CSocket::put_Option",
    "this=%#x",
    this
    ));

  HRESULT hr = E_NOTIMPL;
  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\w3spoof\om\w3srt\file.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    file.cxx

Abstract:

    Implements the File runtime object.
    
Author:

    Paul M Midgen (pmidge) 17-November-2000


Revision History:

    17-November-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

//
// WARNING: do not modify these values. use disphash.exe to generate
//          new values.
//
DISPIDTABLEENTRY g_FileDisptable[] =
{
  0x00008504,   DISPID_FILE_OPEN,               L"open",
  0x00010203,   DISPID_FILE_CLOSE,              L"close",
  0x00011d77,   DISPID_FILE_WRITE,              L"write",
  0x0011fe1f,   DISPID_FILE_WRITELINE,          L"writeline",
  0x023daf9a,   DISPID_FILE_WRITEBLANKLINE,     L"writeblankline",
  0x000081e5,   DISPID_FILE_READ,               L"read",
  0x00043138,   DISPID_FILE_READALL,            L"readall",
  0x0021188d,   DISPID_FILE_ATTRIBUTES,         L"attributes",
  0x00008804,   DISPID_FILE_SIZE,               L"size",
  0x00008c34,   DISPID_FILE_TYPE,               L"type",
  0x07f2b274,   DISPID_FILE_DATELASTMODIFIED,   L"datelastmodified"
};


DWORD g_cFileDisptable = (sizeof(g_FileDisptable) / sizeof(DISPIDTABLEENTRY));


//-----------------------------------------------------------------------------
// CW3SFile
//-----------------------------------------------------------------------------
CW3SFile::CW3SFile():
  m_cRefs(0),
  m_bFileOpened(FALSE),
  m_bReadOnly(FALSE),
  m_bAsciiData(FALSE),
  m_bHttpResponseCached(FALSE),
  m_hFile(INVALID_HANDLE_VALUE),
  m_pWHR(NULL),
  m_cHttpBytesRead(0)
{
  DEBUG_TRACE(RUNTIME, ("CW3SFile [%#x] created", this));
}


CW3SFile::~CW3SFile()
{
  DEBUG_TRACE(RUNTIME, ("CW3SFile [%#x] deleted", this));
}


HRESULT
CW3SFile::Create(IW3SpoofFile** ppw3sf)
{
  DEBUG_ENTER((
    DBG_RUNTIME,
    rt_hresult,
    "CW3SFile::Create",
    "ppw3sf=%#x",
    ppw3sf
    ));

  HRESULT  hr  = S_OK;
  PFILEOBJ pfo = NULL;

    if( !ppw3sf )
    {
      hr = E_POINTER;
    }
    else
    {
      if( pfo = new FILEOBJ )
      {
        hr = pfo->QueryInterface(IID_IW3SpoofFile, (void**) ppw3sf);
      }
      else
      {
        hr = E_OUTOFMEMORY;
      }
    }

  DEBUG_LEAVE(hr);
  return hr;
}


void
CW3SFile::_Cleanup(void)
{
  DEBUG_TRACE(RUNTIME, ("CW3SFile [%#x] cleaning up", this));

  SAFECLOSE(m_hFile);
  SAFERELEASE(m_pWHR);
  VariantClear(&m_vHttpResponse);

  m_cHttpBytesRead      = 0L;
  m_bFileOpened         = FALSE;
  m_bReadOnly           = FALSE;
  m_bAsciiData          = FALSE;
  m_bHttpResponseCached = FALSE;
}


BOOL
CW3SFile::_CacheHttpResponse(void)
{
  BOOL bSuccess = FALSE;

  if( SUCCEEDED(m_pWHR->get_ResponseBody(&m_vHttpResponse)) )
  {
    if( __isempty(m_vHttpResponse) )
    {
      VariantClear(&m_vHttpResponse);
    }
    else
    {
      bSuccess = TRUE;
    }

    V_VT(&m_vHttpResponse) = bSuccess ? (VT_ARRAY | VT_UI1) : VT_NULL;
  }

  return bSuccess;
}


//-----------------------------------------------------------------------------
// IW3SpoofFile
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CW3SFile::Open(BSTR Filename, VARIANT Mode, VARIANT* Success)
{
  DEBUG_ENTER((
    DBG_RUNTIME,
    rt_hresult,
    "CW3SFile::Open",
    "this=%#x; Filename=%S; Mode=%#x",
    this,
    Filename,
    V_UI4(&Mode)
    ));

  HRESULT hr = S_OK;

  if( !Filename )
  {
    hr = E_INVALIDARG;
    goto quit;
  }
    
    if( m_bFileOpened )
    {
      _Cleanup();
    }

    if( __PathIsUNC(Filename) )
    {
      DEBUG_TRACE(RUNTIME, ("attempting to open %S as a UNC path", Filename));

      m_bFileOpened = GetFile(
                        Filename,
                        &m_hFile,
                        NULL,
                        V_UI4(&Mode),
                        &m_bReadOnly
                        );

      if( m_bFileOpened )
      {
        GetFileInformationByHandle(m_hFile, &m_bhfi);
      }
    }
    else if( __PathIsURL(Filename) )
    {
      DEBUG_TRACE(RUNTIME, ("attempting to open %S as an HTTP URL", Filename));

      m_bFileOpened = GetFile(
                        Filename,
                        NULL,
                        &m_pWHR,
                        V_UI4(&Mode),
                        &m_bReadOnly
                        );
    }
    else
    {
      // might be a local path
      m_bFileOpened = GetFile(
                        Filename,
                        &m_hFile,
                        NULL,
                        V_UI4(&Mode),
                        &m_bReadOnly
                        );

      if( m_bFileOpened )
      {
        GetFileInformationByHandle(m_hFile, &m_bhfi);
      }
      else
      {
        DEBUG_TRACE(RUNTIME, ("path/file type could not be determined"));
        hr = E_FAIL;
        goto quit;
      }
    }

  if( m_bFileOpened )
  {
    NEWVARIANT(type);

    hr = Type(&type);

    if( SUCCEEDED(hr) )
    {
      if( wcsstr(V_BSTR(&type), L"text") )
      {
        m_bAsciiData = TRUE;
      }
    }

    VariantClear(&type);
  }

  // check if the automation client wants status
  if( Success )
  {
    V_VT(Success)   = VT_BOOL;
    V_BOOL(Success) = m_bFileOpened ? TRUE : FALSE;
    hr              = S_OK;
  }
  else
  {
    hr = m_bFileOpened ? S_OK : E_FAIL;
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3SFile::Close(void)
{
  DEBUG_ENTER((
    DBG_RUNTIME,
    rt_hresult,
    "CW3SFile::Close",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

    _Cleanup();

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3SFile::Write(VARIANT Data, VARIANT* Success)
{
  DEBUG_ENTER((
    DBG_RUNTIME,
    rt_hresult,
    "CW3SFile::Write",
    "this=%#x",
    this
    ));

  HRESULT hr       = S_OK;
  BOOL    bSuccess = FALSE;
  LPBYTE  pbyte    = NULL;
  DWORD   len      = 0L;
  DWORD   bytes    = 0L;

  if( !m_bFileOpened )
  {
    hr = E_UNEXPECTED;
    goto quit;
  }

  if( m_bReadOnly )
  {
    hr = E_ACCESSDENIED;
    goto quit;
  }

    if( m_pWHR )
    {
      DEBUG_TRACE(RUNTIME, ("attempt to write to HTTP resource denied"));
      hr = E_FAIL;
    }
    else
    {
      if( !__isempty(Data) )
      {
        hr = ProcessVariant(&Data, &pbyte, &len, NULL);

        if( SUCCEEDED(hr) )
        {
          //DEBUG_DATA_DUMP(RUNTIME, ("writing data", pbyte, len));

          bSuccess = WriteFile(
                       m_hFile,
                       (LPVOID) pbyte,
                       len,
                       &bytes,
                       NULL
                       );

          if( !bSuccess || (bytes != len) )
          {
            DEBUG_TRACE(RUNTIME, ("error writing to file: %s", MapErrorToString(GetLastError())));
            hr = E_FAIL;
          }
          else
          {
            DEBUG_TRACE(RUNTIME, ("write of %d bytes succeeded", bytes));
          }
        }
        else
        {
          DEBUG_TRACE(RUNTIME, ("could not convert input in usable data"));
          hr = E_FAIL;
        }
      }
    }

  if( Success )
  {
    V_VT(Success)   = VT_BOOL;
    V_BOOL(Success) = bSuccess ? TRUE : FALSE;
    hr              = S_OK;
  }
  else
  {
    hr = bSuccess ? TRUE : FALSE;
  }

  SAFEDELETEBUF(pbyte);

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3SFile::WriteLine(BSTR Line, VARIANT* Success)
{
  DEBUG_ENTER((
    DBG_RUNTIME,
    rt_hresult,
    "CW3SFile::WriteLine",
    "this=%#x",
    this
    ));

  HRESULT hr  = S_OK;
  DWORD   len = 0L;

  if( !Line )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  if( !m_bFileOpened )
  {
    hr = E_UNEXPECTED;
    goto quit;
  }
  
  NEWVARIANT(data);

    len           = SysStringLen(Line);
    V_BSTR(&data) = SysAllocStringLen(Line,  len + 2);
    V_VT(&data)   = VT_BSTR;

    wcscat(
      (V_BSTR(&data) + len),
      L"\r\n"
      );

      hr = Write(data, Success);

  VariantClear(&data);

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3SFile::WriteBlankLine(VARIANT* Success)
{
  DEBUG_ENTER((
    DBG_RUNTIME,
    rt_hresult,
    "CW3SFile::WriteBlankLine",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  if( !m_bFileOpened )
  {
    hr = E_UNEXPECTED;
    goto quit;
  }

  NEWVARIANT(data);

    V_VT(&data)   = VT_BSTR;
    V_BSTR(&data) = SysAllocString(L"\r\n");

      hr = Write(data, Success);

  VariantClear(&data);

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3SFile::Read(VARIANT Bytes, VARIANT* Data)
{
  DEBUG_ENTER((
    DBG_RUNTIME,
    rt_hresult,
    "CW3SFile::Read",
    "this=%#x",
    this
    ));

  HRESULT hr    = S_OK;
  LPBYTE  pbuf  = NULL;
  DWORD   bytes = 0L;

  if( !Data )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  if( !m_bFileOpened )
  {
    hr = E_UNEXPECTED;
    goto quit;
  }

  bytes = V_UI4(&Bytes);
  pbuf  = new BYTE[bytes];

    if( m_pWHR )
    {
      LPBYTE pbyte = NULL;

      if( !m_bHttpResponseCached )
      {
        m_bHttpResponseCached = _CacheHttpResponse();
      }

      SafeArrayAccessData(V_ARRAY(&m_vHttpResponse), (void**) &pbyte);

        memcpy(
          pbuf,
          pbyte + m_cHttpBytesRead,
          bytes
          );

      SafeArrayUnaccessData(V_ARRAY(&m_vHttpResponse));

      m_cHttpBytesRead += bytes;
    }
    else
    {
      ReadFile(m_hFile, pbuf, V_UI4(&Bytes), &bytes, NULL);
    }

    //DEBUG_DATA_DUMP(RUNTIME, ("bytes read", pbuf, bytes % 1000000));

    if( m_bAsciiData )
    {
      int flags = IS_TEXT_UNICODE_ODD_LENGTH | IS_TEXT_UNICODE_NULL_BYTES;

      if( IsTextUnicode((LPVOID) pbuf, bytes, &flags) )
      {
        LPWSTR wsz = NULL;

        wsz          = __wstrndup((LPWSTR) pbuf, bytes);
        V_BSTR(Data) = __widetobstr(wsz);

        SAFEDELETEBUF(wsz);
      }
      else
      {
        LPSTR sz = NULL;

        sz           = __strndup((LPSTR) pbuf, bytes);
        V_BSTR(Data) = __ansitobstr(sz);

        SAFEDELETEBUF(sz);
      }
      
      V_VT(Data) = VT_BSTR;
    }
    else
    {
      SAFEARRAY* psa = NULL;

      psa = SafeArrayCreateVector(VT_UI1, 1, bytes);

      if( psa )
      {
        memcpy((LPBYTE) psa->pvData, pbuf, bytes);

        V_VT(Data)    = VT_ARRAY | VT_UI1;
        V_ARRAY(Data) = psa;
      }
      else
      {
        hr = E_FAIL;
      }
    }

  SAFEDELETEBUF(pbuf);

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3SFile::ReadAll(VARIANT* Data)
{
  DEBUG_ENTER((
    DBG_RUNTIME,
    rt_hresult,
    "CW3SFile::ReadAll",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  if( !Data )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  if( !m_bFileOpened )
  {
    hr = E_UNEXPECTED;
    goto quit;
  }

  NEWVARIANT(size);

    if( SUCCEEDED(Size(&size)) )
    {
      hr = Read(size, Data);

      if( !m_pWHR )
      {
        SetFilePointer(m_hFile, 0L, NULL, FILE_BEGIN);
      }
    }
    else
    {
      hr = E_FAIL;
    }

  VariantClear(&size);
  
quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3SFile::Attributes(VARIANT* Attributes)
{
  DEBUG_ENTER((
    DBG_RUNTIME,
    rt_hresult,
    "CW3SFile::Attributes",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  if( !Attributes )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  if( !m_bFileOpened )
  {
    hr = E_UNEXPECTED;
    goto quit;
  }

  if( m_pWHR )
  {
    V_UI4(Attributes) = 0;
  }
  else
  {
    V_UI4(Attributes) = m_bhfi.dwFileAttributes;
  }

  DEBUG_TRACE(RUNTIME, ("file attributes are %0.8x", V_UI4(Attributes)));

  V_VT(Attributes) = VT_UI4;

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3SFile::Size(VARIANT* Size)
{
  DEBUG_ENTER((
    DBG_RUNTIME,
    rt_hresult,
    "CW3SFile::Size",
    "this=%#x",
    this
    ));

  HRESULT hr   = S_OK;
  DWORD   size = 0L;

  if( !m_bFileOpened )
  {
    hr = E_UNEXPECTED;
    goto quit;
  }

    if( m_pWHR )
    {
      BSTR   contentlen = SysAllocString(L"content-length");
      BSTR   val        = NULL;
      WCHAR* stop       = L"\0";

      //
      // BUGBUG: the if() block below works around buggyness in WinHttpRequest.
      //         i will have to modify it at some point once the WHR bugs are
      //         fixed.
      //

      hr = m_pWHR->GetResponseHeader(contentlen, &val);

      if( SUCCEEDED(hr) && (val[0] != 0x00) )
      {
        size = wcstoul(val, &stop, 10);
      }
      else
      {
        if( _CacheHttpResponse() )
        {
          SafeArrayGetUBound(V_ARRAY(&m_vHttpResponse), 1, (long*) &size);
        }
        else
        {
          DEBUG_TRACE(RUNTIME, ("failed to determine content-length"));
          hr = E_FAIL;
        }
      }

      SAFEDELETEBSTR(contentlen);
      SAFEDELETEBSTR(val);
    }
    else
    {
      //
      // BUGBUG: it's possible we're dealing with a really large file, and we'll
      //         incorrectly represent the file size to interface clients.
      //
      size = m_bhfi.nFileSizeLow;
    }

  DEBUG_TRACE(RUNTIME, ("file size is %d bytes", size));

  V_VT(Size)  = VT_UI4;
  V_UI4(Size) = size;

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3SFile::Type(VARIANT* Type)
{
  DEBUG_ENTER((
    DBG_RUNTIME,
    rt_hresult,
    "CW3SFile::Type",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  if( !Type )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  if( !m_bFileOpened )
  {
    hr = E_UNEXPECTED;
    goto quit;
  }

    //
    // for URL returns the content-type, for UNC returns binary or text
    // if type cannot be determined, returns "unknown"
    //

    if( m_pWHR )
    {
      BSTR contenttype = SysAllocString(L"content-type");

      hr = m_pWHR->GetResponseHeader(contenttype, &V_BSTR(Type));

      SAFEDELETEBSTR(contenttype);
    }
    else
    {
      BOOL  bFoundNonTextChar = FALSE;
      DWORD bytes             = 0L;
      BYTE  taste[16];

      if( ReadFile(m_hFile, (LPVOID) taste, 16, &bytes, NULL) )
      {
        if( !(bytes < 16) )
        {
          for(DWORD n=0; n<bytes; n++)
          {
            if( !((taste[n] >= 32) && (taste[n] <= 127)) )
            {
              bFoundNonTextChar = TRUE;
              break;
            }
          }

          V_BSTR(Type) = SysAllocString(
                           bFoundNonTextChar ? L"binary" : L"text"
                           );
        }
        else
        {
          DEBUG_TRACE(RUNTIME, ("nondeterministic data sample, type unknown"));
          hr = E_FAIL;
        }

        // reset the file pointer
        SetFilePointer(m_hFile, 0, NULL, FILE_BEGIN);
      }
      else
      {
        DEBUG_TRACE(RUNTIME, ("read error occurred, couldn\'t determine file type"));
        hr = E_FAIL;
      }
    }

  if( FAILED(hr) )
  {
    V_BSTR(Type) = SysAllocString(L"unknown");
    hr           = S_OK;
  }

  DEBUG_TRACE(RUNTIME, ("file type is %S", V_BSTR(Type)));

  V_VT(Type) = VT_BSTR;

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3SFile::DateLastModified(VARIANT* Date)
{
  DEBUG_ENTER((
    DBG_RUNTIME,
    rt_hresult,
    "CW3SFile::DateLastModified",
    "this=%#x",
    this
    ));

  HRESULT    hr = S_OK;
  SYSTEMTIME st;

  if( !Date )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  if( !m_bFileOpened )
  {
    hr = E_UNEXPECTED;
    goto quit;
  }

    //
    // this function differs in behavior from others in that if an error
    // is encountered, we don't generate a script error (except for invalidarg).
    // we return a null date instead.
    //

    if( m_pWHR )
    {
      BSTR lastmodified = SysAllocString(L"last-modified");

        hr = m_pWHR->GetResponseHeader(lastmodified, &V_BSTR(Date));

        if( FAILED(hr) || (V_VT(Date) == VT_EMPTY) )
        {
          V_VT(Date) = VT_NULL;
          hr         = S_OK;
        }
        else
        {
          V_VT(Date) = VT_BSTR;
        }

      SAFEDELETEBSTR(lastmodified);
    }
    else
    {
      if( FileTimeToSystemTime(&m_bhfi.ftLastWriteTime, &st) )
      {
        if( !SystemTimeToVariantTime(&st, &V_DATE(Date)) )
        {
          DEBUG_TRACE(RUNTIME, ("error converting system time to variant"));
          hr = E_FAIL;
        }
      }
      else
      {
        DEBUG_TRACE(RUNTIME, ("error converting last-write time to system time"));
        hr = E_FAIL;
      }

      if( FAILED(hr) )
      {
        V_VT(Date) = VT_NULL;
        hr         = S_OK;
      }
      else
      {
        V_VT(Date) = VT_DATE;
      }
    }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


//-----------------------------------------------------------------------------
// IUnknown
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CW3SFile::QueryInterface(REFIID riid, void** ppv)
{
  DEBUG_ENTER((
    DBG_REFCOUNT,
    rt_hresult,
    "CW3SFile::QueryInterface",
    "this=%#x; riid=%s; ppv=%#x",
    this,
    MapIIDToString(riid),
    ppv
    ));

  HRESULT hr = S_OK;

  if( !ppv )
  {
    hr = E_POINTER;
    goto quit;
  }

    if(
      IsEqualIID(riid, IID_IUnknown)  ||
      IsEqualIID(riid, IID_IDispatch) ||
      IsEqualIID(riid, IID_IW3SpoofFile)
      )
    {
      *ppv = static_cast<IW3SpoofFile*>(this);
    }
    else
    {
      *ppv = NULL;
      hr   = E_NOINTERFACE;
    }

  if( SUCCEEDED(hr) )
  {
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


ULONG
__stdcall
CW3SFile::AddRef(void)
{
  InterlockedIncrement(&m_cRefs);
  DEBUG_ADDREF("CW3SFile", m_cRefs);
  return m_cRefs;
}


ULONG
__stdcall
CW3SFile::Release(void)
{
  InterlockedDecrement(&m_cRefs);
  DEBUG_RELEASE("CW3SFile", m_cRefs);

  if( m_cRefs == 0 )
  {
    DEBUG_FINALRELEASE("CW3SFile");
    _Cleanup();    
    delete this;
    return 0;
  }

  return m_cRefs;
}


//-----------------------------------------------------------------------------
// IDispatch
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CW3SFile::GetTypeInfoCount(UINT* pctinfo)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "CW3SFile::GetTypeInfoCount",
    "this=%#x; pctinfo=%#x",
    this,
    pctinfo
    ));

  HRESULT hr = E_NOTIMPL;

    if( pctinfo )
    {
      *pctinfo = 0;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3SFile::GetTypeInfo(UINT index, LCID lcid, ITypeInfo** ppti)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "CW3SFile::GetTypeInfo",
    "this=%#x; index=%#x; lcid=%#x; ppti=%#x",
    this,
    index,
    lcid,
    ppti
    ));

  HRESULT hr = E_NOTIMPL;

    if( ppti )
    {
      *ppti = NULL;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3SFile::GetIDsOfNames(REFIID riid, LPOLESTR* arNames, UINT cNames, LCID lcid, DISPID* arDispId)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "CW3SFile::GetIDsOfNames",
    "this=%#x; riid=%s; arNames=%#x; cNames=%d; lcid=%#x; arDispId=%#x",
    this,
    MapIIDToString(riid),
    arNames,
    cNames,
    lcid,
    arDispId
    ));

  HRESULT hr = S_OK;
  UINT    n  = 0L;

  if( !IsEqualIID(riid, IID_NULL) )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  while( n < cNames )
  {
    arDispId[n] = GetDispidFromName(g_FileDisptable, g_cFileDisptable, arNames[n]);
    ++n;
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3SFile::Invoke(DISPID dispid, REFIID riid, LCID lcid, WORD flags, DISPPARAMS* pdp, VARIANT* pvr, EXCEPINFO* pei, UINT* pae)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "CW3SFile::Invoke",
    "this=%#x; dispid=%s; riid=%s; lcid=%#x; flags=%#x; pdp=%#x; pvr=%#x; pei=%#x; pae=%#x",
    this,
    MapDispidToString(dispid),
    MapIIDToString(riid),
    lcid,
    flags,
    pdp, pvr,
    pei, pae
    ));

  HRESULT hr = S_OK;

  hr = ValidateDispatchArgs(riid, pdp, pvr, pae);

    if( FAILED(hr) )
      goto quit;

  switch( dispid )
  {
    case DISPID_FILE_OPEN :
      {
        NEWVARIANT(filename);
        NEWVARIANT(mode);

        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, FALSE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 1, TRUE, 1);

          if( SUCCEEDED(hr) )
          {
            hr = DispGetParam(pdp, 0, VT_BSTR, &filename, pae);
            
            if( SUCCEEDED(hr) )
            {
              if( FAILED(DispGetParam(pdp, 1, VT_UI4, &mode, pae)) )
              {
                V_VT(&mode)  = VT_UI4;
                V_UI4(&mode) = OPEN_EXISTING;
              }

              hr = Open(V_BSTR(&filename), mode, pvr);
            }
          }
        }

        VariantClear(&mode);
        VariantClear(&filename);
      }
      break;

    case DISPID_FILE_CLOSE :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, FALSE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 0, FALSE, 0);

          if( SUCCEEDED(hr) )
          {
            hr = Close();
          }
        }
      }
      break;

    case DISPID_FILE_WRITE :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, FALSE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 1, FALSE, 0);

          if( SUCCEEDED(hr) )
          {
            hr = Write(pdp->rgvarg[0], pvr);
          }
        }
      }
      break;

    case DISPID_FILE_WRITELINE :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, FALSE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 1, FALSE, 0);

          if( SUCCEEDED(hr) )
          {
            hr = WriteLine(V_BSTR(&pdp->rgvarg[0]), pvr);
          }
        }
      }
      break;

    case DISPID_FILE_WRITEBLANKLINE :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, FALSE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 0, FALSE, 0);

          if( SUCCEEDED(hr) )
          {
            hr = WriteBlankLine(pvr);
          }
        }
      }
      break;

    case DISPID_FILE_READ :
      {
        NEWVARIANT(bytes);

        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, FALSE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 1, FALSE, 0);

          if( SUCCEEDED(hr) )
          {
            hr = DispGetParam(pdp, 0, VT_UI4, &bytes, pae);

            if( SUCCEEDED(hr) )
            {
              hr = Read(bytes, pvr);
            }
          }
        }
        
        VariantClear(&bytes);
      }
      break;

    case DISPID_FILE_READALL :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, FALSE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 0, FALSE, 0);

          if( SUCCEEDED(hr) )
          {
            hr = ReadAll(pvr);
          }
        }
      }
      break;

    case DISPID_FILE_ATTRIBUTES :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_PROPERTYGET, TRUE);

        if( SUCCEEDED(hr) )
        {
          hr = Attributes(pvr);
        }
      }
      break;

    case DISPID_FILE_SIZE :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_PROPERTYGET, TRUE);

        if( SUCCEEDED(hr) )
        {
          hr = Size(pvr);
        }
      }
      break;

    case DISPID_FILE_TYPE :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_PROPERTYGET, TRUE);

        if( SUCCEEDED(hr) )
        {
          hr = Type(pvr);
        }
      }
      break;

    case DISPID_FILE_DATELASTMODIFIED :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_PROPERTYGET, TRUE);

        if( SUCCEEDED(hr) )
        {
          hr = DateLastModified(pvr);
        }
      }
      break;

    default : hr = DISP_E_MEMBERNOTFOUND;
  }

quit:

  if( FAILED(hr) )
  {
    hr = HandleDispatchError(L"file object", pei, hr);
  }

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\w3spoof\om\w3srt\guids.c ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    guids.c

Abstract:

    GUIDs for the w3spoof runtime objects.
    
Author:

    Paul M Midgen (pmidge) 06-November-2000

Revision History:

    06-November-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long  x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifdef __cplusplus
extern "C" {
#endif

// {B38C33BD-1623-4138-9DAB-7F81EBEB1A3D}
const IID IID_IW3SpoofRuntime = 
{
  0xb38c33bd,
  0x1623,
  0x4138,
  { 0x9d, 0xab, 0x7f, 0x81, 0xeb, 0xeb, 0x1a, 0x3d }
};


// {D128BB46-2C79-4432-91D9-5F5FCF240C83}
const IID IID_IW3SpoofFile = 
{
  0xd128bb46,
  0x2c79,
  0x4432,
  { 0x91, 0xd9, 0x5f, 0x5f, 0xcf, 0x24, 0xc, 0x83 }
};

// {B4560FD1-1EED-4d48-AAF1-88626F0A7EC4}
const IID IID_IW3SpoofPropertyBag = 
{
  0xb4560fd1,
  0x1eed,
  0x4d48,
  { 0xaa, 0xf1, 0x88, 0x62, 0x6f, 0xa, 0x7e, 0xc4 }
};

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\w3spoof\om\url\url.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    url.cxx

Abstract:

    Implements the Url object.
    
Author:

    Paul M Midgen (pmidge) 10-November-2000


Revision History:

    10-November-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

LPWSTR g_wszUrlObjectName = L"url";

//-----------------------------------------------------------------------------
// CUrl methods
//-----------------------------------------------------------------------------
CUrl::CUrl():
  m_cRefs(1),
  m_pSite(NULL),
  m_pti(NULL),
  m_bReadOnly(FALSE),
  m_szOriginalUrl(NULL),
  m_szUnescapedUrl(NULL),
  m_bEscaped(FALSE),
  m_wszUrl(NULL),
  m_wszScheme(NULL),
  m_usPort(0),
  m_wszServer(NULL),
  m_wszPath(NULL),
  m_wszResource(NULL),
  m_wszQuery(NULL),
  m_wszFragment(NULL)
{
  DEBUG_TRACE(URL, ("CUrl [%#x] created", this));
}


CUrl::~CUrl()
{
  DEBUG_TRACE(URL, ("CUrl [%#x] deleted", this));
}


HRESULT
CUrl::Create(CHAR* url, BOOL bReadOnly, PURLOBJ* ppurl)
{
  DEBUG_ENTER((
    DBG_URL,
    rt_hresult,
    "CUrl::Create",
    "url=%s; bReadOnly=%d; ppurl=%#x",
    url,
    bReadOnly,
    ppurl
    ));

  HRESULT hr  = S_OK;
  PURLOBJ puo = NULL;

  if( !url )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  if( !ppurl )
  {
    hr = E_POINTER;
    goto quit;
  }
  
  if( puo = new URLOBJ )
  {
    if( SUCCEEDED(puo->_Initialize(url, bReadOnly)) )
    {
      *ppurl = puo;
    }
    else
    {
      delete puo;
      *ppurl = NULL;
      hr     = E_FAIL;
    }
  }
  else
  {
    hr = E_OUTOFMEMORY;
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
CUrl::_Initialize(CHAR* url, BOOL bReadOnly)
{
  DEBUG_ENTER((
    DBG_URL,
    rt_hresult,
    "CUrl::_Initialize",
    "this=%#x; bReadOnly=%d; url=%s",
    this,
    bReadOnly,
    url
    ));

  HRESULT hr       = S_OK;
  BOOL    bCracked = FALSE;
  URLCOMP uc;

  if( !url )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  m_bReadOnly      = bReadOnly;
  m_szOriginalUrl  = __strdup(url);
  m_szUnescapedUrl = __unescape(url);  
  m_wszUrl         = __ansitowide(m_szUnescapedUrl);

  uc.dwStructSize      = sizeof(URLCOMP);
  uc.lpszScheme        = NULL;
  uc.dwSchemeLength    = -1;
  uc.nScheme           = INTERNET_SCHEME_UNKNOWN;
  uc.lpszHostName      = NULL;
  uc.dwHostNameLength  = -1;
  uc.nPort             = 0;
  uc.lpszUrlPath       = NULL;
  uc.dwUrlPathLength   = -1;
  uc.lpszExtraInfo     = NULL;
  uc.dwExtraInfoLength = -1;
  uc.lpszUserName      = NULL;
  uc.dwUserNameLength  = 0L;
  uc.lpszPassword      = NULL;
  uc.dwPasswordLength  = 0L;

  bCracked = WinHttpCrackUrl(
               m_wszUrl,
               wcslen(m_wszUrl),
               0,
               &uc
               );

  if( bCracked && (uc.nScheme != INTERNET_SCHEME_UNKNOWN) )
  {
    WCHAR* token = NULL;
    WCHAR* tmp   = NULL;

    // duplicate the scheme and hostname fields
    m_wszScheme   = __wstrndup(uc.lpszScheme, uc.dwSchemeLength);
    m_wszServer   = __wstrndup(uc.lpszHostName, uc.dwHostNameLength);

    // split out and duplicate the path and resource fields
    tmp           = __wstrndup(uc.lpszUrlPath, uc.dwUrlPathLength);
    token         = wcsrchr(tmp, L'/')+1;

    m_wszPath     = __wstrndup(
                      tmp,
                      (uc.dwUrlPathLength - wcslen(token))
                      );

    m_wszResource = __wstrndup(
                      (tmp + wcslen(m_wszPath)),
                      wcslen(token)
                      );

    SAFEDELETEBUF(tmp);

    // duplicate the query string field
    m_wszQuery    = __wstrndup(uc.lpszExtraInfo, uc.dwExtraInfoLength);
    m_wszFragment = NULL;

    // set the requested server port
    m_usPort      = uc.nPort;
  }
  else
  {
    DEBUG_TRACE(URL, ("WinHttpCrackUrl failed with %s", MapErrorToString(GetLastError())));

    CHAR* token  = NULL;
    CHAR* tmpurl = __unescape(url);

      // snag the extra info
      token = strrchr(tmpurl, '?');

      if( token )
      {
        m_wszQuery = __ansitowide(token);
        *token     = '\0';
      }

      // snag the resource
      token = strrchr(tmpurl, '/')+1;

      if( token )
      {
        m_wszResource = __ansitowide(token);
        *token        = '\0';
      }

      // snag the path
      m_wszPath = __ansitowide(tmpurl);

    SAFEDELETEBUF(tmpurl);
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


void
CUrl::_Cleanup(void)
{
  DEBUG_TRACE(URL, ("CUrl [%#x] cleaning up", this));

  m_bEscaped = FALSE;

  SAFEDELETEBUF(m_szOriginalUrl);
  SAFEDELETEBUF(m_szUnescapedUrl);
  SAFEDELETEBUF(m_wszUrl);
  SAFEDELETEBUF(m_wszScheme);
  SAFEDELETEBUF(m_wszServer);
  SAFEDELETEBUF(m_wszPath);
  SAFEDELETEBUF(m_wszResource);
  SAFEDELETEBUF(m_wszQuery);
  SAFEDELETEBUF(m_wszFragment);
}


void
CUrl::Terminate(void)
{
  DEBUG_TRACE(URL, ("CUrl [%#x] terminating", this));

  m_bReadOnly = FALSE;
  SAFERELEASE(m_pSite);
  Release();
}


//-----------------------------------------------------------------------------
// IUnknown
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CUrl::QueryInterface(REFIID riid, void** ppv)
{
  DEBUG_ENTER((
    DBG_REFCOUNT,
    rt_hresult,
    "CUrl::QueryInterface",
    "this=%#x; riid=%s; ppv=%#x",
    this,
    MapIIDToString(riid),
    ppv
    ));

  HRESULT hr = S_OK;

  if( !ppv )
  {
    hr = E_POINTER;
    goto quit;
  }

    if(
      IsEqualIID(riid, IID_IUnknown)  ||
      IsEqualIID(riid, IID_IDispatch) ||
      IsEqualIID(riid, IID_IUrl)
      )
    {
      *ppv = static_cast<IUrl*>(this);
    }
    else if( IsEqualIID(riid, IID_IProvideClassInfo) )
    {
      *ppv = static_cast<IProvideClassInfo*>(this);
    }
    else if( IsEqualIID(riid, IID_IObjectWithSite) )
    {
      *ppv = static_cast<IObjectWithSite*>(this);
    }
    else
    {
      *ppv = NULL;
      hr   = E_NOINTERFACE;
    }

  if( SUCCEEDED(hr) )
  {
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


ULONG
__stdcall
CUrl::AddRef(void)
{
  InterlockedIncrement(&m_cRefs);
  DEBUG_ADDREF("CUrl", m_cRefs);
  return m_cRefs;
}


ULONG
__stdcall
CUrl::Release(void)
{
  InterlockedDecrement(&m_cRefs);
  DEBUG_RELEASE("CUrl", m_cRefs);

  if( m_cRefs == 0 )
  {
    DEBUG_FINALRELEASE("CUrl");
    _Cleanup();
    SAFERELEASE(m_pti);
    delete this;
    return 0;
  }

  return m_cRefs;
}


//-----------------------------------------------------------------------------
// IProvideClassInfo
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CUrl::GetClassInfo(ITypeInfo** ppti)
{
  DEBUG_ENTER((
    DBG_URL,
    rt_hresult,
    "CUrl::GetClassInfo",
    "this=%#x; ppti=%#x",
    this,
    ppti
    ));

  HRESULT hr = S_OK;

    if( ppti )
    {
      m_pti->AddRef();
      *ppti = m_pti;
    }
    else
    {
      hr = E_POINTER;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


//-----------------------------------------------------------------------------
// IObjectWithSite
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CUrl::SetSite(IUnknown* pUnkSite)
{
  DEBUG_ENTER((
    DBG_URL,
    rt_hresult,
    "CUrl::SetSite",
    "this=%#x; pUnkSite=%#x",
    this,
    pUnkSite
    ));

  HRESULT            hr         = S_OK;
  IActiveScriptSite* pias       = NULL;
  IObjectWithSite*   pcontainer = NULL;

    if( !pUnkSite )
    {
      hr = E_INVALIDARG;
    }
    else
    {
      SAFERELEASE(m_pSite);
      SAFERELEASE(m_pti);

      m_pSite = pUnkSite;
      m_pSite->AddRef();

      hr = m_pSite->QueryInterface(IID_IObjectWithSite, (void**) &pcontainer);

      if( SUCCEEDED(hr) )
      {
        hr = pcontainer->GetSite(IID_IActiveScriptSite, (void**) &pias);

        if( SUCCEEDED(hr) )
        {
          hr = pias->GetItemInfo(
                       g_wszUrlObjectName,
                       SCRIPTINFO_ITYPEINFO,
                       NULL,
                       &m_pti
                       );
        }
      }
    }

  SAFERELEASE(pcontainer);
  SAFERELEASE(pias);

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CUrl::GetSite(REFIID riid, void** ppvSite)
{
  DEBUG_ENTER((
    DBG_URL,
    rt_hresult,
    "CUrl::GetSite",
    "this=%#x; riid=%s; ppvSite=%#x",
    this,
    MapIIDToString(riid),
    ppvSite
    ));

  HRESULT hr = S_OK;

    if( !ppvSite )
    {
      hr = E_POINTER;
    }
    else
    {
      if( m_pSite )
      {
        hr = m_pSite->QueryInterface(riid, ppvSite);
      }
      else
      {
        hr = E_FAIL;
      }
    }

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\w3spoof\om\w3srt\propertybag.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    propertybag.cxx

Abstract:

    Implements the propertybag runtime object.
    
Author:

    Paul M Midgen (pmidge) 06-November-2000


Revision History:

    06-November-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

//
// WARNING: do not modify these values. use disphash.exe to generate
//          new values.
//
DISPIDTABLEENTRY g_PropertyBagDisptable[] =
{
  0x00003b7b,   DISPID_PROPERTYBAG_GET,      L"get",
  0x00003f5f,   DISPID_PROPERTYBAG_SET,      L"set",
  0x00043afe,   DISPID_PROPERTYBAG_EXPIRES,  L"expires",
  0x00010803,   DISPID_PROPERTYBAG_FLUSH,    L"flush"
};

DWORD g_cPropertyBagDisptable = (sizeof(g_PropertyBagDisptable) / sizeof(DISPIDTABLEENTRY));


//-----------------------------------------------------------------------------
// CW3SPropertyBag
//-----------------------------------------------------------------------------
CW3SPropertyBag::CW3SPropertyBag():
  m_cRefs(1),
  m_name(NULL),
  m_stale(FALSE),
  m_expiry(0),
  m_created(0),
  m_propertybag(NULL)
{
  DEBUG_TRACE(RUNTIME, ("CW3SPropertyBag created: %#x"));
}


CW3SPropertyBag::~CW3SPropertyBag()
{
  DEBUG_TRACE(RUNTIME, ("CW3SPropertyBag deleted: %#x"));
}


HRESULT
CW3SPropertyBag::Create(LPWSTR name, PPROPERTYBAG* ppbag)
{
  DEBUG_ENTER((
    DBG_RUNTIME,
    rt_hresult,
    "CW3SPropertyBag::Create",
    "name=%S; ppbag=%#x",
    name,
    ppbag
    ));

  HRESULT      hr   = S_OK;
  PPROPERTYBAG pbag = NULL;

    if( !ppbag )
    {
      hr = E_POINTER;
    }
    else
    {
      if( pbag = new PROPERTYBAG )
      {
        if( SUCCEEDED(pbag->_Initialize(name)) )
        {
          *ppbag = pbag;
        }
        else
        {
          DEBUG_TRACE(RUNTIME, ("failed to create propertybag"));
          delete pbag;
          *ppbag = NULL;
          hr     = E_FAIL;
        }
      }
      else
      {
        hr = E_OUTOFMEMORY;
      }
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
CW3SPropertyBag::_Initialize(LPWSTR name)
{
  DEBUG_ENTER((
    DBG_RUNTIME,
    rt_hresult,
    "CW3SPropertyBag::_Initialize",
    "this=%#x; name=%S",
    this,
    name
    ));

  HRESULT hr = S_OK;

    m_expiry      = 3600000;
    m_created     = GetTickCount();
    m_name        = __wstrdup(name);
    m_propertybag = new STRINGMAP;

    m_propertybag->SetClearFunction(VariantKiller);

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
CW3SPropertyBag::Terminate(void)
{
  DEBUG_ENTER((
    DBG_RUNTIME,
    rt_hresult,
    "CW3SPropertyBag::Terminate",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

    m_propertybag->Clear();

    SAFEDELETE(m_propertybag);
    SAFEDELETEBUF(m_name);

    Release();

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
CW3SPropertyBag::GetBagName(LPWSTR* ppwsz)
{
  DEBUG_ENTER((
    DBG_RUNTIME,
    rt_hresult,
    "CW3SPropertyBag::GetBagName",
    "this=%#x; ppwsz=%#x",
    this,
    ppwsz
    ));

  HRESULT hr = S_OK;
  
    if( !ppwsz )
    {
      hr = E_POINTER;
    }
    else
    {
      *ppwsz = __wstrdup(m_name);
    }

  DEBUG_LEAVE(hr);
  return hr;
}


void
CW3SPropertyBag::_Reset(void)
{
  m_created = GetTickCount();
  DEBUG_TRACE(RUNTIME, ("creation time reset to %d msec", m_created));
}


BOOL
CW3SPropertyBag::_IsStale(void)
{
  DWORD now = GetTickCount();
  BOOL  ret = FALSE;

  if( m_created + m_expiry < now )
  {
    DEBUG_TRACE(RUNTIME, ("property bag is stale, flushing"));
    Flush();
    _Reset();
    ret = TRUE;
  }
  else
  {
    DEBUG_TRACE(
      RUNTIME,
      ("property bag valid for another %d msec", m_created+m_expiry-now)
      );
  }

  return ret;
}

//-----------------------------------------------------------------------------
// IUnknown
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CW3SPropertyBag::QueryInterface(REFIID riid, void** ppv)
{
  DEBUG_ENTER((
    DBG_RUNTIME,
    rt_hresult,
    "CW3SPropertyBag::QueryInterface",
    "this=%#x; riid=%s; ppv=%#x",
    this,
    MapIIDToString(riid),
    ppv
    ));

  HRESULT hr = S_OK;

  if( !ppv )
  {
    hr = E_POINTER;
    goto quit;
  }

    if(
      IsEqualIID(riid, IID_IUnknown)  ||
      IsEqualIID(riid, IID_IDispatch) ||
      IsEqualIID(riid, IID_IW3SpoofPropertyBag)
      )
    {
      *ppv = static_cast<IW3SpoofPropertyBag*>(this);
    }
    else
    {
      *ppv = NULL;
      hr   = E_NOINTERFACE;
    }

  if( SUCCEEDED(hr) )
  {
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


ULONG
__stdcall
CW3SPropertyBag::AddRef(void)
{
  InterlockedIncrement(&m_cRefs);
  DEBUG_ADDREF("CW3SPropertyBag", m_cRefs);
  return m_cRefs;
}


ULONG
__stdcall
CW3SPropertyBag::Release(void)
{
  InterlockedDecrement(&m_cRefs);
  DEBUG_RELEASE("CW3SPropertyBag", m_cRefs);

  if( m_cRefs == 0 )
  {
    DEBUG_FINALRELEASE("CW3SPropertyBag");
    delete this;
    return 0;
  }

  return m_cRefs;
}


//-----------------------------------------------------------------------------
// IDispatch
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CW3SPropertyBag::GetTypeInfoCount(UINT* pctinfo)
{
  DEBUG_ENTER((
    DBG_RUNTIME,
    rt_hresult,
    "CW3SPropertyBag::GetTypeInfoCount",
    "this=%#x; pctinfo=%#x",
    this,
    pctinfo
    ));

  HRESULT hr = E_NOTIMPL;

    if( pctinfo )
    {
      *pctinfo = 0;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3SPropertyBag::GetTypeInfo(UINT index, LCID lcid, ITypeInfo** ppti)
{
  DEBUG_ENTER((
    DBG_RUNTIME,
    rt_hresult,
    "CW3SPropertyBag::GetTypeInfo",
    "this=%#x; index=%#x; lcid=%#x; ppti=%#x",
    this,
    index,
    lcid,
    ppti
    ));

  HRESULT hr = E_NOTIMPL;

    if( ppti )
    {
      *ppti = NULL;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3SPropertyBag::GetIDsOfNames(REFIID riid, LPOLESTR* arNames, UINT cNames, LCID lcid, DISPID* arDispId)
{
  DEBUG_ENTER((
    DBG_RUNTIME,
    rt_hresult,
    "CW3SPropertyBag::GetIDsOfNames",
    "this=%#x; riid=%s; arNames=%#x; cNames=%d; lcid=%#x; arDispId=%#x",
    this,
    MapIIDToString(riid),
    arNames,
    cNames,
    lcid,
    arDispId
    ));

  HRESULT hr = S_OK;
  UINT    n  = 0L;

  if( !IsEqualIID(riid, IID_NULL) )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  while( n < cNames )
  {
    arDispId[n] = GetDispidFromName(g_PropertyBagDisptable, g_cPropertyBagDisptable, arNames[n]);
    ++n;
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3SPropertyBag::Invoke(DISPID dispid, REFIID riid, LCID lcid, WORD flags, DISPPARAMS* pdp, VARIANT* pvr, EXCEPINFO* pei, UINT* pae)
{
  DEBUG_ENTER((
    DBG_RUNTIME,
    rt_hresult,
    "CW3SPropertyBag::Invoke",
    "this=%#x; dispid=%s; riid=%s; lcid=%#x; flags=%#x; pdp=%#x; pvr=%#x; pei=%#x; pae=%#x",
    this,
    MapDispidToString(dispid),
    MapIIDToString(riid),
    lcid,
    flags,
    pdp, pvr,
    pei, pae
    ));

  HRESULT hr = S_OK;

  // make sure there aren't any bits set we don't understand
  if( flags & ~(DISPATCH_METHOD | DISPATCH_PROPERTYGET | DISPATCH_PROPERTYPUT) )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  if( !IsEqualIID(riid, IID_NULL) )
  {
    hr = DISP_E_UNKNOWNINTERFACE;
    goto quit;
  }

  if( !pdp )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  if( pae )
  {
    *pae = 0;
  }

  if( pvr )
  {
    VariantInit(pvr);
  }

  switch( dispid )
  {
    case DISPID_PROPERTYBAG_GET :
      {
        NEWVARIANT(name);

        if( pdp->cArgs == 1 )
        {
          if( pvr )
          {
            DispGetParam(pdp, 0, VT_BSTR, &name, pae);

              hr = Get(V_BSTR(&name), pvr);

            VariantClear(&name);
          }
          else
          {
            hr = DISP_E_PARAMNOTOPTIONAL;
          }
        }
        else
        {
          hr = DISP_E_BADPARAMCOUNT;
        }
      }
      break;

    case DISPID_PROPERTYBAG_SET :
      {
        NEWVARIANT(name);
        NEWVARIANT(value);

        if( pdp->cArgs == 2 )
        {
          hr = VariantCopy(&value, &pdp->rgvarg[0]);
        }
        
        DispGetParam(pdp, 0, VT_BSTR, &name, pae);
        
          hr = Set(V_BSTR(&name), value);

        VariantClear(&name);
        VariantClear(&value);
      }
      break;

    case DISPID_PROPERTYBAG_EXPIRES :
      {
        if( flags & DISPATCH_PROPERTYGET )
        {
          V_VT(pvr) = VT_UI4;
          hr        = get_Expires(pvr);
        }
        else if( flags & DISPATCH_PROPERTYPUT || flags & DISPATCH_METHOD )
        {
          NEWVARIANT(expiry);

          hr = DispGetParam(pdp, 0, VT_UI4, &expiry, pae);

            if( SUCCEEDED(hr) )
            {
              hr = put_Expires(expiry);
            }

          VariantClear(&expiry);
        }
      }
      break;

    case DISPID_PROPERTYBAG_FLUSH :
      {
        Flush();
      }
      break;

    default :
    {
      hr = DISP_E_MEMBERNOTFOUND;
    }
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


//-----------------------------------------------------------------------------
// IW3SpoofPropertyBag
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CW3SPropertyBag::Get(BSTR Name, VARIANT* Value)
{
  DEBUG_ENTER((
    DBG_RUNTIME,
    rt_hresult,
    "CW3SPropertyBag::Get",
    "this=%#x; name=%S",
    this,
    Name
    ));

  HRESULT  hr  = S_OK;
  VARIANT* pvr = NULL;

  _IsStale();

    if( !Name )
    {
      hr = E_INVALIDARG;
    }
    else
    {
      if( m_propertybag->Get(Name, (void**) &pvr) == ERROR_SUCCESS )
      {
        hr = VariantCopy(Value, pvr);

        //
        // TODO: debug logging function that accepts Name & pvr
        //       and outputs useful information (name, type, data, etc.)
        //
      }
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3SPropertyBag::Set(BSTR Name, VARIANT Value)
{
  DEBUG_ENTER((
    DBG_RUNTIME,
    rt_hresult,
    "CW3SPropertyBag::Set",
    "this=%#x; name=%S",
    this,
    Name
    ));

  HRESULT  hr  = S_OK;
  VARIANT* pvr = NULL;

  _IsStale();

    if( !Name )
    {
      hr = E_INVALIDARG;
    }
    else
    {
      if( !__isempty(Value) )
      {
        pvr = new VARIANT;
        VariantInit(pvr);

        hr = VariantCopy(pvr, &Value);

        if( SUCCEEDED(hr) )
        {
          //
          // TODO: debug logging function that accepts Name & pvr
          //       and outputs useful information (name, type, data, etc.)
          //
          m_propertybag->Insert(Name, (void*) pvr);
        }
      }
      else
      {
        DEBUG_TRACE(RUNTIME, ("removing property \"%S\"", Name));
        m_propertybag->Delete(Name, NULL);
      }
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3SPropertyBag::get_Expires(VARIANT* Expiry)
{
  DEBUG_ENTER((
    DBG_RUNTIME,
    rt_hresult,
    "CW3SPropertyBag::get_Expires",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

    V_UI4(Expiry) = m_expiry;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3SPropertyBag::put_Expires(VARIANT Expiry)
{
  DEBUG_ENTER((
    DBG_RUNTIME,
    rt_hresult,
    "CW3SPropertyBag::put_Expires",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

    m_expiry = V_UI4(&Expiry);
    DEBUG_TRACE(RUNTIME, ("property bag will expire in %d msec", m_expiry));
    _Reset();

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3SPropertyBag::Flush(void)
{
  DEBUG_ENTER((
    DBG_RUNTIME,
    rt_hresult,
    "CW3SPropertyBag::Flush",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

    m_propertybag->Clear();
    DEBUG_TRACE(RUNTIME, ("property bag has been flushed"));

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\w3spoof\w3scon\w3scon.h ===
#ifndef _W3SUI_H_
#define _W3SUI_H_

class CW3SpoofUI : public IW3SpoofEvents
{
  public:
    //
    // IUnknown and IW3SpoofEvents
    //
    HRESULT __stdcall QueryInterface(REFIID riid, void** ppv);
    ULONG   __stdcall AddRef(void);
    ULONG   __stdcall Release(void);

    HRESULT __stdcall OnSessionOpen(LPWSTR clientid);
    HRESULT __stdcall OnSessionStateChange(LPWSTR clientid, STATE state);
    HRESULT __stdcall OnSessionClose(LPWSTR clientid);

    //
    // object methods 
    //
    CW3SpoofUI();
   ~CW3SpoofUI();

    static HRESULT Create(CW3SpoofUI** ppw3sui, HINSTANCE hInst, IW3SpoofClientSupport* pcs);

    HRESULT Initialize(HINSTANCE hInst, IW3SpoofClientSupport* pcs);
    HRESULT Terminate(void);
    HRESULT Run(void);

    friend LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

  protected:
    LRESULT _WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

  private:
    HRESULT _CreateUI(void);
    HRESULT _CreateTrayIcon(void);
    HRESULT _UpdateTrayIcon(void);
    HRESULT _DestroyTrayIcon(void);
    void  _WriteText(const WCHAR* format, ...);

    HINSTANCE         m_hInst;
    HWND              m_hWnd;
    HWND              m_listbox;
    HFONT             m_font;
    HICON             m_hIcon;
    IConnectionPoint* m_pCP;
    DWORD             m_dwCookie;
    LONG              m_cRefs;
};

#endif /* _W3SUI_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\w3spoof\om\w3srt\w3srtobj.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    w3srtobj.cxx

Abstract:

    Implements the w3spoof runtime object.
    
Author:

    Paul M Midgen (pmidge) 06-November-2000


Revision History:

    06-November-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

LPWSTR g_wszRuntimeObjectName = L"w3srt";

//
// WARNING: do not modify these values. use disphash.exe to generate
//          new values.
//
DISPIDTABLEENTRY g_RuntimeDisptable[] =
{
  0x00041557, DISPID_RUNTIME_GETFILE, L"getfile"
};

DWORD g_cRuntimeDisptable = (sizeof(g_RuntimeDisptable) / sizeof(DISPIDTABLEENTRY));

//-----------------------------------------------------------------------------
// CW3SRuntime
//-----------------------------------------------------------------------------
CW3SRuntime::CW3SRuntime():
  m_cRefs(1),
  m_propertybags(NULL)
{
  DEBUG_TRACE(RUNTIME, ("CW3SRuntime created: %#x", this));
}


CW3SRuntime::~CW3SRuntime()
{
  DEBUG_TRACE(RUNTIME, ("CW3SRuntime deleted: %#x", this));
}


HRESULT
CW3SRuntime::Create(PRUNTIME* pprt)
{
  DEBUG_ENTER((
    DBG_RUNTIME,
    rt_hresult,
    "CW3SRuntime::Create",
    "pprt=%#x",
    pprt
    ));

  HRESULT  hr  = S_OK;
  PRUNTIME prt = NULL;

    if( !pprt )
    {
      hr = E_POINTER;
    }
    else
    {
      if( prt = new RUNTIME )
      {
        if( SUCCEEDED(prt->_Initialize()) )
        {
          *pprt = prt;
        }
        else
        {
          DEBUG_TRACE(RUNTIME, ("failed to initialize runtime"));
          delete prt;
          *pprt = NULL;
          hr    = E_FAIL;
        }
      }
      else
      {
        hr = E_OUTOFMEMORY;
      }
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
CW3SRuntime::_Initialize(void)
{
  DEBUG_ENTER((
    DBG_RUNTIME,
    rt_hresult,
    "CW3SRuntime::_Initialize",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

    m_propertybags = new STRINGMAP;

      if( m_propertybags )
      {
        m_propertybags->SetClearFunction(PropertyBagKiller);
      }
      else
      {
        DEBUG_TRACE(RUNTIME, ("failed to create propertybag bag"));
        hr = E_FAIL;
      }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
CW3SRuntime::Terminate(void)
{
  DEBUG_ENTER((
    DBG_RUNTIME,
    rt_hresult,
    "CW3SRuntime::Terminate",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

    m_propertybags->Clear();
    SAFEDELETE(m_propertybags);

    Release();

  DEBUG_LEAVE(hr);
  return hr;
}


//-----------------------------------------------------------------------------
// IUnknown
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CW3SRuntime::QueryInterface(REFIID riid, void** ppv)
{
  DEBUG_ENTER((
    DBG_REFCOUNT,
    rt_hresult,
    "CW3SRuntime::QueryInterface",
    "this=%#x; riid=%s; ppv=%#x",
    this,
    MapIIDToString(riid),
    ppv
    ));

  HRESULT hr = S_OK;

  if( !ppv )
  {
    hr = E_POINTER;
    goto quit;
  }

    if( IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IW3SpoofRuntime) )
    {
      *ppv = static_cast<IW3SpoofRuntime*>(this);
    }
    else if( IsEqualIID(riid, IID_IDispatch) )
    {
      *ppv = static_cast<IDispatch*>(this);
    }
    else
    {
      *ppv = NULL;
      hr   = E_NOINTERFACE;
    }

  if( SUCCEEDED(hr) )
  {
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


ULONG
__stdcall
CW3SRuntime::AddRef(void)
{
  InterlockedIncrement(&m_cRefs);
  DEBUG_ADDREF("CW3SRuntime", m_cRefs);
  return m_cRefs;
}


ULONG
__stdcall
CW3SRuntime::Release(void)
{
  InterlockedDecrement(&m_cRefs);
  DEBUG_RELEASE("CW3SRuntime", m_cRefs);

  if( m_cRefs == 0 )
  {
    DEBUG_FINALRELEASE("CW3SRuntime");
    delete this;
    return 0;
  }

  return m_cRefs;
}


//-----------------------------------------------------------------------------
// IDispatch
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CW3SRuntime::GetTypeInfoCount(UINT* pctinfo)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "CW3SRuntime::GetTypeInfoCount",
    "this=%#x; pctinfo=%#x",
    this,
    pctinfo
    ));

  HRESULT hr = E_NOTIMPL;

    if( pctinfo )
    {
      *pctinfo = 0;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3SRuntime::GetTypeInfo(UINT index, LCID lcid, ITypeInfo** ppti)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "CW3SRuntime::GetTypeInfo",
    "this=%#x; index=%#x; lcid=%#x; ppti=%#x",
    this,
    index,
    lcid,
    ppti
    ));

  HRESULT hr = E_NOTIMPL;

    if( ppti )
    {
      *ppti = NULL;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3SRuntime::GetIDsOfNames(REFIID riid, LPOLESTR* arNames, UINT cNames, LCID lcid, DISPID* arDispId)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "CW3SRuntime::GetIDsOfNames",
    "this=%#x; riid=%s; arNames=%#x; cNames=%d; lcid=%#x; arDispId=%#x",
    this,
    MapIIDToString(riid),
    arNames,
    cNames,
    lcid,
    arDispId
    ));

  HRESULT hr = S_OK;
  UINT    n  = 0L;

  if( !IsEqualIID(riid, IID_NULL) )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  while( n < cNames )
  {
    arDispId[n] = GetDispidFromName(g_RuntimeDisptable, g_cRuntimeDisptable, arNames[n]);
    ++n;
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3SRuntime::Invoke(DISPID dispid, REFIID riid, LCID lcid, WORD flags, DISPPARAMS* pdp, VARIANT* pvr, EXCEPINFO* pei, UINT* pae)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "CW3SRuntime::Invoke",
    "this=%#x; dispid=%s; riid=%s; lcid=%#x; flags=%#x; pdp=%#x; pvr=%#x; pei=%#x; pae=%#x",
    this,
    MapDispidToString(dispid),
    MapIIDToString(riid),
    lcid,
    flags,
    pdp, pvr,
    pei, pae
    ));

  HRESULT hr = S_OK;

  // make sure there aren't any bits set we don't understand
  if( flags & ~(DISPATCH_METHOD | DISPATCH_PROPERTYGET | DISPATCH_PROPERTYPUT) )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  if( !IsEqualIID(riid, IID_NULL) )
  {
    hr = DISP_E_UNKNOWNINTERFACE;
    goto quit;
  }

  if( !pdp )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  if( pae )
  {
    *pae = 0;
  }

  if( pvr )
  {
    VariantInit(pvr);
  }

  switch( dispid )
  {
    case DISPID_RUNTIME_GETFILE :
      {
        if( pvr )
        {
          V_VT(pvr) = VT_DISPATCH;
          hr        = GetFile(&V_DISPATCH(pvr));
        }
      }
      break;

    default :
      {
        hr = DISP_E_MEMBERNOTFOUND;
      }
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


//-----------------------------------------------------------------------------
// IW3SpoofRuntime
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CW3SRuntime::GetFile(IDispatch** ppdisp)
{
  DEBUG_ENTER((
    DBG_RUNTIME,
    rt_hresult,
    "CW3SRuntime::GetFile",
    "this=%#x; ppdisp=%#x",
    this,
    ppdisp
    ));

  HRESULT       hr    = S_OK;
  IW3SpoofFile* pw3sf = NULL;

    if( !ppdisp )
    {
      hr = E_POINTER;
    }
    else
    {
      if( SUCCEEDED(FILEOBJ::Create(&pw3sf)) )
      {
        hr = pw3sf->QueryInterface(IID_IDispatch, (void**) ppdisp);
      }
    }

  SAFERELEASE(pw3sf);
  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3SRuntime::GetPropertyBag(BSTR Name, IW3SpoofPropertyBag** ppbag)
{
  DEBUG_ENTER((
    DBG_RUNTIME,
    rt_hresult,
    "CW3SRuntime::GetPropertyBag",
    "this=%#x; name=%S; ppbag=%#x",
    this,
    Name,
    ppbag
    ));

  HRESULT      hr      = S_OK;
  PPROPERTYBAG pbagobj = NULL;

    if( m_propertybags->Get(Name, (void**) &pbagobj) != ERROR_SUCCESS )
    {
      DEBUG_TRACE(RUNTIME, ("no existing property bag, creating new one"));

      if( SUCCEEDED(PROPERTYBAG::Create(Name, &pbagobj)) )
      {
        m_propertybags->Insert(Name, (void*) pbagobj);
      }
      else
      {
        DEBUG_TRACE(RUNTIME, ("failed to create new property bag"));
        *ppbag = NULL;
        hr     = E_FAIL;
        goto quit;
      }
    }

    DEBUG_TRACE(RUNTIME, ("retrieving property bag"));
    hr = pbagobj->QueryInterface(IID_IW3SpoofPropertyBag, (void**) ppbag);

quit:

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\w3spoof\w3scon\w3scon.inc ===
!IF 0

Copyright (c) 1994  Microsoft Corporation

Module Name:

    w3scon.inc

Abstract:

    Common makefile contents for w3scon project

!ENDIF

!IFNDEF SDKINC
SDKINC=$(SDK_INC_PATH)
!ENDIF

!IFDEF LIBDIR
!ERROR LIBDIR already defined - choose new name
!ENDIF

LIBDIR=$(_OBJ_DIR)
W3SPOOFINC=..\inc

#
# if TARGETPATH is not defined (in the paths that build libraries) then this
# is the default target path
#
!IFNDEF TARGETPATH
TARGETPATH=$(LIBDIR)
TARGETTYPE=LIBRARY
!ENDIF

#
# what it is that we're building
#
MAJORCOMP=w3scon

USE_NOLIBS=1
#USE_LIBCMT=0
NO_NTDLL=1
#NO_BINPLACE=1
#BINPLACE_PLACEFILE=..\binplace.txt

#
# Linker flags
#
WIN32_WINNT_VERSION=0x0500
#WIN32_WIN95_VERSION=0x0400

#
# compiler warning flags
#
MSC_WARNING_LEVEL=/W3 /WX

#
# compiler definitions
#
C_DEFINES=$(C_DEFINES) -DWIN32

#CLEANINF = cleaninf.exe $(CLEANINF_FLAGS)

#
# Set debugging level
#
!IF "$(NTDEBUG)" != "" && "$(NTDEBUG)" != "retail" && "$(NTDEBUG)" != "ntsdnodbg"
C_DEFINES=$(C_DEFINES) -D_DEBUG
!ENDIF

!IF "$(__FULL_DEBUG__)" != "" && "$(__RELEASE_DEBUG__)" == ""
C_DEFINES=$(C_DEFINES) -D__FULL_DEBUG__
!IF "$(__DBG_TO_CONSOLE__)" == "1"
C_DEFINES=$(C_DEFINES) -D__DBG_TO_CONSOLE__
!ENDIF
!ENDIF

!IF "$(__RELEASE_DEBUG__)" != "" && "$(__FULL_DEBUG__)" == ""
C_DEFINES=$(C_DEFINES) -D__RELEASE_DEBUG__
!ENDIF


!IFNDEF W3SPOOF_PCH
PRECOMPILED_OPTION=/Fp..\inc\$(_OBJ_DIR)\*\common.pch /Yucommon.h
PRECOMPILED_CXX=1
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\w3spoof\w3scon\w3scon.cxx ===
#include "common.h"
#include <windowsx.h>
#include <stdio.h>
#include "w3scon.h"

CW3SpoofUI* g_pw3sui      = NULL;
LPCWSTR     g_wszShowUI   = L"ShowUI";
LPCWSTR     g_wszNIFText1 = L"W3Spoof is running.";

//-----------------------------------------------------------------------------
// Program entry
//-----------------------------------------------------------------------------
int
WINAPI
WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR szCmdLine, int iCmdShow)
{
  HRESULT                hr  = S_OK;
  IW3SpoofClientSupport* pcs = NULL;

  CoInitialize(NULL);

  hr = CoCreateInstance(
         CLSID_W3Spoof,
         NULL,
         CLSCTX_LOCAL_SERVER,
         IID_IW3SpoofClientSupport,
         (void**) &pcs
         );

  if( SUCCEEDED(hr) )
  {
    hr = CW3SpoofUI::Create(&g_pw3sui, hInstance, pcs);

    if( SUCCEEDED(hr) )
    {
      g_pw3sui->Run();
    }
  
    g_pw3sui->Terminate();
  }

  if( pcs )
    pcs->Release();

  CoUninitialize();

  return 0L;
}


//-----------------------------------------------------------------------------
// CW3SpoofUI methods
//-----------------------------------------------------------------------------
CW3SpoofUI::CW3SpoofUI()
{
  m_hInst = NULL;
  m_hWnd  = NULL;
  m_cRefs = 1L;
  m_hIcon = NULL;
}


CW3SpoofUI::~CW3SpoofUI()
{
}


HRESULT
CW3SpoofUI::Create(CW3SpoofUI** ppw3sui, HINSTANCE hInst, IW3SpoofClientSupport* pcs)
{
  HRESULT hr = S_OK;

  if( !ppw3sui )
  {
    hr = E_INVALIDARG;
  }
  else
  {
    *ppw3sui = new CW3SpoofUI;

    if( !(*ppw3sui) )
    {
      hr = E_OUTOFMEMORY;
    }
    else
    {
      hr = (*ppw3sui)->Initialize(hInst, pcs);
    }
  }

  return hr;
}


HRESULT
CW3SpoofUI::Initialize(HINSTANCE hInst, IW3SpoofClientSupport* pcs)
{
  LPDWORD pdw   = NULL;
  HRESULT hr    = S_OK;
  IConnectionPointContainer* pCPC = NULL;

  if( !hInst )
  {
    hr = E_INVALIDARG;
    goto quit;
  }
  else
  {
    m_hInst = hInst;
  }

  //
  // load our friendly icon and if successful create the ui
  //
  m_hIcon = (HICON) LoadImage(m_hInst, L"IDI_W3SPOOF", IMAGE_ICON, 16, 16, 0);

  if( m_hIcon )
  {
    hr = _CreateUI();
  }
  else
  {
    hr = E_FAIL;
    goto quit;
  }

  //
  // sink the IW3SpoofEvents interface.
  //
  hr = pcs->QueryInterface(IID_IConnectionPointContainer, (void**) &pCPC);
  
  if( SUCCEEDED(hr) )
  {
    hr = pCPC->FindConnectionPoint(IID_IW3SpoofEvents, &m_pCP);

      if( SUCCEEDED(hr) )
      {
        pCPC->Release();
      }
      else
      {
        goto quit;
      }

    hr = m_pCP->Advise(static_cast<IUnknown*>(this), &m_dwCookie);
  }
  
quit:

  return hr;
}


HRESULT
CW3SpoofUI::Terminate(void)
{
  HRESULT hr = S_OK;

    if( m_pCP )
      m_pCP->Unadvise(m_dwCookie);

    SAFERELEASE(m_pCP);

    _DestroyTrayIcon();

    //
    // the ui object is created with a refcount of 1. this release will
    // drop the refcount to 0 and cause the object to be deleted.
    //
    Release();

  return hr;
}


HRESULT
CW3SpoofUI::Run()
{
  HRESULT hr = S_OK;
  MSG     msg;

    while( GetMessage(&msg, NULL, 0, 0) )   
    {
      TranslateMessage(&msg);
      DispatchMessage(&msg);
    }
  
  return hr;
}


HRESULT
CW3SpoofUI::_CreateUI(void)
{
  HRESULT    hr    = S_OK;
  DWORD      dwRet = ERROR_SUCCESS;
  WNDCLASSEX wc    = {0};

    wc.cbSize        = sizeof(wc);
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = 0;

    wc.hInstance     = m_hInst;
    wc.lpfnWndProc   = WndProc;
    wc.lpszMenuName  = NULL;
    wc.lpszClassName = L"w3spoof_main";

    wc.style         = CS_HREDRAW | CS_VREDRAW;
    wc.hIcon         = m_hIcon;
    wc.hIconSm       = NULL;
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH) GetStockObject(WHITE_BRUSH);

    RegisterClassEx(&wc);

    m_hWnd = CreateWindow(
               wc.lpszClassName,
               L"w3spoof",
               WS_OVERLAPPEDWINDOW,
               CW_USEDEFAULT,
               CW_USEDEFAULT,
               600,
               600,
               NULL,
               NULL,
               wc.hInstance,
               NULL
               );

    if( m_hWnd )
    {
      hr = _CreateTrayIcon();
    }
    else
    {
      hr = E_FAIL;
      goto quit;
    }
    
    ShowWindow(m_hWnd, SW_SHOWNORMAL);
    UpdateWindow(m_hWnd);

quit:

  return hr;
}


HRESULT
CW3SpoofUI::_CreateTrayIcon(void)
{
  HRESULT        hr    = S_OK;
  NOTIFYICONDATA nid   = {0};

  nid.cbSize           = sizeof(NOTIFYICONDATA);
  nid.hWnd             = m_hWnd;
  nid.uID              = SHELLMESSAGE_W3SICON;
  nid.uCallbackMessage = nid.uID;
  nid.uFlags           = NIF_ICON | NIF_MESSAGE | NIF_TIP;
  nid.hIcon            = m_hIcon;

  wsprintf(nid.szTip, L"%s", g_wszNIFText1);

  if( !Shell_NotifyIcon(NIM_ADD, &nid) )
  {
    hr = E_FAIL;
  }

  return hr;
}


HRESULT
CW3SpoofUI::_UpdateTrayIcon(void)
{
  //
  // TODO: implementation
  //

  return S_OK;
}


HRESULT
CW3SpoofUI::_DestroyTrayIcon(void)
{
  HRESULT        hr    = S_OK;
  NOTIFYICONDATA nid   = {0};

  nid.cbSize           = sizeof(NOTIFYICONDATA);
  nid.hWnd             = m_hWnd;
  nid.uID              = SHELLMESSAGE_W3SICON;
  nid.uCallbackMessage = nid.uID;

  if( !Shell_NotifyIcon(NIM_DELETE, &nid) )
  {
    hr = E_FAIL;
  }

  DestroyIcon(m_hIcon);
  return hr;
}


void
CW3SpoofUI::_WriteText(const WCHAR* format, ...)
{
  int        ret       = 0;
  int        offset    = 0;
  WCHAR*     timestamp = new WCHAR[256];
  WCHAR*     buffer    = new WCHAR[1024];
  va_list    arg_list;
  SYSTEMTIME st;
 
  GetLocalTime(&st);

  wsprintf(
    timestamp,
    L"%0.2d:%0.2d:%0.2d.%0.3d",
    st.wHour,
    st.wMinute,
    st.wSecond,
    st.wMilliseconds
    );

    offset = wsprintf(buffer, L"[%s] ", timestamp);

    va_start(arg_list, format);

      _vsnwprintf(
        (buffer + offset),
        (1024 - wcslen(timestamp)),
        format,
        arg_list
        );

    va_end(arg_list);

    do
    {
      if( (ret = ListBox_AddString(m_listbox, buffer)) == LB_ERR )
      {
        ListBox_DeleteString(m_listbox, 0);
      }
      else
      {
        ListBox_SetCurSel(m_listbox, ret);
      }
    }
    while( ret == LB_ERR );

  SAFEDELETEBUF(timestamp);
  SAFEDELETEBUF(buffer);
}


//-----------------------------------------------------------------------------
// IUnknown
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CW3SpoofUI::QueryInterface(REFIID riid, void** ppv)
{
  HRESULT hr = S_OK;

  if( !ppv )
  {
    hr = E_POINTER;
  }
  else
  {
    if( IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IW3SpoofEvents))
    {
      *ppv = static_cast<IW3SpoofEvents*>(this);
    }
    else
    {
      *ppv = NULL;
      hr   = E_NOINTERFACE;
    }

    if( SUCCEEDED(hr) )
      reinterpret_cast<IUnknown*>(*ppv)->AddRef();
  }

  return hr;
}


ULONG
__stdcall
CW3SpoofUI::AddRef(void)
{
  InterlockedIncrement(&m_cRefs);
  return m_cRefs;
}


ULONG
__stdcall
CW3SpoofUI::Release(void)
{
  InterlockedDecrement(&m_cRefs);

  if( m_cRefs == 0 )
  {
    delete this;
    return 0;
  }

  return m_cRefs;
}


//-----------------------------------------------------------------------------
// IW3SpoofEvents methods
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CW3SpoofUI::OnSessionOpen(LPWSTR clientid)
{
  _WriteText(
    L"client %s session is open",
    clientid
    );

  return S_OK;
}


HRESULT
__stdcall
CW3SpoofUI::OnSessionStateChange(LPWSTR clientid, STATE state)
{
  return S_OK;
}


HRESULT
__stdcall
CW3SpoofUI::OnSessionClose(LPWSTR clientid)
{
  _WriteText(
    L"client %s session is closed",
    clientid
    );

  return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\w3spoof\w3scon\wndproc.cxx ===
#include "common.h"
#include "w3scon.h"

extern CW3SpoofUI* g_pw3sui;

LRESULT
CALLBACK
WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
  return g_pw3sui->_WndProc(hwnd, msg, wParam, lParam);
}


LRESULT
CW3SpoofUI::_WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
  DWORD   ret = 0;
  RECT    rect;
  LOGFONT logfont;

  switch( msg )
  {
    case WM_CREATE :
      {
        InitCommonControls();
    
        GetClientRect(hwnd, &rect);

        m_listbox = CreateWindowEx(
                      WS_EX_CLIENTEDGE,
                      L"listbox",
                      NULL,                         
                      WS_CHILD | WS_VISIBLE | WS_HSCROLL | WS_VSCROLL | \
                      WS_BORDER | LBS_NOSEL | LBS_NOINTEGRALHEIGHT,
                      rect.left, rect.top, rect.right, rect.bottom,
                      hwnd,
                      NULL,
                      (HINSTANCE) GetWindowLong(hwnd, GWL_HINSTANCE),
                      NULL
                      );
        
        GetObject(
          GetStockObject(ANSI_FIXED_FONT),
          sizeof(LOGFONT),
          (LPVOID) &logfont
          );

        m_font = CreateFontIndirect(&logfont);
        PostMessage(m_listbox, WM_SETFONT, (WPARAM) m_font, 0);
      }
      break;

    case SHELLMESSAGE_W3SICON :
      {
      }
      break;

    case WM_SIZE :
      {
        GetClientRect(hwnd, &rect);

        MoveWindow(
          m_listbox,
          rect.left, rect.top,
          rect.right, rect.bottom,
          FALSE
          );

        InvalidateRect(hwnd, &rect, TRUE);
      }
      break;

    case WM_DESTROY :
      {
        DeleteObject(m_font);
        PostQuitMessage(0);
      }
      break;

    default : return DefWindowProc(hwnd, msg, wParam, lParam);
  }

  return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\w3spoof\w3sobj\ioctx.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    ioctx.cxx

Abstract:

    Implements the IO Context object.
    
Author:

    Paul M Midgen (pmidge) 08-February-2001


Revision History:

    08-February-2001 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

IOCTX::IOCTX(IOTYPE iot, SOCKET s):
  clientid(NULL),
  local(NULL),
  remote(NULL),
  session(NULL),
  socket(s),
  sockbuf(NULL),
  bytes(0),
  flags(0),
  bufsize(0),
  error(0),
  _iot(iot),
  _cRefs(1)
{
  pthis = this;
  memset(&overlapped, 0, sizeof(OVERLAPPED));

  if( _iot == IOCT_CONNECT )
  {
    sockbuf = new BYTE[((sizeof(SOCKADDR_IN)+16)*2)];
  }
}

IOCTX::~IOCTX()
{
  if( _iot == IOCT_CONNECT )
  {
    SAFEDELETE(sockbuf);
    SAFEDELETEBUF(clientid);
  }
  
  SAFECLOSE(overlapped.hEvent);
}

void
IOCTX::AddRef(void)
{
  InterlockedIncrement(&_cRefs);
}

void
IOCTX::Release(void)
{
  InterlockedDecrement(&_cRefs);
  
  if( _cRefs == 0 )
  {
    delete this;
  }
  
  return;
}

IOTYPE
IOCTX::Type(void)
{
  return _iot;
}

BOOL
IOCTX::AllocateWSABuffer(DWORD size, LPVOID pv)
{
  if( !(pwsa = new WSABUF) )
  {
    return FALSE;
  }

  if( size != 0 )
  {
    bufsize = size;

    if( pv )
    {
      pwsa->buf = (CHAR*) pv;
      pwsa->len = size;
    }
    else
    {
      if( !(pwsa->buf = new CHAR[size]) )
      {
        return FALSE;
      }
    
      pwsa->len = (_iot == IOCT_SEND) ? 0 : size;
    }
  }

  return TRUE;
}

void
IOCTX::FreeWSABuffer(void)
{
  SAFEDELETEBUF(pwsa->buf);
  SAFEDELETE(pwsa);
  bufsize = 0;
}

BOOL
IOCTX::ResizeWSABuffer(DWORD size)
{
  SAFEDELETEBUF(pwsa->buf);

  if( !(pwsa->buf = new CHAR[size]) )
  {
    return FALSE;
  }

  bufsize   = size;  
  pwsa->len = (_iot == IOCT_SEND) ? 0 : size;

  return TRUE;
}

void
IOCTX::DisableIoCompletion(void)
{
  overlapped.hEvent =
    (HANDLE) ((ULONG_PTR) CreateEvent(NULL, TRUE, FALSE, NULL) | 0x00000001);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\w3spoof\w3sobj\ithreadpool.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    ithreadpool.cxx

Abstract:

    Implements the W3Spoof object's IThreadPool interface.
    
Author:

    Paul M Midgen (pmidge) 08-February-2001


Revision History:

    08-February-2001 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

BOOL
CW3Spoof::_InitializeThreads(void)
{
  DEBUG_ENTER((
    DBG_W3SOBJ,
    rt_bool,
    "CW3Spoof::_InitializeThreads",
    "this=%#x",
    this
    ));

  BOOL        bStatus = FALSE;
  DWORD       error   = 0L;
  SOCKADDR_IN local   = {0};

  m_hIOCP = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, m_dwMaxActiveThreads);

    if( !m_hIOCP )
    {
      DEBUG_TRACE(
        W3SOBJ,
        ("error creating completion port: %s", MapErrorToString(GetLastError()))
        );
      
      goto quit;
    }

  m_sListen = socket(AF_INET, SOCK_STREAM, 0);

    if( m_sListen == INVALID_SOCKET )
    {
      DEBUG_TRACE(
        W3SOBJ,
        ("error creating listen socket: %s", MapErrorToString(WSAGetLastError()))
        );

      goto quit;
    }

  local.sin_family      = AF_INET;
  local.sin_addr.s_addr = htonl(INADDR_ANY);
  local.sin_port        = htons(m_usServerPort);

  error = bind(m_sListen, (PSOCKADDR) &local, sizeof(local));

    if( error == SOCKET_ERROR )
    {        
      DEBUG_TRACE(W3SOBJ, ("error binding listen socket: %s", MapErrorToString(WSAGetLastError())));
      goto quit;
    }

  error = listen(m_sListen, SOMAXCONN);

    if( error == SOCKET_ERROR )
    {
      DEBUG_TRACE(W3SOBJ, ("error listening: %s", MapErrorToString(WSAGetLastError())));
      goto quit;
    }
    
  CreateIoCompletionPort((HANDLE) m_sListen, m_hIOCP, CK_NEW_CONNECTION, m_dwMaxActiveThreads);

  m_arThreads = new HANDLE[m_dwPoolSize];

    if( !m_arThreads )
    {
      DEBUG_TRACE(W3SOBJ, ("error allocating thread handles: %s", MapErrorToString(GetLastError())));
      goto quit;
    }

  for(DWORD n=0; n < m_dwPoolSize; n++)
  {
    m_arThreads[n] = CreateThread(
                       NULL, 0,
                       ThreadFunc, (LPVOID) (static_cast<IThreadPool*>(this)),
                       0, NULL
                       );

    if( !m_arThreads[n] )
    {
      DEBUG_TRACE(W3SOBJ, ("error creating thread %d: %s", n, MapErrorToString(GetLastError())));
      goto quit;
    }
  }

  bStatus = TRUE;

quit:

  DEBUG_LEAVE(bStatus);
  return bStatus;
}


void
CW3Spoof::_TerminateThreads(void)
{
  DEBUG_ENTER((
    DBG_W3SOBJ,
    rt_void,
    "CW3Spoof::_TerminateThreads",
    "this=%#x",
    this
    ));

  //
  // BUGBUG: this could generate *_OPERATION_ABORTED results, need to keep this in mind
  //         in case there are weird state issues handling aborted io ops. should be no
  //         problem... but you never know.
  //
  SAFECLOSESOCKET(m_sListen);

  for(DWORD n=0; n < m_dwPoolSize; n++)
  {
    PostQueuedCompletionStatus(m_hIOCP, 0L, CK_CANCEL_IO, NULL);
  }

  WaitForMultipleObjects(m_dwPoolSize, m_arThreads, TRUE, INFINITE);

  for(DWORD n=0; n < m_dwPoolSize; n++)
  {
    SAFECLOSE(m_arThreads[n]);
  }

  SAFEDELETEBUF(m_arThreads);
  SAFECLOSE(m_hIOCP);

  DEBUG_LEAVE(0);
}


DWORD
CW3Spoof::_QueueAccept(void)
{
  DEBUG_ENTER((
    DBG_W3SOBJ,
    rt_dword,
    "CW3Spoof::_QueueAccept",
    "this=%#x",
    this
    ));

  DWORD ret = ERROR_IO_PENDING;

  if( 0 == InterlockedCompareExchange(&m_PendingAccepts, 0, 0) )
  {
    // available pending accepts has dropped to 0, close
    // the accept queue.
    m_AcceptQueueStatus = 0;
  }
  else
  {
    if( m_AcceptQueueStatus )
    {
      BOOL   bAccepted = TRUE;
      PIOCTX pioc      = NULL;

      InterlockedDecrement(&m_PendingAccepts);

      pioc = new IOCTX(IOCT_CONNECT, socket(AF_INET, SOCK_STREAM, 0));

      if( pioc && pioc->sockbuf )
      {
        bAccepted = AcceptEx(
                      m_sListen,
                      pioc->socket,
                      (LPVOID) pioc->sockbuf,
                      0L,
                      sizeof(SOCKADDR_IN)+16,
                      sizeof(SOCKADDR_IN)+16,
                      NULL,
                      &pioc->overlapped
                      );

        if( !bAccepted )
        {
          ret = WSAGetLastError();
        }
      }
      else
      {
        ret = ERROR_OUTOFMEMORY;
      }
    }
    else
    {
      ret = ERROR_SUCCESS;
      DEBUG_TRACE(W3SOBJ, ("queue is closed"));
    }
  }

  DEBUG_LEAVE(ret);
  return ret;
}


BOOL
CW3Spoof::_CompleteAccept(PIOCTX pioc)
{
  DEBUG_ENTER((
    DBG_W3SOBJ,
    rt_bool,
    "CW3Spoof::_CompleteAccept",
    "this=%#x; pioc=%#x",
    this, pioc
    ));

  BOOL bStatus = FALSE;

  if( pioc->socket != INVALID_SOCKET )
  {
    DWORD  mode           = 1L;
    struct linger _linger = {1, 2};

    setsockopt(
      pioc->socket,
      SOL_SOCKET, SO_UPDATE_ACCEPT_CONTEXT,
      (char*) &m_sListen, sizeof(m_sListen)
      );

    setsockopt(
      pioc->socket,
      SOL_SOCKET, SO_LINGER,
      (char*) &_linger, sizeof(struct linger)
      );

    setsockopt(
      pioc->socket,
      IPPROTO_TCP, TCP_NODELAY,
      (char*) &mode, sizeof(DWORD)
      );

    ParseSocketInfo(pioc);

    bStatus = SUCCEEDED(Register(pioc->socket)) ? TRUE : FALSE;
  }

  // increment available pending accepts and check to see if the queue
  // can be reopened
  InterlockedIncrement(&m_PendingAccepts);

  if( m_MaxQueuedAccepts ==
      InterlockedCompareExchange(&m_PendingAccepts, m_MaxQueuedAccepts, m_MaxQueuedAccepts)
    )
  {
    m_AcceptQueueStatus = 1;
  }

  DEBUG_LEAVE(bStatus);
  return bStatus;
}


BOOL
CW3Spoof::_DisconnectSocket(PIOCTX pioc, BOOL fNBGC)
{
  if( pioc->socket != INVALID_SOCKET )
  {
    if( fNBGC )
    {
      shutdown(pioc->socket, SD_SEND);
    }
    else
    {
      struct linger _linger = {1, 0};

      setsockopt(
        pioc->socket,
        SOL_SOCKET, SO_LINGER,
        (char*) &_linger, sizeof(struct linger)
        );
    }

    closesocket(pioc->socket);
    pioc->socket = INVALID_SOCKET;

    return TRUE;
  }

  return FALSE;
}


HRESULT
__stdcall
CW3Spoof::GetStatus(PIOCTX* ppioc, LPBOOL pbQuit)
{
  DEBUG_ENTER((
    DBG_W3SOBJ,
    rt_hresult,
    "CW3Spoof::GetStatus",
    "this=%#x; ppioc=%#x; pbQuit=%#x",
    this,
    ppioc,
    pbQuit
    ));

  HRESULT      hr      = S_OK;
  DWORD        error   = ERROR_SUCCESS;
  DWORD        comp    = 0L;
  DWORD        bytes   = 0L;
  LPOVERLAPPED lpo     = NULL;

  _QueueAccept();

  if( GetQueuedCompletionStatus(m_hIOCP, &bytes, &comp, &lpo, INFINITE) )
  {
    switch( comp )
    {
      case CK_NEW_CONNECTION :
        {
          DEBUG_TRACE(W3SOBJ, ("status: new connection"));

          *ppioc  = GETIOCTX(lpo);
          *pbQuit = FALSE;

          if( (*ppioc) && _CompleteAccept(*ppioc) )
          {
            IW3Spoof* pw3s = NULL;

            hr = QueryInterface(IID_IW3Spoof, (void**) &pw3s);

            if( SUCCEEDED(hr) )
            {
              hr = SESSIONOBJ::Create(*ppioc, pw3s);
              SAFERELEASE(pw3s);
            }
          }
          else
          {
            SAFERELEASE((*ppioc));
            hr = E_FAIL;
          }

          if( FAILED(hr) )
          {
            break;
          }
        }

      case CK_NORMAL :
        {
          DEBUG_TRACE(W3SOBJ, ("status: normal"));

          *ppioc          = GETIOCTX(lpo);
          (*ppioc)->bytes = bytes;
          *pbQuit         = FALSE;
          hr              = S_OK;
        }
        break;

      case CK_CANCEL_IO :
        {
          DEBUG_TRACE(W3SOBJ, ("status: cancel io"));

          m_AcceptQueueStatus = 0;
          CancelIo((HANDLE) m_sListen);

          //
          // BUGBUG: temporary hack to get all threads to call CancelIo().
          //         i need to figure out a better way.
          //
          // P.S. this works because it puts the thread in a non-alertable state,
          //      which causes the completion port code to wake up another thread.
          //
          Sleep(100);

          PostQueuedCompletionStatus(m_hIOCP, 0L, CK_TERMINATE_THREAD, NULL);
          
          *ppioc  = NULL;
          *pbQuit = FALSE;
          hr      = E_FAIL;
        }
        break;

      case CK_TERMINATE_THREAD :
        {
          DEBUG_TRACE(W3SOBJ, ("status: terminate thread"));

          *ppioc  = NULL;
          *pbQuit = TRUE;
          hr      = E_FAIL;
        }
        break;
    }
  }
  else
  {
    error = GetLastError();

    switch( error )
    {
      case ERROR_NETNAME_DELETED :
        {
          *ppioc = GETIOCTX(lpo);

          //
          // happens when a client closes a keep-alive connection on which
          // we have a receive pending. if there's a session associated with
          // this IO, we defer error handling to the session fsm.
          //
          if( (*ppioc)->clientid && SUCCEEDED(m_sessionmap->Get((*ppioc)->clientid, (void**) &(*ppioc)->session)) )
          {
            (*ppioc)->error = error;
            hr              = S_OK;
          }
          else
          {
            _DisconnectSocket(*ppioc, TRUE);
            SAFERELEASE((*ppioc));
            hr = E_FAIL;
          }
        }
        break;

      case ERROR_OPERATION_ABORTED :
        {
          *ppioc = GETIOCTX(lpo);

          //
          // happens when CancelIo() or closesocket() are called and there are
          // pending overlapped operations. if there's a session associated with
          // the IOCTX, we defer error handling to the session fsm.
          //
          if( (*ppioc)->clientid && SUCCEEDED(m_sessionmap->Get((*ppioc)->clientid, (void**) &(*ppioc)->session)) )
          {
            (*ppioc)->error = error;
            hr              = S_OK;
          }
          else
          {
            _DisconnectSocket(*ppioc, FALSE);
            SAFERELEASE((*ppioc));
            hr = E_FAIL;
          }
        }
        break;

      default :
        {
          DEBUG_TRACE(W3SOBJ, ("unhandled error - %s", MapErrorToString(error)));
        }
        break;
    }
  }
  
  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3Spoof::GetSession(LPWSTR clientid, PSESSIONOBJ* ppso)
{
  HRESULT hr = S_OK;

  hr = m_sessionmap->Get(clientid, (void**) ppso);

  return hr;
}


HRESULT
__stdcall
CW3Spoof::Register(SOCKET s)
{
  DEBUG_ENTER((
    DBG_W3SOBJ,
    rt_hresult,
    "CW3Spoof::Register",
    "this=%#x; s=%#x",
    this,
    s
    ));

  HRESULT hr = S_OK;
  HANDLE  ret = NULL;
  
  ret = CreateIoCompletionPort(
          (HANDLE) s, m_hIOCP,
          CK_NORMAL, m_dwMaxActiveThreads
          );

  if( !ret )
  {
    DEBUG_TRACE(W3SOBJ, ("failed to associate socket!"));
    hr = E_FAIL;
  }

  DEBUG_LEAVE(hr);
  return hr;
}


DWORD
WINAPI
ThreadFunc(LPVOID lpv)
{
  DEBUG_ENTER((
    DBG_WORKER,
    rt_hresult,
    "worker",
    "lpv=%#x",
    lpv
    ));

  HRESULT      hr    = S_OK;
  BOOL         bQuit = FALSE;
  PIOCTX       pioc  = NULL;
  IThreadPool* ptp   = (IThreadPool*) lpv;
  PSESSIONOBJ  pso   = NULL;

    while( !bQuit )
    {
      if( SUCCEEDED(ptp->GetStatus(&pioc, &bQuit)) )
      {
        if( (pso = pioc->session) || SUCCEEDED(ptp->GetSession(pioc->clientid, &pso)) )
        {
          pso->Run(pioc);
        }
        
        SAFERELEASE(pioc);
      }
    }

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\w3spoof\w3sobj\iunknown.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    iunknown.cxx

Abstract:

    Implements the W3Spoof object's IUnknown & IExternalConnection interfaces.
    
Author:

    Paul M Midgen (pmidge) 08-January-2001


Revision History:

    08-January-2001 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

//-----------------------------------------------------------------------------
// IUnknown
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CW3Spoof::QueryInterface(REFIID riid, void** ppv)
{
  DEBUG_ENTER((
    DBG_REFCOUNT,
    rt_hresult,
    "CW3Spoof::QueryInterface",
    "this=%#x; riid=%s; ppv=%#x",
    this,
    MapIIDToString(riid),
    ppv
    ));

  HRESULT hr = S_OK;

  if( !ppv )
  {
    hr = E_POINTER;
    goto quit;
  }

  if( m_state != ST_OPEN )
  {
    DEBUG_TRACE(W3SOBJ, ("invalid state!"));

    *ppv = NULL;
    hr   = E_FAIL;
    goto quit;
  }
  else
  {
    if(
      IsEqualIID(riid, IID_IUnknown) ||
      IsEqualIID(riid, IID_IW3Spoof) ||
      IsEqualIID(riid, IID_IConfig)
      )
    {
      *ppv = static_cast<IW3Spoof*>(this);
    }
    else if( IsEqualIID(riid, IID_IDispatch) )
    {
      *ppv = static_cast<IDispatch*>(this);
    }
    else if( IsEqualIID(riid, IID_IThreadPool) )
    {
      *ppv = static_cast<IThreadPool*>(this);
    }
    else if( IsEqualIID(riid, IID_IW3SpoofClientSupport) )
    {
      *ppv = static_cast<IW3SpoofClientSupport*>(this);
    }
    else if( IsEqualIID(riid, IID_IExternalConnection) )
    {
      *ppv = static_cast<IExternalConnection*>(this);
    }
    else if( IsEqualIID(riid, IID_IConnectionPointContainer) )
    {
      *ppv = static_cast<IConnectionPointContainer*>(this);
    }
    else
    {
      *ppv = NULL;
      hr   = E_NOINTERFACE;
    }

    if( SUCCEEDED(hr) )
      reinterpret_cast<IUnknown*>(*ppv)->AddRef();
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


ULONG
__stdcall
CW3Spoof::AddRef(void)
{
  InterlockedIncrement(&m_cRefs);
  DEBUG_ADDREF("CW3Spoof", m_cRefs);
  return m_cRefs;
}


ULONG
__stdcall
CW3Spoof::Release(void)
{
  InterlockedDecrement(&m_cRefs);
  DEBUG_RELEASE("CW3Spoof", m_cRefs);

    if( m_cRefs == 0 )
    {
      DEBUG_FINALRELEASE("CW3Spoof");
      delete this;
      return 0;
    }

  return m_cRefs;
}


//-----------------------------------------------------------------------------
// IExternalConnection
//-----------------------------------------------------------------------------
DWORD
__stdcall
CW3Spoof::AddConnection(DWORD type, DWORD reserved)
{
  DWORD ret = 0L;

    if( type & EXTCONN_STRONG )
    {
      ret = (DWORD) InterlockedIncrement(&m_cExtRefs);
    }

  DEBUG_TRACE(W3SOBJ, ("external refcount: %d", m_cExtRefs));
  return ret;
}


DWORD
__stdcall
CW3Spoof::ReleaseConnection(DWORD type, DWORD reserved, BOOL bCloseIfLast)
{
  DWORD ret = 0L;

    if( type & EXTCONN_STRONG )
    {
      ret = (DWORD) InterlockedDecrement(&m_cExtRefs);

      if( (ret == 0) && bCloseIfLast )
      {
        SetEvent(m_evtServerUnload);
      }
    }

  DEBUG_TRACE(W3SOBJ, ("external refcount: %d", m_cExtRefs));
  return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\w3spoof\w3sobj\iw3spoof.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    iw3spoof.cxx

Abstract:

    Implements the W3Spoof object's IW3Spoof interface.
    
Author:

    Paul M Midgen (pmidge) 08-February-2001


Revision History:

    08-February-2001 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"


HRESULT
__stdcall
CW3Spoof::GetRuntime(IW3SpoofRuntime** pprt)
{
  DEBUG_ENTER((
    DBG_W3SOBJ,
    rt_hresult,
    "CW3Spoof::GetRuntime",
    "this=%#x; pprt=%#x",
    this,
    pprt
    ));

  HRESULT hr = S_OK;

    if( !pprt )
    {
      hr = E_POINTER;
    }
    else
    {
      *pprt = NULL;

      if( m_prt )
      {
        hr = m_prt->QueryInterface(IID_IW3SpoofRuntime, (void**) pprt);
        DEBUG_TRACE(W3SOBJ, ("returning IW3SpoofRuntime instance %#x", *pprt));
      }
      else
      {
        hr = E_FAIL;
      }
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3Spoof::GetTypeLibrary(ITypeLib** pptl)
{
  DEBUG_ENTER((
    DBG_W3SOBJ,
    rt_hresult,
    "CW3Spoof::GetTypeLibrary",
    "this=%#x; pptl=%#x",
    this,
    pptl
    ));

  HRESULT hr = S_OK;

    if( !pptl )
    {
      hr = E_POINTER;
    }
    else
    {
      *pptl = NULL;

      if( m_ptl )
      {
        hr = m_ptl->QueryInterface(IID_ITypeLib, (void**) pptl);
        DEBUG_TRACE(W3SOBJ, ("returning ITypeLib instance %#x", *pptl));
      }
      else
      {
        hr = E_FAIL;
      }
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3Spoof::GetScriptEngine(IActiveScript** ppas)
{
  DEBUG_ENTER((
    DBG_W3SOBJ,
    rt_hresult,
    "CW3Spoof::GetScriptEngine",
    "this=%#x; ppas=%#x",
    this,
    ppas
    ));

  HRESULT hr = S_OK;

    if( !ppas )
    {
      hr = E_POINTER;
    }
    else
    {
      *ppas = NULL;

      if( m_pas )
      {
        hr = m_pas->QueryInterface(IID_IActiveScript, (void**) ppas);
        DEBUG_TRACE(W3SOBJ, ("returning IActiveScript instance %#x", *ppas));
      }
      else
      {
        hr = E_FAIL;
      }
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3Spoof::GetScriptPath(LPWSTR client, LPWSTR* path)
{
  DEBUG_ENTER((
    DBG_W3SOBJ,
    rt_hresult,
    "CW3Spoof::GetScriptPath",
    "this=%#x; client=%S; path=%#x",
    this,
    client,
    path
    ));

  HRESULT hr = S_OK;

  if( !path )
  {
    hr = E_POINTER;
    goto quit;
  }

  if( !client )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  if( m_clientmap && (m_clientmap->Get(client, (void**) path) != ERROR_SUCCESS) )
  {
    *path = L"default.js";
  }

  DEBUG_TRACE(W3SOBJ, ("script path is %S", *path));

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3Spoof::Notify(LPWSTR clientid, PSESSIONOBJ pso, STATE state)
{
  DEBUG_ENTER((
    DBG_W3SOBJ,
    rt_hresult,
    "CW3Spoof::Notify",
    "this=%#x; clientid=%S; pso=%#x; state=%s",
    this,
    clientid,
    pso,
    MapStateToString(state)
    ));

  HRESULT hr = S_OK;

    //
    // states not directly handled:
    //
    // ST_CREATED
    // ST_OPENING
    // ST_CLOSING
    //

    switch( state )
    {
      case ST_OPEN :
        {
          DEBUG_TRACE(W3SOBJ, ("registering session object"));

          m_CP.FireOnSessionOpen(clientid);
          hr = m_sessionmap->Insert(clientid, (void*) pso);
        }
        break;

      case ST_CLOSED :
        {
          DEBUG_TRACE(W3SOBJ, ("unregistering session object"));

          m_CP.FireOnSessionClose(clientid);
          m_sessionmap->Delete(clientid, NULL);
        }
        break;

      case ST_ERROR :
        {
          m_CP.FireOnSessionStateChange(clientid, state);
          m_sessionmap->Delete(clientid, NULL);
        }
        break;

      default :
        {
          m_CP.FireOnSessionStateChange(clientid, state);
        }
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3Spoof::WaitForUnload(void)
{
  DEBUG_ENTER((
    DBG_W3SOBJ,
    rt_hresult,
    "CW3Spoof::WaitForUnload",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  WaitForSingleObject(m_evtServerUnload, INFINITE);

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3Spoof::Terminate(void)
{
  DEBUG_ENTER((
    DBG_W3SOBJ,
    rt_hresult,
    "CW3Spoof::Terminate",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  _SetState(ST_CLOSING);

    _TerminateThreads();

    SAFETERMINATE(m_prt);
    SAFERELEASE(m_ptl);
    SAFERELEASE(m_pas);
    SAFEDELETE(m_clientmap);
    SAFEDELETE(m_sessionmap);
    SAFECLOSE(m_evtServerUnload);

  _SetState(ST_CLOSED);

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\w3spoof\w3sobj\methods.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    methods.cxx

Abstract:

    Implements the W3Spoof object's IW3SpoofClientSupport interface.
    
Author:

    Paul M Midgen (pmidge) 08-January-2001


Revision History:

    08-January-2001 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"


HRESULT
__stdcall
CW3Spoof::RegisterClient(BSTR Client, BSTR ScriptPath)
{
  DEBUG_ENTER((
    DBG_W3SOBJ,
    rt_hresult,
    "CW3Spoof::RegisterClient",
    "this=%#x; Client=%S; ScriptPath=%.32S",
    this,
    Client,
    ScriptPath
    ));

  HRESULT hr  = S_OK;
  DWORD   ret = ERROR_SUCCESS;

  if( !Client || !ScriptPath )
  {
    hr = E_INVALIDARG;
  }
  else
  {    
    ret = m_clientmap->Insert(
                         Client,
                         (void*) __widetobstr(ScriptPath)
                         );

    //
    // if Insert() returns ERROR_DUP_NAME, don't increase the external
    // refcount.
    //
    if( ret == ERROR_SUCCESS )
    {
      AddConnection(EXTCONN_STRONG, 0L);
    }
    else if( ret == ERROR_OUTOFMEMORY )
    {
      hr = E_OUTOFMEMORY;
    }
  }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3Spoof::RevokeClient(BSTR Client)
{
  DEBUG_ENTER((
    DBG_W3SOBJ,
    rt_hresult,
    "CW3Spoof::RevokeClient",
    "this=%#x; Client=%S",
    this,
    Client
    ));

  HRESULT hr = S_OK;

    if( ERROR_SUCCESS != m_clientmap->Delete(Client, NULL) )
    {
      hr = E_FAIL;
    }
    else
    {
      ReleaseConnection(EXTCONN_STRONG, 0L, TRUE);
    }

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\w3spoof\w3sobj\dispatch.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    dispatch.cxx

Abstract:

    Implements the IDispatch interface for the W3Spoof object.
    
Author:

    Paul M Midgen (pmidge) 18-January-2001


Revision History:

    18-January-2001 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

//
// WARNING: do not modify these values. use disphash.exe to generate
//          new values.
//
DISPIDTABLEENTRY g_W3SpoofDisptable[] =
{
  0x021fca0d,   DISPID_W3SPOOF_REGISTERCLIENT,  L"registerclient",
  0x008a2dce,   DISPID_W3SPOOF_REVOKECLIENT,    L"revokeclient"
};

DWORD  g_cW3SpoofDisptable    = (sizeof(g_W3SpoofDisptable) / sizeof(DISPIDTABLEENTRY));
LPWSTR g_wszW3SpoofObjectName = L"w3spoof";

//-----------------------------------------------------------------------------
// IDispatch
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CW3Spoof::GetTypeInfoCount(UINT* pctinfo)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "CW3Spoof::GetTypeInfoCount",
    "this=%#x; pctinfo=%#x",
    this,
    pctinfo
    ));

  HRESULT hr = S_OK;

    if( !pctinfo )
    {
      hr = E_POINTER;
    }
    else
    {
      *pctinfo = 1;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3Spoof::GetTypeInfo(UINT index, LCID lcid, ITypeInfo** ppti)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "CW3Spoof::GetTypeInfo",
    "this=%#x; index=%#x; lcid=%#x; ppti=%#x",
    this,
    index,
    lcid,
    ppti
    ));

  HRESULT hr = S_OK;

  if( !ppti )
  {
    hr = E_POINTER;
  }
  else
  {
    if( index != 0 )
    {
      hr    = DISP_E_BADINDEX;
      *ppti = NULL;
    }
    else
    {
      hr = GetTypeInfoFromName(g_wszW3SpoofObjectName, m_ptl, ppti);
    }
  }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3Spoof::GetIDsOfNames(REFIID riid, LPOLESTR* arNames, UINT cNames, LCID lcid, DISPID* arDispId)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "CW3Spoof::GetIDsOfNames",
    "this=%#x; riid=%s; arNames=%#x; cNames=%d; lcid=%#x; arDispId=%#x",
    this,
    MapIIDToString(riid),
    arNames,
    cNames,
    lcid,
    arDispId
    ));

  HRESULT hr = S_OK;
  UINT    n  = 0L;

  if( !IsEqualIID(riid, IID_NULL) )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  while( n < cNames )
  {
    arDispId[n] = GetDispidFromName(g_W3SpoofDisptable, g_cW3SpoofDisptable, arNames[n]);
    ++n;
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3Spoof::Invoke(DISPID dispid, REFIID riid, LCID lcid, WORD flags, DISPPARAMS* pdp, VARIANT* pvr, EXCEPINFO* pei, UINT* pae)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "CW3Spoof::Invoke",
    "this=%#x; dispid=%s; riid=%s; lcid=%#x; flags=%#x; pdp=%#x; pvr=%#x; pei=%#x; pae=%#x",
    this,
    MapDispidToString(dispid),
    MapIIDToString(riid),
    lcid,
    flags,
    pdp, pvr,
    pei, pae
    ));

  HRESULT hr = S_OK;

  hr = ValidateDispatchArgs(riid, pdp, pvr, pae);

    if( FAILED(hr) )
      goto quit;

  switch( dispid )
  {
    case DISPID_W3SPOOF_REGISTERCLIENT :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, FALSE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 2, FALSE, 0);

          if( SUCCEEDED(hr) )
          {
            hr = RegisterClient(
                   V_BSTR(&pdp->rgvarg[1]),
                   V_BSTR(&pdp->rgvarg[0])
                   );
          }
        }
      }
      break;

    case DISPID_W3SPOOF_REVOKECLIENT :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, FALSE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 1, FALSE, 0);

          if( SUCCEEDED(hr) )
          {
            hr = RevokeClient(
                   V_BSTR(&pdp->rgvarg[0])
                   );
          }
        }
      }
      break;

    default : hr = DISP_E_MEMBERNOTFOUND;
  }

quit:

  if( FAILED(hr) )
  {
    hr = HandleDispatchError(L"w3spoof object", pei, hr);
  }

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\w3spoof\w3sobj\factory.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    factory.cpp

Abstract:

    W3Spoof class factory implementation. Also implements component
    registration and runtime registration for the local server.
    
Author:

    Paul M Midgen (pmidge) 17-July-2000


Revision History:

    17-July-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

LPCWSTR g_wszRegistered = L"Registered";
LPCWSTR g_wszAdvPackDll = L"advpack.dll";

// advapi doesn't speak unicode
LPCSTR g_szRegSection   = "reg";
LPCSTR g_szUnRegSection = "unreg";

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  CFactory::CFactory()

  WHAT    : W3Spoof class factory constructor. Writes the COM server entries
            to the registry and registers itself with COM as the W3Spoof
            class factory.

  ARGS    : fEmbedded - when the server starts and creates the class factory,
                        it passes this flag in, letting us know if the server
                        is running embedded or not. if we're embedded, we
                        don't want to pop ui, so we store this value and
                        use it when creating W3Spoof objects.

  RETURNS : nothing.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
CFactory::CFactory()
{
  DEBUG_ENTER((
    DBG_FACTORY,
    rt_void,
    "CFactory::CFactory",
    "this=%#x",
    this
    ));

  LPDWORD pdw   = NULL;
  BOOL    bRet  = FALSE;
  DWORD   dwRet = ERROR_SUCCESS;

  m_pw3s     = NULL;
  m_dwCookie = 0L;
  m_cRefs    = 1;
  m_cLocks   = 0L;

  //
  // component registration check
  //
  // if the regkey exists but is 0 (someone wants to force us to reregister)
  // or if the regkey doesn't exist (new install or someone nuked the regkey)
  // then we register ourselves as a COM server.
  //
  bRet = GetRegValue(g_wszRegistered, REG_DWORD, (void**)&pdw);

  if( (bRet && (*pdw == 0)) || !bRet )
  {
    _RegisterServer(TRUE);
  }

  delete pdw;

  //
  // create a single instance (singleton) of CW3Spoof to
  // be used by all callers and grab an IUnknown* for the
  // factory object so it controls the singleton's lifetime.
  //
  CW3Spoof::Create(&m_pw3s);

  DEBUG_ASSERT((m_pw3s != NULL));

  _RegisterClassFactory(TRUE);

  DEBUG_LEAVE(0);
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  CFactory::~CFactory()

  WHAT    : W3Spoof class factory destructor. Cleans up.
  ARGS    : none.
  RETURNS : nothing.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
CFactory::~CFactory()
{
  DEBUG_ENTER((
    DBG_FACTORY,
    rt_void,
    "CFactory::~CFactory",
    "this=%#x",
    this
    ));

  DEBUG_TRACE(FACTORY, ("refcount=%d; locks=%d", m_cRefs, m_cLocks));
  DEBUG_LEAVE(0);
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  CFactory::Create()

  WHAT    : Creates the class factory.
  ARGS    : none.
  RETURNS : nothing.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
HRESULT
CFactory::Create(CFactory** ppCF)
{
  DEBUG_ENTER((
    DBG_FACTORY,
    rt_hresult,
    "CFactory::Create",
    "ppCF=%#x",
    ppCF
    ));

  HRESULT hr = S_OK;

  *ppCF = new CFactory;

  if( !(*ppCF) )
  {
    hr = E_OUTOFMEMORY;
  }

  DEBUG_LEAVE(hr);
  return hr;
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  CFactory::Terminate()

  WHAT    : Terminates the class factory.
  ARGS    : none.
  RETURNS : nothing.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
HRESULT
CFactory::Terminate(void)
{
  DEBUG_ENTER((
    DBG_FACTORY,
    rt_hresult,
    "CFactory::Terminate",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  _RegisterClassFactory(FALSE);

  if( m_pw3s )
    m_pw3s->Terminate();

  SAFERELEASE(m_pw3s);
  Release();

  DEBUG_LEAVE(hr);
  return hr;
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  CFactory::QueryInterface()

  WHAT    : IUnknown member implementation.

  ARGS    : riid - IID wanted by caller
            ppv  - pointer to return interface through

  RETURNS : S_OK          - the caller got the interface they wanted.
            E_NOINTERFACE - they didn't.
            E_INVALIDARG  - the supplied a bogus return pointer.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
HRESULT
__stdcall
CFactory::QueryInterface(REFIID riid, void** ppv)
{
  DEBUG_ENTER((
    DBG_FACTORY,
    rt_hresult,
    "CFactory::QueryInterface",
    "this=%#x; riid=%s; ppv=%#x",
    this,
    MapIIDToString(riid),
    ppv
    ));

  HRESULT hr = S_OK;

  if( !ppv )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  if( IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IClassFactory) )
  {
    *ppv = static_cast<IClassFactory*>(this);
  }
  else
  {
    *ppv = NULL;
    hr   = E_NOINTERFACE;
  }

  if( SUCCEEDED(hr) )
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();

quit:

  DEBUG_LEAVE(hr);
  return hr;
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  CFactory::AddRef()

  WHAT    : IUnknown member implementation.
  ARGS    : none.
  RETURNS : nothing of consequence.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
ULONG
__stdcall
CFactory::AddRef(void)
{
  InterlockedIncrement(&m_cRefs);
  DEBUG_ADDREF("CFactory", m_cRefs);
  return m_cRefs;
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  CFactory::Release()

  WHAT    : IUnknown member implementation.
  ARGS    : none.
  RETURNS : nothing of consequence.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
ULONG
__stdcall
CFactory::Release(void)
{

  InterlockedDecrement(&m_cRefs);
  DEBUG_RELEASE("CFactory", m_cRefs);

    if( m_cRefs == 0 )
    {
      DEBUG_FINALRELEASE("CFactory");
      delete this;
      return 0;
    }

  return m_cRefs;
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  CFactory::CreateInstance()

  WHAT    : IClassFactory member implementation.

  ARGS    : pContainer - an object attempting to aggregate this class
                         will supply its IUnknown pointer through this
                         parameter.

            riid       - interface caller wants.
            ppv        - pointer to return interface through.

  RETURNS : S_OK                  - caller got what they wanted.
            E_INVALIDARG          - caller supplied bogus return pointer.
            CLASS_E_NOAGGREGATION - caller tried to aggregate.
            E_NOINTERFACE         - caller asked for unsupported interface.
            E_OUTOFMEMORY         - couldn't allocate object.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
HRESULT
__stdcall
CFactory::CreateInstance(IUnknown* pContainer, REFIID riid, void** ppv)
{
  DEBUG_ENTER((
    DBG_FACTORY,
    rt_hresult,
    "CFactory::CreateInstance",
    "this=%#x; pContainer=%#x; riid=%s; ppv=%#x",
    this,
    pContainer,
    MapIIDToString(riid),
    ppv
    ));

  HRESULT hr = S_OK;

  if( !ppv )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  if( pContainer )
  {
    *ppv = NULL;
    hr   = CLASS_E_NOAGGREGATION;
    goto quit;
  }

  if( m_pw3s )
  {
    hr = m_pw3s->QueryInterface(riid, ppv);
  }
  else
  {
    hr = E_OUTOFMEMORY;
    goto quit;
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  CFactory::LockServer()

  WHAT    : IClassFactory member implementation.

  ARGS    : fLock - apply or remove a lock.
  RETURNS : S_OK  - always.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
HRESULT
__stdcall
CFactory::LockServer(BOOL fLock)
{
  DEBUG_ENTER((
    DBG_FACTORY,
    rt_hresult,
    "CFactory::LockServer",
    "this=%#x; fLock=%d",
    this,
    fLock
    ));

  HRESULT hr = S_OK;

    fLock ? InterlockedIncrement(&m_cLocks) : InterlockedDecrement(&m_cLocks);
    DEBUG_TRACE(REFCOUNT, ("factory locks=%d", m_cLocks));

  DEBUG_LEAVE(hr);
  return hr;
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  CFactory::Activate()

  WHAT    : Allows COM to use the class factory, which is registered in
            suspended mode.

  ARGS    : none.

  RETURNS : S_OK  - class factory was resumed..
            other - error describes reason for failure.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
HRESULT
CFactory::Activate(void)
{
  DEBUG_ENTER((
    DBG_FACTORY,
    rt_hresult,
    "CFactory::Activate",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

    hr = CoResumeClassObjects();

  DEBUG_LEAVE(hr);
  return hr;
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  CFactory::_RegisterServer()

  WHAT    : Self-registration routine.

  ARGS    : fMode  - if true, registers the component. if false...

  RETURNS : S_OK   - registration succeeded.
            E_FAIL - registration failed.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
HRESULT
CFactory::_RegisterServer(BOOL fMode)
{
  DEBUG_ENTER((
    DBG_FACTORY,
    rt_hresult,
    "CFactory::_RegisterServer",
    "this=%#x; fMode=%s",
    this,
    fMode ? "reg" : "unreg"
    ));

  HRESULT    hr      = S_OK;
  HINSTANCE  advpack = NULL;
  REGINSTALL pfnri   = NULL;

  advpack = LoadLibrary(g_wszAdvPackDll);

    if( !advpack )
    {
      DEBUG_TRACE(
        FACTORY,
        ("couldn't load advpack.dll: %s", MapErrorToString(GetLastError()))
        );

      hr = E_FAIL;
      goto quit;
    }

  DEBUG_TRACE(FACTORY, ("loaded advpack.dll"));
  pfnri = (REGINSTALL) GetProcAddress(advpack, achREGINSTALL);

    if( !pfnri )
    {
      DEBUG_TRACE(
        FACTORY,
        ("couldn't get RegInstall pointer: %s", MapErrorToString(GetLastError()))
        );

      hr = E_FAIL;
      goto quit;
    }

  DEBUG_TRACE(FACTORY, ("calling reginstall to %s", (fMode ? "reg" : "unreg")));
  hr = pfnri(
        GetModuleHandle(NULL),
        fMode ? g_szRegSection : g_szUnRegSection,
        NULL
        );

  if( SUCCEEDED(hr) )
  {
    DWORD dw = 1;

    SetRegValue(g_wszRegistered, REG_DWORD, (void*)&dw, sizeof(DWORD));
  }

  DEBUG_TRACE(FACTORY, ("unloading advpack.dll"));
  FreeLibrary(advpack);

  hr = _RegisterTypeLibrary(fMode);

quit:

  DEBUG_LEAVE(hr);
  return hr;
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  CFactory::_RegisterClassFactory()

  WHAT    : Class factory registration routine.

  ARGS    : fMode - if true, register, if false...

  RETURNS : S_OK   - success
            E_FAIL - failure

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
HRESULT
CFactory::_RegisterClassFactory(BOOL fMode)
{
  DEBUG_ENTER((
    DBG_FACTORY,
    rt_hresult,
    "CFactory::_RegisterClassFactory",
    "this=%#x; fMode=%s",
    this,
    fMode ? "reg" : "unreg"
    ));

  HRESULT hr = S_OK;

    if( fMode )
    {
      hr = CoRegisterClassObject(
            CLSID_W3Spoof,
            static_cast<IUnknown*>(this),
            CLSCTX_LOCAL_SERVER,
            REGCLS_MULTI_SEPARATE | REGCLS_SUSPENDED,
            &m_dwCookie
            );
    }
    else
    {
      hr = CoRevokeClassObject(m_dwCookie);
    }

  DEBUG_LEAVE(hr);
  return hr;
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  CFactory::_RegisterTypeLibrary()

  WHAT    : TypeLib registration routine.

  ARGS    : fMode - if true, register, if false...

  RETURNS : S_OK   - success
            E_FAIL - failure

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
HRESULT
CFactory::_RegisterTypeLibrary(BOOL fMode)
{
  DEBUG_ENTER((
    DBG_FACTORY,
    rt_hresult,
    "CFactory::_RegisterTypeLibrary",
    "this=%#x; fMode=%s",
    this,
    fMode ? "reg" : "unreg"
    ));

  ITypeLib* ptl  = NULL;
  TLIBATTR* pta  = NULL;
  WCHAR*    pbuf = NULL;
  HRESULT   hr   = S_OK;

  if( (pbuf = new WCHAR[MAX_PATH]) )
  {
    GetModuleFileName(NULL, pbuf, MAX_PATH);
  }
  else
  {
    hr = E_OUTOFMEMORY;
    goto quit;
  }

  hr = LoadTypeLib(pbuf, &ptl);

  if( SUCCEEDED(hr) )
  {
    if( fMode )
    {
      hr = RegisterTypeLib(ptl, pbuf, NULL);
    }
    else
    {
      hr = ptl->GetLibAttr(&pta);

        if( SUCCEEDED(hr) )
        {
          hr = UnRegisterTypeLib(
                pta->guid,
                pta->wMajorVerNum,
                pta->wMinorVerNum,
                pta->lcid,
                pta->syskind
                );

          ptl->ReleaseTLibAttr(pta);
        }
        else
        {
          goto quit;
        }
    }
    
    ptl->Release();
  }

quit:

  delete [] pbuf;

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\whttptst\inc\mem.h ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 1999  Microsoft Corporation

Module Name:

    mem.h

Abstract:

    Internal memory allocation/deallocation routines.
    
Author:

    Paul M Midgen (pmidge) 01-June-2000


Revision History:

    01-June-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#ifndef __MEM_H__
#define __MEM_H__

#include "common.h"

void  _InitMem(void);

void* __cdecl operator new(size_t size);
void  __cdecl operator delete(void* pv);

#endif /* __MEM_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\whttptst\inc\pch.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 1999  Microsoft Corporation

Module Name:

    pch.cxx

Abstract:

    Need this so the precompiled header will, umm, compile.
    
Author:

    Paul M Midgen (pmidge) 24-July-2000


Revision History:

    24-July-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

void foobar(void);

void foobar(void)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\w3spoof\w3sobj\w3sobj.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    w3spoof.cpp

Abstract:

    Implements the W3Spoof application object and the following interfaces:
    
      IConfig
      IConnectionPointContainer
      IConnectionPoint (via contained CW3SpoofEventsCP object)
    
Author:

    Paul M Midgen (pmidge) 07-June-2000


Revision History:

    07-June-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

LPCWSTR g_wszPoolSize      = L"MaxPoolSize";
LPCWSTR g_wszActiveThreads = L"MaxActiveThreads";
LPCWSTR g_wszServerPort    = L"ServerPort";

//-----------------------------------------------------------------------------
// CW3Spoof methods
//-----------------------------------------------------------------------------
CW3Spoof::CW3Spoof():
  m_cRefs(0),
  m_cExtRefs(0),
  m_evtServerUnload(INVALID_HANDLE_VALUE),
  m_prt(NULL),
  m_ptl(NULL),
  m_clientmap(NULL),
  m_sessionmap(NULL),
  m_dwPoolSize(0),
  m_dwMaxActiveThreads(0),
  m_usServerPort(8080),
  m_arThreads(NULL),
  m_sListen(INVALID_SOCKET),
  m_hIOCP(NULL),
  m_AcceptQueueStatus(1),
  m_MaxQueuedAccepts(10),
  m_PendingAccepts(10)
{
  DEBUG_TRACE(W3SOBJ, ("CW3Spoof created: %#x", this));
  _SetState(ST_OPENING);
}


CW3Spoof::~CW3Spoof()
{
  DEBUG_TRACE(W3SOBJ, ("CW3Spoof deleted: %#x", this));
}


HRESULT
CW3Spoof::Create(IW3Spoof** ppw3s)
{
  DEBUG_ENTER((
    DBG_W3SOBJ,
    rt_hresult,
    "CW3Spoof::Create",
    "ppw3s=%#x",
    ppw3s
    ));

  HRESULT   hr   = E_FAIL;
  CW3Spoof* pw3s = NULL;

  if( pw3s = new CW3Spoof )
  {
    if( pw3s->_Initialize() != ERROR_SUCCESS )
    {
      DEBUG_TRACE(W3SOBJ, ("object initialization failed"));
      delete pw3s;
      goto quit;
    }
  }
  else
  {
    DEBUG_TRACE(W3SOBJ, ("failed to allocate object: %s", GetLastError()));
    *ppw3s = NULL;
    goto quit;
  }

  hr = pw3s->QueryInterface(IID_IW3Spoof, (void**) ppw3s);

    if( FAILED(hr) )
    {
      *ppw3s = NULL;
      delete pw3s;
    }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


DWORD
CW3Spoof::_Initialize(void)
{
  DEBUG_ENTER((
    DBG_W3SOBJ,
    rt_dword,
    "CW3Spoof::_Initialize",
    "this=%#x",
    this
    ));

  DWORD               dwRet = ERROR_SUCCESS;
  HRESULT             hr    = S_OK;
  WCHAR*              buf   = NULL;
  CLSID               clsid = {0};
  SYSTEM_INFO         si    = {0};
  IActiveScriptParse* parse = NULL;

  if( m_state != ST_OPENING )
  {
    dwRet = ERROR_INVALID_STATE;
    goto quit;
  }

  GetSystemInfo(&si);

  m_dwPoolSize         = si.dwNumberOfProcessors;
  m_dwMaxActiveThreads = si.dwNumberOfProcessors;

  _LoadRegDefaults();

  m_CP.SetSite(dynamic_cast<IW3Spoof*>(this));

  if( !_InitializeThreads() )
  {
    dwRet = ERROR_FAILURE;
    DEBUG_TRACE(W3SOBJ, ("error creating worker threads"));
    goto quit;
  }

  m_clientmap = new STRINGMAP;

    if( m_clientmap )
    {
      m_clientmap->SetClearFunction(BSTRKiller);
    }
    else
    {
      dwRet = ERROR_OUTOFMEMORY;
      goto quit;
    }

  m_sessionmap = new STRINGMAP;
  buf          = new WCHAR[MAX_PATH];

    if( !(m_sessionmap && buf) )
    {
      dwRet = ERROR_OUTOFMEMORY;
      goto quit;
    }

  GetModuleFileName(NULL, buf, MAX_PATH);

    hr = LoadTypeLib(buf, &m_ptl);

    if( FAILED(hr) )
    {
      dwRet = ERROR_FAILURE;
      DEBUG_TRACE(W3SOBJ, ("failed to load type library - %s", MapHResultToString(hr)));
    }

  if( FAILED(RUNTIME::Create(&m_prt)) )
  {
    dwRet = ERROR_FAILURE;
    DEBUG_TRACE(W3SOBJ, ("failed to create runtime"));
    goto quit;
  }

  if( GetJScriptCLSID(&clsid) )
  {
    hr = CoCreateInstance(
           clsid,
           NULL,
           CLSCTX_ALL,
           IID_IActiveScript,
           (void**) &m_pas
           );

    if( FAILED(hr) )
    {
      dwRet = ERROR_FAILURE;
      DEBUG_TRACE(W3SOBJ, ("error cocreating script engine - %s", MapHResultToString(hr)));
    }
    else
    {
      hr = m_pas->QueryInterface(IID_IActiveScriptParse, (void**) &parse);

        if( FAILED(hr) )
          goto quit;

      hr = parse->InitNew();
    }
  }
  else
  {
    DEBUG_TRACE(W3SOBJ, ("ERROR! Couldn't find the JScript CLSID."));
    dwRet = ERROR_FAILURE;
    goto quit;
  }

  m_evtServerUnload = CreateEvent(NULL, TRUE, FALSE, NULL);

quit:

  _SetState(
    (dwRet == ERROR_SUCCESS) ? ST_OPEN : ST_ERROR
    );

  SAFEDELETEBUF(buf);
  SAFERELEASE(parse);

  DEBUG_LEAVE(dwRet);
  return dwRet;
}


void
CW3Spoof::_LoadRegDefaults(void)
{
  LPDWORD pdw = NULL;

  if( GetRegValue(g_wszPoolSize, REG_DWORD, (void**) &pdw) )
  {
    m_dwPoolSize = *pdw;
    DEBUG_TRACE(W3SOBJ, ("pool size: %d", m_dwPoolSize));
    delete pdw;
  }

  if( GetRegValue(g_wszActiveThreads, REG_DWORD, (void**) &pdw) )
  {
    m_dwMaxActiveThreads = *pdw;
    DEBUG_TRACE(W3SOBJ, ("max active threads: %d", m_dwMaxActiveThreads));
    delete pdw;
  }

  if( GetRegValue(g_wszServerPort, REG_DWORD, (void**) &pdw) )
  {
    m_usServerPort = (USHORT) *pdw;
    DEBUG_TRACE(W3SOBJ, ("server port: %d", m_usServerPort));
    delete pdw;
  }
}


void
CW3Spoof::_SetState(STATE st)
{
  DEBUG_TRACE(W3SOBJ, ("w3sobj state: %s", MapStateToString(st)));
  m_state = st;
}


//-----------------------------------------------------------------------------
// IConfig
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CW3Spoof::SetOption(DWORD dwOption, LPDWORD lpdwValue)
{
  return E_NOTIMPL;
}


HRESULT
__stdcall
CW3Spoof::GetOption(DWORD dwOption, LPDWORD lpdwValue)
{
  return E_NOTIMPL;
}


//-----------------------------------------------------------------------------
// IConnectionPointContainer
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CW3Spoof::EnumConnectionPoints(IEnumConnectionPoints** ppEnum)
{
  return E_NOTIMPL;
}


HRESULT
__stdcall
CW3Spoof::FindConnectionPoint(REFIID riid, IConnectionPoint** ppCP)
{
  DEBUG_ENTER((
    DBG_W3SOBJ,
    rt_hresult,
    "CW3Spoof::FindConnectionPoint",
    "this=%#x; riid=%s; ppCP=%#x",
    this,
    MapIIDToString(riid),
    ppCP
    ));

  HRESULT hr = S_OK;

  if( !ppCP )
  {
    hr = E_POINTER;
    goto quit;
  }

  if( IsEqualIID(riid, IID_IW3SpoofEvents) )
  {
    hr = m_CP.QueryInterface(IID_IConnectionPoint, (void**) ppCP);
  }
  else
  {
    *ppCP = NULL;
    hr    = CONNECT_E_NOCONNECTION;
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


//-----------------------------------------------------------------------------
// IConnectionPoint
//-----------------------------------------------------------------------------
HRESULT
__stdcall
CW3Spoof::CW3SpoofEventsCP::QueryInterface(REFIID riid, void** ppv)
{
  DEBUG_ENTER((
    DBG_REFCOUNT,
    rt_hresult,
    "CW3SpoofEventsCP::QueryInterface",
    "this=%#x; riid=%s; ppv=%#x",
    this,
    MapIIDToString(riid),
    ppv
    ));

  HRESULT hr = S_OK;

    if( IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IConnectionPoint) )
    {
      *ppv = static_cast<IConnectionPoint*>(this);
    }
    else
    {
      *ppv = NULL;
      hr   = E_NOINTERFACE;
    }

    if( SUCCEEDED(hr) )
      reinterpret_cast<IUnknown*>(*ppv)->AddRef();

  DEBUG_LEAVE(hr);
  return hr;
}


ULONG
__stdcall
CW3Spoof::CW3SpoofEventsCP::AddRef(void)
{
  InterlockedIncrement(&m_cRefs);
  DEBUG_ADDREF("CW3SpoofEventsCP", m_cRefs);
  return m_cRefs;
}


ULONG
__stdcall
CW3Spoof::CW3SpoofEventsCP::Release(void)
{
  InterlockedDecrement(&m_cRefs);
  DEBUG_RELEASE("CW3SpoofEventsCP", m_cRefs);
  return m_cRefs;
}


HRESULT
__stdcall
CW3Spoof::CW3SpoofEventsCP::GetConnectionInterface(IID* pIID)
{
  DEBUG_ENTER((
    DBG_W3SOBJ,
    rt_hresult,
    "CW3SpoofEventsCP::GetConnectionInterface",
    "this=%#x; pIID=%s",
    this,
    MapIIDToString((const IID&)pIID)
    ));

  HRESULT hr = S_OK;

    if( !pIID )
    {
      hr = E_POINTER;
    }
    else
    {
      *pIID = IID_IW3SpoofEvents;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3Spoof::CW3SpoofEventsCP::GetConnectionPointContainer(IConnectionPointContainer** ppCPC)
{
  DEBUG_ENTER((
    DBG_W3SOBJ,
    rt_hresult,
    "CW3SpoofEventsCP::GetConnectionPointContainer",
    "this=%#x; ppCPC=%#x",
    this,
    ppCPC
    ));

  HRESULT hr = S_OK;

    if( !ppCPC )
    {
      hr = E_POINTER;
    }
    else
    {
      hr = m_pSite->QueryInterface(IID_IConnectionPointContainer, (void**) ppCPC);
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3Spoof::CW3SpoofEventsCP::Advise(IUnknown* punkSink, LPDWORD pdwCookie)
{
  DEBUG_ENTER((
    DBG_W3SOBJ,
    rt_hresult,
    "CW3SpoofEventsCP::Advise",
    "this=%#x; punkSink=%#x; pdwCookie=%#x",
    this,
    punkSink,
    pdwCookie
    ));

  HRESULT hr = S_OK;

  if( !punkSink || !pdwCookie )
  {
    hr = E_POINTER;
    goto quit;
  }

  if( m_cConnections != 0 )
  {
    hr = CONNECT_E_ADVISELIMIT;
    goto quit;
  }

    hr = punkSink->QueryInterface(IID_IW3SpoofEvents, (void**) &m_pSink);

    if( SUCCEEDED(hr) )
    {
      *pdwCookie = m_dwCookie = 1L;
      ++m_cConnections;
    }
    else
    {
      *pdwCookie = 0L;
      m_pSink    = NULL;
      hr         = CONNECT_E_CANNOTCONNECT;
    }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3Spoof::CW3SpoofEventsCP::Unadvise(DWORD dwCookie)
{
  DEBUG_ENTER((
    DBG_W3SOBJ,
    rt_hresult,
    "CW3SpoofEventsCP::Unadvise",
    "this=%#x; dwCookie=%d",
    this,
    dwCookie
    ));

  HRESULT hr = S_OK;

    if( dwCookie != 1L )
    {
      hr = CONNECT_E_NOCONNECTION;
    }
    else
    {
      m_pSink->Release();
      m_pSink    = NULL;
      m_dwCookie = 0L;
      --m_cConnections;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
CW3Spoof::CW3SpoofEventsCP::EnumConnections(IEnumConnections** ppEnum)
{
  return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\whttptst\inc\registry.h ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    registry.h

Abstract:

    Registry functions
    
Author:

    Paul M Midgen (pmidge) 23-May-2000


Revision History:

    23-May-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#ifndef _REGISTRY_H_
#define _REGISTRY_H_

#include "common.h"

HKEY _GetRootKey(BOOL fOpen);

BOOL SetRegValue(LPCWSTR wszValueName, DWORD dwType, LPVOID pvData, DWORD dwSize);
BOOL GetRegValue(LPCWSTR wszValueName, DWORD dwType, LPVOID* ppvData);

#endif /* _REGISTRY_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\whttptst\whttptst.inc ===
!IF 0

Copyright (c) 1994  Microsoft Corporation

!ENDIF

!IFNDEF SDKINC
SDKINC=$(SDK_INC_PATH)
!ENDIF

!IFDEF LIBDIR
!ERROR LIBDIR already defined - choose new name
!ENDIF

ROOT=$(SDXROOT)\inetcore\winhttp\tools\whttptst
LIBDIR=$(ROOT)\obj
WHTTPTSTINC=$(ROOT)\inc

#
# if TARGETPATH is not defined (in the paths that build libraries) then this
# is the default target path
#
!IFNDEF TARGETPATH
TARGETPATH=$(LIBDIR)
TARGETTYPE=LIBRARY
!ENDIF

#
# what it is that we're building
#
MAJORCOMP=whttptst

USE_NOLIBS=1
#USE_LIBCMT=0
NO_NTDLL=1
#NO_BINPLACE=0
#BINPLACE_PLACEFILE=..\binplace.txt

#
# Linker flags
#
WIN32_WINNT_VERSION=0x0500
#WIN32_WIN95_VERSION=0x0400

#
# compiler warning flags
#
MSC_WARNING_LEVEL=/W3 /WX

#
# enable exception handling
#
USE_NATIVE_EH=1

#
# compiler definitions
#
C_DEFINES=$(C_DEFINES) -DWIN32

CLEANINF = cleaninf.exe $(CLEANINF_FLAGS)

#
# Set debugging level
#
!IF "$(NTDEBUG)" != "" && "$(NTDEBUG)" != "retail" && "$(NTDEBUG)" != "ntsdnodbg"
C_DEFINES=$(C_DEFINES) -D_DEBUG
!ENDIF

!IF "$(__FULL_DEBUG__)" != ""
C_DEFINES=$(C_DEFINES) -D__FULL_DEBUG__
!ENDIF

!IFNDEF BUILD_PCH
PRECOMPILED_OPTION=/Fp$(ROOT)\inc\$(_OBJ_DIR)\*\common.pch /Yucommon.h
PRECOMPILED_CXX=1
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\whttptst\dll\dllentry.cxx ===
#include "common.h"

HINSTANCE  g_hGlobalDllInstance = NULL;
PHANDLEMAP g_pGlobalHandleMap   = NULL;
LPCWSTR    g_wszAdvPackDll      = L"advpack.dll";
LPCSTR     g_szInstallSection   = "install";
LPCSTR     g_szUninstallSection = "uninstall";

HRESULT RegisterServer(BOOL fMode);
HRESULT RegisterTypeLibrary(BOOL fMode);

//-----------------------------------------------------------------------------
// DLL Entry Point
//-----------------------------------------------------------------------------
BOOL
WINAPI
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID pvReserved)
{
  BOOL bRet = TRUE;

  DEBUG_TRACE(
    DLL,
    ("dllmain: %s", MapDllReasonToString(dwReason))
    );

  switch( dwReason )
  {
    case DLL_PROCESS_ATTACH :
      {
        DEBUG_INITIALIZE();
        
        g_hGlobalDllInstance = hInstance;
        g_pGlobalHandleMap   = new HANDLEMAP;

        if( g_pGlobalHandleMap )
        {
          g_pGlobalHandleMap->SetClearFunction(ScriptCallbackKiller);
        }
        else
        {
          bRet = FALSE;
        }
      }
      break;

    case DLL_PROCESS_DETACH:
      {
        SAFEDELETE(g_pGlobalHandleMap);
        _GetRootKey(FALSE);
        DEBUG_TERMINATE();
      }
      break;

    case DLL_THREAD_DETACH:
      break;

    case DLL_THREAD_ATTACH:
      break;
  }
  
  return bRet;
}


//-----------------------------------------------------------------------------
// COM Entry Points
//-----------------------------------------------------------------------------
STDAPI
DllRegisterServer(void)
{
  return RegisterServer(TRUE);
}


STDAPI
DllUnregisterServer(void)
{
  return RegisterServer(FALSE);
}


STDAPI
DllGetClassObject(REFIID clsid, REFIID riid, void** ppv)
{
  return CLSFACTORY::Create(clsid, riid, ppv);
}


//-----------------------------------------------------------------------------
// SelfRegistration helper routines
//-----------------------------------------------------------------------------
HRESULT
RegisterServer(BOOL fMode)
{
  DEBUG_ENTER((
    DBG_DLL,
    rt_hresult,
    "RegisterServer",
    "fMode=%s",    
    fMode ? g_szInstallSection : g_szUninstallSection
    ));

  HRESULT    hr      = S_OK;
  HINSTANCE  advpack = NULL;
  REGINSTALL pfnri   = NULL;

  advpack = LoadLibrary(g_wszAdvPackDll);

    if( !advpack )
    {
      DEBUG_TRACE(
        DLL,
        ("couldn't load advpack.dll: %s", MapErrorToString(GetLastError()))
        );

      hr = E_FAIL;
      goto quit;
    }

  pfnri = (REGINSTALL) GetProcAddress(advpack, achREGINSTALL);

    if( !pfnri )
    {
      DEBUG_TRACE(
        DLL,
        ("couldn't get RegInstall pointer: %s", MapErrorToString(GetLastError()))
        );

      hr = E_FAIL;
      goto quit;
    }

  hr = pfnri(
        g_hGlobalDllInstance,
        fMode ? g_szInstallSection : g_szUninstallSection,
        NULL
        );

  FreeLibrary(advpack);

  hr = RegisterTypeLibrary(fMode);

quit:

  DEBUG_LEAVE(hr);
  return hr;
}

HRESULT
RegisterTypeLibrary(BOOL fMode)
{
  DEBUG_ENTER((
    DBG_FACTORY,
    rt_hresult,
    "RegisterTypeLibrary",
    "fMode=%s",    
    fMode ? g_szInstallSection : g_szUninstallSection
    ));

  ITypeLib* ptl  = NULL;
  TLIBATTR* pta  = NULL;
  WCHAR*    pbuf = NULL;
  HRESULT   hr   = S_OK;

  if( (pbuf = new WCHAR[MAX_PATH]) )
  {
    GetModuleFileName(g_hGlobalDllInstance, pbuf, MAX_PATH);
  }
  else
  {
    hr = E_OUTOFMEMORY;
    goto quit;
  }

  hr = LoadTypeLib(pbuf, &ptl);

  if( SUCCEEDED(hr) )
  {
    if( fMode )
    {
      hr = RegisterTypeLib(ptl, pbuf, NULL);
    }
    else
    {
      hr = ptl->GetLibAttr(&pta);

        if( SUCCEEDED(hr) )
        {
          hr = UnRegisterTypeLib(
                pta->guid,
                pta->wMajorVerNum,
                pta->wMinorVerNum,
                pta->lcid,
                pta->syskind
                );

          ptl->ReleaseTLibAttr(pta);
        }
        else
        {
          goto quit;
        }
    }
    
    ptl->Release();
  }

quit:

  SAFEDELETEBUF(pbuf);

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\whttptst\inc\debug.h ===
#ifndef __DEBUG_H__
#define __DEBUG_H__

#include "common.h"

//
// always build this stuff.
//
#define CASE_OF(constant) case constant: return # constant
#define CASE_OF_MUTATE(val, name) case val: return # name
#define CASE_IID(riid, iid) if(IsEqualIID(riid, iid)) return # iid

LPSTR MapDispidToString(DISPID dispid);
LPSTR MapErrorToString(int error);
LPSTR MapHResultToString(HRESULT hr);
LPSTR MapIIDToString(REFIID riid);
LPSTR MapVariantTypeToString(VARIANT* pvar);
LPSTR MapPointerTypeToString(POINTER pointer);
LPSTR MapDataTypeToString(TYPE type);
LPSTR MapWinHttpAccessType(DWORD type);
LPSTR MapWinHttpIOMode(DWORD mode);
LPSTR MapWinHttpHandleType(HINTERNET hInternet);
LPSTR MapMemsetFlagToString(MEMSETFLAG mf);
LPSTR MapCallbackFlagToString(DWORD flag);

int DebugDataDumpFormat(LPSTR buffer, LPBYTE data, DWORD len);

#ifdef _DEBUG

//
// manifests
//

#if defined(__DBG_TO_CONSOLE__)
#define OUTPUT_FLAGS DBG_TO_DEBUGGER
#else
#define OUTPUT_FLAGS DBG_TO_FILE
#endif

#if defined(__FULL_DEBUG__)
#define DEBUG_DEFAULT_FLAGS ( \
                             DBG_DLL          \
                           | DBG_INITIALIZE   \
                           | DBG_WHTTPTST     \
                           | DBG_WHTERROR     \
                           | DBG_WHTURLCMP    \
                           | DBG_REGISTRY     \
                           | DBG_MEM          \
                           | DBG_REFCOUNT     \
                           | DBG_FACTORY      \
                           | DBG_UTILS        \
                           | DBG_DISPATCH     \
                           | DBG_HELPER       \
                           | DBG_THREAD_INFO  \
                           | DBG_CALL_INFO    \
                           | DBG_CALL_DEPTH   \
                           | DBG_TIMESTAMP    \
                           | DBG_NEST_CALLS   \
                           | OUTPUT_FLAGS)
#else
#define DEBUG_DEFAULT_FLAGS ( \
                             DBG_WHTTPTST     \
                           | DBG_TYPE         \
                           | DBG_HELPER       \
                           | DBG_WHTURLCMP    \
                           | DBG_THREAD_INFO  \
                           | DBG_CALL_INFO    \
                           | DBG_CALL_DEPTH   \
                           | DBG_TIMESTAMP    \
                           | DBG_NEST_CALLS   \
                           | OUTPUT_FLAGS)
#endif

// category flags
#define DBG_DLL           0x00000001
#define DBG_WHTTPTST      0x00000002
#define DBG_REGISTRY      0x00000004
#define DBG_MEM           0x00000008
#define DBG_REFCOUNT      0x00000010
#define DBG_FACTORY       0x00000020
#define DBG_UTILS         0x00000040
#define DBG_DISPATCH      0x00000080
#define DBG_HELPER        0x00000100
#define DBG_TYPE          0x00000200
#define DBG_WHTERROR      0x00000400
#define DBG_INITIALIZE    0x00000800
#define DBG_WHTURLCMP     0x00001000

// control flags
#define DBG_THROWDBGALERT 0x00800000
#define DBG_THREAD_INFO   0x01000000
#define DBG_CALL_DEPTH    0x02000000 // remove
#define DBG_TIMESTAMP     0x04000000
#define DBG_NEST_CALLS    0x08000000
#define DBG_TO_FILE       0x10000000
#define DBG_TO_DEBUGGER   0x20000000
#define DBG_CALL_INFO     0x40000000
#define DBG_NO_DEBUG      0x80000000

//
// types
//

typedef struct _memusage
{
  CRITICAL_SECTION lock;
  DWORD            total;
  MEMORYSTATUS     status;
}
MEMUSAGE, *PMEMUSAGE;

typedef enum _rettype
{
  rt_void,
  rt_bool,
  rt_dword,
  rt_hresult,
  rt_string
}
RETTYPE, *LPRETTYPE;

typedef struct _callinfo
{
  struct _callinfo* next;
  struct _callinfo* last;
  DWORD             category;
  LPCSTR            fname;
  RETTYPE           rettype;
}
CALLINFO, *LPCALLINFO;

typedef struct _threadinfo
{
  DWORD      threadid;
  DWORD      threadcat;
  DWORD      depth;
  LPCALLINFO stack;
}
THREADINFO, *LPTHREADINFO;

//
// prototypes
//

void DebugInitialize(void);
void DebugTerminate(void);

void DebugMemInitialize(void);
void DebugMemTerminate(void);
void DebugMemAlloc(void* pv);
void DebugMemFree(void* pv);

void DebugEnter(int category, RETTYPE rt, LPCSTR function, const char* format, ...);
void DebugLeave(int retval);
void DebugTrace(const char* format, ...);
void DebugAssert(LPSTR condition, LPSTR file, int line);

void DebugDataDump(LPSTR title, LPBYTE data, DWORD len);

void DebugThrowDbgAlert(void);

void AcquireDebugFileLock(void);
void ReleaseDebugFileLock(void);

LPTHREADINFO GetThreadInfo(void);

LPCALLINFO   SetCallInfo(LPTHREADINFO pti, DWORD category, RETTYPE rt, LPCSTR function);
LPCALLINFO   GetCallInfo(LPTHREADINFO pti);
void         DeleteCallInfo(LPCALLINFO pci);

LPSTR        FormatCallReturnString(LPCALLINFO pci, int retval);
LPSTR        MapCategoryToString(int category);
LPSTR        MapDllReasonToString(int reason);

void  _debugout(LPTHREADINFO pti, BOOL fRaw, BOOL fTrace, const char* format, ...);
char* _gettimestamp(void);
char* _getwhitespace(int spaces);
BOOL  _opendebugfile(void);
void  _closedebugfile(void);

//
// macros
//
#define DEBUG_INITIALIZE() DebugInitialize()
#define DEBUG_TERMINATE()  DebugTerminate()

#define DEBUG_ENTER(parameters) \
              DebugEnter parameters

#define DEBUG_LEAVE(retval) \
              DebugLeave(retval)

#define DEBUG_ALLOC(block) \
              DebugMemAlloc(block)

#define DEBUG_FREE(block) \
              DebugMemFree(block)

extern DWORD g_dwDebugFlags;

#define DEBUG_TRACE(category, parameters) \
              if( DBG_##category & g_dwDebugFlags ) \
                DebugTrace parameters

#define DEBUG_DATA_DUMP(category, parameters) \
              if(DBG_##category & g_dwDebugFlags ) \
                DebugDataDump parameters

#define DEBUG_ADDREF(objname, refcount) \
              if( DBG_REFCOUNT & g_dwDebugFlags ) \
                DebugTrace("%s [%#x] addref: %d", objname, this, refcount)

#define DEBUG_RELEASE(objname, refcount) \
              if( DBG_REFCOUNT & g_dwDebugFlags ) \
                DebugTrace("%s [%#x] release: %d", objname, this, refcount)

#define DEBUG_FINALRELEASE(objname) \
              if( DBG_REFCOUNT & g_dwDebugFlags ) \
                DebugTrace("%s [%#x] final release!", objname, this)

#define DEBUG_DUMPWSOCKSTATS(wsd) \
              if( DBG_APP & g_dwDebugFlags ) \
                DebugTrace(\
                  "%s (v%d.%d in use) is %s",\
                  wsd.szDescription,\
                  (wsd.wVersion & 0x00FF),\
                  ((wsd.wVersion & 0xFF00) >> 8),\
                  wsd.szSystemStatus)


#define DEBUG_ASSERT(condition) \
          if( !(condition) ) \
            DebugAssert(#condition, __FILE__, __LINE__)

#else

// we will get rebuked for the bogus 
// arglists in the debug macros
#pragma warning( disable : 4002 )
#pragma warning( disable : 4003 )

#define DEBUG_ASSERT(x, y, z)
#define DEBUG_INITIALIZE()
#define DEBUG_TERMINATE()
#define DEBUG_ALLOC(x)
#define DEBUG_FREE(x)
#define DEBUG_ENTER(x)
#define DEBUG_LEAVE(x)
#define DEBUG_TRACE(x)
#define DEBUG_ADDREF(x)
#define DEBUG_RELEASE(x)
#define DEBUG_FINALRELEASE(x)
#define DEBUG_DUMPWSOCKSTATS(x)
#define DEBUG_DATA_DUMP(X)

#endif /* _DEBUG */
#endif /* __DEBUG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\whttptst\inc\hashtable.h ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    hashtable.cxx

Abstract:

    Simple hash table implementation.


Author:

    Paul M Midgen (pmidge) 14-August-2000


Revision History:

    14-August-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include <common.h>

/*++===========================================================================

    An array is separated into N buckets that     +---+
    each contain a pointer to a binary search     | 0 |------> O
    tree. The tree's nodes are indexed by a       +---+       / \
    DWORD identifier to enable speedy traversals. | 1 |      O   O
    The array buckets are indexed by the values   +---+     / \   \
    generated by the hashing function supplied    | 2 |    O   O   O
    by a derived class.                           +---+        
                                                  | N |

    Clients derive a class from the hashtable ADT and specialize it for a 
    given data type. Any data type can be used. The only function the client
    must implement is the GetHashAndBucket function, and their class must
    provide the number of buckets the ADT needs to support. This is usually
    some number that is modulo'd against the generated hashes to yield the
    bucket number.

===========================================================================--*/

#define HT_COMPARE_LARGER  0x00000001
#define HT_COMPARE_SMALLER 0x00000002
#define HT_COMPARE_EQUAL   0x00000003

#define HT_TREE_ROOT       0x00000004
#define HT_TREE_RHSUBTREE  0x00000005
#define HT_TREE_LHSUBTREE  0x00000006

typedef struct _NODE
{
  DWORD  hash;
  DWORD  bucket;
  LPVOID data;
  _NODE* parent;
  _NODE* rh_child;
  _NODE* lh_child;
  BOOL   isLeft;
}
NODE, *PNODE;

typedef VOID (*PFNCLEARFUNC)(LPVOID* ppv);

template <class T> class CHashTable
{
  public:
    CHashTable(DWORD buckets)
    {
      pfnClear  = NULL;
      cBuckets  = buckets;
      arBuckets = new PNODE[buckets];
      InitializeCriticalSection(&csTable);
    }

   ~CHashTable()
    {
      SAFEDELETEBUF(arBuckets);
      DeleteCriticalSection(&csTable);
    }

    virtual void GetHashAndBucket(T id, LPDWORD lpHash, LPDWORD lpBucket) =0;

    DWORD Insert(T id, LPVOID pv);
    DWORD Get(T id, LPVOID* ppv);
    DWORD Delete(T id, LPVOID* ppv);

    void  Clear(void);
    void  SetClearFunction(PFNCLEARFUNC pfn) { pfnClear = pfn; }

  private:
    void  _Get(DWORD hash, PNODE& proot, PNODE& pnode);
    DWORD _Insert(PNODE& proot, PNODE pnew);
    void  _Remove(DWORD hash, PNODE& proot, PNODE& pnode);

    PNODE _NewNode(T id, LPVOID pv);
    DWORD _CompareNodes(DWORD hash_target, DWORD hash_tree);

    BOOL  _HasChildren(PNODE pnode);
    void  _PostTraverseAndDelete(PNODE proot);
    void  _Lock(void)   { EnterCriticalSection(&csTable); }
    void  _Unlock(void) { LeaveCriticalSection(&csTable); }

    PNODE*       arBuckets;
    DWORD        cBuckets;
    CRITSEC      csTable;
    PFNCLEARFUNC pfnClear;
};

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

template <class T> DWORD CHashTable<T>::Insert(T id, LPVOID pv)
{
  DWORD ret = ERROR_SUCCESS;
  PNODE pn  = _NewNode(id, pv);

  _Lock();

    if( pn )
    {
      ret = _Insert(arBuckets[pn->bucket], pn);
    }
    else
    {
      ret = ERROR_OUTOFMEMORY;
    }

  _Unlock();

  return ret;
}

template <class T> DWORD CHashTable<T>::Get(T id, LPVOID* ppv)
{
  DWORD ret    = ERROR_SUCCESS;
  DWORD hash   = 0L;
  DWORD bucket = 0L;
  PNODE pnode  = NULL;

  GetHashAndBucket(id, &hash, &bucket);

  _Lock();

    _Get(hash, arBuckets[bucket], pnode);

    if( pnode )
    {
      *ppv = (void*) pnode->data;
    }
    else
    {
      *ppv = NULL;
      ret  = ERROR_NOT_FOUND;
    }

  _Unlock();

  return ret;
}

template <class T> DWORD CHashTable<T>::Delete(T id, LPVOID* ppv)
{
  DWORD ret   = ERROR_SUCCESS;
  DWORD hash   = 0L;
  DWORD bucket = 0L;
  PNODE pnode = NULL;

  GetHashAndBucket(id, &hash, &bucket);

  _Lock();

    _Remove(hash, arBuckets[bucket], pnode);

    if( pnode )
    {
      if( ppv )
      {
        *ppv = pnode->data;
      }
      else
      {
        if( pfnClear )
        {
          pfnClear(&pnode->data);
        }
      }

      delete pnode;
    }
    else
    {
      ret = ERROR_NOT_FOUND;

      if( ppv )
      {
        *ppv = NULL;
      }
    }

  _Unlock();

  return ret;
}

template <class T> void CHashTable<T>::Clear(void)
{
  _Lock();

    for(DWORD n=0; n < cBuckets; n++)
    {
      if( arBuckets[n] )
      {
        _PostTraverseAndDelete(arBuckets[n]);
        arBuckets[n] = NULL;
      }
    }

  _Unlock();
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

template <class T> DWORD CHashTable<T>::_Insert(PNODE& proot, PNODE pnew)
{
  DWORD ret = ERROR_SUCCESS;

  if( pnew )
  {
    if( !proot )
    {
      proot = pnew;
    }
    else
    {
      switch( _CompareNodes(pnew->hash, proot->hash) )
      {
        case HT_COMPARE_SMALLER :
          {
            pnew->isLeft = TRUE;
            pnew->parent = proot;
            ret = _Insert(proot->lh_child, pnew);
          }
          break;

        case HT_COMPARE_LARGER :
          {
            pnew->isLeft = FALSE;
            pnew->parent = proot;
            ret = _Insert(proot->rh_child, pnew);
          }
          break;

        case HT_COMPARE_EQUAL :
          {
            if( pfnClear )
            {
              pfnClear(&proot->data);
            }

            ret         = ERROR_DUP_NAME;
            proot->data = pnew->data;
            delete pnew;
          }
          break;
      }
    }
  }

  return ret;
}

template <class T> void CHashTable<T>::_Get(DWORD hash, PNODE& proot, PNODE& pnode)
{
  if( proot )
  {
    switch( _CompareNodes(hash, proot->hash) )
    {
      case HT_COMPARE_SMALLER :
        {
          _Get(hash, proot->lh_child, pnode);
        }
        break;

      case HT_COMPARE_LARGER :
        {
          _Get(hash, proot->rh_child, pnode);
        }
        break;

      case HT_COMPARE_EQUAL :
        {
          pnode = proot;
        }
        break;
    }
  }
  else
  {
    pnode = NULL;
  }
}

template <class T> void CHashTable<T>::_Remove(DWORD hash, PNODE& proot, PNODE& pnode)
{
  if( proot )
  {
    switch( _CompareNodes(hash, proot->hash) )
    {
      case HT_COMPARE_SMALLER :
        {
          _Remove(hash, proot->lh_child, pnode);
        }
        break;

      case HT_COMPARE_LARGER :
        {
          _Remove(hash, proot->rh_child, pnode);
        }
        break;

      case HT_COMPARE_EQUAL :
        {
          pnode = proot;

          //
          // if proot has no parent it is the tree's root node
          //
          //   - if it has children, promote the left child to root
          //     and insert the right child in the new tree. after
          //     inserting, make sure the new root has no parent.
          //
          //   - if it has no children the tree is empty, set the root
          //     to null
          //

          if( !proot->parent )
          {
            if( _HasChildren(proot) )
            {
              proot = proot->lh_child;
              _Insert(proot, pnode->rh_child);
              proot->parent = NULL;
            }
            else
            {
              proot = NULL;
            }
          }
          else
          {
            if( proot->isLeft )
            {
              proot->parent->lh_child = NULL;
            }
            else
            {
              proot->parent->rh_child = NULL;
            }

            _Insert(pnode->parent, pnode->lh_child);
            _Insert(pnode->parent, pnode->rh_child);
          }
        }
        break;
    }
  }
  else
  {
    pnode = NULL;
  }
}

template <class T> void CHashTable<T>::_PostTraverseAndDelete(PNODE proot)
{
  if( proot )
  {
    _PostTraverseAndDelete(proot->lh_child);
    _PostTraverseAndDelete(proot->rh_child);

    if( pfnClear )
    {
      pfnClear(&proot->data);
    }

    delete proot;
    proot = NULL;
  }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

template <class T> DWORD CHashTable<T>::_CompareNodes(DWORD hash_target, DWORD hash_tree)
{
  if( hash_target == hash_tree )
  {
    return HT_COMPARE_EQUAL;
  }
  else if( hash_target < hash_tree )
  {
    return HT_COMPARE_SMALLER;
  }
  else
  {
    return HT_COMPARE_LARGER;
  }
}

template <class T> PNODE CHashTable<T>::_NewNode(T id, LPVOID pv)
{
  PNODE pn = new NODE;

  if( pn )
  {
    GetHashAndBucket(id, &pn->hash, &pn->bucket);
    pn->data = pv;
  }

  return pn;
}

template <class T> BOOL CHashTable<T>::_HasChildren(PNODE pnode)
{
  if( pnode )
  {
    return (pnode->lh_child || pnode->rh_child);
  }
  else
  {
    return FALSE;
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\whttptst\inc\common.h ===
#ifndef _COMMON_H_
#define _COMMON_H_

#define _WIN32_WINNT 0x0500
#define _UNICODE
#define UNICODE

//
// OS includes
//

#if defined(__cplusplus)
extern "C" {
#endif

#include <windows.h>
#include <shellapi.h>
#include <advpub.h>
#include <oleauto.h>
#include <objbase.h>
#include <ocidl.h>
#include <olectl.h>
#include <winhttp.h>

#if defined(__cplusplus)
}
#endif


//
// app includes
//

#pragma warning( disable : 4100 ) // unreferenced formal parameter

#include "registry.h"
#include "mem.h"
#include "dispids.h"
#include "resources.h"
#include "debug.h"
#include "whttptst.h" // generated
#include "hashtable.h"
#include "utils.h"


//
// class declarations
//
typedef class CHashTable<HINTERNET> _HANDLEMAP;
typedef class CHandleMap  HANDLEMAP;
typedef class CHandleMap* PHANDLEMAP;

void ScriptCallbackKiller(LPVOID* ppv);

class CHandleMap : public _HANDLEMAP
{
  public:
    CHandleMap() : _HANDLEMAP(10) {}
   ~CHandleMap() {}

    void GetHashAndBucket(HINTERNET id, LPDWORD lpHash, LPDWORD lpBucket);
};

typedef class ClassFactory  CLSFACTORY;
typedef class ClassFactory* PCLSFACTORY;

class ClassFactory : public IClassFactory
{
  public:
    DECLAREIUNKNOWN();
    DECLAREICLASSFACTORY();

    ClassFactory();
   ~ClassFactory();

    static HRESULT Create(REFIID clsid, REFIID riid, void** ppv);

  private:
    LONG m_cRefs;
    LONG m_cLocks;
};

void WinHttpCallback(
       HINTERNET hInternet,
       DWORD_PTR dwContext,
       DWORD     dwInternetStatus,
       LPVOID    lpvStatusInformation,
       DWORD     dwStatusInformationLength
       );

typedef class WinHttpTest  WHTTPTST;
typedef class WinHttpTest* PWHTTPTST;

class WinHttpTest : public IWinHttpTest,
                    public IProvideClassInfo
{
  public:
    DECLAREIUNKNOWN();
    DECLAREIDISPATCH();

    //
    // IWinHttpTest
    //
    HRESULT __stdcall WinHttpOpen(
                        VARIANT UserAgent,
                        VARIANT AccessType,
                        VARIANT ProxyName,
                        VARIANT ProxyBypass,
                        VARIANT Flags, 
                        VARIANT *OpenHandle
                        );
        
    HRESULT __stdcall WinHttpConnect(
                        VARIANT OpenHandle,
                        VARIANT ServerName,
                        VARIANT ServerPort,
                        VARIANT Reserved,
                        VARIANT *ConnectHandle
                        );
        
    HRESULT __stdcall WinHttpOpenRequest(
                        VARIANT ConnectHandle,
                        VARIANT Verb,
                        VARIANT ObjectName,
                        VARIANT Version,
                        VARIANT Referrer,
                        VARIANT AcceptTypes,
                        VARIANT Flags,
                        VARIANT *RequestHandle
                        );
        
    HRESULT __stdcall WinHttpSendRequest(
                        VARIANT RequestHandle,
                        VARIANT Headers,
                        VARIANT HeadersLength,
                        VARIANT OptionalData,
                        VARIANT OptionalLength,
                        VARIANT TotalLength,
                        VARIANT Context,
                        VARIANT *Success
                        );
        
    HRESULT __stdcall WinHttpReceiveResponse(
                        VARIANT RequestHandle,
                        VARIANT Reserved,
                        VARIANT *Success
                        );

    HRESULT __stdcall WinHttpCloseHandle(
                        VARIANT InternetHandle,
                        VARIANT *Success
                        );

    HRESULT __stdcall WinHttpReadData(
                        VARIANT RequestHandle,
                        VARIANT BufferObject,
                        VARIANT *Success
                        );

    HRESULT __stdcall WinHttpWriteData(
                        VARIANT RequestHandle,
                        VARIANT BufferObject,
                        VARIANT *Success
                        );

    HRESULT __stdcall WinHttpQueryDataAvailable(
                        VARIANT RequestHandle,
                        VARIANT boNumberOfBytesAvailable,
                        VARIANT *Success
                        );

    HRESULT __stdcall WinHttpQueryOption(
                        VARIANT InternetHandle,
                        VARIANT Option,
                        VARIANT BufferObject,
                        VARIANT *Success
                        );

    HRESULT __stdcall WinHttpSetOption(
                        VARIANT InternetHandle,
                        VARIANT Option,
                        VARIANT BufferObject,
                        VARIANT *Success
                        );

    HRESULT __stdcall WinHttpSetTimeouts(
                        VARIANT InternetHandle,
                        VARIANT ResolveTimeout,
                        VARIANT ConnectTimeout,
                        VARIANT SendTimeout,
                        VARIANT ReceiveTimeout,
                        VARIANT *Success
                        );
        
    HRESULT __stdcall WinHttpAddRequestHeaders(
                        VARIANT RequestHandle,
                        VARIANT Headers,
                        VARIANT HeadersLength,
                        VARIANT Modifiers,
                        VARIANT *Success
                        );
        
    HRESULT __stdcall WinHttpSetCredentials(
                        VARIANT RequestHandle,
                        VARIANT AuthTargets,
                        VARIANT AuthScheme,
                        VARIANT UserName,
                        VARIANT Password,
                        VARIANT AuthParams,
                        VARIANT *Success
                        );
        
    HRESULT __stdcall WinHttpQueryAuthSchemes(
                        VARIANT RequestHandle,
                        VARIANT SupportedSchemes,
                        VARIANT PreferredSchemes,
                        VARIANT AuthTarget,
                        VARIANT *Success
                        );
        
    HRESULT __stdcall WinHttpQueryHeaders(
                        VARIANT RequestHandle,
                        VARIANT InfoLevel,
                        VARIANT HeaderName,
                        VARIANT HeaderValue,
                        VARIANT HeaderValueLength,
                        VARIANT *Success
                        );
        
    HRESULT __stdcall WinHttpTimeFromSystemTime(
                        VARIANT SystemTime,
                        VARIANT boHttpTime,
                        VARIANT *Success
                        );

    HRESULT __stdcall WinHttpTimeToSystemTime(
                        VARIANT boHttpTime,
                        VARIANT SystemTime,
                        VARIANT *Success
                        );
        
    HRESULT __stdcall WinHttpCrackUrl(
                        VARIANT Url,
                        VARIANT UrlLength,
                        VARIANT Flags,
                        VARIANT UrlComponents,
                        VARIANT *Success
                        );
        
    HRESULT __stdcall WinHttpCreateUrl(
                        VARIANT UrlComponents,
                        VARIANT Flags,
                        VARIANT BufferObject,
                        VARIANT *Success
                        );

    HRESULT __stdcall WinHttpSetStatusCallback(
                        VARIANT InternetHandle,
                        VARIANT CallbackFunction,
                        VARIANT NotificationFlags,
                        VARIANT Reserved,
                        VARIANT *RetVal
                        );
        
    HRESULT __stdcall HelperGetBufferObject(
                        VARIANT Size,
                        VARIANT Type,
                        VARIANT Flags,
                        VARIANT *BufferObject
                        );
        
    HRESULT __stdcall HelperGetUrlComponents(
                        VARIANT Flags,
                        VARIANT *UrlComponents
                        );
        
    HRESULT __stdcall HelperGetSystemTime(
                        VARIANT Flags,
                        VARIANT *SystemTime
                        );
        
    HRESULT __stdcall HelperGetLastError(
                        VARIANT *Win32ErrorCode
                        );
    
    DECLAREIPROVIDECLASSINFO();

    public:
      WinHttpTest();
     ~WinHttpTest();

      static HRESULT Create(REFIID riid, void** ppv);

    private:
      HRESULT    _Initialize(void);
      HRESULT    _SetErrorCode(DWORD error);

      HRESULT    _WinHttpOpen(
                    LPCWSTR  pwszUserAgent,
                    DWORD    dwAccessType,
                    LPCWSTR  pwszProxyName,
                    LPCWSTR  pwszProxyBypass,
                    DWORD    dwFlags,
                    VARIANT* retval
                    );
      
      HRESULT    _WinHttpConnect(
                    HINTERNET     hSession,
                    LPCWSTR       pwszServerName,
                    INTERNET_PORT nServerPort,
                    DWORD         dwReserved,
                    VARIANT*      retval
                    );

      HRESULT    _WinHttpOpenRequest(
                    HINTERNET hConnect,
                    LPCWSTR   pwszVerb,
                    LPCWSTR   pwszObjectName,
                    LPCWSTR   pwszVersion,
                    LPCWSTR   pwszReferrer,
                    LPCWSTR*  ppwszAcceptTypes,
                    DWORD     dwFlags,
                    VARIANT*  retval
                    );

      HRESULT    _WinHttpSendRequest(
                    HINTERNET hRequest,
                    LPCWSTR   pwszHeaders,
                    DWORD     dwHeadersLength,
                    LPVOID    lpOptional,
                    DWORD     dwOptionalLength,
                    DWORD     dwTotalLength,
                    DWORD_PTR dwContext,
                    VARIANT*  retval
                    );

      HRESULT    _WinHttpCloseHandle(
                    HINTERNET hInternet,
                    VARIANT*  retval
                    );

      HRESULT    _WinHttpSetStatusCallback(
                    HINTERNET               hInternet,
                    WINHTTP_STATUS_CALLBACK lpfnCallback,
                    DWORD                   dwNotificationFlags,
                    DWORD_PTR               dwReserved,
                    VARIANT*                retval
                    );

    private:
      LONG                m_cRefs;
      ITypeInfo*          m_pti;
      IWHTWin32ErrorCode* m_pw32ec;
};


typedef class WHTUrlComponents  WHTURLCMP;
typedef class WHTUrlComponents* PWHTURLCMP;

class WHTUrlComponents : public IWHTUrlComponents,
                         public IProvideClassInfo
{
  public:
    DECLAREIUNKNOWN();
    DECLAREIDISPATCH();

    //
    // IWHTUrlComponents
    //
    HRESULT __stdcall get_StructSize(
                        VARIANT *Value
                        );
        
    HRESULT __stdcall put_StructSize(
                        VARIANT Value
                        );
        
    HRESULT __stdcall get_Scheme(
                        VARIANT *Value
                        );
        
    HRESULT __stdcall put_Scheme(
                        VARIANT Value
                        );
        
    HRESULT __stdcall get_SchemeLength(
                        VARIANT *Length
                        );
        
    HRESULT __stdcall put_SchemeLength(
                        VARIANT Length
                        );
        
    HRESULT __stdcall get_SchemeId(
                        VARIANT *Value
                        );
        
    HRESULT __stdcall put_SchemeId(
                        VARIANT Value
                        );
        
    HRESULT __stdcall get_HostName(
                        VARIANT *Value
                        );
        
    HRESULT __stdcall put_HostName(
                        VARIANT Value
                        );
        
    HRESULT __stdcall get_HostNameLength(
                        VARIANT *Length
                        );
        
    HRESULT __stdcall put_HostNameLength(
                        VARIANT Length
                        );
        
    HRESULT __stdcall get_Port(
                        VARIANT *Value
                        );
        
    HRESULT __stdcall put_Port(
                        VARIANT Value
                        );
        
    HRESULT __stdcall get_UserName(
                        VARIANT *Value
                        );
        
    HRESULT __stdcall put_UserName(
                        VARIANT Value
                        );
        
    HRESULT __stdcall get_UserNameLength(
                        VARIANT *Value
                        );
        
    HRESULT __stdcall put_UserNameLength(
                        VARIANT Value
                        );
        
    HRESULT __stdcall get_Password(
                        VARIANT *Value
                        );
        
    HRESULT __stdcall put_Password(
                        VARIANT Value
                        );
        
    HRESULT __stdcall get_PasswordLength(
                        VARIANT *Length
                        );
        
    HRESULT __stdcall put_PasswordLength(
                        VARIANT Length
                        );
        
    HRESULT __stdcall get_UrlPath(
                        VARIANT *Value
                        );
        
    HRESULT __stdcall put_UrlPath(
                        VARIANT Value
                        );
        
    HRESULT __stdcall get_UrlPathLength(
                        VARIANT *Length
                        );
        
    HRESULT __stdcall put_UrlPathLength(
                        VARIANT Length
                        );
        
    HRESULT __stdcall get_ExtraInfo(
                        VARIANT *Value
                        );
        
    HRESULT __stdcall put_ExtraInfo(
                        VARIANT Value
                        );
        
    HRESULT __stdcall get_ExtraInfoLength(
                        VARIANT *Length
                        );
        
    HRESULT __stdcall put_ExtraInfoLength(
                        VARIANT Length
                        );

    DECLAREIPROVIDECLASSINFO();

  public:
    WHTUrlComponents();
   ~WHTUrlComponents();

    static HRESULT Create(MEMSETFLAG mf, IWHTUrlComponents** ppwuc);

  private:
    HRESULT         _Initialize(MEMSETFLAG mf);
    LONG            m_cRefs;
    ITypeInfo*      m_pti;
    URL_COMPONENTSW m_uc;
};


typedef class WHTWin32ErrorCode  WHTERROR;
typedef class WHTWin32ErrorCode* PWHTERROR;

class WHTWin32ErrorCode : public IWHTWin32ErrorCode,
                          public IProvideClassInfo
{
  public:
    DECLAREIUNKNOWN();
    DECLAREIDISPATCH();

    HRESULT __stdcall get_ErrorCode(
                        VARIANT *ErrorCode
                        );

    HRESULT __stdcall get_ErrorString(
                        VARIANT *ErrorString
                        );

    HRESULT __stdcall get_IsException(
                        VARIANT *IsException
                        );

    DECLAREIPROVIDECLASSINFO();

  public:
    WHTWin32ErrorCode(DWORD error);
   ~WHTWin32ErrorCode();

    static HRESULT Create(DWORD error, IWHTWin32ErrorCode** ppwec);

  private:
    HRESULT    _Initialize(void);
    BOOL       _IsException(int e);
    LONG       m_cRefs;
    ITypeInfo* m_pti;
    DWORD      m_error;
    BOOL       m_bIsException;
};

#endif /* _COMMON_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\whttptst\inc\resources.h ===
#ifndef __RESOURCES_H__
#define __RESOURCES_H__

#define ERROR_FAILURE            0xFFFFF666

#define DECLAREIUNKNOWN() \
    HRESULT __stdcall QueryInterface(REFIID riid, void** ppv); \
    ULONG   __stdcall AddRef(void); \
    ULONG   __stdcall Release(void); 

#define DECLAREICLASSFACTORY() \
    HRESULT __stdcall CreateInstance(IUnknown* outer, REFIID riid, void** ppv); \
    HRESULT __stdcall LockServer(BOOL lock);

#define DECLAREIDISPATCH() \
    HRESULT __stdcall GetTypeInfoCount(UINT* pctinfo);  \
    HRESULT __stdcall GetTypeInfo(UINT index, LCID lcid, ITypeInfo** ppti); \
    HRESULT __stdcall GetIDsOfNames(REFIID riid, LPOLESTR* arNames, UINT cNames, LCID lcid, DISPID* arDispId); \
    HRESULT __stdcall Invoke(DISPID dispid, REFIID riid, LCID lcid, WORD flags, DISPPARAMS* pdp, VARIANT* pvr, EXCEPINFO* pei, UINT* pae);

#define DECLAREIPROVIDECLASSINFO() \
  HRESULT __stdcall GetClassInfo(ITypeInfo** ppti);

#define DECLAREIOBJECTWITHSITE() \
    HRESULT __stdcall SetSite(IUnknown* pUnkSite); \
    HRESULT __stdcall GetSite(REFIID riid, void** ppvSite);

#define SAFECLOSE(x) if((x!=INVALID_HANDLE_VALUE) && (x!=NULL)) { CloseHandle(x); x=NULL; }
#define SAFEDELETE(x) if(x) { delete x; x=NULL; }
#define SAFEDELETEBUF(x) if(DWORD(x)) {delete [] x; x=NULL;}
#define SAFERELEASE(x) if(x) { x->Release(); x=NULL; }
#define SAFEDELETEBSTR(x) if(x) { SysFreeString(x); x=NULL; }
#define VALIDDISPID(x) ((x!=DISPID_UNKNOWN) ? TRUE : FALSE)
#define NEWVARIANT(x) VARIANT x; VariantInit(&x);

#define TF(x) (x?"TRUE":"FALSE")
#define VTF(x) (V_BOOL(x)?"TRUE":"FALSE")

typedef CRITICAL_SECTION             CRITSEC;
typedef LPCRITICAL_SECTION           PCRITSEC;
typedef BY_HANDLE_FILE_INFORMATION   BHFI;
typedef LPBY_HANDLE_FILE_INFORMATION LPBHFI;

typedef struct _dispidtableentry
{
  DWORD  hash;
  DISPID dispid;
  LPWSTR name;
}
DISPIDTABLEENTRY, *PDISPIDTABLEENTRY;

typedef enum _tagType
{
  TYPE_LPWSTR=0,
  TYPE_LPLPWSTR,
  TYPE_LPSTR,
  TYPE_LPLPSTR,
  TYPE_DWORD,
  TYPE_LPDWORD
}
TYPE, *PTYPE;

typedef enum _tagPointer
{
  NULL_PTR=0,
  BAD_PTR,
  FREE_PTR,
  UNINIT_PTR,
  NEGONE_PTR
}
POINTER, *PPOINTER;

typedef enum _tagMemsetFlag
{
  INIT_NULL=0,
  INIT_SMILEY,
  INIT_HEXFF,
  INIT_GARBAGE
}
MEMSETFLAG, *PMEMSETFLAG;

#endif /* __RESOURCES_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\whttptst\inc\utils.h ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 1999  Microsoft Corporation

Module Name:

    utils.h

Abstract:

    Utility functions.
    
Author:

    Paul M Midgen (pmidge) 12-January-2001


Revision History:

    12-January-2001 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#ifndef _UTILS_H_
#define _UTILS_H_

#define CALLBACK_HANDLE_MAP   0x00
#define CALLBACK_HANDLE_UNMAP 0x01
#define CALLBACK_HANDLE_GET   0x02

// exception handling
int exception_filter(PEXCEPTION_POINTERS pep);

// file retrieval
HANDLE  __OpenFile(LPCWSTR path, DWORD mode, BOOL* bReadOnly);

// general utility
HRESULT ManageCallbackForHandle(HINTERNET hInet, IDispatch** ppCallback, DWORD dwAction);
HRESULT GetTypeInfoFromName(LPCOLESTR name, ITypeLib* ptl, ITypeInfo** ppti);
DISPID  GetDispidFromName(PDISPIDTABLEENTRY pdt, DWORD cEntries, LPWSTR name);
HRESULT HandleDispatchError(LPWSTR id, EXCEPINFO* pei, HRESULT hr);
void    AddRichErrorInfo(EXCEPINFO* pei, LPWSTR source, LPWSTR description, HRESULT error);
DWORD   GetHash(LPWSTR name);
DWORD   GetHash(LPSTR name);
HRESULT ValidateDispatchArgs(REFIID riid, DISPPARAMS* pdp, VARIANT* pvr, UINT* pae);
HRESULT ValidateInvokeFlags(WORD flags, WORD accesstype, BOOL bNotMethod);
HRESULT ValidateArgCount(DISPPARAMS* pdp, DWORD needed, BOOL bHasOptionalArgs, DWORD optional);

// type manipulation
HRESULT   ProcessWideStringParam(LPWSTR name, VARIANT* pvar, LPWSTR* ppwsz);
HRESULT   ProcessWideMultiStringParam(LPWSTR name, VARIANT* pvar, LPWSTR** pppwsz);
HRESULT   ProcessBufferParam(LPWSTR name, VARIANT* pvar, LPVOID* ppv, LPBOOL pbDidAlloc);
HRESULT   InvalidatePointer(POINTER pointer, void** ppv);
DWORD_PTR GetBadPointer(void);
DWORD_PTR GetFreedPointer(void);
void      MemsetByFlag(LPVOID pv, DWORD size, MEMSETFLAG mf);

// string handling
char*  __strndup(const char* src, int len);
char*  __strdup(const char* src);
WCHAR* __wstrndup(const WCHAR* src, int len);
WCHAR* __wstrdup(const WCHAR* src);
CHAR*  __widetoansi(const WCHAR* pwsz);
WCHAR* __ansitowide(const char* psz);
BOOL   __isempty(VARIANT var);
BSTR   __ansitobstr(LPCSTR src);
BSTR   __widetobstr(LPCWSTR wsrc);
char*  __unescape(char* str);

#endif /* _UTILS_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\whttptst\inc\dispids.h ===
#ifndef __DISPIDS_H__
#define __DISPIDS_H__

#define DISPID_WINHTTPTEST_BASE                    0x00000100
#define DISPID_WINHTTPTEST_HELPER_BASE             0x00000200
#define DISPID_WIN32ERRORCODE_BASE                 0x00000300
#define DISPID_BUFFEROBJECT_BASE                   0x00000400
#define DISPID_URLCOMPONENTS_BASE                  0x00000500
#define DISPID_SYSTEMTIME_BASE                     0x00000600

#define DISPID_WINHTTPTEST_OPEN                    (DISPID_WINHTTPTEST_BASE)
#define DISPID_WINHTTPTEST_CONNECT                 (DISPID_WINHTTPTEST_BASE + 1)
#define DISPID_WINHTTPTEST_OPENREQUEST             (DISPID_WINHTTPTEST_BASE + 2)
#define DISPID_WINHTTPTEST_SENDREQUEST             (DISPID_WINHTTPTEST_BASE + 3)
#define DISPID_WINHTTPTEST_RECEIVERESPONSE         (DISPID_WINHTTPTEST_BASE + 4)
#define DISPID_WINHTTPTEST_CLOSEHANDLE             (DISPID_WINHTTPTEST_BASE + 5)
#define DISPID_WINHTTPTEST_READDATA                (DISPID_WINHTTPTEST_BASE + 6)
#define DISPID_WINHTTPTEST_WRITEDATA               (DISPID_WINHTTPTEST_BASE + 7)
#define DISPID_WINHTTPTEST_QUERYDATAAVAILABLE      (DISPID_WINHTTPTEST_BASE + 8)
#define DISPID_WINHTTPTEST_QUERYOPTION             (DISPID_WINHTTPTEST_BASE + 9)
#define DISPID_WINHTTPTEST_SETOPTION               (DISPID_WINHTTPTEST_BASE + 10)
#define DISPID_WINHTTPTEST_SETTIMEOUTS             (DISPID_WINHTTPTEST_BASE + 11)
#define DISPID_WINHTTPTEST_ADDREQUESTHEADERS       (DISPID_WINHTTPTEST_BASE + 12)
#define DISPID_WINHTTPTEST_SETCREDENTIALS          (DISPID_WINHTTPTEST_BASE + 13)
#define DISPID_WINHTTPTEST_QUERYAUTHSCHEMES        (DISPID_WINHTTPTEST_BASE + 14)
#define DISPID_WINHTTPTEST_QUERYHEADERS            (DISPID_WINHTTPTEST_BASE + 15)
#define DISPID_WINHTTPTEST_TIMEFROMSYSTEMTIME      (DISPID_WINHTTPTEST_BASE + 16)
#define DISPID_WINHTTPTEST_TIMETOSYSTEMTIME        (DISPID_WINHTTPTEST_BASE + 17)
#define DISPID_WINHTTPTEST_CRACKURL                (DISPID_WINHTTPTEST_BASE + 18)
#define DISPID_WINHTTPTEST_CREATEURL               (DISPID_WINHTTPTEST_BASE + 19)
#define DISPID_WINHTTPTEST_SETSTATUSCALLBACK       (DISPID_WINHTTPTEST_BASE + 20)

#define DISPID_WINHTTPTEST_HELPER_GETBUFFEROBJECT  (DISPID_WINHTTPTEST_HELPER_BASE)
#define DISPID_WINHTTPTEST_HELPER_GETURLCOMPONENTS (DISPID_WINHTTPTEST_HELPER_BASE + 1)
#define DISPID_WINHTTPTEST_HELPER_GETSYSTEMTIME    (DISPID_WINHTTPTEST_HELPER_BASE + 2)
#define DISPID_WINHTTPTEST_HELPER_GETLASTERROR     (DISPID_WINHTTPTEST_HELPER_BASE + 3)

#define DISPID_WIN32ERRORCODE_ERRORCODE            (DISPID_WIN32ERRORCODE_BASE + 1)
#define DISPID_WIN32ERRORCODE_ERRORSTRING          (DISPID_WIN32ERRORCODE_BASE + 2)
#define DISPID_WIN32ERRORCODE_ISEXCEPTION          (DISPID_WIN32ERRORCODE_BASE + 3)

#define DISPID_BUFFEROBJECT_SIZE                   (DISPID_BUFFEROBJECT_BASE)
#define DISPID_BUFFEROBJECT_TYPE                   (DISPID_BUFFEROBJECT_BASE + 1)
#define DISPID_BUFFEROBJECT_BYTESTRANSFERRED       (DISPID_BUFFEROBJECT_BASE + 2)
#define DISPID_BUFFEROBJECT_FLAGS                  (DISPID_BUFFEROBJECT_BASE + 3)

#define DISPID_URLCOMPONENTS_STRUCTSIZE            (DISPID_URLCOMPONENTS_BASE)
#define DISPID_URLCOMPONENTS_SCHEME                (DISPID_URLCOMPONENTS_BASE + 1)
#define DISPID_URLCOMPONENTS_SCHEMELENGTH          (DISPID_URLCOMPONENTS_BASE + 2)
#define DISPID_URLCOMPONENTS_SCHEMEID              (DISPID_URLCOMPONENTS_BASE + 3)
#define DISPID_URLCOMPONENTS_HOSTNAME              (DISPID_URLCOMPONENTS_BASE + 4)
#define DISPID_URLCOMPONENTS_HOSTNAMELENGTH        (DISPID_URLCOMPONENTS_BASE + 5)
#define DISPID_URLCOMPONENTS_PORT                  (DISPID_URLCOMPONENTS_BASE + 6)
#define DISPID_URLCOMPONENTS_USERNAME              (DISPID_URLCOMPONENTS_BASE + 7)
#define DISPID_URLCOMPONENTS_USERNAMELENGTH        (DISPID_URLCOMPONENTS_BASE + 8)
#define DISPID_URLCOMPONENTS_PASSWORD              (DISPID_URLCOMPONENTS_BASE + 9)
#define DISPID_URLCOMPONENTS_PASSWORDLENGTH        (DISPID_URLCOMPONENTS_BASE + 10)
#define DISPID_URLCOMPONENTS_URLPATH               (DISPID_URLCOMPONENTS_BASE + 11)
#define DISPID_URLCOMPONENTS_URLPATHLENGTH         (DISPID_URLCOMPONENTS_BASE + 12)
#define DISPID_URLCOMPONENTS_EXTRAINFO             (DISPID_URLCOMPONENTS_BASE + 13)
#define DISPID_URLCOMPONENTS_EXTRAINFOLENGTH       (DISPID_URLCOMPONENTS_BASE + 14)

#define DISPID_SYSTEMTIME_YEAR                     (DISPID_SYSTEMTIME_BASE)
#define DISPID_SYSTEMTIME_MONTH                    (DISPID_SYSTEMTIME_BASE + 1)
#define DISPID_SYSTEMTIME_DAYOFWEEK                (DISPID_SYSTEMTIME_BASE + 2)
#define DISPID_SYSTEMTIME_DAY                      (DISPID_SYSTEMTIME_BASE + 3)
#define DISPID_SYSTEMTIME_HOUR                     (DISPID_SYSTEMTIME_BASE + 4)
#define DISPID_SYSTEMTIME_MINUTE                   (DISPID_SYSTEMTIME_BASE + 5)
#define DISPID_SYSTEMTIME_SECOND                   (DISPID_SYSTEMTIME_BASE + 6)
#define DISPID_SYSTEMTIME_MSEC                     (DISPID_SYSTEMTIME_BASE + 7)

#endif /* __DISPIDS_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\whttptst\src\urlcmp\dispatch.cxx ===
#include "common.h"


//
// WARNING: do not modify these values. use disphash.exe to generate
//          new values.
//
DISPIDTABLEENTRY g_WHTUrlComponentsDisptable[] =
{
  0x0023e96f,   DISPID_URLCOMPONENTS_STRUCTSIZE,       L"structsize",
  0x00021d6b,   DISPID_URLCOMPONENTS_SCHEME,           L"scheme",
  0x00875a9b,   DISPID_URLCOMPONENTS_SCHEMELENGTH,     L"schemelength",
  0x000879f7,   DISPID_URLCOMPONENTS_SCHEMEID,         L"schemeid",
  0x000876d5,   DISPID_URLCOMPONENTS_HOSTNAME,         L"hostname",
  0x021c16c1,   DISPID_URLCOMPONENTS_HOSTNAMELENGTH,   L"hostnamelength",
  0x000087f5,   DISPID_URLCOMPONENTS_PORT,             L"port",
  0x0008e77b,   DISPID_URLCOMPONENTS_USERNAME,         L"username",
  0x023836ed,   DISPID_URLCOMPONENTS_USERNAMELENGTH,   L"usernamelength",
  0x00088a79,   DISPID_URLCOMPONENTS_PASSWORD,         L"password",
  0x0220f469,   DISPID_URLCOMPONENTS_PASSWORDLENGTH,   L"passwordlength",
  0x000477be,   DISPID_URLCOMPONENTS_URLPATH,          L"urlpath",
  0x011d165c,   DISPID_URLCOMPONENTS_URLPATHLENGTH,    L"urlpathlength",
  0x0010fe0f,   DISPID_URLCOMPONENTS_EXTRAINFO,        L"extrainfo",
  0x043cf541,   DISPID_URLCOMPONENTS_EXTRAINFOLENGTH,  L"extrainfolength"
};

DWORD g_cWHTUrlComponentsDisptable = (sizeof(g_WHTUrlComponentsDisptable) / sizeof(DISPIDTABLEENTRY));


//-----------------------------------------------------------------------------
// IDispatch
//-----------------------------------------------------------------------------
HRESULT
__stdcall
WHTUrlComponents::GetTypeInfoCount(UINT* pctinfo)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "WHTUrlComponents::GetTypeInfoCount",
    "this=%#x; pctinfo=%#x",
    this,
    pctinfo
    ));

  HRESULT hr = S_OK;

    if( !pctinfo )
    {
      hr = E_POINTER;
    }
    else
    {
      *pctinfo = 1;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WHTUrlComponents::GetTypeInfo(UINT index, LCID lcid, ITypeInfo** ppti)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "WHTUrlComponents::GetTypeInfo",
    "this=%#x; index=%#x; lcid=%#x; ppti=%#x",
    this,
    index,
    lcid,
    ppti
    ));

  HRESULT hr   = S_OK;

  if( !ppti )
  {
    hr = E_POINTER;
  }
  else
  {
    if( index != 0 )
    {
      hr    = DISP_E_BADINDEX;
      *ppti = NULL;
    }
    else
    {
      hr = GetClassInfo(ppti);
    }
  }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WHTUrlComponents::GetIDsOfNames(REFIID riid, LPOLESTR* arNames, UINT cNames, LCID lcid, DISPID* arDispId)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "WHTUrlComponents::GetIDsOfNames",
    "this=%#x; riid=%s; arNames=%#x; cNames=%d; lcid=%#x; arDispId=%#x",
    this,
    MapIIDToString(riid),
    arNames,
    cNames,
    lcid,
    arDispId
    ));

  HRESULT hr = S_OK;
  UINT    n  = 0L;

  if( !IsEqualIID(riid, IID_NULL) )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  while( n < cNames )
  {
    arDispId[n] = GetDispidFromName(g_WHTUrlComponentsDisptable, g_cWHTUrlComponentsDisptable, arNames[n]);
    ++n;
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WHTUrlComponents::Invoke(DISPID dispid, REFIID riid, LCID lcid, WORD flags, DISPPARAMS* pdp, VARIANT* pvr, EXCEPINFO* pei, UINT* pae)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "WHTUrlComponents::Invoke",
    "this=%#x; dispid=%s; riid=%s; lcid=%#x; flags=%#x; pdp=%#x; pvr=%#x; pei=%#x; pae=%#x",
    this,
    MapDispidToString(dispid),
    MapIIDToString(riid),
    lcid,
    flags,
    pdp, pvr,
    pei, pae
    ));

  HRESULT hr = S_OK;

  hr = ValidateDispatchArgs(riid, pdp, pvr, pae);

    if( FAILED(hr) )
      goto quit;

  switch( dispid )
  {
    case DISPID_VALUE :
    default : hr = DISP_E_MEMBERNOTFOUND;
  }

quit:

  if( FAILED(hr) )
  {
    hr = HandleDispatchError(L"WHTUrlComponents", pei, hr);
  }

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\whttptst\src\urlcmp\urlcmp.cxx ===
#include "common.h"

extern HINSTANCE g_hGlobalDllInstance;
LPCWSTR          g_wszWHTUrlComponentsObjectName = L"WHTUrlComponents";

//-----------------------------------------------------------------------------
// WHTUrlComponents methods
//-----------------------------------------------------------------------------
WHTUrlComponents::WHTUrlComponents():
  m_cRefs(0),
  m_pti(NULL)
{
  DEBUG_TRACE(WHTERROR, ("WHTUrlComponents [%#x] created", this));
}


WHTUrlComponents::~WHTUrlComponents()
{
  SAFERELEASE(m_pti);
  DEBUG_TRACE(WHTERROR, ("WHTUrlComponents [%#x] deleted", this));
}


HRESULT
WHTUrlComponents::Create(MEMSETFLAG mf, IWHTUrlComponents** ppwuc)
{
  DEBUG_ENTER((
    DBG_INITIALIZE,
    rt_hresult,
    "WHTUrlComponents::Create",
    "mf=%s; ppwuc=%#x",
    MapMemsetFlagToString(mf),
    ppwuc
    ));

  HRESULT    hr     = S_OK;
  PWHTURLCMP pwhtuc = NULL;

  if( ppwuc )
  {
    pwhtuc = new WHTURLCMP;

    if( pwhtuc )
    {
      hr = pwhtuc->_Initialize(mf);

      if( SUCCEEDED(hr) )
      {
        hr = pwhtuc->QueryInterface(IID_IWHTUrlComponents, (void**) ppwuc);
      }
    }
    else
    {
      hr = E_OUTOFMEMORY;
    }
  }
  else
  {
    hr = E_POINTER;
  }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
WHTUrlComponents::_Initialize(MEMSETFLAG mf)
{
  DEBUG_ENTER((
    DBG_INITIALIZE,
    rt_hresult,
    "WHTUrlComponents::_Initialize",
    "this=%#x; mf=%s",
    this,
    MapMemsetFlagToString(mf)
    ));

  HRESULT   hr  = S_OK;
  WCHAR*    buf = NULL;
  ITypeLib* ptl = NULL;

  buf = new WCHAR[MAX_PATH];

    if( buf )
    {
      if( GetModuleFileName(g_hGlobalDllInstance, buf, MAX_PATH) )
      {
        hr = LoadTypeLib(buf, &ptl);

        if( SUCCEEDED(hr) )
        {
          hr = GetTypeInfoFromName(g_wszWHTUrlComponentsObjectName, ptl, &m_pti);

          if( SUCCEEDED(hr) )
          {
            MemsetByFlag(
              (void*) &m_uc,
              sizeof(URL_COMPONENTSW),
              mf
              );
            
            m_uc.dwStructSize = sizeof(URL_COMPONENTSW);
          }
        }
      }
      else
      {
        hr = E_FAIL;
      }
    }
    else
    {
      hr = E_OUTOFMEMORY;
    }

  SAFERELEASE(ptl);
  SAFEDELETEBUF(buf);

  DEBUG_LEAVE(hr);
  return hr;
}


//-----------------------------------------------------------------------------
// IUnknown methods
//-----------------------------------------------------------------------------
HRESULT
__stdcall
WHTUrlComponents::QueryInterface(REFIID riid, void** ppv)
{
  DEBUG_ENTER((
    DBG_REFCOUNT,
    rt_hresult,
    "WHTUrlComponents::QueryInterface",
    "this=%#x; riid=%s; ppv=%#x",
    this,
    MapIIDToString(riid),
    ppv
    ));

  HRESULT hr = S_OK;

    if( ppv )
    {
      if(
        IsEqualIID(riid, IID_IUnknown)           ||
        IsEqualIID(riid, IID_IDispatch)          ||
        IsEqualIID(riid, IID_IWHTUrlComponents)
        )
      {
        *ppv = static_cast<IWHTUrlComponents*>(this);
      }
      else if( IsEqualIID(riid, IID_IProvideClassInfo) )
      {
        *ppv = static_cast<IProvideClassInfo*>(this);
      }
      else
      {
        *ppv = NULL;
        hr   = E_NOINTERFACE;
      }
    }
    else
    {
      hr = E_POINTER;
    }

    if( SUCCEEDED(hr) )
    {
      DEBUG_TRACE(REFCOUNT, ("returning %s pointer", MapIIDToString(riid)));
      reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    }

  DEBUG_LEAVE(hr);
  return hr;
}


ULONG
__stdcall
WHTUrlComponents::AddRef(void)
{
  InterlockedIncrement(&m_cRefs);
  DEBUG_ADDREF("WHTUrlComponents", m_cRefs);
  return m_cRefs;
}


ULONG
__stdcall
WHTUrlComponents::Release(void)
{
  InterlockedDecrement(&m_cRefs);
  DEBUG_RELEASE("WHTUrlComponents", m_cRefs);

  if( m_cRefs == 0 )
  {
    DEBUG_FINALRELEASE("WHTUrlComponents");
    delete this;
    return 0;
  }

  return m_cRefs;
}


//-----------------------------------------------------------------------------
// IProvideClassInfo methods
//-----------------------------------------------------------------------------
HRESULT
__stdcall
WHTUrlComponents::GetClassInfo(ITypeInfo** ppti)
{
  DEBUG_ENTER((
    DBG_WHTERROR,
    rt_hresult,
    "WHTUrlComponents::GetClassInfo",
    "this=%#x; ppti=%#x",
    this,
    ppti
    ));

  HRESULT hr = S_OK;

    if( ppti )
    {
      m_pti->AddRef();
      *ppti = m_pti;
    }
    else
    {
      hr = E_POINTER;
    }

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\whttptst\src\urlcmp\methods.cxx ===
#include "common.h"

//-----------------------------------------------------------------------------
// IWHTUrlComponents methods
//-----------------------------------------------------------------------------
HRESULT
__stdcall
WHTUrlComponents::get_StructSize(VARIANT *Value)
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WHTUrlComponents::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}

        
HRESULT
__stdcall
WHTUrlComponents::put_StructSize(VARIANT Value)
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WHTUrlComponents::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WHTUrlComponents::get_Scheme(VARIANT *Value)
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WHTUrlComponents::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}
        

HRESULT
__stdcall
WHTUrlComponents::put_Scheme(VARIANT Value)
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WHTUrlComponents::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WHTUrlComponents::get_SchemeLength(VARIANT *Length)
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WHTUrlComponents::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}

 
HRESULT
__stdcall
WHTUrlComponents::put_SchemeLength(VARIANT Length)
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WHTUrlComponents::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WHTUrlComponents::get_SchemeId(VARIANT *Value)
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WHTUrlComponents::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WHTUrlComponents::put_SchemeId(VARIANT Value)
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WHTUrlComponents::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}

        
HRESULT
__stdcall
WHTUrlComponents::get_HostName(VARIANT *Value)
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WHTUrlComponents::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WHTUrlComponents::put_HostName(VARIANT Value)
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WHTUrlComponents::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WHTUrlComponents::get_HostNameLength(VARIANT *Length)
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WHTUrlComponents::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WHTUrlComponents::put_HostNameLength(VARIANT Length)
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WHTUrlComponents::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WHTUrlComponents::get_Port(VARIANT *Value)
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WHTUrlComponents::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}

        
HRESULT
__stdcall
WHTUrlComponents::put_Port(VARIANT Value)
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WHTUrlComponents::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WHTUrlComponents::get_UserName(VARIANT *Value)
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WHTUrlComponents::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WHTUrlComponents::put_UserName(VARIANT Value)
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WHTUrlComponents::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WHTUrlComponents::get_UserNameLength(VARIANT *Value)
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WHTUrlComponents::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WHTUrlComponents::put_UserNameLength(VARIANT Value)
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WHTUrlComponents::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WHTUrlComponents::get_Password(VARIANT *Value)
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WHTUrlComponents::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WHTUrlComponents::put_Password(VARIANT Value)
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WHTUrlComponents::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WHTUrlComponents::get_PasswordLength(VARIANT *Length)
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WHTUrlComponents::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WHTUrlComponents::put_PasswordLength(VARIANT Length)
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WHTUrlComponents::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WHTUrlComponents::get_UrlPath(VARIANT *Value)
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WHTUrlComponents::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WHTUrlComponents::put_UrlPath(VARIANT Value)
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WHTUrlComponents::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WHTUrlComponents::get_UrlPathLength(VARIANT *Length)
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WHTUrlComponents::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WHTUrlComponents::put_UrlPathLength(VARIANT Length)
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WHTUrlComponents::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WHTUrlComponents::get_ExtraInfo(VARIANT *Value)
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WHTUrlComponents::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WHTUrlComponents::put_ExtraInfo(VARIANT Value)
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WHTUrlComponents::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WHTUrlComponents::get_ExtraInfoLength(VARIANT *Length)
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WHTUrlComponents::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WHTUrlComponents::put_ExtraInfoLength(VARIANT Length)
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WHTUrlComponents::",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\whttptst\src\utils\mem.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 1999  Microsoft Corporation

Module Name:

    mem.cpp

Abstract:

    Replacements for operators new & delete.

    Routines implemented in this module:

      _InitMem()
      operator new
      operator delete

    These routines delegate to HeapAlloc/HeapFree, and party on the process
    heap. This helps overcome the problem of using general-purpose allocation
    functions as well as using new/delete to deal with C++ objects.
    
    Rudimentary allocation tracking is enabled in debug builds that
    allows us to see (via the last line in the log file) how much memory
    went unallocated at process termination. This doesn't take into account
    kernel, gdi, or user objects.

    Memory deallocation routines are "safe" in the sense that you can pass
    NULL pointers (invalid pointers aren't detected).

Author:

    Paul M Midgen (pmidge) 01-June-2000


Revision History:

    01-June-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

HANDLE g_hProcessHeap = NULL;

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  _InitMem()

  WHAT    : Sets the global process heap handle call this before any
            allocations occur or you'll fault. Pretty simple.

  ARGS    : none.
  RETURNS : nothing

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void _InitMem(void)
{
  g_hProcessHeap = GetProcessHeap();
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  operator new

  WHAT    : Replaces the global operator new. Same usage semantics. Allocates
            objects, makes implicit calls to their constructors.

  ARGS    : size - size in bytes of the object to be allocated. the compiler
                   pushes this argument on the stack automagically.

  RETURNS : void pointer to allocated memory.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void* __cdecl operator new(size_t size)
{
  void* pv = NULL;

  if( !g_hProcessHeap )
    _InitMem();
  
    pv = HeapAlloc(g_hProcessHeap, HEAP_ZERO_MEMORY, size);
    DEBUG_ALLOC(pv);

  return pv;
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  operator delete

  WHAT    : Replaces the global operator delete. Same usage semantics. Deletes
            objects, makes implicit call to their destructors.

  ARGS    : pv - pointer to object to be freed. same compiler magic as with
                 operator new.

  RETURNS : nothing.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void __cdecl operator delete(void* pv)
{
  if( !g_hProcessHeap )
    _InitMem();

  if( pv )
  {
    DEBUG_FREE(pv);
    HeapFree(g_hProcessHeap, 0, pv);
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\whttptst\src\utils\type.cxx ===
#include "common.h"

// private
LPWSTR* ConvertDelimitedStringToArray(LPWSTR pwsz, LPWSTR delim);

//-----------------------------------------------------------------------------
// Type manipulation routines
//-----------------------------------------------------------------------------
HRESULT
ProcessWideStringParam(LPWSTR name, VARIANT* pvar, LPWSTR* ppwsz)
{
  DEBUG_ENTER((
    DBG_TYPE,
    rt_hresult,
    "ProcessWideStringParam",
    "name=%S; pvar=%#x; ppwsz=%#x",
    name,
    pvar,
    ppwsz
    ));
  
  HRESULT hr   = S_OK;
  LPWSTR  pwsz = NULL;

  if( !ppwsz )
  {
    hr = E_POINTER;
    goto quit;
  }

  DEBUG_TRACE(
    TYPE,
    ("variant type is %s", MapVariantTypeToString(pvar))
    );

  switch( V_VT(pvar) )
  {
    case VT_BSTR :
      {
        *ppwsz = V_BSTR(pvar);

        DEBUG_DATA_DUMP(TYPE, ("wide string", (LPBYTE) *ppwsz, (sizeof(WCHAR)*wcslen(*ppwsz)) ));

      }
      break;

    case VT_I4 :
      {
        hr = InvalidatePointer((POINTER) V_UI4(pvar), (void**) ppwsz);
      }
      break;

    default : hr = E_INVALIDARG;
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}

HRESULT
ProcessWideMultiStringParam(LPWSTR name, VARIANT* pvar, LPWSTR** pppwsz)
{
  DEBUG_ENTER((
    DBG_TYPE,
    rt_hresult,
    "ProcessWideMultiStringParam",
    "name=%S; pvar=%#x; pppwsz=%#x",
    name,
    pvar,
    pppwsz
    ));

  HRESULT hr = S_OK;

  DEBUG_TRACE(
    TYPE,
    ("variant type is %s", MapVariantTypeToString(pvar))
    );

  switch( V_VT(pvar) )
  {
    case VT_BSTR :
      {
        *pppwsz = ConvertDelimitedStringToArray(V_BSTR(pvar), L";");
      }
      break;

    case VT_I4 :
      {
        LPVOID pv = NULL;

        hr      = InvalidatePointer((POINTER) V_UI4(pvar), (void**) &pv);
        *pppwsz = (LPWSTR*) pv;
      }
      break;

    default : hr = E_INVALIDARG;
  }

  DEBUG_LEAVE(hr);
  return hr;
}

HRESULT
ProcessBufferParam(LPWSTR name, VARIANT* pvar, LPVOID* ppv, LPBOOL pbDidAlloc)
{
  DEBUG_ENTER((
    DBG_TYPE,
    rt_hresult,
    "ProcessBufferParam",
    "name=%S; pvar=%#x; ppv=%#x; pbDidAlloc=%#x",
    name,
    pvar,
    ppv,
    pbDidAlloc
    ));

  HRESULT hr = S_OK;

  DEBUG_TRACE(
    TYPE,
    ("variant type is %s", MapVariantTypeToString(pvar))
    );

  switch( V_VT(pvar) )
  {
    case VT_BSTR :
      {
        *ppv        = V_BSTR(pvar);
        *pbDidAlloc = FALSE;
      }
      break;

    case VT_DISPATCH :
      {
        //
        // TODO: do in conjunction with the BufferObject work.
        //

        *ppv        = NULL;
        *pbDidAlloc = FALSE;
      }
      break;

    case VT_I4 :
      {
        hr          = InvalidatePointer((POINTER) V_UI4(pvar), (void**) ppv);
        *pbDidAlloc = FALSE;
      }
      break;

    default : hr = E_INVALIDARG;
  }

  DEBUG_LEAVE(hr);
  return hr;
}

LPWSTR*
ConvertDelimitedStringToArray(LPWSTR pwsz, LPWSTR delim)
{
  LPWSTR* arTokens = NULL;
  LPWSTR  wszTmp   = pwsz;
  DWORD   tokens   = 0L;

  if( pwsz )
  {
    while( 1 )
    {
      if( *wszTmp == *delim )
      {
        ++tokens;
      }
      else if( *wszTmp == NULL )
      {
        tokens += 2; // account for the single-token case and add a slot for NULL delimiter
        break;
      }
    
      ++wszTmp;
    }

    arTokens = new LPWSTR[tokens];

    if( arTokens )
    {
      --tokens; // correct for the null delimiter
      wszTmp = wcstok(pwsz, delim);

      for(DWORD n=0; n<tokens; n++)
      {
        DEBUG_DATA_DUMP(TYPE, ("delimited-string token", (LPBYTE) wszTmp, (sizeof(WCHAR)*wcslen(wszTmp)) ));

        arTokens[n] = wszTmp;
        wszTmp      = wcstok(NULL, delim);
      }
    }
  }

  return arTokens;
}

// disable warning for use of uninitialized variable
#pragma warning( disable : 4700 )

HRESULT
InvalidatePointer(POINTER pointer, void** ppv)
{
  DEBUG_ENTER((
    DBG_TYPE,
    rt_hresult,
    "InvalidatePointer",
    "pointer=%s; ppv=%#x",
    MapPointerTypeToString(pointer),
    ppv
    ));
  
  HRESULT hr = S_OK;
  LPVOID  pv;

  if( !ppv )
  {
    hr = E_POINTER;
    goto quit;
  }

  *ppv = NULL;

  switch( pointer )
  {
    case NULL_PTR   : break;
    case BAD_PTR    : *ppv = (LPVOID) GetBadPointer();   break;
    case FREE_PTR   : *ppv = (LPVOID) GetFreedPointer(); break;
    case UNINIT_PTR : *ppv = pv;                         break;
    case NEGONE_PTR : *ppv = (LPVOID) 0xFFFFFFFF;        break;

    default : hr = E_INVALIDARG;
  }

  DEBUG_TRACE(TYPE, ("returning pointer value 0x%0.8x", *ppv));

quit:

  DEBUG_LEAVE(hr);
  return hr;
}

#pragma warning( default : 4700 )

DWORD_PTR
GetBadPointer(void)
{
  SYSTEM_INFO si;

  GetSystemInfo(&si);
  return ((DWORD_PTR) si.lpMaximumApplicationAddress)+1;
}

DWORD_PTR
GetFreedPointer(void)
{
  LPBYTE pb = NULL;

  pb = new BYTE;
  delete pb;
  return (DWORD_PTR) pb;
}

void
MemsetByFlag(LPVOID pv, DWORD size, MEMSETFLAG mf)
{
  int ch = 0x00;

  switch( mf )
  {
    case INIT_SMILEY  : ch = 0x02; break;
    case INIT_HEXFF   : ch = 0xFF; break;
    case INIT_GARBAGE : return;

    case INIT_NULL    :
    default           : ch = 0x00;
  }

  memset(pv, ch, size);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\whttptst\src\utils\debug.cxx ===
#include "common.h"


LPSTR
MapDllReasonToString(int reason)
{
  switch(reason)
  {
    CASE_OF(DLL_PROCESS_ATTACH);
    CASE_OF(DLL_PROCESS_DETACH);
    CASE_OF(DLL_THREAD_ATTACH);
    CASE_OF(DLL_THREAD_DETACH);
  
    default : return "?";
  }
}

LPSTR
MapIIDToString(REFIID riid)
{
  CASE_IID(riid, IID_NULL);
  CASE_IID(riid, IID_IUnknown);
  CASE_IID(riid, IID_IClassFactory);
  CASE_IID(riid, IID_IDispatch);
  CASE_IID(riid, IID_IConnectionPointContainer);
  CASE_IID(riid, IID_IConnectionPoint);
  CASE_IID(riid, IID_IMarshal);
  CASE_IID(riid, IID_IStdMarshalInfo);
  CASE_IID(riid, IID_IExternalConnection);
  CASE_IID(riid, IID_IObjectWithSite);
  CASE_IID(riid, IID_IProvideClassInfo);
  CASE_IID(riid, IID_IServiceProvider);

  CASE_IID(riid, IID_IWinHttpTest);
  CASE_IID(riid, IID_IWHTUrlComponents);
  CASE_IID(riid, IID_IWHTWin32ErrorCode);

  return "?";
}

LPSTR
MapHResultToString(HRESULT hr)
{
  switch(hr)
  {
    CASE_OF(S_OK);
    CASE_OF(E_NOINTERFACE);
    CASE_OF(E_POINTER);
    CASE_OF(E_UNEXPECTED);
    CASE_OF(E_INVALIDARG);
    CASE_OF(E_OUTOFMEMORY);
    CASE_OF(E_FAIL);
    CASE_OF(E_NOTIMPL);
    CASE_OF(E_PENDING);
    CASE_OF(E_ACCESSDENIED);
    CASE_OF(CLASS_E_NOAGGREGATION);
    CASE_OF(TYPE_E_IOERROR);
    CASE_OF(TYPE_E_REGISTRYACCESS);
    CASE_OF(TYPE_E_INVALIDSTATE);
    CASE_OF(TYPE_E_BUFFERTOOSMALL);
    CASE_OF(TYPE_E_FIELDNOTFOUND);
    CASE_OF(TYPE_E_ELEMENTNOTFOUND);
    CASE_OF(TYPE_E_AMBIGUOUSNAME);
    CASE_OF(TYPE_E_UNKNOWNLCID);
    CASE_OF(TYPE_E_BADMODULEKIND);
    CASE_OF(TYPE_E_CANTLOADLIBRARY);
    CASE_OF(TYPE_E_INCONSISTENTPROPFUNCS);
    CASE_OF(CONNECT_E_NOCONNECTION);
    CASE_OF(CONNECT_E_ADVISELIMIT);
    CASE_OF(CO_E_OBJNOTREG);
    CASE_OF(DISP_E_BADPARAMCOUNT);
    CASE_OF(DISP_E_BADVARTYPE);
    CASE_OF(DISP_E_EXCEPTION);
    CASE_OF(DISP_E_MEMBERNOTFOUND);
    CASE_OF(DISP_E_NONAMEDARGS);
    CASE_OF(DISP_E_OVERFLOW);
    CASE_OF(DISP_E_PARAMNOTFOUND);
    CASE_OF(DISP_E_TYPEMISMATCH);
    CASE_OF(DISP_E_UNKNOWNINTERFACE);
    CASE_OF(DISP_E_UNKNOWNLCID);
    CASE_OF(DISP_E_PARAMNOTOPTIONAL);
    CASE_OF(DISP_E_UNKNOWNNAME);

    default : return "?";
  }
}

LPSTR
MapErrorToString(int error)
{
  switch(error)
  {
    CASE_OF(ERROR_WINHTTP_OUT_OF_HANDLES);
    CASE_OF(ERROR_WINHTTP_TIMEOUT);
    CASE_OF(ERROR_WINHTTP_INTERNAL_ERROR);
    CASE_OF(ERROR_WINHTTP_INVALID_URL);
    CASE_OF(ERROR_WINHTTP_UNRECOGNIZED_SCHEME);
    CASE_OF(ERROR_WINHTTP_NAME_NOT_RESOLVED);
    CASE_OF(ERROR_WINHTTP_INVALID_OPTION);
    CASE_OF(ERROR_WINHTTP_OPTION_NOT_SETTABLE);
    CASE_OF(ERROR_WINHTTP_SHUTDOWN);
    CASE_OF(ERROR_WINHTTP_LOGIN_FAILURE);
    CASE_OF(ERROR_WINHTTP_OPERATION_CANCELLED);
    CASE_OF(ERROR_WINHTTP_INCORRECT_HANDLE_TYPE);
    CASE_OF(ERROR_WINHTTP_INCORRECT_HANDLE_STATE);
    CASE_OF(ERROR_WINHTTP_CANNOT_CONNECT);
    CASE_OF(ERROR_WINHTTP_CONNECTION_ERROR);
    CASE_OF(ERROR_WINHTTP_RESEND_REQUEST);
    CASE_OF(ERROR_WINHTTP_CLIENT_AUTH_CERT_NEEDED);
    CASE_OF(ERROR_WINHTTP_HEADER_NOT_FOUND);
    CASE_OF(ERROR_WINHTTP_INVALID_SERVER_RESPONSE);
    CASE_OF(ERROR_WINHTTP_INVALID_QUERY_REQUEST);
    CASE_OF(ERROR_WINHTTP_HEADER_ALREADY_EXISTS);
    CASE_OF(ERROR_WINHTTP_REDIRECT_FAILED);
    CASE_OF(ERROR_WINHTTP_NOT_INITIALIZED);
    CASE_OF(ERROR_WINHTTP_SECURE_FAILURE);

    CASE_OF(ERROR_SUCCESS);
    CASE_OF(ERROR_INVALID_FUNCTION);
    CASE_OF(ERROR_FILE_NOT_FOUND);
    CASE_OF(ERROR_PATH_NOT_FOUND);
    CASE_OF(ERROR_TOO_MANY_OPEN_FILES);
    CASE_OF(ERROR_ACCESS_DENIED);
    CASE_OF(ERROR_INVALID_HANDLE);
    CASE_OF(ERROR_ARENA_TRASHED);
    CASE_OF(ERROR_NOT_ENOUGH_MEMORY);
    CASE_OF(ERROR_INVALID_BLOCK);
    CASE_OF(ERROR_BAD_ENVIRONMENT);
    CASE_OF(ERROR_BAD_FORMAT);
    CASE_OF(ERROR_INVALID_ACCESS);
    CASE_OF(ERROR_INVALID_DATA);
    CASE_OF(ERROR_OUTOFMEMORY);
    CASE_OF(ERROR_INVALID_DRIVE);
    CASE_OF(ERROR_CURRENT_DIRECTORY);
    CASE_OF(ERROR_NOT_SAME_DEVICE);
    CASE_OF(ERROR_NO_MORE_FILES);
    CASE_OF(ERROR_WRITE_PROTECT);
    CASE_OF(ERROR_BAD_UNIT);
    CASE_OF(ERROR_NOT_READY);
    CASE_OF(ERROR_BAD_COMMAND);
    CASE_OF(ERROR_CRC);
    CASE_OF(ERROR_BAD_LENGTH);
    CASE_OF(ERROR_SEEK);
    CASE_OF(ERROR_NOT_DOS_DISK);
    CASE_OF(ERROR_SECTOR_NOT_FOUND);
    CASE_OF(ERROR_OUT_OF_PAPER);
    CASE_OF(ERROR_WRITE_FAULT);
    CASE_OF(ERROR_READ_FAULT);
    CASE_OF(ERROR_GEN_FAILURE);
    CASE_OF(ERROR_SHARING_VIOLATION);
    CASE_OF(ERROR_LOCK_VIOLATION);
    CASE_OF(ERROR_WRONG_DISK);
    CASE_OF(ERROR_SHARING_BUFFER_EXCEEDED);
    CASE_OF(ERROR_HANDLE_EOF);
    CASE_OF(ERROR_HANDLE_DISK_FULL);
    CASE_OF(ERROR_NOT_SUPPORTED);
    CASE_OF(ERROR_REM_NOT_LIST);
    CASE_OF(ERROR_DUP_NAME);
    CASE_OF(ERROR_BAD_NETPATH);
    CASE_OF(ERROR_NETWORK_BUSY);
    CASE_OF(ERROR_DEV_NOT_EXIST);
    CASE_OF(ERROR_TOO_MANY_CMDS);
    CASE_OF(ERROR_ADAP_HDW_ERR);
    CASE_OF(ERROR_BAD_NET_RESP);
    CASE_OF(ERROR_UNEXP_NET_ERR);
    CASE_OF(ERROR_BAD_REM_ADAP);
    CASE_OF(ERROR_PRINTQ_FULL);
    CASE_OF(ERROR_NO_SPOOL_SPACE);
    CASE_OF(ERROR_PRINT_CANCELLED);
    CASE_OF(ERROR_NETNAME_DELETED);
    CASE_OF(ERROR_NETWORK_ACCESS_DENIED);
    CASE_OF(ERROR_BAD_DEV_TYPE);
    CASE_OF(ERROR_BAD_NET_NAME);
    CASE_OF(ERROR_TOO_MANY_NAMES);
    CASE_OF(ERROR_TOO_MANY_SESS);
    CASE_OF(ERROR_SHARING_PAUSED);
    CASE_OF(ERROR_REQ_NOT_ACCEP);
    CASE_OF(ERROR_REDIR_PAUSED);
    CASE_OF(ERROR_FILE_EXISTS);
    CASE_OF(ERROR_CANNOT_MAKE);
    CASE_OF(ERROR_FAIL_I24);
    CASE_OF(ERROR_OUT_OF_STRUCTURES);
    CASE_OF(ERROR_ALREADY_ASSIGNED);
    CASE_OF(ERROR_INVALID_PASSWORD);
    CASE_OF(ERROR_INVALID_PARAMETER);
    CASE_OF(ERROR_NET_WRITE_FAULT);
    CASE_OF(ERROR_NO_PROC_SLOTS);
    CASE_OF(ERROR_TOO_MANY_SEMAPHORES);
    CASE_OF(ERROR_EXCL_SEM_ALREADY_OWNED);
    CASE_OF(ERROR_SEM_IS_SET);
    CASE_OF(ERROR_TOO_MANY_SEM_REQUESTS);
    CASE_OF(ERROR_INVALID_AT_INTERRUPT_TIME);
    CASE_OF(ERROR_SEM_OWNER_DIED);
    CASE_OF(ERROR_SEM_USER_LIMIT);
    CASE_OF(ERROR_DISK_CHANGE);
    CASE_OF(ERROR_DRIVE_LOCKED);
    CASE_OF(ERROR_BROKEN_PIPE);
    CASE_OF(ERROR_OPEN_FAILED);
    CASE_OF(ERROR_BUFFER_OVERFLOW);
    CASE_OF(ERROR_DISK_FULL);
    CASE_OF(ERROR_NO_MORE_SEARCH_HANDLES);
    CASE_OF(ERROR_INVALID_TARGET_HANDLE);
    CASE_OF(ERROR_INVALID_CATEGORY);
    CASE_OF(ERROR_INVALID_VERIFY_SWITCH);
    CASE_OF(ERROR_BAD_DRIVER_LEVEL);
    CASE_OF(ERROR_CALL_NOT_IMPLEMENTED);
    CASE_OF(ERROR_SEM_TIMEOUT);
    CASE_OF(ERROR_INSUFFICIENT_BUFFER);
    CASE_OF(ERROR_INVALID_NAME);
    CASE_OF(ERROR_INVALID_LEVEL);
    CASE_OF(ERROR_NO_VOLUME_LABEL);
    CASE_OF(ERROR_MOD_NOT_FOUND);
    CASE_OF(ERROR_PROC_NOT_FOUND);
    CASE_OF(ERROR_WAIT_NO_CHILDREN);
    CASE_OF(ERROR_CHILD_NOT_COMPLETE);
    CASE_OF(ERROR_DIRECT_ACCESS_HANDLE);
    CASE_OF(ERROR_NEGATIVE_SEEK);
    CASE_OF(ERROR_SEEK_ON_DEVICE);
    CASE_OF(ERROR_DIR_NOT_ROOT);
    CASE_OF(ERROR_DIR_NOT_EMPTY);
    CASE_OF(ERROR_PATH_BUSY);
    CASE_OF(ERROR_SYSTEM_TRACE);
    CASE_OF(ERROR_INVALID_EVENT_COUNT);
    CASE_OF(ERROR_TOO_MANY_MUXWAITERS);
    CASE_OF(ERROR_INVALID_LIST_FORMAT);
    CASE_OF(ERROR_BAD_ARGUMENTS);
    CASE_OF(ERROR_BAD_PATHNAME);
    CASE_OF(ERROR_BUSY);
    CASE_OF(ERROR_CANCEL_VIOLATION);
    CASE_OF(ERROR_ALREADY_EXISTS);
    CASE_OF(ERROR_FILENAME_EXCED_RANGE);
    CASE_OF(ERROR_LOCKED);
    CASE_OF(ERROR_NESTING_NOT_ALLOWED);
    CASE_OF(ERROR_BAD_PIPE);
    CASE_OF(ERROR_PIPE_BUSY);
    CASE_OF(ERROR_NO_DATA);
    CASE_OF(ERROR_PIPE_NOT_CONNECTED);
    CASE_OF(ERROR_MORE_DATA);
    CASE_OF(ERROR_NO_MORE_ITEMS);
    CASE_OF(ERROR_NOT_OWNER);
    CASE_OF(ERROR_PARTIAL_COPY);
    CASE_OF(ERROR_MR_MID_NOT_FOUND);
    CASE_OF(ERROR_INVALID_ADDRESS);
    CASE_OF(ERROR_PIPE_CONNECTED);
    CASE_OF(ERROR_PIPE_LISTENING);
    CASE_OF(ERROR_OPERATION_ABORTED);
    CASE_OF(ERROR_IO_INCOMPLETE);
    CASE_OF(ERROR_IO_PENDING);
    CASE_OF(ERROR_NOACCESS);
    CASE_OF(ERROR_STACK_OVERFLOW);
    CASE_OF(ERROR_INVALID_FLAGS);
    CASE_OF(ERROR_NO_TOKEN);
    CASE_OF(ERROR_BADDB);
    CASE_OF(ERROR_BADKEY);
    CASE_OF(ERROR_CANTOPEN);
    CASE_OF(ERROR_CANTREAD);
    CASE_OF(ERROR_CANTWRITE);
    CASE_OF(ERROR_REGISTRY_RECOVERED);
    CASE_OF(ERROR_REGISTRY_CORRUPT);
    CASE_OF(ERROR_REGISTRY_IO_FAILED);
    CASE_OF(ERROR_NOT_REGISTRY_FILE);
    CASE_OF(ERROR_KEY_DELETED);
    CASE_OF(ERROR_CIRCULAR_DEPENDENCY);
    CASE_OF(ERROR_SERVICE_NOT_ACTIVE);
    CASE_OF(ERROR_DLL_INIT_FAILED);
    CASE_OF(ERROR_CANCELLED);
    CASE_OF(ERROR_BAD_USERNAME);
    CASE_OF(ERROR_LOGON_FAILURE);

    CASE_OF(WAIT_FAILED);
    CASE_OF(WAIT_TIMEOUT);
    CASE_OF(WAIT_IO_COMPLETION);

    CASE_OF(EXCEPTION_ACCESS_VIOLATION);
    CASE_OF(EXCEPTION_DATATYPE_MISALIGNMENT);
    CASE_OF(EXCEPTION_BREAKPOINT);
    CASE_OF(EXCEPTION_SINGLE_STEP);
    CASE_OF(EXCEPTION_ARRAY_BOUNDS_EXCEEDED);
    CASE_OF(EXCEPTION_FLT_DENORMAL_OPERAND);
    CASE_OF(EXCEPTION_FLT_DIVIDE_BY_ZERO);
    CASE_OF(EXCEPTION_FLT_INEXACT_RESULT);
    CASE_OF(EXCEPTION_FLT_INVALID_OPERATION);
    CASE_OF(EXCEPTION_FLT_OVERFLOW);
    CASE_OF(EXCEPTION_FLT_STACK_CHECK);
    CASE_OF(EXCEPTION_FLT_UNDERFLOW);
    CASE_OF(EXCEPTION_INT_DIVIDE_BY_ZERO);
    CASE_OF(EXCEPTION_INT_OVERFLOW);
    CASE_OF(EXCEPTION_PRIV_INSTRUCTION);
    CASE_OF(EXCEPTION_IN_PAGE_ERROR);
    CASE_OF(EXCEPTION_ILLEGAL_INSTRUCTION);
    CASE_OF(EXCEPTION_NONCONTINUABLE_EXCEPTION);
    CASE_OF(EXCEPTION_STACK_OVERFLOW);
    CASE_OF(EXCEPTION_INVALID_DISPOSITION);
    CASE_OF(EXCEPTION_GUARD_PAGE);
    CASE_OF(EXCEPTION_INVALID_HANDLE);

    CASE_OF(RPC_S_INVALID_STRING_BINDING);
    CASE_OF(RPC_S_WRONG_KIND_OF_BINDING);
    CASE_OF(RPC_S_INVALID_BINDING);
    CASE_OF(RPC_S_PROTSEQ_NOT_SUPPORTED);
    CASE_OF(RPC_S_INVALID_RPC_PROTSEQ);
    CASE_OF(RPC_S_INVALID_STRING_UUID);
    CASE_OF(RPC_S_INVALID_ENDPOINT_FORMAT);
    CASE_OF(RPC_S_INVALID_NET_ADDR);
    CASE_OF(RPC_S_NO_ENDPOINT_FOUND);
    CASE_OF(RPC_S_INVALID_TIMEOUT);
    CASE_OF(RPC_S_OBJECT_NOT_FOUND);
    CASE_OF(RPC_S_ALREADY_REGISTERED);
    CASE_OF(RPC_S_TYPE_ALREADY_REGISTERED);
    CASE_OF(RPC_S_ALREADY_LISTENING);
    CASE_OF(RPC_S_NO_PROTSEQS_REGISTERED);
    CASE_OF(RPC_S_NOT_LISTENING);
    CASE_OF(RPC_S_UNKNOWN_MGR_TYPE);
    CASE_OF(RPC_S_UNKNOWN_IF);
    CASE_OF(RPC_S_NO_BINDINGS);
    CASE_OF(RPC_S_NO_PROTSEQS);
    CASE_OF(RPC_S_CANT_CREATE_ENDPOINT);
    CASE_OF(RPC_S_OUT_OF_RESOURCES);
    CASE_OF(RPC_S_SERVER_UNAVAILABLE);
    CASE_OF(RPC_S_SERVER_TOO_BUSY);
    CASE_OF(RPC_S_INVALID_NETWORK_OPTIONS);
    CASE_OF(RPC_S_NO_CALL_ACTIVE);
    CASE_OF(RPC_S_CALL_FAILED);
    CASE_OF(RPC_S_CALL_FAILED_DNE);
    CASE_OF(RPC_S_PROTOCOL_ERROR);
    CASE_OF(RPC_S_UNSUPPORTED_TRANS_SYN);
    CASE_OF(RPC_S_UNSUPPORTED_TYPE);
    CASE_OF(RPC_S_INVALID_TAG);
    CASE_OF(RPC_S_INVALID_BOUND);
    CASE_OF(RPC_S_NO_ENTRY_NAME);
    CASE_OF(RPC_S_INVALID_NAME_SYNTAX);
    CASE_OF(RPC_S_UNSUPPORTED_NAME_SYNTAX);
    CASE_OF(RPC_S_UUID_NO_ADDRESS);
    CASE_OF(RPC_S_DUPLICATE_ENDPOINT);
    CASE_OF(RPC_S_UNKNOWN_AUTHN_TYPE);
    CASE_OF(RPC_S_MAX_CALLS_TOO_SMALL);
    CASE_OF(RPC_S_STRING_TOO_LONG);
    CASE_OF(RPC_S_PROTSEQ_NOT_FOUND);
    CASE_OF(RPC_S_PROCNUM_OUT_OF_RANGE);
    CASE_OF(RPC_S_BINDING_HAS_NO_AUTH);
    CASE_OF(RPC_S_UNKNOWN_AUTHN_SERVICE);
    CASE_OF(RPC_S_UNKNOWN_AUTHN_LEVEL);
    CASE_OF(RPC_S_INVALID_AUTH_IDENTITY);
    CASE_OF(RPC_S_UNKNOWN_AUTHZ_SERVICE);
    CASE_OF(EPT_S_INVALID_ENTRY);
    CASE_OF(EPT_S_CANT_PERFORM_OP);
    CASE_OF(EPT_S_NOT_REGISTERED);
    CASE_OF(RPC_S_NOTHING_TO_EXPORT);
    CASE_OF(RPC_S_INCOMPLETE_NAME);
    CASE_OF(RPC_S_INVALID_VERS_OPTION);
    CASE_OF(RPC_S_NO_MORE_MEMBERS);
    CASE_OF(RPC_S_NOT_ALL_OBJS_UNEXPORTED);
    CASE_OF(RPC_S_INTERFACE_NOT_FOUND);
    CASE_OF(RPC_S_ENTRY_ALREADY_EXISTS);
    CASE_OF(RPC_S_ENTRY_NOT_FOUND);
    CASE_OF(RPC_S_NAME_SERVICE_UNAVAILABLE);
    CASE_OF(RPC_S_INVALID_NAF_ID);
    CASE_OF(RPC_S_CANNOT_SUPPORT);
    CASE_OF(RPC_S_NO_CONTEXT_AVAILABLE);
    CASE_OF(RPC_S_INTERNAL_ERROR);
    CASE_OF(RPC_S_ZERO_DIVIDE);
    CASE_OF(RPC_S_ADDRESS_ERROR);
    CASE_OF(RPC_S_FP_DIV_ZERO);
    CASE_OF(RPC_S_FP_UNDERFLOW);
    CASE_OF(RPC_S_FP_OVERFLOW);
    CASE_OF(RPC_X_NO_MORE_ENTRIES);
    CASE_OF(RPC_X_SS_CHAR_TRANS_OPEN_FAIL);
    CASE_OF(RPC_X_SS_CHAR_TRANS_SHORT_FILE);
    CASE_OF(RPC_X_SS_IN_NULL_CONTEXT);
    CASE_OF(RPC_X_SS_CONTEXT_DAMAGED);
    CASE_OF(RPC_X_SS_HANDLES_MISMATCH);
    CASE_OF(RPC_X_SS_CANNOT_GET_CALL_HANDLE);
    CASE_OF(RPC_X_NULL_REF_POINTER);
    CASE_OF(RPC_X_ENUM_VALUE_OUT_OF_RANGE);
    CASE_OF(RPC_X_BYTE_COUNT_TOO_SMALL);
    CASE_OF(RPC_X_BAD_STUB_DATA);

    CASE_OF(WSAEINTR);
    CASE_OF(WSAEBADF);
    CASE_OF(WSAEACCES);
    CASE_OF(WSAEFAULT);
    CASE_OF(WSAEINVAL);
    CASE_OF(WSAEMFILE);
    CASE_OF(WSAEWOULDBLOCK);
    CASE_OF(WSAEINPROGRESS);
    CASE_OF(WSAEALREADY);
    CASE_OF(WSAENOTSOCK);
    CASE_OF(WSAEDESTADDRREQ);
    CASE_OF(WSAEMSGSIZE);
    CASE_OF(WSAEPROTOTYPE);
    CASE_OF(WSAENOPROTOOPT);
    CASE_OF(WSAEPROTONOSUPPORT);
    CASE_OF(WSAESOCKTNOSUPPORT);
    CASE_OF(WSAEOPNOTSUPP);
    CASE_OF(WSAEPFNOSUPPORT);
    CASE_OF(WSAEAFNOSUPPORT);
    CASE_OF(WSAEADDRINUSE);
    CASE_OF(WSAEADDRNOTAVAIL);
    CASE_OF(WSAENETDOWN);
    CASE_OF(WSAENETUNREACH);
    CASE_OF(WSAENETRESET);
    CASE_OF(WSAECONNABORTED);
    CASE_OF(WSAECONNRESET);
    CASE_OF(WSAENOBUFS);
    CASE_OF(WSAEISCONN);
    CASE_OF(WSAENOTCONN);
    CASE_OF(WSAESHUTDOWN);
    CASE_OF(WSAETOOMANYREFS);
    CASE_OF(WSAETIMEDOUT);
    CASE_OF(WSAECONNREFUSED);
    CASE_OF(WSAELOOP);
    CASE_OF(WSAENAMETOOLONG);
    CASE_OF(WSAEHOSTDOWN);
    CASE_OF(WSAEHOSTUNREACH);
    CASE_OF(WSAENOTEMPTY);
    CASE_OF(WSAEPROCLIM);
    CASE_OF(WSAEUSERS);
    CASE_OF(WSAEDQUOT);
    CASE_OF(WSAESTALE);
    CASE_OF(WSAEREMOTE);
    CASE_OF(WSAEDISCON);
    CASE_OF(WSASYSNOTREADY);
    CASE_OF(WSAVERNOTSUPPORTED);
    CASE_OF(WSANOTINITIALISED);
    CASE_OF(WSAHOST_NOT_FOUND);
    CASE_OF(WSATRY_AGAIN);
    CASE_OF(WSANO_RECOVERY);
    CASE_OF(WSANO_DATA);

    CASE_OF(ERROR_FAILURE);
    CASE_OF(ERROR_INVALID_STATE);

    default : return "?";
  }
}

LPSTR
MapDispidToString(DISPID dispid)
{
  switch(dispid)
  {
    // special dispids
    CASE_OF(DISPID_VALUE);
    CASE_OF(DISPID_NEWENUM);
    CASE_OF(DISPID_EVALUATE);
    CASE_OF(DISPID_PROPERTYPUT);
    CASE_OF(DISPID_CONSTRUCTOR);
    CASE_OF(DISPID_DESTRUCTOR);
    CASE_OF(DISPID_UNKNOWN);
    CASE_OF(DISPID_COLLECT);

    CASE_OF(DISPID_WINHTTPTEST_OPEN);
    CASE_OF(DISPID_WINHTTPTEST_CONNECT);
    CASE_OF(DISPID_WINHTTPTEST_OPENREQUEST);
    CASE_OF(DISPID_WINHTTPTEST_SENDREQUEST);
    CASE_OF(DISPID_WINHTTPTEST_RECEIVERESPONSE);
    CASE_OF(DISPID_WINHTTPTEST_CLOSEHANDLE);
    CASE_OF(DISPID_WINHTTPTEST_READDATA);
    CASE_OF(DISPID_WINHTTPTEST_WRITEDATA);
    CASE_OF(DISPID_WINHTTPTEST_QUERYDATAAVAILABLE);
    CASE_OF(DISPID_WINHTTPTEST_QUERYOPTION);
    CASE_OF(DISPID_WINHTTPTEST_SETOPTION);
    CASE_OF(DISPID_WINHTTPTEST_SETTIMEOUTS);
    CASE_OF(DISPID_WINHTTPTEST_ADDREQUESTHEADERS);
    CASE_OF(DISPID_WINHTTPTEST_SETCREDENTIALS);
    CASE_OF(DISPID_WINHTTPTEST_QUERYAUTHSCHEMES);
    CASE_OF(DISPID_WINHTTPTEST_QUERYHEADERS);
    CASE_OF(DISPID_WINHTTPTEST_TIMEFROMSYSTEMTIME);
    CASE_OF(DISPID_WINHTTPTEST_TIMETOSYSTEMTIME);
    CASE_OF(DISPID_WINHTTPTEST_CRACKURL);
    CASE_OF(DISPID_WINHTTPTEST_CREATEURL);
    CASE_OF(DISPID_WINHTTPTEST_SETSTATUSCALLBACK);
    CASE_OF(DISPID_WINHTTPTEST_HELPER_GETBUFFEROBJECT);
    CASE_OF(DISPID_WINHTTPTEST_HELPER_GETURLCOMPONENTS);
    CASE_OF(DISPID_WINHTTPTEST_HELPER_GETSYSTEMTIME);
    CASE_OF(DISPID_WINHTTPTEST_HELPER_GETLASTERROR);
    CASE_OF(DISPID_WIN32ERRORCODE_ERRORCODE);
    CASE_OF(DISPID_WIN32ERRORCODE_ERRORSTRING);
    CASE_OF(DISPID_WIN32ERRORCODE_ISEXCEPTION);
    CASE_OF(DISPID_BUFFEROBJECT_SIZE);
    CASE_OF(DISPID_BUFFEROBJECT_TYPE);
    CASE_OF(DISPID_BUFFEROBJECT_BYTESTRANSFERRED);
    CASE_OF(DISPID_BUFFEROBJECT_FLAGS);
    CASE_OF(DISPID_URLCOMPONENTS_STRUCTSIZE);
    CASE_OF(DISPID_URLCOMPONENTS_SCHEME);
    CASE_OF(DISPID_URLCOMPONENTS_SCHEMELENGTH);
    CASE_OF(DISPID_URLCOMPONENTS_SCHEMEID);
    CASE_OF(DISPID_URLCOMPONENTS_HOSTNAME);
    CASE_OF(DISPID_URLCOMPONENTS_HOSTNAMELENGTH);
    CASE_OF(DISPID_URLCOMPONENTS_PORT);
    CASE_OF(DISPID_URLCOMPONENTS_USERNAME);
    CASE_OF(DISPID_URLCOMPONENTS_USERNAMELENGTH);
    CASE_OF(DISPID_URLCOMPONENTS_PASSWORD);
    CASE_OF(DISPID_URLCOMPONENTS_PASSWORDLENGTH);
    CASE_OF(DISPID_URLCOMPONENTS_URLPATH);
    CASE_OF(DISPID_URLCOMPONENTS_URLPATHLENGTH);
    CASE_OF(DISPID_URLCOMPONENTS_EXTRAINFO);
    CASE_OF(DISPID_URLCOMPONENTS_EXTRAINFOLENGTH);
    CASE_OF(DISPID_SYSTEMTIME_YEAR);
    CASE_OF(DISPID_SYSTEMTIME_MONTH);
    CASE_OF(DISPID_SYSTEMTIME_DAYOFWEEK);
    CASE_OF(DISPID_SYSTEMTIME_DAY);
    CASE_OF(DISPID_SYSTEMTIME_HOUR);
    CASE_OF(DISPID_SYSTEMTIME_MINUTE);
    CASE_OF(DISPID_SYSTEMTIME_SECOND);
    CASE_OF(DISPID_SYSTEMTIME_MSEC);

    default : return "?";
  }
}

LPSTR
MapVariantTypeToString(VARIANT* pvar)
{
  if( pvar )
  {
    switch( V_VT(pvar) )
    {
      CASE_OF(VT_ARRAY | VT_UI1);
      CASE_OF(VT_EMPTY);
      CASE_OF(VT_NULL);
      CASE_OF(VT_I2);
      CASE_OF(VT_I4);
      CASE_OF(VT_R4);
      CASE_OF(VT_R8);
      CASE_OF(VT_CY);
      CASE_OF(VT_DATE);
      CASE_OF(VT_BSTR);
      CASE_OF(VT_DISPATCH);
      CASE_OF(VT_ERROR);
      CASE_OF(VT_BOOL);
      CASE_OF(VT_VARIANT);
      CASE_OF(VT_DECIMAL);
      CASE_OF(VT_RECORD);
      CASE_OF(VT_UNKNOWN);
      CASE_OF(VT_I1);
      CASE_OF(VT_UI1);
      CASE_OF(VT_UI2);
      CASE_OF(VT_UI4);
      CASE_OF(VT_INT);
      CASE_OF(VT_UINT);
      CASE_OF(VT_ARRAY);
      CASE_OF(VT_BYREF);

      default : return "?";
    }
  }
  else
  {
    return "null";
  }
}

LPSTR
MapDataTypeToString(TYPE type)
{
  switch( type )
  {
    CASE_OF(TYPE_LPWSTR);
    CASE_OF(TYPE_LPLPWSTR);
    CASE_OF(TYPE_LPSTR);
    CASE_OF(TYPE_LPLPSTR);
    CASE_OF(TYPE_DWORD);
    CASE_OF(TYPE_LPDWORD);

    default : return "?";
  }
}

LPSTR
MapPointerTypeToString(POINTER pointer)
{
  switch( pointer )
  {
    CASE_OF(NULL_PTR);
    CASE_OF(BAD_PTR);
    CASE_OF(FREE_PTR);
    CASE_OF(UNINIT_PTR);

    default : return "?";
  }
}

LPSTR
MapWinHttpAccessType(DWORD type)
{
  switch( type )
  {
    CASE_OF(WINHTTP_ACCESS_TYPE_DEFAULT_PROXY);
    CASE_OF(WINHTTP_ACCESS_TYPE_NO_PROXY);
    CASE_OF(WINHTTP_ACCESS_TYPE_NAMED_PROXY);

    default : return "?";
  }
}

LPSTR
MapWinHttpIOMode(DWORD mode)
{
  switch( mode )
  {
    CASE_OF_MUTATE(0, WINHTTP_FLAG_SYNC);
    CASE_OF(WINHTTP_FLAG_ASYNC);

    default : return "?";
  }
}

LPSTR
MapWinHttpHandleType(HINTERNET hInternet)
{
  DWORD type = 0L;
  DWORD size = sizeof(HINTERNET);

  WinHttpQueryOption(hInternet, WINHTTP_OPTION_HANDLE_TYPE, (void*) &type, &size);

  switch( type )
  {
    CASE_OF(WINHTTP_HANDLE_TYPE_SESSION);
    CASE_OF(WINHTTP_HANDLE_TYPE_CONNECT);
    CASE_OF(WINHTTP_HANDLE_TYPE_REQUEST);

    default : return "INVALID_HANDLE_VALUE";
  }
}

LPSTR
MapCallbackFlagToString(DWORD flag)
{
  switch( flag )
  {
    CASE_OF(WINHTTP_CALLBACK_STATUS_RESOLVING_NAME);
    CASE_OF(WINHTTP_CALLBACK_STATUS_NAME_RESOLVED);
    CASE_OF(WINHTTP_CALLBACK_STATUS_CONNECTING_TO_SERVER);
    CASE_OF(WINHTTP_CALLBACK_STATUS_CONNECTED_TO_SERVER);
    CASE_OF(WINHTTP_CALLBACK_STATUS_SENDING_REQUEST);
    CASE_OF(WINHTTP_CALLBACK_STATUS_REQUEST_SENT);
    CASE_OF(WINHTTP_CALLBACK_STATUS_RECEIVING_RESPONSE);
    CASE_OF(WINHTTP_CALLBACK_STATUS_RESPONSE_RECEIVED);
    CASE_OF(WINHTTP_CALLBACK_STATUS_CLOSING_CONNECTION);
    CASE_OF(WINHTTP_CALLBACK_STATUS_CONNECTION_CLOSED);
    CASE_OF(WINHTTP_CALLBACK_STATUS_HANDLE_CREATED);
    CASE_OF(WINHTTP_CALLBACK_STATUS_HANDLE_CLOSING);
    CASE_OF(WINHTTP_CALLBACK_STATUS_DETECTING_PROXY);
    CASE_OF(WINHTTP_CALLBACK_STATUS_REQUEST_COMPLETE);
    CASE_OF(WINHTTP_CALLBACK_STATUS_REDIRECT);
    CASE_OF(WINHTTP_CALLBACK_STATUS_INTERMEDIATE_RESPONSE);
    CASE_OF(WINHTTP_CALLBACK_STATUS_SECURE_FAILURE);

    default : return "?";
  }
}

LPSTR
MapMemsetFlagToString(MEMSETFLAG mf)
{
  switch( mf )
  {
    CASE_OF(INIT_NULL);
    CASE_OF(INIT_SMILEY);
    CASE_OF(INIT_HEXFF);
    CASE_OF(INIT_GARBAGE);

    default : return "?";
  }
}

#ifdef _DEBUG

#define DEBUG_DEFAULT_DBGFILE L"WHTTPTST.LOG"
#define DEBUG_LOGFILE_MUTEX   L"WHTTPTST_LogFile_Mutex"

//
// globals
//

DWORD    g_dwTlsIndex        = 0L;
DWORD    g_dwDebugFlags      = DBG_NO_DEBUG;
HANDLE   g_hDebugLogFile     = NULL;
HANDLE   g_mtxDebugLogFile   = NULL;
LPCWSTR  g_wszDebugFlags     = L"debugflags";
MEMUSAGE g_memusage          = {0};

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  DebugInitialize()

  WHAT    : initializes the debugging support for the application. allocates
            thread-local storage and opens a log file if necessary.

            on failure, the function sets the DBG_NO_DEBUG flag so other
            debug functions won't do anything to get us in trouble.

  ARGS    : none
  RETURNS : nothing

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void
DebugInitialize( void )
{
  LPDWORD pdw   = NULL;

  DebugMemInitialize();

  if( GetRegValue(g_wszDebugFlags, REG_DWORD, (void**) &pdw) )
  {
    g_dwDebugFlags = *pdw;
    delete pdw;
  }
  else
  {
    g_dwDebugFlags = DEBUG_DEFAULT_FLAGS;
  }

  if( DBG_THROWDBGALERT & g_dwDebugFlags )
    DebugThrowDbgAlert();

  if( !(g_dwDebugFlags & DBG_NO_DEBUG) )
  {
    //
    // allocate a TLS slot or else we can't
    // do call tracing
    //

    if( (g_dwTlsIndex = TlsAlloc()) == 0xFFFFFFFF )
      goto no_debug;

    //
    // if logging to file is enabled, open the log file
    // and create a mutex for log dumps, disable debug
    // logging on error
    //

    if( g_dwDebugFlags & DBG_TO_FILE )
    {
      if(
        !( _opendebugfile() &&
           (g_mtxDebugLogFile = CreateMutex(NULL, FALSE, DEBUG_LOGFILE_MUTEX))
         )
        )
        goto no_debug;
    }

    //
    // print the log banner
    //

    char* time = _gettimestamp();

    _debugout(
      NULL,
      TRUE,
      FALSE,
      "\r\nDebug WHTTPTST.DLL started at %s with flags: %x\r\n\r\n",
      time,
      g_dwDebugFlags
      );

    delete [] time;
    return;
  }
  else
  {
    DebugMemTerminate();
  }

no_debug:
  g_dwDebugFlags = DBG_NO_DEBUG;
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  DebugTerminate()

  WHAT    : terminates debugging support for the application. 

  ARGS    : none
  RETURNS : nothing.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void
DebugTerminate( void )
{
  if( !(g_dwDebugFlags & DBG_NO_DEBUG) )
  {
    DebugMemTerminate();

    if( g_dwTlsIndex )
        TlsFree(g_dwTlsIndex);

    if( (g_dwDebugFlags & DBG_TO_FILE) && g_hDebugLogFile )
    {
      _closedebugfile();
      CloseHandle(g_mtxDebugLogFile);
      g_mtxDebugLogFile = NULL;
    }
  }
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  DebugMemInitialize()

  WHAT    : Initializes memory allocation tracking for the app.

  ARGS    : none.
  RETURNS : nothing.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void
DebugMemInitialize(void)
{
  InitializeCriticalSection(&g_memusage.lock);
  g_memusage.total = 0;
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  DebugMemTerminate()

  WHAT    : Terminates memory allocation tracking and prints the final line
            in the logfile indicating how many bytes of memory were unallocated
            at process termination.

  ARGS    : none.
  RETURNS : nothing.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void
DebugMemTerminate(void)
{
  if( g_dwDebugFlags & DBG_MEM )
    DebugTrace("*** unallocated memory: %d bytes", g_memusage.total);

  DeleteCriticalSection(&g_memusage.lock);
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  DebugMemAlloc()

  WHAT    : Increments our allocation tracking value by the number of bytes
            a given allocation maps to on the process heap.

  ARGS    : pv - pointer to allocated memory.

  RETURNS : nothing.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void
DebugMemAlloc(void* pv)
{
  EnterCriticalSection(&g_memusage.lock);

    g_memusage.total += HeapSize(GetProcessHeap(), 0, pv);

  LeaveCriticalSection(&g_memusage.lock);
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  DebugMemFree()

  WHAT    : Decrements our allocation tracking value by the number of bytes an
            allocation uses on the heap.

  ARGS    : pv - pointer to allocated memory.

  RETURNS : nothing.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void
DebugMemFree(void* pv)
{
  EnterCriticalSection(&g_memusage.lock);

    g_memusage.total -= HeapSize(GetProcessHeap(), 0, pv);    

  LeaveCriticalSection(&g_memusage.lock);
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  DebugThrowDbgAlert()

  WHAT    : Throws an alert dialog displaying the process PID so a debugger
            can be attached.

  ARGS    : none.
  RETURNS : nothing.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void
DebugThrowDbgAlert(void)
{
  char buf[256];

  wsprintfA(
    buf,
    "pid=%d",
    GetCurrentProcessId()
    );

  MessageBoxA(NULL, buf, "Attach Debugger!", MB_OK | MB_ICONSTOP | MB_SERVICE_NOTIFICATION);
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  DebugEnter()

  WHAT    : called on api entry. prints a log entry resembling the following:

              CalledFunctionName(param1=value, etc.)

  ARGS    : category - the debugging category for the logged function
            rt       - lets us know what type the function returns
            function - the logged function's name
            format   - user-supplied format string containing function args
            ...      - optional parameter list

  RETURNS : nothing

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void
DebugEnter(int category, RETTYPE rt, LPCSTR function, const char* format, ...)
{
  LPTHREADINFO pti = NULL;
  LPCALLINFO   pci = NULL;

  if( !(g_dwDebugFlags & DBG_NO_DEBUG) )
  {
    pti = GetThreadInfo();
    pci = SetCallInfo(pti, category, rt, function);

    if( g_dwDebugFlags & category )
    {
      char*   buffer = new char[1024];
      va_list arg_list;

      pti->depth++;

      if( buffer )
      {
        //
        // if the user passed an arglist & some values,
        // we'll plug it in to the function entry listing
        // in the log. otherwise we just print empty parens
        //

        if( format )
        {
          va_start(arg_list, format);
          wvsprintfA(buffer, format, arg_list);

            _debugout(pti, FALSE, FALSE, "%s(%s)", function, buffer);

          va_end(arg_list);
        }
        else
        {
          _debugout(pti, FALSE, FALSE, "%s()", function);
        }
    
        delete [] buffer;
      }
    }
  }
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  DebugLeave()

  WHAT    : prints a log entry for the logged function displaying the return
            value.
            
  ARGS    : retval - the value the logged function will return
  RETURNS : nothing.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void
DebugLeave(int retval)
{
  LPTHREADINFO pti = NULL;
  LPCALLINFO   pci = NULL;

  if( !(g_dwDebugFlags & DBG_NO_DEBUG) )
  {
    pti = GetThreadInfo();
    pci = GetCallInfo(pti);

    if( g_dwDebugFlags & pci->category )
    {
      char* buffer = FormatCallReturnString(pci, retval);

      _debugout(pti, FALSE, FALSE, buffer);
      pti->depth--;
      delete [] buffer;
    }

    DeleteCallInfo(pci);
  }
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  DebugTrace()

  WHAT    : prints a generic output line with the usual timestamp & thread id,
            etc.

  ARGS    : format - user-supplied format string
            ...    - optional parameter list

  RETURNS : nothing

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void
DebugTrace(const char* format, ...)
{
  va_list arg_list;
  char    buf[1024];

  if( !(g_dwDebugFlags & DBG_NO_DEBUG) )
  {
    va_start(arg_list, format);

      wvsprintfA(buf, format, arg_list);
      _debugout(GetThreadInfo(), FALSE, TRUE, buf);

    va_end(arg_list);
  }
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  DebugAssert()

  WHAT    : logs asserts to the selected outputs but doesn't break execution.

  ARGS    : condition - the stringized failure condition.
            file      - the file containing the assert
            line      - the line of code that asserted

  RETURNS : nothing

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void
DebugAssert(LPSTR condition, LPSTR file, int line)
{
  LPTHREADINFO pti = GetThreadInfo();
  LPCALLINFO   pci = NULL;

  _debugout(
    pti,
    TRUE,
    FALSE,
    "\r\n\r\n\t*******************************************\r\n" \
    "\t ASSERTION FAILED: \"%s\"\r\n" \
    "\t  %s (line %d)\r\n",
    condition,
    file,
    line
    );

  for(pci = pti->stack; pci; pci = pci->next)
  {
    _debugout(pti, TRUE, FALSE, "\t   %s", pci->fname);
  }

  _debugout(pti, TRUE, FALSE, "\r\n\t*******************************************\r\n");
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  DebugDataDump*()

  WHAT    : functions to dump a data buffer to the log file.

  ARGS    : title - a legend for the dump
            data  - the buffer
            len   - number of interesting bytes in the buffer

  RETURNS : nothing

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void
DebugDataDump(LPSTR title, LPBYTE data, DWORD len)
{
  DWORD n      = 0L;
  DWORD offset = 0L;
  CHAR* buf    = NULL;

  DebugTrace("%s (%#x bytes @ %#x)", title, len, data);

  buf = new CHAR[256];

    while( len )
    {
      n = DebugDataDumpFormat(buf, data, len);

      DebugTrace(buf);

      data += n;
      len  -= n;
    }

  delete [] buf;
}

int
DebugDataDumpFormat(LPSTR buffer, LPBYTE data, DWORD len)
{
  //
  // note - plagiarized from similar code in wininet.
  //

  static char spaces[] = "                                               ";

  DWORD n      = 0L;
  DWORD bytes  = 0L;
  DWORD offset = 0L;
  DWORD byte   = 0L;
  CHAR  ch;

  bytes  = min(len, 16);
  offset = wsprintfA(buffer, "%08x  ", data);

  for(n=0; n<bytes; n++)
  {
    byte    = data[n] & 0xFF;

    offset += wsprintfA(
                buffer+offset,
                ((n & 15) == 7 ? "%02.2x-" : "%02.2x "),
                byte                
                );
  }

  memcpy(buffer+offset, spaces, (16-bytes) * 3 + 2);
  offset += (16-bytes) * 3 + 2;

  for(n=0; n<bytes; n++)
  {
    ch = data[n];
    buffer[offset + n] =  (((ch < 32) || (ch > 127)) || ch == '%') ? '.' : ch;
  }

  buffer[offset + n] = '\0';

  return bytes;
}


/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  AcquireDebugFileLock()

  WHAT    : synchronizes access to the log file handle.

  ARGS    : none
  RETURNS : nothing

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void
AcquireDebugFileLock(void)
{
  WaitForSingleObject(g_mtxDebugLogFile, INFINITE);
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  ReleaseDebugFileLock()

  WHAT    : releases a thread's lock on the log file handle

  ARGS    : none
  RETURNS : nothing

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void
ReleaseDebugFileLock(void)
{
  ReleaseMutex(g_mtxDebugLogFile);
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  GetThreadInfo()

  WHAT    : extracts a THREADINFO struct from TLS. if one does not exist,
            this function allocates one and returns it.

  ARGS    : none
  RETURNS : pointer to a THREADINFO struct.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
LPTHREADINFO
GetThreadInfo(void)
{
  LPTHREADINFO pti = (LPTHREADINFO) TlsGetValue(g_dwTlsIndex);

    if( !pti )
    {
      pti = new THREADINFO;

      pti->threadid  = GetCurrentThreadId();
      pti->threadcat = 0;
      pti->depth     = 0;
      pti->stack     = NULL;

      TlsSetValue(g_dwTlsIndex, (LPVOID) pti);
    }

  return pti;
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  SetCallInfo()

  WHAT    : allocates and pushes a CALLINFO struct onto the thread's internal
            call list.

  ARGS    : pti      - pointer to the thread's THREADINFO struct
            category - the debug category associated with the logged function
            rt       - return type used by the logged function
            function - the function name

  RETURNS : pointer to a newly allocated CALLINFO struct

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
LPCALLINFO
SetCallInfo(LPTHREADINFO pti, DWORD category, RETTYPE rt, LPCSTR function)
{
  LPCALLINFO pci   = NULL;
  LPCALLINFO plast = NULL;

  //
  // walk the call stack to the last item,
  // store the next-to-last position
  //

  for( pci = pti->stack; pci; pci = pci->next )
  {
    plast = pci;
  }

  if( !pci )
  {
    pci = new CALLINFO;

    //
    // if this is the first call on this thread, set the thread
    // category id. this makes logging more understandable by
    // remembering where a thread was first created and what it
    // was used for. the old method changed the caller id based
    // on the function category, which was dumb.
    //

    if( !pti->threadcat )
      pti->threadcat = category;

    pci->category = category;
    pci->fname    = function;
    pci->rettype  = rt;
    pci->last     = plast;
    pci->next     = NULL;

    //
    // if this is the first element, insert it
    // at the head of the list, otherwise
    // link up with the last element
    //

    if( !pti->stack )
    {
      pti->stack = pci;
    }
    else
    {
      plast->next = pci;
    }
  }

  return pci;
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  GetCallInfo()

  WHAT    : retrieves the last THREADINFO struct from the threads call trace
            list.

  ARGS    : pti - pointer to the THREADINFO struct whose call list you want

  RETURNS : pointer to a CALLINFO struct

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
LPCALLINFO
GetCallInfo(LPTHREADINFO pti)
{
  LPCALLINFO pci = NULL;

  if( pti->stack )
  {
    for( pci = pti->stack; pci->next; pci = pci->next );
  }

  return pci;
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  DeleteCallInfo()

  WHAT    : pops the specified CALLINFO struct off the thread's call list and
            deletes it. if we just popped & deleted the last call record, then
            delete the thread's THREADINFO struct.

  ARGS    : pci - the CALLINFO struct you wish to delete

  RETURNS : nothing

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void
DeleteCallInfo(LPCALLINFO pci)
{
  LPTHREADINFO pti = GetThreadInfo();

  //
  // if the call record we're dealing with isn't the top of the stack
  // then fix up the stack pointers
  //
  // if the current call record is the last then delete the THREADINFO
  // for this thread and NULL the TLS value
  //

  if( pci->last )
  {
    pci->last->next = NULL;
  }
  else
  {
    delete pti;
    TlsSetValue(g_dwTlsIndex, NULL);
  }

  //
  // for all cases, free the call record
  //

  delete pci;
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  FormatCallReturnString()

  WHAT    : examines the returning function's return type and formats a string
            containing the return value. in the case of known error codes, we
            include a string representation of the error (e.g. ERROR_SUCCESS).

  ARGS    : pci    - pointer to the CALLINFO struct for the returning function
            retval - the function's return value

  RETURNS : formatted character buffer

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
LPSTR
FormatCallReturnString(LPCALLINFO pci, int retval)
{
  char* buffer = new char[256];
  int   offset = 0;

  if( buffer )
  {
    offset = wsprintfA(
               buffer,
               "%s() returned ",
               pci->fname
               );

    switch( pci->rettype )
    {
      case rt_void :
        {
          wsprintfA(buffer+offset, "<void>");
        }
        break;

      case rt_bool :
        {
          wsprintfA(buffer+offset, "%s", (retval ? "TRUE" : "FALSE"));
        }
        break;

      case rt_dword :
        {
          wsprintfA(buffer+offset, "%d [%s]", retval, MapErrorToString(retval));
        }
        break;

      case rt_hresult :
        {
          wsprintfA(buffer+offset, "%x [%s]", retval, MapHResultToString(retval));
        }
        break;

      case rt_string :
        {
          wsprintfA(buffer+offset, "%.16s", (LPSTR)retval);
        }
        break;

      default:
        {
          wsprintfA(buffer+offset, "?");
        }
    }
  }

  return buffer;
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  MapCategoryToString()

  WHAT    : maps a debug category to a string for the log file.

  ARGS    : category - the category id

  RETURNS : string representation of the category id

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
LPSTR
MapCategoryToString(int category)
{
  switch(category)
  {
    case DBG_DLL : return "dll";

    default : return "???";
  }
}


/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  _debugout()

  WHAT    : the debug output workhorse. sloppy as crap and i don't care.

  ARGS    : pti    - THREADINFO pointer
            fRaw   - skip debug info formatting
            fTrace - flag that causes us to do in-function indenting
            format - printf format string
            ...    - arglist

  RETURNS : nothing  

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void
_debugout(LPTHREADINFO pti, BOOL fRaw, BOOL fTrace, const char* format, ...)
{
  int        offset = 0;
  char*      buffer = new char[2048];
  va_list    arg_list;

  if( !buffer )
    goto quit;

    //
    // check if the user wants verbose debug info
    //

    if( !fRaw )
    {
      if( DBG_TIMESTAMP & g_dwDebugFlags )
      {
        char* timestamp = _gettimestamp();

        offset = wsprintfA(buffer, "%s ", timestamp);
        delete [] timestamp;
      }

      if( DBG_THREAD_INFO & g_dwDebugFlags )
      {
        offset += wsprintfA(buffer+offset, "%0.8x:%0.3d ", pti->threadid, pti->depth);
      }

      if( DBG_CALL_INFO & g_dwDebugFlags )
      {
        //
        // 260500 pmidge
        // changed this to use the thread category id instead of the caller's id.
        //

        offset += wsprintfA(buffer+offset, "<%s> ", MapCategoryToString(pti->threadcat));
      }

      if( DBG_NEST_CALLS & g_dwDebugFlags )
      {
        char* whitespace = _getwhitespace(
                              (fTrace ? pti->depth+1 : pti->depth)
                              );

        offset += wsprintfA(buffer+offset, "%s", whitespace);
        delete [] whitespace;
      }
    }


    //
    // plug in caller's goo if present
    //

    if( format )
    {
      va_start(arg_list, format);
      
        offset += wvsprintfA(buffer+offset, format, arg_list);
        wsprintfA(buffer+offset, "\r\n");
      
      va_end(arg_list);
    }


    //
    // dump to selected outputs
    //

    //
    // BUGBUG: this app only runs on W2K, need to
    //         investigate WMI support
    //

    if( DBG_TO_FILE & g_dwDebugFlags )
    {
      DWORD dw = 0;
    
      AcquireDebugFileLock();

        WriteFile(
          g_hDebugLogFile,
          buffer,
          strlen(buffer),
          &dw,
          NULL
          );
      
      ReleaseDebugFileLock();
    }

    if( DBG_TO_DEBUGGER & g_dwDebugFlags )
      OutputDebugStringA(buffer);

quit:
  delete [] buffer;
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  _gettimestamp( void )

  WHAT    : gets the current time, formats it, and returns it to the caller.
            the caller MUST free the return value when done.

  ARGS    : none
  RETURNS : pointer to formatted time string

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
char*
_gettimestamp( void )
{
  SYSTEMTIME st;
  char*      buffer = new char[256];
  
  if( buffer )
  {
    GetLocalTime(&st);

    wsprintfA(
      buffer,
      "%0.2d:%0.2d:%0.2d.%0.3d",
      st.wHour,
      st.wMinute,
      st.wSecond,
      st.wMilliseconds
      );
  }

  return buffer;
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  _getwhitespace( int spaces )

  WHAT    : used to insert a number of spaces for indenting. caller must
            free return value.

  ARGS    : spaces - number of spaces to insert
  
  RETURNS : pointer to character buffer filled with spaces

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
char*
_getwhitespace(int spaces)
{
  char* buffer = new char[(spaces * 2) + 1];

  if( buffer )
  {
    memset(buffer, ' ', (spaces * 2));
    buffer[(spaces * 2)] = '\0';
  }

  return buffer;
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  _opendebugfile( void )

  WHAT    : opens the debug log file. will stomp previous logs instead of
            appending.

  ARGS    : none

  RETURNS : true or false based on whether the file was opened.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
BOOL
_opendebugfile(void)
{
  WCHAR buf[MAX_PATH];

  if( !g_hDebugLogFile )
  {
    memset(buf, 0x00, (sizeof(WCHAR) * MAX_PATH));

    wsprintf(
      buf,
      L"whttptst_%0.8x.log",
      GetTickCount()
      );

    g_hDebugLogFile = CreateFile(
                        buf,
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ,
                        NULL,
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );
  }
  
  return (g_hDebugLogFile ? TRUE : FALSE);
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  _closedebugfile( void )

  WHAT    : closes the debug log file.
  ARGS    : none
  RETURNS : nothing

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
void
_closedebugfile(void)
{
  SAFECLOSE(g_hDebugLogFile);
}

#endif /* _DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\whttptst\src\utils\registry.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    registry.cpp

Abstract:

    Registry functions.
    
Author:

    Paul M Midgen (pmidge) 23-May-2000


Revision History:

    23-May-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

LPCWSTR g_wszAppRootKeyName = L"Software\\Microsoft\\WINHTTPTST";

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  GetRegValue()

  WHAT      : Reads the value of a REG_DWORD or REG_SZ registry value. The
              caller must free the value returned through ppvData.

  ARGS      : szValueName - the value to look up
              dwType      - can be REG_SZ or REG_DWORD
              ppvData     - address of a pointer to initialize to the data
                            read from the registry

  RETURNS   : True if the lookup succeeded, false if there was an error. The
              caller can call GetLastError() to determine the type of error.
              Possible values returned by GetLastError() are:

              ERROR_NOT_ENOUGH_MEMORY - failed to allocate storage for the
                                        requested key

              ERROR_INVALID_PARAMETER - unsupported type in dwType

              If registry lookups fail we set last error to the retcode
              from the registry api we called.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
BOOL
GetRegValue(LPCWSTR wszValueName, DWORD dwType, LPVOID* ppvData)
{
  BOOL   bStatus   = FALSE;
  DWORD  dwRet     = 0L;
  LPBYTE lpData    = NULL;
  DWORD  cbData    = 0L;
  HKEY   hkAppRoot = _GetRootKey(TRUE);

  switch( dwType )
  {
    case REG_DWORD :
      {
        cbData = sizeof(DWORD);
        lpData = new BYTE[cbData];

        if( !lpData )
        {
          SetLastError(ERROR_NOT_ENOUGH_MEMORY);
          goto quit;
        }
      }
      break;

    case REG_SZ :
      {
        // get required buffer size
        dwRet = RegQueryValueEx(
                  hkAppRoot, wszValueName, 0L,
                  &dwType, lpData, &cbData
                  );

          if( dwRet )
          {
            //DEBUG_TRACE(REGISTRY, ("requested key (%s) doesn't exist", szValueName));
            SetLastError(dwRet);
            goto quit;
          }

        lpData = new BYTE[cbData];

          if( !lpData )
          {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto quit;
          }
      }
      break;

    default :
      {
        DEBUG_TRACE(REGISTRY, ("requested type not supported"));
        SetLastError(ERROR_INVALID_PARAMETER);
        goto quit;
      }
      break;
  }

  //
  // do the lookup
  //
  dwRet = RegQueryValueEx(
            hkAppRoot, wszValueName, 0L,
            &dwType, lpData, &cbData
            );
    
    if( dwRet )
    {
      delete [] lpData;
      SetLastError(dwRet);
      goto quit;
    }

  bStatus  = TRUE;
  *ppvData = (LPVOID) lpData;

#ifdef _DEBUG
    if( bStatus )
    {
      switch( dwType )
      {
        case REG_DWORD :
          DEBUG_TRACE(REGISTRY, ("lpData: %d; cbData: %d", (DWORD)*lpData, cbData));
          break;

        case REG_SZ :
          DEBUG_TRACE(REGISTRY, ("lpdata: %s; cbData: %d", (LPSTR)lpData, cbData));
          break;
      }
    }
#endif

quit:

  return bStatus;
}


/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  SetRegValue()

  WHAT      : Writes a value under the application registry key.

  ARGS      : szValueName - the name of the regkey to write to
              dwType      - type of the regkey to write
              pvData      - regkey data
              dwSize      - bytecount of data to write

  RETURNS   : True if the write succeeded, false if otherwise.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
BOOL
SetRegValue(LPCWSTR wszValueName, DWORD dwType, LPVOID pvData, DWORD dwSize)
{
  BOOL  bStatus   = FALSE;
  DWORD dwRet     = 0L;
  HKEY  hkAppRoot = _GetRootKey(TRUE);

#ifdef _DEBUG
    switch( dwType )
    {
      case REG_DWORD :
        DEBUG_TRACE(REGISTRY, ("pvData: %d; dwSize: %d", (DWORD)*((LPDWORD)pvData), dwSize));
        break;

      case REG_SZ :
        DEBUG_TRACE(REGISTRY, ("pvData: %s; dwSize: %d", (LPSTR)pvData, dwSize));
        break;
    }
#endif

    if( !dwSize && pvData )
      dwSize = strlen((LPSTR)pvData);

    dwRet = RegSetValueEx(
              hkAppRoot, wszValueName, 0L,
              dwType, (LPBYTE)pvData, dwSize
              );

    if( dwRet != ERROR_SUCCESS )
      SetLastError(dwRet);
    else
      bStatus = TRUE;      

  return bStatus;
}

/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  _GetRootKey()

  WHAT      : Creates/opens the root key used by the app. Remembers the key
              handle across calls, and can be called to release the key handle.

  ARGS      : fOpen - if true, open the regkey, if false, close it.

  RETURNS   : regkey handle.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/
HKEY _GetRootKey(BOOL fOpen)
{
  DWORD       disp = 0;
  DWORD       ret  = 0;
  static HKEY root = NULL;

  if( fOpen )
  {
    if( !root )
    {
      ret = RegCreateKeyEx(
              HKEY_CURRENT_USER,
              g_wszAppRootKeyName,
              0,
              NULL,
              REG_OPTION_NON_VOLATILE,
              KEY_ALL_ACCESS,
              NULL,
              &root,
              &disp
              );
    }
  }
  else
  {
    if( root )
    {
      RegCloseKey(root);
      root = NULL;
    }
  }

  return root;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\whttptst\src\utils\utils.cxx ===
/*++=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Copyright (c) 2000  Microsoft Corporation

Module Name:

    utils.cxx

Abstract:

    Utility functions.
    
Author:

    Paul M Midgen (pmidge) 12-October-2000


Revision History:

    12-October-2000 pmidge
        Created

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--*/

#include "common.h"

extern PHANDLEMAP g_pGlobalHandleMap;

//-----------------------------------------------------------------------------
// exception handling
//-----------------------------------------------------------------------------
int exception_filter(PEXCEPTION_POINTERS pep)
{
  int e = pep->ExceptionRecord->ExceptionCode;

  DEBUG_TRACE(HELPER, ("*************** EXCEPTION CAUGHT ***************"));
  DEBUG_TRACE(HELPER, ("type: 0x%0.8x [%s]", e, MapErrorToString(e)));
  DEBUG_TRACE(HELPER, ("eip : 0x%0.8x", pep->ExceptionRecord->ExceptionAddress));

  if( pep->ExceptionRecord->ExceptionCode == EXCEPTION_ACCESS_VIOLATION )
  {
    DEBUG_TRACE(
      HELPER,
      ("mode: %s", pep->ExceptionRecord->ExceptionInformation[0] ? "write" : "read")
      );

    DEBUG_TRACE(
      HELPER,
      ("addr: 0x%0.8x", pep->ExceptionRecord->ExceptionInformation[1])
      );
  }

  DEBUG_TRACE(HELPER, ("************************************************"));

  return EXCEPTION_EXECUTE_HANDLER;
}

//-----------------------------------------------------------------------------
// file retrieval
//-----------------------------------------------------------------------------
HANDLE
__OpenFile(LPCWSTR path, DWORD mode, BOOL* bReadOnly)
{
  HANDLE hFile = INVALID_HANDLE_VALUE;
  DWORD  flags = GENERIC_READ | GENERIC_WRITE;

retry:

  hFile = CreateFile(
            path,
            flags,
            FILE_SHARE_READ,
            NULL,
            mode,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );

  if( hFile == INVALID_HANDLE_VALUE )
  {
    if( GetLastError() == ERROR_ACCESS_DENIED )
    {
      if( flags == (GENERIC_READ | GENERIC_WRITE) )
      {
        DEBUG_TRACE(UTILS, ("read/write open attempt failed, retrying for read-only access"));

        flags      = GENERIC_READ;
        *bReadOnly = TRUE;
        goto retry;
      }
    }

    DEBUG_TRACE(UTILS, ("error opening %S: %s", path, MapErrorToString(GetLastError())));
  }
  else
  {
    DEBUG_TRACE(UTILS, ("file opened"));
  }

  return hFile;
}

//-----------------------------------------------------------------------------
// general utility functions
//-----------------------------------------------------------------------------
HRESULT
ManageCallbackForHandle(HINTERNET hInet, IDispatch** ppCallback, DWORD dwAction)
{
  DEBUG_ENTER((
    DBG_HELPER,
    rt_hresult,
    "ManageCallbackForHandle",
    "hInet=%#x; ppCallback=%#x; dwAction=%#x",
    hInet,
    ppCallback,
    dwAction
    ));

  HRESULT hr    = S_OK;
  DWORD   error = ERROR_SUCCESS;

  if( !ppCallback && (dwAction != CALLBACK_HANDLE_UNMAP) )
  {
    hr = E_POINTER;
    goto quit;
  }

  DEBUG_TRACE(HELPER, ("handle %#x is a %s", hInet, MapWinHttpHandleType(hInet)));

    switch( dwAction )
    {
      case CALLBACK_HANDLE_MAP :
        {
          error = g_pGlobalHandleMap->Insert(hInet, (void*) *ppCallback);

          if( (error == ERROR_SUCCESS) || (error == ERROR_DUP_NAME) )
          {
            DEBUG_TRACE(HELPER, ("handle %#x mapped to callback %#x", hInet, *ppCallback));
            (*ppCallback)->AddRef();
          }
          else
          {
            DEBUG_TRACE(HELPER, ("failed to map handle"));
            hr = E_FAIL;
          }
        }
        break;

      case CALLBACK_HANDLE_UNMAP :
        {
          DEBUG_TRACE(HELPER, ("deleting callback mapping for handle %#x", hInet));
          g_pGlobalHandleMap->Delete(hInet, NULL);
        }
        break;

      case CALLBACK_HANDLE_GET :
        {
          if( g_pGlobalHandleMap->Get(hInet, (void**) ppCallback) != ERROR_SUCCESS )
          {
            DEBUG_TRACE(HELPER, ("no mapping found for handle"));

            *ppCallback = NULL;
            hr          = E_FAIL;
          }
        }
        break;

      default : hr = E_INVALIDARG;
    }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}

HRESULT
GetTypeInfoFromName(LPCOLESTR name, ITypeLib* ptl, ITypeInfo** ppti)
{
  DEBUG_ENTER((
    DBG_UTILS,
    rt_hresult,
    "GetTypeInfoFromName",
    "name=%.16S; ptl=%#x; ppti=%#x",
    name,
    ptl,
    ppti
    ));

  HRESULT  hr     = S_OK;
  BOOL     bFound = FALSE;
  USHORT   cf     = 1L;
  ULONG    hash   = 0L;
  LONG     id     = 0L;
  LPOLESTR pstr   = NULL;

  if( !name || ! ptl )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  if( !ppti )
  {
    hr = E_POINTER;
    goto quit;
  }

  *ppti = NULL;
  pstr  = __wstrdup(name);

    ptl->IsName(pstr, 0L, &bFound);

      if( !bFound )
      {
        hr = TYPE_E_ELEMENTNOTFOUND;
        goto quit;
      }

    hash = LHashValOfNameSys(
             SYS_WIN32,
             MAKELCID(MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL), SORT_DEFAULT),
             pstr
             );

    hr = ptl->FindName(pstr, hash, ppti, &id, &cf);

    DEBUG_TRACE(UTILS, ("find name: pti=%#x; cf=%d", *ppti, cf));

quit:

  SAFEDELETEBUF(pstr);

  DEBUG_LEAVE(hr);
  return hr;
}

DISPID
GetDispidFromName(PDISPIDTABLEENTRY pdt, DWORD cEntries, LPWSTR name)
{
  DWORD  n      = 0L;
  DWORD  hash   = GetHash(name);
  DISPID dispid = DISPID_UNKNOWN;

  while( n < cEntries )
  {
    if( pdt[n].hash != hash )
    {
      ++n;
    }
    else
    {
      dispid = pdt[n].dispid;
      break;
    }
  }

  DEBUG_TRACE(DISPATCH, ("hash %#x is %s", hash, MapDispidToString(dispid)));
  return dispid;
}

void
AddRichErrorInfo(EXCEPINFO* pei, LPWSTR source, LPWSTR description, HRESULT error)
{
  if( pei )
  {
    pei->bstrSource      = __widetobstr((source ? source : L"unknown source"));
    pei->bstrDescription = __widetobstr((description ? description : L"no description"));
    pei->scode           = error;
  }
}

DWORD
GetHash(LPWSTR name)
{
  DWORD hash   = 0L;
  DWORD n      = 0L;
  DWORD len    = 0L;
  LPSTR string = NULL;

  string = __widetoansi(name);

  if( string )
  {
    _strlwr(string);

    for(n=0, len=strlen(string); n<=len; n++)
    {
      hash += __toascii(string[len-n]) * ((10<<n)^n);
    }

    DEBUG_TRACE(DISPATCH, ("name=%s; hash=%#x", string, hash));
  }

  SAFEDELETEBUF(string);
  return hash;
}

DWORD
GetHash(LPSTR name)
{
  DWORD hash   = 0L;
  DWORD n      = 0L;
  DWORD len    = 0L;
  LPSTR string = NULL;

  string = __strdup(name);

  if( string )
  {
    _strlwr(string);

    for(n=0, len=strlen(string); n<=len; n++)
    {
      hash += __toascii(string[len-n]) * ((10<<n)^n);
    }

    DEBUG_TRACE(DISPATCH, ("name=%s; hash=%#x", string, hash));
  }

  SAFEDELETEBUF(string);
  return hash;
}

HRESULT
ValidateDispatchArgs(REFIID riid, DISPPARAMS* pdp, VARIANT* pvr, UINT* pae)
{
  HRESULT hr = S_OK;

    if( !IsEqualIID(riid, IID_NULL) )
    {
      hr = DISP_E_UNKNOWNINTERFACE;
      goto quit;
    }

    if( !pdp )
    {
      hr = E_INVALIDARG;
      goto quit;
    }

    if( pae )
    {
      *pae = 0;
    }

    if( pvr )
    {
      VariantInit(pvr);
    }

quit:

  return hr;
}

HRESULT
ValidateInvokeFlags(WORD flags, WORD accesstype, BOOL bMethod)
{
  HRESULT hr = S_OK;

    if( (flags & ~(DISPATCH_METHOD | DISPATCH_PROPERTYGET | DISPATCH_PROPERTYPUT)) )
    {
      hr = E_INVALIDARG;
    }
    else
    {
      if( !bMethod )
      {
        if( flags & DISPATCH_METHOD )
        {
          hr = E_NOINTERFACE;
        }
        else
        {
          if( (flags & DISPATCH_PROPERTYPUT) && !(accesstype & DISPATCH_PROPERTYPUT) )
          {
            hr = E_ACCESSDENIED;
          }
          else
          {
            if( !(flags & accesstype) )
            {
              hr = E_FAIL;
            }
          }
        }
      }
      else
      {
        if( flags & ~(DISPATCH_METHOD | DISPATCH_PROPERTYGET) )
        {
          hr = E_NOINTERFACE;
        }
      }
    }

  return hr;
}

HRESULT
ValidateArgCount(DISPPARAMS* pdp, DWORD needed, BOOL bHasOptionalArgs, DWORD optional)
{
  HRESULT hr = S_OK;

    if( bHasOptionalArgs )
    {
      if( (pdp->cArgs > needed+optional) || (pdp->cArgs < needed) )
      {
        hr = DISP_E_BADPARAMCOUNT;
      }
    }
    else
    {
      if( (!needed && pdp->cArgs) || (needed < pdp->cArgs) )
      {
        hr = DISP_E_BADPARAMCOUNT;
      }
      else
      {
        hr = (pdp->cArgs == needed) ? S_OK : DISP_E_PARAMNOTOPTIONAL;
      }
    }

  return hr;
}

HRESULT
HandleDispatchError(LPWSTR id, EXCEPINFO* pei, HRESULT hr)
{
  LPWSTR msg = NULL;

  switch( hr )
  {
    case E_POINTER      : msg = L"a return pointer parameter was missing";                         break;
    case E_ACCESSDENIED : msg = L"an attempt to modify a property failed because it is read-only"; break;
    case E_FAIL         : msg = L"an unhandled error occurred";                                    break;
    case E_INVALIDARG   : msg = L"an argument passed to a property or method was invalid";         break;
    case E_NOINTERFACE  : msg = L"a property or method was accessed incorrectly";                  break;
    default             : return hr;
  }

  AddRichErrorInfo(pei, id, msg, hr);

  return DISP_E_EXCEPTION;
}

//-----------------------------------------------------------------------------
// string & type manipulation
//-----------------------------------------------------------------------------
char*
__strdup(const char* src)
{
  int   n   = 0;
  char* dup = NULL;

  if( src )
  {
    n   = strlen(src)+1;
    dup = new char[n];
    strncpy(dup, src, n);
  }

  return dup;
}

char*
__strndup(const char* src, int len)
{
  char* dup = NULL;

  if( src )
  {
    dup      = new char[len+1];
    dup[len] = '\0';
    strncpy(dup, src, len);
  }

  return dup;
}

WCHAR*
__wstrdup(const WCHAR* src)
{
  int    n   = 0;
  WCHAR* dup = NULL;

  if( src )
  {
    n   = wcslen(src)+1;
    dup = new WCHAR[n];
    wcsncpy(dup, src, n);
  }

  return dup;
}

WCHAR*
__wstrndup(const WCHAR* src, int len)
{
  WCHAR* dup = NULL;

  if( src )
  {
    dup      = new WCHAR[len+1];
    dup[len] = L'\0';
    wcsncpy(dup, src, len);
  }

  return dup;
}

WCHAR*
__ansitowide(const char* psz)
{
  WCHAR* wide = NULL;
  int    len  = 0L;

  if( psz )
  {
    len  = strlen(psz);

    if( len )
    {
      ++len;
      wide = new WCHAR[len];

      MultiByteToWideChar(
        CP_ACP,
        0,
        psz,
        len,
        wide,
        len
        );
    }
  }

  return wide;
}

CHAR*
__widetoansi(const WCHAR* pwsz)
{
  CHAR* ansi = NULL;
  int   len  = 0L;
  BOOL  def  = FALSE;

  if( pwsz )
  {
    len  = wcslen(pwsz);

    if( len )
    {
      ++len;
      ansi = new CHAR[len];

      WideCharToMultiByte(
        CP_ACP,
        0,
        pwsz,
        len,
        ansi,
        len,
        "?",
        &def
        );
    }
  }

  return ansi;
}

BSTR
__ansitobstr(LPCSTR src)
{
  BSTR   ret = NULL;
  LPWSTR wsz = NULL;

  if( src )
  {
    wsz = __ansitowide(src);
    ret = SysAllocString(wsz);
    SAFEDELETEBUF(wsz);
  }

  return ret;
}

BSTR
__widetobstr(LPCWSTR wsrc)
{
  return (wsrc ? SysAllocString(wsrc) : NULL);
}

BOOL
__isempty(VARIANT var)
{
  BOOL isempty = FALSE;

  if(
      ((V_VT(&var) == VT_EMPTY) || (V_VT(&var) == VT_NULL) || (V_VT(&var) == VT_ERROR)) ||
      ((V_VT(&var) == VT_BSTR) && (SysStringLen(V_BSTR(&var)) == 0))
    )
  {
    isempty = TRUE;
  }

  return isempty;
}

// private
char hex2char(char* hex)
{
  register char digit;
  
    digit  = (hex[0] >= 'A' ? ((hex[0] & 0xdf) - 'A')+10 : (hex[0] - '0'));
    digit *= 16;
    digit += (hex[1] >= 'A' ? ((hex[1] & 0xdf) - 'A')+10 : (hex[1] - '0'));

  return(digit);
}

char*
__unescape(char* str)
{
  register int x;
  register int y;
  char*        str2;

  str2 = __strdup(str);

  if( str2 )
  {    
    for(x=0, y=0; str2[y]; ++x, ++y)
    {
      if((str2[x] = str2[y]) == '%')
      {
        str2[x] = hex2char(&str2[y+1]);
        y += 2;
      }
    }
    
    str2[x] = '\0';
  }

  return str2;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\whttptst\script\whttptst_include.h ===
var EXCEPTION_ACCESS_VIOLATION    = 0xc0000005;
var EXCEPTION_STACK_OVERFLOW      = 0xc00000fd;
var EXCEPTION_INT_DIVIDE_BY_ZERO  = 0xc0000094;
var EXCEPTION_ILLEGAL_INSTRUCTION = 0xc000001d;

// from resources.h
var TYPE_LPWSTR   = 0;
var TYPE_LPLPWSTR = 1;
var TYPE_LPSTR    = 2;
var TYPE_LPLPSTR  = 3;
var TYPE_DWORD    = 4;
var TYPE_LPDWORD  = 5;

// pointer value flags
var NULL_PTR      = 0;
var BAD_PTR       = 1; 
var FREE_PTR      = 2;
var UNINIT_PTR    = 3;

// data init flags
var INIT_NULL     = 0;
var INIT_SMILEY   = 1;
var INIT_HEXFF    = 2;
var INIT_GARBAGE  = 3;

// from winhttp.h
var WINHTTP_ACCESS_TYPE_DEFAULT_PROXY = 0;
var WINHTTP_ACCESS_TYPE_NO_PROXY      = 1;
var WINHTTP_ACCESS_TYPE_NAMED_PROXY   = 3;
var WINHTTP_FLAG_SYNC                 = 0x00000000; // not in header
var WINHTTP_FLAG_ASYNC                = 0x10000000;

var WINHTTP_CALLBACK_STATUS_RESOLVING_NAME          = 0x00000001;
var WINHTTP_CALLBACK_STATUS_NAME_RESOLVED           = 0x00000002;
var WINHTTP_CALLBACK_STATUS_CONNECTING_TO_SERVER    = 0x00000004;
var WINHTTP_CALLBACK_STATUS_CONNECTED_TO_SERVER     = 0x00000008;
var WINHTTP_CALLBACK_STATUS_SENDING_REQUEST         = 0x00000010;
var WINHTTP_CALLBACK_STATUS_REQUEST_SENT            = 0x00000020;
var WINHTTP_CALLBACK_STATUS_RECEIVING_RESPONSE      = 0x00000040;
var WINHTTP_CALLBACK_STATUS_RESPONSE_RECEIVED       = 0x00000080;
var WINHTTP_CALLBACK_STATUS_CLOSING_CONNECTION      = 0x00000100;
var WINHTTP_CALLBACK_STATUS_CONNECTION_CLOSED       = 0x00000200;
var WINHTTP_CALLBACK_STATUS_HANDLE_CREATED          = 0x00000400;
var WINHTTP_CALLBACK_STATUS_HANDLE_CLOSING          = 0x00000800;
var WINHTTP_CALLBACK_STATUS_DETECTING_PROXY         = 0x00001000;
var WINHTTP_CALLBACK_STATUS_REQUEST_COMPLETE        = 0x00002000;
var WINHTTP_CALLBACK_STATUS_REDIRECT                = 0x00004000;
var WINHTTP_CALLBACK_STATUS_INTERMEDIATE_RESPONSE   = 0x00008000;
var WINHTTP_CALLBACK_STATUS_SECURE_FAILURE          = 0x00010000;

var WINHTTP_CALLBACK_FLAG_RESOLVE_NAME              = (WINHTTP_CALLBACK_STATUS_RESOLVING_NAME | WINHTTP_CALLBACK_STATUS_NAME_RESOLVED);
var WINHTTP_CALLBACK_FLAG_CONNECT_TO_SERVER         = (WINHTTP_CALLBACK_STATUS_CONNECTING_TO_SERVER | WINHTTP_CALLBACK_STATUS_CONNECTED_TO_SERVER);
var WINHTTP_CALLBACK_FLAG_SEND_REQUEST              = (WINHTTP_CALLBACK_STATUS_SENDING_REQUEST | WINHTTP_CALLBACK_STATUS_REQUEST_SENT);
var WINHTTP_CALLBACK_FLAG_RECEIVE_RESPONSE          = (WINHTTP_CALLBACK_STATUS_RECEIVING_RESPONSE | WINHTTP_CALLBACK_STATUS_RESPONSE_RECEIVED);
var WINHTTP_CALLBACK_FLAG_CLOSE_CONNECTION          = (WINHTTP_CALLBACK_STATUS_CLOSING_CONNECTION | WINHTTP_CALLBACK_STATUS_CONNECTION_CLOSED);
var WINHTTP_CALLBACK_FLAG_HANDLES                   = (WINHTTP_CALLBACK_STATUS_HANDLE_CREATED | WINHTTP_CALLBACK_STATUS_HANDLE_CLOSING);
var WINHTTP_CALLBACK_FLAG_DETECTING_PROXY           = WINHTTP_CALLBACK_STATUS_DETECTING_PROXY;
var WINHTTP_CALLBACK_FLAG_REQUEST_COMPLETE          = WINHTTP_CALLBACK_STATUS_REQUEST_COMPLETE;
var WINHTTP_CALLBACK_FLAG_REDIRECT                  = WINHTTP_CALLBACK_STATUS_REDIRECT;
var WINHTTP_CALLBACK_FLAG_INTERMEDIATE_RESPONSE     = WINHTTP_CALLBACK_STATUS_INTERMEDIATE_RESPONSE;
var WINHTTP_CALLBACK_FLAG_SECURE_FAILURE            = WINHTTP_CALLBACK_STATUS_SECURE_FAILURE;
var WINHTTP_CALLBACK_FLAG_ALL_NOTIFICATIONS         = 0x0000000a; // not the same as the header file, but script doesn't like 0xffffffff
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\whttptst\src\whterror\methods.cxx ===
#include "common.h"

//-----------------------------------------------------------------------------
// IWHTWin32ErrorCode methods
//-----------------------------------------------------------------------------
HRESULT
WHTWin32ErrorCode::get_ErrorCode(VARIANT* ErrorCode)
{
  DEBUG_ENTER((
    DBG_WHTERROR,
    rt_hresult,
    "WHTWin32ErrorCode::get_ErrorCode",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

    if( ErrorCode )
    {
      DEBUG_TRACE(WHTERROR, ("error code: %d [%#x]", m_error, m_error));

      V_VT(ErrorCode) = VT_I4;
      V_I4(ErrorCode) = m_error;
    }
    else
    {
      hr = E_INVALIDARG;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
WHTWin32ErrorCode::get_ErrorString(VARIANT* ErrorString)
{
  DEBUG_ENTER((
    DBG_WHTERROR,
    rt_hresult,
    "WHTWin32ErrorCode::get_ErrorString",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

    if( ErrorString )
    {
      DEBUG_TRACE(WHTERROR, ("error string: %s", MapErrorToString(m_error)));
      
      V_VT(ErrorString)   = VT_BSTR;
      V_BSTR(ErrorString) = __ansitobstr(MapErrorToString(m_error));
    }
    else
    {
      hr = E_INVALIDARG;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
WHTWin32ErrorCode::get_IsException(VARIANT* IsException)
{
  DEBUG_ENTER((
    DBG_WHTERROR,
    rt_hresult,
    "WHTWin32ErrorCode::get_IsException",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

    if( IsException )
    {
      DEBUG_TRACE(WHTERROR, ("isexception: %s", TF(m_bIsException)));
      
      V_VT(IsException)   = VT_BOOL;
      V_BOOL(IsException) = m_bIsException ? VARIANT_TRUE : VARIANT_FALSE;
    }
    else
    {
      hr = E_INVALIDARG;
    }

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\whttptst\src\whterror\dispatch.cxx ===
#include "common.h"


//
// WARNING: do not modify these values. use disphash.exe to generate
//          new values.
//
DISPIDTABLEENTRY g_WHTWin32ErrorCodeDisptable[] =
{
  0x0010c129,   DISPID_WIN32ERRORCODE_ERRORCODE,    L"errorcode",
  0x0043266b,   DISPID_WIN32ERRORCODE_ERRORSTRING,  L"errorstring",
  0x004372a8,   DISPID_WIN32ERRORCODE_ISEXCEPTION,  L"isexception"
};

DWORD g_cWHTWin32ErrorCodeDisptable = (sizeof(g_WHTWin32ErrorCodeDisptable) / sizeof(DISPIDTABLEENTRY));


//-----------------------------------------------------------------------------
// IDispatch
//-----------------------------------------------------------------------------
HRESULT
__stdcall
WHTWin32ErrorCode::GetTypeInfoCount(UINT* pctinfo)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "WHTWin32ErrorCode::GetTypeInfoCount",
    "this=%#x; pctinfo=%#x",
    this,
    pctinfo
    ));

  HRESULT hr = S_OK;

    if( !pctinfo )
    {
      hr = E_POINTER;
    }
    else
    {
      *pctinfo = 1;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WHTWin32ErrorCode::GetTypeInfo(UINT index, LCID lcid, ITypeInfo** ppti)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "WHTWin32ErrorCode::GetTypeInfo",
    "this=%#x; index=%#x; lcid=%#x; ppti=%#x",
    this,
    index,
    lcid,
    ppti
    ));

  HRESULT hr   = S_OK;

  if( !ppti )
  {
    hr = E_POINTER;
  }
  else
  {
    if( index != 0 )
    {
      hr    = DISP_E_BADINDEX;
      *ppti = NULL;
    }
    else
    {
      hr = GetClassInfo(ppti);
    }
  }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WHTWin32ErrorCode::GetIDsOfNames(REFIID riid, LPOLESTR* arNames, UINT cNames, LCID lcid, DISPID* arDispId)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "WHTWin32ErrorCode::GetIDsOfNames",
    "this=%#x; riid=%s; arNames=%#x; cNames=%d; lcid=%#x; arDispId=%#x",
    this,
    MapIIDToString(riid),
    arNames,
    cNames,
    lcid,
    arDispId
    ));

  HRESULT hr = S_OK;
  UINT    n  = 0L;

  if( !IsEqualIID(riid, IID_NULL) )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  while( n < cNames )
  {
    arDispId[n] = GetDispidFromName(g_WHTWin32ErrorCodeDisptable, g_cWHTWin32ErrorCodeDisptable, arNames[n]);
    ++n;
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WHTWin32ErrorCode::Invoke(DISPID dispid, REFIID riid, LCID lcid, WORD flags, DISPPARAMS* pdp, VARIANT* pvr, EXCEPINFO* pei, UINT* pae)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "WHTWin32ErrorCode::Invoke",
    "this=%#x; dispid=%s; riid=%s; lcid=%#x; flags=%#x; pdp=%#x; pvr=%#x; pei=%#x; pae=%#x",
    this,
    MapDispidToString(dispid),
    MapIIDToString(riid),
    lcid,
    flags,
    pdp, pvr,
    pei, pae
    ));

  HRESULT hr = S_OK;

  hr = ValidateDispatchArgs(riid, pdp, pvr, pae);

    if( FAILED(hr) )
      goto quit;

  switch( dispid )
  {
    case DISPID_WIN32ERRORCODE_ERRORCODE :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_PROPERTYGET, FALSE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 0, FALSE, 0);

          if( SUCCEEDED(hr) )
          {
            hr = get_ErrorCode(pvr);
          }
        }
      }
      break;

    case DISPID_WIN32ERRORCODE_ERRORSTRING :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_PROPERTYGET, FALSE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 0, FALSE, 0);

          if( SUCCEEDED(hr) )
          {
            hr = get_ErrorString(pvr);
          }
        }
      }
      break;

    case DISPID_WIN32ERRORCODE_ISEXCEPTION :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_PROPERTYGET, FALSE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 0, FALSE, 0);

          if( SUCCEEDED(hr) )
          {
            hr = get_IsException(pvr);
          }
        }
      }
      break;

    default : hr = DISP_E_MEMBERNOTFOUND;
  }

quit:

  if( FAILED(hr) )
  {
    hr = HandleDispatchError(L"WHTWin32ErrorCode", pei, hr);
  }

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\whttptst\src\whterror\whterror.cxx ===
#include "common.h"

extern HINSTANCE g_hGlobalDllInstance;
LPCWSTR          g_wszWHTWin32ErrorCodeObjectName = L"WHTWin32ErrorCode";

//-----------------------------------------------------------------------------
// WHTWin32ErrorCode methods
//-----------------------------------------------------------------------------
WHTWin32ErrorCode::WHTWin32ErrorCode(DWORD error):
  m_cRefs(0),
  m_pti(NULL),
  m_error(error),
  m_bIsException(FALSE)
{
  DEBUG_TRACE(WHTERROR, ("WHTWin32ErrorCode [%#x] created", this));
}


WHTWin32ErrorCode::~WHTWin32ErrorCode()
{
  SAFERELEASE(m_pti);
  DEBUG_TRACE(WHTERROR, ("WHTWin32ErrorCode [%#x] deleted", this));
}


HRESULT
WHTWin32ErrorCode::Create(DWORD error, IWHTWin32ErrorCode** ppwec)
{
  DEBUG_ENTER((
    DBG_INITIALIZE,
    rt_hresult,
    "WHTWin32ErrorCode::Create",
    "error=%s; ppwec=%#x",
    MapErrorToString(error),
    ppwec
    ));

  HRESULT   hr      = S_OK;
  PWHTERROR pwhterr = NULL;

  if( ppwec )
  {
    pwhterr = new WHTERROR(error);

    if( pwhterr )
    {
      hr = pwhterr->_Initialize();

      if( SUCCEEDED(hr) )
      {
        hr = pwhterr->QueryInterface(IID_IWHTWin32ErrorCode, (void**) ppwec);
      }
    }
    else
    {
      hr = E_OUTOFMEMORY;
    }
  }
  else
  {
    hr = E_POINTER;
  }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
WHTWin32ErrorCode::_Initialize(void)
{
  DEBUG_ENTER((
    DBG_INITIALIZE,
    rt_hresult,
    "WHTWin32ErrorCode::_Initialize",
    "this=%#x",
    this
    ));

  HRESULT   hr  = S_OK;
  WCHAR*    buf = NULL;
  ITypeLib* ptl = NULL;

  buf = new WCHAR[MAX_PATH];

  if( buf )
  {
    if( GetModuleFileName(g_hGlobalDllInstance, buf, MAX_PATH) )
    {
      hr = LoadTypeLib(buf, &ptl);

      if( SUCCEEDED(hr) )
      {
        hr = GetTypeInfoFromName(g_wszWHTWin32ErrorCodeObjectName, ptl, &m_pti);
      }
    }
    else
    {
      hr = E_FAIL;
    }
  }

  SAFERELEASE(ptl);
  SAFEDELETEBUF(buf);

  m_bIsException = _IsException(m_error);

  DEBUG_LEAVE(hr);
  return hr;
}


BOOL
WHTWin32ErrorCode::_IsException(int e)
{
  switch( e )
  {
    case EXCEPTION_ACCESS_VIOLATION         :
    case EXCEPTION_DATATYPE_MISALIGNMENT    :
    case EXCEPTION_BREAKPOINT               :
    case EXCEPTION_SINGLE_STEP              :
    case EXCEPTION_ARRAY_BOUNDS_EXCEEDED    :
    case EXCEPTION_FLT_DENORMAL_OPERAND     :
    case EXCEPTION_FLT_DIVIDE_BY_ZERO       :
    case EXCEPTION_FLT_INEXACT_RESULT       :
    case EXCEPTION_FLT_INVALID_OPERATION    :
    case EXCEPTION_FLT_OVERFLOW             :
    case EXCEPTION_FLT_STACK_CHECK          :
    case EXCEPTION_FLT_UNDERFLOW            :
    case EXCEPTION_INT_DIVIDE_BY_ZERO       :
    case EXCEPTION_INT_OVERFLOW             :
    case EXCEPTION_PRIV_INSTRUCTION         :
    case EXCEPTION_IN_PAGE_ERROR            :
    case EXCEPTION_ILLEGAL_INSTRUCTION      :
    case EXCEPTION_NONCONTINUABLE_EXCEPTION :
    case EXCEPTION_STACK_OVERFLOW           :
    case EXCEPTION_INVALID_DISPOSITION      :
    case EXCEPTION_GUARD_PAGE               :
    case EXCEPTION_INVALID_HANDLE           : return TRUE;

    default : return FALSE;
  }
}


//-----------------------------------------------------------------------------
// IUnknown methods
//-----------------------------------------------------------------------------
HRESULT
__stdcall
WHTWin32ErrorCode::QueryInterface(REFIID riid, void** ppv)
{
  DEBUG_ENTER((
    DBG_REFCOUNT,
    rt_hresult,
    "WHTWin32ErrorCode::QueryInterface",
    "this=%#x; riid=%s; ppv=%#x",
    this,
    MapIIDToString(riid),
    ppv
    ));

  HRESULT hr = S_OK;

    if( ppv )
    {
      if(
        IsEqualIID(riid, IID_IUnknown)           ||
        IsEqualIID(riid, IID_IDispatch)          ||
        IsEqualIID(riid, IID_IWHTWin32ErrorCode)
        )
      {
        *ppv = static_cast<IWHTWin32ErrorCode*>(this);
      }
      else if( IsEqualIID(riid, IID_IProvideClassInfo) )
      {
        *ppv = static_cast<IProvideClassInfo*>(this);
      }
      else
      {
        *ppv = NULL;
        hr   = E_NOINTERFACE;
      }
    }
    else
    {
      hr = E_POINTER;
    }

    if( SUCCEEDED(hr) )
    {
      DEBUG_TRACE(REFCOUNT, ("returning %s pointer", MapIIDToString(riid)));
      reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    }

  DEBUG_LEAVE(hr);
  return hr;
}


ULONG
__stdcall
WHTWin32ErrorCode::AddRef(void)
{
  InterlockedIncrement(&m_cRefs);
  DEBUG_ADDREF("WHTWin32ErrorCode", m_cRefs);
  return m_cRefs;
}


ULONG
__stdcall
WHTWin32ErrorCode::Release(void)
{
  InterlockedDecrement(&m_cRefs);
  DEBUG_RELEASE("WHTWin32ErrorCode", m_cRefs);

  if( m_cRefs == 0 )
  {
    DEBUG_FINALRELEASE("WHTWin32ErrorCode");
    delete this;
    return 0;
  }

  return m_cRefs;
}


//-----------------------------------------------------------------------------
// IProvideClassInfo methods
//-----------------------------------------------------------------------------
HRESULT
__stdcall
WHTWin32ErrorCode::GetClassInfo(ITypeInfo** ppti)
{
  DEBUG_ENTER((
    DBG_WHTERROR,
    rt_hresult,
    "WHTWin32ErrorCode::GetClassInfo",
    "this=%#x; ppti=%#x",
    this,
    ppti
    ));

  HRESULT hr = S_OK;

    if( ppti )
    {
      m_pti->AddRef();
      *ppti = m_pti;
    }
    else
    {
      hr = E_POINTER;
    }

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\whttptst\src\winhttptest\classfactory.cxx ===
#include "common.h"

//-----------------------------------------------------------------------------
// ClassFactory methods
//-----------------------------------------------------------------------------
ClassFactory::ClassFactory():
  m_cRefs(0),
  m_cLocks(0)
{
  DEBUG_TRACE(FACTORY, ("ClassFactory [%#x] created", this));
}


ClassFactory::~ClassFactory()
{
  DEBUG_TRACE(FACTORY, ("ClassFactory [%#x] deleted", this));
}


HRESULT
ClassFactory::Create(REFIID clsid, REFIID riid, void** ppv)
{
  DEBUG_ENTER((
    DBG_FACTORY,
    rt_hresult,
    "ClassFactory::Create",
    "clsid=%s; riid=%s; ppv=%#x",
    MapIIDToString(clsid),
    MapIIDToString(riid),
    ppv
    ));

  HRESULT     hr  = S_OK;
  PCLSFACTORY pcf = NULL;

  if( !ppv )
  {
    hr = E_POINTER;
    goto quit;
  }

  if( !IsEqualIID(clsid, CLSID_WinHttpTest) )
  {
    hr   = CLASS_E_CLASSNOTAVAILABLE;
    *ppv = NULL;
    goto quit;
  }

  if( pcf = new CLSFACTORY )
  {
    hr = pcf->QueryInterface(riid, ppv);

    if( FAILED(hr) )
    {
      delete pcf;
    }
  }
  else
  {
    hr = E_OUTOFMEMORY;
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


//-----------------------------------------------------------------------------
// IUnknown methods
//-----------------------------------------------------------------------------
HRESULT
__stdcall
ClassFactory::QueryInterface(REFIID riid, void** ppv)
{
  DEBUG_ENTER((
    DBG_FACTORY,
    rt_hresult,
    "ClassFactory::QueryInterface",
    "this=%#x; riid=%s; ppv=%#x",
    this,
    MapIIDToString(riid),
    ppv
    ));

  HRESULT hr = S_OK;

    if( ppv )
    {
      if( IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IClassFactory) )
      {
        *ppv = static_cast<IClassFactory*>(this);
      }
      else
      {
        *ppv = NULL;
        hr   = E_NOINTERFACE;
      }
    }
    else
    {
      hr = E_POINTER;
    }

    if( SUCCEEDED(hr) )
    {
      DEBUG_TRACE(FACTORY, ("returning %s pointer", MapIIDToString(riid)));
      reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    }

  DEBUG_LEAVE(hr);
  return hr;
}


ULONG
__stdcall
ClassFactory::AddRef(void)
{
  InterlockedIncrement(&m_cRefs);
  DEBUG_ADDREF("ClassFactory", m_cRefs);
  return m_cRefs;
}


ULONG
__stdcall
ClassFactory::Release(void)
{
  InterlockedDecrement(&m_cRefs);
  DEBUG_RELEASE("ClassFactory", m_cRefs);

  if( (m_cRefs == 0) && (m_cLocks == 0) )
  {
    DEBUG_FINALRELEASE("ClassFactory");
    delete this;
    return 0;
  }

  return m_cRefs;
}


//-----------------------------------------------------------------------------
// IClassFactory methods
//-----------------------------------------------------------------------------
HRESULT
__stdcall
ClassFactory::CreateInstance(IUnknown* outer, REFIID riid, void** ppv)
{
  DEBUG_ENTER((
    DBG_FACTORY,
    rt_hresult,
    "ClassFactory::CreateInstance",
    "this=%#x; outer=%#x; riid=%s; ppv=%#x",
    this,
    outer,
    MapIIDToString(riid),
    ppv
    ));

  HRESULT hr = S_OK;

  if( !ppv )
  {
    hr = E_POINTER;
    goto quit;
  }

  if( outer )
  {
    hr   = CLASS_E_NOAGGREGATION;
    *ppv = NULL;
    goto quit;
  }

  hr = WHTTPTST::Create(riid, ppv);

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
ClassFactory::LockServer(BOOL lock)
{
  HRESULT hr = S_OK;

  lock ? InterlockedIncrement(&m_cLocks) : InterlockedDecrement(&m_cLocks);

  DEBUG_TRACE(FACTORY, ("lock count now: %d", m_cLocks));

  if( (m_cRefs == 0) && (m_cLocks == 0) )
  {
    DEBUG_TRACE(FACTORY, ("ClassFactory [%#x]: final lock released!", this));
    delete this;
    return hr;
  }

  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\whttptst\src\winhttptest\dispatch.cxx ===
#include "common.h"

//
// WARNING: do not modify these values. use disphash.exe to generate
//          new values.
//
DISPIDTABLEENTRY g_WinHttpTestDisptable[] =
{
  0x0046cf6d,   DISPID_WINHTTPTEST_OPEN,                    L"winhttpopen",
  0x0235c801,   DISPID_WINHTTPTEST_CONNECT,                 L"winhttpconnect",
  0x235df173,   DISPID_WINHTTPTEST_OPENREQUEST,             L"winhttpopenrequest",
  0x235dc932,   DISPID_WINHTTPTEST_SENDREQUEST,             L"winhttpsendrequest",
  0x35c58a48,   DISPID_WINHTTPTEST_RECEIVERESPONSE,         L"winhttpreceiveresponse",
  0x235a3600,   DISPID_WINHTTPTEST_CLOSEHANDLE,             L"winhttpclosehandle",
  0x046ba62e,   DISPID_WINHTTPTEST_READDATA,                L"winhttpreaddata",
  0x08d85ebe,   DISPID_WINHTTPTEST_WRITEDATA,               L"winhttpwritedata",
  0xafa429a3,   DISPID_WINHTTPTEST_QUERYDATAAVAILABLE,      L"winhttpquerydataavailable",
  0x235fbc85,   DISPID_WINHTTPTEST_QUERYOPTION,             L"winhttpqueryoption",
  0x08d7d1ef,   DISPID_WINHTTPTEST_SETOPTION,               L"winhttpsetoption",
  0x235ebb0a,   DISPID_WINHTTPTEST_SETTIMEOUTS,             L"winhttpsettimeouts",
  0xd5d831c6,   DISPID_WINHTTPTEST_ADDREQUESTHEADERS,       L"winhttpaddrequestheaders",
  0x1aef45ab,   DISPID_WINHTTPTEST_SETCREDENTIALS,          L"winhttpsetcredentials",
  0x6bec0214,   DISPID_WINHTTPTEST_QUERYAUTHSCHEMES,        L"winhttpqueryauthschemes",
  0x46bee2b5,   DISPID_WINHTTPTEST_QUERYHEADERS,            L"winhttpqueryheaders",
  0xaf28b192,   DISPID_WINHTTPTEST_TIMEFROMSYSTEMTIME,      L"winhttptimefromsystemtime",
  0x6bd39d0c,   DISPID_WINHTTPTEST_TIMETOSYSTEMTIME,        L"winhttptimetosystemtime",
  0x046b5b57,   DISPID_WINHTTPTEST_CRACKURL,                L"winhttpcrackurl",
  0x08d6a4ba,   DISPID_WINHTTPTEST_CREATEURL,               L"winhttpcreateurl",
  0xd7a6f0d4,   DISPID_WINHTTPTEST_SETSTATUSCALLBACK,       L"winhttpsetstatuscallback",
  0x04129fd7,   DISPID_WINHTTPTEST_HELPER_GETBUFFEROBJECT,  L"getbufferobject",
  0x083d2b72,   DISPID_WINHTTPTEST_HELPER_GETURLCOMPONENTS, L"geturlcomponents",
  0x01087c3b,   DISPID_WINHTTPTEST_HELPER_GETSYSTEMTIME,    L"getsystemtime",
  0x0082cf2b,   DISPID_WINHTTPTEST_HELPER_GETLASTERROR,     L"getlasterror"
};

DWORD g_cWinHttpTestDisptable = (sizeof(g_WinHttpTestDisptable) / sizeof(DISPIDTABLEENTRY));

//-----------------------------------------------------------------------------
// IDispatch
//-----------------------------------------------------------------------------
HRESULT
__stdcall
WinHttpTest::GetTypeInfoCount(UINT* pctinfo)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "WinHttpTest::GetTypeInfoCount",
    "this=%#x; pctinfo=%#x",
    this,
    pctinfo
    ));

  HRESULT hr = S_OK;

    if( !pctinfo )
    {
      hr = E_POINTER;
    }
    else
    {
      *pctinfo = 1;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WinHttpTest::GetTypeInfo(UINT index, LCID lcid, ITypeInfo** ppti)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "WinHttpTest::GetTypeInfo",
    "this=%#x; index=%#x; lcid=%#x; ppti=%#x",
    this,
    index,
    lcid,
    ppti
    ));

  HRESULT hr   = S_OK;

  if( !ppti )
  {
    hr = E_POINTER;
  }
  else
  {
    if( index != 0 )
    {
      hr    = DISP_E_BADINDEX;
      *ppti = NULL;
    }
    else
    {
      hr = GetClassInfo(ppti);
    }
  }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WinHttpTest::GetIDsOfNames(REFIID riid, LPOLESTR* arNames, UINT cNames, LCID lcid, DISPID* arDispId)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "WinHttpTest::GetIDsOfNames",
    "this=%#x; riid=%s; arNames=%#x; cNames=%d; lcid=%#x; arDispId=%#x",
    this,
    MapIIDToString(riid),
    arNames,
    cNames,
    lcid,
    arDispId
    ));

  HRESULT hr = S_OK;
  UINT    n  = 0L;

  if( !IsEqualIID(riid, IID_NULL) )
  {
    hr = E_INVALIDARG;
    goto quit;
  }

  while( n < cNames )
  {
    arDispId[n] = GetDispidFromName(g_WinHttpTestDisptable, g_cWinHttpTestDisptable, arNames[n]);
    ++n;
  }

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WinHttpTest::Invoke(DISPID dispid, REFIID riid, LCID lcid, WORD flags, DISPPARAMS* pdp, VARIANT* pvr, EXCEPINFO* pei, UINT* pae)
{
  DEBUG_ENTER((
    DBG_DISPATCH,
    rt_hresult,
    "WinHttpTest::Invoke",
    "this=%#x; dispid=%s; riid=%s; lcid=%#x; flags=%#x; pdp=%#x; pvr=%#x; pei=%#x; pae=%#x",
    this,
    MapDispidToString(dispid),
    MapIIDToString(riid),
    lcid,
    flags,
    pdp, pvr,
    pei, pae
    ));

  HRESULT hr = S_OK;

  hr = ValidateDispatchArgs(riid, pdp, pvr, pae);

    if( FAILED(hr) )
      goto quit;

  switch( dispid )
  {
    case DISPID_WINHTTPTEST_OPEN :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, TRUE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 5, FALSE, 0);

          if( SUCCEEDED(hr) )
          {
            hr = WinHttpOpen(
                   pdp->rgvarg[4],
                   pdp->rgvarg[3],
                   pdp->rgvarg[2],
                   pdp->rgvarg[1],
                   pdp->rgvarg[0],
                   pvr
                   );
          }
        }
      }
      break;

    case DISPID_WINHTTPTEST_CONNECT :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, TRUE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 4, FALSE, 0);

          if( SUCCEEDED(hr) )
          {
            hr = WinHttpConnect(
                   pdp->rgvarg[3],
                   pdp->rgvarg[2],
                   pdp->rgvarg[1],
                   pdp->rgvarg[0],
                   pvr
                   );
          }
        }
      }
      break;

    case DISPID_WINHTTPTEST_OPENREQUEST :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, TRUE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 7, FALSE, 0);

          if( SUCCEEDED(hr) )
          {
            hr = WinHttpOpenRequest(
                   pdp->rgvarg[6],
                   pdp->rgvarg[5],
                   pdp->rgvarg[4],
                   pdp->rgvarg[3],
                   pdp->rgvarg[2],
                   pdp->rgvarg[1],
                   pdp->rgvarg[0],
                   pvr
                   );
          }
        }
      }
      break;

    case DISPID_WINHTTPTEST_SENDREQUEST :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, TRUE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 7, FALSE, 0);

          if( SUCCEEDED(hr) )
          {
            hr = WinHttpSendRequest(
                   pdp->rgvarg[6],
                   pdp->rgvarg[5],
                   pdp->rgvarg[4],
                   pdp->rgvarg[3],
                   pdp->rgvarg[2],
                   pdp->rgvarg[1],
                   pdp->rgvarg[0],
                   pvr
                   );
          }
        }
      }
      break;

    case DISPID_WINHTTPTEST_CLOSEHANDLE :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, TRUE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 1, FALSE, 0);

          if( SUCCEEDED(hr) )
          {
            hr = WinHttpCloseHandle(
                   pdp->rgvarg[0],
                   pvr
                   );
          }
        }
      }
      break;

    case DISPID_WINHTTPTEST_SETSTATUSCALLBACK :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, TRUE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 4, FALSE, 0);

          if( SUCCEEDED(hr) )
          {
            hr = WinHttpSetStatusCallback(
                   pdp->rgvarg[3],
                   pdp->rgvarg[2],
                   pdp->rgvarg[1],
                   pdp->rgvarg[0],
                   pvr
                   );
          }
        }
      }
      break;

    case DISPID_WINHTTPTEST_HELPER_GETURLCOMPONENTS :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, TRUE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 1, FALSE, 0);

          if( SUCCEEDED(hr) )
          {
            hr = HelperGetUrlComponents(
                   pdp->rgvarg[0],
                   pvr
                   );
          }
        }
      }
      break;

    case DISPID_WINHTTPTEST_HELPER_GETLASTERROR :
      {
        hr = ValidateInvokeFlags(flags, DISPATCH_METHOD, TRUE);

        if( SUCCEEDED(hr) )
        {
          hr = ValidateArgCount(pdp, 0, FALSE, 0);

          if( SUCCEEDED(hr) )
          {
            hr = HelperGetLastError(pvr);
          }
        }
      }
      break;
    
    default : hr = DISP_E_MEMBERNOTFOUND;
  }

quit:

  if( FAILED(hr) )
  {
    hr = HandleDispatchError(L"WinHttpTest", pei, hr);
  }

  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\wininet.inc ===
!IF 0

Copyright (c) 1994  Microsoft Corporation

Module Name:

    wininet.inc

Abstract:

    Common makefile contents for wininet project

Author:

    Richard L Firth (rfirth) 10-Feb-1996

Revision History:

    10-Feb-1996 rfirth
        Created

!ENDIF

!IFNDEF SDKINC
SDKINC=$(SDK_INC_PATH)
!ENDIF

!IFDEF LIBDIR
!ERROR LIBDIR already defined - choose new name
!ENDIF

LIBDIR=..\lib\$(_OBJ_DIR)

#
# if TARGETPATH is not defined (in the paths that build libraries) then this
# is the default target path
#

!IFNDEF TARGETPATH
TARGETPATH=$(LIBDIR)
TARGETTYPE=LIBRARY
!ENDIF

#
# what it is that we're building
#

MAJORCOMP=winhttpx

USE_NOLIBS=1
USE_MSVCRT=1
NO_NTDLL=1

#
# compiler definitions
#

C_DEFINES=$(C_DEFINES) -D_WINHTTP_INTERNAL_  -DCOMPILING_ROCKALL_LIBRARY

# Get same version from NT or IE builds.
C_DEFINES=$(C_DEFINES)

!IFDEF USE_ICECAP
C_DEFINES=$(C_DEFINES) -DICECAP
!ENDIF

#
# Set debugging level
#

!IF "$(NTDEBUG)" != "" && "$(NTDEBUG)" != "retail" && "$(NTDEBUG)" != "ntsdnodbg"
C_DEFINES=$(C_DEFINES) -DENABLE_DEBUG -DINET_DEBUG=1

#
# remove maximal diagnostics for customer debug version based on environment
# variable
#

!IF "$(FULL_DEBUG)" != ""
C_DEFINES=$(C_DEFINES) -DUSE_DEBUG_MEMORY
!ELSE
C_DEFINES=$(C_DEFINES) -DRETAIL_LOGGING
!IF "$(BUILD_PRODUCT)" != "NT"
C_DEFINES=$(C_DEFINES) -DDISABLE_ASSERTS
!ENDIF
!ENDIF

!ELSE IF "$(ALMOSTRETAIL)" != ""
C_DEFINES=$(C_DEFINES) -DENABLE_DEBUG
!ENDIF

!IF "$(WIN64)" == "0" && "$(FULL_DEBUG)"==""
C_DEFINES=$(C_DEFINES) -DUSE_ROCKALL
!ENDIF

#
# performance diagnostics
#

!IF "$(PERF_BUILD)" != ""
C_DEFINES=$(C_DEFINES) -DUSE_PERF_DIAG
!ENDIF

!if !defined(CLEANINF_FLAGS)
# Cleaninf flags
CLEANINF_FLAGS  = -w
!endif

#
# Linker flags
#

!if "$(BUILD_PRODUCT)" == "IE"
USE_WIN98OPT=1
!endif

# Cleaninf utility
CLEANINF        = cleaninf.exe $(CLEANINF_FLAGS)

#
# Do this to assure that we run on NT 4.0 and Win95, even with
# NT5/Memphis headers.
#

WIN32_WINNT_VERSION=0x0400
WIN32_WIN95_VERSION=0x0400

#
# compiler warning flags
#

MSC_WARNING_LEVEL=/W3 /WX

#
# precompiled header options
#

!IFNDEF WININET_PCH

PRECOMPILED_OPTION=/Fp..\inc\$(_OBJ_DIR)\*\wininetp.pch /Yuwininetp.h
PRECOMPILED_CXX=1

!ENDIF

CONDITIONAL_INCLUDES = \
        winwlm.h \
        macwin32.h \
        ia64inst.h \
        pshpck16.h \
        rpcerr.h \
        rpcmac.h \
        macname1.h \
        macpub.h \
        macapi.h \
        macname2.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\api\certcach.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    certcach.cxx

Abstract:

    Contains class implementation for certificate cache object.
    This object will hold various Certificate entries.

    Contents:
        SECURITY_CACHE_LIST_ENTRY::SECURITY_CACHE_LIST_ENTRY
        SECURITY_CACHE_LIST_ENTRY::~SECURITY_CACHE_LIST_ENTRY
        SECURITY_CACHE_LIST_ENTRY::AddRef
        SECURITY_CACHE_LIST_ENTRY::Release
        SECURITY_CACHE_LIST_ENTRY::Clear
        SECURITY_CACHE_LIST::Find
        SECURITY_CACHE_LIST::Add
        SECURITY_CACHE_LIST::ClearList

    TODO:  Add Cert validation.  What if Cert is given but different?

Author:

    Arthur L Bierer (arthurbi) 20-Apr-1996

Revision History:

    20-Apr-1996 arthurbi
        Created

--*/
#include <wininetp.h>

//
// private manifests
//

#define MAX_CERT_CACHE_CERTS    16

//
// private types
//

//
// SECURITY_CACHE_LIST_ENTRY member functions
//


SECURITY_CACHE_LIST_ENTRY::SECURITY_CACHE_LIST_ENTRY(
    IN LPSTR lpszHostName
    )

/*++

Routine Description:

    SECURITY_CACHE_LIST_ENTRY constructor. Create object; don't add it to list

Arguments:

    lpszHostName    - name of host for which this cache entry created

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "SECURITY_CACHE_LIST_ENTRY::SECURITY_CACHE_LIST_ENTRY",
                 "%q",
                 lpszHostName
                 ));

#if INET_DEBUG
    _List.Flink = _List.Blink = NULL;
#endif
    _cRef = 1;
    _fInCache = FALSE;
    _ServerName = lpszHostName;
    ZeroMemory(&_CertInfo, sizeof(_CertInfo));
    _dwSecurityFlags = 0;
    _dwStatusFlags = 0;
    _pCertContextArray = NULL;

#if INET_DEBUG
    m_Signature = 0x454c4353;   // 'SCLE'
#endif

    DEBUG_LEAVE(0);
}


SECURITY_CACHE_LIST_ENTRY::~SECURITY_CACHE_LIST_ENTRY()

/*++

Routine Description:

    SECURITY_CACHE_LIST_ENTRY destructor.

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "~SECURITY_CACHE_LIST_ENTRY",
                 "{%#x [%q]}",
                 this,
                 _ServerName.StringAddress()
                 ));

    INET_ASSERT((_List.Flink == NULL) && (_List.Blink == NULL));

    Clear();

    DEBUG_LEAVE(0);
}


LONG
SECURITY_CACHE_LIST_ENTRY::AddRef(
    VOID
    )

/*++

Routine Description:

    Increment reference count of SECURITY_CACHE_LIST_ENTRY

Arguments:

    None.

Return Value:

    LONG    - reference count after increment

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 Int,
                 "SECURITY_CACHE_LIST_ENTRY::AddRef",
                 "{%#x [%q, %d]}",
                 this,
                 _ServerName.StringAddress(),
                 _cRef
                 ));

    InterlockedIncrement(&_cRef);

    DEBUG_LEAVE(_cRef);

    return _cRef;
}


LONG
SECURITY_CACHE_LIST_ENTRY::Release(
    VOID
    )

/*++

Routine Description:

    Decrement reference count and destroy object if (<=) zero

Arguments:

    None.

Return Value:

    LONG    - reference count after decrement

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 Int,
                 "SECURITY_CACHE_LIST_ENTRY::Release",
                 "{%q [%d]}",
                 _ServerName.StringAddress(),
                 _cRef
                 ));

    LONG cRet;

    if (0 >= (cRet = InterlockedDecrement(&_cRef))) {
        delete this;
    }

    DEBUG_LEAVE(cRet);

    return cRet;
}


VOID
SECURITY_CACHE_LIST_ENTRY::Clear()

/*++

Routine Description:

    Clear out SECURITY_CACHE_LIST_ENTRY

Arguments:

    Clear   -

Return Value:

    None.

--*/

{
    if (_CertInfo.pCertificate != NULL)
    {
        SAFE_WRAP_REVERT_USER_VOID(CertFreeCertificateContext, (_CertInfo.pCertificate));
        _CertInfo.pCertificate = NULL;
    }

    ZeroMemory(&_CertInfo, sizeof(_CertInfo));
    _CertInfo.dwSize = sizeof(_CertInfo);

    _dwSecurityFlags = 0;
    _dwStatusFlags = 0;
    _ServerName = NULL;
    if( _pCertContextArray )
    {
        delete _pCertContextArray;
        _pCertContextArray = NULL;
    }
}

//
// SECURITY_CACHE_LIST member functions
//


VOID
SECURITY_CACHE_LIST::ClearList(
    VOID
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "SECURITY_CACHE_LIST::ClearList",
                 NULL
                 ));

    if (!LockSerializedList(&_List))
    {
        DEBUG_PRINT(OBJECTS,
                    ERROR,
                    ("Failed to obtain lock -- SECURITY_CACHE_LIST potentially leaked\n"
                    ));
        goto quit;
    }

    while (!IsSerializedListEmpty(&_List)) {

        SECURITY_CACHE_LIST_ENTRY * CacheEntry;

        //
        // remove the PROXY_SERVER_LIST_ENTRY at the head of the serialized
        // list
        //

        LPVOID entry = SlDequeueHead(&_List);

        //
        // entry should not be NULL - IsSerializedListEmpty() told us we
        // could expect something
        //

        INET_ASSERT(entry != NULL);

        //
        // get the address of the object (should be the same as entry) and
        // delete it
        //

        CacheEntry = CONTAINING_RECORD(entry, SECURITY_CACHE_LIST_ENTRY, _List);

        DEBUG_PRINT(OBJECTS,
                    INFO,
                    ("releasing %q (%d)\n",
                    CacheEntry->_ServerName.StringAddress(),
                    CacheEntry->_cRef
                    ));

        CacheEntry->Release();
    }

    UnlockSerializedList(&_List);

quit:
    DEBUG_LEAVE(0);
}


DWORD
SECURITY_CACHE_LIST::Add(
    IN SECURITY_CACHE_LIST_ENTRY * entry
    )

/*++

Routine Description:

    Adds a CertInfo Structure to the list front of the list.

Arguments:

    lpszHost    - Hostname to add.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "SECURITY_CACHE_LIST::Add",
                 "%#x [%q, %d]",
                 entry,
                 entry ? entry->_ServerName.StringAddress() : "",
                 entry ? entry->_cRef : 0
                 ));

    DWORD error = ERROR_SUCCESS;

    INET_ASSERT(entry != NULL);

    if (entry != NULL) {
        if (LockSerializedList(&_List))
        {

            //
            // If we've grown too much, nuke the oldest one.
            //

            if (ElementsOnSerializedList(&_List) >= MAX_CERT_CACHE_CERTS) {

                SECURITY_CACHE_LIST_ENTRY *pOld;
                LPVOID old_entry = SlDequeueTail(&_List);

                INET_ASSERT(old_entry != NULL);

                pOld = CONTAINING_RECORD(old_entry, SECURITY_CACHE_LIST_ENTRY, _List);

                //
                // entry should not be NULL - IsSerializedListEmpty() told us we
                // could expect something
                //

                pOld->_fInCache = FALSE;

                //
                // Clean Our old object, and reinstatiate with a new name.
                //

                pOld->Release();
            }
            if (InsertAtHeadOfSerializedList(&_List, &entry->_List)) {
                entry->AddRef();
                entry->_fInCache = TRUE;
            }
            UnlockSerializedList(&_List);
        }
        else
            error = ERROR_NOT_ENOUGH_MEMORY;
    }

    DEBUG_LEAVE(error);

    return error;
}


SECURITY_CACHE_LIST_ENTRY *
SECURITY_CACHE_LIST::Find(
    IN LPSTR lpszHost
    )

/*++

Routine Description:

    Searches the linked list for the Cert, and returns
    the found entry, or NULL if not found.

Arguments:

    lpszHost    - Hostname to search on.

Return Value:

    CERT_CACHE_LIST_ENTRY *
        Success - Pointer to found entry.

        Failure - NULL, not found.

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Pointer,
                 "SECURITY_CACHE_LIST::Find",
                 "%q",
                 lpszHost
                 ));

    SECURITY_CACHE_LIST_ENTRY * info = NULL;

    //
    // BUGBUG need to validate against Server Certifcate on every
    //  connection, this Find only validates by Hostname.
    //  What about DNS spoofing?  Won't we be hosed?
    //

    //
    // TODO if found, need to push to front of list.
    //

    if (LockSerializedList(&_List))
    {
        for (PLIST_ENTRY entry = HeadOfSerializedList(&_List);
            entry != (PLIST_ENTRY)SlSelf(&_List);
            entry = entry->Flink)
        {
            info = CONTAINING_RECORD(entry, SECURITY_CACHE_LIST_ENTRY, _List);

            //
            // check to see if they match.
            //

            if (info->_ServerName.Stricmp(lpszHost) == 0) {
                info->AddRef();
                break; // match.
            }
            info = NULL;
        }
        UnlockSerializedList(&_List);
    }

    DEBUG_LEAVE(info);

    return info;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\api\cliauth.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    cliauth.cxx

Abstract:

    Contains Schannel/SSPI specific code for handling Client Authenication
    multiplexed between several asynchronous requests using fibers

    Contents:
        CliAuthRefreshCredential
        CliAuthSelectCredential

Author:

    Arthur L Bierer (arthurbi) 13-Jun-1996

Environment:

    Win32 user-mode DLL

Revision History:

    13-Jun-1996 arthurbi
        Created, based on orginal code from a-petesk.

--*/

#include <wininetp.h>


extern "C" {

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntsecapi.h>

}


CERT_CONTEXT_ARRAY::CERT_CONTEXT_ARRAY()
{
    _error           = ERROR_SUCCESS;
    _iSelected  = -1;
    _ppCertContexts    = (PCCERT_CONTEXT *)
                        ALLOCATE_MEMORY(LMEM_FIXED,
                            sizeof(PCERT_CONTEXT)* CERT_CONTEXT_ARRAY_ALLOC_UNIT);

    if ( _ppCertContexts == NULL ) {
        _error = GetLastError();
    }

    _cAlloced  = CERT_CONTEXT_ARRAY_ALLOC_UNIT;
    _cCertContexts     = 0;

    ClearCreds(_hCreds);
    _cs.Init();
}

void CERT_CONTEXT_ARRAY::Reset(void)
{
    if ( _ppCertContexts )
    {
        for ( DWORD i = 0; i < _cCertContexts; i++ )
        {
            INET_ASSERT(_ppCertContexts[i]);
            WRAP_REVERT_USER_VOID(CertFreeCertificateContext, (_ppCertContexts[i]));
        }
    }
    _cCertContexts = 0;
    
    // It is important that this Free is guarded by a try except.
    // These objects get freed up at dll unload time and there is a circular
    // dependency between winient and schannel which can cause schannel to 
    // get unloaded. If that is the case we could fault here.
    if (!IsCredClear(_hCreds))
    {
        SAFE_WRAP_REVERT_USER_VOID(g_FreeCredentialsHandle, (&_hCreds));
    }
}


CERT_CONTEXT_ARRAY::~CERT_CONTEXT_ARRAY()
{
    Reset();

    FREE_MEMORY(_ppCertContexts);
}

DWORD
CliAuthSelectCredential(
    IN PCtxtHandle        phContext,
    IN LPTSTR             pszPackageName,
    IN CERT_CONTEXT_ARRAY*  pCertContextArray,
    OUT PCredHandle       phCredential,
    IN LPDWORD            pdwStatus)

/*++

Routine Description:

    Uses a selected Certificate Chain to produce a Credential handle.

    The credential handle will be used by SCHANNEL to produce a valid Client
    Auth session with a server.

Arguments:

    phContext       - SSPI Context Handle

    pszPackageName  - Name of the SSPI package we're using.

    pSelectedCert   - Cert that User wishes us to use for Client Auth with this server.
                       (BUGBUG who should free this? )

    phCredential    - Outgoing SSPI Credential handle that we may generate
                    IMPORTANT: Do not free the credential handle returned by this function.
                    These have to be cached for the lifetime of the process so the user 
                    doesn't get prompted forthe password over and over. Unfortunately there is
                    no ref-counting mechanism on CredHandle's so callers of this function need to 
                    make sure they don't free the handle.

    pdwStatus       - Secure error status flag that's filled in if an error occurs.
                    Pointer is assumed to be valid.

Return Value:

    DWORD
        Success - ERROR_SUCCESS
                        Caller should return ERROR_WINHTTP_CLIENT_AUTH_CERT_NEEDED,
                        to its caller.  The appropriate Cert chain was generated,
                        and the User needs to select it using UI.

        Failure -
                  ERROR_NOT_ENOUGH_MEMORY -
                        Out of Memory

                  ERROR_WINHTTP_SECURE_FAILURE -
                        Call Down to SSPI or WinTrust failed.

--*/

{

     SCHANNEL_CRED CredData = {SCHANNEL_CRED_VERSION,
                                     0,
                                     NULL,
                                     0,
                                     0,
                                     NULL,
                                     0,
                                     NULL,
                                     DEFAULT_SECURE_PROTOCOLS,
                                     0,
                                     0,
                                     0,
                                     SCH_CRED_MANUAL_CRED_VALIDATION |
                                     SCH_CRED_NO_DEFAULT_CREDS
                                     };
    SECURITY_STATUS scRet;


    DWORD           i;
    PCERT_BLOB      pBlob;
    DWORD           index;
    DWORD           error = ERROR_SUCCESS;
    PCCERT_CONTEXT  pCert;

    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CliAuthSelectCredential",
                 "%#x, %s, %x, %x",
                 phContext,
                 pszPackageName,
                 pCertContextArray,
                 phCredential
                 ));


    INET_ASSERT(phContext);
    INET_ASSERT(pCertContextArray);
    INET_ASSERT(pszPackageName);


    if (!pCertContextArray->LockCredHandle( ))
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    if ( pCertContextArray->GetArraySize() == 0 )
    {
        goto cleanup;
    }
    else
    {
        // First check and see if the Cert context already has a CredHandle associated with it.
        CredHandle hCreds = pCertContextArray->GetCredHandle( );

        if (!IsCredClear(hCreds))
        {
            *phCredential = hCreds;
            error = ERROR_SUCCESS;
            goto cleanup;
        }
    }

    pCert =         pCertContextArray->GetSelectedCertContext();


    //
    // Setup strucutres for AcquireCredentialsHandle call.
    //

    if ( pCert )
    {

        CredData.cCreds = 1;
        CredData.paCred = &pCert;
    }
    InternetReadRegistryDword("SecureProtocols",
                          (LPDWORD)&CredData.grbitEnabledProtocols
                          );

    WRAP_REVERT_USER(g_AcquireCredentialsHandle,
                     (NULL,
                      pszPackageName,
                      SECPKG_CRED_OUTBOUND,
                      NULL,
                      &CredData,
                      NULL,
                      NULL,
                      phCredential,
                      NULL),
                     scRet);

    error = MapInternetError((DWORD)scRet, pdwStatus);
    if (error == ERROR_SUCCESS)
    {
        pCertContextArray->SetCredHandle(*phCredential);
    }

cleanup:
    pCertContextArray->UnlockCredHandle();
    
quit:
    DEBUG_LEAVE(error);

    return error;
}


DWORD
CliAuthAcquireCertContexts(
    IN  PCtxtHandle        phContext,
    IN  LPTSTR             pszPackageName,
    OUT CERT_CONTEXT_ARRAY** ppCertContextArray,
    LPDWORD                pdwStatus
    )

/*++

Routine Description:

    Acquires a List of valid Certificate Chains for use in Client Authentication.

    Gathers an issuer list from the current context, and uses CAPI stored Certificates
    to build a list which will be selected from by the user at a later point.

Arguments:

    phContext       - SSPI Context Handle

    pszPackageName  - Name of the SSPI package we're using.

    phCredential    - Outgoing SSPI Credential handle that we may generate

    ppCertContextArray  - Outgoing List of Certifcate Contexts that can be selected
                        among to generate a Context.

    pdwStatus       - If failure is ERROR_WINHTTP_SECURE_FAILURE, this will
                      be filled in with the mapped flag for the error.

Return Value:

    DWORD
        Success - ERROR_SUCCESS
                        Caller should return ERROR_WINHTTP_CLIENT_AUTH_CERT_NEEDED,
                        to its caller.  The appropriate Cert chain was generated,
                        and the User needs to select it using UI.

        Failure -
                  ERROR_NOT_ENOUGH_MEMORY -
                        Out of Memory

                  ERROR_WINHTTP_SECURE_FAILURE -
                        Call Down to SSPI or WinTrust failed.

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CliAuthAcquireCertContexts",
                 "%#x, %s, %x",
                 phContext,
                 pszPackageName,
                 ppCertContextArray
                 ));

    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
    BOOL async;
    SECURITY_STATUS scRet;
    DWORD           cCerts;
    CERT_CHAIN_FIND_BY_ISSUER_PARA FindByIssuerPara;
    SecPkgContext_IssuerListInfoEx IssuerListInfo;
    PCCERT_CHAIN_CONTEXT pChainContext;
    PCCERT_CONTEXT pCertContext;
    DWORD error;

    if (lpThreadInfo != NULL) {
        async = _InternetGetAsync(lpThreadInfo);
        _InternetSetAsync(lpThreadInfo, FALSE);
    }

    INET_ASSERT(ppCertContextArray);


    INET_ASSERT(*ppCertContextArray == NULL );
    *ppCertContextArray = NULL;

    IssuerListInfo.cIssuers = 0;
    IssuerListInfo.aIssuers = NULL;

    if ( phContext == NULL )
    {
        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }

    //
    // Create our CertChain Array for keeping CertChains around
    //

    *ppCertContextArray = New CERT_CONTEXT_ARRAY();

    if ( *ppCertContextArray == NULL )
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    error = (*ppCertContextArray)->GetError();

    if ( error != ERROR_SUCCESS)
    {
        goto quit;
    }

    if (g_hMyCertStore == NULL)
    {
        // In middle-tier server scenarios, it's possible for the account
        // to not be configured with a store for client auth support.
        // If so, simply return an empty array to mimic no certs available.
        goto quit;
    }

    //
    // Attempt to find out whether we have any issuers
    //  from this connection that the Server might have
    //  told us about.
    //

    WRAP_REVERT_USER(g_QueryContextAttributes,
                     (phContext,
                      SECPKG_ATTR_ISSUER_LIST_EX,
                      &IssuerListInfo),
                     scRet);

    if(FAILED(scRet))
    {
        error = MapInternetError((DWORD) scRet, pdwStatus);
        goto quit;
    }

    cCerts = 0;

    if (g_CertFindChainInStore == NULL || g_CertFreeCertificateChain == NULL)
    {
        // We don't support client-auth unless we have the new crypto dlls
        error = ERROR_CALL_NOT_IMPLEMENTED;
        goto quit;
    }

    ZeroMemory(&FindByIssuerPara, sizeof(FindByIssuerPara));

    FindByIssuerPara.cbSize = sizeof(FindByIssuerPara);
    FindByIssuerPara.pszUsageIdentifier = szOID_PKIX_KP_CLIENT_AUTH;
    FindByIssuerPara.dwKeySpec = 0;
    FindByIssuerPara.cIssuer   = IssuerListInfo.cIssuers;
    FindByIssuerPara.rgIssuer  = IssuerListInfo.aIssuers;

    pChainContext = NULL;

    while (TRUE)
    {
        // Find a certificate chain.
        WRAP_REVERT_USER(g_CertFindChainInStore,
                         (g_hMyCertStore,
                          X509_ASN_ENCODING,
                          0,
                          CERT_CHAIN_FIND_BY_ISSUER,
                          &FindByIssuerPara,
                          pChainContext),
                         pChainContext);

        if (pChainContext == NULL)
            break;

        // Get pointer to leaf certificate context.
        pCertContext = pChainContext->rgpChain[0]->rgpElement[0]->pCertContext;

        // This could only happen if there is a bug in the crypto code. But we will deal with
        // that and continue looking in any case.
        if (pCertContext == NULL)
        {
            INET_ASSERT(FALSE);
            continue;
        }

        error = (*ppCertContextArray)->AddCertContext(pCertContext);

        if (error != ERROR_SUCCESS)
        {
            WRAP_REVERT_USER_VOID(g_CertFreeCertificateChain,(pChainContext));
            goto quit;
        }
    }

quit:

    if ( error != ERROR_SUCCESS &&
         *ppCertContextArray != NULL )
    {
        delete *ppCertContextArray;
        *ppCertContextArray = NULL;
    }

    if (IssuerListInfo.aIssuers != NULL)
    {
        WRAP_REVERT_USER_VOID(g_FreeContextBuffer, (IssuerListInfo.aIssuers));
    }

    if (lpThreadInfo != NULL) {
        _InternetSetAsync(lpThreadInfo, async);
    }

    DEBUG_LEAVE(error);

    return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\whttptst\src\winhttptest\helpers.cxx ===
#include "common.h"

//-----------------------------------------------------------------------------
// WinHttpTest helper functions
//-----------------------------------------------------------------------------
HRESULT
WinHttpTest::_WinHttpOpen(
  LPCWSTR  pwszUserAgent,
  DWORD    dwAccessType,
  LPCWSTR  pwszProxyName,
  LPCWSTR  pwszProxyBypass,
  DWORD    dwFlags,
  VARIANT* retval
  )
{
  DEBUG_ENTER((
    DBG_HELPER,
    rt_hresult,
    "WinHttpTest::_WinHttpOpen",
    "pwszUserAgent=%#x; dwAccessType=%s; pwszProxyName=%#x; pwszProxyBypass=%#x; dwFlags=%s",
    pwszUserAgent,
    MapWinHttpAccessType(dwAccessType),
    pwszProxyName,
    pwszProxyBypass,
    MapWinHttpIOMode(dwFlags)
    ));

  HRESULT   hr    = S_OK;
  DWORD     error = ERROR_SUCCESS;
  HINTERNET hOpen = NULL;
  
  __try
  {
    hOpen = ::WinHttpOpen(
                pwszUserAgent,
                dwAccessType,
                pwszProxyName,
                pwszProxyBypass,
                dwFlags
                );
    
    if( !hOpen )
    {
      error = GetLastError();
    }
  }
  __except(exception_filter(GetExceptionInformation()))
  {
    error = _exception_code();
    goto quit;
  }

  if( retval )
  {
    V_VT(retval) = VT_I4;
    V_I4(retval) = (DWORD) hOpen;
  }

quit:
  
  _SetErrorCode(error);

  DEBUG_TRACE(WHTTPTST, ("hOpen=%#x", hOpen));
  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
WinHttpTest::_WinHttpConnect(
  HINTERNET     hSession,
  LPCWSTR       pwszServerName,
  INTERNET_PORT nServerPort,
  DWORD         dwReserved,
  VARIANT*      retval
  )
{
  DEBUG_ENTER((
    DBG_HELPER,
    rt_hresult,
    "WinHttpTest::_WinHttpConnect",
    "hSession=%#x; pwszServerName=%#x; nServerPort=%d; dwReserved=%#x",
    hSession,
    pwszServerName,
    nServerPort,
    dwReserved
    ));

  HRESULT    hr        = S_OK;
  DWORD      error     = ERROR_SUCCESS;
  HINTERNET  hConnect  = NULL;
  IDispatch* pCallback = NULL;

  __try
  {
    hConnect = ::WinHttpConnect(
                   hSession,
                   pwszServerName,
                   nServerPort,
                   dwReserved
                   );

    if( !hConnect )
    {
      error = GetLastError();
    }
  }
  __except(exception_filter(GetExceptionInformation()))
  {
    error = _exception_code();
    goto quit;
  }

  if( retval )
  {
    V_VT(retval) = VT_I4;
    V_I4(retval) = (DWORD) hConnect;

    if( error == ERROR_SUCCESS )
    {
      // WinHTTP handles inherit their parent's callback function pointer. Since we're
      // thunking the callback from C to JavaScript, we need to simulate this inheritance
      // in the callback handle map.

      if( SUCCEEDED(ManageCallbackForHandle(hSession, &pCallback, CALLBACK_HANDLE_GET)) )
      {
        hr = ManageCallbackForHandle(hConnect, &pCallback, CALLBACK_HANDLE_MAP);
      }
    }
  }

quit:
  
  _SetErrorCode(error);
  
  DEBUG_TRACE(WHTTPTST, ("hConnect=%#x", hConnect));    
  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
WinHttpTest::_WinHttpOpenRequest(
  HINTERNET hConnect,
  LPCWSTR   pwszVerb,
  LPCWSTR   pwszObjectName,
  LPCWSTR   pwszVersion,
  LPCWSTR   pwszReferrer,
  LPCWSTR*  ppwszAcceptTypes,
  DWORD     dwFlags,
  VARIANT*  retval
  )
{
  DEBUG_ENTER((
    DBG_HELPER,
    rt_hresult,
    "WinHttpTest::_WinHttpOpenRequest",
    "hConnect=%#x; pwszVerb=%#x; pwszObjectName=%#x; pwszVersion=%#x; pwszReferrer=%#x; ppwszAcceptTypes=%#x; dwFlags=%#x",
    hConnect,
    pwszVerb,
    pwszObjectName,
    pwszVersion,
    pwszReferrer,
    ppwszAcceptTypes,
    dwFlags
    ));

  HRESULT    hr        = S_OK;
  DWORD      error     = ERROR_SUCCESS;
  HINTERNET  hRequest  = NULL;
  IDispatch* pCallback = NULL;

  __try
  {
    hRequest = ::WinHttpOpenRequest(
                   hConnect,
                   pwszVerb,
                   pwszObjectName,
                   pwszVersion,
                   pwszReferrer,
                   ppwszAcceptTypes,
                   dwFlags
                   );

    if( !hRequest )
    {
      error = GetLastError();
    }
  }
  __except(exception_filter(GetExceptionInformation()))
  {
    error = _exception_code();
    goto quit;
  }

  if( retval )
  {
    V_VT(retval) = VT_I4;
    V_I4(retval) = (DWORD) hRequest;

    if( error == ERROR_SUCCESS )
    {
      // WinHTTP handles inherit their parent's callback function pointer. Since we're
      // thunking the callback from C to JavaScript, we need to simulate this inheritance
      // in the callback handle map.

      if( SUCCEEDED(ManageCallbackForHandle(hConnect, &pCallback, CALLBACK_HANDLE_GET)) )
      {
        hr = ManageCallbackForHandle(hRequest, &pCallback, CALLBACK_HANDLE_MAP);
      }
    }
  }

quit:

  _SetErrorCode(error);

  DEBUG_TRACE(WHTTPTST, ("hRequest=%#x", hRequest));
  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
WinHttpTest::_WinHttpSendRequest(
  HINTERNET hRequest,
  LPCWSTR   pwszHeaders,
  DWORD     dwHeadersLength,
  LPVOID    lpOptional,
  DWORD     dwOptionalLength,
  DWORD     dwTotalLength,
  DWORD_PTR dwContext,
  VARIANT*  retval
  )
{
  DEBUG_ENTER((
    DBG_HELPER,
    rt_hresult,
    "WinHttpTest::_WinHttpSendRequest",
    "hRequest=%#x; pwszHeaders=%#x; dwHeadersLength=%#x; lpOptional=%#x; dwOptionalLength=%#x; dwTotalLength=%#x; dwContext=%#x",
    hRequest,
    pwszHeaders,
    dwHeadersLength,
    lpOptional,
    dwOptionalLength,
    dwTotalLength,
    dwContext    
    ));

  HRESULT hr    = S_OK;
  DWORD   error = ERROR_SUCCESS;
  BOOL    bRet  = NULL;

  __try
  {
    bRet = ::WinHttpSendRequest(
               hRequest,
               pwszHeaders,
               dwHeadersLength,
               lpOptional,
               dwOptionalLength,
               dwTotalLength,
               dwContext
               );

    if( !bRet )
    {
      error = GetLastError();
    }
  }
  __except(exception_filter(GetExceptionInformation()))
  {
    error = _exception_code();
    goto quit;
  }

  if( retval )
  {
    V_VT(retval)   = VT_BOOL;
    V_BOOL(retval) = bRet ? VARIANT_TRUE : VARIANT_FALSE;
  }

quit:

  _SetErrorCode(error);

  DEBUG_TRACE(WHTTPTST, ("bRet=%s", TF(bRet)));
  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
WinHttpTest::_WinHttpCloseHandle(
  HINTERNET hInternet,
  VARIANT*  retval
  )
{
  DEBUG_ENTER((
    DBG_HELPER,
    rt_hresult,
    "WinHttpTest::_WinHttpCloseHandle",
    "hInternet=%#x",
    hInternet
    ));

  HRESULT hr    = S_OK;
  DWORD   error = ERROR_SUCCESS;
  BOOL    bRet  = TRUE;

  __try
  {
    bRet = ::WinHttpCloseHandle(hInternet);

    if( !bRet )
    {
      error = GetLastError();
    }
  }
  __except(exception_filter(GetExceptionInformation()))
  {
    error = _exception_code();
    goto quit;
  }

  if( retval )
  {
    V_VT(retval)   = VT_BOOL;
    V_BOOL(retval) = bRet ? VARIANT_TRUE : VARIANT_FALSE;
  }

quit:

  // we don't care about success or failure, always unmap the
  // callback from the (now closed) internet handle
  ManageCallbackForHandle(hInternet, NULL, CALLBACK_HANDLE_UNMAP);

  _SetErrorCode(error);
        
  DEBUG_TRACE(WHTTPTST, ("bRet=%s", TF(bRet)));
  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
WinHttpTest::_WinHttpSetStatusCallback(
  HINTERNET               hInternet,
  WINHTTP_STATUS_CALLBACK lpfnCallback,
  DWORD                   dwNotificationFlags,
  DWORD_PTR               dwReserved,
  VARIANT*                retval
  )
{
  DEBUG_ENTER((
    DBG_HELPER,
    rt_hresult,
    "WinHttpTest::_WinHttpSetStatusCallback",
    "hInternet=%#x; lpfnCallback=%#x; dwNotificationFlags=%#x; dwReserved=%#x",
    hInternet,
    lpfnCallback,
    dwNotificationFlags,
    dwReserved
    ));

  HRESULT                 hr          = S_OK;
  DWORD                   error       = ERROR_SUCCESS;
  WINHTTP_STATUS_CALLBACK pfnPrevious = NULL;
  
  __try
  {
    pfnPrevious = ::WinHttpSetStatusCallback(
                      hInternet,
                      lpfnCallback,
                      dwNotificationFlags,
                      dwReserved
                      );

    if( pfnPrevious == WINHTTP_INVALID_STATUS_CALLBACK )
    {
      error = GetLastError();
    }
  }
  __except(exception_filter(GetExceptionInformation()))
  {
    error = _exception_code();
    goto quit;
  }

  if( retval )
  {
    V_VT(retval) = VT_I4;
    V_I4(retval) = (DWORD_PTR) pfnPrevious;
  }

quit:

  _SetErrorCode(error);

  DEBUG_TRACE(WHTTPTST, ("pfnPrevious=%#x [%s]", pfnPrevious, MapErrorToString((DWORD) pfnPrevious)));
  DEBUG_LEAVE(hr);
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\whttptst\src\winhttptest\methods.cxx ===
#include "common.h"

//-----------------------------------------------------------------------------
// IWinHttpTest methods
//-----------------------------------------------------------------------------
HRESULT
__stdcall
WinHttpTest::WinHttpOpen(
  VARIANT UserAgent,
  VARIANT AccessType,
  VARIANT ProxyName,
  VARIANT ProxyBypass,
  VARIANT Flags, 
  VARIANT *OpenHandle
  )
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WinHttpTest::WinHttpOpen",
    "this=%#x",
    this
    ));

  HRESULT hr              = S_OK;
  LPWSTR  pwszUserAgent   = NULL;
  LPWSTR  pwszProxyName   = NULL;
  LPWSTR  pwszProxyBypass = NULL;
  DWORD   dwAccessType    = 0L;
  DWORD   dwFlags         = 0L;

  hr = ProcessWideStringParam(L"UserAgent", &UserAgent, &pwszUserAgent);

    if( FAILED(hr) )
      goto quit;

  hr = ProcessWideStringParam(L"ProxyName", &ProxyName, &pwszProxyName);

    if( FAILED(hr) )
      goto quit;

  hr = ProcessWideStringParam(L"ProxyBypass", &ProxyBypass, &pwszProxyBypass);

    if( FAILED(hr) )
      goto quit;

  dwAccessType = V_I4(&AccessType);
  dwFlags      = V_I4(&Flags);

  hr = _WinHttpOpen(
          pwszUserAgent,
          dwAccessType,
          pwszProxyName,
          pwszProxyBypass,
          dwFlags,
          OpenHandle
          );

quit:

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WinHttpTest::WinHttpConnect(
  VARIANT OpenHandle,
  VARIANT ServerName,
  VARIANT ServerPort,
  VARIANT Reserved,
  VARIANT *ConnectHandle
  )
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WinHttpTest::WinHttpConnect",
    "this=%#x",
    this
    ));

  HRESULT       hr             = S_OK;
  HINTERNET     hOpen          = NULL;
  LPWSTR        pwszServerName = NULL;
  INTERNET_PORT nServerPort    = 0;
  DWORD         dwReserved     = 0L;

  hr = ProcessWideStringParam(L"ServerName", &ServerName, &pwszServerName);

    if( FAILED(hr) )
      goto quit;

  hOpen       = (HINTERNET) V_I4(&OpenHandle);
  nServerPort = (INTERNET_PORT) V_I4(&ServerPort);
  dwReserved  = V_I4(&Reserved);

  hr = _WinHttpConnect(
          hOpen,
          pwszServerName,
          nServerPort,
          dwReserved,
          ConnectHandle
          );

quit:

  DEBUG_LEAVE(hr);
  return hr;
}

        
HRESULT
__stdcall
WinHttpTest::WinHttpOpenRequest(
  VARIANT ConnectHandle,
  VARIANT Verb,
  VARIANT ObjectName,
  VARIANT Version,
  VARIANT Referrer,
  VARIANT AcceptTypes,
  VARIANT Flags,
  VARIANT *RequestHandle
  )
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WinHttpTest::WinHttpOpenRequest",
    "this=%#x",
    this
    ));

  HRESULT   hr                = S_OK;
  HINTERNET hConnect          = NULL;
  LPWSTR    pwszVerb          = NULL;
  LPWSTR    pwszObjectName    = NULL;
  LPWSTR    pwszVersion       = NULL;
  LPWSTR    pwszReferrer      = NULL;
  LPCWSTR*  ppwszAcceptTypes  = NULL;
  DWORD     dwFlags           = NULL;

  hr = ProcessWideStringParam(L"Verb", &Verb, &pwszVerb);

    if( FAILED(hr) )
      goto quit;

  hr = ProcessWideStringParam(L"ObjectName", &ObjectName, &pwszObjectName);

    if( FAILED(hr) )
      goto quit;

  hr = ProcessWideStringParam(L"Version", &Version, &pwszVersion);

    if( FAILED(hr) )
      goto quit;

  hr = ProcessWideStringParam(L"Referrer", &Referrer, &pwszReferrer);

    if( FAILED(hr) )
      goto quit;

  hr = ProcessWideMultiStringParam(L"AcceptTypes", &AcceptTypes, (LPWSTR**) &ppwszAcceptTypes);

    if( FAILED(hr) )
      goto quit;

  hConnect = (HINTERNET) V_I4(&ConnectHandle);
  dwFlags  = V_I4(&Flags);

  hr = _WinHttpOpenRequest(
          hConnect,
          pwszVerb,
          pwszObjectName,
          pwszVersion,
          pwszReferrer,
          ppwszAcceptTypes,
          dwFlags,
          RequestHandle
          );

quit:

  SAFEDELETEBUF(ppwszAcceptTypes);

  DEBUG_LEAVE(hr);
  return hr;
}

        
HRESULT
__stdcall
WinHttpTest::WinHttpSendRequest(
  VARIANT RequestHandle,
  VARIANT Headers,
  VARIANT HeadersLength,
  VARIANT OptionalData,
  VARIANT OptionalLength,
  VARIANT TotalLength,
  VARIANT Context,
  VARIANT *Success
  )
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WinHttpTest::WinHttpSendRequest",
    "this=%#x",
    this
    ));

  HRESULT   hr               = S_OK;
  BOOL      bDidAlloc        = FALSE;
  HINTERNET hRequest         = NULL;
  LPCWSTR   pwszHeaders      = NULL;
  DWORD     dwHeadersLength  = 0L;
  LPVOID    lpOptional       = NULL;
  DWORD     dwOptionalLength = 0L;
  DWORD     dwTotalLength    = 0L;
  DWORD_PTR dwContext        = NULL;

  hr = ProcessWideStringParam(L"Headers", &Headers, (LPWSTR*) &pwszHeaders);

    if( FAILED(hr) )
      goto quit;

  hr = ProcessBufferParam(L"OptionalData", &OptionalData, &lpOptional, &bDidAlloc);

    if( FAILED(hr) )
      goto quit;

  hRequest         = (HINTERNET) V_I4(&RequestHandle);
  dwHeadersLength  = V_I4(&HeadersLength);
  dwOptionalLength = V_I4(&OptionalLength);
  dwTotalLength    = V_I4(&TotalLength);
  dwContext        = V_I4(&Context);

  hr = _WinHttpSendRequest(
          hRequest,
          pwszHeaders,
          dwHeadersLength,
          lpOptional,
          dwOptionalLength,
          dwTotalLength,
          dwContext,
          Success
          );

quit:

  if( bDidAlloc )
  {
    SAFEDELETEBUF(lpOptional);
  }

  DEBUG_LEAVE(hr);
  return hr;
}

        
HRESULT
__stdcall
WinHttpTest::WinHttpReceiveResponse(
  VARIANT RequestHandle,
  VARIANT Reserved,
  VARIANT *Success
  )
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WinHttpTest::WinHttp",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WinHttpTest::WinHttpCloseHandle(
  VARIANT InternetHandle,
  VARIANT *Success
  )
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WinHttpTest::WinHttpCloseHandle",
    "this=%#x",
    this
    ));

  HRESULT   hr        = S_OK;
  HINTERNET hInternet = NULL;
  
  hInternet = (HINTERNET) V_I4(&InternetHandle);

  hr = _WinHttpCloseHandle(
          hInternet,
          Success
          );

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WinHttpTest::WinHttpReadData(
  VARIANT RequestHandle,
  VARIANT BufferObject,
  VARIANT *Success
  )
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WinHttpTest::WinHttp",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WinHttpTest::WinHttpWriteData(
  VARIANT RequestHandle,
  VARIANT BufferObject,
  VARIANT *Success
  )
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WinHttpTest::WinHttp",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WinHttpTest::WinHttpQueryDataAvailable(
  VARIANT RequestHandle,
  VARIANT boNumberOfBytesAvailable,
  VARIANT *Success
  )
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WinHttpTest::WinHttp",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WinHttpTest::WinHttpQueryOption(
  VARIANT InternetHandle,
  VARIANT Option,
  VARIANT BufferObject,
  VARIANT *Success
  )
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WinHttpTest::WinHttp",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WinHttpTest::WinHttpSetOption(
  VARIANT InternetHandle,
  VARIANT Option,
  VARIANT BufferObject,
  VARIANT *Success
  )
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WinHttpTest::WinHttp",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WinHttpTest::WinHttpSetTimeouts(
  VARIANT InternetHandle,
  VARIANT ResolveTimeout,
  VARIANT ConnectTimeout,
  VARIANT SendTimeout,
  VARIANT ReceiveTimeout,
  VARIANT *Success
  )
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WinHttpTest::WinHttp",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WinHttpTest::WinHttpAddRequestHeaders(
  VARIANT RequestHandle,
  VARIANT Headers,
  VARIANT HeadersLength,
  VARIANT Modifiers,
  VARIANT *Success
  )
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WinHttpTest::WinHttp",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}

        
HRESULT
__stdcall
WinHttpTest::WinHttpSetCredentials(
  VARIANT RequestHandle,
  VARIANT AuthTargets,
  VARIANT AuthScheme,
  VARIANT UserName,
  VARIANT Password,
  VARIANT AuthParams,
  VARIANT *Success
  )
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WinHttpTest::WinHttp",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}

        
HRESULT
__stdcall
WinHttpTest::WinHttpQueryAuthSchemes(
  VARIANT RequestHandle,
  VARIANT SupportedSchemes,
  VARIANT PreferredSchemes,
  VARIANT AuthTarget,
  VARIANT *Success
  )
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WinHttpTest::WinHttp",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}

        
HRESULT
__stdcall
WinHttpTest::WinHttpQueryHeaders(
  VARIANT RequestHandle,
  VARIANT InfoLevel,
  VARIANT HeaderName,
  VARIANT HeaderValue,
  VARIANT HeaderValueLength,
  VARIANT *Success
  )
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WinHttpTest::WinHttp",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}

        
HRESULT
__stdcall
WinHttpTest::WinHttpTimeFromSystemTime(
  VARIANT SystemTime,
  VARIANT boHttpTime,
  VARIANT *Success
  )
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WinHttpTest::WinHttp",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WinHttpTest::WinHttpTimeToSystemTime(
  VARIANT boHttpTime,
  VARIANT SystemTime,
  VARIANT *Success
  )
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WinHttpTest::WinHttp",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}

        
HRESULT
__stdcall
WinHttpTest:: WinHttpCrackUrl(
  VARIANT Url,
  VARIANT UrlLength,
  VARIANT Flags,
  VARIANT UrlComponents,
  VARIANT *Success
  )
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WinHttpTest::WinHttp",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}

        
HRESULT
__stdcall
WinHttpTest::WinHttpCreateUrl(
  VARIANT UrlComponents,
  VARIANT Flags,
  VARIANT BufferObject,
  VARIANT *Success
  )
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WinHttpTest::WinHttp",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WinHttpTest::WinHttpSetStatusCallback(
  VARIANT InternetHandle,
  VARIANT CallbackFunction,
  VARIANT NotificationFlags,
  VARIANT Reserved,
  VARIANT *RetVal
  )
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WinHttpTest::WinHttpSetStatusCallback",
    "this=%#x",
    this
    ));

  HRESULT                 hr                  = S_OK;
  IDispatch*              pCallback           = NULL;
  HINTERNET               hInternet           = NULL;
  WINHTTP_STATUS_CALLBACK lpfnCallback        = NULL;
  DWORD                   dwNotificationFlags = 0L;
  DWORD                   dwReserved          = 0L;

  hInternet           = (HINTERNET) V_I4(&InternetHandle);
  dwNotificationFlags = V_UI4(&NotificationFlags);

  //
  // special case to deal with javascript not liking 0xFFFFFFFF
  //
  if( dwNotificationFlags == 0x0000000a )
  {
    dwNotificationFlags = WINHTTP_CALLBACK_FLAG_ALL_NOTIFICATIONS;
  }

  dwReserved          = V_I4(&Reserved);

  switch( V_VT(&CallbackFunction) )
  {
    case VT_DISPATCH :
      {
        pCallback = V_DISPATCH(&CallbackFunction);
        hr        = ManageCallbackForHandle(hInternet, &pCallback, CALLBACK_HANDLE_MAP);

        if( SUCCEEDED(hr) )
        {
          lpfnCallback = WinHttpCallback;
        }
      }
      break;

    case VT_I4 :
      {
        hr = InvalidatePointer(
               (POINTER) V_I4(&CallbackFunction),
               (void**) &lpfnCallback
               );
      }
      break;

    default : hr = E_INVALIDARG;
  }

  if( SUCCEEDED(hr) )
  {
    hr = _WinHttpSetStatusCallback(
            hInternet,
            lpfnCallback,
            dwNotificationFlags,
            dwReserved,
            RetVal
            );
  }

  DEBUG_LEAVE(hr);
  return hr;
}

        
HRESULT
__stdcall
WinHttpTest::HelperGetBufferObject(
  VARIANT Size,
  VARIANT Type,
  VARIANT Flags,
  VARIANT *BufferObject
  )
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WinHttpTest::WinHttp",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}

        
HRESULT
__stdcall
WinHttpTest::HelperGetUrlComponents(
  VARIANT Flags,
  VARIANT *UrlComponents
  )
{
  HRESULT            hr   = S_OK;
  IWHTUrlComponents* pwuc = NULL;

    if( UrlComponents )
    {
      hr = WHTURLCMP::Create((MEMSETFLAG) V_I4(&Flags), &pwuc);

      if( SUCCEEDED(hr) )
      {
        V_VT(UrlComponents)       = VT_DISPATCH;
        V_DISPATCH(UrlComponents) = pwuc;
      }
      else
      {
        V_VT(UrlComponents) = VT_NULL;
      }
    }
    else
    {
      hr = E_INVALIDARG;
    }

  return hr;
}

        
HRESULT
__stdcall
WinHttpTest::HelperGetSystemTime(
  VARIANT Flags,
  VARIANT *SystemTime
  )
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WinHttpTest::WinHttp",
    "this=%#x",
    this
    ));

  HRESULT hr = S_OK;

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
__stdcall
WinHttpTest::HelperGetLastError(
  VARIANT *Win32ErrorCode
  )
{
  HRESULT hr = S_OK;

    if( Win32ErrorCode )
    {
      if( m_pw32ec )
      {
        m_pw32ec->AddRef();

        V_VT(Win32ErrorCode)       = VT_DISPATCH;
        V_DISPATCH(Win32ErrorCode) = m_pw32ec;
      }
      else
      {
        V_VT(Win32ErrorCode) = VT_NULL;
      }
    }
    else
    {
      hr = E_INVALIDARG;
    }

  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\api\creds.cxx ===
/*++

Copyright (c) 1994-2000  Microsoft Corporation

Module Name:

    Creds.cxx

Abstract:

    Contains the Creds APIs

    Contents:
        WinHttpSetCredentialsA
        WinHttpSetCredentials
        WinHttpQueryAuthSchemes
        
Author:

    Biao Wang (biaow) 27-June-2000

Environment:

    Win32 user-mode DLL

Revision History:

    27-June-2000 biaow
        Created

--*/

#include <wininetp.h>

/*
BOOLAPI WinHttpQueryAuthParams(
    IN  HINTERNET   hRequest,        // HINTERNET handle returned by WinHttpOpenRequest   
    IN  DWORD       AuthScheme,
    OUT LPVOID*     pAuthParams      // Scheme-specific Advanced auth parameters
    )
{
    //BUG-BUG Verify parameters
    
    // biaow: to implement this fully
    *pAuthParams = 0;

    return TRUE;
}
*/

BOOLAPI WinHttpQueryAuthSchemes(
    
    IN  HINTERNET   hRequest,       // HINTERNET handle returned by HttpOpenRequest.   
    OUT LPDWORD     lpdwSupportedSchemes,// a bitmap of available Authentication Schemes
    OUT LPDWORD     lpdwPreferredScheme,  // WinHttp's preferred Authentication Method 
    OUT LPDWORD      pdwAuthTarget  
    )
{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "WinHttpQueryAuthSchemes",
                     "%#x, %#x, %#x",
                     hRequest,
                     lpdwSupportedSchemes,
                     lpdwPreferredScheme
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    HINTERNET hRequestMapped = NULL;
    BOOL fResult = FALSE;
    HINTERNET_HANDLE_TYPE HandleType;    

    dwErr = ::MapHandleToAddress(hRequest, (LPVOID *)&hRequestMapped, FALSE);
    
    if ((dwErr != ERROR_SUCCESS) || (hRequestMapped == NULL)) 
    {
        dwErr = ERROR_INVALID_HANDLE;
        goto cleanup;
    }

    HTTP_REQUEST_HANDLE_OBJECT * pRequest;

    if ((::RGetHandleType(hRequestMapped, &HandleType) != ERROR_SUCCESS) 
        || (HandleType != TypeHttpRequestHandle))
    {
        dwErr = ERROR_INVALID_HANDLE;
        goto cleanup;
    }
    
    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)hRequestMapped;

    if (::IsBadWritePtr(lpdwSupportedSchemes, sizeof(DWORD)) 
        || ::IsBadWritePtr(lpdwPreferredScheme, sizeof(DWORD)) 
        || ::IsBadWritePtr(pdwAuthTarget, sizeof(DWORD)))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    if ((!pRequest->_SupportedSchemes) || (!pRequest->_PreferredScheme))
    {
        dwErr = ERROR_INVALID_OPERATION;
        goto cleanup;
    }

    *lpdwSupportedSchemes = pRequest->_SupportedSchemes;
    *lpdwPreferredScheme = pRequest->_PreferredScheme;
    *pdwAuthTarget = pRequest->_AuthTarget;
    
    fResult = TRUE;

cleanup:

    if (hRequestMapped)
    {
        DereferenceObject(hRequestMapped);
    }

    if (dwErr!= ERROR_SUCCESS) 
    { 
        ::SetLastError(dwErr); 
        DEBUG_ERROR(HTTP, dwErr);
    }
    
    DEBUG_LEAVE_API(fResult);
    return fResult;
}

BOOL WinHttpSetCredentialsA (
    
    IN HINTERNET   hRequest,        // HINTERNET handle returned by HttpOpenRequest.   
    
    
    IN DWORD       AuthTargets,      // Only WINHTTP_AUTH_TARGET_SERVER and 
                                    // WINHTTP_AUTH_TARGET_PROXY are supported
                                    // in this version and they are mutually 
                                    // exclusive 
    
    IN DWORD       AuthScheme,      // must be one of the supported Auth Schemes 
                                    // returned from HttpQueryAuthSchemes(), Apps 
                                    // should use the Preferred Scheme returned
    
    IN LPCSTR     pszUserName,     // 1) NULL if default creds is to be used, in 
                                    // which case pszPassword will be ignored
    
    IN LPCSTR     pszPassword,     // 1) "" == Blank Passowrd; 2)Parameter ignored 
                                    // if pszUserName is NULL; 3) Invalid to pass in 
                                    // NULL if pszUserName is not NULL
    IN LPVOID     pAuthParams
   
    )
{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "WinHttpSetCredentialsA",
                     "%#x, %#x, %#x, %q, %q, %q",
                     hRequest,
                     AuthTargets,
                     AuthScheme,
                     pAuthParams,
                     pszUserName,
                     pszPassword
                     ));
    
    // Note: we assume WinHttp will explose an Unicode only API, so this function
    // will not be called directly by Apps. If this assumption is no longer true 
    // in future revisions, we need to add more elaborate parameter validation here.

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;
    HINTERNET hRequestMapped = NULL;
    HTTP_REQUEST_HANDLE_OBJECT* pRequest;
    HINTERNET_HANDLE_TYPE HandleType;
    PSTR pszRealm = NULL;

    // validate API symantics

    if (pszUserName != NULL)
    {
        // in any case, it doesn't make sense (and therefore invalid) to pass 
        // in a blank("") User Name
        if (::strlen(pszUserName) == 0)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
        else if (pszPassword == NULL)
        {
            // in any case, if an app passes in a UserName, it is invalid to
            // then pass in a NULL password (should use "" for blank passowrd)
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
    }
    // biaow: is blank scheme OK?

    // if an app picks BASIC auth, it must also supply an UserName and password
    if ((AuthScheme == WINHTTP_AUTH_SCHEME_BASIC) && (pszUserName == NULL))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    // default credentials (UserName/Password == NULL/NULL) are allowed only for 
    // NTLM/NEGOTIATE/PASSPORT auth
    if (pszUserName == NULL)
    {
        if ((AuthScheme != WINHTTP_AUTH_SCHEME_NTLM) 
            && (AuthScheme != WINHTTP_AUTH_SCHEME_NEGOTIATE)
            && (AuthScheme != WINHTTP_AUTH_SCHEME_PASSPORT))
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
    }

    dwErr = ::MapHandleToAddress(hRequest, (LPVOID *)&hRequestMapped, FALSE);
    
    if ((dwErr != ERROR_SUCCESS) || (hRequestMapped == NULL)) {
        
        dwErr = ERROR_INVALID_HANDLE;
        goto cleanup;
    }

    if ((::RGetHandleType(hRequestMapped, &HandleType) != ERROR_SUCCESS) 
        || (HandleType != TypeHttpRequestHandle))
    {
        dwErr = ERROR_INVALID_HANDLE;
        goto cleanup;
    }

    pRequest = 
        reinterpret_cast<HTTP_REQUEST_HANDLE_OBJECT*>(hRequestMapped);

    if (AuthScheme == WINHTTP_AUTH_SCHEME_DIGEST)
    {
        if (pAuthParams)
        {
            pszRealm = NewString((PCSTR)pAuthParams);
        }
        else
        {
            pszRealm = pRequest->_pszRealm;
        }

        if (pszRealm == NULL)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
    }

    if (AuthTargets == WINHTTP_AUTH_TARGET_PROXY)
    {
        delete pRequest->_pProxyCreds;
        pRequest->_pProxyCreds = New WINHTTP_REQUEST_CREDENTIALS(AuthScheme, 
                                                              pszRealm, pszUserName, pszPassword);
        if (pRequest->_pProxyCreds == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
    }
    else 
    {
        delete pRequest->_pServerCreds;
        pRequest->_pServerCreds = New WINHTTP_REQUEST_CREDENTIALS(AuthScheme, 
                                                                  pszRealm, pszUserName, pszPassword);
        if (pRequest->_pServerCreds == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
    }

    pRequest->_PreferredScheme = 0x00000000;
    pRequest->_SupportedSchemes = 0x00000000;
    pRequest->_AuthTarget = 0x00000000;
    if (pRequest->_pszRealm)
    {
        FREE_MEMORY(pRequest->_pszRealm);
        pRequest->_pszRealm = NULL;
    }

    fResult = TRUE;

cleanup:

    if (hRequestMapped)
    {
        DereferenceObject(hRequestMapped);
    }

    if (dwErr!=ERROR_SUCCESS) 
    { 
        ::SetLastError(dwErr); 
        DEBUG_ERROR(HTTP, dwErr);
    }
    
    DEBUG_LEAVE_API(fResult);
    return fResult;
}

BOOLAPI 
WinHttpSetCredentials(
    
    IN HINTERNET   hRequest,        // HINTERNET handle returned by HttpOpenRequest.   
    
    
    IN DWORD       AuthTargets,      // Only WINHTTP_AUTH_TARGET_SERVER and 
                                    // WINHTTP_AUTH_TARGET_PROXY are supported
                                    // in this version and they are mutually 
                                    // exclusive 
    
    IN DWORD       AuthScheme,      // must be one of the supported Auth Schemes 
                                    // returned from HttpQueryAuthSchemes(), Apps 
                                    // should use the Preferred Scheme returned
    
    IN LPCWSTR     pwszUserName,     // 1) NULL if default creds is to be used, in 
                                    // which case pszPassword will be ignored
    
    IN LPCWSTR     pwszPassword,     // 1) "" == Blank Passowrd; 2)Parameter ignored 
                                    // if pszUserName is NULL; 3) Invalid to pass in 
                                    // NULL if pszUserName is not NULL
    IN LPVOID      pAuthParams
   
    )
{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "WinHttpSetCredentials",
                     "%#x, %#x, %#x, %wq, %wq, %wq",
                     hRequest,
                     AuthTargets,
                     AuthScheme,
                     pAuthParams,
                     pwszUserName,
                     pwszPassword
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;
    LPCWSTR pwszRealm = NULL;
    MEMORYPACKET mpRealm, mpUserName, mpPassword;

    if (!hRequest)
    {
        dwErr = ERROR_INVALID_HANDLE;
        goto cleanup;
    }

    // make sure only one bit in AuthScheme is set
    if ((AuthScheme & (AuthScheme - 1)) != 0x00000000)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    // make sure the input strings are valid
    if (pwszUserName 
        && ::IsBadStringPtrW(pwszUserName, INTERNET_MAX_USER_NAME_LENGTH))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    if (pwszPassword 
        && ::IsBadStringPtrW(pwszPassword, INTERNET_MAX_PASSWORD_LENGTH))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    
    if ((AuthScheme == WINHTTP_AUTH_SCHEME_DIGEST) && pAuthParams)
    {
        pwszRealm = (LPCWSTR)pAuthParams;
    }
    if (pwszRealm 
        && ::IsBadStringPtrW(pwszRealm, INTERNET_MAX_REALM_LENGTH))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    // make sure AuthTargets are either Server or Proxy (not both)
    if ((AuthTargets != WINHTTP_AUTH_TARGET_SERVER) 
        && (AuthTargets != WINHTTP_AUTH_TARGET_PROXY))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    // convert Unicode strings to Ansi
    
    if (pwszUserName)
    {
        ALLOC_MB(pwszUserName, 0, mpUserName);
        if (!mpUserName.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(pwszUserName, mpUserName);
    }
    if (pwszPassword)
    {
        ALLOC_MB(pwszPassword, 0, mpPassword);
        if (!mpPassword.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(pwszPassword, mpPassword);
    }
    if (pwszRealm)
    {
        ALLOC_MB(pwszRealm, 0, mpRealm);
        if (!mpRealm.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(pwszRealm, mpRealm);
    }

    fResult = ::WinHttpSetCredentialsA(hRequest, AuthTargets,
                                       AuthScheme, mpUserName.psStr, mpPassword.psStr, mpRealm.psStr);

cleanup:

    if (dwErr!=ERROR_SUCCESS) 
    { 
        ::SetLastError(dwErr); 
        DEBUG_ERROR(HTTP, dwErr);
    }
    
    DEBUG_LEAVE_API(fResult);
    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\tools\whttptst\src\winhttptest\winhttptest.cxx ===
#include "common.h"

extern HINSTANCE  g_hGlobalDllInstance;
LPCWSTR           g_wszWinHttpTestObjectName = L"WinHttpTest";


//-----------------------------------------------------------------------------
// WinHttpTest methods
//-----------------------------------------------------------------------------
WinHttpTest::WinHttpTest():
  m_cRefs(0),
  m_pti(NULL),
  m_pw32ec(NULL)
{
  DEBUG_TRACE(WHTTPTST, ("WinHttpTest [%#x] created", this));
}


WinHttpTest::~WinHttpTest()
{
  SAFERELEASE(m_pti);
  SAFERELEASE(m_pw32ec);
  DEBUG_TRACE(WHTTPTST, ("WinHttpTest [%#x] deleted", this));
}


HRESULT
WinHttpTest::Create(REFIID riid, void** ppv)
{
  DEBUG_ENTER((
    DBG_INITIALIZE,
    rt_hresult,
    "WinHttpTest::Create",
    "riid=%s; ppv=%#x",
    MapIIDToString(riid),
    ppv
    ));

  HRESULT   hr   = S_OK;
  PWHTTPTST pwht = NULL;

    if( pwht = new WHTTPTST )
    {
      hr = pwht->_Initialize();

      if( SUCCEEDED(hr) )
      {
        hr = pwht->QueryInterface(riid, ppv);
      }
    }
    else
    {
      hr = E_OUTOFMEMORY;
    }

    if( FAILED(hr) )
    {
      SAFEDELETE(pwht);
    }

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
WinHttpTest::_Initialize(void)
{
  DEBUG_ENTER((
    DBG_INITIALIZE,
    rt_hresult,
    "WinHttpTest::_Initialize",
    "this=%#x;",
    this
    ));

  HRESULT   hr  = S_OK;
  WCHAR*    buf = NULL;
  ITypeLib* ptl = NULL;

  buf = new WCHAR[MAX_PATH];

  if( buf )
  {
    if( GetModuleFileName(g_hGlobalDllInstance, buf, MAX_PATH) )
    {
      hr = LoadTypeLib(buf, &ptl);

      if( SUCCEEDED(hr) )
      {
        hr = GetTypeInfoFromName(g_wszWinHttpTestObjectName, ptl, &m_pti);
      }
    }
    else
    {
      hr = E_FAIL;
    }
  }

  SAFERELEASE(ptl);
  SAFEDELETEBUF(buf);

  DEBUG_LEAVE(hr);
  return hr;
}


HRESULT
WinHttpTest::_SetErrorCode(DWORD error)
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WinHttpTest::_SetErrorCode",
    "this=%#x; error=%s",
    this,
    MapErrorToString(error)
    ));

  HRESULT hr = S_OK;

  SAFERELEASE(m_pw32ec);

  hr = WHTERROR::Create(error, &m_pw32ec);

  DEBUG_LEAVE(hr);
  return hr;
}


//-----------------------------------------------------------------------------
// IUnknown methods
//-----------------------------------------------------------------------------
HRESULT
__stdcall
WinHttpTest::QueryInterface(REFIID riid, void** ppv)
{
  DEBUG_ENTER((
    DBG_REFCOUNT,
    rt_hresult,
    "WinHttpTest::QueryInterface",
    "this=%#x; riid=%s; ppv=%#x",
    this,
    MapIIDToString(riid),
    ppv
    ));

  HRESULT hr = S_OK;

    if( ppv )
    {
      if(
        IsEqualIID(riid, IID_IUnknown)     ||
        IsEqualIID(riid, IID_IDispatch)    ||
        IsEqualIID(riid, IID_IWinHttpTest)
        )
      {
        *ppv = static_cast<IWinHttpTest*>(this);
      }
      else if( IsEqualIID(riid, IID_IProvideClassInfo) )
      {
        *ppv = static_cast<IProvideClassInfo*>(this);
      }
      else
      {
        *ppv = NULL;
        hr   = E_NOINTERFACE;
      }
    }
    else
    {
      hr = E_POINTER;
    }

    if( SUCCEEDED(hr) )
    {
      DEBUG_TRACE(REFCOUNT, ("returning %s pointer", MapIIDToString(riid)));
      reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    }

  DEBUG_LEAVE(hr);
  return hr;
}


ULONG
__stdcall
WinHttpTest::AddRef(void)
{
  InterlockedIncrement(&m_cRefs);
  DEBUG_ADDREF("WinHttpTest", m_cRefs);
  return m_cRefs;
}


ULONG
__stdcall
WinHttpTest::Release(void)
{
  InterlockedDecrement(&m_cRefs);
  DEBUG_RELEASE("WinHttpTest", m_cRefs);

  if( m_cRefs == 0 )
  {
    DEBUG_FINALRELEASE("WinHttpTest");
    delete this;
    return 0;
  }

  return m_cRefs;
}


//-----------------------------------------------------------------------------
// IProvideClassInfo methods
//-----------------------------------------------------------------------------
HRESULT
__stdcall
WinHttpTest::GetClassInfo(ITypeInfo** ppti)
{
  DEBUG_ENTER((
    DBG_WHTTPTST,
    rt_hresult,
    "WinHttpTest::GetClassInfo",
    "this=%#x; ppti=%#x",
    this,
    ppti
    ));

  HRESULT hr = S_OK;

    if( ppti )
    {
      m_pti->AddRef();
      *ppti = m_pti;
    }
    else
    {
      hr = E_POINTER;
    }

  DEBUG_LEAVE(hr);
  return hr;
}


//-----------------------------------------------------------------------------
// WinHttpTest callback function
//-----------------------------------------------------------------------------
void
WinHttpCallback(
  HINTERNET hInternet,
  DWORD_PTR dwContext,
  DWORD     dwInternetStatus,
  LPVOID    lpvStatusInformation,
  DWORD     dwStatusInformationLength
  )
{
  DEBUG_ENTER((
    DBG_HELPER,
    rt_void,
    "WinHttpCallback",
    "hInternet=%#x; dwContext=%#x; dwInternetStatus=%d [%s]; lpvStatusInformation=%#x; dwStatusInformationLength=%#x",
    hInternet,
    dwContext,
    dwInternetStatus,
    MapCallbackFlagToString(dwInternetStatus),
    lpvStatusInformation,
    dwStatusInformationLength
    ));

  HRESULT    hr   = S_OK;
  IDispatch* pdc  = NULL;
  UINT       ae   = 0L;
  LCID       lcid = GetThreadLocale();
  DISPPARAMS dp;
  EXCEPINFO  ei;

  hr = ManageCallbackForHandle(hInternet, &pdc, CALLBACK_HANDLE_GET);
  
    if( FAILED(hr) )
      goto quit;

  memset((void*) &dp, 0x00, sizeof(DISPPARAMS));
  memset((void*) &ei, 0x00, sizeof(EXCEPINFO));

  dp.cArgs  = 5;
  dp.rgvarg = new VARIANT[dp.cArgs];

    if( !dp.rgvarg )
    {
      DEBUG_TRACE(HELPER, ("failed to allocate variant array!"));
      goto quit;
    }

  V_VT(&dp.rgvarg[4]) = VT_I4;
  V_I4(&dp.rgvarg[4]) = (DWORD) hInternet;

  V_VT(&dp.rgvarg[3]) = VT_I4;
  V_I4(&dp.rgvarg[3]) = dwContext;

  V_VT(&dp.rgvarg[2]) = VT_I4;
  V_I4(&dp.rgvarg[2]) = dwInternetStatus;

  V_VT(&dp.rgvarg[1]) = VT_I4;
  V_I4(&dp.rgvarg[1]) = (DWORD) lpvStatusInformation;

  V_VT(&dp.rgvarg[0]) = VT_I4;
  V_I4(&dp.rgvarg[0]) = dwStatusInformationLength;

  DEBUG_TRACE(HELPER, ("******** ENTER CALLBACK HANDLER ********"));

    hr = pdc->Invoke(
                DISPID_VALUE, IID_NULL,
                lcid, DISPATCH_METHOD,
                &dp, NULL, &ei, &ae
                );
  
  DEBUG_TRACE(HELPER, ("******** LEAVE CALLBACK HANDLER ********"));

quit:

  SAFEDELETEBUF(dp.rgvarg);
  DEBUG_LEAVE(0);
}


//-----------------------------------------------------------------------------
// HANDLEMAP hashtable support functions
//-----------------------------------------------------------------------------
void
CHandleMap::GetHashAndBucket(HINTERNET id, LPDWORD lpHash, LPDWORD lpBucket)
{
  DWORD hash = (DWORD) id;

  *lpHash   = hash;
  *lpBucket = hash % 10;
}

void
ScriptCallbackKiller(LPVOID* ppv)
{
  if( ppv )
  {
    ((IDispatch*) *ppv)->Release();
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\api\globals.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    globals.cxx

Abstract:

    Contains global data items for WININET.DLL and initialization function

    Contents:
        GlobalDllInitialize
        GlobalDllTerminate
        GlobalDataInitialize
        GlobalDataTerminate
        IsHttp1_1
        SetOfflineUserState
        GetWininetUserName
        ChangeGlobalSettings

Author:

    Richard L Firth (rfirth) 15-Jul-1995

Revision History:

    15-Jul-1995 rfirth
        Created

    07-Oct-1998 joshco
        updated minor version number 1->2

--*/

#include <wininetp.h>
#include <ntverp.h>
#include <schnlsp.h>
#include <persist.h>

//
// WinHttpX major & minor versions - allow to be defined externally
//

#if !defined(WINHTTPX_MAJOR_VERSION)
#define WINHTTPX_MAJOR_VERSION   5
#endif
#if !defined(WINHTTPX_MINOR_VERSION)
#define WINHTTPX_MINOR_VERSION   1
#endif

//
// external functions
//

#if INET_DEBUG

VOID
InitDebugSock(
    VOID
    );

#endif


//
// global DLL state data
//

GLOBAL HINSTANCE GlobalDllHandle = NULL;
GLOBAL DWORD GlobalPlatformType;
GLOBAL DWORD GlobalPlatformVersion5;
GLOBAL DWORD GlobalPlatformMillennium = FALSE;
GLOBAL BOOL GlobalDataInitialized = FALSE;

GLOBAL HANDLE g_hCompletionPort = NULL;
GLOBAL LPOVERLAPPED g_lpCustomOverlapped = NULL;
GLOBAL DWORD g_cNumIOCPThreads = 0;

#if INET_DEBUG
LONG g_cWSACompletions = 0;
LONG g_cCustomCompletions = 0;
#endif

//
// WinInet DLL version information (mainly for diagnostics)
//

#if !defined(VER_PRODUCTBUILD)
#define VER_PRODUCTBUILD    0
#endif

GLOBAL DWORD InternetBuildNumber = VER_PRODUCTBUILD;

//
// transport-based time-outs, etc.
//

#ifndef unix
GLOBAL const DWORD GlobalConnectTimeout = DEFAULT_CONNECT_TIMEOUT;
#else
GLOBAL const DWORD GlobalConnectTimeout = 1 * 60 * 1000;
#endif /* unix */
GLOBAL const DWORD GlobalResolveTimeout = DEFAULT_RESOLVE_TIMEOUT;
GLOBAL const DWORD GlobalConnectRetries = DEFAULT_CONNECT_RETRIES;
GLOBAL const DWORD GlobalSendTimeout = DEFAULT_SEND_TIMEOUT;
GLOBAL const DWORD GlobalReceiveTimeout = DEFAULT_RECEIVE_TIMEOUT;
GLOBAL const DWORD GlobalTransportPacketLength = DEFAULT_TRANSPORT_PACKET_LENGTH;
GLOBAL const DWORD GlobalKeepAliveSocketTimeout = DEFAULT_KEEP_ALIVE_TIMEOUT;
GLOBAL const DWORD GlobalSocketSendBufferLength = DEFAULT_SOCKET_SEND_BUFFER_LENGTH;
GLOBAL const DWORD GlobalSocketReceiveBufferLength = DEFAULT_SOCKET_RECEIVE_BUFFER_LENGTH;
GLOBAL const DWORD GlobalMaxHttpRedirects = DEFAULT_MAX_HTTP_REDIRECTS;
GLOBAL const DWORD GlobalConnectionInactiveTimeout = DEFAULT_CONNECTION_INACTIVE_TIMEOUT;
GLOBAL const DWORD GlobalServerInfoTimeout = DEFAULT_SERVER_INFO_TIMEOUT;

//
// switches
//

GLOBAL BOOL InDllCleanup = FALSE;
GLOBAL BOOL GlobalDynaUnload = FALSE;
GLOBAL BOOL GlobalDisableKeepAlive = FALSE;
GLOBAL BOOL GlobalEnableHttp1_1 = FALSE;
GLOBAL BOOL GlobalEnableProxyHttp1_1 = FALSE;

GLOBAL BOOL GlobalIsProcessExplorer = FALSE;
#ifndef UNIX
GLOBAL const BOOL GlobalEnableFortezza = TRUE;
#else /* for UNIX */
GLOBAL const BOOL GlobalEnableFortezza = FALSE;
#endif /* UNIX */

// SSL Switches  (petesk 7/24/97)
GLOBAL const DWORD GlobalSecureProtocols  = DEFAULT_SECURE_PROTOCOLS;

//
// AutoDetect Proxy Globals
//

GLOBAL LONG GlobalInternetOpenHandleCount = -1;
GLOBAL DWORD GlobalProxyVersionCount = 0;
GLOBAL BOOL GlobalAutoProxyInInit = FALSE;
GLOBAL BOOL GlobalAutoProxyCacheEnable = TRUE;
GLOBAL BOOL GlobalDisplayScriptDownloadFailureUI = FALSE;

//
//  Workaround for Novell's Client32
//

GLOBAL const BOOL fDontUseDNSLoadBalancing = FALSE;

//
// lists
//

GLOBAL SERIALIZED_LIST GlobalObjectList;

//
// SSL globals, for UI.  We need to know
//  whether its ok for us to pop up UI.
//
//

GLOBAL SECURITY_CACHE_LIST GlobalCertCache;

GLOBAL BOOL GlobalDisableNTLMPreAuth = FALSE;

//
// critical sections
//

GLOBAL CCritSec MlangCritSec;


// Mlang related data and functions.
PRIVATE HINSTANCE hInstMlang;
PRIVATE PFNINETMULTIBYTETOUNICODE pfnInetMultiByteToUnicode;
PRIVATE BOOL bFailedMlangLoad;  // So we don't try repeatedly if we fail once.
BOOL LoadMlang( );
BOOL UnloadMlang( );
#define MLANGDLLNAME    "mlang.dll"


//
// novell client32 (hack) "support"
//

GLOBAL BOOL GlobalRunningNovellClient32 = FALSE;
GLOBAL const BOOL GlobalNonBlockingClient32 = FALSE;

//
// proxy info
//

GLOBAL PROXY_INFO_GLOBAL * g_pGlobalProxyInfo;

//
// DLL version info
//

GLOBAL INTERNET_VERSION_INFO InternetVersionInfo = {
    WINHTTPX_MAJOR_VERSION,
    WINHTTPX_MINOR_VERSION
};

//
// HTTP version info - default 1.0
//

GLOBAL HTTP_VERSION_INFO HttpVersionInfo = {1, 0};


GLOBAL BOOL fCdromDialogActive = FALSE; // this needs to go

//
// The following globals are literal strings passed to winsock.
// Do NOT make them const, otherwise they end up in .text section,
// and web release of winsock2 has a bug where it locks and dirties
// send buffers, confusing the win95 vmm and resulting in code
// getting corrupted when it is paged back in.  -RajeevD
//

GLOBAL char gszAt[]   = "@";
GLOBAL char gszBang[] = "!";
GLOBAL char gszCRLF[] = "\r\n";


// cookie special casing
GLOBAL PTSTR GlobalSpecialDomains = NULL;
GLOBAL PTSTR *GlobalSDOffsets = NULL;

GLOBAL LONG g_cSessionCount=0;
GLOBAL CAsyncCount* g_pAsyncCount = NULL;

// implemented in ihttprequest\httprequest.cxx:
extern void CleanupWinHttpRequestGlobals();


//
// functions
//

BOOL AddEventSource(void)
{
    HKEY hKey; 
    DWORD dwData; 
    CHAR szBuf[80];
    DWORD dwDispo;
    // Add your source name as a subkey under the Application 
    // key in the EventLog registry key. 
 
    if (RegCreateKeyExA(HKEY_LOCAL_MACHINE, 
                        "SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\WinHttp5",
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_READ | KEY_WRITE,
                        NULL,
                        &hKey,
                        &dwDispo) != ERROR_SUCCESS)
    {
        return FALSE;
    }

    if (dwDispo == REG_OPENED_EXISTING_KEY)
    {
        RegCloseKey(hKey); 
        return TRUE;
    }
 
    // Set the name of the message file. 
 
    strcpy(szBuf, "%SystemRoot%\\System32\\WinHttp5.dll"); 
 
    // Add the name to the EventMessageFile subkey. 
 
    if (RegSetValueEx(hKey,             // subkey handle 
            "EventMessageFile",       // value name 
            0,                        // must be zero 
            REG_EXPAND_SZ,            // value type 
            (LPBYTE) szBuf,           // pointer to value data 
            strlen(szBuf) + 1) != ERROR_SUCCESS)       // length of value data
    {
        RegCloseKey(hKey); 
        return FALSE;
    }
 
    // Set the supported event types in the TypesSupported subkey. 
 
    dwData = EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE | 
        EVENTLOG_INFORMATION_TYPE; 
 
    if (RegSetValueEx(hKey,      // subkey handle 
            "TypesSupported",  // value name 
            0,                 // must be zero 
            REG_DWORD,         // value type 
            (LPBYTE) &dwData,  // pointer to value data 
            sizeof(DWORD)) != ERROR_SUCCESS)    // length of value data 
    {
        RegCloseKey(hKey); 
        return FALSE;
    }

    RegCloseKey(hKey);
    return TRUE;
} 

HANDLE g_hEventLog = 0;

BOOL InitializeEventLog(void)
{
    if (AddEventSource() == FALSE)
    {
        return FALSE;
    }

    g_hEventLog = ::RegisterEventSourceA(NULL, "WinHttp5");

    return g_hEventLog != NULL;
}

void TerminateEventLog(void)
{
    if (g_hEventLog)
    {
        ::DeregisterEventSource(g_hEventLog);
        g_hEventLog = NULL;
    }
}


#ifdef UNIX
extern "C"
#endif /* UNIX */
BOOL
GlobalDllInitialize(
    VOID
    )

/*++

Routine Description:

    The set of initializations - critical sections, etc. - that must be done at
    DLL_PROCESS_ATTACH

Arguments:

    None.

Return Value:

    TRUE, only FALSE when not enough memory to initialize globals

--*/

{
    BOOL fResult = FALSE;
    
    DEBUG_ENTER((DBG_GLOBAL,
                 None,
                 "GlobalDllInitialize",
                 NULL
                 ));

    InitializeEventLog();

    CLEAR_DEBUG_CRIT(szDebugBlankBuffer);

    if (MlangCritSec.Init() &&
        InitializeSerializedList(&GlobalObjectList) &&
        AuthOpen() &&
        IwinsockInitialize() &&
        SecurityInitialize()
        )
    {
        fResult = TRUE;
    }

    DEBUG_LEAVE(fResult);
    return fResult;
}


#ifdef UNIX
extern "C"
#endif /* UNIX */
VOID
GlobalDllTerminate(
    VOID
    )

/*++

Routine Description:

    Undoes the initializations of GlobalDllInitialize

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_GLOBAL,
                 None,
                 "GlobalDllTerminate",
                 NULL
                 ));

    //
    // only perform resource clean-up if this DLL is being unloaded due to a
    // FreeLibrary() call. Otherwise, we take the lazy way out and let the
    // system clean up after us
    //

    if (GlobalDynaUnload) {
        TerminateAsyncSupport(TRUE);
        IwinsockTerminate();
        HandleTerminate();
    }

    CHECK_SOCKETS();

    AuthClose();

    //
    //BUGBUG: we can't Terminate the list here because
    //        of a race condition from IE3
    //        (someone still holds the handle)
    //        but we don't want to leak the CritSec
    //        TerminateSerlizedList == DeleteCritSec + some Asserts
    //
    //TerminateSerializedList(&GlobalObjectList);
    GlobalObjectList.Lock.FreeLock();


    MlangCritSec.FreeLock();

    SecurityTerminate();

    TerminateEventLog();
    
    DEBUG_LEAVE(0);
}


DWORD
GlobalDataInitialize(
    VOID
    )

/*++

Routine Description:

    Loads any global data items from the registry

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DEBUG_ENTER((DBG_GLOBAL,
                 Dword,
                 "GlobalDataInitialize",
                 NULL
                 ));

    static BOOL Initializing = FALSE;
    static BOOL Initialized = FALSE;
    static DWORD error = ERROR_SUCCESS;
    
    //
    // only one thread initializes
    //

    if (InterlockedExchange((LPLONG)&Initializing, TRUE)) {
        while (!Initialized) {
            SleepEx(0, TRUE);
        }
        goto done;
    }
    
    //
    // create the global cert-cache and proxy lists
    //

    GlobalCertCache.Initialize();

    INET_ASSERT(g_pGlobalProxyInfo==NULL);
    g_pGlobalProxyInfo = New PROXY_INFO_GLOBAL();

    if (!g_pGlobalProxyInfo)
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    g_pGlobalProxyInfo->InitializeProxySettings();

    //
    // Load proxy config settings from registry...
    //
    error = LoadProxySettings();

    if (error != ERROR_SUCCESS)
        goto quit;



    char buf[MAX_PATH + 1];

    if (GetModuleFileName(NULL, buf, sizeof(buf))) {
        LPSTR p = strrchr(buf, DIR_SEPARATOR_CHAR);
        p = p ? ++p : buf;

        DEBUG_PRINT(INET, INFO, ("process is %q\n", p));

        if (lstrcmpi(p, "EXPLORER.EXE") && lstrcmpi(p, "IEXPLORE.EXE")) {

            //
            // yet another app-hack: AOL's current browser can't understand
            // HTTP 1.1. When they do, they have to call InternetSetOption()
            // with WINHTTP_OPTION_HTTP_VERSION
            //

            if (!lstrcmpi(p, "WAOL.EXE")) {
                GlobalEnableHttp1_1 = FALSE;
            }
        } else {
            GlobalIsProcessExplorer = TRUE;
        }
    } else {

        DEBUG_PRINT(INET,
                    INFO,
                    ("GetModuleFileName() returns %d\n",
                    GetLastError()
                    ));

    }

    //
    // perform module/package-specific initialization
    //

    error = HandleInitialize();
    if (error != ERROR_SUCCESS) {
        goto quit;
    }
    
quit:

    //
    // finally, if EnableHttp1_1 was set to non-zero in the registry, enable
    // HTTP 1.1
    //

    if (GlobalEnableHttp1_1) {
        HttpVersionInfo.dwMajorVersion = 1;
        HttpVersionInfo.dwMinorVersion = 1;
    }

    if (error == ERROR_SUCCESS) {
        GlobalDataInitialized = TRUE;
    }

    //
    // irrespective of success or failure, we have attempted global data
    // initialization. If we failed then we assume its something fundamental
    // and fatal: we don't try again
    //

    Initialized = TRUE;

done:

    DEBUG_LEAVE(error);

    return error;
}



VOID
GlobalDataTerminate(
    VOID
    )

/*++

Routine Description:

    Undoes work of GlobalDataInitialize()

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_GLOBAL,
                 None,
                 "GlobalDataTerminate",
                 NULL
                 ));

    RIP(g_cSessionCount == 0);
#ifndef WININET_SERVER_CORE
    //
    // Release background task manager
    //
    UnloadBackgroundTaskMgr();
#endif

    AuthUnload();

    if (GlobalSpecialDomains)
    {
        delete [] GlobalSpecialDomains;
        delete [] GlobalSDOffsets;
    }
    
    //
    // terminate the global cert-cache and proxy lists
    //

    GlobalCertCache.Terminate();

    if (g_pGlobalProxyInfo)
    {
        g_pGlobalProxyInfo->TerminateProxySettings();
        delete g_pGlobalProxyInfo;
        g_pGlobalProxyInfo = NULL;
    }

    //
    // ServerInfo's in WinHttpX are per-session instead of global.
    // InternetCloseHandle on a session handles purging the server
    // info list.
    //
#ifndef WININET_SERVER_CORE
    PurgeServerInfoList(TRUE);
#endif

    UnloadMlang();
    UnloadSecurity();


    CleanupWinHttpRequestGlobals();

    GlobalDataInitialized = FALSE;

    DEBUG_LEAVE(0);
}


BOOL
IsHttp1_1(
    VOID
    )

/*++

Routine Description:

    Determine if we are using HTTP 1.1 or greater

Arguments:

    None.

Return Value:

    BOOL

--*/

{
    return (HttpVersionInfo.dwMajorVersion > 1)
            ? TRUE
            : (((HttpVersionInfo.dwMajorVersion == 1)
                && (HttpVersionInfo.dwMajorVersion >= 1))
                ? TRUE
                : FALSE);
}



VOID
ChangeGlobalSettings(
    VOID
    )

/*++

Routine Description:

    Changes global settings

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_GLOBAL,
                 None,
                 "ChangeGlobalSettings",
                 NULL
                 ));

#ifndef WININET_SERVER_CORE
    InternetReadRegistryDword("EnableHttp1_1",
                              (LPDWORD)&GlobalEnableHttp1_1
                              );

    InternetReadRegistryDword("ProxyHttp1.1",
                              (LPDWORD)&GlobalEnableProxyHttp1_1
                              );

    if (!g_pGlobalProxyInfo->IsModifiedInProcess())
    {
        FixProxySettingsForCurrentConnection(
            FALSE
            );
    }

#endif //!WININET_SERVER_CORE

    DEBUG_LEAVE(0);
}



// Loads Mlang.dll and get the entry point we are interested in.

BOOL LoadMlang( )
{
    if (!MlangCritSec.Lock())
        goto quit;

    if (hInstMlang == NULL && !bFailedMlangLoad)
    {
        INET_ASSERT(pfnInetMultiByteToUnicode == NULL);
        hInstMlang = LoadLibrary(MLANGDLLNAME);

        if (hInstMlang != NULL)
        {
            pfnInetMultiByteToUnicode = (PFNINETMULTIBYTETOUNICODE)GetProcAddress
                                            (hInstMlang,"ConvertINetMultiByteToUnicode");
            if (pfnInetMultiByteToUnicode == NULL)
            {
                INET_ASSERT(FALSE);
                FreeLibrary(hInstMlang);
                hInstMlang = NULL;
            }
        }
        else
        {
            INET_ASSERT(FALSE); // bad news if we can't load mlang.dll
        }

        if (pfnInetMultiByteToUnicode == NULL)
            bFailedMlangLoad = TRUE;
    }

    MlangCritSec.Unlock();

quit:
    return (pfnInetMultiByteToUnicode != NULL);
}

BOOL UnloadMlang( )
{
    if (!MlangCritSec.Lock())
        return FALSE;

    if (hInstMlang)
        FreeLibrary(hInstMlang);

    hInstMlang = NULL;
    pfnInetMultiByteToUnicode = NULL;
    bFailedMlangLoad = FALSE;

    MlangCritSec.Unlock();

    return TRUE;
}

PFNINETMULTIBYTETOUNICODE GetInetMultiByteToUnicode( )
{
    // We are checking for pfnInetMultiByteToUnicode without getting a crit section.
    // This works only because UnloadMlang is called at the Dll unload time.

    if (pfnInetMultiByteToUnicode == NULL)
    {
        LoadMlang( );
    }

    return pfnInetMultiByteToUnicode;
}

int cdecl _sprintf(char* buffer, char* format, va_list args);

void LOG_EVENT(DWORD dwEventType, char* format, ...)
{
    if (g_hEventLog == NULL)
    {
        return;
    }

    va_list args;
    int n;
    char *pBuffer = (char *) ALLOCATE_FIXED_MEMORY(1024);

    if (pBuffer == NULL)
        return;

    va_start(args, format);
    n = _sprintf(pBuffer, format, args);
    va_end(args);
    
    LPCSTR pszMessages[1];
    pszMessages[0] = &pBuffer[0];

    ::ReportEvent(g_hEventLog, 
                  (WORD)dwEventType,
                  0,
                  dwEventType,
                  NULL,
                  1,
                  0,
                  &pszMessages[0],
                  NULL);

    FREE_MEMORY(pBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\api\inetapiu.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    inetapiu.cxx

Abstract:

    Contains WinInet API utility & sub-API functions

    Contents:
        wInternetQueryDataAvailable

Author:

    Richard L Firth (rfirth) 16-Feb-1996

Environment:

    Win32 user-level

Revision History:

    16-Feb-1996 rfirth
        Created

--*/

#include <wininetp.h>

//
// functions
//


BOOL
wInternetQueryDataAvailable(
    IN LPVOID hFileMapped,
    OUT LPDWORD lpdwNumberOfBytesAvailable,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    Part 2 of InternetQueryDataAvailabe. This function is called by the async
    worker thread in order to resume InternetQueryDataAvailable(), and by the
    app as the worker part of the API, post validation

    We can query available data for handle types that return data, either from
    a socket, or from a cache file:

        - HTTP request
        - FTP file
        - FTP find
        - FTP find HTML
        - gopher file
        - gopher find
        - gopher find HTML

Arguments:

    hFileMapped                 - the mapped HINTERNET

    lpdwNumberOfBytesAvailable  - where the number of bytes is returned

    dwFlags                     - flags controlling operation

    dwContext                   - context value for callbacks

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_INET,
                Bool,
                "wInternetQueryDataAvailable",
                "%#x, %#x, %#x, %#x",
                hFileMapped,
                lpdwNumberOfBytesAvailable,
                dwFlags,
                dwContext
                ));

    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
    DWORD error;
    HINTERNET_HANDLE_TYPE handleType;

    INET_ASSERT(hFileMapped);

    //
    // as usual, grab the per-thread info block
    //

    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto quit;
    }

    //
    // if this is the async worker thread then set the handle, and
    // last-error info in the per-thread data block before we go any further
    // (we already did this on the sync path)
    //

    if (lpThreadInfo->IsAsyncWorkerThread) {
        _InternetSetObjectHandle(lpThreadInfo,
                                 ((HANDLE_OBJECT *)hFileMapped)->GetPseudoHandle(),
                                 hFileMapped
                                 );
        _InternetClearLastError(lpThreadInfo);

        //
        // we should only be here in async mode if there was no data immediately
        // available
        //

        INET_ASSERT(!((INTERNET_HANDLE_OBJECT *)hFileMapped)->IsDataAvailable());

    }

    //
    // we copy the number of bytes available to a local variable first, and
    // only update the caller's variable if we succeed
    //

    DWORD bytesAvailable;

    //
    // get the current data available
    //

    error = ((HTTP_REQUEST_HANDLE_OBJECT *)hFileMapped)
                ->QueryDataAvailable(&bytesAvailable);

quit:

    BOOL success;

    if (error == ERROR_SUCCESS) {
        ((INTERNET_HANDLE_OBJECT *)hFileMapped)->SetAvailableDataLength(bytesAvailable);
        *lpdwNumberOfBytesAvailable = bytesAvailable;
        success = TRUE;

        DEBUG_PRINT(INET,
                    INFO,
                    ("%d bytes available\n",
                    bytesAvailable
                    ));

        DEBUG_PRINT_API(API,
                        INFO,
                        ("*lpdwNumberOfBytesAvailable (%#x) = %d\n",
                        lpdwNumberOfBytesAvailable,
                        bytesAvailable
                        ));

    } else {
        success = FALSE;

        DEBUG_ERROR(INET, error);

    }

    SetLastError(error);

    DEBUG_LEAVE(success);

    return success;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\api\inetapia.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    inetapia.cxx

Abstract:

    Contains the ANSI and character-mode-independent Internet APIs

    Contents:
        WinHttpCloseHandle
        WinHttpReadData
        WinHttpWriteData
        WinHttpQueryDataAvailable
        
    
        WinHttpCrackUrlA
        WinHttpCreateUrlA
        InternetCanonicalizeUrlA
        InternetCombineUrlA
        InternetOpenA
        _InternetCloseHandle
        _InternetCloseHandleNoContext
        InternetConnectA
        InternetOpenUrlA
        ReadFile_End
        InternetQueryOptionA
        InternetSetOptionA
        InternetGetLastResponseInfoA
        (wInternetCloseConnectA)
        (CreateDeleteSocket)

Author:

    Richard L Firth (rfirth) 02-Mar-1995

Environment:

    Win32 user-mode DLL

Revision History:

    02-Mar-1995 rfirth
        Created

    07-Mar-1995 madana


--*/


#include <wininetp.h>
#include <perfdiag.hxx>

//  because wininet doesnt know IStream
#define NO_SHLWAPI_STREAM
#include <shlwapi.h>
#include <shlwapip.h>


//
// private manifests
//

//
// private prototypes
//

PRIVATE
DWORD
ReadFile_Fsm(
    IN CFsm_ReadFile * Fsm
    );

PRIVATE
DWORD
ReadFileEx_Fsm(
    IN CFsm_ReadFileEx * Fsm
    );

PRIVATE
VOID
ReadFile_End(
    IN BOOL bDeref,
    IN BOOL bSuccess,
    IN HINTERNET hFileMapped,
    IN DWORD dwBytesRead,
    IN LPVOID lpBuffer OPTIONAL,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead OPTIONAL
    );

PRIVATE
DWORD
QueryAvailable_Fsm(
    IN CFsm_QueryAvailable * Fsm
    );


PRIVATE
DWORD
wInternetCloseConnectA(
    IN HINTERNET lpConnectHandle,
    IN DWORD ServiceType
    );

PRIVATE
BOOL
InternetParseCommon(
    IN LPCTSTR lpszBaseUrl,
    IN LPCTSTR lpszRelativeUrl,
    OUT LPTSTR lpszBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwFlags
    );


//
// functions
//


INTERNETAPI
BOOL
WINAPI
WinHttpCrackUrlA(
    IN LPCSTR lpszUrl,
    IN DWORD dwUrlLength,
    IN DWORD dwFlags,
    IN LPURL_COMPONENTSA lpUrlComponents
    )

/*++

Routine Description:

    Cracks an URL into its constituent parts. Optionally escapes the url-path.
    We assume that the user has supplied large enough buffers for the various
    URL parts

Arguments:

    lpszUrl         - pointer to URL to crack

    dwUrlLength     - 0 if lpszUrl is ASCIIZ string, else length of lpszUrl

    dwFlags         - flags controlling operation

    lpUrlComponents - pointer to URL_COMPONENTS

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "WinHttpCrackUrlA",
                     "%q, %#x, %#x, %#x",
                     lpszUrl,
                     dwUrlLength,
                     dwFlags,
                     lpUrlComponents
                     ));

    DWORD error;

    //
    // validate parameters
    //
    if (!dwUrlLength)
        dwUrlLength = lstrlen(lpszUrl);

    //
    // get the individual components to return. If they reference a buffer then
    // check it for writeability
    //

    LPSTR lpUrl;
    LPSTR urlCopy;
    INTERNET_SCHEME schemeType;
    LPSTR schemeName;
    DWORD schemeNameLength;
    LPSTR hostName;
    DWORD hostNameLength;
    INTERNET_PORT nPort;
    LPSTR userName;
    DWORD userNameLength;
    LPSTR password;
    DWORD passwordLength;
    LPSTR urlPath;
    DWORD urlPathLength;
    LPSTR extraInfo;
    DWORD extraInfoLength;
    BOOL copyComponent;
    BOOL havePort;

    copyComponent = FALSE;

    schemeName = lpUrlComponents->lpszScheme;
    schemeNameLength = lpUrlComponents->dwSchemeLength;
    if ((schemeName != NULL) && (schemeNameLength != 0)) 
    {
        *schemeName = '\0';
        copyComponent = TRUE;
    }

    hostName = lpUrlComponents->lpszHostName;
    hostNameLength = lpUrlComponents->dwHostNameLength;
    if ((hostName != NULL) && (hostNameLength != 0)) 
    {
        *hostName = '\0';
        copyComponent = TRUE;
    }

    userName = lpUrlComponents->lpszUserName;
    userNameLength = lpUrlComponents->dwUserNameLength;
    if ((userName != NULL) && (userNameLength != 0)) 
    {
        *userName = '\0';
        copyComponent = TRUE;
    }

    password = lpUrlComponents->lpszPassword;
    passwordLength = lpUrlComponents->dwPasswordLength;
    if ((password != NULL) && (passwordLength != 0)) 
    {
        *password = '\0';
        copyComponent = TRUE;
    }

    urlPath = lpUrlComponents->lpszUrlPath;
    urlPathLength = lpUrlComponents->dwUrlPathLength;
    if ((urlPath != NULL) && (urlPathLength != 0)) 
    {
        *urlPath = '\0';
        copyComponent = TRUE;
    }

    extraInfo = lpUrlComponents->lpszExtraInfo;
    extraInfoLength = lpUrlComponents->dwExtraInfoLength;
    if ((extraInfo != NULL) && (extraInfoLength != 0)) 
    {
        *extraInfo = '\0';
        copyComponent = TRUE;
    }

    //
    // we can only escape or decode the URL if the caller has provided us with
    // buffers to write the escaped strings into
    //

    if (dwFlags & (ICU_ESCAPE | ICU_DECODE)) {
        if (!copyComponent) {
            error = ERROR_INVALID_PARAMETER;
            goto quit;
        }

        //
        // create a copy of the URL. CrackUrl() will modify this in situ. We
        // need to copy the results back to the user's buffer(s)
        //

        urlCopy = NewString((LPSTR)lpszUrl, dwUrlLength);
        if (urlCopy == NULL) {
            error = ERROR_NOT_ENOUGH_MEMORY;
            goto quit;
        }
        lpUrl = urlCopy;
    } else {
        lpUrl = (LPSTR)lpszUrl;
        urlCopy = NULL;
    }

    //
    // crack the URL into its constituent parts
    //

    error = CrackUrl(lpUrl,
                     dwUrlLength,
                     (dwFlags & ICU_ESCAPE) ? TRUE : FALSE,
                     &schemeType,
                     &schemeName,
                     &schemeNameLength,
                     &hostName,
                     &hostNameLength,
                     &nPort,
                     &userName,
                     &userNameLength,
                     &password,
                     &passwordLength,
                     &urlPath,
                     &urlPathLength,
                     extraInfoLength ? &extraInfo : NULL,
                     extraInfoLength ? &extraInfoLength : 0,
                     &havePort
                     );
    if (error != ERROR_SUCCESS) {
        goto crack_error;
    }

    BOOL copyFailure;

    copyFailure = FALSE;

    //
    // update the URL_COMPONENTS structure based on the results, and what was
    // asked for
    //

    if (lpUrlComponents->lpszScheme != NULL) {
        if (lpUrlComponents->dwSchemeLength > schemeNameLength) {
            memcpy((LPVOID)lpUrlComponents->lpszScheme,
                   (LPVOID)schemeName,
                   schemeNameLength
                   );
            lpUrlComponents->lpszScheme[schemeNameLength] = '\0';
            if (dwFlags & ICU_DECODE) {
                UrlUnescapeInPlace(lpUrlComponents->lpszScheme, 0);
            }
        } else {
            ++schemeNameLength;
            copyFailure = TRUE;
        }
        lpUrlComponents->dwSchemeLength = schemeNameLength;
    } else if (lpUrlComponents->dwSchemeLength != 0) {
        lpUrlComponents->lpszScheme = schemeName;
        lpUrlComponents->dwSchemeLength = schemeNameLength;
    }

    if (lpUrlComponents->lpszHostName != NULL) {
        if (lpUrlComponents->dwHostNameLength > hostNameLength) {
            memcpy((LPVOID)lpUrlComponents->lpszHostName,
                   (LPVOID)hostName,
                   hostNameLength
                   );
            lpUrlComponents->lpszHostName[hostNameLength] = '\0';
            if (dwFlags & ICU_DECODE) {
                UrlUnescapeInPlace(lpUrlComponents->lpszHostName, 0);
            }
        } else {
            ++hostNameLength;
            copyFailure = TRUE;
        }
        lpUrlComponents->dwHostNameLength = hostNameLength;
    } else if (lpUrlComponents->dwHostNameLength != 0) {
        lpUrlComponents->lpszHostName = hostName;
        lpUrlComponents->dwHostNameLength = hostNameLength;
    }

    if (lpUrlComponents->lpszUserName != NULL) {
        if (lpUrlComponents->dwUserNameLength > userNameLength) {
            memcpy((LPVOID)lpUrlComponents->lpszUserName,
                   (LPVOID)userName,
                   userNameLength
                   );
            lpUrlComponents->lpszUserName[userNameLength] = '\0';
            if (dwFlags & ICU_DECODE) {
                UrlUnescapeInPlace(lpUrlComponents->lpszUserName, 0);
            }
        } else {
            ++userNameLength;
            copyFailure = TRUE;
        }
        lpUrlComponents->dwUserNameLength = userNameLength;
    } else if (lpUrlComponents->dwUserNameLength != 0) {
        lpUrlComponents->lpszUserName = userName;
        lpUrlComponents->dwUserNameLength = userNameLength;
    }

    if (lpUrlComponents->lpszPassword != NULL) {
        if (lpUrlComponents->dwPasswordLength > passwordLength) {
            memcpy((LPVOID)lpUrlComponents->lpszPassword,
                   (LPVOID)password,
                   passwordLength
                   );
            lpUrlComponents->lpszPassword[passwordLength] = '\0';
            if (dwFlags & ICU_DECODE) {
                UrlUnescapeInPlace(lpUrlComponents->lpszPassword, 0);
            }
        } else {
            ++passwordLength;
            copyFailure = TRUE;
        }
        lpUrlComponents->dwPasswordLength = passwordLength;
    } else if (lpUrlComponents->dwPasswordLength != 0) {
        lpUrlComponents->lpszPassword = password;
        lpUrlComponents->dwPasswordLength = passwordLength;
    }

    if (lpUrlComponents->lpszUrlPath != NULL) {
        if (lpUrlComponents->dwUrlPathLength > urlPathLength) {
            memcpy((LPVOID)lpUrlComponents->lpszUrlPath,
                   (LPVOID)urlPath,
                   urlPathLength
                   );
            lpUrlComponents->lpszUrlPath[urlPathLength] = '\0';
            if (dwFlags & ICU_DECODE) {
                UrlUnescapeInPlace(lpUrlComponents->lpszUrlPath, 0);
            }
            lpUrlComponents->dwUrlPathLength = urlPathLength;
        } else {
            ++urlPathLength;
            copyFailure = TRUE;
            lpUrlComponents->dwUrlPathLength = urlPathLength;
        }
    } else if (lpUrlComponents->dwUrlPathLength != 0) {
        lpUrlComponents->lpszUrlPath = urlPath;
        lpUrlComponents->dwUrlPathLength = urlPathLength;
    }

    if (lpUrlComponents->lpszExtraInfo != NULL) {
        if (lpUrlComponents->dwExtraInfoLength > extraInfoLength) {
            memcpy((LPVOID)lpUrlComponents->lpszExtraInfo,
                   (LPVOID)extraInfo,
                   extraInfoLength
                   );
            lpUrlComponents->lpszExtraInfo[extraInfoLength] = '\0';
            if (dwFlags & ICU_DECODE) {
                UrlUnescapeInPlace(lpUrlComponents->lpszExtraInfo, 0);
            }
        } else {
            ++extraInfoLength;
            copyFailure = TRUE;
        }
        lpUrlComponents->dwExtraInfoLength = extraInfoLength;
    } else if (lpUrlComponents->dwExtraInfoLength != 0) {
        lpUrlComponents->lpszExtraInfo = extraInfo;
        lpUrlComponents->dwExtraInfoLength = extraInfoLength;
    }

    //
    // we may have failed to copy one or more components because we didn't have
    // enough buffer space.
    //
    // N.B. Don't change error below here. If need be, move this test lower
    //

    if (copyFailure) {
        error = ERROR_INSUFFICIENT_BUFFER;
    }

    //
    // copy the scheme type
    //

    lpUrlComponents->nScheme = schemeType;

    //
    // convert 0 port (not in URL) to default value for scheme
    //

    if (nPort == INTERNET_INVALID_PORT_NUMBER && !havePort) {
        switch (schemeType) {
        case INTERNET_SCHEME_HTTP:
            nPort = INTERNET_DEFAULT_HTTP_PORT;
            break;

        case INTERNET_SCHEME_HTTPS:
            nPort = INTERNET_DEFAULT_HTTPS_PORT;
            break;
        }
    }
    lpUrlComponents->nPort = nPort;

crack_error:

    if (urlCopy != NULL) {
        DEL_STRING(urlCopy);
    }

quit:
    BOOL success = (error==ERROR_SUCCESS);

    if (!success) {
        DEBUG_ERROR(API, error);
        SetLastError(error);
    }

    DEBUG_LEAVE_API(success);
    return success;
}


INTERNETAPI
BOOL
WINAPI
WinHttpCreateUrlA(
    IN LPURL_COMPONENTSA lpUrlComponents,
    IN DWORD dwFlags,
    OUT LPSTR lpszUrl OPTIONAL,
    IN OUT LPDWORD lpdwUrlLength
    )

/*++

Routine Description:

    Creates an URL from its constituent parts

Arguments:

    lpUrlComponents - pointer to URL_COMPONENTS structure containing pointers
                      and lengths of components of interest

    dwFlags         - flags controlling function:

                        ICU_ESCAPE  - the components contain characters that
                                      must be escaped in the output URL

    lpszUrl         - pointer to buffer where output URL will be written

    lpdwUrlLength   - IN: number of bytes in lpszUrl buffer
                      OUT: if success, number of characters in lpszUrl, else
                           number of bytes required for buffer

Return Value:

    BOOL
        Success - URL written to lpszUrl

        Failure - call GetLastError() for more info

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "WinHttpCreateUrlA",
                     "%#x, %#x, %#x, %#x",
                     lpUrlComponents,
                     dwFlags,
                     lpszUrl,
                     lpdwUrlLength
                     ));

#if INET_DEBUG

    LPSTR lpszUrlOriginal = lpszUrl;

#endif

    DWORD error = ERROR_SUCCESS;
    LPSTR encodedUrlPath = NULL;
    LPSTR encodedExtraInfo = NULL;

    //
    // validate parameters
    //

    if (!ARGUMENT_PRESENT(lpszUrl)) {
        *lpdwUrlLength = 0;
    }

    //
    // allocate large buffers from heap
    //

    encodedUrlPath = (LPSTR)ALLOCATE_MEMORY(LMEM_FIXED, INTERNET_MAX_URL_LENGTH + 1);
    encodedExtraInfo = (LPSTR)ALLOCATE_MEMORY(LMEM_FIXED, INTERNET_MAX_URL_LENGTH + 1);
    if ((encodedUrlPath == NULL) || (encodedExtraInfo == NULL)) {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    //
    // if we get an exception, we return ERROR_INVALID_PARAMETER
    //
    
    __try {

        //
        // get the individual components to copy
        //

        LPSTR schemeName;
        DWORD schemeNameLength;
        DWORD schemeFlags;
        LPSTR hostName;
        DWORD hostNameLength;
        INTERNET_PORT nPort;
        DWORD portLength;
        LPSTR userName;
        DWORD userNameLength;
        LPSTR password;
        DWORD passwordLength;
        LPSTR urlPath;
        DWORD urlPathLength;
        DWORD extraLength;
        DWORD encodedUrlPathLength;
        LPSTR extraInfo;
        DWORD extraInfoLength;
        DWORD encodedExtraInfoLength;
        LPSTR schemeSep;
        DWORD schemeSepLength;
        INTERNET_SCHEME schemeType;
        INTERNET_PORT defaultPort;

        //
        // if the scheme name is absent then we use the default
        //

        schemeName = lpUrlComponents->lpszScheme;
        schemeType = lpUrlComponents->nScheme;

        if (schemeName == NULL) {
            if (schemeType == INTERNET_SCHEME_DEFAULT){
                schemeName = DEFAULT_URL_SCHEME_NAME;
                schemeNameLength = sizeof(DEFAULT_URL_SCHEME_NAME) - 1;
            }
            else {
                schemeName = MapUrlScheme(schemeType, &schemeNameLength);
            }
        } else {
            schemeNameLength = lpUrlComponents->dwSchemeLength;
            if (schemeNameLength == 0) {
                schemeNameLength = lstrlen(schemeName);
            }
        }

        if (schemeNameLength == 0)
        {
            error = ERROR_INVALID_PARAMETER;
            goto quit;
        }
        

        //
        // doesn't have to be a host name
        //

        hostName = lpUrlComponents->lpszHostName;
        portLength = 0;
        if (hostName != NULL) {
            hostNameLength = lpUrlComponents->dwHostNameLength;
            if (hostNameLength == 0) {
                hostNameLength = lstrlen(hostName);
            }

        //
        // if the port is default then we don't add it to the URL, else we need to
        // copy it as a string
        //
        // there won't be a port unless there's host.

            schemeType = MapUrlSchemeName(schemeName, schemeNameLength ? schemeNameLength : -1);
            switch (schemeType) {
            case INTERNET_SCHEME_HTTP:
                defaultPort = INTERNET_DEFAULT_HTTP_PORT;
                break;

            case INTERNET_SCHEME_HTTPS:
                defaultPort = INTERNET_DEFAULT_HTTPS_PORT;
                break;

            default:
                defaultPort = INTERNET_INVALID_PORT_NUMBER;
                break;
            }

            if (lpUrlComponents->nPort != defaultPort) {

                INTERNET_PORT divisor;

                nPort = lpUrlComponents->nPort;
                if (nPort) {
                    divisor = 10000;
                    portLength = 6; // max is 5 characters, plus 1 for ':'
                    while ((nPort / divisor) == 0) {
                        --portLength;
                        divisor /= 10;
                    }
                } else {
                    portLength = 2;         // port is ":0"
                }
            }
        } else {
            hostNameLength = 0;
        }


        //
        // doesn't have to be a user name
        //

        userName = lpUrlComponents->lpszUserName;
        if (userName != NULL) {
            userNameLength = lpUrlComponents->dwUserNameLength;
            if (userNameLength == 0) {
                userNameLength = lstrlen(userName);
            }
        } else {

            userNameLength = 0;
        }

        //
        // doesn't have to be a password
        //

        password = lpUrlComponents->lpszPassword;
        if (password != NULL) {
            passwordLength = lpUrlComponents->dwPasswordLength;
            if (passwordLength == 0) {
                passwordLength = lstrlen(password);
            }
        } else {

            passwordLength = 0;
        }

        //
        // but if there's a password without a user name, then its an error
        //

        if (password && !userName) {
            error = ERROR_INVALID_PARAMETER;
        } else {

            //
            // determine the scheme type for possible uses below
            //

            schemeFlags = 0;
            if (strnicmp(schemeName, "http", schemeNameLength) == 0) {
                schemeFlags = SCHEME_HTTP;
            } else if (strnicmp(schemeName, "ftp", schemeNameLength) == 0) {
                schemeFlags = SCHEME_FTP;
            } else if (strnicmp(schemeName, "gopher", schemeNameLength) == 0) {
                schemeFlags = SCHEME_GOPHER;
            }

            //
            // doesn't have to be an URL-path. Empty string is default
            //

            urlPath = lpUrlComponents->lpszUrlPath;
            if (urlPath != NULL) {
                urlPathLength = lpUrlComponents->dwUrlPathLength;
                if (urlPathLength == 0) {
                    urlPathLength = lstrlen(urlPath);
                }
                if ((*urlPath != '/') && (*urlPath != '\\')) {
                    extraLength = 1;
                } else {
                    extraLength = 0;
                }

                //
                // if requested, we will encode the URL-path
                //

                if (dwFlags & ICU_ESCAPE) {

                    //
                    // only encode the URL-path if it's a recognized scheme
                    //

                    if (schemeFlags != 0) {
                        encodedUrlPathLength = INTERNET_MAX_URL_LENGTH + 1;
                        error = EncodeUrlPath(NO_ENCODE_PATH_SEP,
                                              schemeFlags,
                                              urlPath,
                                              urlPathLength,
                                              &encodedUrlPath,
                                              &encodedUrlPathLength
                                              );
                        if (error == ERROR_SUCCESS) {
                            urlPath = encodedUrlPath;
                            urlPathLength = encodedUrlPathLength;
                        }
                    }
                }
            } else {
                urlPathLength = 0;
                extraLength = 0;
            }

            //
            // handle extra info if present
            //

            if (error == ERROR_SUCCESS) {
                extraInfo = lpUrlComponents->lpszExtraInfo;
                if (extraInfo != NULL) {
                    extraInfoLength = lpUrlComponents->dwExtraInfoLength;
                    if (extraInfoLength == 0) {
                        extraInfoLength = lstrlen(extraInfo);
                    }

                    //
                    // if requested, we will encode the extra info
                    //

                    if (dwFlags & ICU_ESCAPE) {

                        //
                        // only encode the extra info if it's a recognized scheme
                        //

                        if (schemeFlags != 0) {
                            encodedExtraInfoLength = INTERNET_MAX_URL_LENGTH + 1;
                            error = EncodeUrlPath(0,
                                                  schemeFlags,
                                                  extraInfo,
                                                  extraInfoLength,
                                                  &encodedExtraInfo,
                                                  &encodedExtraInfoLength
                                                  );
                            if (error == ERROR_SUCCESS) {
                                extraInfo = encodedExtraInfo;
                                extraInfoLength = encodedExtraInfoLength;
                            }
                        }
                    }
                } else {
                    extraInfoLength = 0;
                }
            }

            DWORD requiredSize;

            if (error == ERROR_SUCCESS) {

                //
                // Determine if we have a protocol scheme that requires slashes
                //

                if (DoesSchemeRequireSlashes(schemeName, schemeNameLength, (hostName != NULL))) {
                    schemeSep = "://";
                    schemeSepLength = sizeof("://") - 1;
                } else {
                    schemeSep = ":";
                    schemeSepLength = sizeof(":") - 1;
                }

                //
                // ensure we have enough buffer space
                //

                requiredSize = schemeNameLength
                             + schemeSepLength
                             + hostNameLength
                             + portLength
                             + (userName ? userNameLength + 1 : 0) // +1 for '@'
                             + (password ? passwordLength + 1 : 0) // +1 for ':'
                             + urlPathLength
                             + extraLength
                             + extraInfoLength
                             + 1                                // +1 for '\0'
                             ;

                //
                // if there is enough buffer, copy the URL
                //

                if (*lpdwUrlLength >= requiredSize) {
                    memcpy((LPVOID)lpszUrl, (LPVOID)schemeName, schemeNameLength);
                    lpszUrl += schemeNameLength;
                    memcpy((LPVOID)lpszUrl, (LPVOID)schemeSep, schemeSepLength);
                    lpszUrl += schemeSepLength;
                    if (userName) {
                        memcpy((LPVOID)lpszUrl, (LPVOID)userName, userNameLength);
                        lpszUrl += userNameLength;
                        if (password) {
                            *lpszUrl++ = ':';
                            memcpy((LPVOID)lpszUrl, (LPVOID)password, passwordLength);
                            lpszUrl += passwordLength;
                        }
                        *lpszUrl++ = '@';
                    }
                    if (hostName) {
                        memcpy((LPVOID)lpszUrl, (LPVOID)hostName, hostNameLength);
                        lpszUrl += hostNameLength;

                        // We won't attach a port unless there's a host to go with it.
                        if (portLength) {
                            lpszUrl += wsprintf(lpszUrl, ":%d", nPort & 0xffff);
                        }

                    }
                    if (urlPath) {

                        //
                        // Only do extraLength if we've actually copied something
                        // after the scheme.
                        //

                        if (extraLength != 0 && (userName || hostName || portLength)) {
                            *lpszUrl++ = '/';
                        } else if (extraLength != 0) {
                            --requiredSize;
                        }
                        memcpy((LPVOID)lpszUrl, (LPVOID)urlPath, urlPathLength);
                        lpszUrl += urlPathLength;
                    } else if (extraLength != 0) {
                        --requiredSize;
                    }
                    if (extraInfo) {
                        memcpy((LPVOID)lpszUrl, (LPVOID)extraInfo, extraInfoLength);
                        lpszUrl += extraInfoLength;
                    }

                    //
                    // terminate string
                    //

                    *lpszUrl = '\0';

                    //
                    // -1 for terminating '\0'
                    //

                    --requiredSize;
                } else {

                    //
                    // not enough buffer space - just return the required buffer length
                    //

                    error = ERROR_INSUFFICIENT_BUFFER;
                }
            }

            //
            // update returned parameters
            //

            *lpdwUrlLength = requiredSize;
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        error = ERROR_INVALID_PARAMETER;
    }
    ENDEXCEPT
quit:

    //
    // clear up the buffers we allocated
    //


    if (encodedUrlPath != NULL) {
        FREE_MEMORY(encodedUrlPath);
    }
    if (encodedExtraInfo != NULL) {
        FREE_MEMORY(encodedExtraInfo);
    }

    BOOL success = (error==ERROR_SUCCESS);

    if (success) {

        DEBUG_PRINT_API(API,
                        INFO,
                        ("URL = %q\n",
                        lpszUrlOriginal
                        ));
    } else {

        DEBUG_ERROR(API, error);
        SetLastError(error);
    }

    DEBUG_LEAVE_API(success);
    return success;
}

//
//  ICUHrToWin32Error() is specifically for converting the return codes for
//  Url* APIs in shlwapi into win32 errors.
//  WARNING:  it should not be used for any other purpose.
//
DWORD
ICUHrToWin32Error(HRESULT hr)
{
    DWORD err = ERROR_INVALID_PARAMETER;
    switch(hr)
    {
    case E_OUTOFMEMORY:
        err = ERROR_NOT_ENOUGH_MEMORY;
        break;

    case E_POINTER:
        err = ERROR_INSUFFICIENT_BUFFER;
        break;

    case S_OK:
        err = ERROR_SUCCESS;
        break;

    default:
        break;
    }
    return err;
}


INTERNETAPI
BOOL
WINAPI
InternetCanonicalizeUrlA(
    IN LPCSTR lpszUrl,
    OUT LPSTR lpszBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Combines a relative URL with a base URL to form a new full URL.

Arguments:

    lpszUrl             - pointer to URL to be canonicalize
    lpszBuffer          - pointer to buffer where new URL is written
    lpdwBufferLength    - size of buffer on entry, length of new URL on exit
    dwFlags             - flags controlling operation

Return Value:

    BOOL                - TRUE if successful, FALSE if not

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetCanonicalizeUrlA",
                     "%q, %#x, %#x [%d], %#x",
                     lpszUrl,
                     lpszBuffer,
                     lpdwBufferLength,
                     lpdwBufferLength ? *lpdwBufferLength : 0,
                     dwFlags
                     ));

    HRESULT hr ;
    BOOL bRet = TRUE;;

    INET_ASSERT(lpszUrl);
    INET_ASSERT(lpszBuffer);
    INET_ASSERT(lpdwBufferLength && (*lpdwBufferLength > 0));

    //
    //  the flags for the Url* APIs in shlwapi should be the same
    //  except that NO_ENCODE is on by default.  so we need to flip it
    //
    dwFlags ^= ICU_NO_ENCODE;

    // Check for invalid parameters

    if (!lpszUrl || !lpszBuffer || !lpdwBufferLength || *lpdwBufferLength == 0 || IsBadWritePtr(lpszBuffer, *lpdwBufferLength*sizeof(CHAR)))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = UrlCanonicalizeA(lpszUrl, lpszBuffer,
                    lpdwBufferLength, dwFlags | URL_WININET_COMPATIBILITY);
    }

    if(FAILED(hr))
    {
        DWORD dw = ICUHrToWin32Error(hr);

        bRet = FALSE;

        DEBUG_ERROR(API, dw);

        SetLastError(dw);
    }

    DEBUG_LEAVE_API(bRet);

    return bRet;
}


INTERNETAPI
BOOL
WINAPI
InternetCombineUrlA(
    IN LPCSTR lpszBaseUrl,
    IN LPCSTR lpszRelativeUrl,
    OUT LPSTR lpszBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Combines a relative URL with a base URL to form a new full URL.

Arguments:

    lpszBaseUrl         - pointer to base URL
    lpszRelativeUrl     - pointer to relative URL
    lpszBuffer          - pointer to buffer where new URL is written
    lpdwBufferLength    - size of buffer on entry, length of new URL on exit
    dwFlags             - flags controlling operation

Return Value:

    BOOL                - TRUE if successful, FALSE if not

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetCombineUrlA",
                     "%q, %q, %#x, %#x [%d], %#x",
                     lpszBaseUrl,
                     lpszRelativeUrl,
                     lpszBuffer,
                     lpdwBufferLength,
                     lpdwBufferLength ? *lpdwBufferLength : 0,
                     dwFlags
                     ));

    HRESULT hr ;
    BOOL bRet;

    INET_ASSERT(lpszBaseUrl);
    INET_ASSERT(lpszRelativeUrl);
    INET_ASSERT(lpdwBufferLength);

    //
    //  the flags for the Url* APIs in shlwapi should be the same
    //  except that NO_ENCODE is on by default.  so we need to flip it
    //
    dwFlags ^= ICU_NO_ENCODE;

    // Check for invalid parameters

    if (!lpszBaseUrl || !lpszRelativeUrl || !lpdwBufferLength || (lpszBuffer && IsBadWritePtr(lpszBuffer, *lpdwBufferLength*sizeof(CHAR))))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = UrlCombineA(lpszBaseUrl, lpszRelativeUrl, lpszBuffer,
                    lpdwBufferLength, dwFlags | URL_WININET_COMPATIBILITY);
    }

    if(FAILED(hr))
    {
        DWORD dw = ICUHrToWin32Error(hr);

        bRet = FALSE;

        DEBUG_ERROR(API, dw);

        SetLastError(dw);
    }
    else
        bRet = TRUE;

    IF_DEBUG_CODE() {
        if (bRet) {
            DEBUG_PRINT_API(API,
                            INFO,
                            ("URL = %q\n",
                            lpszBuffer
                            ));
        }
    }

    DEBUG_LEAVE_API(bRet);

    return bRet;
}


INTERNETAPI
HINTERNET
WINAPI
InternetOpenA(
    IN LPCSTR lpszAgent,
    IN DWORD dwAccessType,
    IN LPCSTR lpszProxy OPTIONAL,
    IN LPCSTR lpszProxyBypass OPTIONAL,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Opens a root Internet handle from which all HINTERNET objects are derived

Arguments:

    lpszAgent       - name of the application making the request (arbitrary
                      identifying string). Used in "User-Agent" header when
                      communicating with HTTP servers, if the application does
                      not add a User-Agent header of its own

    dwAccessType    - type of access required. Can be

                        INTERNET_OPEN_TYPE_PRECONFIG
                            - Gets the configuration from the registry

                        INTERNET_OPEN_TYPE_DIRECT
                            - Requests are made directly to the nominated server

                        INTERNET_OPEN_TYPE_PROXY
                            - Requests are made via the nominated proxy

                        INTERNET_OPEN_TYPE_PRECONFIG_WITH_NO_AUTOPROXY
                            - Like Pre-Config, but prevents JavaScript, INS
                                and other auto-proxy types from being used.

    lpszProxy       - if INTERNET_OPEN_TYPE_PROXY, a list of proxy servers to
                      use

    lpszProxyBypass - if INTERNET_OPEN_TYPE_PROXY, a list of servers which we
                      will communicate with directly

    dwFlags         - flags to control the operation of this API or potentially
                      all APIs called on the handle generated by this API.
                      Currently supported are:

                        WINHTTP_FLAG_ASYNC - Not supported in WinHttpX v6.


Return Value:

    HINTERNET
        Success - handle of Internet object

        Failure - NULL. For more information, call GetLastError()

--*/

{
    PERF_INIT();

    DEBUG_ENTER_API((DBG_API,
                     Handle,
                     "InternetOpenA",
                     "%q, %s (%d), %q, %q, %#x",
                     lpszAgent,
                     InternetMapOpenType(dwAccessType),
                     dwAccessType,
                     lpszProxy,
                     lpszProxyBypass,
                     dwFlags
                     ));

    DWORD error;
    HINTERNET hInternet = NULL;

    if (!GlobalDataInitialized) {
        error = GlobalDataInitialize();
        if (error != ERROR_SUCCESS) {
            goto quit;
        }
    }

    //
    // validate parameters
    //

    if (!
         (
              (dwAccessType == INTERNET_OPEN_TYPE_DIRECT)
           || (dwAccessType == INTERNET_OPEN_TYPE_PROXY)
           || (dwAccessType == INTERNET_OPEN_TYPE_PRECONFIG)
           || (dwAccessType == INTERNET_OPEN_TYPE_PRECONFIG_WITH_NO_AUTOPROXY)
           || (
                (dwAccessType == INTERNET_OPEN_TYPE_PROXY)
                &&
                    (
                       !ARGUMENT_PRESENT(lpszProxy)
                    || (*lpszProxy == '\0')

                    )
              )
           || (dwFlags & ~WINHTTP_OPEN_FLAGS_MASK)
         )
       )
    {
        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }


    INTERNET_HANDLE_OBJECT * lpInternet;

    lpInternet = New INTERNET_HANDLE_OBJECT(lpszAgent,
                                            dwAccessType,
                                            (LPSTR)lpszProxy,
                                            (LPSTR)lpszProxyBypass,
                                            dwFlags
                                            );
    if (lpInternet == NULL) {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }
    error = lpInternet->GetStatus();
    if (error == ERROR_SUCCESS) {
        hInternet = (HINTERNET)lpInternet;

        //
        // success - don't return the object address, return the pseudo-handle
        // value we generated
        //

        hInternet = ((HANDLE_OBJECT *)hInternet)->GetPseudoHandle();
        
    } else {

        //
        // hack fix to stop InternetIndicateStatus (called from the handle
        // object destructor) blowing up if there is no handle object in the
        // thread info block. We can't call back anyway
        //

        LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

        if (lpThreadInfo) {

            //
            // BUGBUG - incorrect handle value
            //

            _InternetSetObjectHandle(lpThreadInfo, lpInternet, lpInternet);
        }

        //
        // we failed during initialization. Kill the handle using Dereference()
        // (in order to stop the debug version complaining about the reference
        // count not being 0. Invalidate for same reason)
        //

        lpInternet->Invalidate();
        lpInternet->Dereference();

        INET_ASSERT(hInternet == NULL);

    }

quit:

    if (error != ERROR_SUCCESS) {

        DEBUG_ERROR(API, error);

        SetLastError(error);
    }

    DEBUG_LEAVE_API(hInternet);

    return hInternet;
}


INTERNETAPI
BOOL
WINAPI
WinHttpCloseHandle(
    IN HINTERNET hInternet
    )

/*++

Routine Description:

    Closes any open internet handle object

Arguments:

    hInternet   - handle of internet object to close

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. For more information call GetLastError()

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "WinHttpCloseHandle",
                     "%#x",
                     hInternet
                     ));

    PERF_ENTER(InternetCloseHandle);

    DWORD error;
    BOOL success = FALSE;
    HINTERNET hInternetMapped = NULL;

    if (!GlobalDataInitialized) {
        error = GlobalDataInitialize();
        if (error != ERROR_SUCCESS) {
            goto quit;
        }
    }

    //
    // map the handle. Don't invalidate it (_InternetCloseHandle() does this)
    //

    error = MapHandleToAddress(hInternet, (LPVOID *)&hInternetMapped, FALSE);
    if (error != ERROR_SUCCESS) {
        if (hInternetMapped == NULL) {

            //
            // the handle never existed or has been completely destroyed
            //

            DEBUG_PRINT(API,
                        ERROR,
                        ("Handle %#x is invalid\n",
                        hInternet
                        ));

            //
            // catch invalid handles - may help caller
            //

            DEBUG_BREAK(INVALID_HANDLES);

        } else {

            //
            // this handle is already being closed (it's invalidated). We only
            // need one InternetCloseHandle() operation to invalidate the handle.
            // All other threads will simply dereference the handle, and
            // eventually it will be destroyed
            //

            DereferenceObject((LPVOID)hInternetMapped);
        }
        goto quit;
    }

    //
    // the handle is not invalidated
    //

    HANDLE_OBJECT * pHandle;

    pHandle = (HANDLE_OBJECT *)hInternetMapped;

    DEBUG_PRINT(INET,
                INFO,
                ("handle %#x == %#x == %s\n",
                hInternet,
                hInternetMapped,
                InternetMapHandleType(pHandle->GetHandleType())
                ));

    //
    // clear the handle object last error variables
    //

    InternetClearLastError();

    //
    // decrement session count here rather than in destructor, since 
    // the session is ref-counted and there may still be outstanding
    // references from request/connect handles on async fsms.
    //
    if (pHandle->GetHandleType() == TypeInternetHandle)
    {
        InterlockedDecrement(&g_cSessionCount);
    }

    //
    // remove the reference added by MapHandleToAddress(), or the handle won't
    // be destroyed by _InternetCloseHandle()
    //

    DereferenceObject((LPVOID)hInternetMapped);

    //
    // use _InternetCloseHandle() to do the work
    //

    success = _InternetCloseHandle(hInternet);

quit:

    // SetLastError must be called after PERF_LEAVE !!!
    PERF_LEAVE(InternetCloseHandle);

    if (error != ERROR_SUCCESS) {
        DEBUG_ERROR(API, error);
        SetLastError(error);
    }

    DEBUG_LEAVE_API(success);

    return success;
}


BOOL
_InternetCloseHandle(
    IN HINTERNET hInternet
    )

/*++

Routine Description:

    Same as InternetCloseHandle() except does not clear out the last error text.
    Mainly for FTP

Arguments:

    hInternet   - handle of internet object to close

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. For more information call GetLastError()

--*/

{
    DEBUG_ENTER((DBG_INET,
                 Bool,
                 "_InternetCloseHandle",
                 "%#x",
                 hInternet
                 ));

    DWORD error;
    BOOL success;
    HINTERNET hInternetMapped = NULL;
    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

    if (lpThreadInfo == NULL) {
        if (InDllCleanup) {
            error = ERROR_WINHTTP_SHUTDOWN;
        } else {

            INET_ASSERT(FALSE);

            error = ERROR_WINHTTP_INTERNAL_ERROR;
        }
        goto quit;
    }

    //
    // map the handle and invalidate it. This will cause any new requests with
    // the handle as a parameter to fail
    //

    error = MapHandleToAddress(hInternet, (LPVOID *)&hInternetMapped, TRUE);
    if (error != ERROR_SUCCESS) {
        if (hInternetMapped != NULL) {

            //
            // the handle is already being closed, or is already deleted
            //

            DereferenceObject((LPVOID)hInternetMapped);
        }

        //
        // since this is the only function that can invalidate a handle, if we
        // are here then the handle is just waiting for its refcount to go to
        // zero. We already removed the refcount we added above, so we're in
        // the clear
        //

        goto quit;
    }

    //
    // there may be an active socket operation. We close the socket to abort the
    // operation
    //

    ((INTERNET_HANDLE_OBJECT *)hInternetMapped)->AbortSocket();

    //
    // we need the parent handle - we will set this as the handle object being
    // processed by this thread. This is required for async worker threads (see
    // below)
    //

    HINTERNET hParent;
    HINTERNET hParentMapped;
    DWORD_PTR dwParentContext;

    hParentMapped = ((HANDLE_OBJECT *)hInternetMapped)->GetParent();
    if (hParentMapped != NULL) {
        hParent = ((HANDLE_OBJECT *)hParentMapped)->GetPseudoHandle();
        dwParentContext = ((HANDLE_OBJECT *)hParentMapped)->GetContext();
    }

    //
    // set the object handle in the per-thread data structure
    //

    _InternetSetObjectHandle(lpThreadInfo, hInternet, hInternetMapped);

    //
    // at this point, there should *always* be at least 2 references on the
    // handle - one added when the object was created, and one added by
    // MapHandleToAddress() above. If the object is still alive after the 2
    // dereferences, then it will be destroyed when the current owning thread
    // dereferences it
    //

    (void)DereferenceObject((LPVOID)hInternetMapped);
    error = DereferenceObject((LPVOID)hInternetMapped);

    //
    // now set the object to be the parent. This is necessary for e.g.
    // FtpGetFile() and async requests (where the async worker thread will make
    // an extra callback to deliver the results of the async request)
    //

    if (hParentMapped != NULL) {
        _InternetSetObjectHandle(lpThreadInfo, hParent, hParentMapped);
    }

    //
    // if the handle was still alive after dereferencing it then we will inform
    // the app that the close is pending
    //

quit:

    success = (error==ERROR_SUCCESS);
    if (!success) {
        SetLastError(error);
        DEBUG_ERROR(INET, error);
    }
    DEBUG_LEAVE(success);
    return success;
}


DWORD
_InternetCloseHandleNoContext(
    IN HINTERNET hInternet
    )

/*++

Routine Description:

    Same as _InternetCloseHandle() except does not change the per-thread info
    structure handle/context values

    BUGBUG - This should be handled via a parameter to _InternetCloseHandle(),
             but its close to shipping...

Arguments:

    hInternet   - handle of internet object to close

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_HANDLE

--*/

{
    DEBUG_ENTER((DBG_INET,
                 Bool,
                 "_InternetCloseHandleNoContext",
                 "%#x",
                 hInternet
                 ));

    DWORD error;
    HINTERNET hInternetMapped = NULL;

    //
    // map the handle and invalidate it. This will cause any new requests with
    // the handle as a parameter to fail
    //

    error = MapHandleToAddress(hInternet, (LPVOID *)&hInternetMapped, TRUE);
    if (error != ERROR_SUCCESS) {
        if (hInternetMapped != NULL) {

            //
            // the handle is already being closed, or is already deleted
            //

            DereferenceObject((LPVOID)hInternetMapped);
        }

        //
        // since this is the only function that can invalidate a handle, if we
        // are here then the handle is just waiting for its refcount to go to
        // zero. We already removed the refcount we added above, so we're in
        // the clear
        //

        goto quit;
    }

    //
    // there may be an active socket operation. We close the socket to abort the
    // operation
    //

    ((INTERNET_HANDLE_OBJECT *)hInternetMapped)->AbortSocket();

    //
    // at this point, there should *always* be at least 2 references on the
    // handle - one added when the object was created, and one added by
    // MapHandleToAddress() above. If the object is still alive after the 2
    // dereferences, then it will be destroyed when the current owning thread
    // dereferences it
    //

    (void)DereferenceObject((LPVOID)hInternetMapped);
    error = DereferenceObject((LPVOID)hInternetMapped);

quit:

    DEBUG_LEAVE(error);

    return error;
}



INTERNETAPI
HINTERNET
WINAPI
InternetConnectA(
    IN HINTERNET hInternet,
    IN LPCSTR lpszServerName,
    IN INTERNET_PORT nServerPort,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    Opens a connection with a server, logging-on the user in the process.

Arguments:

    hInternet       - Internet handle, returned by InternetOpen()

    lpszServerName  - name of server with which to connect

    nServerPort     - port at which server listens

    dwFlags         - protocol-specific flags. The following are defined:
                        - INTERNET_FLAG_KEEP_CONNECTION (HTTP)
                        - WINHTTP_FLAG_SECURE (HTTP)

    dwContext       - application-supplied value used to identify this
                      request in callbacks

Return Value:

    HINTERNET
        Success - address of a new handle object

        Failure - NULL. Call GetLastError() for more info

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Handle,
                     "InternetConnectA",
                     "%#x, %q, %d, %#08x, %#x",
                     hInternet,
                     lpszServerName,
                     nServerPort,
                     dwFlags,
                     dwContext
                     ));

    HINTERNET connectHandle = NULL;
    HINTERNET hInternetMapped = NULL;

    LPINTERNET_THREAD_INFO lpThreadInfo;

    INTERNET_CONNECT_HANDLE_OBJECT * pConnect = NULL;

    BOOL bIsWorker = FALSE;
    BOOL bNonNestedAsync = FALSE;
    BOOL isAsync;

    DWORD error = ERROR_SUCCESS;

    if (!GlobalDataInitialized) {
        error = ERROR_WINHTTP_NOT_INITIALIZED;
        goto done;
    }

    //
    // get the per-thread info block
    //

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto done;
    }

    _InternetIncNestingCount();
    bIsWorker = lpThreadInfo->IsAsyncWorkerThread;
    bNonNestedAsync = bIsWorker && (lpThreadInfo->NestedRequests == 1);

    //
    // handle/refcount munging:
    //
    //  sync:
    //      map hInternet on input (+1 ref)
    //      generate connect handle (1 ref)
    //      if failure && !connect handle
    //          close connect handle (0 refs: delete)
    //      if success
    //          deref hInternet (-1 ref)
    //      else if going async
    //          ref connect handle (2 refs)
    //
    //  async:
    //      hInternet is mapped connect handle (2 refs)
    //      get real hInternet from connect handle parent (2 refs (e.g.))
    //      deref connect handle (1 ref)
    //      if failure
    //          close connect handle (0 refs: delete)
    //      deref open handle (-1 ref)
    //
    // N.B. the final deref of the *indicated* handle on async callback will
    // happen in the async code
    //

    if (bNonNestedAsync) {
        connectHandle = hInternet;
        hInternetMapped = ((HANDLE_OBJECT *)connectHandle)->GetParent();
        hInternet = ((HANDLE_OBJECT *)hInternetMapped)->GetPseudoHandle();
    } else {
        error = MapHandleToAddress(hInternet, (LPVOID *)&hInternetMapped, FALSE);
        if ((error != ERROR_SUCCESS) && (hInternetMapped == NULL)) {
            goto quit;
        }

        //
        // set the info and clear the last error info
        //

        _InternetSetObjectHandle(lpThreadInfo, hInternet, hInternetMapped);
        _InternetClearLastError(lpThreadInfo);

        //
        // quit now if the handle object is invalidated
        //

        if (error != ERROR_SUCCESS) {
            goto quit;
        }

        //
        // validate the handle & discover sync/async
        //

        error = RIsHandleLocal(hInternetMapped,
                               NULL,
                               &isAsync,
                               TypeInternetHandle
                               );
        if (error != ERROR_SUCCESS) {
            goto quit;
        }

        //
        // we allow all valid flags to be passed in
        //

        if ((dwFlags & ~WINHTTP_CONNECT_FLAGS_MASK)
            || (lpszServerName == NULL)
            || (*lpszServerName == '\0')) 
        {
            error = ERROR_INVALID_PARAMETER;
            goto quit;
        }
    }

    //
    // validate arguments if we're not in the async thread context, in which
    // case we did this when the original request was made
    //

    if (bNonNestedAsync)
    {
        pConnect = (INTERNET_CONNECT_HANDLE_OBJECT *)connectHandle;
    }
    else
    {
        //
        // app thread or in async worker thread but being called from another
        // async API, such as InternetOpenUrl()
        //

        INET_ASSERT(connectHandle == NULL);
        INET_ASSERT(error == ERROR_SUCCESS);
           
        error = RMakeInternetConnectObjectHandle(
                    hInternetMapped,
                    &connectHandle,
                    (LPSTR) lpszServerName,
                    nServerPort,
                    dwFlags,
                    dwContext
                    );
        if (error != ERROR_SUCCESS) {
            goto quit;
        }

        //
        // this new handle will be used in callbacks
        //

        _InternetSetObjectHandle(lpThreadInfo,
                                 ((HANDLE_OBJECT *)connectHandle)->GetPseudoHandle(),
                                 connectHandle
                                 );

        //
        // based on whether we have been asked to perform async I/O AND we are not
        // in an async worker thread context AND the request is to connect with an
        // FTP service (currently only FTP because this request performs network
        // I/O - gopher and HTTP just allocate & fill in memory) AND there is a
        // valid context value, we will queue the async request, or execute the
        // request synchronously
        //

        pConnect = (INTERNET_CONNECT_HANDLE_OBJECT *)connectHandle;
    }
    

    INET_ASSERT(error == ERROR_SUCCESS);

quit:

    _InternetDecNestingCount(1);


done:

    if (error == ERROR_SUCCESS) {

        //
        // success - return generated pseudo-handle
        //

        connectHandle = ((HANDLE_OBJECT *)connectHandle)->GetPseudoHandle();

    } else {
        if (bNonNestedAsync
            && (/*((HANDLE_OBJECT *)connectHandle)->Dereference()
                ||*/ ((HANDLE_OBJECT *)connectHandle)->IsInvalidated())) {
            error = ERROR_WINHTTP_OPERATION_CANCELLED;
        }

        //
        // if we are not pending an async request but we created a handle object
        // then close it
        //

        if ((error != ERROR_IO_PENDING) && (connectHandle != NULL)) {

            //
            // use _InternetCloseHandle() to close the handle: it doesn't clear
            // out the last error text, so that an app can find out what the
            // server sent us in the event of an FTP login failure
            //


            if (bNonNestedAsync) {

                //
                // this handle deref'd at async completion
                //

                hInternetMapped = NULL;
            }
            else
            {
                _InternetCloseHandle(((HANDLE_OBJECT *)connectHandle)->GetPseudoHandle());
            }
        }
        connectHandle = NULL;
    }
    if (hInternetMapped != NULL) {
        DereferenceObject((LPVOID)hInternetMapped);
    }
    if (error != ERROR_SUCCESS) {
        DEBUG_ERROR(API, error);
        SetLastError(error);
    }
    DEBUG_LEAVE_API(connectHandle);
    return connectHandle;
}



INTERNETAPI
HINTERNET
WINAPI
InternetOpenUrlA(
    IN HINTERNET hInternet,
    IN LPCSTR lpszUrl,
    IN LPCSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )
{
    // this is dead code
    return FALSE;
}



INTERNETAPI
BOOL
WINAPI
WinHttpReadData(
    IN HINTERNET hFile,
    IN LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead
    )

/*++

Routine Description:

    This functions reads the next block of data from the file object.

Arguments:

    hFile                   - handle returned from Open function

    lpBuffer                - pointer to caller's buffer

    dwNumberOfBytesToRead   - size of lpBuffer in BYTEs

    lpdwNumberOfBytesRead   - returned number of bytes read into lpBuffer

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "WinHttpReadData",
                     "%#x, %#x, %d, %#x",
                     hFile,
                     lpBuffer,
                     dwNumberOfBytesToRead,
                     lpdwNumberOfBytesRead
                     ));

    LPINTERNET_THREAD_INFO lpThreadInfo;
    DWORD nestingLevel = 0;
    DWORD error;
    BOOL success = FALSE;
    HINTERNET hFileMapped = NULL;
    DWORD bytesRead = 0;
    BOOL bEndRead = TRUE;

    if (!GlobalDataInitialized)
    {
        error = ERROR_WINHTTP_NOT_INITIALIZED;
        goto done;
    }

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL)
    {
        INET_ASSERT(FALSE);
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto done;
    }

    //INET_ASSERT(lpThreadInfo->Fsm == NULL);

    _InternetIncNestingCount();
    nestingLevel = 1;

    error = MapHandleToAddress(hFile, (LPVOID *)&hFileMapped, FALSE);
    if ((error != ERROR_SUCCESS) && (hFileMapped == NULL))
    {
        goto quit;
    }

    // set the handle, and last-error info in the per-thread data block
    // before we go any further. This allows us to return a status in the async
    // case, even if the handle has been closed

    if (!lpThreadInfo->IsAsyncWorkerThread)
    {
        PERF_LOG(PE_CLIENT_REQUEST_START,
                 AR_INTERNET_READ_FILE,
                 lpThreadInfo->ThreadId,
                 hFile
                 );
    }

    _InternetSetObjectHandle(lpThreadInfo, hFile, hFileMapped);
    _InternetClearLastError(lpThreadInfo);

    // if MapHandleToAddress() returned a non-NULL object address, but also an
    // error status, then the handle is being closed - quit
    if (error != ERROR_SUCCESS)
    {
        goto quit;
    }

    BOOL isAsync;
    error = RIsHandleLocal(hFileMapped, NULL, &isAsync, TypeHttpRequestHandle);
    if (error != ERROR_SUCCESS)
    {
        INET_ASSERT(FALSE);
        goto quit;
    }

    // validate parameters
    if (!lpThreadInfo->IsAsyncWorkerThread)
    {
        error = ProbeAndSetDword(lpdwNumberOfBytesRead, 0);
        if (error != ERROR_SUCCESS)
        {
            goto quit;
        }
        error = ProbeWriteBuffer(lpBuffer, dwNumberOfBytesToRead);
        if (error != ERROR_SUCCESS)
        {
            goto quit;
        }

        *lpdwNumberOfBytesRead = 0;

    } // end if (!lpThreadInfo->IsAsyncWorkerThread)


    INET_ASSERT(error == ERROR_SUCCESS);

    // just call the underlying API: return whatever it returns, and let it
    // handle setting the last error

    CFsm_ReadFile *pFsm;

    pFsm = New CFsm_ReadFile(lpBuffer,
                             dwNumberOfBytesToRead,
                             lpdwNumberOfBytesRead
                             );

    
    if (pFsm != NULL)
    {
        HTTP_REQUEST_HANDLE_OBJECT *pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)hFileMapped;
        if (isAsync && !lpThreadInfo->IsAsyncWorkerThread)
        {
            error = DoAsyncFsm(pFsm, pRequest);
        }
        else
        {
            pFsm->SetPushPop(TRUE);
            pFsm->Push();
            error = DoFsm(pFsm);
        }
    }
    else
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
    }

    success = (error == ERROR_SUCCESS) ? TRUE : FALSE;
    bEndRead = FALSE;


quit:

    _InternetDecNestingCount(nestingLevel);;

    if (bEndRead)
    {
        //
        // if handleType is not HttpRequest or File then we are making this
        // request in the context of an uninterruptable async worker thread.
        // HTTP and file requests use the normal mechanism. In the case of non-
        // HTTP and file requests, we need to treat the request as if it were
        // sync and deref the handle
        //

        ReadFile_End(!lpThreadInfo->IsAsyncWorkerThread,
                     success,
                     hFileMapped,
                     bytesRead,
                     lpBuffer,
                     dwNumberOfBytesToRead,
                     lpdwNumberOfBytesRead
                     );
    }

    if (lpThreadInfo && !lpThreadInfo->IsAsyncWorkerThread)
    {

        PERF_LOG(PE_CLIENT_REQUEST_END,
                 AR_INTERNET_READ_FILE,
                 bytesRead,
                 lpThreadInfo->ThreadId,
                 hFile
                 );

    }

done:

    // if error is not ERROR_SUCCESS then this function returning the error,
    // otherwise the error has already been set by the API we called,
    // irrespective of the value of success
    if (error != ERROR_SUCCESS)
    {
        DEBUG_ERROR(API, error);
        SetLastError(error);
        success = FALSE;
    }

    DEBUG_LEAVE_API(success);
    return success;
}


PRIVATE
VOID
ReadFile_End(
    IN BOOL bDeref,
    IN BOOL bSuccess,
    IN HINTERNET hFileMapped,
    IN DWORD dwBytesRead,
    IN LPVOID lpBuffer OPTIONAL,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead OPTIONAL
    )

/*++

Routine Description:

    Common end-of-read processing:

        - update bytes read parameter
        - dump data if logging & API data requested
        - dereference handle if not async request

Arguments:

    bDeref                  - TRUE if handle should be dereferenced (should be
                              FALSE for async request)

    bSuccess                - TRUE if Read completed successfully

    hFileMapped             - mapped file handle

    dwBytesRead             - number of bytes read

    lpBuffer                - into this buffer

    dwNumberOfBytesToRead   - originally requested bytes to read

    lpdwNumberOfBytesRead   - where bytes read is stored

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_INET,
                 None,
                 "ReadFile_End",
                 "%B, %B, %#x, %d, %#x, %d, %#x",
                 bDeref,
                 bSuccess,
                 hFileMapped,
                 dwBytesRead,
                 lpBuffer,
                 dwNumberOfBytesToRead,
                 lpdwNumberOfBytesRead
                 ));

    if (bSuccess) {

        //
        // update the amount of immediate data available only if we succeeded
        //

        ((INTERNET_HANDLE_OBJECT *)hFileMapped)->ReduceAvailableDataLength(dwBytesRead);

        if (lpdwNumberOfBytesRead != NULL) {
            *lpdwNumberOfBytesRead = dwBytesRead;

            DEBUG_PRINT(API,
                        INFO,
                        ("*lpdwNumberOfBytesRead = %d\n",
                        *lpdwNumberOfBytesRead
                        ));

            //
            // dump API data only if requested
            //

            IF_DEBUG_CONTROL(DUMP_API_DATA) {
                DEBUG_DUMP_API(API,
                               "Received data:\n",
                               lpBuffer,
                               *lpdwNumberOfBytesRead
                               );
            }

        }
        if (dwBytesRead < dwNumberOfBytesToRead) {

            DEBUG_PRINT(API,
                        INFO,
                        ("(!) bytes read (%d) < bytes requested (%d)\n",
                        dwBytesRead,
                        dwNumberOfBytesToRead
                        ));

        }
    }

    //
    // if async request, handle will be deref'd after REQUEST_COMPLETE callback
    // is delivered
    //

    if (bDeref && (hFileMapped != NULL)) {
        DereferenceObject((LPVOID)hFileMapped);
    }

    PERF_LOG(PE_CLIENT_REQUEST_END,
             AR_INTERNET_READ_FILE,
             dwBytesRead,
             0,
             (!bDeref && hFileMapped) ? ((INTERNET_HANDLE_OBJECT *)hFileMapped)->GetPseudoHandle() : NULL
             );

    DEBUG_LEAVE(0);
}




DWORD
CFsm_ReadFile::RunSM(
    IN CFsm * Fsm
    )
{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "CFsm_ReadFile::RunSM",
                 "%#x",
                 Fsm
                 ));

    DWORD error;
    CFsm_ReadFile * stateMachine = (CFsm_ReadFile *)Fsm;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = ReadFile_Fsm(stateMachine);
        break;

    default:
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_WINHTTP_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


PRIVATE
DWORD
ReadFile_Fsm(
    IN CFsm_ReadFile * Fsm
    )
{
    DEBUG_ENTER((DBG_INET,
                 Dword,
                 "ReadFile_Fsm",
                 "%#x",
                 Fsm
                 ));

    CFsm_ReadFile & fsm = *Fsm;
    DWORD error = fsm.GetError();

    if ((error == ERROR_SUCCESS) && (fsm.GetState() == FSM_STATE_INIT)) {
        error = HttpReadData(fsm.GetMappedHandle(),
                             fsm.m_lpBuffer,
                             fsm.m_dwNumberOfBytesToRead,
                             &fsm.m_dwBytesRead,
                             0
                             );
        if (error == ERROR_IO_PENDING) {
            goto quit;
        }
    }
    ReadFile_End(!fsm.GetThreadInfo()->IsAsyncWorkerThread,
                 (error == ERROR_SUCCESS) ? TRUE : FALSE,
                 fsm.GetMappedHandle(),
                 fsm.m_dwBytesRead,
                 fsm.m_lpBuffer,
                 fsm.m_dwNumberOfBytesToRead,
                 fsm.m_lpdwNumberOfBytesRead
                 );
    fsm.SetDone();

quit:

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_ReadFileEx::RunSM(
    IN CFsm * Fsm
    )
{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "CFsm_ReadFileEx::RunSM",
                 "%#x",
                 Fsm
                 ));

    DWORD error;
    CFsm_ReadFileEx * stateMachine = (CFsm_ReadFileEx *)Fsm;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = ReadFileEx_Fsm(stateMachine);
        break;

    default:
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_WINHTTP_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


PRIVATE
DWORD
ReadFileEx_Fsm(
    IN CFsm_ReadFileEx * Fsm
    )
{
    DEBUG_ENTER((DBG_INET,
                 Dword,
                 "ReadFileEx_Fsm",
                 "%#x",
                 Fsm
                 ));

    CFsm_ReadFileEx & fsm = *Fsm;
    DWORD error = fsm.GetError();

    if ((error == ERROR_SUCCESS) && (fsm.GetState() == FSM_STATE_INIT)) {
        fsm.m_dwNumberOfBytesToRead = fsm.m_lpBuffersOut->dwBufferLength;
        error = HttpReadData(fsm.GetMappedHandle(),
                             fsm.m_lpBuffersOut->lpvBuffer,
                             fsm.m_dwNumberOfBytesToRead,
                             &fsm.m_dwBytesRead,
                             (fsm.m_dwFlags & IRF_NO_WAIT)
                               ? SF_NO_WAIT
                               : 0
                             );
        if (error == ERROR_IO_PENDING) {
            goto quit;
        }
    }

    //
    // if we are asynchronously completing a no-wait read then we don't update
    // any app parameters - we simply return the indication that we completed.
    // The app will then make another no-wait read to get the data
    //

    BOOL bNoOutput;

    bNoOutput = ((fsm.m_dwFlags & IRF_NO_WAIT)
                && fsm.GetThreadInfo()->IsAsyncWorkerThread)
                    ? TRUE
                    : FALSE;

    ReadFile_End(!fsm.GetThreadInfo()->IsAsyncWorkerThread,
                 (error == ERROR_SUCCESS) ? TRUE : FALSE,
                 fsm.GetMappedHandle(),
                 bNoOutput ? 0    : fsm.m_dwBytesRead,
                 bNoOutput ? NULL : fsm.m_lpBuffersOut->lpvBuffer,
                 bNoOutput ? 0    : fsm.m_dwNumberOfBytesToRead,
                 bNoOutput ? NULL : &fsm.m_lpBuffersOut->dwBufferLength
                 );
    fsm.SetDone();

quit:

    DEBUG_LEAVE(error);

    return error;
}



INTERNETAPI
BOOL
WINAPI
WinHttpWriteData(
    IN HINTERNET hFile,
    IN LPCVOID lpBuffer,
    IN DWORD dwNumberOfBytesToWrite,
    OUT LPDWORD lpdwNumberOfBytesWritten
    )

/*++

Routine Description:

    This function write next block of data to the internet file. Currently it
    supports the following protocol data:

        HttpWriteFile

Arguments:

    hFile                       - handle that was obtained by OpenFile Call

    lpBuffer                    - pointer to the data buffer

    dwNumberOfBytesToWrite      - number of bytes in the above buffer

    lpdwNumberOfBytesWritten    -  pointer to a DWORD where the number of bytes
                                   of data actually written is returned

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "WinHttpWriteData",
                     "%#x, %#x, %d, %#x",
                     hFile,
                     lpBuffer,
                     dwNumberOfBytesToWrite,
                     lpdwNumberOfBytesWritten
                     ));

    LPINTERNET_THREAD_INFO lpThreadInfo;
    DWORD nestingLevel = 0;
    DWORD error;
    BOOL success = FALSE;
    BOOL fNeedDeref = TRUE;
    HINTERNET hFileMapped = NULL;

    if (!GlobalDataInitialized)
    {
        error = ERROR_WINHTTP_NOT_INITIALIZED;
        goto done;
    }

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL)
    {

        INET_ASSERT(FALSE);

        error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto done;
    }

    _InternetIncNestingCount();
    nestingLevel = 1;

    error = MapHandleToAddress(hFile, (LPVOID *)&hFileMapped, FALSE);
    if ((error != ERROR_SUCCESS) && (hFileMapped == NULL))
    {
        goto quit;
    }

    //
    // set the handle, and last-error info in the per-thread data block
    // before we go any further. This allows us to return a status in the async
    // case, even if the handle has been closed
    //

    _InternetSetObjectHandle(lpThreadInfo, hFile, hFileMapped);
    _InternetClearLastError(lpThreadInfo);

    //
    // if MapHandleToAddress() returned a non-NULL object address, but also an
    // error status, then the handle is being closed - quit
    //

    if (error != ERROR_SUCCESS)
    {
        goto quit;
    }

    // validate handle and its type
    BOOL isAsync;
    error = RIsHandleLocal(hFileMapped, NULL, &isAsync, TypeHttpRequestHandle);
    if (error != ERROR_SUCCESS)
    {
        INET_ASSERT(FALSE);
        goto quit;
    }

    //
    // validate parameters - write length cannot be 0
    //

    if (!lpThreadInfo->IsAsyncWorkerThread)
    {
        if (dwNumberOfBytesToWrite != 0)
        {
            error = ProbeReadBuffer((LPVOID)lpBuffer, dwNumberOfBytesToWrite);
            if (error == ERROR_SUCCESS)
            {
                error = ProbeAndSetDword(lpdwNumberOfBytesWritten, 0);
            }
        }
        else
        {
            error = ERROR_INVALID_PARAMETER;
        }         

        if (error != ERROR_SUCCESS)
        {
            goto quit;
        }
    }


    // # 62953
    // If the authentication state of the handle is Negotiate,
    // don't submit data to the server but return success.
    // ** Added test for NTLM or Negotiate - Adriaanc.
    //
    
    HTTP_REQUEST_HANDLE_OBJECT *pRequest;
    pRequest = (HTTP_REQUEST_HANDLE_OBJECT*) hFileMapped;

    if (pRequest->GetAuthState() == AUTHSTATE_NEGOTIATE)
    {
        *lpdwNumberOfBytesWritten = dwNumberOfBytesToWrite;
        error = ERROR_SUCCESS;
        success = TRUE;
        goto quit;
    }
        

    INET_ASSERT(error == ERROR_SUCCESS);

    CFsm_HttpWriteData *pFsm = New CFsm_HttpWriteData((LPVOID)lpBuffer,
                                                      dwNumberOfBytesToWrite,
                                                      lpdwNumberOfBytesWritten,
                                                      0,
                                                      pRequest
                                                      );

    if (pFsm != NULL)
    {
        HTTP_REQUEST_HANDLE_OBJECT *pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)hFileMapped;
        if (isAsync && !lpThreadInfo->IsAsyncWorkerThread)
        {
            error = DoAsyncFsm(pFsm, pRequest);
        }
        else
        {
            pFsm->SetPushPop(TRUE);
            pFsm->Push();
            error = DoFsm(pFsm);
        }
    }
    else
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Don't Derefrence if we're going pending cause the FSM will do
    //  it for us.
    //

    if ( error == ERROR_IO_PENDING )
    {
        fNeedDeref = FALSE;
    }
    success = (error == ERROR_SUCCESS) ? TRUE : FALSE;

quit:

    if (hFileMapped != NULL && fNeedDeref)
    {
        DereferenceObject((LPVOID)hFileMapped);
    }

    _InternetDecNestingCount(nestingLevel);;

done:

    if (error != ERROR_SUCCESS)
    {
        DEBUG_ERROR(API, error);
        SetLastError(error);
    }

    DEBUG_LEAVE_API(success);

    return success;
}



INTERNETAPI
BOOL
WINAPI
WinHttpQueryDataAvailable(
    IN HINTERNET hFile,
    OUT LPDWORD lpdwNumberOfBytesAvailable
    )

/*++

Routine Description:

    Determines the amount of data currently available to be read on the handle

Arguments:

    hFile                       - handle of internet object

    lpdwNumberOfBytesAvailable  - pointer to returned bytes available

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "WinHttpQueryDataAvailable",
                     "%#x, %#x, %#x",
                     hFile,
                     lpdwNumberOfBytesAvailable
                     ));

    BOOL success;
    DWORD error;
    LPINTERNET_THREAD_INFO lpThreadInfo = NULL;
    HINTERNET hFileMapped = NULL;
    BOOL bDeref = TRUE;

    if (!GlobalDataInitialized)
    {
        error = ERROR_WINHTTP_NOT_INITIALIZED;
        bDeref = FALSE;
        goto quit;
    }

    //
    // get the per-thread info block
    //

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL)
    {

        INET_ASSERT(FALSE);

        error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto quit;
    }

    //INET_ASSERT(lpThreadInfo->Fsm == NULL);

    PERF_LOG(PE_CLIENT_REQUEST_START,
             AR_INTERNET_QUERY_DATA_AVAILABLE,
             lpThreadInfo->ThreadId,
             hFile
             );

    //
    // validate parameters
    //

    error = MapHandleToAddress(hFile, &hFileMapped, FALSE);
    if ((error != ERROR_SUCCESS) && (hFileMapped == NULL))
    {
        goto quit;
    }

    INET_ASSERT(hFileMapped);

    //
    // set the handle values in the per-thread info block (this API
    // can't return extended error info, so we don't care about it)
    //

    _InternetSetObjectHandle(lpThreadInfo, hFile, hFileMapped);

    //
    // if the handle is invalid, quit now
    //

    if (error != ERROR_SUCCESS)
    {
        goto quit;
    }

    //
    // validate rest of parameters
    //

    error = ProbeAndSetDword(lpdwNumberOfBytesAvailable, 0);
    if (error != ERROR_SUCCESS)
    {
        goto quit;
    }

    BOOL isAsync;
    error = RIsHandleLocal(hFileMapped, NULL, &isAsync, TypeHttpRequestHandle);
    if (error != ERROR_SUCCESS)
    {
        goto quit;
    }

    //
    // since the async worker thread doesn't come back through this API, the
    // following test is sufficient. Note that we only go async if there is
    // no data currently available on the handle
    //

    BOOL dataAvailable;
    dataAvailable = ((INTERNET_HANDLE_OBJECT *)hFileMapped)->IsDataAvailable();

    BOOL eof;
    eof = ((INTERNET_HANDLE_OBJECT *)hFileMapped)->IsEndOfFile();

    if (dataAvailable || eof)
    {

        DWORD available;

        available = ((INTERNET_HANDLE_OBJECT *)hFileMapped)->AvailableDataLength();

        DEBUG_PRINT(API,
                    INFO,
                    ("%d bytes are immediately available\n",
                    available
                    ));

        *lpdwNumberOfBytesAvailable = available;
        success = TRUE;
        goto finish;
    }

    INET_ASSERT(hFileMapped);

    //
    // sync path. wInternetQueryDataAvailable will set the last error code
    // if it fails
    //

    CFsm_QueryAvailable *pFsm;

    pFsm = New CFsm_QueryAvailable(lpdwNumberOfBytesAvailable,
                                   0,
                                   NULL
                                   );

    if (pFsm != NULL)
    {
        HTTP_REQUEST_HANDLE_OBJECT *pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)hFileMapped;
        if (isAsync && !lpThreadInfo->IsAsyncWorkerThread)
        {
            error = DoAsyncFsm(pFsm, pRequest);
        }
        else
        {
            pFsm->SetPushPop(TRUE);
            pFsm->Push();
            error = DoFsm(pFsm);
        }
    }
    else
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
    }

    if (error == ERROR_SUCCESS)
    {
        success = TRUE;
    }
    else
    {
        if (error == ERROR_IO_PENDING)
        {
            bDeref = FALSE;
        }
        goto quit;
    }

finish:

    DEBUG_PRINT_API(API,
                    INFO,
                    ("*lpdwNumberOfBytesAvailable (%#x) = %d\n",
                    lpdwNumberOfBytesAvailable,
                    *lpdwNumberOfBytesAvailable
                    ));

    if (bDeref && (hFileMapped != NULL))
    {
        DereferenceObject((LPVOID)hFileMapped);
    }

    if (lpThreadInfo)
    {

        PERF_LOG(PE_CLIENT_REQUEST_END,
                 AR_INTERNET_QUERY_DATA_AVAILABLE,
                 *lpdwNumberOfBytesAvailable,
                 lpThreadInfo->ThreadId,
                 hFile
                 );

    }

    DEBUG_LEAVE_API(success);
    return success;

quit:

    DEBUG_ERROR(API, error);

    SetLastError(error);
    success = FALSE;

    goto finish;
}


DWORD
CFsm_QueryAvailable::RunSM(
    IN CFsm * Fsm
    )
{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "CFsm_QueryAvailable::RunSM",
                 "%#x",
                 Fsm
                 ));

    DWORD error;
    CFsm_QueryAvailable * stateMachine = (CFsm_QueryAvailable *)Fsm;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = QueryAvailable_Fsm(stateMachine);
        break;

    default:
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_WINHTTP_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


PRIVATE
DWORD
QueryAvailable_Fsm(
    IN CFsm_QueryAvailable * Fsm
    )
{
    DEBUG_ENTER((DBG_INET,
                 Dword,
                 "QueryAvailable_Fsm",
                 "%#x",
                 Fsm
                 ));

    CFsm_QueryAvailable & fsm = *Fsm;
    DWORD error = fsm.GetError();

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    HTTP_REQUEST_HANDLE_OBJECT * pRequest;

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)fsm.GetMappedHandle();

    if (fsm.GetState() == FSM_STATE_INIT) {
        error = pRequest->QueryDataAvailable(fsm.m_lpdwNumberOfBytesAvailable);
    }
    if (error == ERROR_SUCCESS) {
        pRequest->SetAvailableDataLength(*fsm.m_lpdwNumberOfBytesAvailable);

        DEBUG_PRINT(INET,
                    INFO,
                    ("%d bytes available\n",
                    *fsm.m_lpdwNumberOfBytesAvailable
                    ));

        fsm.SetApiData(*fsm.m_lpdwNumberOfBytesAvailable);
    }

quit:

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();
    }

    DEBUG_LEAVE(error);

    return error;
}



INTERNETAPI
BOOL
WINAPI
InternetGetLastResponseInfoA(
    OUT LPDWORD lpdwErrorCategory,
    IN LPSTR lpszBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    This function returns the per-thread last internet error description text
    or server response.

    If this function is successful, *lpdwBufferLength contains the string length
    of lpszBuffer.

    If this function returns a failure indication, *lpdwBufferLength contains
    the number of BYTEs required to hold the response text

Arguments:

    lpdwErrorCategory   - pointer to DWORD location where the error catagory is
                          returned

    lpszBuffer          - pointer to buffer where the error text is returned

    lpdwBufferLength    - IN: length of lpszBuffer
                          OUT: number of characters in lpszBuffer if successful
                          else size of buffer required to hold response text

Return Value:

    BOOL
        Success - TRUE
                    lpszBuffer contains the error text. The caller must check
                    *lpdwBufferLength: if 0 then there was no text to return

        Failure - FALSE
                    Call GetLastError() for more information

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetGetLastResponseInfoA",
                     "%#x, %#x, %#x [%d]",
                     lpdwErrorCategory,
                     lpszBuffer,
                     lpdwBufferLength,
                     lpdwBufferLength ? *lpdwBufferLength : 0
                     ));

    DWORD error;
    BOOL success;
    DWORD textLength;
    LPINTERNET_THREAD_INFO lpThreadInfo;

    //
    // validate parameters
    //

    if (IsBadWritePtr(lpdwErrorCategory, sizeof(*lpdwErrorCategory))
    || IsBadWritePtr(lpdwBufferLength, sizeof(*lpdwBufferLength))
    || (ARGUMENT_PRESENT(lpszBuffer)
        ? IsBadWritePtr(lpszBuffer, *lpdwBufferLength)
        : FALSE)) {
        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }

    //
    // if the buffer pointer is NULL then its the same as a zero-length buffer
    //

    if (!ARGUMENT_PRESENT(lpszBuffer)) {
        *lpdwBufferLength = 0;
    } else if (*lpdwBufferLength != 0) {
        *lpszBuffer = '\0';
    }

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {

        DEBUG_PRINT(INET,
                    ERROR,
                    ("failed to get INTERNET_THREAD_INFO\n"
                    ));

        INET_ASSERT(FALSE);

        error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto quit;
    }

    //
    // there may not be any error text for this thread - either no server
    // error/response has been received, or the error text has been cleared by
    // an intervening API
    //

    if (lpThreadInfo->hErrorText != NULL) {

        //
        // copy as much as we can fit in the user supplied buffer
        //

        textLength = lpThreadInfo->ErrorTextLength;
        if (*lpdwBufferLength) {

            LPBYTE errorText;

            errorText = (LPBYTE)LOCK_MEMORY(lpThreadInfo->hErrorText);
            if (errorText != NULL) {
                textLength = min(textLength, *lpdwBufferLength) - 1;
                memcpy(lpszBuffer, errorText, textLength);

                //
                // the error text should always be zero terminated, so the
                // calling app can treat it as a string
                //

                lpszBuffer[textLength] = '\0';

                UNLOCK_MEMORY(lpThreadInfo->hErrorText);

                if (textLength == lpThreadInfo->ErrorTextLength - 1) {
                    error = ERROR_SUCCESS;
                } else {

                    //
                    // returned length is amount of buffer required
                    //

                    textLength = lpThreadInfo->ErrorTextLength;
                    error = ERROR_INSUFFICIENT_BUFFER;
                }
            } else {

                DEBUG_PRINT(INET,
                            ERROR,
                            ("failed to lock hErrorText (%#x): %d\n",
                            lpThreadInfo->hErrorText,
                            GetLastError()
                            ));

                error = ERROR_WINHTTP_INTERNAL_ERROR;
            }
        } else {

            //
            // user's buffer is not large enough to hold the info. We'll
            // let them know the required length
            //

            error = ERROR_INSUFFICIENT_BUFFER;
        }
    } else {

        INET_ASSERT(lpThreadInfo->ErrorTextLength == 0);

        textLength = 0;
        error = ERROR_SUCCESS;
    }

    *lpdwErrorCategory = lpThreadInfo->ErrorNumber;
    *lpdwBufferLength = textLength;

    IF_DEBUG(ANY) {
        if ((error == ERROR_SUCCESS)
        || ((textLength != 0) && (lpszBuffer != NULL))) {

            DEBUG_DUMP_API(API,
                           "Last Response Info:\n",
                           lpszBuffer,
                           textLength
                           );

        }
    }

quit:
    success = (error == ERROR_SUCCESS);
    if (!success) {
        DEBUG_ERROR(API, error);
        SetLastError(error);
    }

    DEBUG_LEAVE_API(success);

    return success;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\api\parseurl.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    parseurl.cxx

Abstract:

    Contains functions to parse the basic URLs - FTP, Gopher, HTTP.

    An URL parser simply acts as a macro: it must break out the protocol-specific
    information from the URL and initiate opening the identified resource: all
    this can be accomplished by calling the relevant Internet protocol APIs.

    Code in this module is based on RFC1738

    Contents:
        IsValidUrl
        DoesSchemeRequireSlashes
        ParseUrl
        CrackUrl
        EncodeUrlPath
        (HexCharToNumber)
        (NumberToHexChar)
        DecodeUrl
        DecodeUrlInSitu
        DecodeUrlStringInSitu
        GetUrlAddressInfo
        GetUrlAddress
        MapUrlSchemeName
        MapUrlScheme
        MapUrlSchemeToName

Author:

    Richard L Firth (rfirth) 26-Apr-1995

Environment:

    Win32(s) user-mode DLL

Revision History:

    26-Apr-1995
        Created

--*/

#include <wininetp.h>

//
// private manifests
//

#define RESERVED    SAFE

//
// private macros
//

//#define HEX_CHAR_TO_NUMBER(ch) \
//    ((ch <= '9') \
//        ? (ch - '0') \
//        : ((ch >= 'a') \
//            ? ((ch - 'a') + 10) \
//            : ((ch - 'A') + 10)))

#define NUMBER_TO_HEX_CHAR(n) \
    (((n) <= 9) ? ((char)(n) + '0') : (((char)(n) - 10) + 'A'))

#define IS_UNSAFE_URL_CHARACTER(Char, Scheme) \
    (((UCHAR)(Char) <= 0x20) || ((UCHAR)(Char) >= 0x7f) \
    || (SafetyList[(Char) - 0x21] & (UNSAFE | Scheme)))

#define IS_UNSAFE_URL_WIDECHARACTER(wChar, Scheme) \
    (((WCHAR)(wChar) <= 0x0020) || ((WCHAR)(wChar) >= 0x007f) \
    || (SafetyList[(wChar) - 0x0021] & (UNSAFE | Scheme)))

//
// private types
//

//
// private prototypes
//

PRIVATE
char
HexCharToNumber(
    IN char ch
    );

PRIVATE
char
NumberToHexChar(
    IN int Number
    );


//
// private data
//

//
// SafetyList - the list of characters above 0x20 and below 0x7f that are
// classified as safe, unsafe or scheme-specific. Safe characters do not need
// to be escaped for any URL scheme. Unsafe characters must be escaped for all
// URL schemes. Scheme-specific characters need only be escaped for the relevant
// scheme(s)
//

const
PRIVATE
UCHAR
SafetyList[] = {

    //
    // UNSAFE: 0x00..0x20
    //

    SAFE | HOSTNAME,                        // 0x21 (!)
    UNSAFE,                                 // 0x22 (")
    UNSAFE,                                 // 0x23 (#)
    SAFE | HOSTNAME,                        // 0x24 ($)
    UNSAFE,                                 // 0x25 (%)
    RESERVED | HOSTNAME,                    // 0x26 (&)
    SAFE | HOSTNAME,                        // 0x27 (')
    SAFE | HOSTNAME,                        // 0x28 (()
    SAFE | HOSTNAME,                        // 0x29 ())
    SAFE | HOSTNAME,                        // 0x2A (*)
    SCHEME_GOPHER | HOSTNAME,               // 0x2B (+)
    SAFE | HOSTNAME,                        // 0x2C (,)
    SAFE,                                   // 0x2D (-)
    SAFE,                                   // 0x2E (.)
    RESERVED | HOSTNAME,                    // 0x2F (/)
    SAFE,                                   // 0x30 (0)
    SAFE,                                   // 0x31 (1)
    SAFE,                                   // 0x32 (2)
    SAFE,                                   // 0x33 (3)
    SAFE,                                   // 0x34 (4)
    SAFE,                                   // 0x35 (5)
    SAFE,                                   // 0x36 (6)
    SAFE,                                   // 0x37 (7)
    SAFE,                                   // 0x38 (8)
    SAFE,                                   // 0x39 (9)
    RESERVED | HOSTNAME,                    // 0x3A (:)
    RESERVED | HOSTNAME,                    // 0x3B (;)
    UNSAFE,                                 // 0x3C (<)
    RESERVED | HOSTNAME,                    // 0x3D (=)
    UNSAFE,                                 // 0x3E (>)
    RESERVED | SCHEME_GOPHER | HOSTNAME,    // 0x3F (?)
    RESERVED | HOSTNAME,                    // 0x40 (@)
    SAFE,                                   // 0x41 (A)
    SAFE,                                   // 0x42 (B)
    SAFE,                                   // 0x43 (C)
    SAFE,                                   // 0x44 (D)
    SAFE,                                   // 0x45 (E)
    SAFE,                                   // 0x46 (F)
    SAFE,                                   // 0x47 (G)
    SAFE,                                   // 0x48 (H)
    SAFE,                                   // 0x49 (I)
    SAFE,                                   // 0x4A (J)
    SAFE,                                   // 0x4B (K)
    SAFE,                                   // 0x4C (L)
    SAFE,                                   // 0x4D (M)
    SAFE,                                   // 0x4E (N)
    SAFE,                                   // 0x4F (O)
    SAFE,                                   // 0x50 (P)
    SAFE,                                   // 0x51 (Q)
    SAFE,                                   // 0x42 (R)
    SAFE,                                   // 0x43 (S)
    SAFE,                                   // 0x44 (T)
    SAFE,                                   // 0x45 (U)
    SAFE,                                   // 0x46 (V)
    SAFE,                                   // 0x47 (W)
    SAFE,                                   // 0x48 (X)
    SAFE,                                   // 0x49 (Y)
    SAFE,                                   // 0x5A (Z)
    UNSAFE,                                 // 0x5B ([)
    UNSAFE,                                 // 0x5C (\)
    UNSAFE,                                 // 0x5D (])
    UNSAFE,                                 // 0x5E (^)
    SAFE,                                   // 0x5F (_)
    UNSAFE,                                 // 0x60 (`)
    SAFE,                                   // 0x61 (a)
    SAFE,                                   // 0x62 (b)
    SAFE,                                   // 0x63 (c)
    SAFE,                                   // 0x64 (d)
    SAFE,                                   // 0x65 (e)
    SAFE,                                   // 0x66 (f)
    SAFE,                                   // 0x67 (g)
    SAFE,                                   // 0x68 (h)
    SAFE,                                   // 0x69 (i)
    SAFE,                                   // 0x6A (j)
    SAFE,                                   // 0x6B (k)
    SAFE,                                   // 0x6C (l)
    SAFE,                                   // 0x6D (m)
    SAFE,                                   // 0x6E (n)
    SAFE,                                   // 0x6F (o)
    SAFE,                                   // 0x70 (p)
    SAFE,                                   // 0x71 (q)
    SAFE,                                   // 0x72 (r)
    SAFE,                                   // 0x73 (s)
    SAFE,                                   // 0x74 (t)
    SAFE,                                   // 0x75 (u)
    SAFE,                                   // 0x76 (v)
    SAFE,                                   // 0x77 (w)
    SAFE,                                   // 0x78 (x)
    SAFE,                                   // 0x79 (y)
    SAFE,                                   // 0x7A (z)
    UNSAFE,                                 // 0x7B ({)
    UNSAFE,                                 // 0x7C (|)
    UNSAFE,                                 // 0x7D (})
    UNSAFE                                  // 0x7E (~)

    //
    // UNSAFE: 0x7F..0xFF
    //

};

//
// UrlSchemeList - the list of schemes that we support
//

typedef struct {
    LPSTR SchemeName;
    DWORD SchemeLength;
    INTERNET_SCHEME SchemeType;
    DWORD SchemeFlags;
    BOOL NeedSlashes;
    DWORD OpenFlags;
} URL_SCHEME_INFO;


const
PRIVATE
URL_SCHEME_INFO
UrlSchemeList[] = {
    NULL,           0,  INTERNET_SCHEME_DEFAULT,    0,              FALSE,  0,
    "http",         4,  INTERNET_SCHEME_HTTP,       SCHEME_HTTP,    TRUE,   0,
    "https",        5,  INTERNET_SCHEME_HTTPS,      SCHEME_HTTP,    TRUE,   WINHTTP_FLAG_SECURE,
};

#define NUMBER_OF_URL_SCHEMES   ARRAY_ELEMENTS(UrlSchemeList)

BOOL ScanSchemes(LPTSTR pszToCheck, DWORD ccStr, PDWORD pwResult)
{
    for (DWORD i=0; i<NUMBER_OF_URL_SCHEMES; i++)
    {
        if ((UrlSchemeList[i].SchemeLength == ccStr)
            && (strnicmp(UrlSchemeList[i].SchemeName, pszToCheck, ccStr)==0))
        {
            *pwResult = i;
            return TRUE;
        }
    }
    return FALSE;
}

//
// functions
//


BOOL
IsValidUrl(
    IN LPCSTR lpszUrl
    )

/*++

Routine Description:

    Determines whether an URL has a valid format

Arguments:

    lpszUrl - pointer to URL to check.

    Assumes:    1. lpszUrl is non-NULL, non-empty string

Return Value:

    BOOL

--*/

{
    INET_ASSERT(lpszUrl != NULL);
    INET_ASSERT(*lpszUrl != '\0');

    while (*lpszUrl != '\0') {
        if (IS_UNSAFE_URL_CHARACTER(*lpszUrl, SCHEME_ANY)) {
            return FALSE;
        }
        ++lpszUrl;
    }
    return TRUE;
}


BOOL
DoesSchemeRequireSlashes(
    IN LPSTR lpszScheme,
    IN DWORD dwSchemeLength,
    IN BOOL bHasHostName
    )

/*++

Routine Description:

    Determines whether a protocol scheme requires slashes

Arguments:

    lpszScheme      - pointer to protocol scheme in question
                      (does not include ':' or slashes, just scheme name)

    dwUrlLength     - if not 0, string length of lpszScheme

Return Value:

    BOOL

--*/

{
    DWORD i;

    //
    // if dwSchemeLength is 0 then lpszUrl is ASCIIZ. Find its length
    //

    if (dwSchemeLength == 0) {
        dwSchemeLength = strlen(lpszScheme);
    }

    if (ScanSchemes(lpszScheme, dwSchemeLength, &i))
    {
        return UrlSchemeList[i].NeedSlashes;
    }
    return bHasHostName;
}


DWORD
CrackUrl(
    IN OUT LPSTR lpszUrl,
    IN DWORD dwUrlLength,
    IN BOOL bEscape,
    OUT LPINTERNET_SCHEME lpSchemeType OPTIONAL,
    OUT LPSTR* lpszSchemeName OPTIONAL,
    OUT LPDWORD lpdwSchemeNameLength OPTIONAL,
    OUT LPSTR* lpszHostName OPTIONAL,
    OUT LPDWORD lpdwHostNameLength OPTIONAL,
    OUT LPINTERNET_PORT lpServerPort OPTIONAL,
    OUT LPSTR* lpszUserName OPTIONAL,
    OUT LPDWORD lpdwUserNameLength OPTIONAL,
    OUT LPSTR* lpszPassword OPTIONAL,
    OUT LPDWORD lpdwPasswordLength OPTIONAL,
    OUT LPSTR* lpszUrlPath OPTIONAL,
    OUT LPDWORD lpdwUrlPathLength OPTIONAL,
    OUT LPSTR* lpszExtraInfo OPTIONAL,
    OUT LPDWORD lpdwExtraInfoLength OPTIONAL,
    OUT LPBOOL pHavePort
    )

/*++

Routine Description:

    Cracks an URL into its constituent parts

    Assumes: 1. If one of the optional lpsz fields is present (e.g. lpszUserName)
                then the accompanying lpdw field must also be supplied

Arguments:

    lpszUrl                 - pointer to URL to crack. This buffer WILL BE
                              OVERWRITTEN if it contains escape sequences that
                              we will convert back to ANSI characters

    dwUrlLength             - if not 0, string length of lpszUrl

    bEscape                 - TRUE if we are to escape the url-path

    lpSchemeType            - returned scheme type - e.g. INTERNET_SCHEME_HTTP

    lpszSchemeName          - returned scheme name

    lpdwSchemeNameLength    - length of scheme name

    lpszHostName            - returned host name

    lpdwHostNameLength      - length of host name buffer

    lpServerPort            - returned server port if present in the URL, else 0

    lpszUserName            - returned user name if present

    lpdwUserNameLength      - length of user name buffer

    lpszPassword            - returned password if present

    lpdwPasswordLength      - length of password buffer

    lpszUrlPath             - returned, canonicalized URL path

    lpdwUrlPathLength       - length of url-path buffer

    lpszExtraInfo           - returned search string or intra-page link if present

    lpdwExtraInfoLength     - length of extra info buffer

    pHavePort               - returned boolean indicating whether port was specified

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_WINHTTP_UNRECOGNIZED_SCHEME

--*/

{
    DWORD error;
    DWORD schemeLength;
    INTERNET_SCHEME schemeType;

    //
    // if dwUrlLength is 0 then lpszUrl is ASCIIZ. Find its length
    //

    if (dwUrlLength == 0) {
        dwUrlLength = strlen(lpszUrl);
    }

    //
    // get parser based on the protocol name
    //

    for (schemeLength = 0; lpszUrl[schemeLength] != ':'; ++schemeLength) {
        if ((dwUrlLength == 0) || (lpszUrl[schemeLength] == '\0')) {

            //
            // no ':' in URL? Bogus (dude)
            //

            error = ERROR_WINHTTP_UNRECOGNIZED_SCHEME;
            goto quit;
        }
        --dwUrlLength;
    }

    DWORD i;
    int skip;
    BOOL isGeneric;
    BOOL needSlashes;
    BOOL haveSlashes;

    isGeneric = FALSE;
    needSlashes = FALSE;
    haveSlashes = FALSE;

    schemeType = INTERNET_SCHEME_UNKNOWN;

    if (ScanSchemes(lpszUrl, schemeLength, &i))
    {
        schemeType = UrlSchemeList[i].SchemeType;
        needSlashes = UrlSchemeList[i].NeedSlashes;
    }
    else
    {
        error = ERROR_WINHTTP_UNRECOGNIZED_SCHEME;
        goto quit;
    }

    skip = 1;       // skip ':'

    if ((dwUrlLength > 3) && (memcmp(&lpszUrl[schemeLength], "://", 3) == 0)) {
        skip = 3;   // skip "://"
        haveSlashes = TRUE;
    }

    //
    // If we don't have slashes, make sure we don't need them.
    // If we have slashes, make sure they are required.
    //

    if ((!haveSlashes && !needSlashes) || (haveSlashes && needSlashes)) {
        if (ARGUMENT_PRESENT(lpSchemeType)) {
            *lpSchemeType = schemeType;
        }
        if (ARGUMENT_PRESENT(lpszSchemeName)) {
            *lpszSchemeName = lpszUrl;
            *lpdwSchemeNameLength = schemeLength;
        }
        lpszUrl += schemeLength + skip;
        dwUrlLength -= skip;

        if (isGeneric) {
            if (ARGUMENT_PRESENT(lpszUserName)) {
                *lpszUserName = NULL;
                *lpdwUserNameLength = 0;
            }
            if (ARGUMENT_PRESENT(lpszPassword)) {
                *lpszPassword = NULL;
                *lpdwPasswordLength = 0;
            }
            if (ARGUMENT_PRESENT(lpszHostName)) {
                *lpszHostName = NULL;
                *lpdwHostNameLength = 0;
            }
            if (ARGUMENT_PRESENT(lpServerPort)) {
                *lpServerPort = 0;
            }
            error = ERROR_SUCCESS;
        } else {
            error = GetUrlAddress(&lpszUrl,
                                  &dwUrlLength,
                                  lpszUserName,
                                  lpdwUserNameLength,
                                  lpszPassword,
                                  lpdwPasswordLength,
                                  lpszHostName,
                                  lpdwHostNameLength,
                                  lpServerPort,
                                  pHavePort
                                  );
        }
        if (bEscape && (error == ERROR_SUCCESS)) {
            error = DecodeUrlInSitu(lpszUrl, &dwUrlLength);
        }
        if ((error == ERROR_SUCCESS) && ARGUMENT_PRESENT(lpszExtraInfo)) {
            *lpdwExtraInfoLength = 0;
            for (i = 0; i < (int)dwUrlLength; i++) {
                if (lpszUrl[i] == '?' || lpszUrl[i] == '#') {
                    *lpszExtraInfo = &lpszUrl[i];
                    *lpdwExtraInfoLength = dwUrlLength - i;
                    dwUrlLength -= *lpdwExtraInfoLength;
                }
            }
        }
        if ((error == ERROR_SUCCESS) && ARGUMENT_PRESENT(lpszUrlPath)) {
            *lpszUrlPath = lpszUrl;
            *lpdwUrlPathLength = dwUrlLength;
        }
    } else {
        error = ERROR_WINHTTP_UNRECOGNIZED_SCHEME;
    }

quit:

    return error;
}

#define DEFAULT_REALLOC_SIZE 1024

DWORD
EncodeUrlPath(
    IN DWORD Flags,
    IN DWORD SchemeFlags,
    IN LPSTR UrlPath,
    IN DWORD UrlPathLength,
    OUT LPSTR* pEncodedUrlPath,
    IN OUT LPDWORD EncodedUrlPathLength
    )

/*++

Routine Description:

    Encodes an URL-path. That is, escapes the string. Creates a new URL-path in
    which all the 'unsafe' and reserved characters for this scheme have been
    converted to escape sequences

Arguments:

    Flags                   - controlling expansion

    SchemeFlags             - which scheme we are encoding for -
                              SCHEME_HTTP, etc.

    UrlPath                 - pointer to the unescaped string

    UrlPathLength           - length of Url

    EncodedUrlPath          - pointer to buffer where encoded URL will be
                              written

    EncodedUrlPathLength    - IN: size of EncodedUrlPath
                              OUT: number of bytes written to EncodedUrlPath

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INSUFFICIENT_BUFFER
                    UrlPathLength not large enough to store encoded URL path

--*/

{
    DWORD error;
    DWORD len;

    len = *EncodedUrlPathLength;
    LPSTR EncodedUrlPath = *pEncodedUrlPath;
    UCHAR ch;

    while(ch = (UCHAR)*UrlPath++)
    {
        //
        // check whether this character is safe. For now, we encode all unsafe
        // and scheme-specific characters the same way (i.e. irrespective of
        // scheme)
        //
        // We are allowing '/' to be copied unmodified
        //

        if (len < 3) 
        {
            LPSTR pStr = (LPSTR)REALLOCATE_MEMORY(*pEncodedUrlPath, *EncodedUrlPathLength+DEFAULT_REALLOC_SIZE, LMEM_MOVEABLE);

            if (pStr)
            {
                EncodedUrlPath = pStr+*EncodedUrlPathLength-len;
                *pEncodedUrlPath = pStr;
                len += DEFAULT_REALLOC_SIZE;
                *EncodedUrlPathLength += DEFAULT_REALLOC_SIZE;
            }
            else
            {                
                goto error;
            }
        }
        
        if (IS_UNSAFE_URL_CHARACTER(ch, SchemeFlags)
        && !((ch == '/') && (Flags & NO_ENCODE_PATH_SEP))) 
        {
            *EncodedUrlPath++ = '%';
            //*EncodedUrlPath++ = NumberToHexChar((int)ch / 16);
            *EncodedUrlPath++ = NUMBER_TO_HEX_CHAR((int)ch / 16);
            //*EncodedUrlPath++ = NumberToHexChar((int)ch % 16);
            *EncodedUrlPath++ = NUMBER_TO_HEX_CHAR((int)ch % 16);
            len -= 2; // extra --len below
        } 
        else 
        {
            *EncodedUrlPath++ = (signed char)ch;
        }
        --len;
    }
    
    *EncodedUrlPath = '\0';
    *EncodedUrlPathLength -= len;
    error = ERROR_SUCCESS;

quit:
    return error;

error:
    error = ERROR_INSUFFICIENT_BUFFER;
    goto quit;
}


PRIVATE
char
HexCharToNumber(
    IN char ch
    )

/*++

Routine Description:

    Converts an ANSI character in the range '0'..'9' 'A'..'F' 'a'..'f' to its
    corresponding hexadecimal value (0..f)

Arguments:

    ch  - character to convert

Return Value:

    char
        hexadecimal value of ch, as an 8-bit (signed) character value

--*/

{
    return (ch <= '9') ? (ch - '0')
                       : ((ch >= 'a') ? ((ch - 'a') + 10) : ((ch - 'A') + 10));
}


PRIVATE
char
NumberToHexChar(
    IN int Number
    )

/*++

Routine Description:

    Converts a number in the range 0..15 to its ASCII character hex representation
    ('0'..'F')

Arguments:

    Number  - to convert

Return Value:

    char
        character in above range

--*/

{
    return (Number <= 9) ? (char)('0' + Number) : (char)('A' + (Number - 10));
}


DWORD
DecodeUrl(
    IN LPSTR Url,
    IN DWORD UrlLength,
    OUT LPSTR DecodedString,
    IN OUT LPDWORD DecodedLength
    )

/*++

Routine Description:

    Converts an URL string with embedded escape sequences (%xx) to a counted
    string

    It is safe to pass the same pointer for the string to convert, and the
    buffer for the converted results: if the current character is not escaped,
    it just gets overwritten, else the input pointer is moved ahead 2 characters
    further than the output pointer, which is benign

Arguments:

    Url             - pointer to URL string to convert

    UrlLength       - number of characters in UrlString

    DecodedString   - pointer to buffer that receives converted string

    DecodedLength   - IN: number of characters in buffer
                      OUT: number of characters converted

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_WINHTTP_INVALID_URL
                    UrlString couldn't be converted

                  ERROR_INSUFFICIENT_BUFFER
                    ConvertedString isn't large enough to hold all the converted
                    UrlString

--*/

{
    DWORD bufferRemaining;

    bufferRemaining = *DecodedLength;
    while (UrlLength && bufferRemaining) {

        char ch;

        if (*Url == '%') {

            //
            // BUGBUG - would %00 ever appear in an URL?
            //

            ++Url;
            if (isxdigit(*Url)) {
                ch = HexCharToNumber(*Url++) << 4;
                if (isxdigit(*Url)) {
                    ch |= HexCharToNumber(*Url++);
                } else {
                    return ERROR_WINHTTP_INVALID_URL;
                }
            } else {
                return ERROR_WINHTTP_INVALID_URL;
            }
            UrlLength -= 3;
        } else {
            ch = *Url++;
            --UrlLength;
        }
        *DecodedString++ = ch;
        --bufferRemaining;
    }
    if (UrlLength == 0) {
        *DecodedLength -= bufferRemaining;
        return ERROR_SUCCESS;
    } else {
        return ERROR_INSUFFICIENT_BUFFER;
    }
}


DWORD
DecodeUrlInSitu(
    IN LPSTR BufferAddress,
    IN OUT LPDWORD BufferLength
    )

/*++

Routine Description:

    Decodes an URL string, if it contains escape sequences. The conversion is
    done in place, since we know that a string containing escapes is longer than
    the string with escape sequences (3 bytes) converted to characters (1 byte)

Arguments:

    BufferAddress   - pointer to the string to convert

    BufferLength    - IN: number of characters to convert
                      OUT: length of converted string

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_WINHTTP_INVALID_URL
                  ERROR_INSUFFICIENT_BUFFER

--*/

{
    DWORD stringLength;

    stringLength = *BufferLength;
    if (memchr(BufferAddress, '%', stringLength)) {
        return DecodeUrl(BufferAddress,
                         stringLength,
                         BufferAddress,
                         BufferLength
                         );
    } else {

        //
        // no escape character in the string, just return success
        //

        return ERROR_SUCCESS;
    }
}


DWORD
DecodeUrlStringInSitu(
    IN LPSTR BufferAddress,
    IN OUT LPDWORD BufferLength
    )

/*++

Routine Description:

    Performs DecodeUrlInSitu() on a string and zero terminates it

    Assumes: 1. Even if no decoding is performed, *BufferLength is large enough
                to fit an extra '\0' character

Arguments:

    BufferAddress   - pointer to the string to convert

    BufferLength    - IN: number of characters to convert
                      OUT: length of converted string, excluding '\0'

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_WINHTTP_INVALID_URL
                  ERROR_INSUFFICIENT_BUFFER

--*/

{
    DWORD error;

    error = DecodeUrlInSitu(BufferAddress, BufferLength);
    if (error == ERROR_SUCCESS) {
        BufferAddress[*BufferLength] = '\0';
    }
    return error;
}


DWORD
GetUrlAddressInfo(
    IN OUT LPSTR* Url,
    IN OUT LPDWORD UrlLength,
    OUT LPSTR* PartOne,
    OUT LPDWORD PartOneLength,
    OUT LPBOOL PartOneEscape,
    OUT LPSTR* PartTwo,
    OUT LPDWORD PartTwoLength,
    OUT LPBOOL PartTwoEscape
    )

/*++

Routine Description:

    Given a string of the form foo:bar, splits them into 2 counted strings about
    the ':' character. The address string may or may not contain a ':'.

    This function is intended to split into substrings the host:port and
    username:password strings commonly used in Internet address specifications
    and by association, in URLs

Arguments:

    Url             - pointer to pointer to string containing URL. On output
                      this is advanced past the address parts

    UrlLength       - pointer to length of URL in UrlString. On output this is
                      reduced by the number of characters parsed

    PartOne         - pointer which will receive first part of address string

    PartOneLength   - pointer which will receive length of first part of address
                      string

    PartOneEscape   - TRUE on output if PartOne contains escape sequences

    PartTwo         - pointer which will receive second part of address string

    PartTwoLength   - pointer which will receive length of second part of address
                      string

    PartOneEscape   - TRUE on output if PartTwo contains escape sequences

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_WINHTTP_INVALID_URL

--*/

{
    LPSTR pString;
    LPSTR pColon;
    DWORD partLength;
    LPBOOL partEscape;
    DWORD length;

    //
    // parse out <host>[:<port>] or <name>[:<password>] (i.e. <part1>[:<part2>]
    //

    pString = *Url;
    pColon = NULL;
    partLength = 0;
    *PartOne = pString;
    *PartOneLength = 0;
    *PartOneEscape = FALSE;
    *PartTwoEscape = FALSE;
    partEscape = PartOneEscape;
    length = *UrlLength;
    while ((*pString != '/') && (*pString != '\0') && (length != 0)) {
        if (*pString == '%') {

            //
            // if there is a % in the string then it *must* (RFC 1738) be the
            // start of an escape sequence. This function just reports the
            // address of the substrings and their lengths; calling functions
            // must handle the escape sequences (i.e. it is their responsibility
            // to decide where to put the results)
            //

            *partEscape = TRUE;
        }
        if (*pString == ':') {
            if (pColon != NULL) {

                //
                // we don't expect more than 1 ':'
                //

                return ERROR_WINHTTP_INVALID_URL;
            }
            pColon = pString;
            *PartOneLength = partLength;
            if (partLength == 0) {
                *PartOne = NULL;
            }
            partLength = 0;
            partEscape = PartTwoEscape;
        } else {
            ++partLength;
        }
        ++pString;
        --length;
    }

    //
    // we either ended on the host (or user) name or the port number (or
    // password), one of which we don't know the length of
    //

    if (pColon == NULL) {
        *PartOneLength = partLength;
        *PartTwo = NULL;
        *PartTwoLength = 0;
        *PartTwoEscape = FALSE;
    } else {
        *PartTwoLength = partLength;
        *PartTwo = pColon + 1;

        //
        // in both the <user>:<password> and <host>:<port> cases, we cannot have
        // the second part without the first, although both parts being zero
        // length is OK (host name will be sorted out elsewhere, but (for now,
        // at least) I am allowing <>:<> for username:password, since I don't
        // see it expressly disallowed in the RFC. I may be revisiting this code
        // later...)
        //
        // N.B.: ftp://ftp.microsoft.com uses http://:0/-http-gw-internal-/menu.gif

//      if ((*PartOneLength == 0) && (partLength != 0)) {
//          return ERROR_WINHTTP_INVALID_URL;
//      }
    }

    //
    // update the URL pointer and length remaining
    //

    *Url = pString;
    *UrlLength = length;

    return ERROR_SUCCESS;
}


DWORD
GetUrlAddress(
    IN OUT LPSTR* lpszUrl,
    OUT LPDWORD lpdwUrlLength,
    OUT LPSTR* lpszUserName OPTIONAL,
    OUT LPDWORD lpdwUserNameLength OPTIONAL,
    OUT LPSTR* lpszPassword OPTIONAL,
    OUT LPDWORD lpdwPasswordLength OPTIONAL,
    OUT LPSTR* lpszHostName OPTIONAL,
    OUT LPDWORD lpdwHostNameLength OPTIONAL,
    OUT LPINTERNET_PORT lpPort OPTIONAL,
    OUT LPBOOL pHavePort
    )

/*++

Routine Description:

    This function extracts any and all parts of the address information for a
    generic URL. If any of the address parts contain escaped characters (%nn)
    then they are converted in situ

    The generic addressing format (RFC 1738) is:

        <user>:<password>@<host>:<port>

    The addressing information cannot contain a password without a user name,
    or a port without a host name
    NB: ftp://ftp.microsoft.com uses URL's that have a port without a host name!
    (e.g. http://:0/-http-gw-internal-/menu.gif)

    Although only the lpszUrl and lpdwUrlLength fields are required, the address
    parts will be checked for presence and completeness

    Assumes: 1. If one of the optional lpsz fields is present (e.g. lpszUserName)
                then the accompanying lpdw field must also be supplied

Arguments:

    lpszUrl             - IN: pointer to the URL to parse
                          OUT: URL remaining after address information

                          N.B. The url-path is NOT canonicalized (unescaped)
                          because it may contain protocol-specific information
                          which must be parsed out by the protocol-specific
                          parser

    lpdwUrlLength       - returned length of the remainder of the URL after the
                          address information

    lpszUserName        - returned pointer to the user name
                          This parameter can be omitted by those protocol parsers
                          that do not require or expect user names in the URL

    lpdwUserNameLength  - returned length of the user name part
                          This parameter can be omitted by those protocol parsers
                          that do not require or expect user names in the URL

    lpszPassword        - returned pointer to the password
                          This parameter can be omitted by those protocol parsers
                          that do not require or expect user passwords in the URL

    lpdwPasswordLength  - returned length of the password
                          This parameter can be omitted by those protocol parsers
                          that do not require or expect user passwords in the URL

    lpszHostName        - returned pointer to the host name
                          This parameter can be omitted by those protocol parsers
                          that do not require the host name info

    lpdwHostNameLength  - returned length of the host name
                          This parameter can be omitted by those protocol parsers
                          that do not require the host name info

    lpPort              - returned value of the port field
                          This parameter can be omitted by those protocol parsers
                          that do not require or expect user port number

    pHavePort           - returned boolean indicating whether a port was specified
                          in the URL or not.  This value is not returned if the
                          lpPort parameter is omitted.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_WINHTTP_INVALID_URL
                    We could not parse some part of the address info, or we
                    found address info where the protocol parser didn't expect
                    any

                  ERROR_INSUFFICIENT_BUFFER
                    We could not convert an escaped string

--*/

{
    LPSTR pAt;
    DWORD urlLength;
    LPSTR pUrl;
    BOOL part1Escape;
    BOOL part2Escape;
    char portNumber[INTERNET_MAX_PORT_NUMBER_LENGTH + 1];
    DWORD portNumberLength;
    LPSTR pPortNumber;
    DWORD error;
    LPSTR hostName;
    DWORD hostNameLength;

    pUrl = *lpszUrl;
    urlLength = strlen(pUrl);

    //
    // check to see if there is an '@' separating user name & password. If we
    // see a '/' or get to the end of the string before we see the '@' then
    // there is no username:password part
    //

    pAt = NULL;
    for (DWORD i = 0; i < urlLength; ++i) {
        if (pUrl[i] == '/') {
            break;
        } else if (pUrl[i] == '@') {
            pAt = &pUrl[i];
            break;
        }
    }

    if (pAt != NULL) {

        DWORD addressPartLength;
        LPSTR userName;
        DWORD userNameLength;
        LPSTR password;
        DWORD passwordLength;

        addressPartLength = (DWORD) (pAt - pUrl);
        urlLength -= addressPartLength;
        error = GetUrlAddressInfo(&pUrl,
                                  &addressPartLength,
                                  &userName,
                                  &userNameLength,
                                  &part1Escape,
                                  &password,
                                  &passwordLength,
                                  &part2Escape
                                  );
        if (error != ERROR_SUCCESS) {
            return error;
        }

        //
        // ensure there is no address information unparsed before the '@'
        //

        INET_ASSERT(addressPartLength == 0);
        INET_ASSERT(pUrl == pAt);

        if (ARGUMENT_PRESENT(lpszUserName)) {

            INET_ASSERT(ARGUMENT_PRESENT(lpdwUserNameLength));

            //
            // convert the user name in situ
            //

            if (part1Escape) {

                INET_ASSERT(userName != NULL);
                INET_ASSERT(userNameLength != 0);

                error = DecodeUrlInSitu(userName, &userNameLength);
                if (error != ERROR_SUCCESS) {
                    return error;
                }
            }
            *lpszUserName = userName;
            *lpdwUserNameLength = userNameLength;
        }

        if (ARGUMENT_PRESENT(lpszPassword)) {

            //
            // convert the password in situ
            //

            if (part2Escape) {

                INET_ASSERT(userName != NULL);
                INET_ASSERT(userNameLength != 0);
                INET_ASSERT(password != NULL);
                INET_ASSERT(passwordLength != 0);

                error = DecodeUrlInSitu(password, &passwordLength);
                if (error != ERROR_SUCCESS) {
                    return error;
                }
            }
            *lpszPassword = password;
            *lpdwPasswordLength = passwordLength;
        }

        //
        // the URL pointer now points at the host:port fields (remember that
        // ExtractAddressParts() must have bumped pUrl up to the end of the
        // password field (if present) which ends at pAt)
        //

        ++pUrl;

        //
        // similarly, bump urlLength to account for the '@'
        //

        --urlLength;
    } else {

        //
        // no '@' therefore no username or password
        //

        if (ARGUMENT_PRESENT(lpszUserName)) {

            INET_ASSERT(ARGUMENT_PRESENT(lpdwUserNameLength));

            *lpszUserName = NULL;
            *lpdwUserNameLength = 0;
        }
        if (ARGUMENT_PRESENT(lpszPassword)) {

            INET_ASSERT(ARGUMENT_PRESENT(lpdwPasswordLength));

            *lpszPassword = NULL;
            *lpdwPasswordLength = 0;
        }
    }

    //
    // now get the host name and the optional port
    //

    pPortNumber = portNumber;
    portNumberLength = sizeof(portNumber);
    error = GetUrlAddressInfo(&pUrl,
                              &urlLength,
                              &hostName,
                              &hostNameLength,
                              &part1Escape,
                              &pPortNumber,
                              &portNumberLength,
                              &part2Escape
                              );
    if (error != ERROR_SUCCESS) {
        return error;
    }

    //
    // the URL address information MUST contain the host name
    //

//  if ((hostName == NULL) || (hostNameLength == 0)) {
//      return ERROR_WINHTTP_INVALID_URL;
//  }

    if (ARGUMENT_PRESENT(lpszHostName)) {

        INET_ASSERT(ARGUMENT_PRESENT(lpdwHostNameLength));

        //
        // if the host name contains escaped characters, convert them in situ
        //

        if (part1Escape) {
            error = DecodeUrlInSitu(hostName, &hostNameLength);
            if (error != ERROR_SUCCESS) {
                return error;
            }
        }
        *lpszHostName = hostName;
        *lpdwHostNameLength = hostNameLength;
    }

    //
    // if there is a port field, convert it if there are escaped characters,
    // check it for valid numeric characters, and convert it to a number
    //

    if (ARGUMENT_PRESENT(lpPort)) {
        if (portNumberLength != 0) {

            DWORD i;
            DWORD port;

            INET_ASSERT(pPortNumber != NULL);

            if (part2Escape) {
                error = DecodeUrlInSitu(pPortNumber, &portNumberLength);
                if (error != ERROR_SUCCESS) {
                    return error;
                }
            }

            //
            // ensure all characters in the port number buffer are numeric, and
            // calculate the port number at the same time
            //

            for (i = 0, port = 0; i < portNumberLength; ++i) {
                if (!isdigit(*pPortNumber)) {
                    return ERROR_WINHTTP_INVALID_URL;
                }
                port = port * 10 + (int)(*pPortNumber++ - '0');
                // We won't allow ports larger than 65535 ((2^16)-1)
                // We have to check this every time to make sure that someone
                // doesn't try to overflow a DWORD.
                if (port > 65535)
                {
                    return ERROR_WINHTTP_INVALID_URL;
                }
            }
            *lpPort = (INTERNET_PORT)port;
            if (ARGUMENT_PRESENT(pHavePort)) {
                *pHavePort = TRUE;
            }
        } else {
            *lpPort = INTERNET_INVALID_PORT_NUMBER;
            if (ARGUMENT_PRESENT(pHavePort)) {
                *pHavePort = FALSE;
            }
        }
    }

    //
    // update the URL pointer and the length of the url-path
    //

    *lpszUrl = pUrl;
    *lpdwUrlLength = urlLength;

    return ERROR_SUCCESS;
}


INTERNET_SCHEME
MapUrlSchemeName(
    IN LPSTR lpszSchemeName,
    IN DWORD dwSchemeNameLength
    )

/*++

Routine Description:

    Maps a scheme name/length to a scheme name type

Arguments:

    lpszSchemeName      - pointer to name of scheme to map

    dwSchemeNameLength  - length of scheme (if -1, lpszSchemeName is ASCIZ)

Return Value:

    INTERNET_SCHEME

--*/

{
    if (dwSchemeNameLength == (DWORD)-1) {
        dwSchemeNameLength = (DWORD)lstrlen(lpszSchemeName);
    }

    DWORD i;
    if (ScanSchemes(lpszSchemeName, dwSchemeNameLength, &i))
    {
        return UrlSchemeList[i].SchemeType;
    }
    return INTERNET_SCHEME_UNKNOWN;
}


LPSTR
MapUrlScheme(
    IN INTERNET_SCHEME Scheme,
    OUT LPDWORD lpdwSchemeNameLength
    )

/*++

Routine Description:

    Maps the enumerated scheme name type to the name

Arguments:

    Scheme                  - enumerated scheme type to map

    lpdwSchemeNameLength    - pointer to returned length of scheme name

Return Value:

    LPSTR   - pointer to scheme name or NULL

--*/

{
    if ((Scheme >= INTERNET_SCHEME_FIRST)
    && (Scheme <= INTERNET_SCHEME_LAST)) 
    {
        *lpdwSchemeNameLength = UrlSchemeList[Scheme].SchemeLength;
        return UrlSchemeList[Scheme].SchemeName;
    }
    *lpdwSchemeNameLength = 0;
    return NULL;
}


LPSTR
MapUrlSchemeToName(
    IN INTERNET_SCHEME Scheme
    )

/*++

Routine Description:

    Maps the enumerated scheme name type to the name

Arguments:

    Scheme  - enumerated scheme type to map

Return Value:

    LPSTR   - pointer to scheme name or NULL

--*/

{
    if ((Scheme >= INTERNET_SCHEME_FIRST)
    && (Scheme <= INTERNET_SCHEME_LAST)) {
        return UrlSchemeList[Scheme].SchemeName;
    }
    return NULL;
}

/*
 * ConvertUnicodeToMultiByte:
 *
 * dwFlags: WINHTTP_FLAG_NULL_CODEPAGE-> assumes correctly encoded string packaged into UTF8, no escaping done.
            WINHTTP_FLAG_VALID_HOSTNAME-> only for server name
                only the previous flag valid for server name passed in here.
                if both of these are not specified, then

            if dwCodePage is not INVALID, it'll be used to convert unicode string to ANSI.
            else UTF8 will be used.

            if ESCAPE && ESCAPE_PERCENT is specified, the ANSI url will be escaped (incl. %) else it will be escaped w/o
            escaping %s.
 */
 
DWORD
ConvertUnicodeToMultiByte(
    LPCWSTR lpszObjectName, 
    DWORD dwCodePage, 
    MEMORYPACKET* pmp, 
    DWORD dwFlags)
{
    DWORD dwError = ERROR_SUCCESS;
    LPSTR pStr;
    WCHAR wc;
    LPCWSTR pwStr;
    BOOL bStrip0s = TRUE;       
    DWORD dwUnicodeUrlSize;

//determine size of string and/or safe characters
    if ((dwFlags & WINHTTP_FLAG_NULL_CODEPAGE) ||
        (dwFlags & WINHTTP_FLAG_VALID_HOSTNAME))
    {
        if (dwFlags & WINHTTP_FLAG_VALID_HOSTNAME)
        {
            for (pwStr = lpszObjectName; wc = *pwStr; ++pwStr)
            {
                if (IS_UNSAFE_URL_WIDECHARACTER(wc, HOSTNAME))
                {
                    dwError = ERROR_WINHTTP_INVALID_URL;
                    goto done;
                }
            }
            pmp->dwAlloc = dwUnicodeUrlSize = (DWORD)(pwStr-lpszObjectName+1);
        }
        else
        {
            pmp->dwAlloc = dwUnicodeUrlSize = lstrlenW(lpszObjectName)+1;
        }
    }
    else 
    {
        DWORD dwUnsafeChars = 0;
        
        // optimization to check for unsafe characters, and optimize the common case.
        // calculate the length, and while parsing the string, check if there are unsafeChars
        for(pwStr = lpszObjectName; wc = *pwStr; ++pwStr)
        {
            if (IS_UNSAFE_URL_WIDECHARACTER(wc, 0))
                ++dwUnsafeChars;
        }
        dwUnicodeUrlSize = (DWORD)(pwStr-lpszObjectName+1);

        if (dwUnsafeChars == 0)
        {
            pmp->dwAlloc = dwUnicodeUrlSize;            
        }
        else
        {
            bStrip0s = FALSE;
        }
    }

//convert to MBCS
    if (bStrip0s)
    {
        INET_ASSERT(pmp->dwAlloc);
        
        pmp->psStr = (LPSTR)ALLOCATE_FIXED_MEMORY(pmp->dwAlloc);

        if (!pmp->psStr)
        {
            pmp->dwAlloc = 0;
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto done;
        }
        pmp->dwSize = pmp->dwAlloc-1;
        
        for (pStr = pmp->psStr; wc = *lpszObjectName; ++lpszObjectName)
        {
            *(pStr)++ = (CHAR)wc;
        }
        *pStr = '\0';
    }
    else
    {
        // convert with WideCharToMultiByte()
        pmp->dwAlloc = WideCharToMultiByte(dwCodePage, 0, lpszObjectName, dwUnicodeUrlSize, NULL, 0, NULL, NULL);
        if (pmp->dwAlloc)
        {
            pmp->psStr = (LPSTR)ALLOCATE_FIXED_MEMORY(pmp->dwAlloc);

            if (!pmp->psStr)
            {
                pmp->dwAlloc = 0;
                dwError = ERROR_NOT_ENOUGH_MEMORY;
                goto done;
            }
            pmp->dwSize = WideCharToMultiByte(dwCodePage, 0, lpszObjectName, dwUnicodeUrlSize, pmp->psStr, pmp->dwAlloc, NULL, NULL);

            if (!pmp->dwSize)
            {
                dwError = GetLastError();
                goto done;
            }
            else
                pmp->dwSize -= 1; 
        }
        else
        {
            dwError = GetLastError();
            goto done;
        }
    }

//escaping
    if (dwFlags & WINHTTP_FLAG_DEFAULT_ESCAPE)
    {
        INET_ASSERT (! (dwFlags & WINHTTP_FLAG_VALID_HOSTNAME));
        
        static CHAR* hexArray = "0123456789ABCDEF";
        UCHAR ch;
        DWORD dwUnsafeChars = 0;
        DWORD dwNewAlloc;
        LPSTR pDest, pNewStr;
        
        for(pStr = pmp->psStr; ch = *pStr; pStr = CharNextExA((WORD)dwCodePage, pStr, 0))
        {
            if (IS_UNSAFE_URL_CHARACTER(ch, SCHEME_HTTP))
                ++dwUnsafeChars;
            else if(ch == '?')
                break;
        }

        if (dwUnsafeChars == 0)
            goto done;


        dwNewAlloc = pmp->dwAlloc + dwUnsafeChars*2;
        pNewStr = pDest = (LPSTR)ALLOCATE_FIXED_MEMORY(dwNewAlloc);

        if (!pDest)
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto done;
        }

        BOOL bEscapePercent = (dwFlags & WINHTTP_FLAG_ESCAPE_PERCENT) ? TRUE : FALSE;

        BOOL bHitQuery = FALSE;
        LPSTR pNext;
        BOOL bLead;
        for (pStr = pmp->psStr; ch = *pStr;)
        {
            pNext = CharNextExA((WORD)dwCodePage, pStr, 0);
            bLead = TRUE;
            do
            {
                ch = *pStr;
                if (IS_UNSAFE_URL_CHARACTER(ch, SCHEME_HTTP)
                    && (!bLead || (ch != '%') || bEscapePercent) )
                {
                    *pDest++ = '%';
                    *pDest++ = hexArray[ch>>4];
                    *pDest++ = hexArray[ch & 0x0f];
                }
                else
                {
                    *pDest++ = ch;
                    if ((ch == '?') && bLead)
                    {
                        bHitQuery = TRUE;

                        ++pStr;
                        INET_ASSERT(pStr == pNext);

                        break;
                    }
                }
                bLead = FALSE;
            }
            while (++pStr != pNext);

            if (bHitQuery)
                break;
        }

        if (bHitQuery)
        {
            for ( ; ch = *pStr; pStr++)
            {
                *pDest++ = ch;
            }
        }
        *pDest = '\0';

        FREE_FIXED_MEMORY(pmp->psStr);
        pmp->psStr = pNewStr;
        pmp->dwSize = (DWORD)(pDest-pNewStr);
        pmp->dwAlloc = dwNewAlloc;
    }
     
done:
    if (pmp->psStr)
        pmp->dwAlloc = (pmp->dwAlloc > MP_MAX_STACK_USE) ? pmp->dwAlloc : MP_MAX_STACK_USE+1;// to force FREE in ~MEMORYPACKET
        
    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\api\registry.cxx ===
/*++


Copyright (c) 1994  Microsoft Corporation

Module Name:

    registry.cxx

Abstract:

    Functions to read/write registry parameters

    Contents:
        OpenInternetSettingsKey
        CloseInternetSettingsKey
        InternetGetComputerName
        InternetDeleteRegistryValue
        InternetReadRegistryDword
        InternetWriteRegistryDword
        InternetReadRegistryString
        InternetWriteRegistryString
        InternetReadRegistryBinary
        (InternetReadRegistryDwordKey)
        (InternetReadRegistryStringKey)
        (InternetReadRegistryBinaryKey)
        (InternetGetPrivateProfileString)
        (ReadRegistryOemString)
        (WriteRegistryDword)
        ReadRegistryDword

Author:

    Richard L Firth (rfirth) 20-Mar-1995

Environment:

    Win32(s) user-level DLL

Revision History:

    20-Mar-1995 rfirth
        Created

--*/

#include <wininetp.h>

char vszDelimiters[] = ";, ";

//
// manifests
//

#define INTERNET_CLIENT_KEY         "Internet Settings"
#define SYSTEM_INI_FILE_NAME        "SYSTEM.INI"
#define NETWORK_SECTION_NAME        "Network"
#define COMPUTER_NAME_VALUE         "ComputerName"
#define PROFILE_INT_BUFFER_LENGTH   128

#define MIME_TO_FILE_EXTENSION_KEY  "MIME\\Database\\Content Type\\"
#define EXTENSION_VALUE             "Extension"

//
// macros
//

#define INTERNET_SETTINGS_KEY       "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings"
#define INTERNET_CACHE_SETTINGS_KEY "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\5.0\\Cache"

//
// private prototypes
//

PRIVATE
DWORD
InternetReadRegistryDwordKey(
    IN HKEY ParameterKey,
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue
    );

PRIVATE
DWORD
InternetReadRegistryStringKey(
    IN HKEY ParameterKey,
    IN LPCSTR ParameterName,
    OUT LPSTR ParameterValue,
    IN OUT LPDWORD ParameterLength
    );

//PRIVATE
//DWORD
//InternetReadRegistryBinaryKey(
//    IN HKEY ParameterKey,
//    IN LPCSTR ParameterName,
//    OUT LPBYTE ParameterValue,
//    IN OUT LPDWORD ParameterLength
//    );
//
//PRIVATE
//DWORD
//InternetGetPrivateProfileString(
//    IN LPSTR IniFileName,
//    IN LPSTR SectionName,
//    IN LPCSTR ParameterName,
//    OUT LPSTR ParameterValue,
//    IN OUT LPDWORD ParameterLength
//    );

PRIVATE
DWORD
ReadRegistryOemString(
    IN HKEY Key,
    IN LPCSTR ParameterName,
    OUT LPSTR String,
    IN OUT LPDWORD Length
    );




PRIVATE
DWORD
WriteRegistryDword(
    IN HKEY Key,
    IN LPCSTR ParameterName,
    IN DWORD ParameterValue
    );

//
// private data
//

PRIVATE HKEY hKeyInternetSettings = NULL;

//
// functions
//


DWORD
OpenInternetSettingsKey(
    VOID
    )

/*++

Routine Description:

    Opens registry key for Internet Settings branch

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "OpenInternetSettingsKey",
                 NULL
                 ));

    DWORD error = ERROR_SUCCESS;

    if (!GeneralInitCritSec.Lock())
    {
        goto quit;
        error = ERROR_NOT_ENOUGH_MEMORY;
    }

    if (hKeyInternetSettings == NULL) {

        DWORD dwDisposition;

        REGCREATEKEYEX(HKEY_LOCAL_MACHINE,
                       INTERNET_SETTINGS_KEY,
                       0,     // reserved
                       NULL,  // class
                       0,     // options
                       KEY_READ | KEY_WRITE,
                       NULL,  // security attributes
                       &hKeyInternetSettings,
                       &dwDisposition
                       );
    }

    GeneralInitCritSec.Unlock();

quit:
    DEBUG_LEAVE(error);

    return error;
}


DWORD
CloseInternetSettingsKey(
    VOID
    )

/*++

Routine Description:

    Closes Internet Settings registry key

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "CloseInternetSettingsKey",
                 NULL
                 ));

    DWORD error = ERROR_SUCCESS;

    if (hKeyInternetSettings != NULL) {
        error = REGCLOSEKEY(hKeyInternetSettings);
        hKeyInternetSettings = NULL;
    }

    DEBUG_LEAVE(error);

    return error;
}


PUBLIC
DWORD
InternetDeleteRegistryValue(
    IN LPSTR ParameterName
    )

/*++

Routine Description:

    Delets an entry from a the Internet Client registry key if the platform
    is NT/Win95.

Arguments:

    ParameterName   - name of the parameter to retrieve (e.g. AccessType)

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND

--*/

{
    DWORD error;

    DEBUG_ENTER((DBG_REGISTRY,
                Dword,
                "InternetDeleteRegistryValue",
                "%q",
                ParameterName
                ));


    HKEY clientKey;

    //
    // open the registry key containing the Internet client values (this is
    // in the same place on NT and Win95)
    //

    error = REGOPENKEYEX(HKEY_CURRENT_USER,
                         INTERNET_SETTINGS_KEY,
                         0, // reserved
                         KEY_ALL_ACCESS,
                         &clientKey
                         );


    if (error == ERROR_SUCCESS) {

        error = RegDeleteValue(clientKey,
                               ParameterName
                               );

        REGCLOSEKEY(clientKey);
    }


    DEBUG_LEAVE(error);

    return error;
}




DWORD
InternetReadRegistryDword(
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue
    )

/*++

Routine Description:

    Reads a single DWORD from a the Internet Client registry key if the platform
    is NT/Win95, else reads the value from SYSTEM.INI if we are running on Win32s

Arguments:

    ParameterName   - name of the parameter to retrieve (e.g. AccessType)

    ParameterValue  - pointer to place to store retrieved value

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "InternetReadRegistryDword",
                 "%q, %x",
                 ParameterName,
                 ParameterValue
                 ));

    DWORD error = InternetReadRegistryDwordKey(HKEY_LOCAL_MACHINE,
                                               ParameterName,
                                               ParameterValue
                                               );

    DEBUG_LEAVE(error);

    return error;
}

#ifdef WININET6

DWORD
InternetIDEWriteRegistryDword(
    IN LPCSTR ParameterName,
    IN DWORD ParameterValue
    )

/*++

Routine Description:

    Writes a single DWORD from to the Internet Client registry key if the platform
    is NT/Win95, otherwise it fails.

Arguments:

    ParameterName   - name of the parameter to retrieve (e.g. AccessType)

    ParameterValue  - value to store in registry.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "InternetIDEWriteRegistryDword",
                 "%q, %x",
                 ParameterName,
                 ParameterValue
                 ));

    DWORD error = GlobalIdentity 
                ? WriteIDRegDword(ParameterName, ParameterValue)
                : InternetWriteRegistryDword(ParameterName, ParameterValue);

    DEBUG_LEAVE(error);

    return error;
}



DWORD
InternetIDEReadRegistryDword(
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue
    )

/*++

Routine Description:

    If we're in an identity-mode, we'll read from the special location.
    Otherwise, read from the old location.

Arguments:

    ParameterName   - name of the parameter to retrieve (e.g. AccessType)

    ParameterValue  - pointer to place to store retrieved value

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "InternetIDEReadRegistryDword",
                 "%q, %x",
                 ParameterName,
                 ParameterValue
                 ));

    DWORD error = GlobalIdentity
                ? ReadIDRegDword(ParameterName, ParameterValue)
                : InternetReadRegistryDwordKey(HKEY_CURRENT_USER, ParameterName, ParameterValue);

    DEBUG_LEAVE(error);

    return error;
}
#endif


DWORD
InternetCacheReadRegistryDword(
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue
    )

/*++

Routine Description:

    Reads a single DWORD from a the Internet Client registry key if the platform
    is NT/Win95, else reads the value from SYSTEM.INI if we are running on Win32s

Arguments:

    ParameterName   - name of the parameter to retrieve (e.g. AccessType)

    ParameterValue  - pointer to place to store retrieved value

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "InternetCacheReadRegistryDword",
                 "%q, %x",
                 ParameterName,
                 ParameterValue
                 ));

    DWORD error = ERROR_SUCCESS;
    HKEY clientKey;

    error = REGOPENKEYEX(HKEY_CURRENT_USER,
                         INTERNET_CACHE_SETTINGS_KEY,
                         0, // reserved
                         KEY_QUERY_VALUE,
                         &clientKey
                         );

    if (error == ERROR_SUCCESS) {
        error = ReadRegistryDword(clientKey,
                                  ParameterName,
                                  ParameterValue
                                  );
        REGCLOSEKEY(clientKey);
    }

    DEBUG_LEAVE(error);

    return error;
}



DWORD
InternetWriteRegistryDword(
    IN LPCSTR ParameterName,
    IN DWORD ParameterValue
    )

/*++

Routine Description:

    Writes a single DWORD from to the Internet Client registry key if the platform
    is NT/Win95, otherwise it fails.

Arguments:

    ParameterName   - name of the parameter to retrieve (e.g. AccessType)

    ParameterValue  - value to store in registry.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "InternetWriteRegistryDword",
                 "%q, %x",
                 ParameterName,
                 ParameterValue
                 ));

    DWORD error;

    if (hKeyInternetSettings != NULL) {
        error = WriteRegistryDword(hKeyInternetSettings,
                                   ParameterName,
                                   ParameterValue
                                   );
    } else {
        error = ERROR_SUCCESS;
    }

    DEBUG_PRINT(REGISTRY,
                INFO,
                ("InternetWriteRegistryDword(%q): value = %d (%#x)\n",
                ParameterName,
                ParameterValue,
                ParameterValue
                ));

    DEBUG_LEAVE(error);

    return error;
}



DWORD
InternetReadRegistryString(
    IN LPCSTR ParameterName,
    OUT LPSTR ParameterValue,
    IN OUT LPDWORD ParameterLength
    )

/*++

Routine Description:

    Reads a string from the Internet Client registry key on NT/Win95, or reads
    the corresponding value from SYSTEM.INI on a Win32s platform

Arguments:

    ParameterName   - name of value parameter within key (e.g. EmailName)

    ParameterValue  - pointer to string buffer for returned string

    ParameterLength - IN: number of bytes in ParameterValue
                      OUT: number of bytes in string (excluding trailing '\0')

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "InternetReadRegistryString",
                 "%q, %x, %x [%d]",
                 ParameterName,
                 ParameterValue,
                 ParameterLength,
                 *ParameterLength
                 ));

    DWORD error = InternetReadRegistryStringKey(HKEY_CURRENT_USER,
                                                ParameterName,
                                                ParameterValue,
                                                ParameterLength
                                                );

    DEBUG_LEAVE(error);

    return error;
}

//
//DWORD
//InternetWriteRegistryString(
//    IN LPCSTR ParameterName,
//    IN LPSTR ParameterValue
//    )
//
///*++
//
//Routine Description:
//
//    Writes a string to the Internet Client registry key on NT/Win95, or writes
//    the corresponding value to SYSTEM.INI on Win32s platform
//
//Arguments:
//
//    ParameterName   - name of value parameter within key (e.g. EmailName)
//
//    ParameterValue  - pointer to string to write
//
//Return Value:
//
//    DWORD
//        Success - ERROR_SUCCESS
//
//        Failure -
//
//--*/
//
//{
//    DEBUG_ENTER((DBG_REGISTRY,
//                 Dword,
//                 "InternetWriteRegistryString",
//                 "%.40q, %.80q",
//                 ParameterName,
//                 ParameterValue
//                 ));
//
//    DWORD error;
//
//    if (IsPlatformWin32s()) {
//
//        BOOL ok;
//
//        ok = WritePrivateProfileString(INTERNET_CLIENT_KEY,
//                                       ParameterName,
//                                       ParameterValue,
//                                       SYSTEM_INI_FILE_NAME
//                                       );
//        error = ok ? ERROR_SUCCESS : GetLastError();
//    } else {
//
//        //
//        // BUGBUG - currently, nothing needs to write to registry if NT or Win95
//        //
//
//        INET_ASSERT(FALSE);
//
//    }
//
//    DEBUG_LEAVE(error);
//
//    return error;
//}
//
//
//DWORD
//InternetReadRegistryBinary(
//    IN LPCSTR ParameterName,
//    OUT LPBYTE ParameterValue,
//    IN OUT LPDWORD ParameterLength
//    )
//
///*++
//
//Routine Description:
//
//    Reads a binary value from the Internet Client registry key on NT/Win95, or
//    reads the corresponding value from SYSTEM.INI on a Win32s platform
//
//Arguments:
//
//    ParameterName   - name of value parameter within key (e.g. EmailName)
//
//    ParameterValue  - pointer to buffer for returned data
//
//    ParameterLength - IN: number of bytes in ParameterValue
//                      OUT: number of bytes in buffer, or required size
//
//Return Value:
//
//    DWORD
//        Success - ERROR_SUCCESS
//
//        Failure - ERROR_PATH_NOT_FOUND
//                    The parameter wasn't found
//
//                  ERROR_MORE_DATA
//                    The buffer isn't large enough
//
//--*/
//
//{
//    DEBUG_ENTER((DBG_REGISTRY,
//                 Dword,
//                 "InternetReadRegistryBinary",
//                 "%q, %#x, %#x [%d]",
//                 ParameterName,
//                 ParameterValue,
//                 ParameterLength,
//                 *ParameterLength
//                 ));
//
//    DWORD error;
//
//    error = InternetReadRegistryBinaryKey(HKEY_CURRENT_USER,
//                                          ParameterName,
//                                          ParameterValue,
//                                          ParameterLength
//                                          );
//
//    DEBUG_LEAVE(error);
//
//    return error;
//}

//
// private functions
//


PUBLIC
DWORD
InternetReadRegistryDwordKey(
    IN HKEY ParameterKey,
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue
    )

/*++

Routine Description:

    Reads a single DWORD from a the Internet Client registry key if the platform
    is NT/Win95, else reads the value from SYSTEM.INI if we are running on Win32s.

    Does not modify the *ParameterValue if the registry variable cannot be read

Arguments:

    ParameterKey    - root registry key (e.g. HKEY_CURRENT_USER)

    ParameterName   - name of the parameter to retrieve (e.g. AccessType)

    ParameterValue  - pointer to place to store retrieved value

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "InternetReadRegistryDwordKey",
                 "%s, %q, %x",
                 (ParameterKey == HKEY_LOCAL_MACHINE)
                    ? "HKEY_LOCAL_MACHINE"
                    : (ParameterKey == HKEY_CURRENT_USER)
                        ? "HKEY_CURRENT_USER"
                        : "???",
                 ParameterName,
                 ParameterValue
                 ));

    DWORD error = ERROR_SUCCESS;
    HKEY clientKey = hKeyInternetSettings;

    if (ParameterKey != HKEY_CURRENT_USER) {
        error = REGOPENKEYEX(ParameterKey,
                             INTERNET_SETTINGS_KEY,
                             0, // reserved
                             KEY_QUERY_VALUE,
                             &clientKey
                             );
    } else if (clientKey == NULL) {
        error = ERROR_PATH_NOT_FOUND;
    }

    if (error == ERROR_SUCCESS) {
        error = ReadRegistryDword(clientKey,
                                  ParameterName,
                                  ParameterValue
                                  );
        if (clientKey != hKeyInternetSettings) {
            REGCLOSEKEY(clientKey);
        }
    }

    DEBUG_PRINT(REGISTRY,
                INFO,
                ("InternetReadRegistryDwordKey(%q): value = %d (%#x)\n",
                ParameterName,
                *ParameterValue,
                *ParameterValue
                ));

    DEBUG_LEAVE(error);

    return error;
}


PRIVATE
DWORD
InternetReadRegistryStringKey(
    IN HKEY ParameterKey,
    IN LPCSTR ParameterName,
    OUT LPSTR ParameterValue,
    IN OUT LPDWORD ParameterLength
    )

/*++

Routine Description:

    Reads a string from the Internet Client registry key on NT/Win95, or reads
    the corresponding value from SYSTEM.INI on a Win32s platform

Arguments:

    ParameterKey    - root registry key (e.g. HKEY_LOCAL_MACHINE)

    ParameterName   - name of value parameter within key (e.g. EmailName)

    ParameterValue  - pointer to string buffer for returned string

    ParameterLength - IN: number of bytes in ParameterValue
                      OUT: number of bytes in string (excluding trailing '\0')

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "InternetReadRegistryStringKey",
                 "%s (%x), %q, %x, %x [%d]",
                 (ParameterKey == HKEY_LOCAL_MACHINE)
                    ? "HKEY_LOCAL_MACHINE"
                    : (ParameterKey == HKEY_CURRENT_USER)
                        ? "HKEY_CURRENT_USER"
                        : "???",
                 ParameterKey,
                 ParameterName,
                 ParameterValue,
                 ParameterLength,
                 *ParameterLength
                 ));

    //
    // zero-terminate the string
    //

    if (*ParameterLength > 0) {
        *ParameterValue = '\0';
    }

    DWORD error = ERROR_SUCCESS;
    HKEY clientKey = hKeyInternetSettings;

    if (ParameterKey != HKEY_CURRENT_USER) {
        error = REGOPENKEYEX(ParameterKey,
                             INTERNET_SETTINGS_KEY,
                             0, // reserved
                             KEY_QUERY_VALUE,
                             &clientKey
                             );
    } else if (clientKey == NULL) {
        error = ERROR_PATH_NOT_FOUND;
    }

    if (error == ERROR_SUCCESS) {
        error = ReadRegistryOemString(clientKey,
                                      ParameterName,
                                      ParameterValue,
                                      ParameterLength
                                      );
        if (clientKey != hKeyInternetSettings) {
            REGCLOSEKEY(clientKey);
        }
    }

    DEBUG_PRINT(REGISTRY,
                INFO,
                ("InternetReadRegistryStringKey(%q): value = %q\n",
                ParameterName,
                ParameterValue
                ));

    DEBUG_LEAVE(error);

    return error;
}

//
//PRIVATE
//DWORD
//InternetReadRegistryBinaryKey(
//    IN HKEY ParameterKey,
//    IN LPCSTR ParameterName,
//    OUT LPBYTE ParameterValue,
//    IN OUT LPDWORD ParameterLength
//    )
//
///*++
//
//Routine Description:
//
//    Reads a binary value from the Internet Client registry key on NT/Win95, or
//    reads the corresponding value from SYSTEM.INI on a Win32s platform
//
//Arguments:
//
//    ParameterKey    - root registry key (e.g. HKEY_LOCAL_MACHINE)
//
//    ParameterName   - name of value parameter within key (e.g. EmailName)
//
//    ParameterValue  - pointer to buffer for returned data
//
//    ParameterLength - IN: number of bytes in ParameterValue
//                      OUT: number of bytes in buffer, or required size
//
//Return Value:
//
//    DWORD
//        Success - ERROR_SUCCESS
//
//        Failure - ERROR_PATH_NOT_FOUND
//                    The parameter wasn't found
//
//                  ERROR_MORE_DATA
//                    The buffer isn't large enough
//
//--*/
//
//{
//    DEBUG_ENTER((DBG_REGISTRY,
//                 Dword,
//                 "InternetReadRegistryBinaryKey",
//                 "%s (%x), %q, %#x, %#x [%d]",
//                 (ParameterKey == HKEY_LOCAL_MACHINE)
//                    ? "HKEY_LOCAL_MACHINE"
//                    : (ParameterKey == HKEY_CURRENT_USER)
//                        ? "HKEY_CURRENT_USER"
//                        : "???",
//                 ParameterKey,
//                 ParameterName,
//                 ParameterValue,
//                 ParameterLength,
//                 *ParameterLength
//                 ));
//
//    DWORD error;
//    HKEY clientKey;
//
//    //
//    // open the registry key containing the Internet client values (this is
//    // in the same place on NT and Win95)
//    //
//
//    error = REGOPENKEYEX(ParameterKey,
//                         INTERNET_SETTINGS_KEY,
//                         0, // reserved
//                         KEY_QUERY_VALUE,
//                         &clientKey
//                         );
//
//    if (error == ERROR_SUCCESS) {
//
//        DWORD valueType;
//
//        error = RegQueryValueEx(clientKey,
//                                ParameterName,
//                                NULL,   // reserved
//                                &valueType,
//                                ParameterValue,
//                                ParameterLength
//                                );
//        REGCLOSEKEY(clientKey);
//    }
//
//    DEBUG_PRINT(REGISTRY,
//                INFO,
//                ("InternetReadRegistryBinaryKey(%q): length = %d\n",
//                ParameterName,
//                *ParameterLength
//                ));
//
//    DEBUG_LEAVE(error);
//
//    return error;
//}
//
//
//PRIVATE
//DWORD
//InternetGetPrivateProfileString(
//    IN LPSTR IniFileName,
//    IN LPSTR SectionName,
//    IN LPCSTR ParameterName,
//    OUT LPSTR ParameterValue,
//    IN OUT LPDWORD ParameterLength
//    )
//
///*++
//
//Routine Description:
//
//    Reads an string out of an INI file. Mainly just for Win32s
//
//Arguments:
//
//    IniFileName     - name of INI file to read
//
//    SectionName     - name of section in INI file to read
//
//    ParameterName   - name of entry in section to read
//
//    ParameterValue  - returned string
//
//    ParameterLength - IN: Length of ParameterValue
//                      OUT: Number of characters in ParameterValue, excluding
//                           terminating NUL
//
//Return Value:
//
//    DWORD
//        Success - ERROR_SUCCESS
//
//        Failure - ERROR_PATH_NOT_FOUND
//                  ERROR_FILE_NOT_FOUND
//
//--*/
//
//{
//    DWORD error;
//    DWORD nChars;
//
//    nChars = GetPrivateProfileString(SectionName,
//                                     ParameterName,
//                                     "",                // lpszDefault
//                                     ParameterValue,
//                                     *ParameterLength,
//                                     IniFileName
//                                     );
//    if (nChars > 0) {
//        *ParameterLength = nChars;
//        error = ERROR_SUCCESS;
//    } else {
//        error = ERROR_PATH_NOT_FOUND;
//    }
//    return error;
//}


PRIVATE
DWORD
ReadRegistryOemString(
    IN HKEY Key,
    IN LPCSTR ParameterName,
    OUT LPSTR String,
    IN OUT LPDWORD Length
    )

/*++

Routine Description:

    Reads a string out of the registry as an OEM string

Arguments:

    Key             - open registry key where to read value from

    ParameterName   - name of registry value to read

    String          - place to put it

    Length          - IN: length of String buffer in characters
                      OUT: length of String in characters, as if returned from
                      strlen()

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_FILE_NOT_FOUND
                    Couldn't find the parameter

                  ERROR_PATH_NOT_FOUND
                    Couldn't find the parameter
--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "ReadRegistryOemString",
                 "%#x, %q, %#x, %#x [%d]",
                 Key,
                 ParameterName,
                 String,
                 Length,
                 *Length
                 ));

    LONG error;
    DWORD valueType;
    LPSTR str;
    DWORD valueLength;

    //
    // first, get the length of the string
    //

    valueLength = *Length;
    error = RegQueryValueEx(Key,
                            ParameterName,
                            NULL, // reserved
                            &valueType,
                            (LPBYTE)String,
                            &valueLength
                            );
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // we only support REG_SZ (single string) values in this function
    //

    if (valueType != REG_SZ) {
        error = ERROR_PATH_NOT_FOUND;
        goto quit;
    }

    //
    // if 1 or 0 chars returned then the string is empty
    //

    if (valueLength <= sizeof(char)) {
        error = ERROR_PATH_NOT_FOUND;
        goto quit;
    }

    //
    // convert the ANSI string to OEM character set in place. According to Win
    // help, this always succeeds
    //

    CharToOem(String, String);

    //
    // return the length as if returned from strlen() (i.e. drop the '\0')
    //

    *Length = valueLength - sizeof(char);

    DEBUG_PRINT(REGISTRY,
                INFO,
                ("ReadRegistryOemString(%q) returning %q (%d chars)\n",
                ParameterName,
                String,
                *Length
                ));

quit:

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ReadRegistryDword(
    IN HKEY Key,
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue
    )

/*++

Routine Description:

    Reads a DWORD parameter from the registry

    Won't modify *ParameterValue unless a valid value is read from the registry

Arguments:

    Key             - handle of open registry key where parameter resides

    ParameterName   - name of DWORD parameter to read

    ParameterValue  - returned DWORD parameter read from registry

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND
                    One of the following occurred:
                        - the parameter is not in the specified registry key
                        - the parameter is the wrong type
                        - the parameter is the wrong size

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "ReadRegistryDword",
                 "%x, %q, %x",
                 Key,
                 ParameterName,
                 ParameterValue
                 ));

    DWORD error;
    DWORD valueLength;
    DWORD valueType;
    DWORD value;

    valueLength = sizeof(*ParameterValue);
    error = (DWORD)RegQueryValueEx(Key,
                                   ParameterName,
                                   NULL, // reserved
                                   &valueType,
                                   (LPBYTE)&value,
                                   &valueLength
                                   );

    //
    // if the size or type aren't correct then return an error, else only if
    // success was returned do we modify *ParameterValue
    //

    if (error == ERROR_SUCCESS) {
        if (((valueType != REG_DWORD)
        && (valueType != REG_BINARY))
        || (valueLength != sizeof(DWORD))) {

            DEBUG_PRINT(REGISTRY,
                        ERROR,
                        ("valueType = %d, valueLength = %d\n",
                        valueType,
                        valueLength
                        ));

            error = ERROR_PATH_NOT_FOUND;
        } else {
            *ParameterValue = value;
        }
    }

    DEBUG_LEAVE(error);

    return error;
}


PRIVATE
DWORD
WriteRegistryDword(
    IN HKEY Key,
    IN LPCSTR ParameterName,
    IN DWORD ParameterValue
    )

/*++

Routine Description:

    Writes a DWORD parameter from the registry

    Will write ParameterValue to the key.

Arguments:

    Key             - handle of open registry key where parameter resides

    ParameterName   - name of DWORD parameter to write

    ParameterValue  - DWORD parameter to write from registry

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND
                    One of the following occurred:
                        - the parameter is not in the specified registry key
                        - the parameter is the wrong type
                        - the parameter is the wrong size

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "WriteRegistryDword",
                 "%x, %q, %x",
                 Key,
                 ParameterName,
                 ParameterValue
                 ));

    DWORD error;
    DWORD valueLength;
    DWORD valueType;
    DWORD value;

    valueLength = sizeof(ParameterValue);
    valueType   = REG_DWORD;
    value       = ParameterValue;

    error = (DWORD)RegSetValueEx(Key,
                                 ParameterName,
                                 NULL, // reserved
                                 valueType,
                                 (LPBYTE)&value,
                                 valueLength
                                 );

    DEBUG_PRINT(REGISTRY,
                INFO,
                ("added: valueType = %d, valueLength = %d\n",
                valueType,
                valueLength
                ));

    DEBUG_LEAVE(error);

    return error;
}

#if INET_DEBUG

typedef struct {
    LIST_ENTRY entry;
    HKEY hkey;
    char * file;
    int line;
    char name[1];
} DBGREGKEYINFO;

SERIALIZED_LIST DbgRegKeyList;

VOID DbgRegKey_Init(VOID) {
    InitializeSerializedList(&DbgRegKeyList);
}

VOID DbgRegKey_Terminate(VOID) {
    TerminateSerializedList(&DbgRegKeyList);
}

void regkey_add(const char * name, HKEY hkey, char * file, int line) {

    if (!name) {
        name = "";
    }

    int len = lstrlen(name);
    DBGREGKEYINFO * p = (DBGREGKEYINFO *)ALLOCATE_FIXED_MEMORY(sizeof(DBGREGKEYINFO) + len);

    if (p) {
//dprintf("Wininet.DbgRegKey: adding %q\n", name);
        memcpy(p->name, name, len + 1);
        p->line = line;
        p->file = file;
        p->hkey = hkey;
        InsertAtHeadOfSerializedList(&DbgRegKeyList, &p->entry);
    }
}

void regkey_remove(HKEY hkey) {
    if (LockSerializedList(&DbgRegKeyList))
    {

        DBGREGKEYINFO * p = (DBGREGKEYINFO *)HeadOfSerializedList(&DbgRegKeyList);

        while (p != (DBGREGKEYINFO *)SlSelf(&DbgRegKeyList)) {
            if (p->hkey == hkey) {
                RemoveFromSerializedList(&DbgRegKeyList, (PLIST_ENTRY)p);
//dprintf("Wininet.DbgRegKey: removing %q\n", p->name);
                FREE_MEMORY(p);
                break;
            }
            p = (DBGREGKEYINFO *)p->entry.Flink;
        }
        UnlockSerializedList(&DbgRegKeyList);
    }
}

char * regkey_name(HKEY hkey, const char * subname) {
    switch ((INT_PTR)hkey) {
    case (INT_PTR)HKEY_CLASSES_ROOT:
        return NEW_STRING("HKEY_CLASSES_ROOT");

    case (INT_PTR)HKEY_CURRENT_USER:
        return NEW_STRING("HKEY_CURRENT_USER");

    case (INT_PTR)HKEY_LOCAL_MACHINE:
        return NEW_STRING("HKEY_LOCAL_MACHINE");

    case (INT_PTR)HKEY_USERS:
        return NEW_STRING("HKEY_USERS");

    case (INT_PTR)HKEY_PERFORMANCE_DATA:
        return NEW_STRING("HKEY_PERFORMANCE_DATA");

    case (INT_PTR)HKEY_CURRENT_CONFIG:
        return NEW_STRING("HKEY_CURRENT_CONFIG");

    case (INT_PTR)HKEY_DYN_DATA:
        return NEW_STRING("HKEY_DYN_DATA");
    }

    char * name = NULL;

    if (LockSerializedList(&DbgRegKeyList))
    {
        DBGREGKEYINFO * p = (DBGREGKEYINFO *)HeadOfSerializedList(&DbgRegKeyList);

        while (p != (DBGREGKEYINFO *)SlSelf(&DbgRegKeyList)) {
            if (p->hkey == hkey) {

                int len = lstrlen(p->name);
                int slen = lstrlen(subname);

                name = (char *)ALLOCATE_FIXED_MEMORY(len + 1 + slen + 1);
                if (name) {
                    memcpy(name, p->name, len);
                    name[len] = '\\';
                    memcpy(name + len + 1, subname, slen + 1);
                }
                break;
            }
            p = (DBGREGKEYINFO *)p->entry.Flink;
        }
        UnlockSerializedList(&DbgRegKeyList);
    }

    return name;
}

void regkey_freename(char * name) {
    if (name) {
        FREE_MEMORY(name);
    }
}

LONG
DbgRegOpenKey(
    IN HKEY hKey,
    IN LPCTSTR lpszSubKey,
    OUT PHKEY phkResult,
    char * file,
    int line
    )
{
    char * keyname = regkey_name(hKey, lpszSubKey);
    LONG rc = RegOpenKey(hKey, lpszSubKey, phkResult);

    if (rc == 0) {
        regkey_add(keyname, *phkResult, file, line);
    }
    regkey_freename(keyname);
    return rc;
}

LONG
DbgRegOpenKeyEx(
    IN HKEY hKey,
    IN LPCSTR lpSubKey,
    IN DWORD ulOptions,
    IN REGSAM samDesired,
    OUT PHKEY phkResult,
    char * file,
    int line
    )
{
    char * keyname = regkey_name(hKey, lpSubKey);
    LONG rc = RegOpenKeyEx(hKey, lpSubKey, ulOptions, samDesired, phkResult);

    if (rc == 0) {
        regkey_add(keyname, *phkResult, file, line);
    }
    regkey_freename(keyname);
    return rc;
}

LONG
DbgRegCreateKeyEx(
    IN HKEY hKey,
    IN LPCSTR lpSubKey,
    IN DWORD Reserved,
    IN LPSTR lpClass,
    IN DWORD dwOptions,
    IN REGSAM samDesired,
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    OUT PHKEY phkResult,
    OUT LPDWORD lpdwDisposition,
    char * file,
    int line
    )
{
    char * keyname = regkey_name(hKey, lpSubKey);
    LONG rc = RegCreateKeyEx(hKey, lpSubKey, Reserved, lpClass, dwOptions, samDesired, lpSecurityAttributes, phkResult, lpdwDisposition);

    if (rc == 0) {
        regkey_add(keyname, *phkResult, file, line);
    }
    regkey_freename(keyname);
    return rc;
}

LONG
DbgRegCloseKey(
    IN HKEY hKey
    )
{
    LONG rc = RegCloseKey(hKey);

    if (rc == 0) {
        regkey_remove(hKey);
    }
    return rc;
}

#endif // INET_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\api\inetapiw.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    inetapiw.cxx

Abstract:

    Contains the wide-character Internet APIs

    Contents:
        WinHttpCrackUrl
        WinHttpCreateUrl
        WinHttpOpen
        WinHttpConnect
        WinHttpSetStatusCallback

Author:

    Richard L Firth (rfirth) 02-Mar-1995

Environment:

    Win32(s) user-mode DLL

Revision History:

    02-Mar-1995 rfirth
        Created

--*/

#include <wininetp.h>

//  because wininet doesnt know about IStream
#define NO_SHLWAPI_STREAM
#include <shlwapi.h>
#include <shlwapip.h>


// -- FixStrings ------

//  Used in WinHttpCrackUrlW only.
//  Either
//  (a) If we have an ansi string, AND a unicode buffer, convert from ansi to unicode
//  (b) If we have an ansi string, but NO unicode buffer, determine where the ansi string
//         occurs in the unicode URL, and point the component there.

VOID
FixStrings(    
    LPSTR& pszA, 
    DWORD cbA, 
    LPWSTR& pszW, 
    DWORD& ccW, 
    LPSTR pszUrlA, 
    LPCWSTR pszUrlW)
{
    if (!pszA)
        return;

    if (pszW) 
    {
        ccW = MultiByteToWideChar(CP_ACP, 0, pszA, cbA+1, pszW, ccW) - 1; 
    } 
    else 
    { 
        pszW = (LPWSTR)(pszUrlW + MultiByteToWideChar(CP_ACP, 0, 
                pszUrlA, (int) (pszA-pszUrlA), NULL, 0)); 
        ccW = MultiByteToWideChar(CP_ACP, 0, pszA, cbA, NULL, 0); 
    } 
}

//
// functions
//


INTERNETAPI
BOOL
WINAPI
WinHttpCrackUrl(
    IN LPCWSTR pszUrlW,
    IN DWORD dwUrlLengthW,
    IN DWORD dwFlags,
    IN OUT LPURL_COMPONENTSW pUCW
    )

/*++

Routine Description:

    Cracks an URL into its constituent parts. Optionally escapes the url-path.
    We assume that the user has supplied large enough buffers for the various
    URL parts

Arguments:

    pszUrl         - pointer to URL to crack

    dwUrlLength     - 0 if pszUrl is ASCIIZ string, else length of pszUrl

    dwFlags         - flags controlling operation

    lpUrlComponents - pointer to URL_COMPONENTS

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "WinHttpCrackUrl",
                     "%wq, %#x, %#x, %#x",
                     pszUrlW,
                     dwUrlLengthW,
                     dwFlags,
                     pUCW
                     ));

    INET_ASSERT(pszUrlW);
    INET_ASSERT(pUCW);

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;
    BOOL fContinue;
    DWORD c;
    MEMORYPACKET mpUrlA, mpHostName, mpUserName, mpScheme, mpPassword, mpUrlPath, mpExtraInfo;
    URL_COMPONENTSA UCA;

    if (!pszUrlW
        || (dwUrlLengthW
            ? IsBadStringPtrW(pszUrlW,-1)
            : IsBadReadPtr(pszUrlW,dwUrlLengthW))
        || !pUCW
        || IsBadWritePtr(pUCW, sizeof(*pUCW))
        || (pUCW->dwStructSize != sizeof(*pUCW)) 
        || (dwFlags & ~(ICU_ESCAPE | ICU_DECODE)))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    
    UCA.dwStructSize = sizeof(URL_COMPONENTSA); 
    ALLOC_MB(pszUrlW, dwUrlLengthW, mpUrlA);
    if (!mpUrlA.psStr) {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
    }
    UNICODE_TO_ANSI(pszUrlW, mpUrlA);

    for (c=0; c<=5; c++) {
        LPWSTR pszWorker;
        DWORD ccLen;
        MEMORYPACKET* pmpWorker;
        
        switch(c)
        {
        case 0:
            pszWorker = pUCW->lpszScheme;
            ccLen = pUCW->dwSchemeLength;
            pmpWorker = &mpScheme;
            break;

        case 1:
            pszWorker = pUCW->lpszHostName;
            ccLen = pUCW->dwHostNameLength;
            pmpWorker = &mpHostName;
            break;

        case 2:
            pszWorker = pUCW->lpszUserName;
            ccLen = pUCW->dwUserNameLength;
            pmpWorker = &mpUserName;
            break;

        case 3:
            pszWorker = pUCW->lpszPassword;
            ccLen = pUCW->dwPasswordLength;
            pmpWorker = &mpPassword;
            break;

        case 4:
            pszWorker = pUCW->lpszUrlPath;
            ccLen = pUCW->dwUrlPathLength;
            pmpWorker = &mpUrlPath;
            break;

        case 5:
            pszWorker = pUCW->lpszExtraInfo;
            ccLen = pUCW->dwExtraInfoLength;
            pmpWorker = &mpExtraInfo;
            break;
        }

        if (pszWorker) 
        {
            if (pszWorker 
                && ccLen 
                && (ProbeWriteBuffer(pszWorker,ccLen) != ERROR_SUCCESS) )
            {
                dwErr = ERROR_INVALID_PARAMETER;
                goto cleanup;
            }
            ALLOC_MB(pszWorker,ccLen,(*pmpWorker)); 
            if (!pmpWorker->psStr) 
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                goto cleanup;
            }
        } 
        else 
        { 
            pmpWorker->dwAlloc = ccLen; 
        }
    };

    REASSIGN_ALLOC(mpScheme,UCA.lpszScheme,UCA.dwSchemeLength);
    REASSIGN_ALLOC(mpHostName, UCA.lpszHostName,UCA.dwHostNameLength);
    REASSIGN_ALLOC(mpUserName, UCA.lpszUserName,UCA.dwUserNameLength);
    REASSIGN_ALLOC(mpPassword,UCA.lpszPassword,UCA.dwPasswordLength);
    REASSIGN_ALLOC(mpUrlPath,UCA.lpszUrlPath,UCA.dwUrlPathLength);
    REASSIGN_ALLOC(mpExtraInfo,UCA.lpszExtraInfo,UCA.dwExtraInfoLength);
                
    fResult = WinHttpCrackUrlA(mpUrlA.psStr, mpUrlA.dwSize, dwFlags, &UCA);
    if (fResult) {
        FixStrings(UCA.lpszScheme, UCA.dwSchemeLength, pUCW->lpszScheme, 
                    pUCW->dwSchemeLength, mpUrlA.psStr, pszUrlW);
        FixStrings(UCA.lpszHostName, UCA.dwHostNameLength, pUCW->lpszHostName, 
                    pUCW->dwHostNameLength, mpUrlA.psStr, pszUrlW);
        FixStrings(UCA.lpszUserName, UCA.dwUserNameLength, pUCW->lpszUserName, 
                    pUCW->dwUserNameLength, mpUrlA.psStr, pszUrlW);
        FixStrings(UCA.lpszPassword, UCA.dwPasswordLength, pUCW->lpszPassword, 
                    pUCW->dwPasswordLength, mpUrlA.psStr, pszUrlW);
        FixStrings(UCA.lpszUrlPath, UCA.dwUrlPathLength, pUCW->lpszUrlPath, 
                    pUCW->dwUrlPathLength, mpUrlA.psStr, pszUrlW);
        FixStrings(UCA.lpszExtraInfo, UCA.dwExtraInfoLength, pUCW->lpszExtraInfo, 
                    pUCW->dwExtraInfoLength, mpUrlA.psStr, pszUrlW);
        pUCW->nScheme = UCA.nScheme;
        pUCW->nPort = UCA.nPort;
        pUCW->dwStructSize = sizeof(URL_COMPONENTSW);
    }

cleanup:        
    if (dwErr!=ERROR_SUCCESS) { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


INTERNETAPI
BOOL
WINAPI
WinHttpCreateUrl(
    IN LPURL_COMPONENTSW pUCW,
    IN DWORD dwFlags,
    OUT LPWSTR pszUrlW,
    IN OUT LPDWORD pdwUrlLengthW
    )

/*++

Routine Description:

    Creates an URL from its constituent parts

Arguments:

Return Value:

    BOOL
        Success - URL written to pszUrl

        Failure - call GetLastError() for more info

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "WinHttpCreateUrl",
                     "%#x, %#x, %#x, %#x",
                     pUCW,
                     dwFlags,
                     pszUrlW,
                     pdwUrlLengthW
                     ));

    INET_ASSERT(pszUrlW);
    INET_ASSERT(pUCW);

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;
    MEMORYPACKET mpUrlA, mpHostName, mpUserName, mpScheme, mpPassword, mpUrlPath, mpExtraInfo;
    URL_COMPONENTSA UCA;

    if (!pdwUrlLengthW 
        || (pUCW==NULL)
        || IsBadWritePtr(pUCW, sizeof(*pUCW))
        || (pUCW->dwStructSize != sizeof(*pUCW))
        || (pszUrlW && IsBadWritePtr(pszUrlW, *pdwUrlLengthW*sizeof(WCHAR)))
        || (dwFlags & ~(ICU_ESCAPE)))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    if (pszUrlW)
    {
        ALLOC_MB(pszUrlW, *pdwUrlLengthW, mpUrlA);
        if (!mpUrlA.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
    }
    mpUrlA.dwSize = mpUrlA.dwAlloc;
    UCA.dwStructSize = sizeof(URL_COMPONENTSA);

    UCA.nScheme = pUCW->nScheme;
    UCA.nPort = pUCW->nPort;
    if (pUCW->lpszScheme)
    {
        if (pUCW->dwSchemeLength
            ? IsBadReadPtr(pUCW->lpszScheme, pUCW->dwSchemeLength)
            : IsBadStringPtrW(pUCW->lpszScheme, -1))
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
        ALLOC_MB(pUCW->lpszScheme, pUCW->dwSchemeLength, mpScheme);
        if (!mpScheme.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(pUCW->lpszScheme, mpScheme);
    }
    REASSIGN_SIZE(mpScheme, UCA.lpszScheme, UCA.dwSchemeLength);
    if (pUCW->lpszHostName)
    {
        if (pUCW->dwHostNameLength
            ? IsBadReadPtr(pUCW->lpszHostName, pUCW->dwHostNameLength)
            : IsBadStringPtrW(pUCW->lpszHostName, -1))
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
        ALLOC_MB(pUCW->lpszHostName, pUCW->dwHostNameLength, mpHostName);
        if (!mpHostName.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(pUCW->lpszHostName, mpHostName);
    }
    REASSIGN_SIZE(mpHostName, UCA.lpszHostName, UCA.dwHostNameLength);
    if (pUCW->lpszUserName)
    {
        if (pUCW->dwUserNameLength
            ? IsBadReadPtr(pUCW->lpszUserName, pUCW->dwUserNameLength)
            : IsBadStringPtrW(pUCW->lpszUserName, -1))
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
        ALLOC_MB(pUCW->lpszUserName, pUCW->dwUserNameLength, mpUserName);
        if (!mpUserName.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(pUCW->lpszUserName, mpUserName);
    }
    REASSIGN_SIZE(mpUserName, UCA.lpszUserName, UCA.dwUserNameLength);
    if (pUCW->lpszPassword)
    {
        if (pUCW->dwPasswordLength
            ? IsBadReadPtr(pUCW->lpszPassword, pUCW->dwPasswordLength)
            : IsBadStringPtrW(pUCW->lpszPassword, -1))
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
        ALLOC_MB(pUCW->lpszPassword, pUCW->dwPasswordLength, mpPassword);
        if (!mpPassword.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(pUCW->lpszPassword, mpPassword);
    }
    REASSIGN_SIZE(mpPassword, UCA.lpszPassword, UCA.dwPasswordLength);
    if (pUCW->lpszUrlPath)
    {
        if (pUCW->dwUrlPathLength
            ? IsBadReadPtr(pUCW->lpszUrlPath, pUCW->dwUrlPathLength)
            : IsBadStringPtrW(pUCW->lpszUrlPath, -1))
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
        ALLOC_MB(pUCW->lpszUrlPath, pUCW->dwUrlPathLength, mpUrlPath); 
        if (!mpUrlPath.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(pUCW->lpszUrlPath, mpUrlPath);
    }
    REASSIGN_SIZE(mpUrlPath, UCA.lpszUrlPath, UCA.dwUrlPathLength);
    if (pUCW->lpszExtraInfo)
    {
        if (pUCW->dwExtraInfoLength
            ? IsBadReadPtr(pUCW->lpszExtraInfo, pUCW->dwExtraInfoLength)
            : IsBadStringPtrW(pUCW->lpszExtraInfo, -1))
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
        ALLOC_MB(pUCW->lpszExtraInfo, pUCW->dwExtraInfoLength, mpExtraInfo);
        if (!mpExtraInfo.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(pUCW->lpszExtraInfo, mpExtraInfo);
    }
    REASSIGN_SIZE(mpExtraInfo, UCA.lpszExtraInfo, UCA.dwExtraInfoLength);
    fResult = WinHttpCreateUrlA(&UCA, dwFlags, mpUrlA.psStr, &mpUrlA.dwSize);
    if (fResult)
    {
        DWORD dwRet;

        fResult = FALSE;
        
        if (pszUrlW && *pdwUrlLengthW)
        {
            //On success, reduce length of terminating NULL widechar.
            dwRet = MultiByteToWideChar(CP_ACP, 0, mpUrlA.psStr, mpUrlA.dwSize+1, pszUrlW, *pdwUrlLengthW);
            
            if (dwRet)
            {
                *pdwUrlLengthW = dwRet-1;
                fResult = TRUE;
            }
        }
        
        //If no url or no length or failure in prev. call, use MBtoWC to calculate required length of buffer.
        //If a value is returned, then set ERROR_INSUFFICIENT_BUFFER as last error
        if (!fResult)
        {
            dwRet = MultiByteToWideChar(CP_ACP, 0, mpUrlA.psStr, mpUrlA.dwSize+1, pszUrlW, 0);
            
            if (dwRet)
            {
                dwErr = ERROR_INSUFFICIENT_BUFFER;
                *pdwUrlLengthW = dwRet;
                
            }
            else
            {
                dwErr = GetLastError();
                //Morph the error since we don't know what to initialize pdwUrlLengthW to
                if (dwErr == ERROR_INSUFFICIENT_BUFFER)
                {
                    dwErr = ERROR_INVALID_PARAMETER;
                }
            }
        }
    }
    else
    {
        *pdwUrlLengthW = mpUrlA.dwSize;
    }

cleanup:        
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }

    DEBUG_LEAVE_API(fResult);
    return fResult;
}


// implemented in inetapia.cxx
DWORD ICUHrToWin32Error(HRESULT);


INTERNETAPI
HINTERNET
WINAPI
WinHttpOpen(
    IN LPCWSTR pszAgentW,
    IN DWORD dwAccessType,
    IN LPCWSTR pszProxyW OPTIONAL,
    IN LPCWSTR pszProxyBypassW OPTIONAL,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    pszAgent       -

    dwAccessType    -

    pszProxy       -

    pszProxyBypass -

    dwFlags         -

Return Value:

    HINTERNET

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Handle,
                     "WinHttpOpen",
                     "%wq, %s (%d), %wq, %wq, %#x",
                     pszAgentW,
                     InternetMapOpenType(dwAccessType),
                     dwAccessType,
                     pszProxyW,
                     pszProxyBypassW,
                     dwFlags
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    HINTERNET hInternet = NULL;
    MEMORYPACKET mpAgentA, mpProxyA, mpProxyBypassA;

    if (dwFlags &~ (WINHTTP_OPEN_FLAGS_MASK))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    
    if (pszAgentW)
    {
        if (IsBadStringPtrW(pszAgentW, -1))
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
        ALLOC_MB(pszAgentW,0,mpAgentA);
        if (!mpAgentA.psStr)
        {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                goto cleanup;
        }
        UNICODE_TO_ANSI(pszAgentW,mpAgentA);
    }

    if (dwAccessType & WINHTTP_ACCESS_TYPE_NAMED_PROXY)
    {
        if (pszProxyW)
        {
            if (IsBadStringPtrW(pszProxyW, -1) 
                || (*pszProxyW == L'\0'))
            {
                dwErr = ERROR_INVALID_PARAMETER;
                goto cleanup;
            }
            ALLOC_MB(pszProxyW,0,mpProxyA);
            if (!mpProxyA.psStr)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                goto cleanup;
            }
            UNICODE_TO_ANSI(pszProxyW,mpProxyA);
        }
        if (pszProxyBypassW)
        {
            if (IsBadStringPtrW(pszProxyBypassW, -1))
            {
                dwErr = ERROR_INVALID_PARAMETER;
                goto cleanup;
            }
            ALLOC_MB(pszProxyBypassW,0,mpProxyBypassA);
            if (!mpProxyBypassA.psStr)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                goto cleanup;
            }
            UNICODE_TO_ANSI(pszProxyBypassW,mpProxyBypassA);
        }
    }

    hInternet = InternetOpenA(mpAgentA.psStr, dwAccessType, mpProxyA.psStr, 
                                        mpProxyBypassA.psStr, dwFlags);

                                        
cleanup:        
    if (dwErr!=ERROR_SUCCESS) { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }

    DEBUG_LEAVE_API(hInternet);
    return hInternet;
}


INTERNETAPI
HINTERNET
WINAPI
WinHttpConnect(
    IN HINTERNET hInternetSession,
    IN LPCWSTR pszServerNameW,
    IN INTERNET_PORT nServerPort,
    IN DWORD dwReserved
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    hInternetSession    -
    pszServerName      -
    nServerPort         -
    pszUserName        -
    pszPassword        -
    dwService           -
    dwReserved             -

Return Value:

    HINTERNET

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Handle,
                     "WinHttpConnect",
                     "%#x, %wq, %d, %#x",
                     hInternetSession,
                     pszServerNameW,
                     nServerPort,
                     dwReserved
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    MEMORYPACKET mpServerNameA;
    HINTERNET hInternet = NULL;

    if (dwReserved)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    
    if (pszServerNameW)
    {
        if (IsBadStringPtrW(pszServerNameW,-1))
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
        dwErr = ConvertUnicodeToMultiByte(pszServerNameW, 0/*CODEPAGE not used here*/, &mpServerNameA, 
                    WINHTTP_FLAG_VALID_HOSTNAME); 
        if (dwErr != ERROR_SUCCESS)
        {
            goto cleanup;
        }
    }
    else
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    hInternet = InternetConnectA
        (hInternetSession, mpServerNameA.psStr, nServerPort, dwReserved, NULL);

cleanup:        
    if (dwErr!=ERROR_SUCCESS) { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }

    DEBUG_LEAVE_API(hInternet);
    return hInternet;
}


INTERNETAPI
WINHTTP_STATUS_CALLBACK
WINAPI
WinHttpSetStatusCallback(
    IN HINTERNET hInternet,
    IN WINHTTP_STATUS_CALLBACK lpfnInternetCallback,
    IN DWORD dwNotificationFlags,
    IN DWORD_PTR dwReserved
    )

/*++

Routine Description:

    Sets the status callback function for the DLL or the handle object

Arguments:

    hInternet               - handle of the object for which we wish to set the
                              status callback

    lpfnInternetCallback    - pointer to caller-supplied status function

Return Value:

    FARPROC
        Success - previous status callback function address

        Failure - INTERNET_INVALID_STATUS_CALLBACK. Call GetLastErrorInfo() for
                  more information:

                    ERROR_INVALID_PARAMETER
                        The callback function is invalid

                    ERROR_WINHTTP_INCORRECT_HANDLE_TYPE
                        Cannot set the callback on the supplied handle (probably
                        a NULL handle - per-process callbacks no longer
                        supported)

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Pointer,
                     "WinHttpSetStatusCallback",
                     "%#x, %#x, %#x",
                     hInternet,
                     lpfnInternetCallback,
                     dwNotificationFlags
                     ));
                 
    DWORD dwErr = ERROR_SUCCESS;
    BOOL fIsUnicode = TRUE; //vestigial UNICODE indicator
    
    WINHTTP_STATUS_CALLBACK previousCallback = WINHTTP_INVALID_STATUS_CALLBACK;
    HINTERNET hObjectMapped = NULL;

    if (!GlobalDataInitialized) 
    {
        dwErr = GlobalDataInitialize();
        if (dwErr != ERROR_SUCCESS) 
        {
            goto cleanup;
        }
    }

    if (((lpfnInternetCallback != NULL) && IsBadCodePtr((FARPROC)lpfnInternetCallback))
        || (dwNotificationFlags == 0) || (dwReserved != 0))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    
    if (!hInternet)
    {
        dwErr = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        goto cleanup;
    }

    // map the handle
    dwErr = MapHandleToAddress(hInternet, (LPVOID *)&hObjectMapped, FALSE);
    if (dwErr != ERROR_SUCCESS)
    {
        goto cleanup;
    }
    
    // swap the new and previous handle object status callbacks, ONLY
    // if there are no pending requests on this handle
    previousCallback = lpfnInternetCallback;
    dwErr = RExchangeStatusCallback(hObjectMapped, &previousCallback, fIsUnicode, dwNotificationFlags);
    
cleanup:

    if (hObjectMapped != NULL) 
    {
        DereferenceObject((LPVOID)hObjectMapped);
    }

    if (dwErr!=ERROR_SUCCESS)
    {
        SetLastError(dwErr);
        DEBUG_ERROR(API, dwErr);
    }
    
    DEBUG_LEAVE_API(previousCallback);
    return previousCallback;
}


// WinHttpPlatformCheck() API routines //////////////////////////////////////

static void ConvertVersionString(LPCSTR pszVersion, WORD rwVer[], CHAR ch)
{
    LPCSTR pszEnd;
    LPCSTR pszTemp;
    int    i; 

    for (i = 0; i < 4; i++)
        rwVer[i] = 0;

    pszEnd = pszVersion + lstrlen(pszVersion);
    pszTemp = pszVersion;

    for (i = 0; i < 4 && pszTemp < pszEnd; i++)
    {
        while (pszTemp < pszEnd && *pszTemp != ch)
        {
            rwVer[i] = rwVer[i] * 10 + (*pszTemp - '0');
            pszTemp++;
        }

        pszTemp++;
    }
}


const char c_gszRegActiveSetup[]        = "Software\\Microsoft\\Active Setup\\Installed Components\\";
const char c_gszInternetExplorerCLSID[] = "{89820200-ECBD-11cf-8B85-00AA005B4383}";

static void GetInstalledComponentVersion(LPCSTR szCLSID, DWORD *pdwMSVer, DWORD *pdwLSVer)
{
    HKEY    hKey;
    char    szKey[MAX_PATH];
    WORD    rgwVersion[4];
    DWORD   dwSize;
    
    *pdwMSVer = 0;
    *pdwLSVer = 0;

    // Build the registry path.
    lstrcpy(szKey, c_gszRegActiveSetup);
    lstrcat(szKey, szCLSID);
    
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, szKey, 0, KEY_QUERY_VALUE, &hKey) == ERROR_SUCCESS)
    {
        dwSize = sizeof(szKey);

        if ((RegQueryValueEx(hKey, "Version", NULL, NULL, (BYTE *)szKey, &dwSize) == ERROR_SUCCESS) &&
            (dwSize > 0))
        {
            ConvertVersionString(szKey, rgwVersion, ',');

            *pdwMSVer = (DWORD)rgwVersion[0] << 16;    // Make hi word of MS version
            *pdwMSVer += (DWORD)rgwVersion[1];         // Make lo word of MS version
            *pdwLSVer = (DWORD)rgwVersion[2] << 16;    // Make hi word of LS version
            *pdwLSVer += (DWORD)rgwVersion[3];         // Make lo word of LS version
        }

        RegCloseKey(hKey);
    }
}

static BOOL Is_IE_501_OrLaterInstalled()
{
    DWORD   dwMSVer;
    DWORD   dwLSVer;

    //
    // Find the IE version number. IE 5.01 has version number 5.00.2919.6300.
    // This will be returned from GetInstalledComponentVersion as two DWORDs,
    // like so:
    //      5.00   ->  0x00050000
    //   2919.6300 ->  0x0B67189C
    //

    GetInstalledComponentVersion(c_gszInternetExplorerCLSID, &dwMSVer, &dwLSVer);

    if (dwMSVer > 0x00050000)
        return TRUE;
    else if ((dwMSVer == 0x00050000) && (dwLSVer >= 0x0B67189C))
        return TRUE;

    return FALSE;
}

#if 0

#define REGSTR_CCS_CONTROL_WINDOWS  TEXT("SYSTEM\\CurrentControlSet\\Control\\WINDOWS")
#define CSDVERSION                  TEXT("CSDVersion")
#define SP6_VERSION                 0x0600

static BOOL Is_SP6_OrLater()
{
    BOOL    fSP6OrLater = FALSE;
    HKEY    hKey;
    DWORD   dwCSDVersion;
    DWORD   dwSize;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_CCS_CONTROL_WINDOWS, 0, KEY_QUERY_VALUE, &hKey) == ERROR_SUCCESS)
    {
        dwSize = sizeof(dwCSDVersion);

        if (RegQueryValueEx(hKey, CSDVERSION, NULL, NULL, (BYTE *)&dwCSDVersion, &dwSize) == ERROR_SUCCESS)
        {
            fSP6OrLater = (LOWORD(dwCSDVersion) >= SP6_VERSION);
        }
        RegCloseKey(hKey);
    }

    return fSP6OrLater;
}
#endif


INTERNETAPI
BOOL
WINAPI
WinHttpCheckPlatform(void)
{
    static BOOL _fCheckedPlatform = FALSE;
    static BOOL _fPlatformOk;


    if (!_fCheckedPlatform)
    {
        OSVERSIONINFO   osvi;
        BOOL            fPlatformOk = FALSE;

        osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        
        if (GetVersionEx(&osvi))
        {
            // Allow only Win2K or NT-based platforms.
            if (osvi.dwPlatformId == VER_PLATFORM_WIN32_NT)
            {
                if (osvi.dwMajorVersion >= 5)
                {
                    // Ok on Win2K or later.
                    fPlatformOk = TRUE;
                }
                else if (osvi.dwMajorVersion == 4)
                {
                    // On NT4, we require IE 5.01 (or later).
                    fPlatformOk = Is_IE_501_OrLaterInstalled();
                }
            }
        }

        _fPlatformOk = fPlatformOk;

        InterlockedExchange((long *)&_fCheckedPlatform, TRUE);
    }

    return _fPlatformOk;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\api\proxreg.cxx ===
#include "wininetp.h"

static const CHAR szRegPathConnections[] = REGSTR_PATH_INTERNET_SETTINGS "\\Connections";




// some winsock stacks fault if we do a gethostbyname(NULL).  If we come
// accross one of these, don't do any more autodetecting.
BOOL g_fGetHostByNameNULLFails = FALSE;

//
// IsConnectionMatch - a worker function to simply some logic elsewhere,
//  it just handles Connection Name Matching.
//

BOOL 
IsConnectionMatch(
    LPCSTR lpszConnection1,
    LPCSTR lpszConnection2)
{
    if ( lpszConnection1 == NULL && 
         lpszConnection2 == NULL) 
    {
        return TRUE;
    }

    if ( lpszConnection1 && lpszConnection2 &&
         stricmp(lpszConnection1, lpszConnection2) == 0 )
    {
        return TRUE;
    }

    return FALSE;
}

///////////////////////////////////////////////////////////////////////////
//
// CRegBlob implementation
//
///////////////////////////////////////////////////////////////////////////

CRegBlob::CRegBlob(
    BOOL fWrite
    )
{
    // initialize members
    _fWrite = fWrite;
    _fCommit = TRUE;
    _dwOffset = 0;
    _pBuffer = NULL;
    _dwBufferLimit = 0;
    _hkey = NULL;
}


CRegBlob::~CRegBlob(
    )
{
    Commit();

    if(_hkey)
        REGCLOSEKEY(_hkey);

    if(_pBuffer)
        FREE_FIXED_MEMORY(_pBuffer);

    // caller owns _pszValue pointer
}


DWORD
CRegBlob::Init(
    HKEY hBaseKey,
    LPCSTR pszSubKey,
    LPCSTR pszValue
    )
{
    long lRes;
    REGSAM  regsam = KEY_QUERY_VALUE;
    DWORD dwDisposition;

    // If we're writing, save reg value name and set access
    if(_fWrite)
    {
        _pszValue = pszValue;
        regsam = KEY_SET_VALUE;

        lRes = REGCREATEKEYEX(hBaseKey, pszSubKey, 0, "", 0,
                    regsam, NULL, &_hkey, &dwDisposition);
    }
    else
    {
        // If not writing, then use RegOpenKeyEx so we don't need
        // registry write permissions.
        lRes = REGOPENKEYEX(hBaseKey, pszSubKey, 0, regsam, &_hkey);
    }

    if(lRes != ERROR_SUCCESS)
    {
        return lRes;
    }

    // figure out buffer size
    _dwBufferLimit = BLOB_BUFF_GRANULARITY;
    if(FALSE == _fWrite)
    {
        // get size of registry blob
        lRes = RegQueryValueEx(_hkey, pszValue, NULL, NULL, NULL, &_dwBufferLimit);
        if(lRes != ERROR_SUCCESS)
        {
            // nothing there - make zero size buffer
            _dwBufferLimit = 0;
        }
    }

    // allocate buffer if necessary
    if(_dwBufferLimit)
    {
        _pBuffer = (BYTE *)ALLOCATE_FIXED_MEMORY(_dwBufferLimit);
        if(NULL == _pBuffer)
            return GetLastError();
    }

    // if we're reading, fill in buffer
    if(FALSE == _fWrite && _dwBufferLimit)
    {
        // read reg key
        DWORD dwSize = _dwBufferLimit;
        lRes = RegQueryValueEx(_hkey, pszValue, NULL, NULL, _pBuffer, &dwSize);
        if(lRes != ERROR_SUCCESS)
        {
            return lRes;
        }
    }

    // reset pointer to beginning of blob
    _dwOffset = 0;

    return 0;
}

DWORD
CRegBlob::Abandon(
    VOID
    )
{
    // don't commit changes when the time comes
    _fCommit = FALSE;

    return 0;
}

DWORD
CRegBlob::Commit(
    )
{
    long lres = 0;

    if(_fCommit && _fWrite && _pszValue && _pBuffer)
    {
        // save blob to reg key
        lres = RegSetValueEx(_hkey, _pszValue, 0, REG_BINARY, _pBuffer, _dwOffset);
    }

    return lres;
}


DWORD
CRegBlob::Encrpyt(
    )
{
    return 0;
}


DWORD
CRegBlob::Decrypt(
    )
{
    return 0;
}


DWORD
CRegBlob::WriteString(
    LPCSTR pszString
    )
{
    DWORD dwBytes, dwLen = 0;

    if(pszString)
    {
        dwLen = lstrlen(pszString);
    }

    dwBytes = WriteBytes(&dwLen, sizeof(DWORD));
    if(dwLen && dwBytes == sizeof(DWORD))
        dwBytes = WriteBytes(pszString, dwLen);

    return dwBytes;
}



DWORD
CRegBlob::ReadString(
    LPCSTR * ppszString
    )
{
    DWORD dwLen, dwBytes = 0;
    LPSTR lpszTemp = NULL;

    dwBytes = ReadBytes(&dwLen, sizeof(DWORD));
    if(dwBytes == sizeof(DWORD))
    {
        if(dwLen)
        {
            lpszTemp = (LPSTR)GlobalAlloc(GPTR, dwLen + 1);
            if(lpszTemp)
            {
                dwBytes = ReadBytes(lpszTemp, dwLen);
                lpszTemp[dwBytes] = 0;
            }
        }
    }

    *ppszString = lpszTemp;
    return dwBytes;
}


DWORD
CRegBlob::WriteBytes(
    LPCVOID pBytes,
    DWORD dwByteCount
    )
{
    BYTE * pNewBuffer;

    // can only do this on write blob
    if(FALSE == _fWrite)
        return 0;

    // grow buffer if necessary
    if(_dwBufferLimit - _dwOffset < dwByteCount)
    {
        DWORD dw = _dwBufferLimit + ((dwByteCount / BLOB_BUFF_GRANULARITY)+1)*BLOB_BUFF_GRANULARITY;
        pNewBuffer = (BYTE *)ALLOCATE_FIXED_MEMORY(dw);
        if(NULL == pNewBuffer)
        {
            // failed to get more memory
            return 0;
        }

        memset(pNewBuffer, 0, dw);
        memcpy(pNewBuffer, _pBuffer, _dwBufferLimit);
        FREE_FIXED_MEMORY(_pBuffer);
        _pBuffer = pNewBuffer;
        _dwBufferLimit = dw;
    }

    // copy callers data to buffer
    memcpy(_pBuffer + _dwOffset, pBytes, dwByteCount);
    _dwOffset += dwByteCount;

    // tell caller how much we wrote
    return dwByteCount;
}



DWORD
CRegBlob::ReadBytes(
    LPVOID pBytes,
    DWORD dwByteCount
    )
{
    DWORD   dwActual = _dwBufferLimit - _dwOffset;

    // can only do this on read blob
    if(_fWrite)
        return 0;

    // don't read past end of blob
    if(dwByteCount < dwActual)
        dwActual = dwByteCount;

    // copy bytes and increment offset
    if(dwActual > 0)
    {
        memcpy(pBytes, _pBuffer + _dwOffset, dwActual);
        _dwOffset += dwActual;
    }

    // tell caller how much we actually read
    return dwActual;
}


//
// Function Declarations
//


DWORD
LoadProxySettings()
/*
** Load global proxy info from registry.
** 
*/
{
    DWORD error;

    //
    // Get proxy struct for proxy object
    //
    INTERNET_PROXY_INFO_EX info;

    memset(&info, 0, sizeof(info));

    info.dwStructSize = sizeof(info);
    info.lpszConnectionName = NULL;

    //
    // Read LAN proxy settings and stuff them into the GlobalProxyInfo object.
    //
    error = ReadProxySettings(&info);

    if (error == ERROR_SUCCESS)
    {
        error = g_pGlobalProxyInfo->SetProxySettings(&info, FALSE);

        info.lpszConnectionName = NULL; // we don't allocate this field
        CleanProxyStruct(&info);
    }

    return error;
}



#define INTERNET_SETTINGS_KEY       "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings"

HKEY
FindBaseProxyKey(
    VOID
    )
/*
** Determine whether proxy settings live in HKLM or HKCU
**
** WinHttpX is hard-coded to always use HKEY_LOCAL_MACHINE
** 
*/

{
    return HKEY_LOCAL_MACHINE;
}


DWORD
ReadProxySettings(
    LPINTERNET_PROXY_INFO_EX pInfo
    )

{
    CRegBlob r(FALSE);
    LPCSTR  pszConnectionName;
    LPCSTR  pszSavedConnectionName;
    DWORD   error = ERROR_SUCCESS;
    long    lRes;
    DWORD   i;
    HKEY    hBaseKey;

    DEBUG_ENTER((DBG_DIALUP,
                 Dword,
                 "ReadProxySettings",
                 "%#x",
                 pInfo
                 ));

    // verify pInfo
    if(NULL == pInfo || pInfo->dwStructSize != sizeof(INTERNET_PROXY_INFO_EX))
    {
        DEBUG_LEAVE(ERROR_INVALID_PARAMETER);
        return ERROR_INVALID_PARAMETER;
    }

    // figure out connection name  (NULL == 'network')
    pszConnectionName = pInfo->lpszConnectionName;
    pszSavedConnectionName = pInfo->lpszConnectionName;
    if(NULL == pszConnectionName || 0 == *pszConnectionName)
    {
        pszConnectionName = "WinHttpSettings";
    }

    // figure out base key
    hBaseKey = FindBaseProxyKey();

    // initialize structure
    memset(pInfo, 0, sizeof(*pInfo));
    pInfo->dwStructSize = sizeof(*pInfo);
    pInfo->lpszConnectionName = pszSavedConnectionName;
    pInfo->dwFlags = PROXY_TYPE_DIRECT;

    // init blob
    lRes = r.Init(hBaseKey, szRegPathConnections, pszConnectionName);
    if(lRes)
    {
        error = (lRes == ERROR_FILE_NOT_FOUND) ? ERROR_SUCCESS : lRes;
        goto quit;
    }

    // read fields from blob
    if(0 == r.ReadBytes(&pInfo->dwStructSize, sizeof(DWORD)) ||
         (pInfo->dwStructSize < sizeof(*pInfo)))
    {
        // blob didn't exist or in correct format - set default values
        pInfo->dwStructSize = sizeof(*pInfo);
    }
    else
    {
        // read the rest of the blob
        r.ReadBytes(&pInfo->dwCurrentSettingsVersion, sizeof(DWORD));
        r.ReadBytes(&pInfo->dwFlags, sizeof(DWORD));
        r.ReadString(&pInfo->lpszProxy);
        r.ReadString(&pInfo->lpszProxyBypass);
    }

    //
    // WinHttpX does not support proxy autodection or autoconfig URL's,
    // so make sure those PROXY_TYPE flags are turned off.
    //
    pInfo->dwFlags &= ~(PROXY_TYPE_AUTO_DETECT | PROXY_TYPE_AUTO_PROXY_URL);


    DEBUG_PRINT(DIALUP, INFO, ("conn=%s, vers=%u, flag=%X, prox=%s, by=%s\n", 
                    pszConnectionName,
                    pInfo->dwCurrentSettingsVersion,
                    pInfo->dwFlags,
                    (pInfo->lpszProxy ? pInfo->lpszProxy : "<none>"),
                    (pInfo->lpszProxyBypass ? pInfo->lpszProxyBypass : "<none>")
                    ));

quit:
    DEBUG_LEAVE(error);
    return error;
}


void
CleanProxyStruct(
    LPINTERNET_PROXY_INFO_EX pInfo
    )

{
    if(pInfo->lpszConnectionName)             GlobalFree((LPSTR) pInfo->lpszConnectionName);
    if(pInfo->lpszProxy)                      GlobalFree((LPSTR) pInfo->lpszProxy);
    if(pInfo->lpszProxyBypass)                GlobalFree((LPSTR) pInfo->lpszProxyBypass);
    memset(pInfo, 0, sizeof(INTERNET_PROXY_INFO_EX));
    pInfo->dwFlags = PROXY_TYPE_DIRECT;
}


DWORD
SetPerConnOptions(
    HINTERNET hInternet,
    BOOL fIsAutoProxyThread,
    LPINTERNET_PER_CONN_OPTION_LISTA pList
    )
{
    INTERNET_PROXY_INFO_EX  info;
    DWORD   i, dwError = ERROR_SUCCESS;
    BOOL fCommit = FALSE;
    LPSTR   pszCopy, pszNew;

    INET_ASSERT(fIsAutoProxyThread == FALSE);

    INET_ASSERT(hInternet != NULL);

    memset(&info, 0, sizeof(info));
    info.dwStructSize = sizeof(info);

    // loop through option list and set members
    for(i=0; i<pList->dwOptionCount; i++)
    {
        pszNew = NULL;

        switch(pList->pOptions[i].dwOption)
        {        
        case INTERNET_PER_CONN_PROXY_SERVER:
        case INTERNET_PER_CONN_PROXY_BYPASS:
            // make a copy of the string passed in for these guys
            pszCopy = pList->pOptions[i].Value.pszValue;
            if(pszCopy)
            {
                pszNew = (LPSTR)GlobalAlloc(GPTR, lstrlen(pszCopy) + 1);
                if(pszNew)
                {
                    lstrcpy(pszNew, pszCopy);
                }
                else
                {
                    dwError = ERROR_NOT_ENOUGH_MEMORY;
                    pList->dwOptionError = i;
                }
            }
            break;
        }

        if(dwError)
        {
            fCommit = FALSE;
            break;
        }

        switch(pList->pOptions[i].dwOption)
        {
        case INTERNET_PER_CONN_FLAGS:
            info.dwFlags = pList->pOptions[i].Value.dwValue;
            fCommit = TRUE;
            break;
        case INTERNET_PER_CONN_PROXY_SERVER:
            if(info.lpszProxy)
                GlobalFree((LPSTR)info.lpszProxy);
            info.lpszProxy = pszNew;
            fCommit = TRUE;
            break;
        case INTERNET_PER_CONN_PROXY_BYPASS:
            if(info.lpszProxyBypass)
                GlobalFree((LPSTR)info.lpszProxyBypass);
            info.lpszProxyBypass = pszNew;
            fCommit = TRUE;
            break;
        case INTERNET_PER_CONN_AUTODISCOVERY_FLAGS:
        case INTERNET_PER_CONN_AUTOCONFIG_RELOAD_DELAY_MINS:
        case INTERNET_PER_CONN_AUTOCONFIG_URL:
        case INTERNET_PER_CONN_AUTOCONFIG_SECONDARY_URL:
        case INTERNET_PER_CONN_AUTOCONFIG_LAST_DETECT_TIME:
        case INTERNET_PER_CONN_AUTOCONFIG_LAST_DETECT_URL:
        default:
            dwError = ERROR_INVALID_PARAMETER;
            pList->dwOptionError = i;
            break;
        }

        if(dwError)
        {
            fCommit = FALSE;
            break;
        }
    }

    if (fCommit && hInternet)
    {
        g_pGlobalProxyInfo->SetProxySettings(&info, TRUE);
    }

    return dwError;
}



DWORD
QueryPerConnOptions(
    HINTERNET hInternet,
    BOOL fIsAutoProxyThread,
    LPINTERNET_PER_CONN_OPTION_LISTA pList
    )
{
    INTERNET_PROXY_INFO_EX  info;
    LPCSTR   pszCopy;
    LPSTR    pszNew;
    DWORD    i, dwError = ERROR_SUCCESS;
    BOOL     fFreeCopy = FALSE;

    pList->dwOptionError = 0;

    memset(&info, 0, sizeof(info));
    info.dwStructSize = sizeof(info);
    info.lpszConnectionName = pList->pszConnection;

    if ( hInternet == NULL ) 
    {
#ifndef WININET_SERVER_CORE
        if ( ! fIsAutoProxyThread ||                          
             ! g_pGlobalProxyInfo->GetAutoProxyThreadSettings(&info) ||
             ! IsConnectionMatch(info.lpszConnectionName, pList->pszConnection)) 
        { 
            CheckForUpgrade();
            ReadProxySettings(&info);
            fFreeCopy = TRUE;
        }
#endif //!WININET_SERVER_CORE
    }
    else 
    {
        g_pGlobalProxyInfo->GetProxySettings(&info, FALSE);
    }

    // loop through option list and fill in members
    for(i=0; i<pList->dwOptionCount; i++)
    {
        pList->pOptions[i].Value.pszValue = NULL;
        pszCopy = NULL;

        switch(pList->pOptions[i].dwOption)
        {
        case INTERNET_PER_CONN_FLAGS:
            pList->pOptions[i].Value.dwValue = info.dwFlags;
            break;
        case INTERNET_PER_CONN_PROXY_SERVER:
            pszCopy = info.lpszProxy;
            break;
        case INTERNET_PER_CONN_PROXY_BYPASS:
            pszCopy = info.lpszProxyBypass;
            break;
        default:
            dwError = ERROR_INVALID_PARAMETER;
            pList->dwOptionError = i;
            break;
        }

        // if this is a string value, make a copy of the string for the
        // caller
        if(pszCopy)
        {
            // make a copy of the string and stick it in the option
            pszNew = (LPSTR)GlobalAlloc(GPTR, lstrlen(pszCopy) + 1);
            if(pszNew)
            {
                lstrcpy(pszNew, pszCopy);
                pList->pOptions[i].Value.pszValue = pszNew;
            }
            else
            {
                dwError = ERROR_NOT_ENOUGH_MEMORY;
                pList->dwOptionError = i;
            }
        }

        if(dwError)
        {
            break;
        }
    }

    if (dwError)
    {
        // If an error has occurred, we should get rid of any strings that
        // we've allocated.
        for (i=0; i<pList->dwOptionError; i++)
        {
            switch(pList->pOptions[i].dwOption)
            {
            case INTERNET_PER_CONN_PROXY_SERVER:
            case INTERNET_PER_CONN_PROXY_BYPASS:
                if (pList->pOptions[i].Value.pszValue)
                {
                    GlobalFree(pList->pOptions[i].Value.pszValue);
                    pList->pOptions[i].Value.pszValue = NULL;
                }
                break;

            default:
                break;
            }
        }
    }

    if ( fFreeCopy ) {
        info.lpszConnectionName = NULL; // we don't allocate this field
        CleanProxyStruct(&info);
    }

    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\api\sendapi.cxx ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    sendapi.cxx

Abstract:

    This file contains the implementation of the HttpSendRequestA API.

    Contents:
        WinHttpSendRequest
        HttpSendRequestA
        WinHttpReceiveResponse
        HttpWrapSendRequest

Author:

    Keith Moore (keithmo) 16-Nov-1994

Revision History:

      29-Apr-97 rfirth
        Conversion to FSM

--*/

#include <wininetp.h>
#include <perfdiag.hxx>

//
// private prototypes
//

PRIVATE
BOOL
HttpWrapSendRequest(
    IN HINTERNET hRequest,
    IN LPCSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN LPVOID lpOptional OPTIONAL,
    IN DWORD dwOptionalLength,
    IN DWORD dwOptionalLengthTotal,
    IN AR_TYPE arRequest,
    IN DWORD_PTR dwContext=NULL
    );

//
// functions
//

INTERNETAPI
BOOL
WINAPI
HttpSendRequestA(
    IN HINTERNET hRequest,
    IN LPCSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN LPVOID lpOptional OPTIONAL,
    IN DWORD dwOptionalLength
    )

/*++

Routine Description:

    Sends the specified request to the HTTP server.

Arguments:

    hRequest                - An open HTTP request handle returned by
                              HttpOpenRequest()

    lpszHeaders             - Additional headers to be appended to the request.
                              This may be NULL if there are no additional
                              headers to append

    dwHeadersLength         - The length (in characters) of the additional
                              headers. If this is -1L and lpszAdditional is
                              non-NULL, then lpszAdditional is assumed to be
                              zero terminated (ASCIIZ)

    lpOptionalData          - Any optional data to send immediately after the
                              request headers. This is typically used for POST
                              operations. This may be NULL if there is no
                              optional data to send

    dwOptionalDataLength    - The length (in BYTEs) of the optional data. This
                              may be zero if there is no optional data to send

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. For more information call GetLastError(). If the
                  request was async, then GetLastError() will return
                  ERROR_IO_PENDING which means that the operation initially
                  succeeded, and that the caller should wait for the status
                  callback to discover the final success/failure status

--*/

{
    DEBUG_ENTER_API((DBG_API,
                Bool,
                "HttpSendRequestA",
                "%#x, %.80q, %d, %#x, %d",
                hRequest,
                lpszHeaders,
                dwHeadersLength,
                lpOptional,
                dwOptionalLength
                ));


    BOOL fRet= HttpWrapSendRequest(
                hRequest,
                lpszHeaders,
                dwHeadersLength,
                lpOptional,
                dwOptionalLength,
                0,
                AR_HTTP_SEND_REQUEST
                );


    DEBUG_LEAVE_API(fRet);

    return fRet;
}

INTERNETAPI
BOOL
WINAPI
WinHttpSendRequest(
    IN HINTERNET hRequest,
    IN LPCWSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN LPVOID lpOptional OPTIONAL,
    IN DWORD dwOptionalLength,
    IN DWORD dwTotalLength,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    Sends the specified request to the HTTP server.

Arguments:

    hRequest                - An open HTTP request handle returned by
                              HttpOpenRequest()

    lpszHeaders             - Additional headers to be appended to the request.
                              This may be NULL if there are no additional
                              headers to append

    dwHeadersLength         - The length (in characters) of the additional
                              headers. If this is -1L and lpszAdditional is
                              non-NULL, then lpszAdditional is assumed to be
                              zero terminated (ASCIIZ)

    lpOptionalData          - Any optional data to send immediately after the
                              request headers. This is typically used for POST
                              operations. This may be NULL if there is no
                              optional data to send

    dwOptionalDataLength    - The length (in BYTEs) of the optional data. This
                              may be zero if there is no optional data to send

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. For more information call GetLastError(). If the
                  request was async, then GetLastError() will return
                  ERROR_IO_PENDING which means that the operation initially
                  succeeded, and that the caller should wait for the status
                  callback to discover the final success/failure status

--*/

{
    DEBUG_ENTER_API((DBG_API,
                Bool,
                "WinHttpSendRequest",
                "%#x, %.80wq, %d, %#x, %d, %d, %x",
                hRequest,
                lpszHeaders,
                dwHeadersLength,
                lpOptional,
                dwOptionalLength,
                dwTotalLength,
                dwContext
                ));

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;
    MEMORYPACKET mpHeaders;

    if (!hRequest)
    {
        dwErr = ERROR_INVALID_HANDLE;
        goto cleanup;
    }

    if (lpszHeaders && IsBadReadPtr(lpszHeaders, 1))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    if (dwHeadersLength == -1L)
    {
        dwHeadersLength = lpszHeaders ? lstrlenW(lpszHeaders) : 0;
    }

    if (lpszHeaders)
    {
        if ((dwHeadersLength == -1)
            ? IsBadStringPtrW(lpszHeaders, -1)
            : IsBadReadPtr(lpszHeaders, dwHeadersLength))
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
        ALLOC_MB(lpszHeaders, dwHeadersLength, mpHeaders);
        if (!mpHeaders.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(lpszHeaders, mpHeaders);
    }
    if (lpOptional 
        && dwOptionalLength
        && IsBadReadPtr(lpOptional, dwOptionalLength) )
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
            
    AR_TYPE ar;
    
    // Always require a WinHttpReceiveResponse to initiate
    // FSM_STATE_4 onwards in HTTP_REQUEST_HANDLE_OBJECT::HttpSendRequest_Start:
    if (dwOptionalLength <= dwTotalLength)
    {
        ar = AR_HTTP_BEGIN_SEND_REQUEST;
    }
    else
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    
    fResult = HttpWrapSendRequest(hRequest, mpHeaders.psStr, mpHeaders.dwSize,
                lpOptional, dwOptionalLength, dwTotalLength, ar, dwContext);
    // This calls SetLastError if fResult is FALSE.
    
cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(HTTP, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


INTERNETAPI
BOOL
WINAPI
WinHttpReceiveResponse(
    IN HINTERNET hRequest,
    IN LPVOID lpBuffersOut OPTIONAL
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    hRequest        -
    lpBuffersOut    -
    dwFlags         -
    dwContext       -

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "WinHttpReceiveResponse",
                     "%#x, %#x",
                     hRequest,
                     lpBuffersOut
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;

    if (!hRequest)
    {
        dwErr = ERROR_INVALID_HANDLE;
    }
    else if (lpBuffersOut)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        fResult = HttpWrapSendRequest(hRequest, NULL, 0, NULL, 0, 0, AR_HTTP_END_SEND_REQUEST);
    }
    
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(HTTP, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


PRIVATE
BOOL
HttpWrapSendRequest(
    IN HINTERNET hRequest,
    IN LPCSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN LPVOID lpOptional OPTIONAL,
    IN DWORD dwOptionalLength,
    IN DWORD dwOptionalLengthTotal,
    IN AR_TYPE arRequest,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    Sends the specified request to the HTTP server.

Arguments:

    hRequest                - An open HTTP request handle returned by
                              HttpOpenRequest()

    lpszHeaders             - Additional headers to be appended to the request.
                              This may be NULL if there are no additional
                              headers to append

    dwHeadersLength         - The length (in characters) of the additional
                              headers. If this is -1L and lpszAdditional is
                              non-NULL, then lpszAdditional is assumed to be
                              zero terminated (ASCIIZ)

    lpOptionalData          - Any optional data to send immediately after the
                              request headers. This is typically used for POST
                              operations. This may be NULL if there is no
                              optional data to send

    dwOptionalDataLength    - The length (in BYTEs) of the optional data. This
                              may be zero if there is no optional data to send

    dwOptionalLengthTotal   - Total length need to be sent for File Upload.

    arRequest               - Which API the caller is making,
                                assumed to be HttpEndRequestA, HttpSendRequestExA, or
                                HttpSendRequestA

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. For more information call GetLastError(). If the
                  request was async, then GetLastError() will return
                  ERROR_IO_PENDING which means that the operation initially
                  succeeded, and that the caller should wait for the status
                  callback to discover the final success/failure status

Comments:

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Bool,
                 "HttpWrapSendRequest",
                 "%#x, %.80q, %d, %#x, %d, %d, %x",
                 hRequest,
                 lpszHeaders,
                 dwHeadersLength,
                 lpOptional,
                 dwOptionalLength,
                 dwOptionalLengthTotal,
                 dwContext
                 ));

    PERF_ENTER(HttpWrapSendRequest);

    DWORD error = ERROR_SUCCESS;
    HINTERNET hRequestMapped = NULL;
    BOOL bDeref = TRUE;

    if (!GlobalDataInitialized) {
        error = ERROR_WINHTTP_NOT_INITIALIZED;
        goto done;
    }

    //
    // we will need the thread info for several items
    //

    LPINTERNET_THREAD_INFO lpThreadInfo;

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto done;
    }

    //
    // the only FSMs that can come before this one are InternetOpenUrl() or
    // HttpSendRequest() when we are performing nested send for https://
    // tunnelling through proxy
    //

    INET_ASSERT((lpThreadInfo->Fsm == NULL)
                || (lpThreadInfo->Fsm->GetType() == FSM_TYPE_PARSE_HTTP_URL)
                || (lpThreadInfo->Fsm->GetType() == FSM_TYPE_OPEN_PROXY_TUNNEL)
                );

    INET_ASSERT( arRequest == AR_HTTP_SEND_REQUEST ||
                 arRequest == AR_HTTP_BEGIN_SEND_REQUEST ||
                 arRequest == AR_HTTP_END_SEND_REQUEST );


    //
    // map the handle
    //
    error = MapHandleToAddress(hRequest, (LPVOID *)&hRequestMapped, FALSE);


    if ((error != ERROR_SUCCESS) && (hRequestMapped == NULL)) {
        goto quit;
    }

    //
    // Cast it to the object that we know. We are going to do caching
    // semantics with this
    //

    HTTP_REQUEST_HANDLE_OBJECT * pRequest;

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)hRequestMapped;

    //
    // set the context and handle info & reset the error variables,
    // but only if not for a ReceiveResponse call.
    //
    if (arRequest != AR_HTTP_END_SEND_REQUEST)
    {
        pRequest->SetContext(dwContext);
        INET_ASSERT( (INTERNET_CONNECT_HANDLE_OBJECT *)pRequest->GetParent() );

        ((INTERNET_CONNECT_HANDLE_OBJECT *)pRequest->GetParent())->SetContext(dwContext);

        // We need this information to special-case for Redirects and Auth because of RR FSM changes:
        pRequest->SetWriteRequired(dwOptionalLength < dwOptionalLengthTotal);
    }
    _InternetSetObjectHandle(lpThreadInfo, hRequest, hRequestMapped);
    _InternetClearLastError(lpThreadInfo);

    //
    // quit now if the handle was invalid
    //

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // use RIsHandleLocal() to discover 4 things:
    //
    //  1. Handle is valid
    //  2. Handle is of expected type (HTTP Request in this case)
    //  3. Handle is local or remote
    //  4. Handle supports async I/O
    //

    BOOL isLocal;
    BOOL isAsync;

    error = RIsHandleLocal(hRequestMapped,
                           &isLocal,
                           &isAsync,
                           TypeHttpRequestHandle
                           );

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    if (isAsync)
    {
        error = InitializeAsyncSupport();
        if (error != ERROR_SUCCESS)
        {
            goto quit;
        }
    }
    //
    // For SEND_REQUEST, and BEGIN_SEND_REQUEST, we need
    //  to do some basic initalization
    //

    if ( arRequest == AR_HTTP_SEND_REQUEST ||
         arRequest == AR_HTTP_BEGIN_SEND_REQUEST)
    {
        error = pRequest->InitBeginSendRequest(lpszHeaders,
                                       dwHeadersLength,
                                       &lpOptional,
                                       &dwOptionalLength,
                                       dwOptionalLengthTotal
                                       );

        if ( error != ERROR_SUCCESS)
        {
            goto quit;
        }

        // (Re)set flag to indicate WinHttpReceiveResponse needs to be called.
        pRequest->SetReceiveResponseState(FALSE);

        // ReceiveResponse FSM won't be exec'ed/queued until the client calls
        // WinHttpReceiveResponse to mark the end of writing additional data.
        pRequest->SetWriteDataNeeded(
                arRequest == AR_HTTP_BEGIN_SEND_REQUEST ? TRUE : FALSE);
    }
    else if (arRequest == AR_HTTP_END_SEND_REQUEST)
    {
        pRequest->SetReceiveResponseState(TRUE);

        // Previously this would be a case where WinHttpReceiveResponse did
        // not need to be called.  Now, in this case, simply return whether or
        // not we've reached the object data state.
        if (!pRequest->CheckWriteDataNeeded())
        {
            // Nothing needs to be queued, so let the original send request fsm
            // complete, if needed, and indicate the current state.
            if (!isAsync ||
                    ((pRequest->GetState() & 0x0F) >=
                     (HttpRequestStateObjectData & 0x0F)))
            {  
                error = ERROR_SUCCESS;
                goto quit;
            }
            else
            {
                // Async sendrequest is still pending, so there's no need to
                // create another fsm.  This call isn't async, so leave deref
                // set to TRUE.
                error = ERROR_IO_PENDING;
                goto quit;
            }
        }
    }


    //
    // send the request to the server. This may involve redirections and user
    // authentication
    //

    //error = DoFsm(New CFsm_HttpSendRequest(lpOptional, dwOptionalLength, pRequest, arRequest));
    //if (error == ERROR_IO_PENDING) {
    //    bDeref = FALSE;
    //}
    CFsm_HttpSendRequest * pFsm;

    pFsm = New CFsm_HttpSendRequest(lpOptional, dwOptionalLength, pRequest, arRequest);

    if (pFsm != NULL)
    {
        if (isAsync && !lpThreadInfo->IsAsyncWorkerThread)
        {
            error = DoAsyncFsm(pFsm, pRequest);
        }
        else
        {
            pFsm->SetPushPop(TRUE);
            pFsm->Push();
            error = DoFsm(pFsm);
        }
        if (error == ERROR_IO_PENDING)
        {
            bDeref = FALSE;
        }
    }
    else
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
    }

quit:

    //
    // if we went async don't deref the handle
    //

    if (bDeref && (hRequestMapped != NULL)) {
        DereferenceObject((LPVOID)hRequestMapped);
    }

done:

    BOOL success = TRUE;

    // SetLastError must be called after PERF_LEAVE !!!
    PERF_LEAVE(HttpWrapSendRequest);

    if (error != ERROR_SUCCESS) {

        SetLastError(error);
        DEBUG_ERROR(HTTP, error);
        success = FALSE;
    }

    DEBUG_LEAVE(success);
    return success;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\auth\auth.h ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    auth.h

Abstract:

    Private include file for 

Author:

    Rajeev Dujari (rajeevd) 28-Jul-97
    
Revision History:

--*/

//
// manifests
//
 
#define HTTP_AUTHORIZATION_SZ           "Authorization:"
#define HTTP_AUTHORIZATION_LEN          (sizeof(HTTP_AUTHORIZATION_SZ)-1)

#define HTTP_PROXY_AUTHORIZATION_SZ     "Proxy-Authorization:"
#define HTTP_PROXY_AUTHORIZATION_LEN    (sizeof(HTTP_PROXY_AUTHORIZATION_SZ)-1)


//
// prototypes - versions of spluginx.hxx for basic auth
//


void UrlZonesDetach (void);

//#ifdef __cplusplus
//extern "C" {
//#endif

extern DWORD g_cSspiContexts; // refcount of sspi contexts

DWORD SSPI_Unload();

DWORD_PTR SSPI_InitScheme (LPCSTR pszScheme);

//#ifdef __cplusplus
//} // end extern "C" {
//#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\api\options.cxx ===
/*++

Copyright (c) 1994-98  Microsoft Corporation

Module Name:

    options.cxx

Abstract:

    Contains the Internet*Option APIs

    Contents:
        InternetQueryOptionA
        InternetSetOptionA
        WinHttpQueryOption
        WinHttpSetOption
        (FValidCacheHandleType)

Author:

    Richard L Firth (rfirth) 02-Mar-1995

Environment:

    Win32 user-mode DLL

Revision History:

    02-Mar-1995 rfirth
        Created

    07-Mar-1995 madana

    07-Jul-1998 Forked by akabir

--*/

#include <wininetp.h>
#include <perfdiag.hxx>
#include "msident.h"

//
// private macros
//

//
// IS_PER_THREAD_OPTION - options applicable to the thread (HINTERNET is NULL).
// Subset of IS_VALID_OPTION()
//

#define IS_PER_THREAD_OPTION(option) ((                     \
       ((option) == WINHTTP_OPTION_EXTENDED_ERROR)         \
    || ((option) == WINHTTP_OPTION_PER_CONNECTION_OPTION)  \
    ) ? TRUE : FALSE)

//
// IS_PER_PROCESS_OPTION - options applicable to the process (HINTERNET is NULL).
// Subset of IS_VALID_OPTION()
//

#define IS_PER_PROCESS_OPTION(option)                       \
    (( ((option) == WINHTTP_OPTION_GET_DEBUG_INFO)         \
    || ((option) == WINHTTP_OPTION_SET_DEBUG_INFO)         \
    || ((option) == WINHTTP_OPTION_GET_HANDLE_COUNT)       \
    || ((option) == WINHTTP_OPTION_PROXY)                  \
    || ((option) == WINHTTP_OPTION_VERSION)                \
    || ((option) == WINHTTP_OPTION_HTTP_VERSION)           \
    || ((option) == WINHTTP_OPTION_DIGEST_AUTH_UNLOAD)    \
    || ((option) == WINHTTP_OPTION_PER_CONNECTION_OPTION)  \
    || ((option) == WINHTTP_OPTION_WORKER_THREAD_COUNT) \
    ) ? TRUE : FALSE)

//
// IS_DEBUG_OPTION - the set of debug-specific options
//

#define IS_DEBUG_OPTION(option)                     \
    (( ((option) >= INTERNET_FIRST_DEBUG_OPTION)    \
    && ((option) <= INTERNET_LAST_DEBUG_OPTION)     \
    ) ? TRUE : FALSE)

//
// IS_VALID_OPTION - the set of known option values, for a HINTERNET, thread, or
// process. In the retail version, debug options are invalid
//

#if INET_DEBUG

#define IS_VALID_OPTION(option)             \
    (((((option) >= WINHTTP_FIRST_OPTION)  \
    && ((option) <= WINHTTP_LAST_OPTION_INTERNAL))  \
    || IS_DEBUG_OPTION(option)              \
    ) ? TRUE : FALSE)

#else

#define IS_VALID_OPTION(option)             \
    (((((option) >= WINHTTP_FIRST_OPTION)  \
    && ((option) <= WINHTTP_LAST_OPTION_INTERNAL))  \
    ) ? TRUE : FALSE)

#endif // INET_DEBUG

//
// private prototypes
//
PRIVATE
BOOL
FValidCacheHandleType(
    HINTERNET_HANDLE_TYPE   hType
    );

PRIVATE
VOID
InitIPCOList(LPINTERNET_PER_CONN_OPTION_LISTW plistW, LPINTERNET_PER_CONN_OPTION_LISTA plistA)
{
    plistA->dwSize = sizeof(INTERNET_PER_CONN_OPTION_LISTA);
    plistA->dwOptionCount = plistW->dwOptionCount;
    if (plistW->pszConnection && *plistW->pszConnection)
    {
        SHUnicodeToAnsi(plistW->pszConnection, plistA->pszConnection, RAS_MaxEntryName + 1);
    }
    else
    {
        plistA->pszConnection = NULL;
    }
}

//
// functions
//


INTERNETAPI
BOOL
WINAPI
InternetQueryOptionA(
    IN HINTERNET hInternet OPTIONAL,
    IN DWORD dwOption,
    OUT LPVOID lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    Returns information about various handle-specific variables

Arguments:

    hInternet           - handle of object for which information will be
                          returned

    dwOption            - the handle-specific WINHTTP_OPTION to query

    lpBuffer            - pointer to a buffer which will receive results

    lpdwBufferLength    - IN: number of bytes available in lpBuffer
                          OUT: number of bytes returned in lpBuffer

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info:
                    ERROR_INVALID_HANDLE
                        hInternet does not identify a valid Internet handle
                        object

                    ERROR_WINHTTP_INTERNAL_ERROR
                        Shouldn't see this?

                    ERROR_INVALID_PARAMETER
                        One of the parameters was bad

                    ERROR_INSUFFICIENT_BUFFER
                        lpBuffer is not large enough to hold the requested
                        information; *lpdwBufferLength contains the number of
                        bytes needed

                    ERROR_WINHTTP_INCORRECT_HANDLE_TYPE
                        The handle is the wrong type for the requested option

                    ERROR_WINHTTP_INVALID_OPTION
                        The option is unrecognized

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetQueryOptionA",
                     "%#x, %s (%d), %#x, %#x [%d]",
                     hInternet,
                     InternetMapOption(dwOption),
                     dwOption,
                     lpBuffer,
                     lpdwBufferLength,
                     lpdwBufferLength
                        ? (!IsBadReadPtr(lpdwBufferLength, sizeof(DWORD))
                            ? *lpdwBufferLength
                            : 0)
                        : 0
                     ));

    DWORD error;
    BOOL success;
    HINTERNET_HANDLE_TYPE handleType;
    LPINTERNET_THREAD_INFO lpThreadInfo;
    DWORD requiredSize = 0;
    LPVOID lpSource;
    DWORD dwValue;
    DWORD_PTR dwPtrValue;
    HANDLE hValue;
    HINTERNET hObjectMapped = NULL;
    BOOL isString = FALSE;
    INTERNET_DIAGNOSTIC_SOCKET_INFO socketInfo;

    if (!GlobalDataInitialized) {
        error = GlobalDataInitialize();
        if (error != ERROR_SUCCESS) {
            goto done;
        }
    }

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto done;
    }

    //
    // validate parameters
    //

    INET_ASSERT(lpdwBufferLength);

    if (!ARGUMENT_PRESENT(lpBuffer)) {
        *lpdwBufferLength = 0;
    }

    //
    // validate the handle and get its type
    //

    HINTERNET hOriginal;

    hOriginal = hInternet;
    if (ARGUMENT_PRESENT(hInternet)) {

        //
        // map the handle
        //

        error = MapHandleToAddress(hInternet, (LPVOID *)&hObjectMapped, FALSE);
        if (error == ERROR_SUCCESS) {
            hInternet = hObjectMapped;
            error = RGetHandleType(hInternet, &handleType);
        }
    } else if (IS_PER_THREAD_OPTION(dwOption)) {

        //
        // this option updates the per-thread information block, so this is a
        // good point at which to get it
        //

        if (lpThreadInfo != NULL) {
            error = ERROR_SUCCESS;
        } else {

            DEBUG_PRINT(INET,
                        ERROR,
                        ("InternetGetThreadInfo() returns NULL\n"
                        ));

            //
            // we never expect this - ERROR_WINHTTP_SPANISH_INQUISITION
            //

            INET_ASSERT(FALSE);

            error = ERROR_WINHTTP_INTERNAL_ERROR;
        }
    } else if (IS_PER_PROCESS_OPTION(dwOption)) {
        error = ERROR_SUCCESS;
    } else {

        //
        // catch any invalid options for the NULL handle. If the option is valid
        // then it is incorrect for this handle type, otherwise its an invalid
        // option, period
        //

        error = IS_VALID_OPTION(dwOption)
                    ? ERROR_WINHTTP_INCORRECT_HANDLE_TYPE
                    : ERROR_WINHTTP_INVALID_OPTION
                    ;
    }

    //
    // if the option and handle combination is valid then query the option value
    //

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    HTTP_REQUEST_HANDLE_OBJECT* pReq;

    switch (handleType)
    {
        case TypeHttpRequestHandle:
            pReq = (HTTP_REQUEST_HANDLE_OBJECT*) hInternet;
            break;

        case TypeInternetHandle:
            pReq = NULL;
            break;

        default:
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;           
            goto quit;
    }
   
   
    // New fast path for request handle options.

    if (dwOption > WINHTTP_OPTION_MASK)
    {
        dwOption &= WINHTTP_OPTION_MASK;
        if (dwOption > MAX_INTERNET_STRING_OPTION)
            error = ERROR_INVALID_PARAMETER;
        else if (!pReq)
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        else
        {
            lpSource = pReq->GetProp (dwOption);
            isString = TRUE;
            error = ERROR_SUCCESS;
        }
        goto quit;
    }

    switch (dwOption) {
    case WINHTTP_OPTION_CALLBACK:
        requiredSize = sizeof(WINHTTP_STATUS_CALLBACK);
        if (hInternet != NULL) {
            error = RGetStatusCallback(hInternet,
                                       (LPWINHTTP_STATUS_CALLBACK)&dwValue
                                       );
            lpSource = (LPVOID)&dwValue;
        } else {
            error = ERROR_INVALID_HANDLE;
        }
        break;

    case WINHTTP_OPTION_RESOLVE_TIMEOUT:
    case WINHTTP_OPTION_CONNECT_TIMEOUT:
    case WINHTTP_OPTION_CONNECT_RETRIES:
    case WINHTTP_OPTION_SEND_TIMEOUT:
    case WINHTTP_OPTION_RECEIVE_TIMEOUT:
        requiredSize = sizeof(DWORD);

        //
        // remember hInternet in the INTERNET_THREAD_INFO then call
        // GetTimeoutValue(). If hInternet refers to a valid Internet
        // object handle, then the relevant timeout value will be
        // returned from that, else we will return the global value
        // corresponding to the requested option
        //

        InternetSetObjectHandle(hOriginal, hInternet);
        dwValue = GetTimeoutValue(dwOption);
        lpSource = (LPVOID)&dwValue;
        break;

    case WINHTTP_OPTION_HANDLE_TYPE:

        requiredSize = sizeof(dwValue);
        switch (handleType)
        {
        case TypeInternetHandle:
            dwValue = WINHTTP_HANDLE_TYPE_SESSION;
            break;

        case TypeHttpConnectHandle:
            dwValue = WINHTTP_HANDLE_TYPE_CONNECT;
            break;

        case TypeHttpRequestHandle:
            dwValue = WINHTTP_HANDLE_TYPE_REQUEST;
            break;

        default:
            error = ERROR_WINHTTP_INTERNAL_ERROR;
            break;
        }
        lpSource = (LPVOID)&dwValue;
        break;

    case WINHTTP_OPTION_CONTEXT_VALUE:
        requiredSize = sizeof(DWORD_PTR);
        error = RGetContext(hInternet, &dwPtrValue);
        lpSource = (LPVOID)&dwPtrValue;
        break;

    case WINHTTP_OPTION_READ_BUFFER_SIZE:
    case WINHTTP_OPTION_WRITE_BUFFER_SIZE:
    
        if (pReq)
        {
            requiredSize = sizeof(DWORD);
            error = ERROR_SUCCESS;
            dwValue = pReq->GetBufferSize(dwOption);
            lpSource = (LPVOID)&dwValue;
        }
        else
        {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        break;

    case WINHTTP_OPTION_PARENT_HANDLE:
        hInternet = ((HANDLE_OBJECT *)hInternet)->GetParent();
        if (hInternet != NULL) {
            hInternet = ((HANDLE_OBJECT *)hInternet)->GetPseudoHandle();
        }
        requiredSize = sizeof(hInternet);
        lpSource = (LPVOID)&hInternet;
        break;

    case WINHTTP_OPTION_EXTENDED_ERROR:
        requiredSize = sizeof(lpThreadInfo->dwMappedErrorCode);
        lpSource = (LPVOID)&lpThreadInfo->dwMappedErrorCode;
        break;
    
    case WINHTTP_OPTION_SECURITY_FLAGS:

        if (handleType != TypeHttpRequestHandle)
        {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        else
        {
            HTTP_REQUEST_HANDLE_OBJECT *lphHttpRqst;

            requiredSize = sizeof(dwValue);
            dwValue = 0;
            lpSource = (LPVOID)&dwValue;

            lphHttpRqst = (HTTP_REQUEST_HANDLE_OBJECT *) hInternet;

            dwValue = lphHttpRqst->GetSecureFlags();

            DEBUG_PRINT(INET,
                        INFO,
                        ("SECURITY_FLAGS: %X\n",
                        dwValue
                        ));


            error = ERROR_SUCCESS;
        }

        break;

   
    case WINHTTP_OPTION_URL:

        //
        // return the URL associated with the request handle. This may be
        // different from the original URL due to redirections
        //

        if (pReq)
        {

            //
            // only these handle types (retrieved object handles) can have
            // associated URLs
            //

            lpSource = pReq->GetURL();
            isString = TRUE;

            INET_ASSERT(error == ERROR_SUCCESS);

        }
        else
        {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        break;


    case WINHTTP_OPTION_SECURITY_CONNECTION_INFO:
        //
        // Caller is expected to pass in an INTERNET_SECURITY_CONNECTION_INFO structure.

        if (handleType != TypeHttpRequestHandle) {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        } else if (*lpdwBufferLength < (DWORD)sizeof(INTERNET_SECURITY_CONNECTION_INFO)) {
            requiredSize = sizeof(INTERNET_SECURITY_CONNECTION_INFO);
            *lpdwBufferLength = requiredSize;
            error = ERROR_INSUFFICIENT_BUFFER;
        } else {
            HTTP_REQUEST_HANDLE_OBJECT *lphHttpRqst;
            LPINTERNET_SECURITY_CONNECTION_INFO lpSecConnInfo;
            INTERNET_SECURITY_INFO ciInfo;

            lphHttpRqst = (HTTP_REQUEST_HANDLE_OBJECT *)hInternet;
            lpSecConnInfo = (LPINTERNET_SECURITY_CONNECTION_INFO)lpBuffer;
            requiredSize = sizeof(INTERNET_SECURITY_CONNECTION_INFO);

            if ((error = lphHttpRqst->GetSecurityInfo(&ciInfo)) == ERROR_SUCCESS) {
                // Set up that data members in the structure passed in.
                lpSecConnInfo->fSecure = TRUE;

                lpSecConnInfo->dwProtocol = ciInfo.dwProtocol;
                lpSecConnInfo->aiCipher = ciInfo.aiCipher;
                lpSecConnInfo->dwCipherStrength = ciInfo.dwCipherStrength;
                lpSecConnInfo->aiHash = ciInfo.aiHash;
                lpSecConnInfo->dwHashStrength = ciInfo.dwHashStrength;
                lpSecConnInfo->aiExch = ciInfo.aiExch;
                lpSecConnInfo->dwExchStrength = ciInfo.dwExchStrength;

                if (ciInfo.pCertificate)
                {
                    WRAP_REVERT_USER_VOID(CertFreeCertificateContext, (ciInfo.pCertificate));
                }

            } else if (error == ERROR_WINHTTP_INTERNAL_ERROR)  {
                // This implies we are not secure.
                error = ERROR_SUCCESS;
                lpSecConnInfo->fSecure = FALSE;
            }

            lpSecConnInfo->dwSize = requiredSize;
            *lpdwBufferLength = requiredSize;
        }

        goto quit;


    case WINHTTP_OPTION_SECURITY_CERTIFICATE_STRUCT:

        //
        // Allocates memory that caller is expected to free.
        //

        if (handleType != TypeHttpRequestHandle) {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        } else {
            LPTSTR szResult = NULL;
            DWORD cchNeedLen = 0;
            HTTP_REQUEST_HANDLE_OBJECT *lphHttpRqst;
            INTERNET_SECURITY_INFO cInfo;
            lphHttpRqst = (HTTP_REQUEST_HANDLE_OBJECT *) hInternet;
            requiredSize = sizeof(INTERNET_CERTIFICATE_INFO);

            if (ERROR_SUCCESS == lphHttpRqst->GetSecurityInfo(&cInfo))
            {
                error = ConvertSecurityInfoIntoCertInfoStruct(&cInfo, (LPINTERNET_CERTIFICATE_INFO)lpBuffer, lpdwBufferLength);
                if(cInfo.pCertificate)
                {
                    WRAP_REVERT_USER_VOID(CertFreeCertificateContext, (cInfo.pCertificate));
                }
                goto quit;
            }
            else
            {
                error = ERROR_INVALID_OPERATION;
            }
        }
        break;

    case WINHTTP_OPTION_SERVER_CERT_CONTEXT:
        if (handleType != TypeHttpRequestHandle)
        {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        else
        {
            HTTP_REQUEST_HANDLE_OBJECT *lphHttpRqst;
            INTERNET_SECURITY_INFO cInfo;
            lphHttpRqst = (HTTP_REQUEST_HANDLE_OBJECT *) hInternet;
            requiredSize = sizeof(PCERT_CONTEXT);

            if (lpBuffer)
            {
                if (ERROR_SUCCESS == lphHttpRqst->GetSecurityInfo(&cInfo))
                {
                    // GetSecurityInfo calls CertDuplicateCertificateContext, so
                    // the client app should call CertFreeCertificateContext when
                    // finished in order to maintain the proper ref count.
                    *((PCCERT_CONTEXT *) lpBuffer) = cInfo.pCertificate;  
                }
                else
                {
                    error = ERROR_INVALID_OPERATION;
                }
            }
        }
        
    case WINHTTP_OPTION_SECURITY_KEY_BITNESS:

        if (handleType != TypeHttpRequestHandle)
        {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        else
        {
            HTTP_REQUEST_HANDLE_OBJECT *lphHttpRqst;
            INTERNET_SECURITY_INFO secInfo;

            requiredSize = sizeof(dwValue);
            dwValue = 0;
            lpSource = (LPVOID)&dwValue;

            lphHttpRqst = (HTTP_REQUEST_HANDLE_OBJECT *) hInternet;
            if (ERROR_SUCCESS != lphHttpRqst->GetSecurityInfo(&secInfo)) {
                error = ERROR_INVALID_OPERATION;
            } else {
                dwValue = secInfo.dwCipherStrength;
                WRAP_REVERT_USER_VOID(CertFreeCertificateContext,
                                      (secInfo.pCertificate));

                INET_ASSERT (error == ERROR_SUCCESS);

                DEBUG_PRINT(INET,
                            INFO,
                            ("SECURITY_KEY_BITNESS: %X\n",
                            dwValue
                            ));

            }
        }

        break;


    case WINHTTP_OPTION_PROXY:
        if (!ARGUMENT_PRESENT(hInternet)) {

            error = g_pGlobalProxyInfo->GetProxyStringInfo(lpBuffer, lpdwBufferLength);
            requiredSize = *lpdwBufferLength;
            goto quit;

        } else if ((handleType == TypeInternetHandle) || (handleType == TypeHttpRequestHandle)) {

            //
            // GetProxyInfo() will return the data, or calculate the buffer
            // length required
            //

            error = ((INTERNET_HANDLE_BASE *)hInternet)->GetProxyStringInfo(
                lpBuffer,
                lpdwBufferLength
                );
            requiredSize = *lpdwBufferLength;
            goto quit;
        } else {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        break;

    case WINHTTP_OPTION_VERSION:
        requiredSize = sizeof(InternetVersionInfo);
        lpSource = (LPVOID)&InternetVersionInfo;
        break;

    case WINHTTP_OPTION_USER_AGENT:
        if (handleType == TypeInternetHandle) {
            lpSource = ((INTERNET_HANDLE_OBJECT *)hInternet)->GetUserAgent();
            isString = TRUE;
        } else {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        break;

    case WINHTTP_OPTION_REQUEST_PRIORITY:
        if (handleType == TypeHttpRequestHandle) {
            requiredSize = sizeof(dwValue);
            dwValue = ((HTTP_REQUEST_HANDLE_OBJECT *)hInternet)->GetPriority();
            lpSource = (LPVOID)&dwValue;
        } else {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        break;

    case WINHTTP_OPTION_HTTP_VERSION:
        requiredSize = sizeof(HttpVersionInfo);
        lpSource = (LPVOID)&HttpVersionInfo;
        break;

    case WINHTTP_OPTION_DIAGNOSTIC_SOCKET_INFO:

        //
        // internal option
        //

        if (pReq) {
            requiredSize = sizeof(socketInfo);
            lpSource = (LPVOID)&socketInfo;

            socketInfo.Socket = pReq->GetSocket();
            socketInfo.SourcePort = pReq->GetSourcePort();
            socketInfo.DestPort = pReq->GetDestPort();
            socketInfo.Flags = (pReq->FromKeepAlivePool()
                                    ? IDSI_FLAG_KEEP_ALIVE : 0)
                                | (pReq->IsSecure()
                                    ? IDSI_FLAG_SECURE : 0)
                                | (pReq->IsRequestUsingProxy()
                                    ? IDSI_FLAG_PROXY : 0)
                                | (pReq->IsTunnel()
                                    ? IDSI_FLAG_TUNNEL : 0);
        } else {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        break;

    case WINHTTP_OPTION_MAX_CONNS_PER_SERVER:
    case WINHTTP_OPTION_MAX_CONNS_PER_1_0_SERVER:
        if (hInternet)
        {
            if (handleType == TypeInternetHandle)
            {
                requiredSize = sizeof(dwValue);
                dwValue = 0;
                lpSource = (LPVOID)&dwValue;
                dwValue = ((INTERNET_HANDLE_OBJECT *)hInternet)->GetMaxConnectionsPerServer(dwOption);
            }
            else
                error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        else
            error = ERROR_INVALID_OPERATION;
        break;

    case WINHTTP_OPTION_PER_CONNECTION_OPTION:
        {
            if (handleType != TypeInternetHandle) {
                hInternet = NULL;
            }

            error = QueryPerConnOptions(hInternet,
                                        FALSE,
                                        (LPINTERNET_PER_CONN_OPTION_LIST)lpBuffer);

            requiredSize = *lpdwBufferLength;
            goto quit;
        }

    case WINHTTP_OPTION_WORKER_THREAD_COUNT:
        
        requiredSize = sizeof(DWORD);
        dwValue = g_cNumIOCPThreads;
        lpSource = (LPVOID)&dwValue;
        break;
        
#if INET_DEBUG

    case WINHTTP_OPTION_GET_DEBUG_INFO:
        error = InternetGetDebugInfo((LPINTERNET_DEBUG_INFO)lpBuffer,
                                     lpdwBufferLength
                                     );

        //
        // everything updated, so quit without going through common buffer
        // processing
        //

        goto quit;
        break;

    case WINHTTP_OPTION_GET_HANDLE_COUNT:
        requiredSize = sizeof(DWORD);
        dwValue = InternetHandleCount();
        lpSource = (LPVOID)&dwValue;
        break;

#endif // INET_DEBUG

    default:
        requiredSize = 0;
        error = ERROR_INVALID_PARAMETER;
        break;
    }

    //
    // if we have a buffer and enough space, then copy the data
    //

    if (error == ERROR_SUCCESS) {

        //
        // if we are returning a string, calculate the amount of space
        // required to hold it
        //

        if (isString) {
            if (lpSource != NULL) {
                requiredSize = lstrlen((LPCSTR)lpSource) + 1;
            } else {

                //
                // option string is NULL: return an empty string
                //

                lpSource = "";
                requiredSize = 1;
            }
        }

        INET_ASSERT(lpSource != NULL);

        if ((*lpdwBufferLength >= requiredSize)
        && ARGUMENT_PRESENT(lpBuffer)) {
            memcpy(lpBuffer, lpSource, requiredSize);
            if (isString) {

                //
                // string copied successfully. Returned length is string
                // length, not buffer length, i.e. drop 1 for '\0'
                //

                --requiredSize;
            }
        } else {
            error = ERROR_INSUFFICIENT_BUFFER;
        }
    }

quit:

    //
    // return the amount the app needs to supply, or the amount of data in the
    // buffer, depending on success/failure status
    //

    *lpdwBufferLength = requiredSize;

    if (hObjectMapped != NULL) {
        DereferenceObject((LPVOID)hObjectMapped);
    }

done:

    if (error == ERROR_SUCCESS) {
        success = TRUE;

        IF_DEBUG(API) {

            if (isString) {

                DEBUG_PRINT_API(API,
                                INFO,
                                ("returning %q (%d chars)\n",
                                lpBuffer,
                                requiredSize
                                ));

            } else {

                DEBUG_DUMP_API(API,
                               "option data:\n",
                               lpBuffer,
                               requiredSize
                               );

            }
        }
    } else {

        DEBUG_ERROR(API, error);

        IF_DEBUG(API) {

            if (error == ERROR_INSUFFICIENT_BUFFER) {

                DEBUG_PRINT_API(API,
                                INFO,
                                ("*lpdwBufferLength (%#x)= %d\n",
                                lpdwBufferLength,
                                *lpdwBufferLength
                                ));

            }
        }

        SetLastError(error);
        success = FALSE;
    }

    DEBUG_LEAVE_API(success);

    return success;
}


INTERNETAPI
BOOL
WINAPI
WinHttpQueryOption(
    IN HINTERNET hInternet OPTIONAL,
    IN DWORD dwOption,
    OUT LPVOID lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    hInternet           -

    dwOption            -

    lpBuffer            -

    lpdwBufferLength    -

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "WinHttpQueryOption",
                     "%#x, %s (%d), %#x, %#x [%d]",
                     hInternet,
                     InternetMapOption(dwOption),
                     dwOption,
                     lpBuffer,
                     lpdwBufferLength,
                     lpdwBufferLength
                        ? (!IsBadReadPtr(lpdwBufferLength, sizeof(DWORD))
                            ? *lpdwBufferLength
                            : 0)
                        : 0
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;
    MEMORYPACKET mpBuffer;

    if (!lpdwBufferLength
        || IsBadWritePtr(lpdwBufferLength, sizeof(*lpdwBufferLength))
        || (lpBuffer && *lpdwBufferLength && IsBadWritePtr(lpBuffer, *lpdwBufferLength)) )
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    
    switch (dwOption)
    {
    case WINHTTP_OPTION_USERNAME:
    case WINHTTP_OPTION_PASSWORD:
    case WINHTTP_OPTION_URL:
    case WINHTTP_OPTION_USER_AGENT:
    case WINHTTP_OPTION_PROXY_USERNAME:
    case WINHTTP_OPTION_PROXY_PASSWORD:
        if (lpBuffer)
        {
            mpBuffer.dwAlloc = mpBuffer.dwSize = *lpdwBufferLength;
            mpBuffer.psStr = (LPSTR)ALLOC_BYTES(mpBuffer.dwAlloc*sizeof(CHAR));
            if (!mpBuffer.psStr)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
        }
        fResult = InternetQueryOptionA(hInternet,
                                  dwOption,
                                  (LPVOID)mpBuffer.psStr,
                                  &mpBuffer.dwSize
                                 );
        if (fResult)
        {
            *lpdwBufferLength = sizeof(WCHAR) *
                MultiByteToWideChar(CP_ACP, 0, mpBuffer.psStr, mpBuffer.dwSize + 1, NULL, 0);
                
            if (*lpdwBufferLength <= mpBuffer.dwAlloc && lpBuffer)
            {
                MultiByteToWideChar(CP_ACP, 0, mpBuffer.psStr, mpBuffer.dwSize+1,
                        (LPWSTR)lpBuffer, *lpdwBufferLength);
                (*lpdwBufferLength)-=sizeof(WCHAR);
            }
            else
            {
                fResult = FALSE;
                dwErr = ERROR_INSUFFICIENT_BUFFER;
            }
        }
        else
        {
            if (GetLastError()==ERROR_INSUFFICIENT_BUFFER)
            {
                *lpdwBufferLength = mpBuffer.dwSize*sizeof(WCHAR);
            }
        }
        break;

    case WINHTTP_OPTION_PER_CONNECTION_OPTION:
        {
            if (!lpBuffer)
            {
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }

            INTERNET_PER_CONN_OPTION_LISTA listA;
            LPINTERNET_PER_CONN_OPTION_LISTW plistW = (LPINTERNET_PER_CONN_OPTION_LISTW)lpBuffer;
            CHAR szEntryA[RAS_MaxEntryName + 1];
            listA.pszConnection = szEntryA;
            
            InitIPCOList(plistW, &listA);
            listA.pOptions = (LPINTERNET_PER_CONN_OPTIONA)_alloca(sizeof(INTERNET_PER_CONN_OPTIONA)*listA.dwOptionCount);

            for (DWORD i=0; i<listA.dwOptionCount; i++)
            {
                listA.pOptions[i].dwOption = plistW->pOptions[i].dwOption;
                listA.pOptions[i].Value.pszValue = NULL;
                plistW->pOptions[i].Value.pszValue = NULL;
            }

            fResult = InternetQueryOptionA(hInternet,
                                  dwOption,
                                  (PVOID)&listA,
                                  lpdwBufferLength);

            // Now, convert from ansi to unicode

            if (fResult)
            {
                for (DWORD i=0; i<listA.dwOptionCount; i++)
                {
                    switch (listA.pOptions[i].dwOption)
                    {
                    case INTERNET_PER_CONN_FLAGS:
                    case INTERNET_PER_CONN_AUTODISCOVERY_FLAGS:
                    case INTERNET_PER_CONN_AUTOCONFIG_RELOAD_DELAY_MINS:
                        plistW->pOptions[i].Value.dwValue = listA.pOptions[i].Value.dwValue;
                        break;

                    case INTERNET_PER_CONN_AUTOCONFIG_LAST_DETECT_TIME:
                        plistW->pOptions[i].Value.ftValue = listA.pOptions[i].Value.ftValue;
                        break;
                    
                    case INTERNET_PER_CONN_PROXY_SERVER:
                    case INTERNET_PER_CONN_PROXY_BYPASS:
                    case INTERNET_PER_CONN_AUTOCONFIG_URL:
                    case INTERNET_PER_CONN_AUTOCONFIG_SECONDARY_URL:
                    case INTERNET_PER_CONN_AUTOCONFIG_LAST_DETECT_URL:
                        if (listA.pOptions[i].Value.pszValue && *listA.pOptions[i].Value.pszValue)
                        {
                            DWORD cc = MultiByteToWideChar(CP_ACP, 
                                                           0, 
                                                           listA.pOptions[i].Value.pszValue, 
                                                           -1,
                                                           NULL,
                                                           0);
                            plistW->pOptions[i].Value.pszValue = (PWSTR)GlobalAlloc(GPTR, cc*sizeof(WCHAR));
                            if (!plistW->pOptions[i].Value.pszValue)
                            {
                                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                                goto iopco_cleanup;
                            }
                            MultiByteToWideChar(CP_ACP, 
                                                0, 
                                                listA.pOptions[i].Value.pszValue, 
                                                -1,
                                                plistW->pOptions[i].Value.pszValue,
                                                cc);
                        }
                        break;

                    default:
                        INET_ASSERT(FALSE);
                        dwErr = ERROR_INVALID_PARAMETER;
                        goto iopco_cleanup;
                        break;
                    }
                }
            }
            else
            {
                plistW->dwOptionError = listA.dwOptionError;
            }
            
        iopco_cleanup:
            // Free all the allocated buffers
            for (i=0; i<listA.dwOptionCount; i++)
            {
                switch (listA.pOptions[i].dwOption)
                {
                case INTERNET_PER_CONN_PROXY_SERVER:
                case INTERNET_PER_CONN_PROXY_BYPASS:
                case INTERNET_PER_CONN_AUTOCONFIG_URL:
                case INTERNET_PER_CONN_AUTOCONFIG_SECONDARY_URL:
                case INTERNET_PER_CONN_AUTOCONFIG_LAST_DETECT_URL:
                    // These should have been converted from ansi to unicode
                    // and can be freed now
                    if (listA.pOptions[i].Value.pszValue)
                    {
                        GlobalFree(listA.pOptions[i].Value.pszValue);
                    }
                    // No point in passing back buffers in the event of an error
                    // condition
                    if (dwErr && plistW->pOptions[i].Value.pszValue)
                    {
                        GlobalFree(plistW->pOptions[i].Value.pszValue);
                    }
                    break;

                default:
                    // No need to do anything
                    break;
                }
            }
        }
        break;

    case WINHTTP_OPTION_PROXY:
        {
            WINHTTP_PROXY_INFOW * pInfo = (WINHTTP_PROXY_INFOW *) lpBuffer;
            
            union
            {
                WINHTTP_PROXY_INFOA InfoA;
                char                Buffer[1024];
            };

            char *  pBuffer;
            DWORD   dwBufferLen = sizeof(Buffer);
            bool    fFreeBuffer = false;

            if (IsBadWritePtr(pInfo, sizeof(WINHTTP_PROXY_INFOW)) ||
                (*lpdwBufferLength < sizeof(WINHTTP_PROXY_INFOW)))
            {
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }

            fResult = InternetQueryOptionA(hInternet, WINHTTP_OPTION_PROXY,
                            (void *) &Buffer,
                            &dwBufferLen);
            
            if (!fResult && (GetLastError() == ERROR_INSUFFICIENT_BUFFER))
            {
                pBuffer = New char[dwBufferLen];

                if (pBuffer)
                {
                    fFreeBuffer = true;

                    fResult = InternetQueryOptionA(hInternet, WINHTTP_OPTION_PROXY,
                                    (void *) pBuffer,
                                    &dwBufferLen);
                }
                else
                    dwErr = ERROR_NOT_ENOUGH_MEMORY;
            }

            if (fResult)
            {
                pInfo->dwAccessType = InfoA.dwAccessType;
            
                dwErr = AsciiToWideChar_UsingGlobalAlloc(InfoA.lpszProxy,
                                &(pInfo->lpszProxy));

                if (dwErr == ERROR_SUCCESS)
                {
                    dwErr = AsciiToWideChar_UsingGlobalAlloc(InfoA.lpszProxyBypass,
                                    &(pInfo->lpszProxyBypass));

                    if ((dwErr != ERROR_SUCCESS) && (pInfo->lpszProxy != NULL))
                    {
                        GlobalFree(pInfo->lpszProxy);
                        pInfo->lpszProxy = NULL;
                    }
                }

                fResult = (dwErr == ERROR_SUCCESS);
            }

            if (fFreeBuffer)
            {
                delete [] pBuffer;
            }
        }
        break;

    default:
        fResult = InternetQueryOptionA(hInternet,
                                  dwOption,
                                  lpBuffer,
                                  lpdwBufferLength
                                 );
    }

cleanup:
    if (dwErr!=ERROR_SUCCESS)
    {
        SetLastError(dwErr);
        DEBUG_ERROR(INET, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


INTERNETAPI
BOOL
WINAPI
InternetSetOptionA(
    IN HINTERNET hInternet OPTIONAL,
    IN DWORD dwOption,
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength
    )

/*++

Routine Description:

    Sets a handle-specific variable, or a per-thread variable

Arguments:

    hInternet           - handle of object for which information will be set,
                          or NULL if the option defines a per-thread variable

    dwOption            - the handle-specific WINHTTP_OPTION to set

    lpBuffer            - pointer to a buffer containing value to set

    dwBufferLength      - size of lpBuffer

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info:
                    ERROR_INVALID_HANDLE
                        hInternet does not identify a valid Internet handle
                        object

                    ERROR_WINHTTP_INTERNAL_ERROR
                        Shouldn't see this?

                    ERROR_INVALID_PARAMETER
                        One of the parameters was bad

                    ERROR_WINHTTP_INVALID_OPTION
                        The requested option cannot be set

                    ERROR_WINHTTP_OPTION_NOT_SETTABLE
                        Can't set this option, only query it

                    ERROR_INSUFFICIENT_BUFFER
                        The dwBufferLength parameter is incorrect for the
                        expected type of the option

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetSetOptionA",
                     "%#x, %s (%d), %#x [%#x], %d",
                     hInternet,
                     InternetMapOption(dwOption),
                     dwOption,
                     lpBuffer,
                     lpBuffer
                        ? (!IsBadReadPtr(lpBuffer, sizeof(DWORD))
                            ? *(LPDWORD)lpBuffer
                            : 0)
                        : 0,
                     dwBufferLength
                     ));

    DWORD error;
    BOOL success = TRUE;
    HINTERNET_HANDLE_TYPE handleType;
    LPINTERNET_THREAD_INFO lpThreadInfo;
    DWORD requiredSize;
    HINTERNET hObjectMapped = NULL;

    INET_ASSERT(dwBufferLength != 0);

    if (!GlobalDataInitialized) {
        error = GlobalDataInitialize();
        if (error != ERROR_SUCCESS) {
            goto done;
        }
    }

    //
    // validate the handle and get its type
    //

    if (ARGUMENT_PRESENT(hInternet)) {

        //
        // map the handle
        //

        error = MapHandleToAddress(hInternet, (LPVOID *)&hObjectMapped, FALSE);
        if (error == ERROR_SUCCESS) {
            hInternet = hObjectMapped;
            error = RGetHandleType(hInternet, &handleType);
        }
    } else if (IS_PER_THREAD_OPTION(dwOption)) {

        //
        // this option updates the per-thread information block, so this is a
        // good point at which to get it
        //

        lpThreadInfo = InternetGetThreadInfo();
        if (lpThreadInfo != NULL) {
            error = ERROR_SUCCESS;
        } else {

            DEBUG_PRINT(INET,
                        ERROR,
                        ("InternetGetThreadInfo() returns NULL\n"
                        ));

            //
            // we never expect this - ERROR_WINHTTP_SPANISH_INQUISITION
            //

            INET_ASSERT(FALSE);

            error = ERROR_WINHTTP_INTERNAL_ERROR;
        }
    } else if (IS_PER_PROCESS_OPTION(dwOption)) {
        error = ERROR_SUCCESS;
    } else {

        //
        // catch any invalid options for the NULL handle. If the option is valid
        // then it is incorrect for this handle type, otherwise its an invalid
        // option, period
        //

        error = IS_VALID_OPTION(dwOption)
                    ? ERROR_WINHTTP_INCORRECT_HANDLE_TYPE
                    : ERROR_WINHTTP_INVALID_OPTION
                    ;
    }

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    HTTP_REQUEST_HANDLE_OBJECT *pReq;

    switch (handleType)
    {
        case TypeHttpRequestHandle:
            pReq = (HTTP_REQUEST_HANDLE_OBJECT*) hInternet;
            break;

        case TypeInternetHandle:
            pReq = NULL;
            break;

        default:
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;           
            goto quit;
    } 
    
    // New fast path for request handle options.

    if (dwOption > WINHTTP_OPTION_MASK)
    {
        dwOption &= WINHTTP_OPTION_MASK;
        if (dwOption > MAX_INTERNET_STRING_OPTION)
            error = ERROR_INVALID_PARAMETER;
        else if (!pReq)
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        else if (pReq->SetProp (dwOption, (LPSTR) lpBuffer))
            error = ERROR_SUCCESS;
        else
            error = ERROR_WINHTTP_INTERNAL_ERROR;
                
        goto quit;
    }

    //
    // if the option and handle combination is valid then set the option value
    //

    switch (dwOption) {
    case WINHTTP_OPTION_CALLBACK:
    case WINHTTP_OPTION_HANDLE_TYPE:
    
        // these options cannot be set by this function
        error = ERROR_WINHTTP_OPTION_NOT_SETTABLE;
        break;
        
    case WINHTTP_OPTION_RESOLVE_TIMEOUT:
    case WINHTTP_OPTION_CONNECT_TIMEOUT:
    case WINHTTP_OPTION_CONNECT_RETRIES:
    case WINHTTP_OPTION_SEND_TIMEOUT:
    case WINHTTP_OPTION_RECEIVE_TIMEOUT:
        requiredSize = sizeof(DWORD);
        if (dwBufferLength != requiredSize) 
        {
            error = ERROR_INSUFFICIENT_BUFFER;
            break;
        }

        // For WinHttp, these options are per-handle, not per-process.
        if (hInternet == NULL) 
        {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
            break;
        }

        // we have a non-NULL context handle: the app wants to set specific
        // protocol timeouts
        switch (handleType) 
        {
        case TypeInternetHandle:

            //only error possible is in allocing memory for OPTIONAL_PARAMS struct
            if (! ((INTERNET_HANDLE_OBJECT*)hObjectMapped)->SetTimeout(dwOption, *(LPDWORD)lpBuffer) )
            {    
                error = ERROR_NOT_ENOUGH_MEMORY;
            }
            break;
            
        case TypeHttpRequestHandle:

            // no errors possible here
            ((HTTP_REQUEST_HANDLE_OBJECT*)hObjectMapped)->SetTimeout(dwOption, *(LPDWORD)lpBuffer);
            break;

        default:

            // any other handle type (?) cannot have timeouts set for it
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
            break;
        }
        break;

    case WINHTTP_OPTION_CONTEXT_VALUE:

        //
        // BUGBUG - can't change context if async operation is pending
        //

        if (dwBufferLength == sizeof(LPVOID)) {
            error = RSetContext(hInternet, *((DWORD_PTR *) lpBuffer));
        } else {
            error = ERROR_INSUFFICIENT_BUFFER;
        }
        break;

    case WINHTTP_OPTION_READ_BUFFER_SIZE:
    case WINHTTP_OPTION_WRITE_BUFFER_SIZE:
        if (pReq)
        {
            if (dwBufferLength == sizeof(DWORD))
            {
                DWORD bufferSize;

                bufferSize = *(LPDWORD)lpBuffer;
                if (bufferSize > 0)
                {
                    pReq->SetBufferSize(dwOption, bufferSize);
                    error = ERROR_SUCCESS;
                }
                else  // the read/write buffer size cannot be set to 0
                {
                    error = ERROR_INVALID_PARAMETER;
                }
            }
            else
            {
                error = ERROR_INSUFFICIENT_BUFFER;
            }
        }
        else
        {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        break;

    case WINHTTP_OPTION_CLIENT_CERT_CONTEXT:

        if (handleType != TypeHttpRequestHandle)
        {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        else if (dwBufferLength < sizeof(CERT_CONTEXT))
        {
            error = ERROR_INSUFFICIENT_BUFFER;
        }
        else
        {
            HTTP_REQUEST_HANDLE_OBJECT *pRequest =
                (HTTP_REQUEST_HANDLE_OBJECT *) hInternet;
            CERT_CONTEXT_ARRAY* pArray = pRequest->GetCertContextArray();
            if (!pArray)
                error = ERROR_WINHTTP_NOT_INITIALIZED;
            else
            {
                pArray->Reset();
                pArray->AddCertContext((PCCERT_CONTEXT) lpBuffer);
                pArray->SelectCertContext(0);
                error = ERROR_SUCCESS;
            }
        }
        break;

    case WINHTTP_OPTION_SECURITY_FLAGS:

        if (handleType != TypeHttpRequestHandle)
        {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        else if (dwBufferLength < sizeof(DWORD))
        {
            error = ERROR_INSUFFICIENT_BUFFER;
        }
        else
        {
            HTTP_REQUEST_HANDLE_OBJECT *lphHttpRqst;

            lphHttpRqst = (HTTP_REQUEST_HANDLE_OBJECT *) hInternet;

            lphHttpRqst->SetSecureFlags(*(LPDWORD)lpBuffer);

            error = ERROR_SUCCESS;
        }

        break;

    case WINHTTP_OPTION_PROXY:
        if ((handleType == TypeInternetHandle) || (handleType == TypeHttpRequestHandle))
        {
            WINHTTP_PROXY_INFOA * lpInfo = (WINHTTP_PROXY_INFOA *) lpBuffer;

            //
            // validate parameters
            //

            if (dwBufferLength != sizeof(*lpInfo))
            {
                error = ERROR_INSUFFICIENT_BUFFER;
            }
            else if (!((lpInfo->dwAccessType == WINHTTP_ACCESS_TYPE_NO_PROXY)
                    || (lpInfo->dwAccessType == WINHTTP_ACCESS_TYPE_NAMED_PROXY))
            || ((lpInfo->dwAccessType == WINHTTP_ACCESS_TYPE_NAMED_PROXY)
                && ((lpInfo->lpszProxy == NULL) || (*lpInfo->lpszProxy == '\0'))))
            {
                error = ERROR_INVALID_PARAMETER;
            }
            else
            {
                error = ((INTERNET_HANDLE_BASE *)hInternet)->SetProxyInfo(
                            lpInfo->dwAccessType,
                            lpInfo->lpszProxy,
                            lpInfo->lpszProxyBypass
                            );
            }
        }
        else
        {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        break;

    case WINHTTP_OPTION_USER_AGENT:
        if (*(LPSTR)lpBuffer == '\0') {
            error = ERROR_INSUFFICIENT_BUFFER;
        } else {
            if ((handleType == TypeInternetHandle) || (handleType == TypeHttpRequestHandle))
            {
                ((INTERNET_HANDLE_BASE *)hInternet)->SetUserAgent((LPSTR)lpBuffer);
            } else {
                error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
            }
        }
        break;
        
    case WINHTTP_OPTION_DIGEST_AUTH_UNLOAD:
        if (DIGEST_CTX::g_pFuncTbl)
        {
            DIGEST_CTX::Logoff();
            DIGEST_CTX::g_pFuncTbl = NULL;
        }            
        break;

    case WINHTTP_OPTION_REQUEST_PRIORITY:
        if (handleType == TypeHttpRequestHandle) {
            if (dwBufferLength == sizeof(LONG)) {
                ((HTTP_REQUEST_HANDLE_OBJECT *)hInternet)->
                    SetPriority(*(LPLONG)lpBuffer);
            } else {
                error = ERROR_INSUFFICIENT_BUFFER;
            }
        } else {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        break;

    case WINHTTP_OPTION_HTTP_VERSION:
        if (dwBufferLength == sizeof(HTTP_VERSION_INFO)) {
            HttpVersionInfo = *(LPHTTP_VERSION_INFO)lpBuffer;
        } else {
            error = ERROR_INSUFFICIENT_BUFFER;
        }
        break;

    case WINHTTP_OPTION_DISABLE_FEATURE:

        if (handleType != TypeHttpRequestHandle)
        {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        else if (dwBufferLength < sizeof(DWORD))
        {
            error = ERROR_INVALID_PARAMETER;
        }
        else
        {
            HTTP_REQUEST_HANDLE_OBJECT *pRequest =
                (HTTP_REQUEST_HANDLE_OBJECT *) hInternet;
            DWORD dwDisable = *((LPDWORD) lpBuffer);
            
            if (dwDisable & WINHTTP_DISABLE_KEEP_ALIVE)
            {
                DWORD dwFlags = pRequest->GetOpenFlags();
                dwFlags &= ~INTERNET_FLAG_KEEP_CONNECTION;
                pRequest->SetOpenFlags (dwFlags);                
            }
            if (dwDisable & WINHTTP_DISABLE_REDIRECTS)
            {
                DWORD dwFlags = pRequest->GetOpenFlags();
                dwFlags |= INTERNET_FLAG_NO_AUTO_REDIRECT;
                pRequest->SetOpenFlags (dwFlags);                
            }
            if (dwDisable & WINHTTP_DISABLE_COOKIES)
            {
                DWORD dwFlags = pRequest->GetOpenFlags();
                dwFlags |= INTERNET_FLAG_NO_COOKIES;
                pRequest->SetOpenFlags (dwFlags);                
            }
            if (dwDisable & WINHTTP_DISABLE_AUTHENTICATION)
            {
                DWORD dwFlags = pRequest->GetOpenFlags();
                dwFlags |= INTERNET_FLAG_NO_AUTH;
                pRequest->SetOpenFlags (dwFlags);                
            }
            error = ERROR_SUCCESS;
        }
        break;
            
  
    case WINHTTP_OPTION_ENABLE_FEATURE:

        if (handleType != TypeHttpRequestHandle)
        {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        else if (dwBufferLength < sizeof(DWORD))
        {
            error = ERROR_INVALID_PARAMETER;
        }
        else
        {
            HTTP_REQUEST_HANDLE_OBJECT *pRequest =
                (HTTP_REQUEST_HANDLE_OBJECT *) hInternet;
            DWORD dwDisable = *((LPDWORD) lpBuffer);

            pRequest->SetEnableFlags(*((LPDWORD) lpBuffer));
            error = ERROR_SUCCESS;
        }
        break;
            
  
    case WINHTTP_OPTION_CODEPAGE:
        if ((hInternet == NULL) || (handleType == TypeHttpRequestHandle))
        {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        else
        {
            if (dwBufferLength == sizeof(DWORD)) 
            {
                ((INTERNET_HANDLE_BASE *)hInternet)->SetCodePage(*(LPDWORD)lpBuffer);
            } 
            else 
            {
                error = ERROR_INSUFFICIENT_BUFFER;
            }
        } 
        break;

    case WINHTTP_OPTION_MAX_CONNS_PER_SERVER:
    case WINHTTP_OPTION_MAX_CONNS_PER_1_0_SERVER:
        if (handleType == TypeInternetHandle)
        {
            if (dwBufferLength == sizeof(DWORD))
            {
                ((INTERNET_HANDLE_OBJECT *)hInternet)->SetMaxConnectionsPerServer(dwOption, *(DWORD *)lpBuffer);
            }
            else
                error = ERROR_INSUFFICIENT_BUFFER;
        }
        else
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        break;

    case WINHTTP_OPTION_PER_CONNECTION_OPTION:
        {
            if (handleType != TypeInternetHandle) {
                hInternet = NULL;
            }

            error = SetPerConnOptions(hInternet, 
                                      FALSE,
                                      (LPINTERNET_PER_CONN_OPTION_LIST)lpBuffer);
            break;
        }

    case WINHTTP_OPTION_AUTOLOGON_POLICY:

        if (handleType != TypeHttpRequestHandle)
        {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        else if (dwBufferLength < sizeof(DWORD))
        {
            error = ERROR_INSUFFICIENT_BUFFER;
        }
        else
        {
            HTTP_REQUEST_HANDLE_OBJECT *lphHttpRqst;

            lphHttpRqst = (HTTP_REQUEST_HANDLE_OBJECT *) hInternet;

            lphHttpRqst->SetSecurityLevel(*(LPDWORD)lpBuffer);

            error = ERROR_SUCCESS;
        }

        break;

    case WINHTTP_OPTION_WORKER_THREAD_COUNT:
        
        if (dwBufferLength < sizeof(DWORD))
        {
            error = ERROR_INSUFFICIENT_BUFFER;
        }
        else
        {
            if (!g_cNumIOCPThreads)
            {
                g_cNumIOCPThreads = *(LPDWORD)lpBuffer;
                error = ERROR_SUCCESS;
            }
            else
            {
                error = ERROR_WINHTTP_OPTION_NOT_SETTABLE;
            }
        }
        break;
        
#if INET_DEBUG
    case WINHTTP_OPTION_SET_DEBUG_INFO:
        error = InternetSetDebugInfo((LPINTERNET_DEBUG_INFO)lpBuffer,
                                     dwBufferLength
                                     );
        break;

#endif // INET_DEBUG

    default:

        //
        // this option is not recognized
        //

        error = ERROR_WINHTTP_INVALID_OPTION;
    }

quit:

    if (hObjectMapped != NULL) {
        DereferenceObject((LPVOID)hObjectMapped);
    }

done:

    if (error != ERROR_SUCCESS) {

        DEBUG_ERROR(API, error);

        SetLastError(error);
        success = FALSE;
    }

    DEBUG_LEAVE_API(success);

    return success;
}

#define CHECK_MODIFY_TIMEOUT(nTimeout) \
{ \
    if (nTimeout <= 0) \
    { \
        if (nTimeout == 0) \
        { \
            nTimeout = (int)INFINITE; \
        } \
        else if (nTimeout < -1) \
        { \
            dwError = ERROR_INVALID_PARAMETER; \
            goto quit; \
        } \
    } \
}

INTERNETAPI
BOOL
WINAPI 
WinHttpSetTimeouts(    
    IN HINTERNET    hInternet,           // Session/Request handle.
    IN int        nResolveTimeout,
    IN int        nConnectTimeout,
    IN int        nSendTimeout,
    IN int        nReceiveTimeout
    )
{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "WinHttpSetTimeouts",
                     "%#x, %d, %d, %d, %d",
                     hInternet,
                     nResolveTimeout,
                     nConnectTimeout,
                     nSendTimeout,
                     nReceiveTimeout
                     ));

    DWORD dwError = ERROR_SUCCESS;
    BOOL bRetval = FALSE;
    HINTERNET_HANDLE_TYPE handleType;
    HINTERNET hObjectMapped = NULL;

    if (!hInternet)
    {
        dwError = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        goto quit;
    }

    CHECK_MODIFY_TIMEOUT(nResolveTimeout);
    CHECK_MODIFY_TIMEOUT(nConnectTimeout);
    CHECK_MODIFY_TIMEOUT(nSendTimeout);
    CHECK_MODIFY_TIMEOUT(nReceiveTimeout);
    
    dwError = MapHandleToAddress(hInternet, (LPVOID *)&hObjectMapped, FALSE);

    if (dwError != ERROR_SUCCESS)
    {
        goto quit;
    }
    
    dwError = RGetHandleType(hObjectMapped, &handleType);

    if (dwError != ERROR_SUCCESS)
    {
        goto quit;
    }

    switch(handleType)
    {
        case TypeInternetHandle:

            //only error possible is in allocing memory for OPTIONAL_PARAMS struct
            bRetval = ((INTERNET_HANDLE_OBJECT*)hObjectMapped)->SetTimeouts(
                nResolveTimeout, nConnectTimeout, nSendTimeout, nReceiveTimeout);
            if (!bRetval)
            {    
                dwError = ERROR_NOT_ENOUGH_MEMORY;
                goto quit;
            }
            break;
            
        case TypeHttpRequestHandle:

            // no errors possible here
            bRetval = ((HTTP_REQUEST_HANDLE_OBJECT*)hObjectMapped)->SetTimeouts( 
                nResolveTimeout, nConnectTimeout, nSendTimeout, nReceiveTimeout);
            INET_ASSERT(bRetval);
            break;

        default:

            // any other handle type cannot have timeouts set for it
            dwError = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
            break;
    }
    
quit:

    if (hObjectMapped) 
    {
        DereferenceObject((LPVOID)hObjectMapped);
    }

    if (dwError != ERROR_SUCCESS) 
    { 
        ::SetLastError(dwError); 
        INET_ASSERT(!bRetval);
    }
    
    DEBUG_LEAVE_API(bRetval);
    return bRetval;
}


INTERNETAPI
BOOL
WINAPI
WinHttpSetOption(
    IN HINTERNET hInternet OPTIONAL,
    IN DWORD dwOption,
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    hInternet       -

    dwOption        -

    lpBuffer        -

    dwBufferLength  -

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "WinHttpSetOption",
                     "%#x, %s (%d), %#x [%#x], %d",
                     hInternet,
                     InternetMapOption(dwOption),
                     dwOption,
                     lpBuffer,
                     lpBuffer
                        ? (!IsBadReadPtr(lpBuffer, sizeof(DWORD))
                            ? *(LPDWORD)lpBuffer
                            : 0)
                        : 0,
                     dwBufferLength
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    MEMORYPACKET mpBuffer;
    BOOL fResult = FALSE;

    //
    // validate parameters
    //

    if ((dwBufferLength == 0) || IsBadReadPtr(lpBuffer, dwBufferLength)) 
    {
        switch (dwOption) 
        {
            //
            // these options don't require a buffer - don't fail request because
            // no buffer supplied
            //

            case WINHTTP_OPTION_DIGEST_AUTH_UNLOAD:
                if (dwBufferLength == 0)
                    break;
                break;

            default:
                dwErr = ERROR_INVALID_PARAMETER;
                goto cleanup;
        }
    }
    
    switch (dwOption)
    {
    case WINHTTP_OPTION_USERNAME:
    case WINHTTP_OPTION_PASSWORD:
    case WINHTTP_OPTION_URL:
    case WINHTTP_OPTION_USER_AGENT:
    case WINHTTP_OPTION_PROXY_USERNAME:
    case WINHTTP_OPTION_PROXY_PASSWORD:
        ALLOC_MB((LPWSTR)lpBuffer, dwBufferLength, mpBuffer);
        if (!mpBuffer.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI((LPWSTR)lpBuffer, mpBuffer);
        fResult = InternetSetOptionA(hInternet,
                                  dwOption,
                                  mpBuffer.psStr,
                                  mpBuffer.dwSize
                                 );
        break;

    case WINHTTP_OPTION_PER_CONNECTION_OPTION:
        {
            if (!lpBuffer)
            {
                dwErr = ERROR_INVALID_PARAMETER;
                goto cleanup;
            }

            INTERNET_PER_CONN_OPTION_LISTA listA;
            LPINTERNET_PER_CONN_OPTION_LISTW plistW = (LPINTERNET_PER_CONN_OPTION_LISTW)lpBuffer;
            CHAR szEntryA[RAS_MaxEntryName + 1];
            listA.pszConnection = szEntryA;
            
            InitIPCOList(plistW, &listA);
            listA.pOptions = (LPINTERNET_PER_CONN_OPTIONA)_alloca(sizeof(INTERNET_PER_CONN_OPTIONA)*listA.dwOptionCount);
            
            for (DWORD i=0; i<listA.dwOptionCount; i++)
            {
                listA.pOptions[i].dwOption = plistW->pOptions[i].dwOption;

                switch (listA.pOptions[i].dwOption)
                {
                case INTERNET_PER_CONN_FLAGS:
                case INTERNET_PER_CONN_AUTODISCOVERY_FLAGS:
                case INTERNET_PER_CONN_AUTOCONFIG_RELOAD_DELAY_MINS:
                    listA.pOptions[i].Value.dwValue = plistW->pOptions[i].Value.dwValue;
                    break;

                case INTERNET_PER_CONN_AUTOCONFIG_LAST_DETECT_TIME:
                    listA.pOptions[i].Value.ftValue = plistW->pOptions[i].Value.ftValue;
                    break;
                    
                case INTERNET_PER_CONN_PROXY_SERVER:
                case INTERNET_PER_CONN_PROXY_BYPASS:
                case INTERNET_PER_CONN_AUTOCONFIG_URL:
                case INTERNET_PER_CONN_AUTOCONFIG_SECONDARY_URL:
                case INTERNET_PER_CONN_AUTOCONFIG_LAST_DETECT_URL:
                    if (plistW->pOptions[i].Value.pszValue && *plistW->pOptions[i].Value.pszValue)
                    {
                        // ** WARNING ** NO UTF8 ENCODING HERE
                        DWORD cb = WideCharToMultiByte(CP_ACP, 
                                        0, 
                                        plistW->pOptions[i].Value.pszValue,
                                        -1,
                                        0, 
                                        0,
                                        NULL,
                                        NULL);
                        listA.pOptions[i].Value.pszValue = (PSTR)_alloca(cb);
                        WideCharToMultiByte(CP_ACP, 
                                        0, 
                                        plistW->pOptions[i].Value.pszValue,
                                        -1,
                                        listA.pOptions[i].Value.pszValue, 
                                        cb,
                                        NULL,
                                        NULL);
                    }
                    else
                    {
                        listA.pOptions[i].Value.pszValue = NULL; 
                    }
                    break;
                    
                default:
                    dwErr = ERROR_INVALID_PARAMETER;
                    goto cleanup;
                    break;
                }
            }
            fResult = InternetSetOptionA(hInternet,
                              dwOption,
                              (PVOID)&listA,
                              dwBufferLength);
            plistW->dwOptionError = listA.dwOptionError;
        }
        break;

    case WINHTTP_OPTION_PROXY:
        {
            WINHTTP_PROXY_INFOW * pInfo = (WINHTTP_PROXY_INFOW *) lpBuffer;
            WINHTTP_PROXY_INFOA   InfoA;

            if (IsBadReadPtr(pInfo, sizeof(WINHTTP_PROXY_INFOW)) || (dwBufferLength < sizeof(WINHTTP_PROXY_INFOW)))
            {
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }

            InfoA.dwAccessType = pInfo->dwAccessType;

            dwErr = WideCharToAscii(pInfo->lpszProxy, &InfoA.lpszProxy);

            if (dwErr == ERROR_SUCCESS)
            {
                dwErr = WideCharToAscii(pInfo->lpszProxyBypass, &InfoA.lpszProxyBypass);

                if (dwErr == ERROR_SUCCESS)
                {
                    fResult = InternetSetOptionA(hInternet, WINHTTP_OPTION_PROXY, &InfoA, sizeof(InfoA));

                    if (InfoA.lpszProxyBypass)
                    {
                        delete [] InfoA.lpszProxyBypass;
                    }
                }

                if (InfoA.lpszProxy)
                {
                    delete [] InfoA.lpszProxy;
                }
            }
        }
        break;

    default:
        fResult = InternetSetOptionA(hInternet,
                                  dwOption,
                                  lpBuffer,
                                  dwBufferLength
                                 );
    }

cleanup:
    if (dwErr!=ERROR_SUCCESS)
    {
        SetLastError(dwErr);
        DEBUG_ERROR(INET, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}



PRIVATE
BOOL
FValidCacheHandleType(
    HINTERNET_HANDLE_TYPE   hType
    )
{
    return ((hType != TypeInternetHandle)   &&
            (hType != TypeHttpConnectHandle));
}

#ifdef ENABLE_DEBUG

#define CASE_OF(constant)   case constant: return # constant

LPSTR
InternetMapOption(
    IN DWORD Option
    )

/*++

Routine Description:

    Convert WINHTTP_OPTION_ value to symbolic name

Arguments:

    Option  - to map

Return Value:

    LPSTR - pointer to symbolic name, or "?" if unknown

--*/

{
    switch (Option) {
    CASE_OF(WINHTTP_OPTION_CALLBACK);
    CASE_OF(WINHTTP_OPTION_RESOLVE_TIMEOUT);
    CASE_OF(WINHTTP_OPTION_CONNECT_TIMEOUT);
    CASE_OF(WINHTTP_OPTION_CONNECT_RETRIES);
    CASE_OF(WINHTTP_OPTION_SEND_TIMEOUT);
    CASE_OF(WINHTTP_OPTION_RECEIVE_TIMEOUT);
    CASE_OF(WINHTTP_OPTION_HANDLE_TYPE);
    CASE_OF(WINHTTP_OPTION_READ_BUFFER_SIZE);
    CASE_OF(WINHTTP_OPTION_WRITE_BUFFER_SIZE);
    CASE_OF(WINHTTP_OPTION_PARENT_HANDLE);
    CASE_OF(WINHTTP_OPTION_EXTENDED_ERROR);
    CASE_OF(WINHTTP_OPTION_USERNAME);
    CASE_OF(WINHTTP_OPTION_PASSWORD);
    CASE_OF(WINHTTP_OPTION_SECURITY_FLAGS);
    CASE_OF(WINHTTP_OPTION_SECURITY_CERTIFICATE_STRUCT);
    CASE_OF(WINHTTP_OPTION_URL);
    CASE_OF(WINHTTP_OPTION_SECURITY_KEY_BITNESS);
    CASE_OF(WINHTTP_OPTION_PROXY);
    CASE_OF(WINHTTP_OPTION_VERSION);
    CASE_OF(WINHTTP_OPTION_USER_AGENT);
    CASE_OF(WINHTTP_OPTION_PROXY_USERNAME);
    CASE_OF(WINHTTP_OPTION_PROXY_PASSWORD);
    CASE_OF(WINHTTP_OPTION_CONTEXT_VALUE);
    CASE_OF(WINHTTP_OPTION_CLIENT_CERT_CONTEXT);
    CASE_OF(WINHTTP_OPTION_REQUEST_PRIORITY);
    CASE_OF(WINHTTP_OPTION_HTTP_VERSION);
    CASE_OF(WINHTTP_OPTION_SECURITY_CONNECTION_INFO);
    CASE_OF(WINHTTP_OPTION_DIAGNOSTIC_SOCKET_INFO);
    CASE_OF(WINHTTP_OPTION_SERVER_CERT_CONTEXT);
    }
    return "?";
}

#endif // ENABLE_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\api\thrdinfo.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    thrdinfo.cxx

Abstract:

    Functions to manipulate an INTERNET_THREAD_INFO

    Contents:
        InternetCreateThreadInfo
        InternetDestroyThreadInfo
        InternetTerminateThreadInfo
        InternetGetThreadInfo
        InternetSetThreadInfo
        InternetIndicateStatusAddress
        InternetIndicateStatusString
        InternetIndicateStatusNewHandle
        InternetIndicateStatus
        InternetSetLastError
        _InternetSetLastError
        InternetLockErrorText
        InternetUnlockErrorText
        InternetSetObjectHandle
        InternetGetObjectHandle
        InternetFreeThreadInfo

Author:

    Richard L Firth (rfirth) 16-Feb-1995

Environment:

    Win32 user-level DLL

Revision History:

    16-Feb-1995 rfirth
        Created

--*/

#include <wininetp.h>
#include <perfdiag.hxx>

//
// manifests
//

#define BAD_TLS_INDEX   0xffffffff  // according to online win32 SDK documentation
#ifdef SPX_SUPPORT
#define GENERIC_SPX_NAME   "SPX Server"
#endif //SPX_SUPPORT
//
// macros
//

#ifdef ENABLE_DEBUG

#define InitializeInternetThreadInfo(lpThreadInfo) \
    InitializeListHead(&lpThreadInfo->List); \
    lpThreadInfo->Signature = INTERNET_THREAD_INFO_SIGNATURE; \
    lpThreadInfo->ThreadId = GetCurrentThreadId();

#else

#define InitializeInternetThreadInfo(threadInfo) \
    InitializeListHead(&lpThreadInfo->List); \
    lpThreadInfo->ThreadId = GetCurrentThreadId();

#endif // ENABLE_DEBUG

//
// private data
//

PRIVATE DWORD InternetTlsIndex = BAD_TLS_INDEX;
PRIVATE SERIALIZED_LIST ThreadInfoList;



LPINTERNET_THREAD_INFO
InternetCreateThreadInfo(
    IN BOOL SetTls
    )

/*++

Routine Description:

    Creates, initializes an INTERNET_THREAD_INFO. Optionally (allocates and)
    sets this thread's Internet TLS

    Assumes: 1. The first time this function is called is in the context of the
                process attach library call, so we allocate the TLS index once

Arguments:

    SetTls  - TRUE if we are to set the INTERNET_THREAD_INFO TLS for this thread

Return Value:

    LPINTERNET_THREAD_INFO
        Success - pointer to allocated INTERNET_THREAD_INFO structure which has
                  been set as this threads value in its InternetTlsIndex slot

        Failure - NULL

--*/

{
    LPINTERNET_THREAD_INFO lpThreadInfo = NULL;
    BOOL ok = FALSE;

    if (InDllCleanup) {
        goto quit;
    }
    if (InternetTlsIndex == BAD_TLS_INDEX) {

        //
        // first time through, initialize serialized list
        //

        InitializeSerializedList(&ThreadInfoList);

        //
        // we assume that if we are allocating the TLS index, then this is the
        // one and only thread in this process that can call into this DLL
        // right now - i.e. this thread is loading the DLL
        //

        InternetTlsIndex = TlsAlloc();
    }
    if (InternetTlsIndex != BAD_TLS_INDEX) {
        lpThreadInfo = NEW(INTERNET_THREAD_INFO);
        if (lpThreadInfo != NULL) {
            InitializeInternetThreadInfo(lpThreadInfo);
            if (SetTls) {
                ok = TlsSetValue(InternetTlsIndex, (LPVOID)lpThreadInfo);
                if (!ok) {

                    DEBUG_PUT(("InternetCreateThreadInfo(): TlsSetValue(%d, %#x) returns %d\n",
                             InternetTlsIndex,
                             lpThreadInfo,
                             GetLastError()
                             ));

                    DEBUG_BREAK(THRDINFO);

                }
            } else {
                ok = TRUE;
            }
        } else {

            DEBUG_PUT(("InternetCreateThreadInfo(): NEW(INTERNET_THREAD_INFO) returned NULL\n"));

            DEBUG_BREAK(THRDINFO);

        }
    } else {

        DEBUG_PUT(("InternetCreateThreadInfo(): TlsAlloc() returns %#x, error %d\n",
                 BAD_TLS_INDEX,
                 GetLastError()
                 ));

        DEBUG_BREAK(THRDINFO);
    }
    if (ok) {
        if (!InsertAtHeadOfSerializedList(&ThreadInfoList, &lpThreadInfo->List)) {
            DEL(lpThreadInfo);
            lpThreadInfo = NULL;

            if (InternetTlsIndex != BAD_TLS_INDEX) {
                TlsFree(InternetTlsIndex);
                InternetTlsIndex = BAD_TLS_INDEX;
            }
        }
    } else {
        if (lpThreadInfo != NULL) {
            DEL(lpThreadInfo);
            lpThreadInfo = NULL;
        }
        if (InternetTlsIndex != BAD_TLS_INDEX) {
            TlsFree(InternetTlsIndex);
            InternetTlsIndex = BAD_TLS_INDEX;
        }
    }

quit:

    return lpThreadInfo;
}


VOID
InternetDestroyThreadInfo(
    VOID
    )

/*++

Routine Description:

    Cleans up the INTERNET_THREAD_INFO - deletes any memory it owns and deletes
    it

Arguments:

    None.

Return Value:

    None.

--*/

{
    LPINTERNET_THREAD_INFO lpThreadInfo;

    IF_DEBUG(NOTHING) {
        DEBUG_PUT(("InternetDestroyThreadInfo(): Thread %#x: Deleting INTERNET_THREAD_INFO\n",
                    GetCurrentThreadId()
                    ));
    }

    //
    // don't call InternetGetThreadInfo() - we don't need to create the
    // INTERNET_THREAD_INFO if it doesn't exist in this case
    //

    lpThreadInfo = (LPINTERNET_THREAD_INFO)TlsGetValue(InternetTlsIndex);
    if (lpThreadInfo != NULL) {

#if INET_DEBUG

        //
        // there shouldn't be anything in the debug record stack. On Win95, we
        // ignore this check if this is the async scheduler (nee worker) thread
        // AND there are entries in the debug record stack. The async thread
        // gets killed off before it has chance to DEBUG_LEAVE, then comes here,
        // causing this assert to be over-active
        //

        if (IsPlatformWin95() && lpThreadInfo->IsAsyncWorkerThread) {
            if (lpThreadInfo->CallDepth != 0) {

                DEBUG_PUT(("InternetDestroyThreadInfo(): "
                            "Thread %#x: "
                            "%d records in debug stack\n",
                            lpThreadInfo->CallDepth
                            ));
            }
        } else {

            INET_ASSERT(lpThreadInfo->Stack == NULL);

        }

#endif // INET_DEBUG

        InternetFreeThreadInfo(lpThreadInfo);

        INET_ASSERT(InternetTlsIndex != BAD_TLS_INDEX);

        TlsSetValue(InternetTlsIndex, NULL);
    } else {

        DEBUG_PUT(("InternetDestroyThreadInfo(): Thread %#x: no INTERNET_THREAD_INFO\n",
                    GetCurrentThreadId()
                    ));

    }
}


VOID
InternetFreeThreadInfo(
    IN LPINTERNET_THREAD_INFO lpThreadInfo
    )

/*++

Routine Description:

    Removes the INTERNET_THREAD_INFO from the list and frees all allocated
    blocks

Arguments:

    lpThreadInfo    - pointer to INTERNET_THREAD_INFO to remove and free

Return Value:

    None.

--*/

{
    if (RemoveFromSerializedList(&ThreadInfoList, &lpThreadInfo->List)) {

        if (lpThreadInfo->hErrorText != NULL) {
            FREE_MEMORY(lpThreadInfo->hErrorText);
        }

        //if (lpThreadInfo->lpResolverInfo != NULL) {
        //    if (lpThreadInfo->lpResolverInfo->DnrSocketHandle != NULL) {
        //        lpThreadInfo->lpResolverInfo->DnrSocketHandle->Dereference();
        //    }
        //    DEL(lpThreadInfo->lpResolverInfo);
        //}

        DEL(lpThreadInfo);
    }
}


VOID
InternetTerminateThreadInfo(
    VOID
    )

/*++

Routine Description:

    Destroy all INTERNET_THREAD_INFO structures and terminate the serialized
    list. This funciton called at process detach time.

    At DLL_PROCESS_DETACH time, there may be other threads in the process for
    which we created an INTERNET_THREAD_INFO that aren't going to get the chance
    to delete the structure, so we do it here.

    Code in this module assumes that it is impossible for a new thread to enter
    this DLL while we are terminating in DLL_PROCESS_DETACH

Arguments:

    None.

Return Value:

    None.

--*/

{
    //
    // get rid of this thread's info structure. No more debug output after this!
    //

    InternetDestroyThreadInfo();

    //
    // get rid of the thread info structures left by other threads
    //

    if (LockSerializedList(&ThreadInfoList))
    {
        LPINTERNET_THREAD_INFO lpThreadInfo;

        while (lpThreadInfo = (LPINTERNET_THREAD_INFO)SlDequeueHead(&ThreadInfoList)) {

            //
            // already dequeued, no need to call InternetFreeThreadInfo()
            //

            FREE_MEMORY(lpThreadInfo);
        }

        UnlockSerializedList(&ThreadInfoList);
    }

    //
    // no more need for list
    //

    TerminateSerializedList(&ThreadInfoList);

    //
    // or TLS index
    //

    TlsFree(InternetTlsIndex);
    InternetTlsIndex = BAD_TLS_INDEX;
}


LPINTERNET_THREAD_INFO
InternetGetThreadInfo(
    VOID
    )

/*++

Routine Description:

    Gets the pointer to the INTERNET_THREAD_INFO for this thread and checks
    that it still looks good.

    If this thread does not have an INTERNET_THREAD_INFO then we create one,
    presuming that this is a new thread

Arguments:

    None.

Return Value:

    LPINTERNET_THREAD_INFO
        Success - pointer to INTERNET_THREAD_INFO block

        Failure - NULL

--*/

{
    LPINTERNET_THREAD_INFO lpThreadInfo = NULL;
    DWORD lastError;

    //
    // this is pretty bad - TlsGetValue() can destroy the per-thread last error
    // variable if it returns NULL (to indicate that NULL was actually set, and
    // that NULL does not indicate an error). So we have to read it before it is
    // potentially destroyed, and reset it before we quit.
    //
    // We do this here because typically, other functions will be completely
    // unsuspecting of this behaviour, and it is better to fix it once here,
    // than in several dozen other places, even though it is slightly
    // inefficient
    //

    lastError = GetLastError();
    if (InternetTlsIndex != BAD_TLS_INDEX) {
        lpThreadInfo = (LPINTERNET_THREAD_INFO)TlsGetValue(InternetTlsIndex);
    }

    //
    // we may be in the process of creating the INTERNET_THREAD_INFO, in
    // which case its okay for this to be NULL. According to online SDK
    // documentation, a threads TLS value will be initialized to NULL
    //

    if (lpThreadInfo == NULL) {

        //
        // we presume this is a new thread. Create an INTERNET_THREAD_INFO
        //

        IF_DEBUG(NOTHING) {
            DEBUG_PUT(("InternetGetThreadInfo(): Thread %#x: Creating INTERNET_THREAD_INFO\n",
                      GetCurrentThreadId()
                      ));
        }

        lpThreadInfo = InternetCreateThreadInfo(TRUE);
    }
    if (lpThreadInfo != NULL) {

        INET_ASSERT(lpThreadInfo->Signature == INTERNET_THREAD_INFO_SIGNATURE);
        INET_ASSERT(lpThreadInfo->ThreadId == GetCurrentThreadId());

    } else {

        DEBUG_PUT(("InternetGetThreadInfo(): Failed to get/create INTERNET_THREAD_INFO\n"));

    }

    //
    // as above - reset the last error variable in case TlsGetValue() trashed it
    //

    SetLastError(lastError);

    //
    // actual success/failure indicated by non-NULL/NULL pointer resp.
    //

    return lpThreadInfo;
}


VOID
InternetSetThreadInfo(
    IN LPINTERNET_THREAD_INFO lpThreadInfo
    )

/*++

Routine Description:

    Sets lpThreadInfo as the current thread's INTERNET_THREAD_INFO. Used within
    fibers

Arguments:

    lpThreadInfo    - new INTERNET_THREAD_INFO to set

Return Value:

    None.

--*/

{
    if (InternetTlsIndex != BAD_TLS_INDEX) {
        if (!TlsSetValue(InternetTlsIndex, (LPVOID)lpThreadInfo)) {

            DEBUG_PUT(("InternetSetThreadInfo(): TlsSetValue(%d, %#x) returns %d\n",
                     InternetTlsIndex,
                     lpThreadInfo,
                     GetLastError()
                     ));

            INET_ASSERT(FALSE);

        }
    } else {

        DEBUG_PUT(("InternetSetThreadInfo(): InternetTlsIndex = %d\n",
                 InternetTlsIndex
                 ));

        INET_ASSERT(FALSE);
    }
}


DWORD
InternetIndicateStatusAddress(
    IN DWORD dwInternetStatus,
    IN LPSOCKADDR lpSockAddr,
    IN DWORD dwSockAddrLength
    )

/*++

Routine Description:

    Make a status callback to the app. The data is a network address that we
    need to convert to a string

Arguments:

    dwInternetStatus    - WINHTTP_CALLBACK_STATUS_ value

    lpSockAddr          - pointer to full socket address

    dwSockAddrLength    - length of lpSockAddr in bytes

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_WINHTTP_OPERATION_CANCELLED
                    The app closed the object handle during the callback

--*/

{
    LPSTR lpAddress;

    INET_ASSERT(lpSockAddr != NULL);

    switch (lpSockAddr->sa_family) 
    {
    case AF_INET:
        lpAddress = _I_inet_ntoa(
                        ((struct sockaddr_in*)lpSockAddr)->sin_addr
                        );
        break;

    case AF_IPX:

        //
        // BUGBUG - this should be a call to WSAAddressToString, but that's not implemented yet
        //
#ifdef SPX_SUPPORT
        lpAddress = GENERIC_SPX_NAME;
#else
        lpAddress = NULL;
#endif //SPX_SUPPORT
        break;

    default:
        lpAddress = NULL;
        break;
    }
    // we don't want a client to mess around with a winsock-internal buffer
    return InternetIndicateStatusString(dwInternetStatus, lpAddress, TRUE/*bCopyBuffer*/);
}


DWORD
InternetIndicateStatusString(
    IN DWORD dwInternetStatus,
    IN LPSTR lpszStatusInfo OPTIONAL,
    IN BOOL  bCopyBuffer,
    IN BOOL  bConvertToUnicode
    )

/*++

Routine Description:

    Make a status callback to the app. The data is a string

Arguments:

    dwInternetStatus    - WINHTTP_CALLBACK_STATUS_ value

    lpszStatusInfo      - string status data

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_WINHTTP_OPERATION_CANCELLED
                    The app closed the object handle during the callback

--*/

{
    DEBUG_ENTER((DBG_THRDINFO,
                Dword,
                "InternetIndicateStatusString",
                "%d, %q",
                dwInternetStatus,
                lpszStatusInfo
                ));

    DWORD length;

    if (ARGUMENT_PRESENT(lpszStatusInfo)) 
    {
        length = strlen(lpszStatusInfo) + 1;
    } 
    else 
    {
        length = 0;
    }

    DWORD error;

    error = InternetIndicateStatus(dwInternetStatus, lpszStatusInfo, length, bCopyBuffer, bConvertToUnicode);

    DEBUG_LEAVE(error);

    return error;
}


DWORD
InternetIndicateStatusNewHandle(
    IN LPVOID hInternetMapped
    )

/*++

Routine Description:

    Indicates to the app a new handle

Arguments:

    hInternetMapped - mapped address of new handle being indicated

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_WINHTTP_OPERATION_CANCELLED
                    The app closed the either the new object handle or the
                    parent object handle during the callback

--*/

{
    DEBUG_ENTER((DBG_THRDINFO,
                Dword,
                "InternetIndicateStatusNewHandle",
                "%#x",
                hInternetMapped
                ));

    HANDLE_OBJECT * hObject = (HANDLE_OBJECT *)hInternetMapped;

    //
    // reference the new request handle, in case the app closes it in the
    // callback. The new handle now has a reference count of 2
    //

    hObject->Reference();

    INET_ASSERT(hObject->ReferenceCount() == 2);

    //
    // we indicate the pseudo handle to the app
    //

    HINTERNET hInternet = hObject->GetPseudoHandle();

    DWORD error = InternetIndicateStatus(WINHTTP_CALLBACK_STATUS_HANDLE_CREATED,
                                         (LPVOID)&hInternet,
                                         sizeof(hInternet)
                                         );

    //
    // dereference the new request handle. If this returns TRUE then the new
    // handle has been deleted (the app called InternetCloseHandle() against
    // it which dereferenced it to 1, and now we've dereferenced it to zero)
    //

    if (hObject->Dereference()) 
    {
        error = ERROR_WINHTTP_OPERATION_CANCELLED;
    } 
    else if (error == ERROR_WINHTTP_OPERATION_CANCELLED) 
    {

        //
        // the parent handle was deleted. Kill off the new handle too
        //

        BOOL ok;

        ok = hObject->Dereference();

        INET_ASSERT(ok);

    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
InternetIndicateStatus(
    IN DWORD dwStatus,
    IN LPVOID lpBuffer,
    IN DWORD dwLength,
    IN BOOL bCopyBuffer,
    IN BOOL bConvertToUnicode
    )

/*++

Routine Description:

    If the app has registered a callback function for the object that this
    thread is operating on, call it with the arguments supplied

Arguments:

    dwStatus    - WINHTTP_CALLBACK_STATUS_ value

    lpBuffer    - pointer to variable data buffer

    dwLength    - length of *lpBuffer in bytes

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_WINHTTP_OPERATION_CANCELLED
                    The app closed the object handle during the callback

--*/

{
    DEBUG_ENTER((DBG_THRDINFO,
                Dword,
                "InternetIndicateStatus",
                "%s, %#x, %d",
                InternetMapStatus(dwStatus),
                lpBuffer,
                dwLength
                ));

    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
    DWORD error = ERROR_SUCCESS;

    //
    // the app can affect callback operation by specifying a zero context value
    // meaning no callbacks will be generated for this API
    //

    if (lpThreadInfo != NULL) 
    {

        INET_ASSERT(lpThreadInfo->hObject != NULL);
        INET_ASSERT(lpThreadInfo->hObjectMapped != NULL);

        //
        // if the context value in the thread info block is 0 then we use the
        // context from the handle object
        //

        DWORD_PTR context;

        context = ((INTERNET_HANDLE_BASE *)lpThreadInfo->hObjectMapped)->GetContext();

        WINHTTP_STATUS_CALLBACK appCallback;

        appCallback = ((INTERNET_HANDLE_BASE *)lpThreadInfo->hObjectMapped)->GetStatusCallback();

        IF_DEBUG(THRDINFO) 
        {
            switch (dwStatus) 
            {
                case WINHTTP_CALLBACK_STATUS_HEADERS_AVAILABLE:
                case WINHTTP_CALLBACK_STATUS_WRITE_COMPLETE:
                case WINHTTP_CALLBACK_STATUS_REQUEST_ERROR:
                    DEBUG_PRINT(THRDINFO,
                                INFO,
                                ("%s: dwResult = %#x, dwError = %d [%s]\n",
                                InternetMapStatus(dwStatus),
                                ((LPWINHTTP_ASYNC_RESULT)lpBuffer)->dwError,
                                InternetMapError(((LPWINHTTP_ASYNC_RESULT)lpBuffer)->dwError)
                                ));
                    break;
                case WINHTTP_CALLBACK_STATUS_DATA_AVAILABLE:
                case WINHTTP_CALLBACK_STATUS_READ_COMPLETE:
                    DEBUG_PRINT(THRDINFO,
                                INFO,
                                ("%s: Buffer = %p, Number of bytes = %d\n",
                                InternetMapStatus(dwStatus),
                                lpBuffer,
                                dwLength
                                ));
                    break;
            }

        }

        if ((appCallback != NULL) &&
            (((INTERNET_HANDLE_BASE *)lpThreadInfo->hObjectMapped)->IsNotificationEnabled(dwStatus)) )
        {
            LPVOID pInfo; //reported thru callback
            DWORD infoLength; //reported thru callback
            BOOL isAsyncWorkerThread;
            BYTE buffer[256];

            //
            // we make a copy of the info to remove the app's opportunity to
            // change it. E.g. if we were about to resolve host name "foo" and
            // passed the pointer to our buffer containing "foo", the app could
            // change the name to "bar", changing the intended server
            //

            if (lpBuffer != NULL) 
            {
                if (bConvertToUnicode)
                {
                    INET_ASSERT( ((INTERNET_HANDLE_BASE *)lpThreadInfo->hObjectMapped)->IsUnicodeStatusCallback() );

                    INET_ASSERT(    
                        (dwStatus == WINHTTP_CALLBACK_STATUS_RESOLVING_NAME)        || 
                        (dwStatus == WINHTTP_CALLBACK_STATUS_NAME_RESOLVED)         ||
                        (dwStatus == WINHTTP_CALLBACK_STATUS_REDIRECT)              ||
                        (dwStatus == WINHTTP_CALLBACK_STATUS_CONNECTING_TO_SERVER)  ||
                        (dwStatus == WINHTTP_CALLBACK_STATUS_CONNECTED_TO_SERVER)
                        );
                        
                    infoLength = MultiByteToWideChar(CP_ACP, 0, (LPSTR)lpBuffer,
                                                                dwLength, NULL, 0);
                    if (infoLength == 0)
                    {
                        pInfo = NULL;
                                
                        DEBUG_PRINT(THRDINFO,
                                    ERROR,
                                    ("MultiByteToWideChar returned 0 for a %d-length MBCS string\n",
                                    dwLength
                                    ));
                    }
                    else if (infoLength <= sizeof(buffer)/sizeof(WCHAR))
                    {
                        pInfo = buffer;
                    }
                    else
                    {
                        pInfo = (LPVOID)ALLOCATE_FIXED_MEMORY(infoLength * sizeof(WCHAR));
                    }
                    
                    if (pInfo)
                    {
                        infoLength = MultiByteToWideChar(CP_ACP, 0, (LPSTR)lpBuffer, 
                                                                dwLength, (LPWSTR)pInfo, infoLength);
                        if (infoLength == 0)
                        {
                            //MBtoWC failed
                            if (pInfo != buffer)
                                FREE_FIXED_MEMORY(pInfo);
                            pInfo = NULL;
                                
                            DEBUG_PRINT(THRDINFO,
                                        ERROR,
                                        ("MultiByteToWideChar returned 0 for a %d-length MBCS string\n",
                                        dwLength
                                        ));
                        }
                    } //pInfo
                    else
                    {
                        infoLength = 0;

                        DEBUG_PRINT(THRDINFO,
                                    ERROR,
                                    ("MultiByteToWideChar() error OR Failed to allocate %d bytes for info\n",
                                    dwLength
                                    ));

                    } //pInfo == NULL
                } //bConvertToUnicode
                else if (bCopyBuffer)
                {
                    if (dwLength <= sizeof(buffer))
                        pInfo = buffer;
                    else
                        pInfo = (LPVOID)ALLOCATE_FIXED_MEMORY(dwLength);

                    if (pInfo)
                    {
                        memcpy(pInfo, lpBuffer, dwLength);
                        infoLength = dwLength;
                    }
                    else 
                    {
                        infoLength = 0;

                        DEBUG_PRINT(THRDINFO,
                                    ERROR,
                                    ("Failed to allocate %d bytes for info\n",
                                    dwLength
                                    ));

                    }
                } //bCopyBuffer
                else
                {
                    pInfo = lpBuffer;
                    infoLength = dwLength;

                    INET_ASSERT(dwLength);
                } //!bCopyBuffer && !bConvertToUnicode
            } //lpBuffer != NULL
            else 
            {
                pInfo = NULL;
                infoLength = 0;
            }

            //
            // we're about to call into the app. We may be in the context of an
            // async worker thread, and if the callback submits an async request
            // then we'll execute it synchronously. To avoid this, we will reset
            // the async worker thread indicator in the INTERNET_THREAD_INFO and
            // restore it when the app returns control to us. This way, if the
            // app makes an API request during the callback, on a handle that
            // has async I/O semantics, then we will simply queue it, and not
            // try to execute it synchronously
            //

            isAsyncWorkerThread = lpThreadInfo->IsAsyncWorkerThread;
            lpThreadInfo->IsAsyncWorkerThread = FALSE;

            BOOL bInCallback = lpThreadInfo->InCallback;

            lpThreadInfo->InCallback = TRUE;

            INET_ASSERT(!IsBadCodePtr((FARPROC)appCallback));

            DEBUG_ENTER((DBG_THRDINFO,
                         None,
                         "(*callback)",
                         "%#x, %#x, %s (%d), %#x [%#x], %d",
                         lpThreadInfo->hObject,
                         context,
                         InternetMapStatus(dwStatus),
                         dwStatus,
                         pInfo,
                         ((dwStatus == WINHTTP_CALLBACK_STATUS_HANDLE_CREATED)
                         || (dwStatus == WINHTTP_CALLBACK_STATUS_HANDLE_CLOSING))
                            ? (DWORD_PTR)*(LPHINTERNET)pInfo
                            : (((dwStatus == WINHTTP_CALLBACK_STATUS_REQUEST_SENT)
                            || (dwStatus == WINHTTP_CALLBACK_STATUS_RESPONSE_RECEIVED)
                            || (dwStatus == WINHTTP_CALLBACK_STATUS_INTERMEDIATE_RESPONSE))
                                ? *(LPDWORD)pInfo
                                : 0),
                         infoLength
                         ));

            PERF_LOG(PE_APP_CALLBACK_START,
                     dwStatus,
                     lpThreadInfo->ThreadId,
                     lpThreadInfo->hObject
                     );

            HINTERNET hObject = lpThreadInfo->hObject;
            LPVOID hObjectMapped = lpThreadInfo->hObjectMapped;

            appCallback(lpThreadInfo->hObject,
                        context,
                        dwStatus,
                        pInfo,
                        infoLength
                        );

            lpThreadInfo->hObject = hObject;
            lpThreadInfo->hObjectMapped = hObjectMapped;

            PERF_LOG(PE_APP_CALLBACK_END,
                     dwStatus,
                     lpThreadInfo->ThreadId,
                     lpThreadInfo->hObject
                     );

            DEBUG_LEAVE(0);

            lpThreadInfo->InCallback = bInCallback;
            lpThreadInfo->IsAsyncWorkerThread = isAsyncWorkerThread;

            //
            // free the buffer
            //

            // We should free the memory only if we have done an ALLOCATE_FIXED_MEMORY in this function:
            if (pInfo != NULL && pInfo != lpBuffer && pInfo != buffer) {
                FREE_FIXED_MEMORY(pInfo);
            }
        } else {

            DEBUG_PRINT(THRDINFO,
                        ERROR,
                        ("%#x: callback = %#x, context = %#x\n",
                        lpThreadInfo->hObject,
                        appCallback,
                        context
                        ));

            //
            // if we're completing a request then we shouldn't be here - it
            // means we lost the context or callback address somewhere along the
            // way
            //

            // don't need the ASSERTS below.
            // It could also mean something as benign as the notification not being enabled:
            /*
            INET_ASSERT(
                    dwStatus != WINHTTP_CALLBACK_STATUS_HEADERS_AVAILABLE
                &&  dwStatus != WINHTTP_CALLBACK_STATUS_WRITE_COMPLETE
                &&  dwStatus != WINHTTP_CALLBACK_STATUS_REQUEST_ERROR
                &&  dwStatus != WINHTTP_CALLBACK_STATUS_DATA_AVAILABLE
                &&  dwStatus != WINHTTP_CALLBACK_STATUS_READ_COMPLETE
                );
            */

#ifdef DEBUG
            if ( 
                    dwStatus == WINHTTP_CALLBACK_STATUS_HEADERS_AVAILABLE
                ||  dwStatus == WINHTTP_CALLBACK_STATUS_WRITE_COMPLETE
                ||  dwStatus == WINHTTP_CALLBACK_STATUS_REQUEST_ERROR
                ||  dwStatus == WINHTTP_CALLBACK_STATUS_DATA_AVAILABLE
                ||  dwStatus == WINHTTP_CALLBACK_STATUS_READ_COMPLETE
            )
            {
                INET_ASSERT(appCallback != NULL);
                /*
                    These are not valid asserts in winhttp.
                    Contexts don't control whether callbacks are made or not.
                 */
                //INET_ASSERT(context != NULL);
                //INET_ASSERT(_InternetGetContext(lpThreadInfo) != NULL);
            }
#endif


        }
        
        //
        // if the object is now invalid then the app closed the handle in
        // the callback, or from an external thread and the entire operation is cancelled
        // propagate this error back to calling code.
        //
        if (((HANDLE_OBJECT *)lpThreadInfo->hObjectMapped)->IsInvalidated()) 
        {
            error = ERROR_WINHTTP_OPERATION_CANCELLED;
        }
    } else {

        //
        // this is catastrophic if the indication was async request completion
        //

        DEBUG_PUT(("InternetIndicateStatus(): no INTERNET_THREAD_INFO?\n"));

    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
InternetSetLastError(
    IN DWORD ErrorNumber,
    IN LPSTR ErrorText,
    IN DWORD ErrorTextLength,
    IN DWORD Flags
    )

/*++

Routine Description:

    Copies the error text to the per-thread error buffer (moveable memory)

Arguments:

    ErrorNumber     - protocol-specific error code

    ErrorText       - protocol-specific error text (from server). The buffer is
                      NOT zero-terminated

    ErrorTextLength - number of characters in ErrorText

    Flags           - Flags that control how this function operates:

                        SLE_APPEND          TRUE if ErrorText is to be appended
                                            to the text already in the buffer

                        SLE_ZERO_TERMINATE  TRUE if ErrorText must have a '\0'
                                            appended to it

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - Win32 error

--*/

{
    DEBUG_ENTER((DBG_THRDINFO,
                Dword,
                "InternetSetLastError",
                "%d, %.80q, %d, %#x",
                ErrorNumber,
                ErrorText,
                ErrorTextLength,
                Flags
                ));

    DWORD error;
    LPINTERNET_THREAD_INFO lpThreadInfo;

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo != NULL) {
        error = _InternetSetLastError(lpThreadInfo,
                                      ErrorNumber,
                                      ErrorText,
                                      ErrorTextLength,
                                      Flags
                                      );
    } else {

        DEBUG_PUT(("InternetSetLastError(): no INTERNET_THREAD_INFO\n"));

        error = ERROR_WINHTTP_INTERNAL_ERROR;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
_InternetSetLastError(
    IN LPINTERNET_THREAD_INFO lpThreadInfo,
    IN DWORD ErrorNumber,
    IN LPSTR ErrorText,
    IN DWORD ErrorTextLength,
    IN DWORD Flags
    )

/*++

Routine Description:

    Sets or resets the last error text in an INTERNET_THREAD_INFO block

Arguments:

    lpThreadInfo    - pointer to INTERNET_THREAD_INFO

    ErrorNumber     - protocol-specific error code

    ErrorText       - protocol-specific error text (from server). The buffer is
                      NOT zero-terminated

    ErrorTextLength - number of characters in ErrorText

    Flags           - Flags that control how this function operates:

                        SLE_APPEND          TRUE if ErrorText is to be appended
                                            to the text already in the buffer

                        SLE_ZERO_TERMINATE  TRUE if ErrorText must have a '\0'
                                            appended to it

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - Win32 error

--*/

{
    DEBUG_ENTER((DBG_THRDINFO,
                Dword,
                "_InternetSetLastError",
                "%#x, %d, %.80q, %d, %#x",
                lpThreadInfo,
                ErrorNumber,
                ErrorText,
                ErrorTextLength,
                Flags
                ));

    DWORD currentLength;
    DWORD newTextLength;
    DWORD error;

    newTextLength = ErrorTextLength;

    //
    // if we are appending text, then account for the '\0' currently at the end
    // of the buffer (if it exists)
    //

    if (Flags & SLE_APPEND) {
        currentLength = lpThreadInfo->ErrorTextLength;
        if (currentLength != 0) {
            --currentLength;
        }
        newTextLength += currentLength;
    }

    if (Flags & SLE_ZERO_TERMINATE) {
        ++newTextLength;
    }

    //
    // expect success (and why not?)
    //

    error = ERROR_SUCCESS;

    //
    // allocate, grow or shrink the buffer to fit. The buffer is moveable. If
    // the buffer is being shrunk to zero size then NULL will be returned as
    // the buffer handle from ResizeBuffer()
    //

    lpThreadInfo->hErrorText = ResizeBuffer(lpThreadInfo->hErrorText,
                                            newTextLength,
                                            FALSE
                                            );
    if (lpThreadInfo->hErrorText != NULL) {

        LPSTR lpErrorText;

        lpErrorText = (LPSTR)LOCK_MEMORY(lpThreadInfo->hErrorText);

        INET_ASSERT(lpErrorText != NULL);

        if (lpErrorText != NULL) {
            if (Flags & SLE_APPEND) {
                lpErrorText += currentLength;
            }
            memcpy(lpErrorText, ErrorText, ErrorTextLength);
            if (Flags & SLE_ZERO_TERMINATE) {
                lpErrorText[ErrorTextLength++] = '\0';
            }

            //
            // the text should always be zero-terminated. We expect this in
            // InternetGetLastResponseInfo()
            //

            INET_ASSERT(lpErrorText[ErrorTextLength - 1] == '\0');

            UNLOCK_MEMORY(lpThreadInfo->hErrorText);

        } else {

            //
            // real error occurred - failed to lock memory?
            //

            error = GetLastError();
        }
    } else {

        INET_ASSERT(newTextLength == 0);

        newTextLength = 0;
    }

    //
    // set the error code and text length
    //

    lpThreadInfo->ErrorTextLength = newTextLength;
    lpThreadInfo->ErrorNumber = ErrorNumber;

    DEBUG_LEAVE(error);

    return error;
}


LPSTR
InternetLockErrorText(
    VOID
    )

/*++

Routine Description:

    Returns a pointer to the locked per-thread error text buffer

Arguments:

    None.

Return Value:

    LPSTR
        Success - pointer to locked buffer

        Failure - NULL

--*/

{
    LPINTERNET_THREAD_INFO lpThreadInfo;

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo != NULL) {

        HLOCAL lpErrorText;

        lpErrorText = lpThreadInfo->hErrorText;
        if (lpErrorText != (HLOCAL)NULL) {
            return (LPSTR)LOCK_MEMORY(lpErrorText);
        }
    }
    return NULL;
}

//
//VOID
//InternetUnlockErrorText(
//    VOID
//    )
//
///*++
//
//Routine Description:
//
//    Unlocks the per-thread error text buffer locked by InternetLockErrorText()
//
//Arguments:
//
//    None.
//
//Return Value:
//
//    None.
//
//--*/
//
//{
//    LPINTERNET_THREAD_INFO lpThreadInfo;
//
//    lpThreadInfo = InternetGetThreadInfo();
//
//    //
//    // assume that if we locked the error text, there must be an
//    // INTERNET_THREAD_INFO when we come to unlock it
//    //
//
//    INET_ASSERT(lpThreadInfo != NULL);
//
//    if (lpThreadInfo != NULL) {
//
//        HLOCAL hErrorText;
//
//        hErrorText = lpThreadInfo->hErrorText;
//
//        //
//        // similarly, there must be a handle to the error text buffer
//        //
//
//        INET_ASSERT(hErrorText != NULL);
//
//        if (hErrorText != (HLOCAL)NULL) {
//            UNLOCK_MEMORY(hErrorText);
//        }
//    }
//}


VOID
InternetSetObjectHandle(
    IN HINTERNET hInternet,
    IN HINTERNET hInternetMapped
    )

/*++

Routine Description:

    Sets the hObject field in the INTERNET_THREAD_INFO structure so we can get
    at the handle contents, even when we're in a function that does not take
    the hInternet as a parameter

Arguments:

    hInternet       - handle of object we may need info from

    hInternetMapped - mapped handle of object we may need info from

Return Value:

    None.

--*/

{
    LPINTERNET_THREAD_INFO lpThreadInfo;

    lpThreadInfo = InternetGetThreadInfo();

    if (lpThreadInfo != NULL) {
        _InternetSetObjectHandle(lpThreadInfo, hInternet, hInternetMapped);
    }
}


HINTERNET
InternetGetObjectHandle(
    VOID
    )

/*++

Routine Description:

    Just returns the hObject value stored in our INTERNET_THREAD_INFO

Arguments:

    None.

Return Value:

    HINTERNET
        Success - non-NULL handle value

        Failure - NULL object handle (may not have been set)

--*/

{
    LPINTERNET_THREAD_INFO lpThreadInfo;
    HINTERNET hInternet;

    lpThreadInfo = InternetGetThreadInfo();

    if (lpThreadInfo != NULL) {
        hInternet = lpThreadInfo->hObject;
    } else {
        hInternet = NULL;
    }
    return hInternet;
}


HINTERNET
InternetGetMappedObjectHandle(
    VOID
    )

/*++

Routine Description:

    Just returns the hObjectMapped value stored in our INTERNET_THREAD_INFO

Arguments:

    None.

Return Value:

    HINTERNET
        Success - non-NULL handle value

        Failure - NULL object handle (may not have been set)

--*/

{
    LPINTERNET_THREAD_INFO lpThreadInfo;
    HINTERNET hInternet;

    lpThreadInfo = InternetGetThreadInfo();

    if (lpThreadInfo != NULL) {
        hInternet = lpThreadInfo->hObjectMapped;
    } else {
        hInternet = NULL;
    }
    return hInternet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\auth\basic.cxx ===
#include <wininetp.h>
#include <splugin.hxx>
#include "htuu.h"

/*---------------------------------------------------------------------------
BASIC_CTX
---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------
    Constructor
---------------------------------------------------------------------------*/
BASIC_CTX::BASIC_CTX(HTTP_REQUEST_HANDLE_OBJECT *pRequest, BOOL fIsProxy, 
                    SPMData* pSPM, AUTH_CREDS* pCreds)
    : AUTHCTX(pSPM, pCreds)
{
    _fIsProxy = fIsProxy;
    _pRequest = pRequest;
}


/*---------------------------------------------------------------------------
    Destructor
---------------------------------------------------------------------------*/
BASIC_CTX::~BASIC_CTX()
{}


/*---------------------------------------------------------------------------
    PreAuthUser
---------------------------------------------------------------------------*/
DWORD BASIC_CTX::PreAuthUser(IN LPSTR pBuf, IN OUT LPDWORD pcbBuf)
{
    if (!_pCreds->lpszUser || !_pCreds->lpszPass)
        return ERROR_INVALID_PARAMETER;
            
    // Prefix the header value with the auth type.
    const static BYTE szBasic[] = "Basic ";

    #define BASIC_LEN sizeof(szBasic)-1

    memcpy (pBuf, szBasic, BASIC_LEN);
    pBuf += BASIC_LEN;

    DWORD cbUserLen = _pCreds->lpszUser ? strlen(_pCreds->lpszUser) : 0;
    DWORD cbPassLen = _pCreds->lpszPass ? strlen(_pCreds->lpszPass) : 0;
    
    // Generate rest of header value by uuencoding user:pass.
    DWORD cbMaxUserPathLen = cbUserLen + 1 + cbPassLen + 1 
        + 2;    // HTUU_encode() parse the buffer 3 bytes at a time; 
                // In the worst case we will be two bytes short, so add 2 here. 
                // longer buffer doesn't matter, HTUU_encode will adjust appropreiately.
    
    LPSTR pszUserPass = New CHAR[cbMaxUserPathLen];
    if (pszUserPass)
    {
        DWORD cbUserPass;
    
        cbUserPass = wsprintf(pszUserPass, "%s:%s", _pCreds->lpszUser, _pCreds->lpszPass);
        
        INET_ASSERT (cbUserPass < cbMaxUserPathLen);
    
        HTUU_encode ((PBYTE) pszUserPass, cbUserPass,
            pBuf, *pcbBuf);
    
        delete [] pszUserPass;
    
        *pcbBuf = BASIC_LEN + lstrlen (pBuf);
        
        _pvContext = (LPVOID) 1;
        return ERROR_SUCCESS;
    }
    else
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
}

/*---------------------------------------------------------------------------
    UpdateFromHeaders
---------------------------------------------------------------------------*/
DWORD BASIC_CTX::UpdateFromHeaders(HTTP_REQUEST_HANDLE_OBJECT *pRequest, BOOL fIsProxy)
{
    DWORD dwAuthIdx, cbRealm, dwError;
    LPSTR szRealm = NULL;
    
    // Get the associated header.
    if ((dwError = FindHdrIdxFromScheme(&dwAuthIdx)) != ERROR_SUCCESS)
        goto exit;

    // Get any realm.
    dwError = GetAuthHeaderData(pRequest, fIsProxy, "Realm", 
        &szRealm, &cbRealm, ALLOCATE_BUFFER, dwAuthIdx);

    // No realm is OK.
    if (dwError != ERROR_SUCCESS)
        szRealm = NULL;

    // If we already have a Creds, ensure that the realm matches. If not,
    // find or create a new one and set it in the auth context.
    if (_pCreds)
    {
        INET_ASSERT(_pCreds->lpszRealm);
        if (/*_pCreds->lpszRealm && */szRealm && lstrcmp(_pCreds->lpszRealm, szRealm))
        {
            // Realms don't match - create a new Creds entry, release the old.
            delete _pCreds;
            _pCreds = CreateCreds(pRequest, fIsProxy, _pSPMData, szRealm);
            INET_ASSERT(_pCreds->pSPM == _pSPMData);
        }
    }
    // If no password cache is set in the auth context,
    // find or create one and set it in the auth context.
    else
    {            
        // Find or create a password cache entry.
        _pCreds = CreateCreds(pRequest, fIsProxy, _pSPMData, szRealm);
        if (!_pCreds)
        {
            dwError = ERROR_WINHTTP_INTERNAL_ERROR;
            goto exit;
        }
        INET_ASSERT(_pCreds->pSPM == _pSPMData);
        // _pCreds->nLockCount++;
    }

    if (!_pCreds)
    {
        INET_ASSERT(FALSE);
        dwError = ERROR_WINHTTP_INTERNAL_ERROR;
        goto exit;
    }

    dwError = ERROR_SUCCESS;
        
    exit:

    if (szRealm)
        delete []szRealm;

    return dwError;
}


/*---------------------------------------------------------------------------
    PostAuthUser
---------------------------------------------------------------------------*/
DWORD BASIC_CTX::PostAuthUser()
{
    DWORD dwRet;

    if (! _pvContext && !_pRequest->GetCreds() 
        && _pCreds->lpszUser && _pCreds->lpszPass)
        dwRet = ERROR_WINHTTP_FORCE_RETRY;
    else
        dwRet = ERROR_WINHTTP_INCORRECT_PASSWORD;

    _pRequest->SetCreds(NULL);
    _pvContext = (LPVOID) 1;
    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\auth\digest.cxx ===
#include <wininetp.h>
#include <splugin.hxx>
#include <security.h>
#include "auth.h"

#define SSP_SPM_NT_DLL      "security.dll"

#define MAX_SILENT_RETRIES  3
#define OUTPUT_BUFFER_LEN   10000

#define HEADER_IDX          0
#define REALM_IDX           1
#define HOST_IDX            2
#define URL_IDX             3
#define METHOD_IDX          4
#define USER_IDX            5
#define PASS_IDX            6
#define NONCE_IDX           7
#define NC_IDX              8
#define HWND_IDX            9
#define NUM_BUFF            10

#define ISC_MODE_AUTH        0
#define ISC_MODE_PREAUTH     1
#define ISC_MODE_UI          2

struct DIGEST_PKG_DATA
{
    LPSTR szAppCtx;
    LPSTR szUserCtx;
};

/*-----------------------------------------------------------------------------
    DIGEST_CTX
-----------------------------------------------------------------------------*/

// Globals
PSecurityFunctionTable DIGEST_CTX::g_pFuncTbl = NULL;
CredHandle DIGEST_CTX::g_hCred;


/*---------------------------------------------------------------------------
DIGEST_CTX::GetFuncTbl
---------------------------------------------------------------------------*/
VOID DIGEST_CTX::GetFuncTbl()
{
    HINSTANCE hSecLib;
    INIT_SECURITY_INTERFACE addrProcISI = NULL;
    OSVERSIONINFO   VerInfo;

    VerInfo.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);

    GetVersionEx (&VerInfo);

    if (VerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
    {
        hSecLib = LoadLibrary (SSP_SPM_NT_DLL);
    }
        
    addrProcISI = (INIT_SECURITY_INTERFACE) GetProcAddress(hSecLib, 
                    SECURITY_ENTRYPOINT_ANSI);       
        
    g_pFuncTbl = (*addrProcISI)();
}

/*---------------------------------------------------------------------------
DIGEST_CTX::GetRequestUri
---------------------------------------------------------------------------*/
LPSTR DIGEST_CTX::GetRequestUri()
{
    LPSTR szUrl;
    DWORD cbUrl;

    URL_COMPONENTS sUrl;        

    memset(&sUrl, 0, sizeof(sUrl));
    sUrl.dwStructSize = sizeof(sUrl);
    sUrl.dwHostNameLength = -1; 
    sUrl.dwUrlPathLength = -1; 
    sUrl.dwExtraInfoLength = -1; 

    szUrl = _pRequest->GetURL();

    // Generate request-uri
    if (WinHttpCrackUrlA(szUrl, strlen(szUrl), 0, &sUrl))
    {
        cbUrl = sUrl.dwUrlPathLength;
        szUrl = New CHAR[cbUrl+1];

        if (!szUrl)
        {
            // Alloc failure. Return NULL. We will
            // use _pRequest->GetURL instead.
            return NULL;
        }
    
        memcpy(szUrl, sUrl.lpszUrlPath, cbUrl);
        szUrl[cbUrl] = '\0';
    }
    else
    {
        // ICU failed. Return NULL which
        // will cause _pRequest->GetURL
        // to be used.
        return NULL;
    }

    return szUrl;
}


/*---------------------------------------------------------------------------
DIGEST_CTX::InitSecurityBuffers
---------------------------------------------------------------------------*/
VOID DIGEST_CTX::InitSecurityBuffers(LPSTR szOutBuf, DWORD cbOutBuf,
    LPDWORD pdwSecFlags, DWORD dwISCMode)
{
    // Input Buffer.    
    _SecBuffInDesc.cBuffers = NUM_BUFF;
    _SecBuffInDesc.pBuffers = _SecBuffIn;

    // Set Header
    _SecBuffIn[HEADER_IDX].pvBuffer     = _szData;
    _SecBuffIn[HEADER_IDX].cbBuffer     = _cbData;
    _SecBuffIn[HEADER_IDX].BufferType   = SECBUFFER_TOKEN;
    
    // If credentials are supplied will be set to
    // ISC_REQ_USE_SUPPLIED_CREDS.
    // If prompting for auth dialog will be set to
    // ISC_REQ_PROMPT_FOR_CREDS.
    *pdwSecFlags = 0;
    
    // Set realm if no header, otherwise NULL.
    if (_SecBuffIn[HEADER_IDX].pvBuffer)
    {
        _SecBuffIn[REALM_IDX].pvBuffer  = NULL;
        _SecBuffIn[REALM_IDX].cbBuffer  = 0;
    }
    else
    {
        // We are preauthenticating using the realm
        _SecBuffIn[REALM_IDX].pvBuffer = _pCreds->lpszRealm;
        _SecBuffIn[REALM_IDX].cbBuffer = strlen(_pCreds->lpszRealm);
    }
    
    // Host.
    _SecBuffIn[HOST_IDX].pvBuffer     = _pCreds->lpszHost;
    _SecBuffIn[HOST_IDX].cbBuffer     = strlen(_pCreds->lpszHost);
    _SecBuffIn[HOST_IDX].BufferType   = SECBUFFER_TOKEN;

    
    // Request URI.    
    if (!_szRequestUri)
    {
        _szRequestUri = GetRequestUri();
        if (_szRequestUri)
            _SecBuffIn[URL_IDX].pvBuffer     = _szRequestUri;
        else
            _SecBuffIn[URL_IDX].pvBuffer = _pRequest->GetURL();
    }

    _SecBuffIn[URL_IDX].cbBuffer     = strlen((LPSTR) _SecBuffIn[URL_IDX].pvBuffer);
    _SecBuffIn[URL_IDX].BufferType   = SECBUFFER_TOKEN;


    // HTTP method.
    _SecBuffIn[METHOD_IDX].cbBuffer = 
        MapHttpMethodType(_pRequest->GetMethodType(), (LPCSTR*) &_SecBuffIn[METHOD_IDX].pvBuffer);
    _SecBuffIn[METHOD_IDX].BufferType   = SECBUFFER_TOKEN;

    // User and pass might be provided from Creds entry. Use only if
    // we have a challenge header (we don't pre-auth using supplied creds).
    if (dwISCMode == ISC_MODE_AUTH && _pCreds->lpszUser && *_pCreds->lpszUser 
        && _pCreds->lpszPass && *_pCreds->lpszPass)
    {
        // User.
        _SecBuffIn[USER_IDX].pvBuffer     = _pCreds->lpszUser;
        _SecBuffIn[USER_IDX].cbBuffer     = strlen(_pCreds->lpszUser);
        _SecBuffIn[USER_IDX].BufferType   = SECBUFFER_TOKEN;

        // Pass.
        _SecBuffIn[PASS_IDX].pvBuffer     = _pCreds->lpszPass;
        _SecBuffIn[PASS_IDX].cbBuffer     = strlen(_pCreds->lpszPass);
        _SecBuffIn[PASS_IDX].BufferType   = SECBUFFER_TOKEN;
        *pdwSecFlags = ISC_REQ_USE_SUPPLIED_CREDS;
    }
    else
    {
        // User.
        _SecBuffIn[USER_IDX].pvBuffer     = NULL;  
        _SecBuffIn[USER_IDX].cbBuffer     = 0;
        _SecBuffIn[USER_IDX].BufferType   = SECBUFFER_TOKEN;

        // Pass.
        _SecBuffIn[PASS_IDX].pvBuffer     = NULL;
        _SecBuffIn[PASS_IDX].cbBuffer     = 0;
        _SecBuffIn[PASS_IDX].BufferType   = SECBUFFER_TOKEN;
    }

    if (dwISCMode == ISC_MODE_UI)
        *pdwSecFlags = ISC_REQ_PROMPT_FOR_CREDS;
        
    // Out Buffer.
    _SecBuffOutDesc.cBuffers    = 1;
    _SecBuffOutDesc.pBuffers    = _SecBuffOut;
    _SecBuffOut[0].pvBuffer     = szOutBuf;
    _SecBuffOut[0].cbBuffer     = cbOutBuf;
    _SecBuffOut[0].BufferType   = SECBUFFER_TOKEN;
}


/*---------------------------------------------------------------------------
    Constructor
---------------------------------------------------------------------------*/
DIGEST_CTX::DIGEST_CTX(HTTP_REQUEST_HANDLE_OBJECT *pRequest, BOOL fIsProxy,
                 SPMData *pSPM, AUTH_CREDS* pCreds)
    : AUTHCTX(pSPM, pCreds)
{
    SECURITY_STATUS ssResult;
    _fIsProxy = fIsProxy;
    _pRequest = pRequest;

    _szAlloc      = NULL;
    _szData       = NULL;
    _pvContext    = NULL;
    _szRequestUri = NULL;
    _cbData       = 0;
    _cbContext    = 0;
    _nRetries     = 0;
    
    
    // Zero out the security buffers and request context.
    memset(&_SecBuffInDesc,  0, sizeof(_SecBuffInDesc));
    memset(&_SecBuffOutDesc, 0, sizeof(_SecBuffInDesc));
    memset(_SecBuffIn,       0, sizeof(_SecBuffIn));
    memset(_SecBuffOut,      0, sizeof(_SecBuffOut));
    memset(&_hCtxt,          0, sizeof(_hCtxt));
        
    // Is this the first time that the digest SSPI package
    // is being called for this process.
    if (!g_pFuncTbl)
    {
        // Get the global SSPI dispatch table.
        GetFuncTbl();

        DIGEST_PKG_DATA             PkgData;
        SEC_WINNT_AUTH_IDENTITY_EXA SecIdExA;

        // Logon with szAppCtx = szUserCtx = NULL.
        PkgData.szAppCtx = PkgData.szUserCtx = NULL;
        memset(&SecIdExA, 0, sizeof(SEC_WINNT_AUTH_IDENTITY_EXA));

        SecIdExA.Version = sizeof(SEC_WINNT_AUTH_IDENTITY_EXA);
        SecIdExA.User = (unsigned char*) &PkgData;
        SecIdExA.UserLength = sizeof(DIGEST_PKG_DATA);
        
        // Get the global credentials handle.
        ssResult = (*(g_pFuncTbl->AcquireCredentialsHandleA))
            (NULL, "Digest", SECPKG_CRED_OUTBOUND, NULL, &SecIdExA, NULL, 0, &g_hCred, NULL);
    }
}


/*---------------------------------------------------------------------------
DIGEST_CTX::PromptForCreds
---------------------------------------------------------------------------*/
DWORD DIGEST_CTX::PromptForCreds(HWND hWnd)
{
    SECURITY_STATUS ssResult;
        
    // Prompt for the credentials.
    INET_ASSERT(_pvContext);
    _cbContext = OUTPUT_BUFFER_LEN;

    DWORD sf;
    InitSecurityBuffers((LPSTR) _pvContext, _cbContext, &sf, ISC_MODE_UI);

    _SecBuffIn[HWND_IDX].pvBuffer = &hWnd;
    _SecBuffIn[HWND_IDX].cbBuffer = sizeof(HWND);

    ssResult = (*(g_pFuncTbl->InitializeSecurityContextA))(&g_hCred, &_hCtxt, NULL, sf, 
        0, 0, &_SecBuffInDesc, 0, &_hCtxt, &_SecBuffOutDesc, NULL, NULL);

    _cbContext = _SecBuffOutDesc.pBuffers[0].cbBuffer;    

    if (ssResult == SEC_E_NO_CREDENTIALS)
        return ERROR_CANCELLED;

    return (DWORD) ssResult;
}


/*---------------------------------------------------------------------------
    Destructor
---------------------------------------------------------------------------*/
DIGEST_CTX::~DIGEST_CTX()
{
    if (_szAlloc)
        delete _szAlloc;

    if (_pvContext)
        delete _pvContext;

    if (_szRequestUri)
        delete _szRequestUri;
}


/*---------------------------------------------------------------------------
    PreAuthUser
---------------------------------------------------------------------------*/
DWORD DIGEST_CTX::PreAuthUser(OUT LPSTR pBuff, IN OUT LPDWORD pcbBuff)
{
    SECURITY_STATUS ssResult = SEC_E_OK;
    INET_ASSERT(_pSPMData == _pCreds->pSPM);

    if (AuthLock())
    {
        // If a response has been generated copy into output buffer.
        if (_cbContext)
        {
            memcpy(pBuff, _pvContext, _cbContext);
            *pcbBuff = _cbContext;
        }
        // Otherwise attempt to preauthenticate.
        else
        {
            // Call into the SSPI package.
            DWORD sf;
            InitSecurityBuffers(pBuff, *pcbBuff, &sf, ISC_MODE_PREAUTH);

            ssResult = (*(g_pFuncTbl->InitializeSecurityContext))(&g_hCred, NULL, NULL, sf, 
                0, 0, &_SecBuffInDesc, 0, &_hCtxt, &_SecBuffOutDesc, NULL, NULL);

            *pcbBuff = _SecBuffOut[0].cbBuffer;
        }

        AuthUnlock();
    }
            
    return (DWORD) ssResult;
}

/*---------------------------------------------------------------------------
    UpdateFromHeaders
---------------------------------------------------------------------------*/
DWORD DIGEST_CTX::UpdateFromHeaders(HTTP_REQUEST_HANDLE_OBJECT *pRequest, BOOL fIsProxy)
{
    if (!AuthLock())
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    DWORD dwError, cbExtra, dwAuthIdx;
    LPSTR szAuthHeader, szExtra, szScheme;
    LPSTR szRealm; 
    DWORD cbRealm;
    
    // Get the associated header.
    if ((dwError = FindHdrIdxFromScheme(&dwAuthIdx)) != ERROR_SUCCESS)
        goto exit;

    // If this auth ctx does not have Creds then it has been
    // just been constructed in response to a 401.
    if (!_pCreds)
    {
        // Get any realm.
        dwError = GetAuthHeaderData(pRequest, fIsProxy, "Realm", 
            &szRealm, &cbRealm, ALLOCATE_BUFFER, dwAuthIdx);

        _pCreds = CreateCreds(pRequest, fIsProxy, _pSPMData, szRealm);
        
        if (pRequest->_pszRealm)
        {
            FREE_MEMORY(pRequest->_pszRealm);
        }
        pRequest->_pszRealm = szRealm;
        szRealm = NULL;

        if (_pCreds)
        {
            INET_ASSERT(_pCreds->pSPM == _pSPMData);
        }
        else
        {
            dwError = ERROR_WINHTTP_INTERNAL_ERROR;
            goto exit;
        }
    }

    // Updating the buffer - delete old one if necessary.
    if (_szAlloc)
    {
        delete _szAlloc;
        _szAlloc = _szData = NULL;
        _cbData = 0;
    }

    // Get the entire authentication header.
    dwError = GetAuthHeaderData(pRequest, fIsProxy, NULL,
        &_szAlloc, &_cbData, ALLOCATE_BUFFER, dwAuthIdx);
    
    if (dwError != ERROR_SUCCESS)
    {
        goto exit;
    }

    // Point just past scheme
    _szData = _szAlloc;
    while (*_szData != ' ')
    {
        _szData++;
        _cbData--;
    }

    // The request will be retried.
    dwError = ERROR_SUCCESS;

exit:
    AuthUnlock();
    return dwError;
}



/*---------------------------------------------------------------------------
    PostAuthUser
---------------------------------------------------------------------------*/
DWORD DIGEST_CTX::PostAuthUser()
{
    if (!AuthLock())
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    INET_ASSERT(_pSPMData == _pCreds->pSPM);

    DWORD dwError;
    SECURITY_STATUS ssResult;

    // Allocate an output buffer if not done so already.
    if (!_pvContext)
    {
        _pvContext = New CHAR[OUTPUT_BUFFER_LEN];
        if (!_pvContext)
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }
    }

    _cbContext = OUTPUT_BUFFER_LEN;


    if (_nRetries++ < MAX_SILENT_RETRIES)
    {
        // If we pre-authenticated, treat as second
        // or subsequent attempt. We depend on the
        // server correctly sending stale=FALSE (or no stale)
        // if the credentials sent during pre-auth were bad.
        // In this case the digest pkg will return SEC_E_NO_CREDENTIALS
        // and we will prompt for credentials.
        // BUGBUG - Use ApplyControlToken
        if (_nRetries == 1 && _pRequest->GetCreds())
        {
            // Increment num of retries to 2
            _nRetries++;

            // The dwLower member has to have the correct value
            // so that secur32.dll can route to correct provider.
            _hCtxt.dwLower = g_hCred.dwLower;
        }

        // Call into the SSPI package.

        DWORD sf;
        InitSecurityBuffers((LPSTR) _pvContext, _cbContext, &sf, ISC_MODE_AUTH);
        ssResult = (*(g_pFuncTbl->InitializeSecurityContext))
            (&g_hCred, (_nRetries == 1 ? NULL : &_hCtxt), NULL, sf, 
            0, 0, &_SecBuffInDesc, 0, &_hCtxt, &_SecBuffOutDesc, NULL, NULL);
        _cbContext = _SecBuffOutDesc.pBuffers[0].cbBuffer;
        
        switch(ssResult)
        {
            case SEC_E_OK:
            {
                dwError = ERROR_WINHTTP_FORCE_RETRY;
                break;
            }
            case SEC_E_NO_CREDENTIALS:
            {
                dwError = ERROR_WINHTTP_INCORRECT_PASSWORD;
                break;
            }
            default:
                dwError = ERROR_WINHTTP_LOGIN_FAILURE;
        }
    }
    else
    {
        _cbContext = 0;
        _nRetries = 0;
        dwError = ERROR_WINHTTP_INCORRECT_PASSWORD;
    }

exit:
    _pRequest->SetCreds(NULL);
    AuthUnlock();
    return dwError;
}

/*---------------------------------------------------------------------------
    Flush creds
---------------------------------------------------------------------------*/
VOID DIGEST_CTX::FlushCreds()
{
    DWORD ssResult;
    if (g_pFuncTbl)
    {
        DWORD sf = ISC_REQ_NULL_SESSION;
        ssResult = (*(g_pFuncTbl->InitializeSecurityContext))(&g_hCred, NULL, NULL, sf, 
            0, 0, NULL, 0, NULL, NULL, NULL, NULL);
    }
}

/*---------------------------------------------------------------------------
    Logoff
---------------------------------------------------------------------------*/
VOID DIGEST_CTX::Logoff()
{
    DWORD ssResult;
    if (g_pFuncTbl)
    {
        ssResult = (*(g_pFuncTbl->FreeCredentialsHandle))(&g_hCred);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\auth\htuu.h ===
/*
   This file was derived from the libwww code, version 2.15, from CERN.
   A number of modifications have been made by Spyglass.

   eric@spyglass.com
 */

/*                              ENCODING TO PRINTABLE CHARACTERS

   File module provides functions HTUU_encode() and HTUU_decode() which convert a buffer
   of bytes to/from RFC 1113 printable encoding format. This technique is similar to the
   familiar Unix uuencode format in that it maps 6 binary bits to one ASCII character (or
   more aptly, 3 binary bytes to 4 ASCII characters).  However, RFC 1113 does not use the
   same mapping to printable characters as uuencode.

	Ported to WinINet Plug In DLL by arthurbi Dec-23-1995

 */

#ifndef HTUU_H
#define HTUU_H

#ifdef __cplusplus
extern "C" {
#endif

int HTUU_encode(unsigned char *bufin,
				unsigned int nbytes,
				char *bufcoded,
                long outbufmax);

int HTUU_decode(char *bufcoded,
				unsigned char *bufplain,
				int outbufsize);

#ifdef __cplusplus
} // end extern "C"
#endif

#endif
/*

   End of file.  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\auth\htuu.c ===
/*
   This file was derived from the libwww code, version 2.15, from CERN.
   A number of modifications have been made by Spyglass.

   eric@spyglass.com

   This file was removed from LibWWW and placed into the
   Security Protocol Module.

   jeff@spyglass.com
 */

/* MODULE                           HTUU.c
   **           UUENCODE AND UUDECODE
   **
   ** ACKNOWLEDGEMENT:
   **   This code is taken from rpem distribution, and was originally
   **   written by Mark Riordan.
   **
   ** AUTHORS:
   **   MR  Mark Riordan    riordanmr@clvax1.cl.msu.edu
   **   AL  Ari Luotonen    luotonen@dxcern.cern.ch
   **
   ** HISTORY:
   **   Added as part of the WWW library and edited to conform
   **   with the WWW project coding standards by:   AL  5 Aug 1993
   **   Originally written by:              MR 12 Aug 1990
   **   Original header text:
   ** -------------------------------------------------------------
   **  File containing routines to convert a buffer
   **  of bytes to/from RFC 1113 printable encoding format.
   **
   **  This technique is similar to the familiar Unix uuencode
   **  format in that it maps 6 binary bits to one ASCII
   **  character (or more aptly, 3 binary bytes to 4 ASCII
   **  characters).  However, RFC 1113 does not use the same
   **  mapping to printable characters as uuencode.
   **
   **  Mark Riordan   12 August 1990 and 17 Feb 1991.
   **  This code is hereby placed in the public domain.
   ** -------------------------------------------------------------
   **
   ** BUGS:
   **
   **
 */


const static char six2pr[64] =
{
	'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
	'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
	'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
	'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
	'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'
};

static unsigned char pr2six[256];


/*--- function HTUU_encode -----------------------------------------------
 *
 *   Encode a single line of binary data to a standard format that
 *   uses only printing ASCII characters (but takes up 33% more bytes).
 *
 *    Entry    bufin    points to a buffer of bytes.  If nbytes is not
 *                      a multiple of three, then the byte just beyond
 *                      the last byte in the buffer must be 0.
 *             nbytes   is the number of bytes in that buffer.
 *                      This cannot be more than 48.
 *             bufcoded points to an output buffer.  Be sure that this
 *                      can hold at least 1 + (4*nbytes)/3 characters.
 *             outbufmax maximum size of the buffer bufcoded.
 *
 *    Exit     bufcoded contains the coded line.  The first 4*nbytes/3 bytes
 *                      contain printing ASCII characters representing
 *                      those binary bytes. This may include one or
 *                      two '=' characters used as padding at the end.
 *                      The last byte is a zero byte.
 *             Returns the number of ASCII characters in "bufcoded".
 */
int HTUU_encode(unsigned char *bufin, unsigned int nbytes, char *bufcoded,
                long outbufmax)
{
/* ENC is the basic 1 character encoding function to make a char printing */
#define ENC(c) six2pr[c]

	register char *outptr = bufcoded;
	unsigned int i;

	for (i = 0; i < nbytes; i += 3)
	{
        if ( (outptr - bufcoded + 4) > outbufmax )
            return (-1);

		*(outptr++) = ENC(*bufin >> 2);		/* c1 */
		*(outptr++) = ENC(((*bufin << 4) & 060) | ((bufin[1] >> 4) & 017));		/*c2 */
		*(outptr++) = ENC(((bufin[1] << 2) & 074) | ((bufin[2] >> 6) & 03));	/*c3 */
		*(outptr++) = ENC(bufin[2] & 077);	/* c4 */

		bufin += 3;
	}

	/* If nbytes was not a multiple of 3, then we have encoded too
	 * many characters.  Adjust appropriately.
	 */
	if (i == nbytes + 1)
	{
		/* There were only 2 bytes in that last group */
		outptr[-1] = '=';
	}
	else if (i == nbytes + 2)
	{
		/* There was only 1 byte in that last group */
		outptr[-1] = '=';
		outptr[-2] = '=';
	}

    if ( (outptr - bufcoded) + 1 < outbufmax )
    	*outptr = '\0';

	return ((int)(outptr - bufcoded));
}


/*--- function HTUU_decode ------------------------------------------------
 *
 *  Decode an ASCII-encoded buffer back to its original binary form.
 *
 *    Entry    bufcoded    points to a uuencoded string.  It is 
 *                         terminated by any character not in
 *                         the printable character table six2pr, but
 *                         leading whitespace is stripped.
 *             bufplain    points to the output buffer; must be big
 *                         enough to hold the decoded string (generally
 *                         shorter than the encoded string) plus
 *                         as many as two extra bytes used during
 *                         the decoding process.
 *             outbufsize  is the maximum number of bytes that
 *                         can fit in bufplain.
 *
 *    Exit     Returns the number of binary bytes decoded.
 *             bufplain    contains these bytes.
 */
int HTUU_decode(char *bufcoded, unsigned char *bufplain, int outbufsize)
{
/* single character decode */
#define DEC(c) pr2six[(int)c]
#define MAXVAL 63

	static int first = 1;

	int nbytesdecoded, j;
	register char *bufin = bufcoded;
	register unsigned char *bufout = bufplain;
	register int nprbytes;

	/* If this is the first call, initialize the mapping table.
	 * This code should work even on non-ASCII machines.
	 */
	if (first)
	{
		first = 0;
		for (j = 0; j < 256; j++)
			pr2six[j] = MAXVAL + 1;

		for (j = 0; j < 64; j++)
			pr2six[(int) six2pr[j]] = (unsigned char) j;
#if 0
		pr2six['A'] = 0;
		pr2six['B'] = 1;
		pr2six['C'] = 2;
		pr2six['D'] = 3;
		pr2six['E'] = 4;
		pr2six['F'] = 5;
		pr2six['G'] = 6;
		pr2six['H'] = 7;
		pr2six['I'] = 8;
		pr2six['J'] = 9;
		pr2six['K'] = 10;
		pr2six['L'] = 11;
		pr2six['M'] = 12;
		pr2six['N'] = 13;
		pr2six['O'] = 14;
		pr2six['P'] = 15;
		pr2six['Q'] = 16;
		pr2six['R'] = 17;
		pr2six['S'] = 18;
		pr2six['T'] = 19;
		pr2six['U'] = 20;
		pr2six['V'] = 21;
		pr2six['W'] = 22;
		pr2six['X'] = 23;
		pr2six['Y'] = 24;
		pr2six['Z'] = 25;
		pr2six['a'] = 26;
		pr2six['b'] = 27;
		pr2six['c'] = 28;
		pr2six['d'] = 29;
		pr2six['e'] = 30;
		pr2six['f'] = 31;
		pr2six['g'] = 32;
		pr2six['h'] = 33;
		pr2six['i'] = 34;
		pr2six['j'] = 35;
		pr2six['k'] = 36;
		pr2six['l'] = 37;
		pr2six['m'] = 38;
		pr2six['n'] = 39;
		pr2six['o'] = 40;
		pr2six['p'] = 41;
		pr2six['q'] = 42;
		pr2six['r'] = 43;
		pr2six['s'] = 44;
		pr2six['t'] = 45;
		pr2six['u'] = 46;
		pr2six['v'] = 47;
		pr2six['w'] = 48;
		pr2six['x'] = 49;
		pr2six['y'] = 50;
		pr2six['z'] = 51;
		pr2six['0'] = 52;
		pr2six['1'] = 53;
		pr2six['2'] = 54;
		pr2six['3'] = 55;
		pr2six['4'] = 56;
		pr2six['5'] = 57;
		pr2six['6'] = 58;
		pr2six['7'] = 59;
		pr2six['8'] = 60;
		pr2six['9'] = 61;
		pr2six['+'] = 62;
		pr2six['/'] = 63;
#endif
	}

	/* Strip leading whitespace. */

	while (*bufcoded == ' ' || *bufcoded == '\t')
		bufcoded++;

	/* Figure out how many characters are in the input buffer.
	 * If this would decode into more bytes than would fit into
	 * the output buffer, adjust the number of input bytes downwards.
	 */
	bufin = bufcoded;
	while (pr2six[(int) *(bufin++)] <= MAXVAL) ;
	nprbytes = (int)(bufin - bufcoded) - 1;
	nbytesdecoded = ((nprbytes + 3) / 4) * 3;
	if (nbytesdecoded > outbufsize)
	{
		nprbytes = (outbufsize * 4) / 3;
	}

	bufin = bufcoded;

	while (nprbytes > 0)
	{
		*(bufout++) = (unsigned char) (DEC(*bufin) << 2 | DEC(bufin[1]) >> 4);
		*(bufout++) = (unsigned char) (DEC(bufin[1]) << 4 | DEC(bufin[2]) >> 2);
		*(bufout++) = (unsigned char) (DEC(bufin[2]) << 6 | DEC(bufin[3]));
		bufin += 4;
		nprbytes -= 4;
	}

	if (nprbytes & 03)
	{
		if (pr2six[(int) bufin[-2]] > MAXVAL)
		{
			nbytesdecoded -= 2;
		}
		else
		{
			nbytesdecoded -= 1;
		}
	}

	return (nbytesdecoded);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\auth\sspspm.cxx ===
/*#----------------------------------------------------------------------------
**
**  File:           sspspm.c
**
**  Synopsis:   Security Protocol Module for SSPI Authentication providers.
**                  
**      This module contains major funtions of the SEC_SSPI.DLL which 
**      allows the Internet Explorer to use SSPI providers for authentication.
**      The function exported to the Internet Explorer is Ssp_Load() which 
**      passes the address of the Ssp__DownCall() function to the Explorer.
**      Then the Explorer will call Ssp__DownCall() when it needs service from 
**      this SPM DLL.  The two major functions called by Ssp__DownCall() to 
**      service Explorer's request are Ssp__PreProcessRequest() and 
**      Ssp__ProcessResponse().  In brief, Ssp__PreProcessRequest() is 
**      called before the Explorer sends out a request which does not have 
**      any 'Authorization' header yet.  And Ssp__ProcessResponse() is called 
**      whenever the Explorer receives an 401 'Unauthorized' response from the 
**      server.  This SPM DLL supports all SSPI packages which are installed 
**      on the machine.
**
**      This SPM DLL is called by the Internet Explorer only for its
**      The Internet Explorer only calls this SPM DLL when it needs 
**      authentication data in its request/response. In other words, the 
**      Explorer never calls this SPM DLL when an authentication succeeded; 
**      it never calls this DLL when it decide to give up on a connection 
**      because of server response timeout.  Because of this fact, this SPM 
**      DLL never has sufficient information on the state of each server 
**      connection; it only know its state based on the content of the last 
**      request and the content of the current response. For this reason, this 
**      SPM DLL does not keep state information for each host it has visited 
**      unless the information is essential. 
**      The security context handle returned from the first call of  
**      InitializeSecurityContext() for NEGOTIATE message generation is 
**      always the identical for a SSPI package when the same server host is 
**      passed.  Since the server host name is always in the request/response
**      header, the only information essential in generating a NEGOTIATE or 
**      RESPONSE is already available in the header. So unlike most SSPI 
**      application, this DLL will not keep the security context handle which 
**      it received from the SSPI function calls. Whenever it needs to call 
**      the SSPI function for generating a RESPONSE, it will first call the 
**      SSPI function without the CHALLENGE to get a security context handle.
**      Then it calls the SSPI function again with the CHALLENGE to generate 
**      a RESPONSE.
**
**
**      Copyright (C) 1995  Microsoft Corporation.  All Rights Reserved.
**
**  Authors:        LucyC       Created                         25 Sept. 1995
**
**---------------------------------------------------------------------------*/
#include <wininetp.h>
#include <ntlmsp.h>
#include "sspspm.h"

//
// Global variable where all the SSPI Pkgs data is collected
//

SspData  *g_pSspData;


HINSTANCE g_hSecLib;

/*-----------------------------------------------------------------------------
**
**  Function:   SpmAddSSPIPkg
**
**  Synopsis:   This function adds a SSPI package to the SPM's package list.
**
**  Arguments:  pData - Points to the private SPM data structure containing 
**                      the package list and the package info.
**              pPkgName - package name
**              cbMaxToken - max size of security token
**
**  Returns:    The index in the package list where this new package is added.
**              If failed to add the new package, SSPPKG_ERROR is returned.
**
**  History:    LucyC       Created                             21 Oct. 1995
**
**---------------------------------------------------------------------------*/
static UCHAR
SpmAddSSPIPkg (
    SspData *pData, 
    LPTSTR   pPkgName,
    ULONG    cbMaxToken
    )
{
    if ( !(pData->PkgList[pData->PkgCnt] =
                        (SSPAuthPkg *)LocalAlloc(0, sizeof(SSPAuthPkg))))
    {
        return SSPPKG_ERROR;
    }

    if ( !(pData->PkgList[pData->PkgCnt]->pName = 
                        (LPSTR)LocalAlloc(0, lstrlen(pPkgName)+1)))
    {
        LocalFree(pData->PkgList[pData->PkgCnt]);
        pData->PkgList[pData->PkgCnt] = NULL;
        return SSPPKG_ERROR;
    }

    lstrcpy (pData->PkgList[pData->PkgCnt]->pName, pPkgName);
    pData->PkgList[ pData->PkgCnt ]->Capabilities = 0 ;

    pData->PkgList[ pData->PkgCnt ]->cbMaxToken = cbMaxToken;

    //
    // Determine if this package supports anything of interest to
    // us.
    //

    if ( lstrcmpi( pPkgName, NTLMSP_NAME_A ) == 0 )
    {
        //
        // NTLM supports the standard credential structure
        //

        pData->PkgList[ pData->PkgCnt ]->Capabilities |= SSPAUTHPKG_SUPPORT_NTLM_CREDS ;
    }
    else if ( lstrcmpi( pPkgName, "Negotiate" ) == 0 )
    {
        //
        // Negotiate supports that cred structure too
        //

        pData->PkgList[ pData->PkgCnt ]->Capabilities |= SSPAUTHPKG_SUPPORT_NTLM_CREDS ;

    }
    else
    {
        //
        // Add more comparisons here, eventually.
        //

        ;
    }

    pData->PkgCnt++;
    return (pData->PkgCnt - 1);
}

/*-----------------------------------------------------------------------------
**
**  Function:   SpmFreePkgList
**
**  Synopsis:   This function frees memory allocated for the package list. 
**
**  Arguments:  pData - Points to the private SPM data structure containing 
**                      the package list and the package info.
**
**  Returns:    void.
**
**  History:    LucyC       Created                             21 Oct. 1995
**
**---------------------------------------------------------------------------*/
static VOID
SpmFreePkgList (
    SspData *pData
    )
{
    int ii;

    for (ii = 0; ii < pData->PkgCnt; ii++)
    {
        LocalFree(pData->PkgList[ii]->pName);

        LocalFree(pData->PkgList[ii]);
    }

    LocalFree(pData->PkgList);
}


/*-----------------------------------------------------------------------------
**
**  Function:   Ssp__Unload
**
**  Synopsis:   This function is called by the Internet Explorer before 
**              the SPM DLL is unloaded from the memory.
**
**  Arguments:  fpUI - From Explorer for making all UI_SERVICE call
**              pvOpaqueOS - From Explorer for making all UI_SERVICE call
**              htspm - the SPM structure which contains the global data 
**                      storage for this SPM DLL.
**
**  Returns:    always returns SPM_STATUS_OK, which means successful.
**
**  History:    LucyC       Created                             25 Sept. 1995
**
**---------------------------------------------------------------------------*/
DWORD SSPI_Unload()
{
    if (!AuthLock())
    {
        return SPM_STATUS_INSUFFICIENT_BUFFER;
    }

    if (g_pSspData != NULL)
    {
        SpmFreePkgList(g_pSspData);
        LocalFree(g_pSspData);
        g_pSspData = NULL;
    }

    if (g_hSecLib)
    {
        FreeLibrary (g_hSecLib);
        g_hSecLib = NULL;
    }

    AuthUnlock();
        
    return SPM_STATUS_OK;
}

/*-----------------------------------------------------------------------------
**
**  Function:   SspSPM_InitData
**
**  Synopsis:   This function allocates and initializes global data structure 
**              of the SPM DLL.
**
**  Arguments:  
**
**  Returns:    Pointer to the allocated global data structure.
**
**  History:    LucyC       Created                             25 Sept. 1995
**
**---------------------------------------------------------------------------*/
LPVOID SSPI_InitGlobals(void)
{
    SspData *pData = NULL;
    OSVERSIONINFO   VerInfo;
    INIT_SECURITY_INTERFACE    addrProcISI = NULL;

    SECURITY_STATUS sstat;
    ULONG           ii, cntPkg;
    PSecPkgInfo     pPkgInfo = NULL;
    PSecurityFunctionTable    pFuncTbl = NULL;

    if (g_pSspData)
        return g_pSspData;

    static BOOL Initializing = FALSE;
    static BOOL Initialized = FALSE;
    
    if (InterlockedExchange((LPLONG)&Initializing, TRUE)) {
        while (!Initialized) {
            SleepEx(0, TRUE);
        }
        goto quit;
    }
    
    //
    // Initialize SSP SPM Global Data
    //

    VerInfo.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
    if (!GetVersionEx (&VerInfo))   // If this fails, something has gone wrong
    {
        goto quit;
    }

    if (VerInfo.dwPlatformId != VER_PLATFORM_WIN32_NT)
    {
        goto quit;
    }

    if (!(pData = (SspData *) LocalAlloc(0, sizeof(SspData))))    {
        
        goto quit;

    }

    //
    //  Keep these information in global SPM
    //
    ZeroMemory (pData, sizeof(SspData));

    //
    //  Load Security DLL
    //
    g_hSecLib = LoadLibrary (SSP_SPM_NT_DLL);
    if (g_hSecLib == NULL)
    {
        // This should never happen.
        LocalFree(pData);
        pData = NULL;
        goto Cleanup;
    }

    addrProcISI = (INIT_SECURITY_INTERFACE) GetProcAddress( g_hSecLib, 
                    SECURITY_ENTRYPOINT);       
    if (addrProcISI == NULL)
    {
        LocalFree(pData);
        pData = NULL;
        goto Cleanup;
    }

    //
    // Get the SSPI function table
    //
    pFuncTbl = (*addrProcISI)();

    //
    //  Get list of packages supported
    //
    sstat = (*(pFuncTbl->EnumerateSecurityPackages))(&cntPkg, &pPkgInfo);
    if (sstat != SEC_E_OK || pPkgInfo == NULL)
    {
        //
        // ??? Should we give up here ???
        // EnumerateSecurityPackage() failed
        //
        goto Cleanup;
    }

    if (cntPkg)
    {
        //
        //  Create the package list
        //
        if (!(pData->PkgList = (PSSPAuthPkg *)LocalAlloc(0, 
                                            cntPkg*sizeof(PSSPAuthPkg))))
        {
            goto Cleanup;
        }
    }

    for (ii = 0; ii < cntPkg; ii++)
    {
        //DebugTrace(SSPSPMID, "Found %s SSPI package\n", 
        //                     pPkgInfo[ii].Name);

        if (SpmAddSSPIPkg (pData, 
                           pPkgInfo[ii].Name,
                           pPkgInfo[ii].cbMaxToken
                           ) == SSPPKG_ERROR)
        {
            goto Cleanup;
        }
    }

    pData->pFuncTbl = pFuncTbl;
    pData->bKeepList = TRUE;

    if (pData->PkgCnt == 0)
    {
        goto Cleanup;
    }

    g_pSspData = pData;
    pData = NULL;

Cleanup:


    if( pPkgInfo != NULL )
    {
        //
        // Free buffer returned by the enumerate security package function
        //

        (*(pFuncTbl->FreeContextBuffer))(pPkgInfo);
    }

    if( pData != NULL )
    {
        SpmFreePkgList (pData);
    }

    if (g_hSecLib)
    {
        FreeLibrary (g_hSecLib);
        g_hSecLib = NULL;
    }


quit: 
    Initialized = TRUE;

    return (g_pSspData);
}

INT
GetPkgId(LPTSTR  lpszPkgName)
{
    int ii;

    if ( g_pSspData == NULL )
    {
        return -1;
    }
    
    if (!AuthLock())
    {
        return -1;
    }
    
    for (ii = 0; ii < g_pSspData->PkgCnt; ii++)
    {
        if (!lstrcmp(g_pSspData->PkgList[ii]->pName, lpszPkgName))
        {
            AuthUnlock();
            return(ii);
        }
    }

    AuthUnlock();
    return(-1);
}

DWORD
GetPkgCapabilities(
    INT Package
    )
{
    if (!AuthLock())
    {
        return 0;
    }
    
    DWORD dwCaps;
    if ( Package < g_pSspData->PkgCnt )
    {
        dwCaps = g_pSspData->PkgList[ Package ]->Capabilities ;
    }
    else
        dwCaps = 0 ;

    AuthUnlock();
    return dwCaps;
}

ULONG
GetPkgMaxToken(
    INT Package
    )
{
    if (!AuthLock())
    {
        return MAX_AUTH_MSG_SIZE;
    }
    
    ULONG dwMaxToken;

    if ( Package < g_pSspData->PkgCnt )
    {
        dwMaxToken = g_pSspData->PkgList[ Package ]->cbMaxToken;
    }
    else {
        // be compatible with old static buffer size
        dwMaxToken = MAX_AUTH_MSG_SIZE;
    }

    AuthUnlock();
    return dwMaxToken;
}

//
//  Calls to this function are serialized
//

DWORD_PTR SSPI_InitScheme (LPCSTR lpszScheme)
{
    int ii;

       if (!SSPI_InitGlobals())
           return 0;
           
       if (!AuthLock())
       {
           return 0;
       }
    //  Once initialized, check to see if this scheme is installed 
    for (ii = 0; ii < g_pSspData->PkgCnt && 
        lstrcmp (g_pSspData->PkgList[ii]->pName, lpszScheme); ii++);

    if (ii >= g_pSspData->PkgCnt)
    {
        // This scheme is not installed on this machine
        AuthUnlock();
        return (0);
    }
    
    AuthUnlock();
    return ((DWORD_PTR)g_pSspData);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\auth\sspspm.h ===
//#----------------------------------------------------------------------------
//
//  File:           sspspm.h
//
//      Synopsis:   Definitions specific to SSPI SPM DLL.
//
//      Copyright (C) 1995  Microsoft Corporation.  All Rights Reserved.
//
//  Authors:        LucyC       Created                         25 Sept 1995
//
//-----------------------------------------------------------------------------
#ifndef _SSPSPM_H_
#define _SSPSPM_H_

#include <platform.h>

#ifdef __cplusplus
extern "C" {
#endif

//
//  Names of secruity DLL
//
#define SSP_SPM_NT_DLL      "security.dll"
#define SSP_SPM_WIN95_DLL   "secur32.dll"


#define SSP_SPM_DLL_NAME_SIZE   16          // max. length of security DLL names

#define MAX_SSPI_PKG        32              // Max. no. of SSPI supported

#define SSPPKG_ERROR        ((UCHAR) 0xff)
#define SSPPKG_NO_PKG       SSPPKG_ERROR
#define MAX_AUTH_MSG_SIZE   10000
#define TCP_PRINT   fprintf
#define DBG_CONTEXT stderr

#define MAX_BLOB_SIZE       13000

//
//  Server host list definition.

//  The following defines an entry in the server host list.
//
typedef struct _ssp_host_list
{
    struct _ssp_host_list   *pNext;

    unsigned char           *pHostname; // name of server host
    unsigned char           pkgID;      // the package being used for this host

} SspHosts, *PSspHosts;

//
//  List of SSPI packages installed on this machine.
//  The following defines an entry of the SSPI package list.
//
typedef struct _ssp_auth_pkg
{
    LPTSTR       pName;         // package name
    DWORD        Capabilities ; // Interesting capabilities bit
    ULONG        cbMaxToken;    // max size of security token
} SSPAuthPkg, *PSSPAuthPkg;

#define SSPAUTHPKG_SUPPORT_NTLM_CREDS   0x00000001

//
//  The following defines the global data structure which the SPM DLL keeps
//  in the HTSPM structure.
//
typedef struct _ssp_htspm
{
    PSecurityFunctionTable pFuncTbl;

    SSPAuthPkg      **PkgList;          // array of pointers to auth packages
    UCHAR           PkgCnt;



    BOOLEAN         bKeepList;          // whether to keep a list of servers
    
    PSspHosts       pHostlist;

} SspData, *PSspData;

#define SPM_STATUS_OK                   0
#define SPM_ERROR                       1
#define SPM_STATUS_WOULD_BLOCK          2
#define SPM_STATUS_INSUFFICIENT_BUFFER  3

/////////////////////////////////////////////////////////////////////////////
//
//  Function headers from sspcalls.c
//
/////////////////////////////////////////////////////////////////////////////

DWORD
GetSecAuthMsg (
    PSspData        pData,
    PCredHandle     pCredential,
    DWORD           pkgID,              // the package index into package list
    PCtxtHandle     pInContext,
    PCtxtHandle     pOutContext,
    ULONG           fContextReq,        // Request Flags
    VOID            *pBuffIn,
    DWORD           cbBuffIn,
    char            *pFinalBuff,
    DWORD           *pcbBuffOut,
    SEC_CHAR        *pszTarget,         // Server Host Name
    BOOL            fTargetTrusted,
    UINT            bNonBlock,
    LPSTR           pszScheme,
	SECURITY_STATUS *pssResult
    );

INT
GetPkgId(LPTSTR  lpszPkgName);

DWORD
GetPkgCapabilities(
    INT Package
    );
ULONG
GetPkgMaxToken(
    INT Package
    );

/////////////////////////////////////////////////////////////////////////////
//
//  Function headers from buffspm.c
//
/////////////////////////////////////////////////////////////////////////////

PSspHosts
SspSpmNewHost (
    PSspData pData,
    UCHAR    *pHost,       // name of server host to be added
    UCHAR    Package
    );

VOID
SspSpmDeleteHost(
    SspData     *pData,
    PSspHosts   pDelHost
    );

VOID
SspSpmTrashHostList(
    SspData     *pData
    );

PSspHosts
SspSpmGetHost(
    PSspData pData,
    UCHAR *pHost
    );

#ifdef __cplusplus
} // end extern "C" {
#endif

#endif  /* _SSPSPM_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\auth\uudec.c ===
#include <stdio.h>
#include "htuu.h"

int main (int argc, char **argv)
{
    char outbuf[500];
    char *pOut = outbuf;
    int cbOut = (strlen(argv[1]) * 3) / 4;

    if (argc != 2)
    {
        fprintf (stderr, "usage: uudec <base64-string>\n");
        exit (1);
    }
    
    HTUU_decode (argv[1], pOut, sizeof(outbuf));

    while (cbOut--)
    {
        printf ("%02x %c\n", (unsigned char) *pOut, *pOut);
        pOut++;
    }
        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\auth\splugin.cxx ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    splugin.cxx

Abstract:

    This file contains the implementation for Plug In Authentication

    The following functions are exported by this module:

    AuthOnRequest
    AuthOnResponse
    AuthCtxClose
    AuthInDialog
    AuthNotify
    AuthUnload

Author:

    Arthur Bierer (arthurbi) 25-Dec-1995

Revision History:
 
    Rajeev Dujari (rajeevd)  01-Oct-1996 overhauled

    Adriaan Canter (adriaanc) 01-03-1998 :
    AUTHCTX now a virtual base class, from which derived classes
    inherit to implement the different authentication protocols:

    BASIC_CTX  (Basic auth),
    PLUG_CTX   (NTLM, Negotiate)
    DIGEST_CTX (Digest auth, new)


--*/

#include <wininetp.h>
#include <splugin.hxx>
#include "auth.h"
#include "sspspm.h"

//
// constants
//

#define WILDCARD 0x05 // don't use '*' since it can appear in an URL
#define AssertHaveLock() INET_ASSERT(g_dwOwnerId == GetCurrentThreadId())

#define MAX_AUTH_HDR_SIZE (MAX_BLOB_SIZE + HTTP_PROXY_AUTHORIZATION_LEN + 2)

//
//  globals
//

// Global authentication providers list and state.
AUTHCTX::SPMState  AUTHCTX::g_eState;
AUTHCTX::SPMData  *AUTHCTX::g_pSPMList = NULL;


// Global auth crit sect.
CCritSec g_crstAuth;

#ifdef DBG
DWORD g_dwOwnerId = 0;
LONG g_nLockCount = 0;
#endif

//
// private prototypes
//

//-----------------------------------------------------------------------------
//
//  AUTH_CREDS class definition.
//
//
PRIVATE AUTH_CREDS *Creds_Create
(
    LPSTR lpszHost,
    LPSTR lpszRealm,
    AUTHCTX::SPMData* pSPM
);

void  Creds_Free (AUTH_CREDS *Creds);



//-----------------------------------------------------------------------------
//
//  Utilities
//
//

PRIVATE VOID SspiFlush (LPSTR pszDll);
PRIVATE BOOL TemplateMatch(LPSTR lpszTemplate, LPSTR lpszFilename);
PRIVATE LPSTR MakeTemplate (LPSTR docname);
PRIVATE LPSTR GetProxyName (HTTP_REQUEST_HANDLE_OBJECT *pRequest);

PRIVATE BOOL ReadRegKey(
    BYTE * pbRegValue,
    DWORD * pdwNumBytes,
    LPSTR  pszRegKey,
    LPSTR  pszRegValueName,
    DWORD  dwRegTypeExpected);



//-----------------------------------------------------------------------------
//
//
//      AUTH_CREDS functions
//
//          Creds_CREATE
//          Creds_FREE
//          SetUser
//          SetPass
//          FlushCredsList
//

PRIVATE AUTH_CREDS *Creds_Create // AUTH_CREDS constructor
(
    LPSTR lpszHost,     // Host Name to place in structure.
    LPSTR lpszRealm,    // Realm string to add.
    AUTHCTX::SPMData * pSPM
)
{
    AUTH_CREDS* Creds = (AUTH_CREDS *) ALLOCATE_ZERO_MEMORY(sizeof(*Creds));
    if (!Creds)
        return NULL;

    INET_ASSERT (!Creds->lpszHost);
    Creds->lpszHost    = lpszHost ?  NewString(lpszHost)   : NULL;
    
    INET_ASSERT (!Creds->lpszRealm);
    Creds->lpszRealm   = lpszRealm ? NewString(lpszRealm)  : NULL;
    Creds->pSPM         = pSPM;

    if (  (!Creds->lpszHost  && lpszHost)
       || (!Creds->lpszRealm && lpszRealm)
       )
    {
        Creds_Free(Creds);
        return NULL;
    }

    return Creds;
}

PRIVATE VOID Creds_Free(AUTH_CREDS *Creds) // AUTH_CREDS destructor
{
    if ( Creds )
    {
        if (Creds->lpszHost)
            FREE_MEMORY(Creds->lpszHost);
        if ( Creds->lpszUser )
            FREE_MEMORY(Creds->lpszUser);
        if ( Creds->lpszPass )
            FREE_MEMORY(Creds->lpszPass);
        if ( Creds->lpszRealm )
            FREE_MEMORY(Creds->lpszRealm);
        FREE_MEMORY(Creds);
    }
}

PUBLIC DWORD AUTH_CREDS::SetUser (LPSTR lpszInput)
{
    //AssertHaveLock();
    if (!lpszInput)
    {
        if (lpszUser)
            FREE_MEMORY (lpszUser);
        lpszUser = NULL;
        return ERROR_SUCCESS;
    }
    if (lpszUser && !lstrcmp (lpszUser, lpszInput))
        return ERROR_SUCCESS; // didn't change
    LPSTR lpszTemp = NewString(lpszInput);
    if (!lpszTemp)
        return ERROR_NOT_ENOUGH_MEMORY;
    if (lpszUser)
        FREE_MEMORY (lpszUser);
    lpszUser = lpszTemp;
    return ERROR_SUCCESS;
}

PUBLIC DWORD AUTH_CREDS::SetPass (LPSTR lpszInput)
{
    //AssertHaveLock();
    if (!lpszInput)
    {
        if (lpszPass)
            FREE_MEMORY (lpszPass);
        lpszPass = NULL;
        return ERROR_SUCCESS;
    }
    if (lpszPass && !lstrcmp (lpszPass, lpszInput))
        return ERROR_SUCCESS; // didn't change
    LPSTR lpszTemp = NewString(lpszInput);
    if (!lpszTemp)
        return ERROR_NOT_ENOUGH_MEMORY;
    if (lpszPass)
        FREE_MEMORY (lpszPass);
    lpszPass = lpszTemp;
    return ERROR_SUCCESS;
}


/*++
Delete some entries from a singly linked list.
--*/
/*
PRIVATE void FlushCredsList (AUTH_CREDS **ppList)
{
    AssertHaveLock();

    AUTH_CREDS *Creds = *ppList;
    while (Creds)
    {
        AUTH_CREDS *CredsNext = Creds->pNext;

        if (!Creds->nLockCount)
            Creds_Free (Creds);
        else
        {
            *ppList = Creds;
            ppList = &(Creds->pNext);
        }

        Creds = CredsNext;
    }
    *ppList = NULL;
}
*/


//-----------------------------------------------------------------------------
//
//
//      Auth* functions
//
//          AuthOpen
//          AuthClose
//          AuthLock
//          AuthUnlock
//          AuthInDialog
//          AuthNotify
//          AuthFlush
//
//

BOOL AuthOpen (void)
{
    INET_ASSERT (!g_dwOwnerId && !g_nLockCount);
    return g_crstAuth.Init();
}

void AuthClose (void)
{
    g_crstAuth.FreeLock();
    INET_ASSERT (!g_dwOwnerId && !g_nLockCount);
}

BOOL AuthLock (void)
{
    INET_ASSERT(g_crstAuth.IsInitialized() == TRUE);
    if (!g_crstAuth.Lock())
    {
        INET_ASSERT(FALSE);
        return FALSE;
    }
    DEBUG_ONLY (if (!g_nLockCount++) g_dwOwnerId = GetCurrentThreadId();)
    return TRUE;
}

void AuthUnlock (void)
{
    INET_ASSERT(g_crstAuth.IsInitialized() == TRUE);
    INET_ASSERT (g_nLockCount > 0);
    DEBUG_ONLY (if (!--g_nLockCount) g_dwOwnerId = 0;)
    g_crstAuth.Unlock();
}

/*++
Flush any server and proxy password cache entries not in use.
--*/
PUBLIC void AuthFlush (void)
{
    // Serialize access to globals.
    if (AuthLock())
    {
        if (!g_cSspiContexts)
            AUTHCTX::UnloadAll();

        DIGEST_CTX::FlushCreds();

        AuthUnlock();
    }
}


PUBLIC void AuthUnload (void)
/*++
Routine Description:
    Frees all Cached URLs, and unloads any loaded DLL authentication modeles.

--*/
{
    if (g_crstAuth.IsInitialized())
    {
        AuthFlush();
        if (AuthLock())
        {
            AUTHCTX::UnloadAll();
            AuthUnlock();
        }
    }
}


//-----------------------------------------------------------------------------
//
//
//      Utility Functions:
//
//          SspiFlush
//          TemplateMatch
//          MakeTemplate
//          GetProxyName
//          ReadRegKey
//          TrimQuotes
//          TrimWhiteSpace
//          GetDelimitedToken
//          GetKeyValuePair
//
//


typedef BOOL (WINAPI * SSPI_FLUSH) (VOID) ;

void SspiFlush (LPSTR pszDll)
{
    __try
    {
        HINSTANCE hinst = GetModuleHandle (pszDll);

        if (hinst)
        {
            SSPI_FLUSH pfnFlush = (SSPI_FLUSH)
                GetProcAddress (hinst, "CleanupCredentialCache");

            if (pfnFlush)
            {
                (*pfnFlush) ();
            }
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        INET_ASSERT (FALSE);
    }
    ENDEXCEPT
}



PRIVATE BOOL TemplateMatch(LPSTR lpszTemplate, LPSTR lpszFilename)

/*++

Routine Description:

    Attempts to match a template URL string with a URL ( FileName )

Arguments:

    lpszTemplate             - Template to match against.
    lpszFilename             - URL to match with the template

Return Value:

    BOOL
    Success - TRUE - match
    Failure - FALSE - no match

Comments:

    Note: This Legacy code from the SpyGlass IE 1.0 browser

--*/

{
    /* code for this routine cloned from HTAA_templateMatch() */

    CHAR *p = lpszTemplate;
    CHAR *q = lpszFilename;
    int m;

    if (!lpszTemplate || !lpszFilename)
        return 0;

    for (; *p && *q && *p == *q; p++, q++)  /* Find first mismatch */
        ;                                                                       /* do nothing else */

    if (!*p && !*q)
        return 1;                                                       /* Equally long equal strings */
    else if (WILDCARD == *p)
    {                                                                               /* Wildcard */
        p++;                                                            /* Skip wildcard character */
        m = strlen(q) - strlen(p);                      /* Amount to match to wildcard */
        if (m < 0)
            return 0;                                               /* No match, filename too short */
        else
        {                                                                       /* Skip the matched characters and compare */
        if (lstrcmp(p, q + m))
                return 0;                                       /* Tail mismatch */
            else
                return 1;                                       /* Tail match */
        }
    }                                                                               /* if wildcard */
    else
        return 0;                                                       /* Length or character mismatch */
}


PRIVATE LPSTR MakeTemplate (LPSTR docname)

/*++
Routine Description:
    Makes a Template String (from a URL) that can later be used to match a range of URLs.

Arguments:
    ppszTemplate             - pointer to pointer of where Template can be stored
    docname                  - URL to create a template with.

Return Value: BOOL
    Success - TRUE - created
    Failure - FALSE - error

Comments:
    Note: This Legacy code from the SpyGlass IE 1.0 browser
--*/

{
    CHAR *pszTemplate = NULL;
    unsigned long k;
    k = 0;

    if (docname)
    {
        CHAR *slash;
        CHAR *first_slash;

        //
        // Ignore everything after first reserved character.
        //

        BYTE chSave = 0;
        LPSTR lpszScan = docname;
        while (*lpszScan)
        {
            if (*lpszScan == '?' || *lpszScan == ';')
            {
                chSave = *lpszScan;
                *lpszScan = 0;
                break;
            }
            lpszScan++;
        }

        slash = strrchr(docname, '/');

        //
        // If there is a "//" and no other slashes,
        //  then make sure not to chop the hostname off
        //  the URL. ex: http://www.netscape.com
        //  should be //www.netscape.com* not //*
        //

        if (slash)
        {
            first_slash = strchr(docname, '/' );
            if ((first_slash+1) == slash)
                k = lstrlen(docname);
            else
                k = (unsigned long)(slash-docname)+1;
        }

        // Restore any reserved character (or rewrite terminating null)
        *lpszScan = chSave;
    }

    pszTemplate = (CHAR *) ALLOCATE_FIXED_MEMORY(k+2);
    if (!pszTemplate)
        return 0;

    memcpy(pszTemplate, docname, k);
    pszTemplate[k]= WILDCARD;
    pszTemplate[k+1]=0;

    DEBUG_PRINT(HTTP, INFO, ("MakeTemplate: made template [%s] from [%s]\n",
        pszTemplate, docname ));

    return pszTemplate;
}

LPSTR GetProxyName (HTTP_REQUEST_HANDLE_OBJECT *pRequest)
{
    // Get the proxy name.
    LPSTR lpszProxy;
    DWORD cbProxy;
    INTERNET_PORT port;

   pRequest->GetProxyName(
                &lpszProxy,
                &cbProxy,
                &port);

   return lpszProxy;
}


//++------------------------------------------------------------------------
//
//   Function: ReadRegKey
//
//   Synopsis: This function reads a registry key.
//
//   Arguments:
//
//   Returns:   TRUE     no error
//                 FALSE    a fatal error happened
//
//   History:      AshishS    Created     5/22/96
//------------------------------------------------------------------------

BOOL ReadRegKey(
    BYTE * pbRegValue, // The value of the reg key will be
                 // stored here
    DWORD * pdwNumBytes, // Pointer to DWORD conataining
     // the number of bytes in the above buffer - will be
     // set to actual bytes stored.
    LPSTR  pszRegKey, // Reg Key to be opened
    LPSTR  pszRegValueName, // Reg Value to query
    DWORD  dwRegTypeExpected) // Expected type of Value
{
    HKEY   hRegKey;
    DWORD  dwRegType;
    LONG lResult;

     //read registry to find out name of the file
    if ( (lResult = REGOPENKEYEX(HKEY_LOCAL_MACHINE,
                                 pszRegKey, // address of subkey name
                                 0,          // reserved
                                 KEY_READ,   // samDesired
                                 &hRegKey
                                  // address of handle of open key
        )) != ERROR_SUCCESS )
    {
        goto cleanup;
    }


    if ( (lResult =RegQueryValueEx( hRegKey,
                                    pszRegValueName,
                                    0,           // reserved
                                    &dwRegType,// address of buffer
                                     // for value type
                                    pbRegValue,
                                    pdwNumBytes)) != ERROR_SUCCESS )
    {
        REGCLOSEKEY(hRegKey);
        goto cleanup;
    }

    REGCLOSEKEY(hRegKey);

    if ( dwRegType != dwRegTypeExpected )
    {
        goto cleanup;
    }

    return TRUE;

cleanup:

    return FALSE;

}


/*-----------------------------------------------------------------------------
Inplace trim of one leading and one trailing quote.
-----------------------------------------------------------------------------*/
VOID TrimQuotes(LPSTR *psz, LPDWORD pcb)
{
    if (*pcb && (**psz == '"'))
    {
        (*psz)++;
        (*pcb)--;
    }
    if (*pcb && (*(*psz + *pcb - 1) == '"'))
        (*pcb)--;
}

/*-----------------------------------------------------------------------------
Inplace trim of leading and trailing whitespace.
-----------------------------------------------------------------------------*/
VOID TrimWhiteSpace(LPSTR *psz, LPDWORD pcb)
{
    DWORD cb = *pcb;
    CHAR* beg = *psz;
    CHAR* end = beg + cb - 1;

    while ((cb != 0) && ((*beg == ' ') || (*beg == '\t')))
    {
        beg++;
        cb--;
    }

    while ((cb != 0) && ((*end == ' ') || (*end == '\t')))
    {
        end--;
        cb--;
    }

    *psz = beg;
    *pcb = cb;
}

/*-----------------------------------------------------------------------------
Inplace strtok based on one delimiter. Ignores delimiter scoped by quotes.
-----------------------------------------------------------------------------*/
BOOL GetDelimitedToken(LPSTR* pszBuf,   LPDWORD pcbBuf,
                       LPSTR* pszTok,   LPDWORD pcbTok,
                       CHAR   cDelim)
{
    CHAR *pEnd;
    BOOL fQuote = FALSE,
         fRet   = FALSE;

    *pcbTok = 0;
    *pszTok = *pszBuf;
    pEnd = *pszBuf + *pcbBuf - 1;

    while (*pcbBuf)
    {
        if ( ((**pszBuf == cDelim) && !fQuote)
            || (*pszBuf == pEnd)
            || (**pszBuf =='\r')
            || (**pszBuf =='\n'))
        {
            fRet = TRUE;
            break;
        }

        if (**pszBuf == '"')
            fQuote = !fQuote;

        (*pszBuf)++;
        (*pcbBuf)--;
    }

    if (fRet)
    {
        *pcbBuf = (DWORD) (pEnd - *pszBuf);
        if (**pszBuf == cDelim)
        {
            *pcbTok = (DWORD)(*pszBuf - *pszTok);
            (*pszBuf)++;
        }
        else
            *pcbTok = (DWORD) (*pszBuf - *pszTok) + 1;
    }

    return fRet;
}


/*-----------------------------------------------------------------------------
Inplace retrieval of key and value from a buffer of form key = <">value<">
-----------------------------------------------------------------------------*/
BOOL GetKeyValuePair(LPSTR  szB,    DWORD cbB,
                     LPSTR* pszK,   LPDWORD pcbK,
                     LPSTR* pszV,   LPDWORD pcbV)
{
    if (GetDelimitedToken(&szB, &cbB, pszK, pcbK, '='))
    {
        TrimWhiteSpace(pszK, pcbK);

        if (cbB)
        {
            *pszV = szB;
            *pcbV = cbB;
            TrimWhiteSpace(pszV, pcbV);
        }
        else
        {
            *pszV = NULL;
            *pcbV = 0;
        }
        return TRUE;
    }

    else
    {
        *pszK  = *pszV  = NULL;
        *pcbK  = *pcbV = 0;
    }
    return FALSE;
}


//-----------------------------------------------------------------------------
//
//
//      Main authentication functions:
//
//          AddAuthorizationHeader
//          AuthOnRequest
//          ProcessResponseHeader
//          AuthOnRequest
//
//



/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/
PRIVATE void AddAuthorizationHeader
(
    HTTP_REQUEST_HANDLE_OBJECT *pRequest,
    AUTHCTX* pAuthCtx
)
{
    if (!pAuthCtx)
        return;

    INET_ASSERT(pAuthCtx->_pSPMData);

    // AssertHaveLock();

    // Call the auth package.
    // CHAR *szHeader;
    // DWORD dwFastHeaderSize = MAX_BLOB_SIZE + HTTP_PROXY_AUTHORIZATION_LEN + 2;
    // CHAR* pszFastHeader = NULL;
    CHAR *szSlowHeader = NULL;
    // ULONG cbHeader;
    LPSTR pBuf;
    DWORD cbBuf;
    DWORD dwPlugInError;
    // CHAR *pszHeader;

    /*
    pszFastHeader = (CHAR*)ALLOCATE_FIXED_MEMORY(dwFastHeaderSize);
    if (!pszFastHeader)
    {
        // Don't worry about reporting an error.
        // Since this is a low mem condition, the only failure resulting
        // from this is that the header won't be added, and this won't
        // directly cause any more harm than unexpectedly failing to
        // authenticate, which isn't bad, given the low mem state.
        return;
    }
    */


    INT PackageId;
    ULONG cbMaxToken;

    //
    // GetPkgMaxToken() will return 10000 if invalid pkg.
    //

    if( (pAuthCtx->_pSPMData) &&
        (pAuthCtx->_pSPMData->szScheme) &&
        ((PackageId = GetPkgId( pAuthCtx->_pSPMData->szScheme )) != -1)
        )
    {
        cbMaxToken = GetPkgMaxToken( PackageId );
    } else {
        cbMaxToken = MAX_AUTH_MSG_SIZE;
    }

    //
    // add space for base64 overhead (33%, but round up)
    //

    cbMaxToken += (cbMaxToken/2);
    
    // Prefix with the appropriate header.

    /*
    if( cbMaxToken < dwFastHeaderSize )
    {
        cbHeader = dwFastHeaderSize;
        szHeader = pszFastHeader;
    } else {
        cbHeader = cbMaxToken;
        */
        szSlowHeader = (CHAR*)ALLOCATE_FIXED_MEMORY(cbMaxToken);

        if( szSlowHeader == NULL )
        {
            //
            // no clean way to report an error here.  just try with the stack
            // buffer.
            //
            /*
            cbHeader = dwFastHeaderSize;
            szHeader = pszFastHeader;
        } else {
            szHeader = szSlowHeader;  */
            return;
        }
    //}

    if (pAuthCtx->_fIsProxy)
    {
        memcpy (szSlowHeader, HTTP_PROXY_AUTHORIZATION_SZ, HTTP_PROXY_AUTHORIZATION_LEN);
        pBuf = szSlowHeader + HTTP_PROXY_AUTHORIZATION_LEN;

        // Don't reuse this keep-alive socket after a password cache flush.
        pRequest->SetAuthorized();
    }
    else
    {
        memcpy (szSlowHeader, HTTP_AUTHORIZATION_SZ, HTTP_AUTHORIZATION_LEN);
        pBuf = szSlowHeader + HTTP_AUTHORIZATION_LEN;

        // Don't reuse a keep-alive socket after a password cache flush.
        if (!pRequest->IsViaProxy())
            pRequest->SetAuthorized();
    }

    *pBuf++ = ' ';
    cbBuf = cbMaxToken - HTTP_PROXY_AUTHORIZATION_LEN - 2;
    INET_ASSERT (HTTP_PROXY_AUTHORIZATION_LEN >= HTTP_AUTHORIZATION_LEN);


    dwPlugInError =
        pAuthCtx->PreAuthUser(pBuf, &cbBuf);

    //  If the plug in did not fail, add its header to the outgoing header list
    if (dwPlugInError == ERROR_SUCCESS && pAuthCtx->GetState() != AUTHCTX::STATE_ERROR)
    {
        // Append CR-LF.
        pBuf += cbBuf;
        *pBuf++ = '\r';
        *pBuf++ = '\n';
        *pBuf = 0;
        cbBuf = (DWORD) (pBuf - szSlowHeader);

        // Add or replace the (proxy-)authorization header.
        wHttpAddRequestHeaders (pRequest, szSlowHeader, cbBuf,
            HTTP_ADDREQ_FLAG_ADD | HTTP_ADDREQ_FLAG_REPLACE);

    }

    // delete [] pszHeader;
    if( szSlowHeader )
    {
        FREE_MEMORY( szSlowHeader );
    }

    /*
    if (pszFastHeader)
    {
        FREE_MEMORY( pszFastHeader );
    }
    */

    DEBUG_LEAVE(0);
}

// biaow: move this to a better place

PSTR DwordSchemeToString(DWORD dwScheme)
{
    switch (dwScheme)
    {
    case WINHTTP_AUTH_SCHEME_BASIC:
        return "Basic";
    case WINHTTP_AUTH_SCHEME_NTLM:
        return "NTLM";
    case WINHTTP_AUTH_SCHEME_PASSPORT:
        return "Passport1.4";
    case WINHTTP_AUTH_SCHEME_DIGEST:
        return "Digest";
    case WINHTTP_AUTH_SCHEME_NEGOTIATE:
        return "Negotiate";
    default:
        return "";
    }
}

DWORD DwordSchemeToFlags(DWORD dwScheme)
{
    switch (dwScheme)
    {
    case WINHTTP_AUTH_SCHEME_BASIC:
        return PLUGIN_AUTH_FLAGS_KEEP_ALIVE_NOT_REQUIRED;
    case WINHTTP_AUTH_SCHEME_NTLM:
        return PLUGIN_AUTH_FLAGS_NO_REALM;
    case WINHTTP_AUTH_SCHEME_PASSPORT:
        return PLUGIN_AUTH_FLAGS_KEEP_ALIVE_NOT_REQUIRED;
    case WINHTTP_AUTH_SCHEME_DIGEST:
        return PLUGIN_AUTH_FLAGS_KEEP_ALIVE_NOT_REQUIRED | PLUGIN_AUTH_FLAGS_CAN_HANDLE_UI;
    case WINHTTP_AUTH_SCHEME_NEGOTIATE:
        return PLUGIN_AUTH_FLAGS_KEEP_ALIVE_NOT_REQUIRED | PLUGIN_AUTH_FLAGS_NO_REALM;
    default:
        return 0;
    }
}

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/
PUBLIC DWORD AuthOnRequest (IN HINTERNET hRequestMapped)
{
    DEBUG_ENTER ((DBG_HTTP, Dword, "AuthOnRequest", "%#x", hRequestMapped));

    DWORD dwError = ERROR_SUCCESS;
    LPSTR lpszUser, lpszPass;
    
    // Get username, password, url, and auth context from request handle.
    HTTP_REQUEST_HANDLE_OBJECT *pRequest =
        (HTTP_REQUEST_HANDLE_OBJECT *) hRequestMapped;

    LPSTR lpszUrl = pRequest->GetURL();
    LPSTR lpszHost= pRequest->GetServerName();

    AUTHCTX *pAuthCtx = pRequest->GetAuthCtx();
    AUTH_CREDS *Creds;
    BOOL fCredsChanged = FALSE;
    
    // PROXY AUTHENTICATION
    //
    // CERN proxies should remove proxy-authorization headers before forwarding
    // requests to servers.  Otherwise, don't add proxy authorization headers
    // that would be seen by servers on a direct connect or via SSL tunneling.

    if  (pRequest->IsRequestUsingProxy()
      && !pRequest->IsTalkingToSecureServerViaProxy())
    {
        // if an app sets proxy creds, we want to make sure that the specified
        // auth scheme is the same as the auth scheme in progress. Otherwise, we
        // will delete the current auth context and build a new one based on the
        // new scheme.
        if (pRequest->_pProxyCreds 
            && (pAuthCtx && pAuthCtx->_fIsProxy)
            && (pAuthCtx->GetRawSchemeType() != pRequest->_pProxyCreds->_AuthScheme))
        {
            delete pAuthCtx;
            pAuthCtx = NULL;
            pRequest->SetAuthCtx(NULL);
        }

        if (pAuthCtx && pAuthCtx->_fIsProxy)
        {
            // We have a proxy authentication in progress.
            // If a user/pass set on handle, transfer to AUTH_CREDS.

            // First check for proxy credentials and fallback to server
            // for legacy wininet apps. This will invalidate the credentials
            // on the handle they were found for any subsequent calls to
            // GetUserAndPass.
            
                // Serialize access to globals.
            if (AuthLock())
            {
                if (pRequest->_pProxyCreds)
                {
                    pAuthCtx->_pCreds->SetUser(pRequest->_pProxyCreds->_pszUserName);
                    pAuthCtx->_pCreds->SetPass(pRequest->_pProxyCreds->_pszPassword);
                }
                else if (pRequest->GetUserAndPass(IS_PROXY, &lpszUser, &lpszPass))
                {
                    pAuthCtx->_pCreds->SetUser(lpszUser);
                    pAuthCtx->_pCreds->SetPass(lpszPass);
                }

                AuthUnlock();

                // Add the authorization header.
                AddAuthorizationHeader (pRequest, pAuthCtx);
            }
        }

        // NO PROXY AUTHENTICATION CONTEXT -> SEE IF A AUTH_CREDS EXISTS.
        else  // See if we have a cached proxy user/pass.
        {
            if (pRequest->_pProxyCreds)
            {
                AUTHCTX::SPMData* pSPMData = 
                    reinterpret_cast<AUTHCTX::SPMData*>(New AUTHCTX::SPMData(
                        DwordSchemeToString(pRequest->_pProxyCreds->_AuthScheme), 
                        DwordSchemeToFlags(pRequest->_pProxyCreds->_AuthScheme)));

                if (pSPMData)
                {
                    AUTH_CREDS *pCreds = AUTHCTX::CreateCreds(pRequest, TRUE,
                                                      pSPMData, pRequest->_pProxyCreds->_pszRealm);
                    if (pCreds)
                    {
                        pCreds->SetUser(pRequest->_pProxyCreds->_pszUserName);
                        pCreds->SetPass(pRequest->_pProxyCreds->_pszPassword);

                        pAuthCtx = AUTHCTX::CreateAuthCtx(pRequest, IS_PROXY, pCreds);
                        if (pAuthCtx && pAuthCtx->GetSchemeType() == WINHTTP_AUTH_SCHEME_BASIC)
                        {
                            AddAuthorizationHeader (pRequest, pAuthCtx);
                        }
                        delete pAuthCtx;
                        pAuthCtx = NULL;
                    }
                }
            }
        }
    }

    // SERVER AUTHENTICATION
    //
    // Don't send server authorization when initiating SSL tunneling with proxy.
    if (!pRequest->IsTunnel())
    {
        // if an app sets server creds, we want to make sure that the specified
        // auth scheme is the same as the auth scheme in progress. Otherwise, we
        // will delete the current auth context and build a new one based on the
        // new scheme.
        if (pRequest->_pServerCreds 
            && (pAuthCtx && !pAuthCtx->_fIsProxy)
            && (pAuthCtx->GetRawSchemeType() != pRequest->_pServerCreds->_AuthScheme))
        {
            delete pAuthCtx;
            pAuthCtx = NULL;
            pRequest->SetAuthCtx(NULL);
        }

        // See if we have a server authentication in progress
        if (pAuthCtx && !pAuthCtx->_fIsProxy)
        {
            // Server authentication in progress.

            // If a user/pass set on handle, transfer to AUTH_CREDS.
            // This will invalidate the credentials on the handle they
            // were found for any subsequent calls to GetUserAndPass.
            
            if (AuthLock())
            {
                if (pRequest->_pServerCreds)
                {
                    pAuthCtx->_pCreds->SetUser(pRequest->_pServerCreds->_pszUserName);
                    pAuthCtx->_pCreds->SetPass(pRequest->_pServerCreds->_pszPassword);
                }
                else if (pRequest->GetUserAndPass(IS_SERVER, &lpszUser, &lpszPass))
                {
                    pAuthCtx->_pCreds->SetUser(lpszUser);
                    pAuthCtx->_pCreds->SetPass(lpszPass);
                }

                AuthUnlock();

                // Add the authorization header.
                AddAuthorizationHeader (pRequest, pAuthCtx);
            }
        }
        else  // See if we have a cached server user/pass.
        {
            // NO PROXY AUTHENTICATION CONTEXT -> SEE IF A AUTH_CREDS EXISTS
                
            if (pRequest->_pServerCreds)
            {
                BOOL fPreauth = FALSE;
                AUTHCTX *pNewAuthCtx = NULL;

                AUTHCTX::SPMData* pSPMData = 
                    reinterpret_cast<AUTHCTX::SPMData*>(New AUTHCTX::SPMData(
                        DwordSchemeToString(pRequest->_pServerCreds->_AuthScheme), 
                        DwordSchemeToFlags(pRequest->_pServerCreds->_AuthScheme)));
                
                INET_ASSERT(pSPMData);

                AUTH_CREDS *pCreds = AUTHCTX::CreateCreds(pRequest, FALSE,
                                                  pSPMData, pRequest->_pServerCreds->_pszRealm);
                if (pCreds)
                {
                    pCreds->SetUser(pRequest->_pServerCreds->_pszUserName);
                    pCreds->SetPass(pRequest->_pServerCreds->_pszPassword);

                    pNewAuthCtx = AUTHCTX::CreateAuthCtx(pRequest, IS_SERVER, pCreds);
                    
                    if(pNewAuthCtx)
                    {
                        if (pNewAuthCtx->GetSchemeType() == WINHTTP_AUTH_SCHEME_NTLM
                            || pNewAuthCtx->GetSchemeType() == WINHTTP_AUTH_SCHEME_NEGOTIATE)
                        {
                            // NTLM or Negotiate (in which case we don't really know the
                            // protocol yet) - create the auth context, set it in the handle
                            // and set state to AUTHSTATE_NEGOTIATE. Handle now has
                            // a valid auth context and is in the correct auth state
                            // for the remainder of the authorization sequence.

                            // It's possible that the Creds entry was created when no proxy
                            // was in use and the user set a proxy. Check that this is
                            // not the case.

                            if (!pRequest->IsMethodBody() 
                                || (pNewAuthCtx->GetSchemeType() == WINHTTP_AUTH_SCHEME_NTLM
                                    && pRequest->IsDisableNTLMPreauth())
                                || (pRequest->IsRequestUsingProxy()
                                    && !pRequest->IsTalkingToSecureServerViaProxy()))
                            {
                                // NTLM preauth disabled or over proxy; no preauth.
                                delete pNewAuthCtx;
                                pNewAuthCtx = NULL;
                            }
                            else
                            {
                                // Set the auth context in the handle and
                                // add the auth header.
                                pRequest->SetAuthCtx(pNewAuthCtx);
                                pRequest->SetAuthState(AUTHSTATE_NEGOTIATE);
                                AddAuthorizationHeader (pRequest, pNewAuthCtx);
                                fPreauth = TRUE;
                            }
                        }
                        else
                        {
                            // For Basic and Digest add the header but do not set the
                            // context in the handle since we will delete it next.
                            // In this case we record that we have pre-authenticated which
                            // is necessary state info if the server challenges with a 401
                            // and we are forced to re-authenticate.
                            if ((pNewAuthCtx->GetSchemeType() == WINHTTP_AUTH_SCHEME_DIGEST && !fCredsChanged)
                                || (pNewAuthCtx->GetSchemeType() == WINHTTP_AUTH_SCHEME_BASIC))
                            {
                                AddAuthorizationHeader (pRequest, pNewAuthCtx);
                                pRequest->SetCreds(pNewAuthCtx->_pCreds);
                                fPreauth = TRUE;
                            }

                            if (pNewAuthCtx->GetSchemeType() == WINHTTP_AUTH_SCHEME_PASSPORT)
                            {
                                pRequest->SetAuthCtx(pNewAuthCtx);
                                AddAuthorizationHeader (pRequest, pNewAuthCtx);
                            }
                        }

                        if (fPreauth)
                        {
                            // Proceed to delete the context if basic or digest.
                            if (pNewAuthCtx->GetSchemeType() == WINHTTP_AUTH_SCHEME_DIGEST
                                || pNewAuthCtx->GetSchemeType() == WINHTTP_AUTH_SCHEME_BASIC)
                            {
                                delete pNewAuthCtx;
                                pNewAuthCtx = NULL;
                            }
                        }                    
                    }
                }
            }
        }
    }

    DEBUG_LEAVE(dwError);
    return dwError;
}


/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/
DWORD ProcessResponseHeaders
(
    HINTERNET hRequestMapped,
    BOOL fIsProxy
)
{
    DEBUG_ENTER ((DBG_HTTP, Dword, "ProcessResponseHeaders", "%#x", hRequestMapped));

    DWORD dwError = ERROR_SUCCESS;

    // Get context from request handle.
    HTTP_REQUEST_HANDLE_OBJECT *pRequest
        = (HTTP_REQUEST_HANDLE_OBJECT *) hRequestMapped;
    AUTHCTX* pAuthCtx = pRequest->GetAuthCtx();

    if (pAuthCtx)
    {
        if ((dwError = pAuthCtx->UpdateFromHeaders(pRequest, fIsProxy))
            != ERROR_SUCCESS)
        {
            // Delete the auth context and fail auth 
            // immediately if any other error than
            // scheme has been changed.
            delete pAuthCtx;
            pRequest->SetAuthCtx(NULL);
            if (dwError != ERROR_HTTP_HEADER_NOT_FOUND)
                goto cleanup;

            // Attempt to create a new auth context using
            // the challenge received from the server.
            // If this fails, we follow logic as commented
            // below.
            pAuthCtx = AUTHCTX::CreateAuthCtx(pRequest, fIsProxy);        
            if (!pAuthCtx)
            {
                dwError = ERROR_SUCCESS;
                goto cleanup;
            }
        }
    }
    else
    {
        // CreateAuthCtx returns NULL if auth scheme not
        // supported (fall through from HttpFiltOnResponse
        // in sendreq.cxx) or if scheme is NTLM and the
        // socket is not keep-alive or via proxy.
        // In these cases it is necessary to check for a NULL
        // return value. The correct return code for these cases is
        // ERROR_SUCCESS, which will be returned by AuthOnResponse.
        pAuthCtx = AUTHCTX::CreateAuthCtx(pRequest, fIsProxy);
        if (!pAuthCtx)
        {
            dwError = ERROR_SUCCESS;
            goto cleanup;
        }
    }

    LPSTR lpszUser, lpszPass;

    // First check for proxy credentials and fallback to server
    // for legacy wininet apps. This will invalidate the credentials
    // on the handle they were found for any subsequent calls to
    // GetUserAndPass.

    // I believe we should be putting the credentials in the
    // password cache at this time. The scenario is that a client
    // sets credentials on a handle, after a successful authentication
    // the Creds will have null credentials. Pre-auth will then pull up
    // credentials for the default user!!!!!!!!!!!
    
        // Serialize access to globals.
    if (AuthLock())
    {
        if (pRequest->_pServerCreds && !fIsProxy)
        {
            lpszUser = pRequest->_pServerCreds->_pszUserName;
            lpszPass = pRequest->_pServerCreds->_pszPassword;
        }
        else if (pRequest->_pProxyCreds && fIsProxy)
        {
            lpszUser = pRequest->_pProxyCreds->_pszUserName;
            lpszPass = pRequest->_pProxyCreds->_pszPassword;
        }
        else if ((!pRequest->GetUserAndPass(fIsProxy, &lpszUser, &lpszPass)) && fIsProxy && !GlobalIsProcessExplorer)
        {
            pRequest->GetUserAndPass(IS_SERVER, &lpszUser, &lpszPass);
        }

        AuthUnlock();
    }
    else
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    // If we retrieved credentials from the handle set
    // them in the Creds.
    if (lpszUser && lpszPass)
    {
       pAuthCtx->_pCreds->SetUser(lpszUser);
       pAuthCtx->_pCreds->SetPass(lpszPass);
    }

    // Post authenticate user.
    dwError = pAuthCtx->PostAuthUser();

    // Map all unexpected error codes to login failure.
    if (dwError != ERROR_WINHTTP_FORCE_RETRY
        && dwError != ERROR_WINHTTP_INCORRECT_PASSWORD)
    {
        dwError = ERROR_WINHTTP_LOGIN_FAILURE;
    }

    pRequest->SetAuthCtx(pAuthCtx);

cleanup:
    
    return dwError;
}

extern CHAR g_szPassportDAHost[];


BOOL IsSameDomain(LPCSTR pszTarget, LPCSTR pszResponse)
{
    LPCSTR pszTargetR = pszTarget + strlen(pszTarget);
    DWORD dwDotsSeen = 0;
    while (--pszTargetR > pszTarget)
    {
        if (*pszTargetR == '.')
        {
            if (++dwDotsSeen == 2)
            {
                break;
            }
        }
    }

    if (dwDotsSeen == 2)
    {
        ++pszTargetR;
        DWORD dwOffsetR = strlen(pszTargetR);
        if (strlen(pszResponse) < dwOffsetR)
        {
            return FALSE;
        }

        LPCSTR pszResponseR = pszResponse + strlen(pszResponse) - dwOffsetR;

        return !strcmp(pszTargetR, pszResponseR);
    }
    else
    {
        return FALSE;
    }
}

VOID CheckForTweenerLogout(HTTP_REQUEST_HANDLE_OBJECT *pRequest)
{
    DWORD dwIndex = 0;
    DWORD dwError;

    do
    {
        LPSTR szData;
        DWORD cbData;
        dwError = pRequest->FastQueryResponseHeader(HTTP_QUERY_AUTHENTICATION_INFO,
                                                    (LPVOID*) &szData,
                                                    &cbData,
                                                    dwIndex);
        if (dwError == ERROR_SUCCESS)
        {
            if (strstr(szData, "Passport1.4") && strstr(szData, "logout"))
            {
                if (IsSameDomain(pRequest->GetServerName(), g_szPassportDAHost))
                {
                    // g_fIgnoreCachedCredsForPassport = TRUE;
                    // todo: call session->Logout
                }
                
                break;
            }
        }

        ++dwIndex;

    } while (dwError == ERROR_SUCCESS);
}


/*-----------------------------------------------------------------------------

Routine Description:

    Validates, and Caches Authentication Request headers if needed. If a URL matches a
    cached set of templates it is assumed to require specific authentication information.

Arguments:

    hRequest                - An open HTTP request handle
                              where headers will be added if needed.

Return Value:

    DWORD
    Success - ERROR_SUCCESS

    Failure - One of Several Error codes defined in winerror.h or wininet.w

Comments:

    Need to handle mutiple authentication pages.

-----------------------------------------------------------------------------*/
PUBLIC DWORD AuthOnResponse (HINTERNET hRequestMapped)
{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "AuthOnResponse",
                 "%#x [%#x]",
                 hRequestMapped,
                 ((INTERNET_HANDLE_OBJECT *)hRequestMapped)->GetPseudoHandle()
                 ));

    // Get URL and password cache entry from request handle.
    HTTP_REQUEST_HANDLE_OBJECT *pRequest =
        (HTTP_REQUEST_HANDLE_OBJECT *) hRequestMapped;

    AUTHCTX *pAuthCtx = pRequest->GetAuthCtx();
    DWORD dwStatus = pRequest->GetStatusCode();

    if (pAuthCtx)
    {
        if (pAuthCtx->_fIsProxy && dwStatus != HTTP_STATUS_PROXY_AUTH_REQ)
        {
            // We are done with proxy authentication.
            delete pAuthCtx;
            pRequest->SetAuthCtx (NULL);
            
            if (pRequest->_pProxyCreds)
            {
                delete pRequest->_pProxyCreds;
                pRequest->_pProxyCreds = NULL;
            }
        }
        else if (!pAuthCtx->_fIsProxy && dwStatus != HTTP_STATUS_DENIED)
        {
			if ((pAuthCtx->GetSchemeType() != WINHTTP_AUTH_SCHEME_PASSPORT) || dwStatus != HTTP_STATUS_REDIRECT)
            {
                // We are done with server authentication.
                delete pAuthCtx;
                pRequest->SetAuthCtx (NULL);

                if (pRequest->_pServerCreds)
                {
                    delete pRequest->_pServerCreds;
                    pRequest->_pServerCreds = NULL;
                }
            }
			else
            {
                // in the case of Passport Auth, 302 is still not done yet, 
                // but this is quite strange since 302 came a second time
                // biaow-todo: we could be in a loop here
            }
        }
    }

    // Remove any stale authorization headers in case wHttpSendRequest
    // loops, for example, to handle a redirect.  To ignore trailing colon,
    // subtract 1 from header lengths passed to ReplaceRequestHeader.
    pRequest->ReplaceRequestHeader
        (HTTP_QUERY_AUTHORIZATION,
                    "", 0, 0, HTTP_ADDREQ_FLAG_REPLACE);
    pRequest->ReplaceRequestHeader
        (HTTP_QUERY_PROXY_AUTHORIZATION,
            "", 0, 0, HTTP_ADDREQ_FLAG_REPLACE);

    DWORD error;

    DWORD dwZone, dwPolicy;

//
// note: Negotiate MUTUAL_AUTH can return dwStatus = 200 with a final
// WWW-Authenticate blob to process.  logic below could be adjusted
// to ProcessResponseHeaders() in this situation, which allows MUTUAL_AUTH
// to be enforced.
//
    
    switch (dwStatus)
    {
        case HTTP_STATUS_PROXY_AUTH_REQ: // 407
            error = ProcessResponseHeaders(pRequest, IS_PROXY);
            break;

        case HTTP_STATUS_REDIRECT: // 302
    
            // process the header to see whether this is a 302 passport1.4 challenge

        case HTTP_STATUS_DENIED: // 401

            error = ProcessResponseHeaders(pRequest, IS_SERVER);
            break;

        default:
            pRequest->SetAuthState(AUTHSTATE_NONE);
            error = ERROR_SUCCESS;
    }

    // creds set by WinHttpSetCredentials() is good for one "authentication attempt" only. 
    // Since we are done authentication here, we are deleting it.

    // biaow: detect the "final" failure so that we can delete the creds.
    
    CheckForTweenerLogout(pRequest);
    
    DEBUG_LEAVE(error);
    return error;
}




//-----------------------------------------------------------------------------
//
//
//      AUTHCTX Base class definitions
//
//
//
//      static funcs:
//          Enumerate
//          UnloadAll
//          CreateAuthCtx
//          CreateAuthCtx (using Creds*)
//          GetSPMListState
//          SearchCredsList
//          FindOrCreateCreds
//          GetAuthHeaderData
//
//      base funcs:
//          FindHdrIdxFromScheme
//          GetScheme
//          GetSchemeType - returns enum
//          GetFlags      - returns SPM flags
//          GetState      - returns state of SPM provider
//
//
//      virtual overrides: defined in basic.cxx, plug.cxx and digest.cxx
//          UpdateFromHeaders
//          PreAuthUser
//          PostAuthUser
//
//
//


/*---------------------------------------------------------------------------
AUTHCTX::SPMData constructor
---------------------------------------------------------------------------*/
AUTHCTX::SPMData::SPMData(LPSTR _szScheme, DWORD _dwFlags)
{
    if (_szScheme)
    {
        szScheme = NewString(_szScheme);
        cbScheme = strlen(_szScheme);
    }
    else
    {
        szScheme = NULL;
        cbScheme = 0;
    }

    if (szScheme)
    {
        if (!lstrcmpi(szScheme, "Basic"))
            eScheme = WINHTTP_AUTH_SCHEME_BASIC;
        else if (!lstrcmpi(szScheme, "NTLM"))
            eScheme = WINHTTP_AUTH_SCHEME_NTLM;
        else if (!lstrcmpi(szScheme, "Digest"))
            eScheme = WINHTTP_AUTH_SCHEME_DIGEST;
        else if (!lstrcmpi(szScheme, "Negotiate"))
            eScheme = WINHTTP_AUTH_SCHEME_NEGOTIATE;
        else if (!lstrcmpi(szScheme, "Passport1.4"))
            eScheme = WINHTTP_AUTH_SCHEME_PASSPORT;
        else
            eScheme = 0;

        dwFlags    = _dwFlags;
        eState     = STATE_NOTLOADED;
    }
    else
    {
        dwFlags    = 0;
        eState     = STATE_ERROR;
    }
}

/*---------------------------------------------------------------------------
AUTHCTX::SPMData destructor
---------------------------------------------------------------------------*/
AUTHCTX::SPMData::~SPMData()
{ delete szScheme; }


/*---------------------------------------------------------------------------
AUTHCTX constructor
---------------------------------------------------------------------------*/
AUTHCTX::AUTHCTX(SPMData *pData, AUTH_CREDS *pCreds)
{
    _pSPMData = pData;
    _pCreds = pCreds;
    _pRequest = NULL;
    _fIsProxy = FALSE;
    _pvContext = NULL;
    _eSubScheme = 0;
    _dwSubFlags = 0;

    _CtxCriSec.Init();
}


/*---------------------------------------------------------------------------
    Destructor
---------------------------------------------------------------------------*/
AUTHCTX::~AUTHCTX()
{
    if (AuthLock())
    {
        if (_pCreds)
            Creds_Free(_pCreds);
        AuthUnlock();
    }

    _CtxCriSec.FreeLock();
}


// ------------------------  Static Functions ---------------------------------


/*---------------------------------------------------------------------------
    Enumerate
---------------------------------------------------------------------------*/
VOID AUTHCTX::Enumerate()
{
    struct SchemeFlagsPair
    {
        LPSTR pszScheme;
        DWORD Flags;
    };

    SchemeFlagsPair SchemeFlags[] = {
                        {"NTLM", PLUGIN_AUTH_FLAGS_NO_REALM},
                        {"Basic", PLUGIN_AUTH_FLAGS_KEEP_ALIVE_NOT_REQUIRED},
                        {"Digest", PLUGIN_AUTH_FLAGS_KEEP_ALIVE_NOT_REQUIRED | PLUGIN_AUTH_FLAGS_CAN_HANDLE_UI},
                        {"Negotiate", PLUGIN_AUTH_FLAGS_KEEP_ALIVE_NOT_REQUIRED | PLUGIN_AUTH_FLAGS_NO_REALM},
                        {"Passport1.4",  PLUGIN_AUTH_FLAGS_KEEP_ALIVE_NOT_REQUIRED}
                        };
    
    SPMData   *pNew;
    g_pSPMList = NULL;
    g_eState = STATE_ERROR;

    AssertHaveLock();

    // Hard-wired Basic, NTLM and Digest
    for (DWORD dwIndex = 0; dwIndex < sizeof(SchemeFlags) / sizeof(SchemeFlagsPair); dwIndex++)
    {
        if (!GlobalPlatformVersion5 // we don't support Negotiate on NT4 or Win9x
            && !stricmp(SchemeFlags[dwIndex].pszScheme, "Negotiate"))
        {
            continue;
        }

        pNew = (AUTHCTX::SPMData*) New SPMData(SchemeFlags[dwIndex].pszScheme, SchemeFlags[dwIndex].Flags);
        if (!pNew)
            return;

        // Add to head of list.
        if (pNew->eState != STATE_ERROR)
        {
            pNew->pNext = g_pSPMList;
            g_pSPMList = pNew;
        }
    }

    // The list is now in the correct state.
    g_eState = STATE_LOADED;
}


VOID AUTHCTX::UnloadAll()
{
    // BUGBUG - AuthFlush is called when the last browser session
    // is closed. First the global Creds lists are destructed, and
    // then this func (UnloadAll) is called. However, the global
    // Creds lists are not necessarily flushed (they may have out-
    // standing ref counts) and may persist across browser sessions.
    // when we destruct the SPM list in this func, SPMs reference
    // by any surviving Creds entries are bogus and can be used
    // for subsequent authentication, resulting in a fault.
    //
    // The temporary hack here is to not destruct the SPM
    // list if any Creds list is not destructed. We leak the
    // SPM list on process detach but don't fault. Put the
    // SPM destruct code in DllProcessDetach.
    
    SPMData *pData = g_pSPMList;
    while (pData)
    {
        SPMData *pNext = pData->pNext;
        delete pData;
        pData = pNext;
    }

    SSPI_Unload();
    g_eState = STATE_NOTLOADED;
    g_pSPMList = NULL;
}

DWORD StringSchemeToDword(LPSTR szScheme)
{
    if (!stricmp(szScheme, "Basic"))
    {
        return WINHTTP_AUTH_SCHEME_BASIC;
    }
    else if (!stricmp(szScheme, "Digest"))
    {
        return WINHTTP_AUTH_SCHEME_DIGEST;
    }
    else if (!stricmp(szScheme, "Passport1.4"))
    {
        return WINHTTP_AUTH_SCHEME_PASSPORT;
    }
    else if (!stricmp(szScheme, "NTLM"))
    {
        return WINHTTP_AUTH_SCHEME_NTLM;
    }
    else if (!stricmp(szScheme, "Negotiate"))
    {
        return WINHTTP_AUTH_SCHEME_NEGOTIATE;
    }
    else
    {
        return 0;
    }
}

/*---------------------------------------------------------------------------
    CreateAuthCtx
    Create an AUTHCTX* from headers - initially the authentication context
    is created without a AUTH_CREDS entry. The AUTH_CREDS entry will be found or created
    and possibly updated in UpdateFromHeaders.
---------------------------------------------------------------------------*/
AUTHCTX* AUTHCTX::CreateAuthCtx(HTTP_REQUEST_HANDLE_OBJECT * pRequest, BOOL fIsProxy)
{
    LPSTR szScheme;
    DWORD cbScheme, dwError, dwAuthIdx;
    AUTHCTX *pAuthCtx = NULL;

    dwAuthIdx = 0;
    szScheme = NULL;


    // Get scheme. This is assumed to be the first
    // non-ws token in the auth header info.
    do
    {
        // It is necessary to hold on to the auth index
        // in this loop because we could have gone through
        // more than one scheme.
        dwError = GetAuthHeaderData(pRequest, fIsProxy, NULL,
            &szScheme, &cbScheme, ALLOCATE_BUFFER | GET_SCHEME, dwAuthIdx);

        if (dwError != ERROR_SUCCESS)
            goto quit;

        pRequest->_SupportedSchemes |= StringSchemeToDword(szScheme);
        pRequest->_AuthTarget = fIsProxy ? WINHTTP_AUTH_TARGET_PROXY : WINHTTP_AUTH_TARGET_SERVER;
        
        // This will create the appropriate authentication context
        // with a NULL password cache. The password cache will be
        // created in the call to UpdateFromHeaders.
        
        if (pAuthCtx == NULL)
        {
            pAuthCtx = CreateAuthCtx(pRequest, fIsProxy, szScheme);

            // If creation of an auth context is successful, update
            // the context from any header info.
            if (pAuthCtx)
            {
                if (pAuthCtx->UpdateFromHeaders(pRequest, fIsProxy) != ERROR_SUCCESS)
                {
                    delete pAuthCtx;
                    pAuthCtx = NULL;
                }
                else
                {
                    pRequest->_PreferredScheme = StringSchemeToDword(szScheme);
                }
            }
        }
        
        dwAuthIdx++;

        delete szScheme;
        szScheme = NULL;

    } while (1);

quit:

    if (szScheme)
        delete szScheme;

    return pAuthCtx;
}

/*---------------------------------------------------------------------------
    CreateAuthCtx
    Create an AUTHCTX without a AUTH_CREDS from scheme
---------------------------------------------------------------------------*/
AUTHCTX* AUTHCTX::CreateAuthCtx(HTTP_REQUEST_HANDLE_OBJECT *pRequest,
    BOOL fIsProxy, LPSTR szScheme)
{
    if (!AuthLock())
    {
        return NULL;
    }

    AUTHCTX *pNewAuthCtx = NULL;

    // we don't want to create a Passport1.4 context on 401 response (from DA)
    if (!lstrcmpi("Passport1.4", szScheme))
    {
        if (pRequest->GetStatusCode() == HTTP_STATUS_DENIED)
        {
            goto quit;
        }
    }

    // If necessary, enumerate auth providers from registry.
    if (AUTHCTX::GetSPMListState() == AUTHCTX::STATE_NOTLOADED)
        AUTHCTX::Enumerate();

    if (AUTHCTX::GetSPMListState() != AUTHCTX::STATE_LOADED)
    {
        // not critical, just no authentication
        goto quit;
    }

    SPMData *pSPM;
    pSPM = g_pSPMList;

    // Find SPMData to create from scheme.
    while (pSPM)
    {
        if (!lstrcmpi(pSPM->szScheme, szScheme))
            break;

        pSPM = pSPM->pNext;
    }

    if (!pSPM)
    {
        // No matching auth scheme found.
        // Not critical, just no auth.
        goto quit;
    }

    // Create an auth context without Creds
    switch(pSPM->eScheme)
    {
        // Create BASIC_CTX with NULL AUTH_CREDS.
        case WINHTTP_AUTH_SCHEME_BASIC:
            pNewAuthCtx = New BASIC_CTX(pRequest, fIsProxy, pSPM, NULL);
            break;

        // Create DIGEST_CTX with NULL AUTH_CREDS.
        case WINHTTP_AUTH_SCHEME_DIGEST:
            pNewAuthCtx = New DIGEST_CTX(pRequest, fIsProxy, pSPM, NULL);
            break;

        case WINHTTP_AUTH_SCHEME_PASSPORT:
            pNewAuthCtx = new PASSPORT_CTX(pRequest, fIsProxy, pSPM, NULL);
            if (pNewAuthCtx)
            {
                if (((PASSPORT_CTX*)pNewAuthCtx)->Init() == FALSE)
                {
                    delete pNewAuthCtx;
                    pNewAuthCtx = NULL;
                }
            }
            break;

        // Create PLUG_CTX with NULL AUTH_CREDS.
        case WINHTTP_AUTH_SCHEME_NTLM:
        case WINHTTP_AUTH_SCHEME_NEGOTIATE:

        default:
            pNewAuthCtx = New PLUG_CTX(pRequest, fIsProxy, pSPM, NULL);

    }


quit:
    AuthUnlock();
    return pNewAuthCtx;
}


/*---------------------------------------------------------------------------
    CreateAuthCtx
    Create an AUTHCTX from a AUTH_CREDS.
---------------------------------------------------------------------------*/
AUTHCTX* AUTHCTX::CreateAuthCtx(HTTP_REQUEST_HANDLE_OBJECT *pRequest,
                    BOOL fIsProxy, AUTH_CREDS* pCreds)
{
    if (!AuthLock())
    {
        return NULL;
    }
    
    AUTHCTX *pNewAuthCtx = NULL;

    // If necessary, enumerate auth providers from registry.
    if (AUTHCTX::GetSPMListState() == AUTHCTX::STATE_NOTLOADED)
        AUTHCTX::Enumerate();

    if (AUTHCTX::GetSPMListState() != AUTHCTX::STATE_LOADED)
    {
        // not critical, just no authentication
        goto quit;
    }

    // Handle tests (via proxy, is keep-alive)
    // will be done in UpdateFromHeaders. Here
    // we just construct the AUTHCTX.
    switch(pCreds->pSPM->eScheme)
    {
        // Create BASIC_CTX.
        case WINHTTP_AUTH_SCHEME_BASIC:

            pNewAuthCtx = New BASIC_CTX(pRequest, fIsProxy, pCreds->pSPM, pCreds);
            break;

        // Create DIGEST_CTX.
        case WINHTTP_AUTH_SCHEME_DIGEST:
            pNewAuthCtx = New DIGEST_CTX(pRequest, fIsProxy, pCreds->pSPM, pCreds);
            break;

        case WINHTTP_AUTH_SCHEME_PASSPORT:
            pNewAuthCtx = new PASSPORT_CTX(pRequest, fIsProxy, pCreds->pSPM, pCreds);
            if (pNewAuthCtx)
            {
                if (((PASSPORT_CTX*)pNewAuthCtx)->Init() == FALSE)
                {
                    delete pNewAuthCtx;
                    pNewAuthCtx = NULL;
                }
            }
            break;

        // Create PLUG_CTX.
        case WINHTTP_AUTH_SCHEME_NTLM:
        case WINHTTP_AUTH_SCHEME_NEGOTIATE:

        default:
            pNewAuthCtx = New PLUG_CTX(pRequest, fIsProxy, pCreds->pSPM, pCreds);

    }


quit:
    AuthUnlock();
    return pNewAuthCtx;
}

AUTHCTX::SPMState AUTHCTX::GetSPMListState()
    { return g_eState; }


/*-----------------------------------------------------------------------------
    SearchCredsList
-----------------------------------------------------------------------------*/
//AUTH_CREDS* AUTHCTX::SearchCredsList
//    (AUTH_CREDS* Creds, LPSTR lpszHost, LPSTR lpszUri, LPSTR lpszRealm, SPMData *pSPM)
/*++

Routine Description:
    Scans the Linked List Cache for URLs, Realms, and Servers.  Also allows
    filter fields, to narrow searches.

Arguments:
    Creds                   - Pointer to first item to search from.
    lpszHost              - Host, or Server name to search on.
    lpszUri               - URL to search on.
    lpszRealm             - Security Realm to search on
    lpszScheme            - Authentication scheme to search on.
Return Value:

    AUTH_CREDS *
    Success - Pointer to found item.

    Failure - NULL pointer.

Comments:
    Note: This Legacy code from the SpyGlass IE 1.0 browser

    The AUTH_CREDS lists are searched on every request.  Could optimize by keeping
    a hash value of the server/proxy name.

    If an exact match isn't found on a 401 response, the list is walked again
    to search for a realm match.  Could add a parameter to do both at once.
--*/

/*
{
    AssertHaveLock();

    while (Creds)
    {
        if (   (!pSPM || pSPM == Creds->pSPM)
            && (!lpszHost  || !lstrcmpi(Creds->lpszHost,lpszHost))
            && (!lpszRealm || !lstrcmpi(Creds->lpszRealm,lpszRealm))
            && (!lpszUri   || TemplateMatch (Creds->lpszUrl, lpszUri))
           )
        {

            DEBUG_PRINT(HTTP, INFO, ("Lookup: Found template match [%q]\n",
                Creds->lpszUser));
            return Creds;
        }
        else
        {
            Creds = Creds->pNext;
        }
    }

    return NULL;
}
*/



/*-----------------------------------------------------------------------------
    FindOrCreateCreds
-----------------------------------------------------------------------------*/
AUTH_CREDS* AUTHCTX::CreateCreds(
    HTTP_REQUEST_HANDLE_OBJECT *pRequest,
    BOOL     fIsProxy,
    SPMData *pSPM,
    LPSTR    lpszRealm
)
{
    //AssertHaveLock();

    // Create a AUTH_CREDS.
    AUTH_CREDS *Creds;
    Creds = NULL;

    if (!pSPM)
    {
        INET_ASSERT(FALSE);
        goto quit;
    }

    // Get host from request handle.
    LPSTR lpszHost;
    lpszHost = fIsProxy?
        GetProxyName(pRequest) : pRequest->GetServerName();

    // For NTLM, use the hostname analagously to basic realm.
    if (pSPM->eScheme == WINHTTP_AUTH_SCHEME_NTLM || pSPM->eScheme == WINHTTP_AUTH_SCHEME_NEGOTIATE)
    {
        INET_ASSERT (!lpszRealm);
        lpszRealm = lpszHost;
    }

    Creds = Creds_Create (lpszHost, lpszRealm, pSPM);
    
quit:
    
    return Creds;
}

/*-----------------------------------------------------------------------------
    GetAuthHeaderData
-----------------------------------------------------------------------------*/
DWORD AUTHCTX::GetAuthHeaderData(
    HTTP_REQUEST_HANDLE_OBJECT *pRequest,
    BOOL      fIsProxy,
    LPSTR     szItem,
    LPSTR    *pszData,
    LPDWORD   pcbData,
    DWORD     dwFlags,
    DWORD     dwIndex)
{
    LPSTR szData;
    DWORD cbData, cbItem, dwError = ERROR_SUCCESS;;
    CHAR *szTok, *szKey, *szValue;
    DWORD cbTok, cbKey, cbValue;

    szTok = szKey = szValue = NULL;
    cbTok = cbKey = cbValue = NULL;

    cbItem = szItem ? strlen(szItem) : 0;

    DWORD dwQuery = fIsProxy?
        HTTP_QUERY_PROXY_AUTHENTICATE : HTTP_QUERY_WWW_AUTHENTICATE;

    // NULL item passed in means get up to the first \r\n, or
    // possibly only the scheme is desired depending on dwFlags.
    if (!cbItem)
    {
        if ((dwError = pRequest->FastQueryResponseHeader(dwQuery,
            (LPVOID*) &szData,
            &cbData,
            dwIndex)) != ERROR_SUCCESS)
        {
            goto quit;
        }

        // Only the scheme is desired.
        if (dwFlags & GET_SCHEME)
        {
            CHAR* ptr;
            ptr = szValue = szData;
            cbValue = 0;
            while (!(*ptr == ' ' || *ptr == '\t' || *ptr == '\r' || *ptr == '\n'))
            {
                ptr++;
                cbValue++;
            }
        }
        else
        {
            // The entire header is desired.
            szValue = szData;
            cbValue = cbData;
        }

    }
    else
    {
        // An item was passed in - attempt to parse this
        // from the headers and return the corresponding
        // value.
        if ((dwError = pRequest->FastQueryResponseHeader(dwQuery,
                  (LPVOID*) &szData,
                  &cbData,
                  dwIndex)) != ERROR_SUCCESS)
        {
            goto quit;
        }

        // Successfully retrieved header. Parse for the desired item.

        // Point past scheme
        while (!(*szData == ' ' || *szData == '\t' || *szData == '\r' || *szData == '\n'))
        {
            szData++;
            cbData--;
        }

        // Attempt to parse an item of the format 'key = <">value<">'
        // from a comma delmited list of items.
        dwError = ERROR_HTTP_HEADER_NOT_FOUND;
        while (GetDelimitedToken(&szData, &cbData, &szTok, &cbTok, ','))
        {
            if (GetKeyValuePair(szTok, cbTok, &szKey, &cbKey, &szValue, &cbValue))
            {
                if ((cbItem == cbKey) && !strnicmp(szKey, szItem, cbItem))
                {
                    TrimQuotes(&szValue, &cbValue);
                    dwError = ERROR_SUCCESS;
                    break;
                }
            }
        }

    }

    if (dwError == ERROR_SUCCESS)
    {
        // Allocate buffer containing data
        // or return reference.
        if (dwFlags & ALLOCATE_BUFFER)
        {
            *pszData = New CHAR[cbValue+1];
            if (!*pszData)
            {
                dwError = ERROR_NOT_ENOUGH_MEMORY;
                goto quit;
            }
            memcpy(*pszData, szValue, cbValue);
            (*pszData)[cbValue] = '\0';
            *pcbData = cbValue;
        }
        else
        {
            *pszData = szValue;
            *pcbData = cbValue;
        }
    }

quit:

    if (dwError != ERROR_SUCCESS)
    {
        INET_ASSERT(dwIndex || dwError == ERROR_HTTP_HEADER_NOT_FOUND);
    }

    return dwError;
}


// ------------------------  Base class funcs---------------------------------




/*-----------------------------------------------------------------------------
FindHdrIdxFromScheme
-----------------------------------------------------------------------------*/
DWORD AUTHCTX::FindHdrIdxFromScheme(LPDWORD pdwIndex)
{
    LPSTR szHeader;
    DWORD cbScheme, cbHeader, dwQuery, dwError;

    dwQuery = _fIsProxy?
        HTTP_QUERY_PROXY_AUTHENTICATE : HTTP_QUERY_WWW_AUTHENTICATE;

    *pdwIndex = 0;

    while ((dwError = _pRequest->FastQueryResponseHeader(dwQuery,
            (LPVOID*) &szHeader,
            &cbHeader,
            *pdwIndex)) == ERROR_SUCCESS)
    {
        DWORD cb = 0;
        CHAR *ptr = szHeader;
        while (!(*ptr == ' ' || *ptr == '\t' || *ptr == '\r' || *ptr == '\n'))
        {
            ptr++;
            cb++;
        }

        if ((_pSPMData->cbScheme == cb)
            && (!strnicmp(_pSPMData->szScheme, szHeader, cb)))
        {
            break;
        }
        (*pdwIndex)++;
    }
    return dwError;
}

/*-----------------------------------------------------------------------------
    Get funcs.
-----------------------------------------------------------------------------*/
LPSTR AUTHCTX::GetScheme()
    { return _pSPMData->szScheme; }

DWORD AUTHCTX::GetSchemeType()
{
    if (_pSPMData->eScheme == WINHTTP_AUTH_SCHEME_NEGOTIATE)
    {
        if (_eSubScheme == WINHTTP_AUTH_SCHEME_NTLM || _eSubScheme == WINHTTP_AUTH_SCHEME_KERBEROS)
        {
            return _eSubScheme;
        }
    }
    return _pSPMData->eScheme;
}

DWORD AUTHCTX::GetRawSchemeType()
{
    return _pSPMData->eScheme;
}

DWORD AUTHCTX::GetFlags()
{
    if (_pSPMData->eScheme == WINHTTP_AUTH_SCHEME_NEGOTIATE)
    {
        if (_eSubScheme == WINHTTP_AUTH_SCHEME_NTLM || _eSubScheme == WINHTTP_AUTH_SCHEME_KERBEROS)
        {
            return _dwSubFlags;
        }
    }
    return _pSPMData->dwFlags;
}

AUTHCTX::SPMState AUTHCTX::GetState()
    { return _pSPMData->eState; }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\auth\passport.cxx ===
#include <wininetp.h>
#include <urlmon.h>
#include <splugin.hxx>
#include "htuu.h"

/*---------------------------------------------------------------------------
PASSPORT_CTX
---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------
    Constructor
---------------------------------------------------------------------------*/
PASSPORT_CTX::PASSPORT_CTX(HTTP_REQUEST_HANDLE_OBJECT *pRequest, BOOL fIsProxy, 
                    SPMData* pSPM, AUTH_CREDS* pCreds)
    : AUTHCTX(pSPM, pCreds)
{
    _fIsProxy = fIsProxy;

    _pRequest = pRequest;
    
    m_hLogon = NULL;

    m_pNewThreadInfo = NULL;
    m_pwszPartnerInfo = NULL;
    m_lpszRetUrl = NULL;

    m_wRealm[0] = '\0';
    m_FromPP[0] = '\0';

    ::MultiByteToWideChar(CP_ACP, 0, _pRequest->GetServerName(), -1, m_wTarget, MAX_AUTH_TARGET_LEN);
}

BOOL PASSPORT_CTX::Init(void)
{
    m_pNewThreadInfo = ::InternetCreateThreadInfo(FALSE);
    if (m_pNewThreadInfo == NULL)
    {
        return FALSE;
    }

    LPINTERNET_THREAD_INFO pCurrentThreadInfo = ::InternetGetThreadInfo();
    m_pNewThreadInfo->ThreadId = ::GetCurrentThreadId();
    ::InternetSetThreadInfo(m_pNewThreadInfo);
    
    m_pInternet = GetRootHandle (_pRequest);
    
    if (!m_pInternet->GetPPContext())
    {
        PP_CONTEXT hPP = ::PP_InitContext(L"WinHttp5.Dll", NULL);
        m_pInternet->SetPPContext(hPP);
        hPP = NULL;
    }
    
    ::InternetSetThreadInfo(pCurrentThreadInfo);

    if (!m_pInternet->GetPPContext())
    {
        return FALSE;
    }
    
    return TRUE;
}
/*---------------------------------------------------------------------------
    Destructor
---------------------------------------------------------------------------*/
PASSPORT_CTX::~PASSPORT_CTX()
{
    LPINTERNET_THREAD_INFO pCurrentThreadInfo = ::InternetGetThreadInfo();
    
    m_pNewThreadInfo->ThreadId = ::GetCurrentThreadId();
    ::InternetSetThreadInfo(m_pNewThreadInfo);
    
    if (m_hLogon)
    {
        ::PP_FreeLogonContext(m_hLogon);
        m_hLogon = NULL;
    }

    ::InternetSetThreadInfo(pCurrentThreadInfo);

    if (m_pNewThreadInfo)
    {
        ::InternetFreeThreadInfo(m_pNewThreadInfo);
    }

    if (m_pwszPartnerInfo)
    {
        delete [] m_pwszPartnerInfo;
    }

    if (m_lpszRetUrl)
    {
        delete [] m_lpszRetUrl;
    }

}

CHAR g_szPassportDAHost[256];

BOOL PASSPORT_CTX::CallbackRegistered(void)
{
    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo)
    {
        WINHTTP_STATUS_CALLBACK appCallback = 
            ((INTERNET_HANDLE_BASE *)lpThreadInfo->hObjectMapped)->GetStatusCallback();

        if (appCallback != NULL) 
        {
            return TRUE;
        }
    }

    return FALSE;
}


DWORD PASSPORT_CTX::HandleSuccessfulLogon(
    LPWSTR  pwszFromPP,
    PDWORD  pdwFromPP,
    BOOL    fPreAuth
    )
{
    // biaow-todo: I am betting the RU DWORD UrlLength = 1024;
    LPWSTR pwszUrl = (LPWSTR) ALLOCATE_FIXED_MEMORY(1024 * sizeof(WCHAR));
    DWORD dwwUrlLength = 1024;//             won't be too long, but I could be wrong 
    LPSTR pszUrl = (LPSTR) ALLOCATE_FIXED_MEMORY(dwwUrlLength * sizeof(CHAR));
    BOOL fRetrySameUrl;
    DWORD dwRet = ERROR_SUCCESS;

    if (pwszUrl == NULL || pszUrl == NULL)
    {
        dwRet = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    if (::PP_GetAuthorizationInfo(m_hLogon,
                                  pwszFromPP, 
                                  pdwFromPP,
                                  &fRetrySameUrl,
                                  pwszUrl,
                                  &dwwUrlLength
                                  ) == FALSE)    
    {
        INET_ASSERT(TRUE); // this shouldn't happen
        dwRet = ERROR_WINHTTP_LOGIN_FAILURE;
        goto exit;
    }

    // save the DA Host name for Logout security check
    WCHAR wszDAHost[256];
    DWORD dwHostLen = ARRAY_ELEMENTS(wszDAHost);
    if (::PP_GetLogonHost(m_hLogon, 
                          wszDAHost, &dwHostLen) == TRUE)
    {
        ::WideCharToMultiByte(CP_ACP, 0, wszDAHost, -1, g_szPassportDAHost, 256, NULL, NULL);
    }

    if (!fRetrySameUrl)
    {
        if (_pRequest->GetMethodType() == HTTP_METHOD_TYPE_GET)
        {
            // DA wanted us to GET to a new Url
            ::WideCharToMultiByte(CP_ACP, 0, pwszUrl, -1, pszUrl, 1024, NULL, NULL);
        }
        else
        {
            fRetrySameUrl = TRUE; // *** WinHttp currently supports retry custom verb to same URL only ***
        }
    }
    
    if (fPreAuth)
    {
        // We are sending, in the context of AuthOnRequest.

        if (fRetrySameUrl)
        {
            // DA told us to keep Verb & Url, so there is nothing more needs to be done
            goto exit;
        }
        
        // Regardless whether we are asked to handle redirect, we'll need to fake
        // that a 302 just came in. 
        
        // biaow-todo: this is causing problem for QueryHeaders(StatusCode). I don't know why yet...
        /*
        _pRequest->AddInternalResponseHeader(HTTP_QUERY_STATUS_TEXT, // use non-standard index, since we never query this normally
                                  "HTTP/1.0 302 Object Moved",
                                  strlen("HTTP/1.0 302 Object Moved")
                                  );
        _pRequest->AddInternalResponseHeader(HTTP_QUERY_LOCATION, 
                                             pszUrl, 
                                             strlen(pszUrl));
        */

        if (_pRequest->GetOpenFlags() & INTERNET_FLAG_NO_AUTO_REDIRECT)
        {
            if (!CallbackRegistered())
            {
                _pRequest->SetPPAbort(TRUE);
                dwRet = ERROR_WINHTTP_LOGIN_FAILURE;
                goto exit;
            }
        }
        
        ::InternetIndicateStatusString(WINHTTP_CALLBACK_STATUS_REDIRECT, pszUrl);
    }
    else
    {
        // We are receiving a 302, in the context of AuthOnResponse.
        
        // Here we need to re-play the request to lpszRetUrl. One way to 
        // achieve this is returning ERROR_INTERNET_FORCE_RETRY. But before
        // that, we'll need to remember the lpszRetUrl.

        // *NOTE* This is in effective an 401. To prevent the send path from
        // following the 302 Location: header, caller must set the status code
        // to 401.

        if (!fRetrySameUrl)
        {
            if (_pRequest->GetOpenFlags() & INTERNET_FLAG_NO_AUTO_REDIRECT)
            {
                if (!CallbackRegistered())
                {
                    dwRet = ERROR_WINHTTP_LOGIN_FAILURE;
                    goto exit;
                }

                ::InternetIndicateStatusString(WINHTTP_CALLBACK_STATUS_REDIRECT, pszUrl);
            }
        }
        
        dwRet = ERROR_WINHTTP_RESEND_REQUEST;
    }

    PCSTR lpszRetUrl = NULL;

    if (fRetrySameUrl)
    {
        lpszRetUrl = _pRequest->GetURL();
    }
    else
    {
        lpszRetUrl = pszUrl;
    }

    if (m_lpszRetUrl)
    {
        delete [] m_lpszRetUrl;
    }

    m_lpszRetUrl = new CHAR[strlen(lpszRetUrl) + 1];
    if (m_lpszRetUrl)
    {
        strcpy(m_lpszRetUrl, lpszRetUrl);
    }

exit:

    if (pwszUrl)
    {
        FREE_MEMORY(pwszUrl);
    }
    if (pszUrl)
    {
        FREE_MEMORY(pszUrl);
    }
    
    return dwRet;
}

/*---------------------------------------------------------------------------
    PreAuthUser
---------------------------------------------------------------------------*/
DWORD PASSPORT_CTX::PreAuthUser(IN LPSTR pBuf, IN OUT LPDWORD pcbBuf)
{
    DEBUG_ENTER ((
		DBG_HTTP,
        Dword,
        "PASSPORT_CTX::PreAuthUser",
        "this=%#x pBuf=%#x pcbBuf=%#x {%d}",
        this,
        pBuf,
        pcbBuf,
        *pcbBuf
        ));

    DWORD dwError = ERROR_SUCCESS;
    LPWSTR pwszFromPP = NULL;
    LPWSTR pwszUser = NULL;
    LPWSTR pwszPass = NULL;

    // Prefix the header value with the auth type.
    const static BYTE szPassport[] = "Passport1.4 ";
    #define PASSPORT_LEN sizeof(szPassport)-1
    
    if (m_FromPP[0] == '\0') 
    {
        DWORD dwFromPPLen = 2048;
        pwszFromPP = (LPWSTR) ALLOCATE_FIXED_MEMORY(dwFromPPLen * sizeof(WCHAR));

        if (pwszFromPP == NULL)
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }

        LPINTERNET_THREAD_INFO pCurrentThreadInfo = ::InternetGetThreadInfo();

        m_pNewThreadInfo->ThreadId = ::GetCurrentThreadId();
        ::InternetSetThreadInfo(m_pNewThreadInfo);

        // if an app already specified creds, use them and do a pre-authentication.

        if (_pCreds->lpszUser && _pCreds->lpszPass)
        {
            pwszUser = (LPWSTR) ALLOCATE_FIXED_MEMORY((strlen(_pCreds->lpszUser) + 1) * sizeof(WCHAR));
            pwszPass = (LPWSTR) ALLOCATE_FIXED_MEMORY((strlen(_pCreds->lpszPass) + 1) * sizeof(WCHAR));

            if (pwszUser == NULL || pwszPass == NULL)
            {
                ::InternetSetThreadInfo(pCurrentThreadInfo);
                dwError = ERROR_NOT_ENOUGH_MEMORY;
                goto cleanup;
            }

            ::MultiByteToWideChar(CP_ACP, 0, _pCreds->lpszUser, -1, pwszUser, strlen(_pCreds->lpszUser) + 1);
            ::MultiByteToWideChar(CP_ACP, 0, _pCreds->lpszPass, -1, pwszPass, strlen(_pCreds->lpszPass) + 1);

            ::PP_SetCredentials(m_hLogon, NULL, NULL, pwszUser, pwszPass);
        }

        // we could do a PP_SetCredentials(...null,null) here. But I don't think we need to.

        DWORD dwLogonStatus = ::PP_Logon(m_hLogon,
                                         0,
                                         NULL,
                                         0);

        ::InternetSetThreadInfo(pCurrentThreadInfo);

        if (dwLogonStatus != PP_LOGON_SUCCESS)
        {
            dwError = ERROR_WINHTTP_LOGIN_FAILURE;
            goto cleanup;
        }

        dwError = HandleSuccessfulLogon(pwszFromPP, &dwFromPPLen, TRUE);

        if (dwError == ERROR_WINHTTP_LOGIN_FAILURE)
        {
            goto cleanup;
        }
        
        ::WideCharToMultiByte(CP_ACP, 0, pwszFromPP, -1, m_FromPP, 2048, NULL, NULL);
    }

    // check to see if we need to update url

    if (m_lpszRetUrl)
    {
        _pRequest->ModifyRequest(_pRequest->GetMethodType(),
                                 m_lpszRetUrl,
                                 strlen(m_lpszRetUrl),
                                 NULL,
                                 0);
        delete [] m_lpszRetUrl;
        m_lpszRetUrl = NULL;
    }

    // Ticket and profile is already present
    
    // put in the header
    memcpy (pBuf, szPassport, PASSPORT_LEN);
    pBuf += PASSPORT_LEN;
    
    // append the ticket
    strcpy(pBuf, m_FromPP);
    *pcbBuf = PASSPORT_LEN + strlen(m_FromPP);

cleanup:
    if (pwszFromPP)
        FREE_MEMORY(pwszFromPP);
    if (pwszUser)
        FREE_MEMORY(pwszUser);
    if (pwszPass)
        FREE_MEMORY(pwszPass);
exit:
    DEBUG_LEAVE(dwError);
    return dwError;
}

/*---------------------------------------------------------------------------
    UpdateFromHeaders
---------------------------------------------------------------------------*/
DWORD PASSPORT_CTX::UpdateFromHeaders(HTTP_REQUEST_HANDLE_OBJECT *pRequest, BOOL fIsProxy)
{
    DEBUG_ENTER ((
		DBG_HTTP,
        Dword,
        "PASSPORT_CTX::UpdateFromHeaders", 
        "this=%#x request=%#x isproxy=%B",
        this,
        pRequest,
        fIsProxy
        ));

    DWORD dwAuthIdx, cbChallenge, dwError;
    LPSTR szChallenge = NULL;

    LPINTERNET_THREAD_INFO pCurrentThreadInfo = NULL;
    LPINTERNET_THREAD_INFO pNewThreadInfo = NULL;
    
    // Get the associated header.
    if ((dwError = FindHdrIdxFromScheme(&dwAuthIdx)) != ERROR_SUCCESS)
        goto exit;

    // Get the complete auth header.
    dwError = GetAuthHeaderData(pRequest, fIsProxy, NULL, 
        &szChallenge, &cbChallenge, ALLOCATE_BUFFER, dwAuthIdx);

    if (dwError != ERROR_SUCCESS)
    {
        szChallenge = NULL;
        goto exit;
    }

    if (!_pCreds)
    {
        _pCreds = CreateCreds(pRequest, fIsProxy, _pSPMData, NULL);
        if (!_pCreds)
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }
    }
    
    if (m_pwszPartnerInfo)
    {
        delete [] m_pwszPartnerInfo;
    }

    {
        HTTP_METHOD_TYPE tOrgMethod = _pRequest->GetMethodType();
        PCSTR pszOrgVerb;
        ::MapHttpMethodType(tOrgMethod, &pszOrgVerb);
        PCSTR pszOrgUrl = _pRequest->GetURL();

        const LPWSTR pwszOrgVerbAttr = L",OrgVerb=";
        const LPWSTR pwszOrgUrlAttr =  L",OrgUrl=";

        DWORD dwPartnerInfoLength = cbChallenge 
                                    +::wcslen(pwszOrgVerbAttr)
                                    +::strlen(pszOrgVerb)
                                    +::wcslen(pwszOrgUrlAttr)
                                    +::strlen(pszOrgUrl)
                                    + 1; // NULL terminator
        
        DWORD dwSize = 0;
        PWSTR pwszPartnerInfo = NULL;

        m_pwszPartnerInfo = new WCHAR[dwPartnerInfoLength];
        if (m_pwszPartnerInfo == NULL)
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }

        pwszPartnerInfo = m_pwszPartnerInfo;

        dwSize = ::MultiByteToWideChar(CP_ACP, 0, szChallenge, -1, pwszPartnerInfo, dwPartnerInfoLength) - 1;
        ::wcscat(pwszPartnerInfo, pwszOrgVerbAttr);
        pwszPartnerInfo += (dwSize + wcslen(pwszOrgVerbAttr));
        dwPartnerInfoLength -= (dwSize + wcslen(pwszOrgVerbAttr));
        dwSize = ::MultiByteToWideChar(CP_ACP, 0, pszOrgVerb, -1, pwszPartnerInfo, dwPartnerInfoLength) - 1;
        ::wcscat(pwszPartnerInfo, pwszOrgUrlAttr);
        pwszPartnerInfo += (dwSize + wcslen(pwszOrgUrlAttr));
        dwPartnerInfoLength -= (dwSize + wcslen(pwszOrgUrlAttr));
        dwSize = ::MultiByteToWideChar(CP_ACP, 0, pszOrgUrl, -1, pwszPartnerInfo, dwPartnerInfoLength) - 1;

        dwError = ERROR_SUCCESS;
    }

exit:

    if (szChallenge)
        delete []szChallenge;

    DEBUG_LEAVE(dwError);
    return dwError;
}

BOOL PASSPORT_CTX::InitLogonContext(void)
{
    // set up the thread context before calling the Passport auth library
    
    LPINTERNET_THREAD_INFO pCurrentThreadInfo = ::InternetGetThreadInfo();
    m_pNewThreadInfo->ThreadId = ::GetCurrentThreadId();
    ::InternetSetThreadInfo(m_pNewThreadInfo);

    if (!m_hLogon)
    {
        INET_ASSERT(m_pInternet->GetPPContext()); // must have been initialized in the Init() call

        m_hLogon = ::PP_InitLogonContext(
                                        m_pInternet->GetPPContext(),
                                        m_pwszPartnerInfo,
                                        (_pRequest->GetOpenFlags() & INTERNET_FLAG_NO_COOKIES)
                                        );
    }

    // restore the WinHttp thread context
    ::InternetSetThreadInfo(pCurrentThreadInfo);
    
    return m_hLogon != NULL;
}

/*---------------------------------------------------------------------------
    PostAuthUser
---------------------------------------------------------------------------*/
DWORD PASSPORT_CTX::PostAuthUser()
{
    DEBUG_ENTER ((
                 DBG_HTTP,
                 Dword,
                 "PASSPORT_CTX::PostAuthUser",
                 "this=%#x",
                 this
                 ));

    LPWSTR pwszUser = NULL;
    LPWSTR pwszPass = NULL;
    DWORD dwRet = ERROR_SUCCESS;

    if (InitLogonContext() == FALSE)
    {
        dwRet = ERROR_WINHTTP_LOGIN_FAILURE;
        goto Cleanup;
    }

    // if an app already specified creds, use them and do a pre-authentication.
    
    if (_pCreds->lpszUser && _pCreds->lpszPass)
    {
        pwszUser = (LPWSTR) ALLOCATE_FIXED_MEMORY(1024*sizeof(WCHAR));
        pwszPass = (LPWSTR) ALLOCATE_FIXED_MEMORY(1024*sizeof(WCHAR));

        if (pwszUser && pwszPass)
        {
            ::MultiByteToWideChar(CP_ACP, 0, _pCreds->lpszUser, -1, pwszUser, 1024);
            ::MultiByteToWideChar(CP_ACP, 0, _pCreds->lpszPass, -1, pwszPass, 1024);

            ::PP_SetCredentials(m_hLogon, NULL, NULL, pwszUser, pwszPass);
        }
        else
        {
            dwRet = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
        
    }
        
    // Ok, Let's give it a try

    LPINTERNET_THREAD_INFO pCurrentThreadInfo = ::InternetGetThreadInfo();
    m_pNewThreadInfo->ThreadId = ::GetCurrentThreadId();
    ::InternetSetThreadInfo(m_pNewThreadInfo);
    
    DWORD dwLogonStatus = ::PP_Logon(m_hLogon, 
                                     0, 
                                     NULL, 
                                     0);

    // restore the WinHttp thread context
    ::InternetSetThreadInfo(pCurrentThreadInfo);

    if (dwLogonStatus == PP_LOGON_FAILED)
    {
        // App/User supplied wrong creds, sorry.
        
        dwRet = ERROR_WINHTTP_LOGIN_FAILURE;
    }
    else if (dwLogonStatus == PP_LOGON_REQUIRED)
    {
        // no creds specified, we are required to sign on.
        
        // change from 302 to 401
        _pRequest->ReplaceResponseHeader(HTTP_QUERY_STATUS_CODE,
                                        "401", strlen("401"),
                                        0, HTTP_ADDREQ_FLAG_REPLACE);

        // biaow-todo: 1) nice to replace the status text as well; weird to have "HTTP/1.1 401 object moved"
        // for example 2) remove the Location: header
        
        if (RetryLogon() == TRUE)
        {
            dwRet = ERROR_WINHTTP_RESEND_REQUEST;
        }
        else
        {
            dwRet = ERROR_WINHTTP_INCORRECT_PASSWORD;
        }
    }
    else if (dwLogonStatus == PP_LOGON_SUCCESS)
    {
        // wow! we got in!!!

        LPWSTR pwszFromPP = (LPWSTR) ALLOCATE_FIXED_MEMORY(2048*sizeof(WCHAR));
        DWORD dwFromPPLen = 2048;

        if (pwszFromPP)
        {
            dwRet = HandleSuccessfulLogon(pwszFromPP, &dwFromPPLen, FALSE);
            if (dwRet != ERROR_WINHTTP_LOGIN_FAILURE)
            {
                ::WideCharToMultiByte(CP_ACP, 0, pwszFromPP, -1, m_FromPP, 2048, NULL, NULL);
            }
            FREE_MEMORY(pwszFromPP);
        }
        else
        {
            dwRet = ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    else
    {
        dwRet = ERROR_WINHTTP_LOGIN_FAILURE;
    }

Cleanup:
    _pRequest->SetStatusCode(401);  // this is needed to prevent send code from tracing Location: header

    if (pwszUser)
        FREE_MEMORY(pwszUser);
    if (pwszPass)
        FREE_MEMORY(pwszPass);

    DEBUG_LEAVE(dwRet);
    return dwRet;
}

/*---------------------------------------------------------------------------
PASSPORT_CTX::PromptForCreds
---------------------------------------------------------------------------*/
BOOL PASSPORT_CTX::RetryLogon(void)
{
    DEBUG_ENTER ((
		DBG_HTTP,
        Dword,
        "PASSPORT_CTX::PromptForCreds",
        "this=%#x",
        this
        ));

    // WCHAR wUser[1024] = {0}; LPWSTR pwszUser = NULL; 
    // WCHAR wPass[1024] = {0}; LPWSTR pwszPass = NULL;
    BOOL fRetry = FALSE;

    INET_ASSERT(m_hLogon != 0);

    BOOL fPrompt = FALSE;
    WCHAR wRealm[MAX_AUTH_REALM_LEN];
    ::PP_GetChallengeInfo(m_hLogon, 
                          NULL, &fPrompt, 
                          NULL, 0, 
                          wRealm, MAX_AUTH_REALM_LEN);

    if (fPrompt)
    {
        goto exit;
    }

    /*
    if (_pCreds->GetUser() && _pCreds->GetPass())
    {
        ::MultiByteToWideChar(CP_ACP, 0, _pCreds->GetUser(), -1, wUser, 1024);
        ::MultiByteToWideChar(CP_ACP, 0, _pCreds->GetPass(), -1, wPass, 1024);

        pwszUser = wUser;
        pwszPass = wPass; 
    }
    */

    if (::PP_SetCredentials(m_hLogon, wRealm, m_wTarget, NULL, NULL) == TRUE)
    {
        fRetry = TRUE;
        goto exit;
    }

exit:

    DEBUG_LEAVE((DWORD) fRetry);
    return (DWORD) fRetry;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\auth\winctxt.h ===
#ifndef _WIN_SIC_CTXT_H_
#define _WIN_SIC_CTXT_H_

#define DEFAULT_SERVER_NAME_LEN		128

typedef struct _WINCONTEXT	{

    //
    //  Buffer for storing exchange blob returned by SSPI before 
    //  PreAuthenticateUser is called
    //
    char        *szOutBuffer;
    DWORD       cbOutBuffer;        // bytes associated with allocated szOutBuffer
	DWORD		dwOutBufferLength;

    char        *szInBuffer;
    DWORD       cbInBuffer;         // bytes associated with allocated szInBuffer
    PCHAR       pInBuffer;
	DWORD		dwInBufferLength;

	DWORD		dwCallId;

	DWORD		pkgId;

    CredHandle  Credential;     // SSPI credential handle for this connection
    PCredHandle pCredential;

	//
	// The SSPI Context Handle is stored here
	//
	CtxtHandle	SspContextHandle;
	PCtxtHandle	pSspContextHandle;  // before any ctxt is created, this is NULL

	LPSTR		lpszServerName;

	char		szServerName[DEFAULT_SERVER_NAME_LEN];

} WINCONTEXT, *PWINCONTEXT;

#endif  // _WIN_SIC_CTXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\auth\plug.cxx ===
#include <wininetp.h>
#include <splugin.hxx>
#include "auth.h"
#include "sspspm.h"
#include "winctxt.h"

extern SspData  *g_pSspData;
/*-----------------------------------------------------------------------------
    PLUG_CTX
-----------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
    Load
---------------------------------------------------------------------------*/
DWORD PLUG_CTX::Load()
{
    INET_ASSERT(_pSPMData == _pCreds->pSPM);

    DWORD_PTR dwAuthCode = 0;

    dwAuthCode = SSPI_InitScheme (GetScheme());

    if (!dwAuthCode)
    {
        _pSPMData->eState = STATE_ERROR;
        return ERROR_WINHTTP_INTERNAL_ERROR;
    }

    _pSPMData->eState = STATE_LOADED;
    return ERROR_SUCCESS;
}


/*---------------------------------------------------------------------------
    ClearAuthUser
---------------------------------------------------------------------------*/
DWORD PLUG_CTX::ClearAuthUser(LPVOID *ppvContext, LPSTR szServer)
{
    if (GetState() == AUTHCTX::STATE_LOADED)
    {
        __try
        {
            UnloadAuthenticateUser(ppvContext, szServer, GetScheme());
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            DEBUG_PRINT(HTTP, ERROR,
                ("UnloadAuthenticateUser call down faulted\n"));
        }
        ENDEXCEPT
    }
    *ppvContext = 0;
    return ERROR_SUCCESS;
}

/*-----------------------------------------------------------------------------
    wQueryHeadersAlloc

Routine Description:

    Allocates a HTTP Header String, and queries the HTTP handle for it.

Arguments:

    hRequestMapped          - An open HTTP request handle
                               where headers can be quiered
    dwQuery                 - The Query Type to pass to HttpQueryHeaders
    lpdwQueryIndex          - The Index of the header to pass to HttpQueryHeaders,
                              make sure to inialize to 0.
    lppszOutStr             - On success, a pointer to Allocated string with header string,
    lpdwSize                - size of the string returned in lppszOutStr

Return Value:

    DWORD
    Success - ERROR_SUCCESS

    Failure - One of Several Error codes defined in winerror.h or wininet.w

Comments:

    On Error, lppszOutStr may still contain an allocated string that will need to be
    freed.
-----------------------------------------------------------------------------*/
DWORD PLUG_CTX::wQueryHeadersAlloc
(
    IN HINTERNET hRequestMapped,
    IN DWORD dwQuery,
    OUT LPDWORD lpdwQueryIndex,
    OUT LPSTR *lppszOutStr,
    OUT LPDWORD lpdwSize
)
{
    LPSTR lpszRawHeaderBuf = NULL;
    DWORD dwcbRawHeaderBuf = 0;
    DWORD error;
    DWORD length;
    HTTP_REQUEST_HANDLE_OBJECT * pHttpRequest;

    INET_ASSERT(lppszOutStr);
    INET_ASSERT(hRequestMapped);
    INET_ASSERT(lpdwSize);
    INET_ASSERT((dwQuery & HTTP_QUERY_HEADER_MASK) != HTTP_QUERY_CUSTOM);

    *lppszOutStr = NULL;
    error = ERROR_SUCCESS;
    pHttpRequest = (HTTP_REQUEST_HANDLE_OBJECT *) hRequestMapped;

    // Attempt to determine whether our header is there.
    length = 0;
    if (pHttpRequest->QueryInfo(dwQuery, NULL, NULL, &length, lpdwQueryIndex)
          != ERROR_INSUFFICIENT_BUFFER)
    {
        // no authentication happening, we're done
        error = ERROR_HTTP_HEADER_NOT_FOUND;
        goto quit;
    }

    // Allocate a Fixed Size Buffer
    lpszRawHeaderBuf = (LPSTR) ALLOCATE_MEMORY(LPTR, length);
    dwcbRawHeaderBuf = length;

    if ( lpszRawHeaderBuf == NULL )
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    error = pHttpRequest->QueryInfo
        (dwQuery, NULL, lpszRawHeaderBuf, &dwcbRawHeaderBuf, lpdwQueryIndex);

    INET_ASSERT(error != ERROR_INSUFFICIENT_BUFFER );
    INET_ASSERT(error != ERROR_HTTP_HEADER_NOT_FOUND );

quit:

    if ( error != ERROR_SUCCESS  )
    {
        dwcbRawHeaderBuf = 0;

        if ( lpszRawHeaderBuf )
            *lpszRawHeaderBuf = '\0';
    }

    *lppszOutStr = lpszRawHeaderBuf;
    *lpdwSize = dwcbRawHeaderBuf;

    return error;
}

/*-----------------------------------------------------------------------------
    CrackAuthenticationHeader

Routine Description:

    Attempts to decode a HTTP 1.1 Authentication header into its
    components.

Arguments:

    hRequestMapped           - Mapped Request handle
    fIsProxy                 - Whether proxy or server auth
    lpdwAuthenticationIndex  - Index of current HTTP header. ( initally called with 0 )
    lppszAuthHeader          - allocated pointer which should be freed by client
    lppszAuthScheme          - Pointer to Authentication scheme string.
    lppszRealm               - Pointer to Realm string,
    lpExtra                  - Pointer to any Extra String data in the header that is not
                                   part of the Realm
    lpdwExtra                - Pointer to Size of Extra data.
    lppszAuthScheme

  Return Value:

    DWORD
    Success - ERROR_SUCCESS

    Failure - ERROR_NOT_ENOUGH_MEMORY,
              ERROR_HTTP_HEADER_NOT_FOUND

Comments:
-----------------------------------------------------------------------------*/
DWORD PLUG_CTX::CrackAuthenticationHeader
(
    IN HINTERNET hRequestMapped,
    IN BOOL      fIsProxy,
    IN     DWORD dwAuthenticationIndex,
    IN OUT LPSTR *lppszAuthHeader,
    IN OUT LPSTR *lppszExtra,
    IN OUT DWORD *lpdwExtra,
       OUT LPSTR *lppszAuthScheme
    )
{
    DWORD error = ERROR_SUCCESS;

    LPSTR lpszAuthHeader = NULL;
    DWORD cbAuthHeader = 0;
    LPSTR lpszExtra = NULL;
    LPSTR lpszAuthScheme = NULL;

    LPDWORD lpdwAuthenticationIndex = &dwAuthenticationIndex;
    INET_ASSERT(lpdwExtra);
    INET_ASSERT(lppszExtra);
    INET_ASSERT(lpdwAuthenticationIndex);

    DWORD dwQuery = fIsProxy?
        HTTP_QUERY_PROXY_AUTHENTICATE : HTTP_QUERY_WWW_AUTHENTICATE;

    error = wQueryHeadersAlloc (hRequestMapped, dwQuery,
        lpdwAuthenticationIndex, &lpszAuthHeader, &cbAuthHeader);

    if ( error != ERROR_SUCCESS )
    {
        INET_ASSERT(*lpdwAuthenticationIndex
            || error == ERROR_HTTP_HEADER_NOT_FOUND );
        goto quit;
    }


    //
    // Parse Header for Scheme type
    //
    lpszAuthScheme = lpszAuthHeader;

    while ( *lpszAuthScheme == ' ' )  // strip spaces
        lpszAuthScheme++;

    lpszExtra = strchr(lpszAuthScheme, ' ');

    if (lpszExtra)
        *lpszExtra++ = '\0';

    if (lstrcmpi(GetScheme(), lpszAuthScheme))
    {
        DEBUG_PRINT(HTTP, ERROR,
               ("Authentication: HTTP Scheme has changed!: Scheme=%q\n",
                lpszAuthScheme));
        goto quit;

    }


    DEBUG_PRINT (HTTP, INFO,
        ("Authentication: found in headers: Scheme=%q, Extra=%q\n",
        lpszAuthScheme, lpszExtra));

quit:
    *lppszExtra  = lpszExtra;
    *lpdwExtra   = lpszExtra ? lstrlen(lpszExtra) : 0;
    *lppszAuthHeader = lpszAuthHeader;
    *lppszAuthScheme = lpszAuthScheme;
    return error;
}


/*---------------------------------------------------------------------------
    ResolveProtocol
---------------------------------------------------------------------------*/
VOID PLUG_CTX::ResolveProtocol()
{
    SECURITY_STATUS ssResult;
    PWINCONTEXT pWinContext;
    SecPkgContext_NegotiationInfo SecPkgCtxtInfo;

    INET_ASSERT(GetSchemeType() == WINHTTP_AUTH_SCHEME_NEGOTIATE);
    
    SecPkgCtxtInfo.PackageInfo = NULL;

    // Call QueryContextAttributes on the context handle.
    pWinContext = (PWINCONTEXT) (_pvContext);
    ssResult = (*(g_pSspData->pFuncTbl->QueryContextAttributes))
        (pWinContext->pSspContextHandle, SECPKG_ATTR_NEGOTIATION_INFO, &SecPkgCtxtInfo);

    if (ssResult == SEC_E_OK 
        && (SecPkgCtxtInfo.NegotiationState == SECPKG_NEGOTIATION_COMPLETE
            || (SecPkgCtxtInfo.NegotiationState == SECPKG_NEGOTIATION_OPTIMISTIC)))
    {
        // Resolve actual auth protocol from package name.
        // update both the auth context and Creds entry.
        if (!lstrcmpi(SecPkgCtxtInfo.PackageInfo->Name, "NTLM"))
        {
            _eSubScheme = WINHTTP_AUTH_SCHEME_NTLM;
            _dwSubFlags = PLUGIN_AUTH_FLAGS_NO_REALM;
        }
        else if (!lstrcmpi(SecPkgCtxtInfo.PackageInfo->Name, "Kerberos"))
        {
            _eSubScheme = WINHTTP_AUTH_SCHEME_KERBEROS;            
            _dwSubFlags = PLUGIN_AUTH_FLAGS_KEEP_ALIVE_NOT_REQUIRED | PLUGIN_AUTH_FLAGS_NO_REALM;
        }

// BUGBUG - This faults.
//        

    }

    if (SecPkgCtxtInfo.PackageInfo)
    {
        (*(g_pSspData->pFuncTbl->FreeContextBuffer))(SecPkgCtxtInfo.PackageInfo);
    }
}


/*---------------------------------------------------------------------------
    Constructor
---------------------------------------------------------------------------*/
PLUG_CTX::PLUG_CTX(HTTP_REQUEST_HANDLE_OBJECT *pRequest, BOOL fIsProxy,
                 SPMData *pSPM, AUTH_CREDS* pCreds)
    : AUTHCTX(pSPM, pCreds)
{
    _fIsProxy = fIsProxy;
    _pRequest = pRequest;
    _szAlloc = NULL;
    _szData = NULL;
    _cbData = 0;
    _pRequest->SetAuthState(AUTHSTATE_NONE);
    _fNTLMProxyAuth = _fIsProxy && (GetSchemeType() == WINHTTP_AUTH_SCHEME_NTLM);

    _pszFQDN = NULL;
}

/*---------------------------------------------------------------------------
    Destructor
---------------------------------------------------------------------------*/
PLUG_CTX::~PLUG_CTX()
{
    if (GetState() == AUTHCTX::STATE_LOADED)
    {
        if (_pCreds)
        {
            if (_CtxCriSec.Lock())
            {
                ClearAuthUser(&_pvContext, _pCreds->lpszHost);

                _CtxCriSec.Unlock();
            }
        }
    }
    if (_pRequest)
    {
        _pRequest->SetAuthState(AUTHSTATE_NONE);
    }

    if (_pszFQDN)
    {
        FREE_MEMORY(_pszFQDN);
    }
}


/*---------------------------------------------------------------------------
    PreAuthUser
---------------------------------------------------------------------------*/
DWORD PLUG_CTX::PreAuthUser(OUT LPSTR pBuf, IN OUT LPDWORD pcbBuf)
{
    if (!_CtxCriSec.Lock())
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    INET_ASSERT(_pSPMData == _pCreds->pSPM);

    DWORD dwError;
    SECURITY_STATUS ssResult;

    //  Make sure the auth provider is loaded.
    if (GetState() != AUTHCTX::STATE_LOADED)
    {
        if (GetState() != AUTHCTX::STATE_ERROR )
            Load();
        if (GetState() != AUTHCTX::STATE_LOADED)
        {
            dwError = ERROR_WINHTTP_INTERNAL_ERROR;
            goto exit;
        }
    }

    BOOL fCanUseLogon = _fIsProxy 
        || _pRequest->SilentLogonOK(_pCreds->lpszHost);

    LPSTR lpszFQDN = GetFQDN(_pCreds->lpszHost);
    LPSTR lpszHostName =  lpszFQDN ? lpszFQDN : _pCreds->lpszHost;

    __try
    {
        ssResult = SEC_E_INTERNAL_ERROR;
        dwError = PreAuthenticateUser(&_pvContext,
                               lpszHostName,
                               GetScheme(),
                               fCanUseLogon,
                               0, // dwFlags
                               pBuf,
                               pcbBuf,
                               _pCreds->lpszUser,
                               _pCreds->lpszPass,
                               &ssResult);


        // Transit to the correct auth state.
        if (ssResult == SEC_E_OK || ssResult == SEC_I_CONTINUE_NEEDED)
        {
            if (GetSchemeType() == WINHTTP_AUTH_SCHEME_NEGOTIATE)
                ResolveProtocol();

            // Kerberos + SEC_E_OK or SEC_I_CONTINUE_NEEDED transits to challenge.
            // Negotiate does not transit to challenge.
            // Any other protocol + SEC_E_OK only transits to challenge.
            if ((GetSchemeType() == WINHTTP_AUTH_SCHEME_KERBEROS
                && (ssResult == SEC_E_OK || ssResult == SEC_I_CONTINUE_NEEDED))
                || (GetSchemeType() != WINHTTP_AUTH_SCHEME_NEGOTIATE && ssResult == SEC_E_OK))
            {
                _pRequest->SetAuthState(AUTHSTATE_CHALLENGE);
            }        
        }
    }

    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        DEBUG_PRINT (HTTP, ERROR, ("preAuthenticateUser call down faulted\n"));
        _pSPMData->eState = STATE_ERROR;
        dwError = ERROR_WINHTTP_INTERNAL_ERROR;
    }

    ENDEXCEPT

exit:
    _CtxCriSec.Unlock();
    return dwError;
}


/*---------------------------------------------------------------------------
    UpdateFromHeaders
---------------------------------------------------------------------------*/
DWORD PLUG_CTX::UpdateFromHeaders(HTTP_REQUEST_HANDLE_OBJECT *pRequest, BOOL fIsProxy)
{
    DWORD dwError, cbExtra, dwAuthIdx;
    LPSTR szAuthHeader, szExtra, szScheme;

    // Get the auth header index corresponding to the scheme of this ctx.
    if ((dwError = FindHdrIdxFromScheme(&dwAuthIdx)) != ERROR_SUCCESS)
        goto quit;

    // Get the scheme and any extra data.
    if ((dwError = CrackAuthenticationHeader(pRequest, fIsProxy, dwAuthIdx,
        &szAuthHeader, &szExtra, &cbExtra, &szScheme)) != ERROR_SUCCESS)
        goto quit;
    
    if (!cbExtra)
        _pRequest->SetAuthState(AUTHSTATE_NEGOTIATE);

    // Check if auth scheme requires keep-alive.
    if (!(GetFlags() & PLUGIN_AUTH_FLAGS_KEEP_ALIVE_NOT_REQUIRED))
    {
        // if in negotiate phase check if we are going via proxy.
        if (pRequest->GetAuthState() == AUTHSTATE_NEGOTIATE)
        {
            // BUGBUG: if via proxy, we are not going to get keep-alive
            // connection to the server.  It would be nice if we knew
            // a priori the whether proxy would allow us to tunnel to
            // http port on the server.  Otherwise if we try and fail,
            // we look bad vs. other browsers who are ignorant of ntlm
            // and fall back to basic.
            CHAR szBuffer[64];
            DWORD dwBufferLength = sizeof(szBuffer);
            DWORD dwIndex = 0;
            BOOL fSessionBasedAuth = FALSE;
            if (pRequest->QueryResponseHeader(HTTP_QUERY_PROXY_SUPPORT, 
                                          szBuffer, &dwBufferLength, 
                                          0, &dwIndex) == ERROR_SUCCESS)
            {
                if (!_stricmp(szBuffer, "Session-Based-Authentication"))
                {
                    fSessionBasedAuth = TRUE;
                }
            }
            if (!fIsProxy && pRequest->IsRequestUsingProxy()
                && !pRequest->IsTalkingToSecureServerViaProxy() && !fSessionBasedAuth)
            {
                // Ignore NTLM via proxy since we won't get k-a to server.
                dwError = ERROR_HTTP_HEADER_NOT_FOUND;
                goto quit;
            }
        }

        // Else if in challenge phase, we require a persistent connection.
        else
        {
            // If we don't have a keep-alive connection ...
            if (!(pRequest->IsPersistentConnection (fIsProxy)))
            {
                dwError = ERROR_HTTP_HEADER_NOT_FOUND;
                goto quit;
            }
        }

    } // end if keep-alive required

    quit:

    if (dwError == ERROR_SUCCESS)
    {
        // If no password cache is set in the auth context,
        // find or create one and set it in the handle.
        if (!_pCreds)
        {
            _pCreds = CreateCreds(pRequest, fIsProxy, _pSPMData, NULL);

            if (!_pCreds)
            {
                INET_ASSERT(FALSE);
                dwError = ERROR_WINHTTP_INTERNAL_ERROR;
            }
            else
            {
                INET_ASSERT(_pCreds->pSPM == _pSPMData);
            }
        }
    }

    if (dwError == ERROR_SUCCESS)
    {
        // Point to allocated data.
        _szAlloc = szAuthHeader;
        _szData = szExtra;
        _cbData = cbExtra;
    }
    else
    {
        // Free allocated data.
        if (_szAlloc)
            delete _szAlloc;
        _szAlloc = NULL;
        _szData = NULL;
        _cbData = 0;
    }

    // Return of non-success will cancel auth session.
    return dwError;
}



/*---------------------------------------------------------------------------
    PostAuthUser
---------------------------------------------------------------------------*/
DWORD PLUG_CTX::PostAuthUser()
{
    if (!_CtxCriSec.Lock())
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    INET_ASSERT(_pSPMData == _pCreds->pSPM);
    DWORD dwError;

    //  Make sure the auth provider is loaded.
    if (GetState() != AUTHCTX::STATE_LOADED)
    {
        if (GetState() != AUTHCTX::STATE_ERROR )
            Load();
        if (GetState() != AUTHCTX::STATE_LOADED)
        {
            dwError = ERROR_WINHTTP_INTERNAL_ERROR;
            goto exit;
        }
    }

    BOOL fCanUseLogon = _fIsProxy 
        || _pRequest->SilentLogonOK(_pCreds->lpszHost);

    LPSTR lpszFQDN = GetFQDN(_pCreds->lpszHost);
    LPSTR lpszHostName = lpszFQDN ? lpszFQDN : _pCreds->lpszHost;

    SECURITY_STATUS ssResult;
    __try
    {
        ssResult = SEC_E_INTERNAL_ERROR;
        dwError = AuthenticateUser(&_pvContext,
                                   lpszHostName,
                                   GetScheme(),
                                   fCanUseLogon,
                                   _szData,
                                   _cbData,
                                   _pCreds->lpszUser,
                                   _pCreds->lpszPass,
                                   &ssResult);



        // Kerberos package can get into a bad state.
        if (GetSchemeType() == WINHTTP_AUTH_SCHEME_KERBEROS && ssResult == SEC_E_WRONG_PRINCIPAL)
            dwError = ERROR_WINHTTP_INCORRECT_PASSWORD;
            
        // Transit to the correct auth state.
        if (ssResult == SEC_E_OK || ssResult == SEC_I_CONTINUE_NEEDED)
        {
            if (GetSchemeType() == WINHTTP_AUTH_SCHEME_NEGOTIATE)
                ResolveProtocol();

            // Kerberos + SEC_E_OK or SEC_I_CONTINUE_NEEDED transits to challenge.
            // Negotiate does not transit to challenge.
            // Any other protocol + SEC_E_OK only transits to challenge.
            if ((GetSchemeType() == WINHTTP_AUTH_SCHEME_KERBEROS
                && (ssResult == SEC_E_OK || ssResult == SEC_I_CONTINUE_NEEDED))
                || (GetSchemeType() != WINHTTP_AUTH_SCHEME_NEGOTIATE && ssResult == SEC_E_OK))
            {
                _pRequest->SetAuthState(AUTHSTATE_CHALLENGE);
            }        
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        DEBUG_PRINT (HTTP, ERROR, ("AuthenticateUser faulted!\n"));
        dwError = ERROR_BAD_FORMAT;
        _pSPMData->eState = STATE_ERROR;
    }
    ENDEXCEPT

    if (_szAlloc)
    {
        delete _szAlloc;
        _szAlloc = NULL;
        _szData = NULL;
    }

    _cbData = 0;

exit:
    _CtxCriSec.Unlock();
    return dwError;
}

LPSTR PLUG_CTX::GetFQDN(LPSTR lpszHostName)
{
    if (lstrcmpi(GetScheme(), "Negotiate")) // only need to get FQDN for Kerberos
    {
        return NULL;
    }

    if (_pszFQDN)
    {
        return _pszFQDN;
    }

    SERIALIZED_LIST* pResolverCache = GetRootHandle(_pRequest)->GetResolverCache()->GetResolverCacheList();
    LPHOSTENT lpHostent;
    DWORD TTL;
    if (QueryHostentCache(pResolverCache,
                          (LPSTR)lpszHostName, 
                          NULL, 
                          &lpHostent, 
                          &TTL)) 
    {
        _pszFQDN = (lpHostent->h_name ? NewString(lpHostent->h_name) : NULL);
        ReleaseHostentCacheEntry(pResolverCache, lpHostent);
        return _pszFQDN;
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\auth\sspi.cxx ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    sspi.c

Abstract:

    This file contains the implementation for SSPI Authentication 

    The following functions are exported by this module:

    UnloadAuthenticateUser
	AuthenticateUser
	PreAuthenticateUser
    AuthenticateUserUI

Author:

    Sudheer Koneru	(SudK)	Created	2/17/96

Revision History:


--*/

#include <wininetp.h>
#include "htuu.h"
//#include "msnspmh.h"
#ifdef DEBUG_WINSSPI
#include <stdio.h>
#endif

#include "auth.h"
#include "internal.h"
//LPSTR StrChrA(LPCSTR lpStart, WORD wMatch); // from shlwapi.h

#include "sspspm.h"
#include "winctxt.h"

extern SspData  *g_pSspData;
LPVOID SSPI_InitGlobals(void);


DWORD g_cSspiContexts;

#define NAME_SEPERATOR  0x5c    // this is a backslash character which 
                                // seperates the domain name from user name

VOID
WINAPI
UnloadAuthenticateUser(LPVOID *lppvContext,
					   LPSTR lpszScheme,
					   LPSTR lpszHost)
{

	PWINCONTEXT		pWinContext = (PWINCONTEXT) (*lppvContext);

    if (!SSPI_InitGlobals())
        return;

	if (*lppvContext == NULL)	{
		return;
	}

    if (pWinContext->pInBuffer != NULL && 
        pWinContext->pInBuffer != pWinContext->szInBuffer)
    {
        LocalFree (pWinContext->pInBuffer);
    }
    pWinContext->pInBuffer = NULL;
    pWinContext->dwInBufferLength = 0;

    // Free SSPI security context
    //
	if (pWinContext->pSspContextHandle != NULL)
		(*(g_pSspData->pFuncTbl->DeleteSecurityContext))(pWinContext->pSspContextHandle);

    //  Free SSPI credential handle
    //
    if (pWinContext->pCredential)
        (*(g_pSspData->pFuncTbl->FreeCredentialHandle))(pWinContext->pCredential);
    pWinContext->pCredential = NULL;
    pWinContext->pSspContextHandle = NULL;
 
	if ( (pWinContext->lpszServerName != NULL) &&
		 (pWinContext->lpszServerName != pWinContext->szServerName) )
	{
		LocalFree(pWinContext->lpszServerName);
	}

	LocalFree(pWinContext);

	*lppvContext = NULL;

	AuthLock();
    g_cSspiContexts--;
    AuthUnlock();

	return;
}


//+---------------------------------------------------------------------------
//
//  Function:   SaveServerName
//
//  Synopsis:   This function saves the destination server name in this
//              connection context for AuthenticateUserUI
//
//  Arguments:  [lpszServerName] - points to the target server name
//              [pWinContext] - points to the connection context
//
//  Returns:    TRUE if server name is successfully saved in connection context.
//              Otherwise, FALSE is returned.
//
//----------------------------------------------------------------------------
BOOL
SaveServerName (
	LPSTR 			lpszServerName,
	PWINCONTEXT		pWinContext
    )
{
	DWORD dwLen = lstrlen(lpszServerName);

	if (dwLen < DEFAULT_SERVER_NAME_LEN)
	{
		lstrcpy(pWinContext->szServerName, lpszServerName);
		pWinContext->lpszServerName = pWinContext->szServerName;
	}
	else
	{   //
        //  Server name is longer, need to allocate memory for the name
        //

        //  Free already allocated memory if any
		if (pWinContext->lpszServerName && 
			pWinContext->lpszServerName != pWinContext->szServerName)
		{
			LocalFree (pWinContext->lpszServerName);
		}

		pWinContext->lpszServerName = (char *) LocalAlloc(0, dwLen+1);

		if (pWinContext->lpszServerName == NULL)
			return FALSE;

		lstrcpy(pWinContext->lpszServerName, lpszServerName);
	}

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   BuildNTLMauthData
//
//  Synopsis:   This function builds SEC_WINNT_AUTH_IDENTITY structure 
//              from the user name and password specified.  If domain name 
//              is not specified in the user name, the Domain field in 
//              the structure is set to NULL.  NOTE: This structure is 
//              specific to the NTLM SSPI package.
//              This function allocates a chunck of memory big enough for 
//              storing user name, domain, and password. Then setup 
//              pointers in pAuthData to use sections of this memory.
//
//  Arguments:  [pAuthData] - points to the SEC_WINNT_AUTH_IDENTITY structure
//              [lpszUserName] - points to the user name, which may also 
//                               include user's domain name.
//              [lpszPassword] - points to user's password
//
//  Returns:    TRUE if SEC_WINNT_AUTH_IDENTITY structure is successfully 
//              initialized and built.  Otherwise, FALSE is returned.
//
//----------------------------------------------------------------------------
BOOL
BuildNTLMauthData (
    PSEC_WINNT_AUTH_IDENTITY pAuthData, 
	LPTSTR       lpszUserName,
	LPTSTR       lpszPassword
    )
{
    DWORD  dwUserLen, dwDomainLen, dwPwdLen;
    LPTSTR pName;
    LPTSTR pDomain = NULL;

    //
    //  Check to see if domain name is specified in lpszUserName
    //
    pAuthData->Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;
    pName = StrChrA (lpszUserName, NAME_SEPERATOR);

    if (pName)  // Domain name specified
    {
        // Make sure that we don't change the original string in lpszUserName 
        // because that it would be reused for other connections

        // Calculate no. of bytes in domain name
        dwDomainLen = (int)(pName - lpszUserName);

        // Convert to no. of characters
        pAuthData->DomainLength = dwDomainLen / sizeof(TCHAR);

        pDomain = lpszUserName;
        pName++;
    }
    else        // No domain specified
    {
        pName = lpszUserName;
        pAuthData->Domain = NULL;
        pDomain = NULL;
        dwDomainLen = pAuthData->DomainLength = 0;
    }

    dwUserLen = pAuthData->UserLength = lstrlen (pName);
    dwPwdLen = pAuthData->PasswordLength = lstrlen (lpszPassword);

    //
    //  Allocate memory for all: name, domain, and password
    //
    pAuthData->User = (UCHAR*) LocalAlloc (LMEM_ZEROINIT, 
                                           dwUserLen + dwDomainLen + dwPwdLen +
                                           sizeof(TCHAR) * 3);
    if (pAuthData->User == NULL)
        return (FALSE);

    CopyMemory (pAuthData->User, pName, dwUserLen);

    //  Setup memory pointer for password
    //
    pAuthData->Password = (UCHAR*)((UINT_PTR)pAuthData->User + 
                                   dwUserLen + sizeof(TCHAR));
    CopyMemory (pAuthData->Password, lpszPassword, dwPwdLen);

    if (pAuthData->DomainLength > 0)
    {
        //  Setup memory pointer for domain
        //
        pAuthData->Domain = (UCHAR*)((UINT_PTR)pAuthData->Password + 
                                     dwPwdLen + sizeof(TCHAR));
        CopyMemory (pAuthData->Domain, pDomain, dwDomainLen);
    }
    else
    {
       pAuthData->Domain = NULL;
    }

    return (TRUE);
}

//+---------------------------------------------------------------------------
//
//  Function:   FreeNTLMauthData
//
//  Synopsis:   This function frees memory allocated for the 
//              SEC_WINNT_AUTH_IDENTITY structure
//
//  Arguments:  [pAuthData] - points to the SEC_WINNT_AUTH_IDENTITY structure
//
//  Returns:    void.
//
//----------------------------------------------------------------------------
VOID
FreeNTLMauthData (
    PSEC_WINNT_AUTH_IDENTITY pAuthData
    )
{
    //
    //  Free User which points to memory for all domain, name, and password
    //
    if (pAuthData->User)
        LocalFree (pAuthData->User);
}

//+---------------------------------------------------------------------------
//
//  Function:   NewWinContext
//
//  Synopsis:   This function creates a new context and a new credential 
//              handle for this connection.  If a user name/password is 
//              specified, the credential handle is created for the 
//              specified user.  Otherwise, the credential handle is created 
//              for the local logon user.
//
//  Arguments:  [pkgId] - the package ID (index into SSPI package list)
//              [lpszScheme] - the name of the current authentication scheme,
//                             which is also the SSPI package name
//              [ppCtxt] - this returns the pointer of the created context 
//                         to the caller.
//              [lpszUserName] - the name of a specific user to be used 
//                               for authentication. If this is NULL, the 
//                               credential of the currently logon user is 
//                               used for authentication.
//              [lpszPassword] - the password of the specified user, if any.
//
//  Returns:    ERROR_SUCCESS - if the new context is created successfully
//              ERROR_NOT_ENOUGH_MEMORY - if memory allocation failed
//              ERROR_INVALID_PARAMETER - the SSPI call for creating the 
//                              security credential handle failed
//
//----------------------------------------------------------------------------
DWORD
NewWinContext (
    INT         pkgId, 
	LPSTR       lpszScheme,
    PWINCONTEXT *ppCtxt,
    BOOL        fCanUseLogon,
	LPSTR       lpszUserName,
	LPSTR       lpszPassword
    )
{
    SECURITY_STATUS ss;
    TimeStamp   Lifetime;
    PWINCONTEXT pWinContext;
    SEC_WINNT_AUTH_IDENTITY  AuthData;
    PSEC_WINNT_AUTH_IDENTITY pAuthData;
    DWORD Capabilities ;

    DWORD SecurityBlobSize;

    //
    // need space for maxtoken size for in+out, + base64 encoding overhead for each.
    // really 1.34 overhead, but just round up to 1.5
    //
    SecurityBlobSize = GetPkgMaxToken(pkgId);
    SecurityBlobSize += (SecurityBlobSize/2);

    //
    // note: for compatibility sake, make the buffer size the MAX_BLOB_SIZE at the minimum
    // consider removing this once we're convinced all packages return good cbMaxToken values.
    //

    if( SecurityBlobSize < MAX_BLOB_SIZE )
    {
        SecurityBlobSize = MAX_BLOB_SIZE;
    }


    pWinContext = (PWINCONTEXT) LocalAlloc(
                        0,
                        sizeof(WINCONTEXT) +
                        (SecurityBlobSize*2)
                        );
	if (pWinContext == NULL)
		return (ERROR_NOT_ENOUGH_MEMORY);
		
    //  Initialize context
    //
    ZeroMemory( pWinContext, sizeof(WINCONTEXT) );
	pWinContext->pkgId = (DWORD)pkgId;
	
    pWinContext->szOutBuffer = (char*)(pWinContext+1);
    pWinContext->cbOutBuffer = SecurityBlobSize;

    pWinContext->szInBuffer = pWinContext->szOutBuffer + pWinContext->cbOutBuffer;
    pWinContext->cbInBuffer = SecurityBlobSize;

    //
    // Get bitmask representing the package capabilities
    //

    Capabilities = GetPkgCapabilities( pkgId );

    if ( ( Capabilities & SSPAUTHPKG_SUPPORT_NTLM_CREDS ) == 0 )
    {
        pAuthData = NULL;
    }
    else if (lpszUserName && lpszPassword)
    {
        //  Build AuthData from the specified user name/password
        if (!BuildNTLMauthData (&AuthData, lpszUserName, lpszPassword))
        {
            LocalFree (pWinContext);
            return (ERROR_NOT_ENOUGH_MEMORY);
        }

        pAuthData = &AuthData;
    }
    else if (fCanUseLogon)
    {
        // The zone policy allows silent use of the logon credential.
        pAuthData = NULL;
    }
    else
    {
        LocalFree (pWinContext);
        // We must prompt the user for credentials.
        return ERROR_WINHTTP_INCORRECT_PASSWORD;
    }

    //
    //  Call SSPI function acquire security credential for this package
    //
    ss = (*(g_pSspData->pFuncTbl->AcquireCredentialsHandle))(
                       NULL,                // New principal
                       lpszScheme,          // SSPI Package Name
                       SECPKG_CRED_OUTBOUND,// Credential Use
                       NULL,                // Logon ID
                       pAuthData,           // Auth Data
                       NULL,                // Get key func
                       NULL,                // Get key arg
                       &pWinContext->Credential,    // Credential Handle
                       &Lifetime );

    if (pAuthData)
        FreeNTLMauthData (pAuthData);

    if (ss != STATUS_SUCCESS)
    {
        LocalFree (pWinContext);
		return (ERROR_INVALID_PARAMETER);
    }

    pWinContext->pCredential = &pWinContext->Credential;

    *ppCtxt = pWinContext;

	AuthLock();
    g_cSspiContexts++;
    AuthUnlock();

    return (ERROR_SUCCESS);
}

//+---------------------------------------------------------------------------
//
//  Function:   RedoNTLMAuth4User
//
//  Synopsis:   This function recreates a NTLM credential handle for the 
//              specified user and generate a NEGOTIATE message in 
//              the provided buffer with the new credential handle.
//
//  Arguments:  [pWinContext] - points to the connection context
//              [pkgId] - specifies the SSPI pkg to be used for authentication
//              [lpszUserName] - the name of the specific user to be used 
//                               for authentication. 
//              [lpszPassword] - the password of the specified user,
//              [lpszServerName] - the target server name
//              [lpszScheme] - the name of the current authentication scheme,
//                             which is also the SSPI package name
//              [lpOutBuffer] - points to the buffer for the new authorization 
//                              header including the UUENCODED NEGOTIATE msg
//              [lpdwOutBufferLength] - returns the length of the generated 
//                                      authorization header.
//
//  Returns:    ERROR_SUCCESS - if the new authorization header is successfully 
//                              created for the new user name/password
//              ERROR_NOT_ENOUGH_MEMORY - if memory allocation failed
//              ERROR_INVALID_HANDLE - the SSPI call for generating the 
//                              new NEGOTIATE msg failed
//
//----------------------------------------------------------------------------
DWORD
RedoNTLMAuth4User (
	PWINCONTEXT	pWinContext, 
    INT         pkgId, 
	LPSTR       lpszUserName,
	LPSTR       lpszPassword, 
	LPSTR       lpszServerName,
	LPSTR       lpszScheme,
    IN BOOL     fCanUseLogon,
	LPSTR       lpOutBuffer,
	LPDWORD     lpdwOutBufferLength,
	SECURITY_STATUS *pssResult
    )
{
    SECURITY_STATUS         ss;
    DWORD                   dwStatus;
    TimeStamp               Lifetime;
    SEC_WINNT_AUTH_IDENTITY AuthData;
    ULONG                   fContextReq = ISC_REQ_DELEGATE;
    DWORD                   dwMaxLen;

   	if (pWinContext->pSspContextHandle)
   	{
		(*(g_pSspData->pFuncTbl->DeleteSecurityContext))(pWinContext->pSspContextHandle);
   	    pWinContext->pSspContextHandle = NULL;
	}

    //  Free existing credential handle
    //
    if (pWinContext->pCredential)
    {
    	(*(g_pSspData->pFuncTbl->FreeCredentialHandle))(pWinContext->pCredential);
        pWinContext->pCredential = NULL;
    }
    //
    //  Build the NTLM SSPI AuthData from the specified user name/password
    //
    if (!BuildNTLMauthData (&AuthData, lpszUserName, lpszPassword))
        return (ERROR_NOT_ENOUGH_MEMORY);

    //
    //  Call SSPI function acquire security credential for this user
    //
    ss = (*(g_pSspData->pFuncTbl->AcquireCredentialsHandle))(
                       NULL,                // New principal
                       lpszScheme,          // SSPI Package Name
                       SECPKG_CRED_OUTBOUND,// Credential Use
                       NULL,                // Logon ID
                       &AuthData,           // Auth Data
                       NULL,                // Get key func
                       NULL,                // Get key arg
                       &pWinContext->Credential,    // Credential Handle
                       &Lifetime );

    FreeNTLMauthData (&AuthData);   // don't need it any more

    if (ss != STATUS_SUCCESS)
    {
		return (ERROR_INVALID_HANDLE);
    }

    pWinContext->pCredential = &pWinContext->Credential;

    dwMaxLen = *lpdwOutBufferLength;

    //
    //  Generate NEGOTIATE message in the provided buffer for this user 
    //
    dwStatus =  GetSecAuthMsg( g_pSspData,
                                pWinContext->pCredential,
                                pkgId,
                                NULL, 
                                &(pWinContext->SspContextHandle),
                                fContextReq,
                                NULL,
                                0,
                                lpOutBuffer,
                                lpdwOutBufferLength,
                                lpszServerName,
                                fCanUseLogon,
                                TRUE,
                                lpszScheme,
                                pssResult);
    
    if (dwStatus != SPM_STATUS_OK)
    {
        *lpdwOutBufferLength = 0; // no exchange blob generated
        return(ERROR_INVALID_HANDLE);
    }

    pWinContext->pSspContextHandle = &(pWinContext->SspContextHandle);

    //
    //  If we are not in the initial state, continue to a RESPONSE message
    //
    if (pWinContext->pInBuffer != NULL && pWinContext->dwInBufferLength > 0)
    {
        *lpdwOutBufferLength = dwMaxLen;
        ZeroMemory( lpOutBuffer, dwMaxLen );

        dwStatus = GetSecAuthMsg( g_pSspData,
                                pWinContext->pCredential,
                                pWinContext->pkgId,
                                pWinContext->pSspContextHandle,
                                (PCtxtHandle) &(pWinContext->SspContextHandle),
                                fContextReq,
                                pWinContext->pInBuffer, 
                                pWinContext->dwInBufferLength, 
                                lpOutBuffer,
                                lpdwOutBufferLength,
                                pWinContext->lpszServerName,
                                fCanUseLogon,
                                TRUE,
                                lpszScheme,
                                pssResult);

        //  Clear out the input exchange blob
        //
        if (pWinContext->pInBuffer != NULL)
        {
            if (pWinContext->pInBuffer != pWinContext->szInBuffer)
                LocalFree (pWinContext->pInBuffer);
            pWinContext->pInBuffer = NULL;
            pWinContext->dwInBufferLength = 0;
        }

        if (dwStatus != SPM_STATUS_OK)
        {
            *lpdwOutBufferLength = 0; // no exchange blob generated
            return(ERROR_INVALID_HANDLE);
        }
    }

    return (ERROR_SUCCESS);
}


//
// functions
//

/*++

Routine Description:

    Generates a Basic User Authentication string for WinINet or 
	other callers can use

Arguments:

	lpContext               - if the package accepts the request & authentication
					requires multiple transactions, the package will supply
					a context value which will be used in subsequent calls,
					Currently this contains a pointer to a pointer of a 
					User defined Void Pointer.  Can be Assume to be NULL
					if this is the first instance of a Realm - Host Combo

	lpszServerName  - the name of the server we are performing 
					authentication for. We may want to supply the full URL
					
	lpszScheme              - the name of the authentication scheme we are seeking, in case the package supports multiple schemes

	dwFlags                 - on input, flags modifying how the package should behave,
					e.g. "only authenticate if you don't have to get user 
					information"  On output contains flags relevant to
					future HTTP requests, e.g. "don't cache any data from 
					this connection". Note, this information should not be 
					specific to HTTP - we may want to use the same flags 
					for FTP, etc.
	
	lpszInBuffer              - pointer to the string containing the response from
					the server (if any)

	dwInBufferLength - number of bytes in lpszInBuffer. No CR-LF sequence, no terminating NUL

	lpOutBuffer -   pointer to a buffer where the challenge response will be written by the 
					package if it can handle the request

	lpdwOutBufferLength - on input, contains the size of lpOutBuffer. On output, contains the
						  number of bytes to return to the server in the next GET request 
						  (or whatever). If lpOutBuffer is too small, the package should 
						  return ERROR_INSUFFICIENT_BUFFER and set *lpdwOutBufferLength to be
						  the required length

	We will keep a list of the authentication packages and the schemes they support, 
	along with the entry point name (should be the same for all packages) in the registry. 

	Wininet should keep enough information such that it can make a reasonable guess as to
	whether we need to authenticate a connection attempt, or whether we can use previously 
	authenticated information


Return Value:

    DWORD
	Success - non-zero 
	Failure - 0. Error status is available by calling GetLastError()

--*/
DWORD
WINAPI
AuthenticateUser(
	IN OUT LPVOID *lppvContext,
	IN LPSTR lpszServerName,
	IN LPSTR lpszScheme,
	IN BOOL  fCanUseLogon,
	IN LPSTR lpszInBuffer,
	IN DWORD dwInBufferLength,
	IN LPSTR lpszUserName,
	IN LPSTR lpszPassword,
	OUT SECURITY_STATUS *pssResult
	)
{
	PWINCONTEXT		pWinContext;
    LPSTR           pServerBlob = NULL;
	int		        pkgId;
    DWORD           SPMStatus;
    ULONG           fContextReq = ISC_REQ_DELEGATE;
    BOOL            bNonBlock = TRUE;

    if (!SSPI_InitGlobals())
        return ERROR_INVALID_PARAMETER;

	
    pkgId = GetPkgId(lpszScheme);

    if (pkgId == -1) 
        return (ERROR_INVALID_PARAMETER);

	if (*lppvContext == NULL)   // a new connection
    {
        char msg[1024];
        DWORD dwStatus;

		//
		// First time we are getting called here, there should be no input blob
		//
        if (dwInBufferLength != 0)
			return (ERROR_INVALID_PARAMETER);

        dwStatus = NewWinContext (pkgId, lpszScheme, &pWinContext,
            fCanUseLogon, lpszUserName, lpszPassword);
		if (dwStatus != ERROR_SUCCESS)
			return (dwStatus);

		(*lppvContext) = (LPVOID) pWinContext;
#ifdef DEBUG_WINSSPI
        (void)wsprintf (msg, "AuthenticateUser> Scheme= %s  Server= '%s'\n", 
                       lpszScheme, lpszServerName);
        OutputDebugString(msg);
#endif
	}
	else
	{
		pWinContext = (PWINCONTEXT) (*lppvContext);

		//
		// The package Id better be the same. Cant just switch packageId 
		// arbitrarily
		//
		if (pWinContext->pkgId != (DWORD)pkgId)
			return (ERROR_INVALID_PARAMETER);
		
		pServerBlob = lpszInBuffer;

		//++(pWinContext->dwCallId);		// Increment Call Id

		//
		// BUGBUG: Hack for now to know when auth failed
		// The only time we get lpszInBuffer to be empty is when 
		// Web server failed the authentication request
		//
        if (dwInBufferLength == 0)
        {
			//
			// This means auth has failed as far as NTLM are concerned.
			// Will result in UI being done again for new passwd
			//

			// Make sure we should have the same server name as before
			//
			if ( pWinContext->lpszServerName != NULL &&  
				 lstrcmp (pWinContext->lpszServerName, lpszServerName) != 0 )
			{
				return(ERROR_INVALID_PARAMETER);
			}

            if (!SaveServerName (lpszServerName, pWinContext))
			    return (ERROR_NOT_ENOUGH_MEMORY);

			//
			//	Delete the original SSPI context handle and 
			//	let UI recreate one.
			//
			if (pWinContext->pSspContextHandle)
			{
				(*(g_pSspData->pFuncTbl->DeleteSecurityContext))(pWinContext->pSspContextHandle);
        		pWinContext->pSspContextHandle = NULL;
			}

            if (pWinContext->pInBuffer != NULL && 
                pWinContext->pInBuffer != pWinContext->szInBuffer)
            {
                LocalFree (pWinContext->pInBuffer);
            }

            pWinContext->pInBuffer = NULL;
            pWinContext->dwInBufferLength = 0;

            //
            //  clear buffer length for the exchange blob
            //
		    pWinContext->dwOutBufferLength = 0;

            return (ERROR_WINHTTP_INCORRECT_PASSWORD);
		}
	}

    //
    //  Setup dwOutBufferLength to represent max. memory in szOutBuffer
    //
    pWinContext->dwOutBufferLength = pWinContext->cbOutBuffer;
    ZeroMemory (pWinContext->szOutBuffer, pWinContext->cbOutBuffer);

    //
    // This will generate an authorization header with UUEncoded blob from SSPI.
    // BUGBUG: Better make sure outbuf buffer is big enough for this.
    //
    SPMStatus =  GetSecAuthMsg( g_pSspData,
                                pWinContext->pCredential,
                                pkgId,
                                pWinContext->pSspContextHandle,
                                &(pWinContext->SspContextHandle),
                                fContextReq,
								pServerBlob, 
                       			dwInBufferLength,
                                pWinContext->szOutBuffer,
                                &pWinContext->dwOutBufferLength,
                                lpszServerName,
                                fCanUseLogon,
                                bNonBlock,
                                lpszScheme,
                                pssResult);

    if (SPMStatus != SPM_STATUS_OK)             // Fail to generate blob
    {
        pWinContext->dwOutBufferLength = 0;     // no exchange blob generated

        //
        //  if SSPI is requesting an opportunity to prompt for user credential
        //
		if (SPMStatus == SPM_STATUS_WOULD_BLOCK)
		{
			if (!SaveServerName (lpszServerName, pWinContext))
				return (ERROR_NOT_ENOUGH_MEMORY);

            //  If there is a exchange blob, this is not the first call
            //
            if (pServerBlob && dwInBufferLength > 0)
            {
                //  Save the exchange blob in the connection context
                //  so we can call SSPI again with the exchange blob
                if (dwInBufferLength > MAX_BLOB_SIZE)
                {
                	pWinContext->pInBuffer = (PCHAR) LocalAlloc(0, 
                                                    dwInBufferLength);
                    if (pWinContext->pInBuffer == NULL)
	        			return (ERROR_NOT_ENOUGH_MEMORY);
                }
                else
                    pWinContext->pInBuffer = pWinContext->szInBuffer;

                CopyMemory( pWinContext->szInBuffer, pServerBlob, 
                            dwInBufferLength );
                pWinContext->dwInBufferLength = dwInBufferLength;
            }
            else
            {
    			//
	    		//	Delete the original SSPI context handle and 
		    	//	let UI recreate one.
			    //
    			if (pWinContext->pSspContextHandle)
	    		{
		    		(*(g_pSspData->pFuncTbl->DeleteSecurityContext))(pWinContext->pSspContextHandle);
        	    	pWinContext->pSspContextHandle = NULL;
			    }

                //
                //  clear buffer length for the exchange blob
                //
                if (pWinContext->pInBuffer != NULL && 
                    pWinContext->pInBuffer != pWinContext->szInBuffer)
                {
                    LocalFree (pWinContext->pInBuffer);
                }

                pWinContext->pInBuffer = NULL;
                pWinContext->dwInBufferLength = 0;
            }
            pWinContext->dwOutBufferLength = 0;

			return(ERROR_WINHTTP_INCORRECT_PASSWORD);
		}

        return (ERROR_WINHTTP_LOGIN_FAILURE);
    }
    else if (pWinContext->pSspContextHandle == NULL)
    {   
        //  This means that we've just created a security context
        //
        pWinContext->pSspContextHandle = &(pWinContext->SspContextHandle);
    }

	return ERROR_WINHTTP_RESEND_REQUEST;
}


DWORD
WINAPI
PreAuthenticateUser(
	IN OUT LPVOID *lppvContext,
	IN LPSTR lpszServerName,
	IN LPSTR lpszScheme,
    IN BOOL  fCanUseLogon,
	IN DWORD dwFlags,
	OUT LPSTR lpOutBuffer,
	IN OUT LPDWORD lpdwOutBufferLength,
	IN LPSTR lpszUserName,
	IN LPSTR lpszPassword,
	SECURITY_STATUS *pssResult
	)
{
    INT             pkgId;
    DWORD           dwStatus;
    PWINCONTEXT		pWinContext;
	BOOL			bNonBlock = TRUE;
    ULONG           fContextReq = ISC_REQ_DELEGATE;
    DWORD Capabilities ;

    if (!SSPI_InitGlobals())
        return ERROR_INVALID_PARAMETER;

	if (lpszServerName == NULL || *lpszServerName == '\0')
        return(ERROR_INVALID_PARAMETER);

    pkgId = GetPkgId(lpszScheme);

    if (pkgId == -1)    {
        return(ERROR_INVALID_PARAMETER);
    }

    Capabilities = GetPkgCapabilities( pkgId );

    //
    //  If this is for an existing connection
    //
	if (*lppvContext != NULL)
    {
    	pWinContext = (PWINCONTEXT) (*lppvContext);

    	if ((DWORD)pkgId != pWinContext->pkgId)
	    	return(ERROR_INVALID_PARAMETER);

        //
        //  For package that does not handle its own UI, if there is no 
        //  generated blob, it means that we have just collected 
        //  user name/password.
        //
        if ( ( pWinContext->dwOutBufferLength == 0 ) &&
                ( Capabilities & SSPAUTHPKG_SUPPORT_NTLM_CREDS ) )
        {
            if (lpszUserName == NULL || lpszPassword == NULL)
            {
    	    	return(ERROR_INVALID_PARAMETER);
            }

            //
            // Need to recreate a credential handle and 
            // generate a new NEGOTIATE message in lpOutBuffer
            //
            dwStatus = RedoNTLMAuth4User (pWinContext, 
                                         pkgId,
                                         lpszUserName,
                                         lpszPassword, 
                                         lpszServerName ,
                                         lpszScheme,
                                         fCanUseLogon,
                                         lpOutBuffer,
                                         lpdwOutBufferLength,
                                         pssResult);

            if (dwStatus != ERROR_SUCCESS)
                return (dwStatus);

        	return(ERROR_SUCCESS);
        }
	    else if (pWinContext->dwOutBufferLength == 0)
        //
        //  For other packages, If there is no generated blob, 
        //  something is wrong 
        //
	    	return(ERROR_INVALID_PARAMETER);

    }
    // If not NTLM, don't pre-auth.
    else if ( (Capabilities & SSPAUTHPKG_SUPPORT_NTLM_CREDS ) == 0 )
    {
        return (ERROR_INVALID_HANDLE);
    }
    else
    {
        // probably sending 1st request on a new connection for the same URL
        //  Create a new context and SSPI credential handle for this connection
        //
        // Set fCanUseLogon to TRUE : we would not be pre-authing
        // unless we have a valid pwc which means we already checked
        // zone policy for silent logon.
        dwStatus = NewWinContext (pkgId, lpszScheme, &pWinContext, 
                                  fCanUseLogon, lpszUserName, lpszPassword);
		if (dwStatus != ERROR_SUCCESS)
			return (dwStatus);
		
#ifdef DEBUG_WINSSPI
        (void)wsprintf (msg, 
            "PreAuthenticateUser> New Context for Scheme= %s  Server= '%s'\n", 
            lpszScheme, lpszServerName);
        OutputDebugString(msg);
#endif
        pWinContext->dwOutBufferLength = pWinContext->cbOutBuffer;
        ZeroMemory (pWinContext->szOutBuffer, pWinContext->cbOutBuffer);
    
        //
        // This will generate an authorization header with the 
        // UUEncoded blob from SSPI. 
        // BUGBUG: Better make sure outbuf buffer is big enough for this.
        //
        dwStatus =  GetSecAuthMsg( g_pSspData,
                                    pWinContext->pCredential,
                                    pkgId,
                                    NULL, 
                                    &(pWinContext->SspContextHandle),
                                    fContextReq,
                                    NULL,
                                    0,
                                    pWinContext->szOutBuffer,
                                    &pWinContext->dwOutBufferLength,
                                    lpszServerName,
                                    fCanUseLogon,
                                    bNonBlock,
                                    lpszScheme,
                                    pssResult);
    
        if (dwStatus != SPM_STATUS_OK)
        {
            //  This is a rare case
            //
            pWinContext->dwOutBufferLength = 0; // no exchange blob generated
            return(ERROR_INVALID_HANDLE);
        }

		(*lppvContext) = (LPVOID) pWinContext;

        //  Save the pointer of the created security ctxt
        //
        pWinContext->pSspContextHandle = &(pWinContext->SspContextHandle);
	}

	//
    //  Copy exchange blob to the output buffer
	//	Make sure output buffer provided is big enough
	//
	if (*lpdwOutBufferLength < pWinContext->dwOutBufferLength)
	{
	    *lpdwOutBufferLength = pWinContext->dwOutBufferLength + 1;
		return(ERROR_INSUFFICIENT_BUFFER);
	}

	CopyMemory (lpOutBuffer, pWinContext->szOutBuffer, 
				pWinContext->dwOutBufferLength);
	if (*lpdwOutBufferLength > pWinContext->dwOutBufferLength)
        lpOutBuffer[pWinContext->dwOutBufferLength] = '\0';

    *lpdwOutBufferLength = pWinContext->dwOutBufferLength;

    //
    //  The exchange blob has being copied to request header, so clear its len
    //

    pWinContext->dwOutBufferLength = 0;

	return(ERROR_SUCCESS);
}

BOOL g_fUUEncodeData = TRUE;

typedef enum _COMPUTER_NAME_FORMAT {
    ComputerNameNetBIOS,
    ComputerNameDnsHostname,
    ComputerNameDnsDomain,
    ComputerNameDnsFullyQualified,
    ComputerNamePhysicalNetBIOS,
    ComputerNamePhysicalDnsHostname,
    ComputerNamePhysicalDnsDomain,
    ComputerNamePhysicalDnsFullyQualified,
    ComputerNameMax
} COMPUTER_NAME_FORMAT ;

typedef 
BOOL
(WINAPI * PFN_GET_COMPUTER_NAME_EX)(
    IN COMPUTER_NAME_FORMAT NameType,
    OUT LPSTR lpBuffer,
    IN OUT LPDWORD nSize
    );

PFN_GET_COMPUTER_NAME_EX g_pfnGetComputerNameExA = NULL;


/*-----------------------------------------------------------------------------
**
**  Function:   GetSecAuthMsg
**
**  Synopsis:   This function generates a SSPI NEGOTIATE or RESPONSE 
**				authorization string for the specified SSPI package.
**				The authorization string generated by this function 
**				follows the format: 
**					"<Package Name> <Package Specific Auth. Data>"
**				If global uuencoding is turned on, this functions will 
**				uuencode the message before building it into an  
**				authorization string; by default, the uuencoding flag is 
**				always on.  
**				This functions calls InitializeSecurityContext() to 
**				generate the NEGOTIATE/RESPONSE message for the authori-
**				zation string. If the SSPI function returns NO_CREDENTIAL, 
**				and if the PROMPT_CREDS flag is not turned on when blocking
**				is permitted, this function will call the SSPI function 
**				again with the PROMPT_CREDS flag set; if SSPI returns 
**				NO_CREDENTIAL again, this SSPI will return ERROR to the 
**				caller.
**
**
**  Arguments:
**
**		pData - pointer to SspData containing the SSPI function table 
**				and the SSPI package list. 
**		pkgID - the package index of the SSPI package to use.
**		pInContext - pointer to a context handle. If NULL is specified, 
**					 this function will use a temporary space for the context
**					 handle and delete the handle before returning to the 
**					 caller. If non-NULL address is specified, the context 
**					 handle created by the SSPI is returned to the caller. 
**					 And the caller will have to delete the handle when it's
**					 done with it.
**		fContextReq - the SSPI request flag to pass to InitializeSecurityContext
**		pBuffIn - pointer to the uudecoded CHALLENGE message if any. 
**				  For generating NEGOTIATE message, this pointer should be NULL.
**		cbBuffIn - length of the CHALLENGE message. This should be zero when  
**				   when pBuffIn is NULL.
**		pFinalBuff - pointer to a buffer for the final authorization string.
**		pszTarget - Server Host Name
**		bNonBlock - a flag which is set if blocking is not permitted.
**
**  Return Value:
**
**		SPM_STATUS_OK	- if an authorization string is generated successfully
**  	SPM_STATUS_WOULD_BLOCK - if generating an authorization string would 
**					cause blocking when blocking is not permitted. 
**		SPM_ERROR - if any problem/error is encountered in generating an 
**					authorization string, including user hitting cancel on 
**					the SSPI dialog prompt for name/password.
**
**---------------------------------------------------------------------------*/
DWORD
GetSecAuthMsg (
    PSspData        pData, 			 
    PCredHandle     pCredential, 
    DWORD           pkgID,              // the package index into package list
    PCtxtHandle     pInContext,
	PCtxtHandle		pOutContext,
    ULONG           fContextReq,        // Request Flags
    VOID            *pBuffIn, 
    DWORD           cbBuffIn, 
    char            *pFinalBuff, 
    DWORD           *pcbBuffOut,
    SEC_CHAR        *pszTarget,         // Server Host Name
    BOOL            fTargetTrusted,
    UINT            bNonBlock,
    LPSTR           pszScheme,
    SECURITY_STATUS *pssResult
    )
{
    char                  *SlowDecodedBuf = NULL;

    int                   retsize;
    SECURITY_STATUS       SecStat;
    TimeStamp             Lifetime;
    SecBufferDesc         OutBuffDesc;
    SecBuffer             OutSecBuff;
    SecBufferDesc         InBuffDesc;
    SecBuffer             InSecBuff;
    ULONG                 ContextAttributes;

    char                  *SlowOutBufPlain = NULL;

    char                  *pOutMsg = NULL;
    DWORD                 RetStatus;
    long                  maxbufsize;
    CHAR                  szDecoratedTarget[MAX_PATH + 6];
    DWORD                 cbTarget;

    ULONG                 cbMaxToken;


	//
	// BUGBUG: Deal with output buffer not being long enough


    if (pFinalBuff == NULL) {
        return(SPM_ERROR);
    }

    //
    //  Prepare our output buffer.  We use a temporary buffer because
    //  the real output buffer will most likely need to be uuencoded
    //
    OutBuffDesc.ulVersion = 0;
    OutBuffDesc.cBuffers  = 1;
    OutBuffDesc.pBuffers  = &OutSecBuff;

    OutSecBuff.cbBuffer   = MAX_AUTH_MSG_SIZE;
    OutSecBuff.BufferType = SECBUFFER_TOKEN;


    // Dynamically allocate since being in a service doesn't
    // give us the guaranteed luxury of 10+KB stack allocations.

    cbMaxToken = GetPkgMaxToken(pkgID);

    SlowOutBufPlain = (char *) ALLOCATE_FIXED_MEMORY(cbMaxToken);

    if( SlowOutBufPlain == NULL )
    {
        RetStatus = SPM_STATUS_INSUFFICIENT_BUFFER;
        goto Cleanup;
    }
    OutSecBuff.pvBuffer = SlowOutBufPlain;
    OutSecBuff.cbBuffer = cbMaxToken;

    //
    //  Prepare our Input buffer if a CHALLENGE message is passed in.
    //
    if ( pBuffIn )
    {
        InBuffDesc.ulVersion = 0;
        InBuffDesc.cBuffers  = 1;
        InBuffDesc.pBuffers  = &InSecBuff;

        InSecBuff.BufferType = SECBUFFER_TOKEN;

        //
        // If this is UUENCODED, decode it first
        //
        if ( g_fUUEncodeData)
        {
            DWORD cbDecodedBuf;

            cbDecodedBuf = cbBuffIn;
            SlowDecodedBuf = (char*) ALLOCATE_FIXED_MEMORY(cbDecodedBuf);
            if( SlowDecodedBuf == NULL )
            {
                RetStatus = SPM_STATUS_INSUFFICIENT_BUFFER;
                goto Cleanup;
            }

            InSecBuff.cbBuffer   = HTUU_decode ((char*)pBuffIn, (UCHAR*)SlowDecodedBuf,
                                                cbDecodedBuf);
            InSecBuff.pvBuffer   = SlowDecodedBuf;
        }
		else
        {
            InSecBuff.cbBuffer   = cbBuffIn;
            InSecBuff.pvBuffer   = pBuffIn;
        }
    }

    // If scheme is Negotiate, set ISC_REQ_MUTUAL_AUTH and decorate
    // the server name indicated by pszTarget by appending a '$' to the
    // server name.
    if (pszScheme && !(lstrcmpi(pszScheme, "Negotiate")))
    {
        fContextReq |= ISC_REQ_MUTUAL_AUTH;
        cbTarget = (pszTarget ? strlen(pszTarget) : 0);
        if (cbTarget && (cbTarget <= MAX_PATH - sizeof( "HTTP/" )))
        {
            memcpy(szDecoratedTarget, "HTTP/", sizeof( "HTTP/" ) - 1 );
            memcpy(szDecoratedTarget + sizeof( "HTTP/" ) - 1, pszTarget, cbTarget + 1);
            pszTarget = szDecoratedTarget;

            OutputDebugStringA(pszTarget);
        }
    }


	//
	//	Call SSPI function generate the NEGOTIATE/RESPONSE message
	//

    if (fContextReq & ISC_REQ_DELEGATE)
    {
        // we should only request delegation when calling InitializeSecurityContext if 
        // the site is in the intranet or trusted sites zone. Otherwise you will be giving 
        // the user's TGT to any web server that is trusted for delegation.

        if (fTargetTrusted)
        {
            fContextReq &= ~ISC_REQ_DELEGATE;
        }
    }

SspiRetry:

//
// BUGBUG: Same credential handle could be used by multiple threads at the
// same time.
//
    SecStat = (*(pData->pFuncTbl->InitializeSecurityContext))(
                                pCredential, 
                                pInContext,
                                pszTarget,
                                fContextReq,
                                0,
                                SECURITY_NATIVE_DREP,
                                (pBuffIn) ? &InBuffDesc : NULL, 
                                0,
                                pOutContext, 
                                &OutBuffDesc,
                                &ContextAttributes,
                                &Lifetime );
	*pssResult = SecStat;
	
	//
	//	If SSPI function fails 
	//
    if ( !NT_SUCCESS( SecStat ) )
    {
        RetStatus = SPM_ERROR;

		//
		//	If SSPI do not have user name/password for the secified package,
		//
        if (SecStat == SEC_E_NO_CREDENTIALS)
        {
            //
            //  If we have prompted the user and still get back "No Credential"
            //  error, it means the user does not have valid credential; the 
            //	user hit <CANCEL> on the UI box. If we have supplied a valid 
			//	credential, but get back a "No Credential" error, then something
			//	has gone wrong; we definitely should return to caller with ERROR
            //
            if ((fContextReq & ISC_REQ_PROMPT_FOR_CREDS) ||
				(fContextReq & ISC_REQ_USE_SUPPLIED_CREDS))
			{
                RetStatus = SPM_ERROR;	// return ERROR to caller
            }
            else if (bNonBlock)
            {
				//
				//	Blocking is not permitted, return WOULD_BLOCK to caller
				//
                RetStatus = SPM_STATUS_WOULD_BLOCK;
            }
            else
            {
                //	Blocking is permitted and we have not asked the SSPI to
                //  prompt the user for proper credential, we should call  
                //  the SSPI again with PROMPT_CREDS flag set.
                //
                fContextReq = fContextReq | ISC_REQ_PROMPT_FOR_CREDS;
                goto SspiRetry;
            }
        }
        SetLastError( SecStat );

        goto Cleanup;
    }

    RetStatus = SPM_STATUS_OK;

    //
    //  Only return the SSPI blob if a output buffer is specified
    //
    if (pFinalBuff)
    {
    	//
	    //	Initialize the final buffer to hold the package name followed by 
    	//	a space. And setup the pOutMsg pointer to points to the character 
    	//	following the space so that the final NEGOTIATE/RESPONSE can be 
    	//	copied into the pFinalBuff starting at the character pointed to 
    	//	by pOutMsg. 
    	//
        wsprintf (pFinalBuff, "%s ", pData->PkgList[pkgID]->pName);
        pOutMsg = pFinalBuff + lstrlen(pFinalBuff);

        if ( g_fUUEncodeData)
        {
            maxbufsize = *pcbBuffOut - 
                         lstrlen(pData->PkgList[pkgID]->pName) - 1;
        	//
        	//  uuencode it, but make sure that it fits in the given buffer
        	//
            retsize = HTUU_encode ((BYTE *) OutSecBuff.pvBuffer,
                                   OutSecBuff.cbBuffer,
                                   (CHAR *) pOutMsg, maxbufsize);
            if (retsize > 0)
                *pcbBuffOut = retsize + lstrlen(pData->PkgList[pkgID]->pName)+1;
            else
                RetStatus = SPM_STATUS_INSUFFICIENT_BUFFER;
        }
        else if ( *pcbBuffOut >= lstrlen(pData->PkgList[pkgID]->pName) + 
                                 OutSecBuff.cbBuffer + 1 )
        {
            CopyMemory( (CHAR *) pOutMsg, 
                        OutSecBuff.pvBuffer,
                        OutSecBuff.cbBuffer );
            *pcbBuffOut = lstrlen(pData->PkgList[pkgID]->pName) + 1 +
                          OutSecBuff.cbBuffer;
        }
        else
        {
            *pcbBuffOut = lstrlen(pData->PkgList[pkgID]->pName) + 
                          OutSecBuff.cbBuffer + 1;
            RetStatus = SPM_STATUS_INSUFFICIENT_BUFFER;
        }
    }

Cleanup:

    if( SlowOutBufPlain != NULL )
    {
        FREE_MEMORY( SlowOutBufPlain );
    }

    if( SlowDecodedBuf != NULL )
    {
        FREE_MEMORY( SlowDecodedBuf );
    }

    return (RetStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\common\buffer.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    buffer.cxx

Abstract:

    Contains code to impliment a double buffering class used in SSL/PCT (secure channel)
        transactions.


Author:

    Arthur L Bierer (arthurbi) 20-March-1996

Revision History:

    20-March-1996 arthurbi
        Created

--*/

#include <wininetp.h>


BOOL
DBLBUFFER::InitBuffer(
    BOOL fDblBufferMode
    )

/*++

Routine Description:

    Allocates, and initalizes internal buffers.

Arguments:

    fDblBufferMode  - TRUE if we are to maintain to buffers,
                      FALSE if we treat the output and input buffers the same

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE, not enough memory to allocate buffers.

Comments:


--*/

{
    DEBUG_ENTER((DBG_BUFFER,
                 Bool,
                 "DBLBUFFER::InitBuffer",
                 "%B",
                 fDblBufferMode
                 ));

    INET_ASSERT(_lpBuffer == NULL);
    INET_ASSERT(_dwInitDefaultBufferSize > 0 );

    _lpBuffer = (LPBYTE)ALLOCATE_FIXED_MEMORY(_dwInitDefaultBufferSize);

    DEBUG_PRINT(API,
                INFO,
                ("allocated %d byte buffer %#x\n",
                _dwInitDefaultBufferSize,
                _lpBuffer
                ));

    BOOL success = FALSE;

    if (_lpBuffer != NULL) {

        INET_ASSERT(_dwBufferOut == 0);
        INET_ASSERT(_dwBufferIn == 0);

        _fDblBufferMode = fDblBufferMode;

        _dwBufferLength = _dwInitDefaultBufferSize ;
        _lpBufferOut = _lpBuffer + _dwBufferLength;
        _lpBufferIn      = _lpBuffer + _dwBufferLength;

        success = TRUE;
    }

    DEBUG_LEAVE(success);

    return success;
}

DWORD
DBLBUFFER::GetInputBufferRemaining(
    VOID
    )

/*++

Routine Description:

    Determines the amount of free bytes availble for reading into the input buffer.
        Will attempt to push current data to the front of the buffer, to make the
        most room in the currently allocated buffer.

Arguments:

    none.

Return Value:

    DWORD
        Number of bytes free.

Comments:

        Assumed to only be called in DblBuffer mode.

--*/


{
    DEBUG_ENTER((DBG_INET,
                 Int,
                 "DBLBUFFER::GetInputBufferRemaining",
                 NULL
                 ));


    INET_ASSERT(_lpBuffer);
    INET_ASSERT(_dwBufferOut == 0 );
    INET_ASSERT(_fDblBufferMode );


    BOOL fIsInputBufferCompressed = (_lpBufferIn == _lpBuffer);

    if ( ! fIsInputBufferCompressed )
    {
        BOOL fIsSuccess;

        fIsSuccess = CompressInputBufferUsage( ) ;

        INET_ASSERT(fIsSuccess);
    }

    INET_ASSERT(_lpBufferIn == _lpBuffer );

    DEBUG_LEAVE((DWORD) (_lpEndOfBuffer - (_dwBufferIn + _lpBuffer) ));

    return (DWORD) (_lpEndOfBuffer - (_dwBufferIn + _lpBuffer) );
}

BOOL
DBLBUFFER::CopyIn(
    IN LPBYTE lpBuffer,
    IN DWORD dwBufferSize
    )
{

    DEBUG_ENTER((DBG_INET,
                 Bool,
                 "DBLBUFFER::CopyIn",
                 "%x, %d",
                 lpBuffer,
                 dwBufferSize
                 ));


    INET_ASSERT(lpBuffer);
    INET_ASSERT(dwBufferSize > 0);

    LPBYTE pbPointer;
    DWORD  dwCurInputSize;

    //
    // Get the current input buffer size
    //

    dwCurInputSize = GetInputBufferSize();

    if ( ! ResizeBufferIfNeeded(dwBufferSize) )
    {
        DEBUG_LEAVE(FALSE);
        return FALSE;
    }

    pbPointer = GetInputBufferPointer()+dwCurInputSize;
    SetInputBufferSize(dwBufferSize+dwCurInputSize);


    CopyMemory(
        pbPointer,             // dest
        lpBuffer,              // src
        dwBufferSize           // size
        );


    DEBUG_LEAVE(TRUE);

    return TRUE;

}

BOOL
DBLBUFFER::CopyOut(
    OUT LPBYTE     lpBuffer,
    IN OUT LPDWORD lpdwBufferRemaining,
    IN OUT LPDWORD lpdwBytesReceived,
    IN OUT LPDWORD lpdwBytesRead
    )

/*++

Routine Description:

    Fills passed in buffer with the contents of the output buffer.

Arguments:

    lpBuffer                    -       Buffer to fill with output buffer bytes

        lpdwBufferRemaining -   Number of bytes remaining in Buffer to fill.

        lpdwBytesReceived       -       Number of bytes currently in Buffer to fill.

        lpdwBytesRead           -       Current total of bytes copied into Buffer to fill.

Return Value:

    BOOL
    Success - TRUE

    Failure - FALSE

Comments:


--*/

{

    DEBUG_ENTER((DBG_INET,
                 Bool,
                 "DBLBUFFER::CopyOut",
                 "%x, %u, %u, %u",
                 lpBuffer,
                 (lpdwBufferRemaining ? *lpdwBufferRemaining : 0),
                 (lpdwBytesReceived ? *lpdwBytesReceived : 0),
                 (lpdwBytesRead ? *lpdwBytesRead : 0)
                 ));


    INET_ASSERT(lpBuffer);
    INET_ASSERT(lpdwBufferRemaining);
    INET_ASSERT(lpdwBytesReceived);
    INET_ASSERT(lpdwBytesRead);

    //
    // Figure out the max number of bytes we can copy into our user's buffer
    //      We need to make sure it will fit into the user's buffer.
    //

    DWORD dwBytesToCopy = (*lpdwBufferRemaining  >= _dwBufferOut)
            ? _dwBufferOut : *lpdwBufferRemaining;


    DEBUG_PRINT(API,
                INFO,
                ("DBLBUFFER::CopyOut: Copying ( to: %x bytes-to-copy=%d )\n",
                (lpBuffer+*lpdwBytesReceived),
                dwBytesToCopy
                ));


    //
    // Transfer Data to User's buffer.
    //

    CopyMemory ((lpBuffer+*lpdwBytesReceived),
                            _lpBufferOut,
                            dwBytesToCopy);


    //
    // Update the number of bytes we copied to the user buffer
    //

    *lpdwBytesRead                  += dwBytesToCopy;
    *lpdwBytesReceived              += dwBytesToCopy;
    *lpdwBufferRemaining    -= dwBytesToCopy;

    //
    // Update Our Internal Vars
    //

    _dwBufferOut                    -= dwBytesToCopy;
    _lpBufferOut                    += dwBytesToCopy;

    UpdateVars();

    //
    // We always succeed for now !
    //

    DEBUG_LEAVE(TRUE);

    return TRUE;
}

BOOL
DBLBUFFER::CompressInputBufferUsage(
    VOID
    )
/*++

Routine Description:

        Moves the input buffer to the begining of the internal allocated buffer.
        This produces a larger block of internal free space.

Arguments:

        none.

Return Value:

    BOOL
    Success - TRUE

    Success     - FALSE, there was no need to compress the buffer.

Comments:

  Assumed to be called only if DblBufferMode is enabled.

--*/


{
    DEBUG_ENTER((DBG_INET,
                 Bool,
                 "DBLBUFFER::CompressInputBufferUsage",
                 NULL
                 ));

    BOOL bResult = FALSE;

    //
    // Maximize use of buffer by moving input data to the front
    // of the buffer.
    //

    INET_ASSERT(_lpBuffer);
    INET_ASSERT(_dwBufferOut == 0);
    INET_ASSERT(_fDblBufferMode);

    if (_lpBufferIn > _lpBuffer) {

        DEBUG_PRINT(API,
                    INFO,
                    ("compressing input buffer %d (%#x) @ %#x => %#x\n",
                    _dwBufferIn,
                    _dwBufferIn,
                    _lpBufferIn,
                    _lpBuffer
                    ));

        MoveMemory(_lpBuffer,
                   _lpBufferIn,
                   _dwBufferIn
                   );

        //
        // Input Buffer now starts at the begining of the allocated buffer
        //

        _lpBufferIn = _lpBuffer;
        bResult = TRUE;
    }

    DEBUG_LEAVE(bResult);

    return bResult;
}



BOOL
DBLBUFFER::ConcatenateOutputBufferUsage(
    IN LPBYTE lpSecondOutputBuffer,
    IN DWORD  dwSecondOutputBufferSize
    )

/*++

Routine Description:

    Combines the current output buffer with the contents of a new buffer.
    (Note: intented for use in combining decrypted data which may be seperated by
    header or trailer data)

Arguments:

    lpSecondOutputBuffer        - New Buffer to combine with internal output buffer.

    dwSecondOutputBufferSize    - Size of New Buffer in bytes.


Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE

Comments:

    If the internal buffer is sized 0, the new buffer replaces the internal buffer.
    Its assumed that the New buffer is a former input buffer turned output by
    some external operation, such as a block decryption operation.
--*/

{


    DEBUG_ENTER((DBG_INET,
                 Bool,
                 "DBLBUFFER::ConcatenateOutputBufferUsage",
                 "%x, %u",
                 lpSecondOutputBuffer,
                 dwSecondOutputBufferSize
                 ));


    //
    // Combinate Two buffers into one.
    //

    INET_ASSERT(_lpBuffer);
    INET_ASSERT(_fDblBufferMode );
    INET_ASSERT(lpSecondOutputBuffer);
    INET_ASSERT(dwSecondOutputBufferSize);

    INET_ASSERT(_lpBufferOut < _lpBufferIn );
    INET_ASSERT(lpSecondOutputBuffer >= _lpBuffer && lpSecondOutputBuffer <=_lpEndOfBuffer );



    if ( _dwBufferOut != 0 )
    {
        DEBUG_PRINT(API,
                    INFO,
                    ("DBLBUFFER::ConcatenateOutputBufferUsage: Combining new data with output buffer\n"
                    ));

        MoveMemory((_lpBufferOut+_dwBufferOut),
                   lpSecondOutputBuffer,
                   dwSecondOutputBufferSize);
        //
        // Output Buffer is now bigger ( sum of orginal + new buffer size )
        //

        _dwBufferOut += dwSecondOutputBufferSize;

    }
    else
    {
        //
        // No previous output buffer, new buffer becomes output buffer
        //

        INET_ASSERT(_lpBufferOut == _lpEndOfBuffer );

        _lpBufferOut = lpSecondOutputBuffer;
        _dwBufferOut = dwSecondOutputBufferSize;

    }

    DEBUG_LEAVE(TRUE);

    return TRUE;
}


BOOL
DBLBUFFER::ResizeBufferIfNeeded(
    IN DWORD dwAddlBufferNeeded
    )

/*++

Routine Description:

    ReSizes internal buffer space to extend size of the buffer by dwAddlBufferNeeded.
    If the additional bytes can be made availble by compressing currently stored
    into one place ( ie the start of the buffer ), the reallocation of the buffer
    will not be done.

Arguments:

    dwAddlBufferNeeded  - Number of additional bytes to resize

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE, the reallocation failed due to lack of memory.

Comments:

    Its assumed the caller will only use this function in dbl buffering mode.

 --*/

{

    DEBUG_ENTER((DBG_INET,
                 Bool,
                 "DBLBUFFER::ResizeBufferIfNeeded",
                 "%u",
                 dwAddlBufferNeeded
                 ));

    INET_ASSERT(_lpBuffer);
    INET_ASSERT(_dwBufferOut == 0 );
    INET_ASSERT(_fDblBufferMode );

    DWORD dwInputBytesFree = GetInputBufferRemaining();

    INET_ASSERT(_lpBuffer == _lpBufferIn );

    //
    // #bytes needed > #bytes left free in Buffer.
    //

    if ( dwAddlBufferNeeded > dwInputBytesFree )
    {
        HLOCAL hBuffer;

        hBuffer = (HLOCAL) _lpBuffer;

        //
        // length increases by (bytes needed - current bytes free[in old buffer])
        //

        _dwBufferLength += (dwAddlBufferNeeded - dwInputBytesFree);

        DEBUG_PRINT(API,
                    INFO,
                    ("DBLBUFFER::ResizeBufferIfNeeded: Resizing Buffer to %d, addl=%d, free=%d\n",
                    _dwBufferLength,
                    dwAddlBufferNeeded,
                    dwInputBytesFree
                    ));

        INET_ASSERT(_dwBufferLength < DBLBUFFER_MAX_SIZE);

        //
        // Do Resize, and store result
        //

        _lpBuffer = (LPBYTE)ResizeBuffer(hBuffer, _dwBufferLength, FALSE);

        DEBUG_PRINT(BUFFER,
                    INFO,
                    ("resized %#x => %#x, %d bytes\n",
                    hBuffer,
                    _lpBuffer,
                    _dwBufferLength
                    ));

        if ( ! _lpBuffer )
        {
            DEBUG_PRINT(API,
                        ERROR,
                        ("DBLBUFFER::ResizeBufferIfNeeded: Failed while Resizing, Out of Mem?\n"
                        ));

            DEBUG_LEAVE(FALSE);

            return FALSE;  // failing due to NOT_ENOUGH_MEMORY
        }

        //
        // Update ReSized Buffer pointers
        //

        _lpBufferIn = _lpBuffer;

        UpdateVars();
    }

    DEBUG_LEAVE(TRUE);

    return TRUE;
}

BOOL
DBLBUFFER::SetOutputInputBuffer(
    IN LPBYTE lpNewOutputBuffer,
    IN DWORD  dwNewOutputBufferSize,
    IN LPBYTE lpNewInputBuffer,
    IN DWORD  dwNewInputBufferSize,
    IN BOOL   fConcatenatePreviousOutput
    )

/*++

Routine Description:

    Allows caller to specify new addresses for input and output buffer.
    If fConcatenatePreviousOutput is set, SetOutputInputBuffer will combine
    the passed in output buffer with any internal output buffer.
    Also allows size changes to buffers.

Arguments:

    lpNewOutputBuffer           - New Output Buffer.

    dwNewOutputBufferSize       - Size of New Output Buffer.

    lpNewInputBuffer            - New Input Buffer.

    dwNewInputBufferSize        - New Input Buffer Size.

    fConcatenatePreviousOutput  - TRUE if we are to combine internal output buffer
                                  with (passed in) new output buffer
                                  FALSE if we are to just replace output buffer pointers.

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE

Comments:

    Assumed to be called from double buffering mode.

--*/


{

    INET_ASSERT(_lpBuffer);
    INET_ASSERT(lpNewOutputBuffer >= _lpBuffer && lpNewOutputBuffer <= _lpEndOfBuffer );
    INET_ASSERT((lpNewInputBuffer >= _lpBuffer && lpNewInputBuffer <= _lpEndOfBuffer) || dwNewInputBufferSize == 0);
    INET_ASSERT(fConcatenatePreviousOutput || _dwBufferOut == 0 );
    INET_ASSERT(_fDblBufferMode );

    DEBUG_PRINT(API,
         INFO,
         ("DBLBUFFER::SetOutputInputBuffer: Getting New Output( %x, size=%d ) New Input( %x, size=%d)\n",
         lpNewOutputBuffer,
         dwNewOutputBufferSize,
         lpNewInputBuffer,
         dwNewInputBufferSize
         ));


    if ( fConcatenatePreviousOutput )
    {
        ConcatenateOutputBufferUsage(
                    lpNewOutputBuffer,
                    dwNewOutputBufferSize
                    );
    }
    else
    {
        _lpBufferOut = lpNewOutputBuffer;
        _dwBufferOut = dwNewOutputBufferSize;
    }


    _lpBufferIn = lpNewInputBuffer;
    _dwBufferIn = dwNewInputBufferSize;

    UpdateVars();

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\common\icasync.cxx ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    icasync.cxx

Abstract:

    Contains async socket (select) thread and support functions. Work items now
    processed by SHLWAPI/KERNEL32 thread pool

    Contents:
        InitializeAsyncSupport
        TerminateAsyncSupport
        QueueSocketWorkItem
        BlockWorkItem
        UnblockWorkItems
        CheckForBlockedWorkItems
        ICAsyncThread::~ICAsyncThread
        ICAsyncThread::QueueSocketWorkItem
        ICAsyncThread::BlockWorkItem
        ICAsyncThread::UnblockWorkItems
        ICAsyncThread::CheckForBlockedWorkItems
        ICAsyncThread::SelectThreadWrapper
        ICAsyncThread::SelectThread
        (ICAsyncThread::CreateSelectSocket)
        (ICAsyncThread::DestroySelectSocket)
        (ICAsyncThread::RecreateSelectSocket)
        (ICAsyncThread::InterruptSelect)
        (ICAsyncThread::DrainSelectSocket)

Author:

    Richard L Firth (rfirth) 04-Mar-1998

Environment:

    Win32 user-mode

Revision History:

    04-Mar-1998 rfirth
        Created

--*/

#include <wininetp.h>
#include <perfdiag.hxx>

DWORD CAsyncCount::AddRef()
{
    DWORD error = ERROR_SUCCESS;
    
    if (!GeneralInitCritSec.Lock())
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    ++dwRef;

    GeneralInitCritSec.Unlock();
quit:
    return error;       
}

VOID CAsyncCount::Release()
{
    BOOL bUnlock = GeneralInitCritSec.Lock();

    //Decrement the refcount always, but only Terminate if we obtained the critsec.
    if (!--dwRef && bUnlock)
    {
        //BUGBUG-enable later.
        TerminateAsyncSupport(TRUE);
    }

    if (bUnlock)
    {
        GeneralInitCritSec.Unlock();
    }
}
    
//
// private classes
//


class ICAsyncThread {

private:

    CPriorityList m_BlockedQueue;
    SOCKET m_SelectSocket;
    LONG m_lSelectInterrupts;
    BOOL m_bTerminating;
    DWORD m_dwError;
    HANDLE m_hThread;
    BOOL m_bCleanUp;

public:

    ICAsyncThread() {

        DEBUG_ENTER((DBG_ASYNC,
                     None,
                     "ICAsyncThread::ICAsyncThread",
                     NULL
                     ));

        m_SelectSocket = INVALID_SOCKET;
        m_lSelectInterrupts = -1;
        m_bTerminating = FALSE;
        m_dwError = ERROR_SUCCESS;

        DWORD dwThreadId;

        m_hThread = CreateThread(
                    NULL,
                    0,
                    (LPTHREAD_START_ROUTINE)ICAsyncThread::SelectThreadWrapper,
                    (LPVOID)this,
                    0,
                    &dwThreadId
                    );
        if (m_hThread == NULL) {
            SetError();
        }

        m_bCleanUp = FALSE;
        
        DEBUG_LEAVE(0);
    }

    ~ICAsyncThread();

    VOID SetCleanUp()
    {
        m_bCleanUp = TRUE;
    }
    
    DWORD GetError(VOID) const {
        return m_dwError;
    }

    VOID SetError(DWORD dwError = GetLastError()) {
        m_dwError = dwError;
    }

    BOOL IsTerminating(VOID) const {
        return m_bTerminating;
    }

    VOID SetTerminating(VOID) {
        m_bTerminating = TRUE;
    }

    DWORD
    QueueSocketWorkItem(
        IN CFsm * pFsm
        );

    BOOL
    RemoveFsmFromAsyncList(
        IN CFsm * pFsm
        );

    DWORD
    BlockWorkItem(
        IN CFsm * WorkItem,
        IN DWORD_PTR dwBlockId,
        IN DWORD dwTimeout = TP_NO_TIMEOUT
        );

    DWORD
    UnblockWorkItems(
        IN DWORD dwCount,
        IN DWORD_PTR dwBlockId,
        IN DWORD dwError,
        IN LONG lPriority = TP_NO_PRIORITY_CHANGE
        );

    DWORD
    CheckForBlockedWorkItems(
        IN DWORD dwCount,
        IN DWORD_PTR dwBlockId
        );

    static
    DWORD
    SelectThreadWrapper(
        IN ICAsyncThread * pThread
        );

    DWORD
    SelectThread(
        VOID
        );

    DWORD
    CreateSelectSocket(
        VOID
        );

    PRIVATE
    VOID
    DestroySelectSocket(
        VOID
        );

    VOID
    RecreateSelectSocket(
        VOID
        );

    VOID
    InterruptSelect(
        VOID
        );

    BOOL
    DrainSelectSocket(
        VOID
        );
};

//
// private data
//

PRIVATE ICAsyncThread * p_AsyncThread = NULL;
PRIVATE HANDLE* p_ThreadHandleArray = NULL;
PRIVATE DWORD* p_ThreadIdArray = NULL;
PRIVATE int p_iNumIOCPThreads = 0;

//
// functions
//



VOID
TerminateIOCPGlobals()
{
    if (g_lpCustomOverlapped)
    {
        delete g_lpCustomOverlapped;
        g_lpCustomOverlapped = NULL;
    }
    if (g_hCompletionPort)
    {
        CloseHandle(g_hCompletionPort);
        g_hCompletionPort = NULL;
    }
}


DWORD
IOCompletionThreadFunc(
    IN ULONG_PTR pContext
    )
{
    LPOVERLAPPED lpOverlapped;
    DWORD dwBytes;
    ULONG_PTR lpCompletionKey;
    DWORD dwTimeout = 1000;
    DWORD dwError = 0;
    BOOL bDeleteOverlapped = FALSE;
    LPINTERNET_THREAD_INFO lpThreadInfo;

    BOOL fExitThread = FALSE;
    lpThreadInfo = InternetGetThreadInfo();

    while (TRUE)
    {
                         
        BOOL bRet = GetQueuedCompletionStatus(g_hCompletionPort,
                                            &dwBytes,
                                            &lpCompletionKey,
                                            &lpOverlapped,
                                            fExitThread ? 0 : INFINITE);

        DEBUG_ENTER((DBG_API,
                         Dword,
                         "***GetQueuedCompletionStatus",
                         "(hcomp)%#x, (dwBytes)%#x, (completionkey)%#x, (overlapped)%#x",
                         g_hCompletionPort,
                         dwBytes,
                         lpCompletionKey,
                         lpOverlapped
                         ));

        if (!bRet && !lpOverlapped)
        {
            DEBUG_LEAVE_API(NULL);
            
            DWORD dwError = GetLastError();

            if (dwError == WAIT_TIMEOUT)
            {
                break;
            }

            // other errors currently not possible since we only have custom completion packets.
            INET_ASSERT (FALSE);

            continue;
        }

        ICSocket* pObject;
        CFsm* pFsm;
        CWrapOverlapped* lpWrapOverlapped;
        if (lpOverlapped != g_lpCustomOverlapped)
        {
            pObject = (ICSocket *) lpCompletionKey;
            pFsm = pObject->GetAndSetCurrentFsm(NULL);
            DEBUG_LEAVE(pFsm);
            
#if INET_DEBUG
            InterlockedDecrement(&g_cWSACompletions);
#endif

            INET_ASSERT(pFsm);
            bDeleteOverlapped = TRUE;
            lpWrapOverlapped = GetWrapOverlappedObject(lpOverlapped);

            if (pFsm->HasTimeout())
            {
                if (!RemoveFsmFromAsyncList(pFsm))
                {
                    //failure! the select thread already enforced timeout and updated state
                    //INET_ASSERT (FALSE && "COOL");
                    goto runworkitem;
                }
            }
            
            ((CFsm_SocketIOCP*)pFsm)->dwBytesTransferred = dwBytes;
            ((CFsm_SocketIOCP*)pFsm)->bIOCPSuccess = bRet;
            
            pFsm->ResetSocket();
            pFsm->SetPriority(TP_NO_PRIORITY_CHANGE);
            
            if (bRet)
            {
                pFsm->SetError(ERROR_SUCCESS);
                pFsm->SetState(pFsm->GetNextState());
            }
            else
            {
                //VENKATK_BUG-informational assert - remove later.
                DWORD dwErrorDebug = GetLastError();
                INET_ASSERT (FALSE && "IoCompletionError");
                
                ((CFsm_SocketIOCP*)pFsm)->dwIOCPError = GetLastError();

                if (((CFsm_SocketIOCP*)pFsm)->dwIOCPError == WSA_OPERATION_ABORTED)
                    pFsm->SetErrorState(ERROR_WINHTTP_OPERATION_CANCELLED);
                else
                    pFsm->SetErrorState(ERROR_WINHTTP_CONNECTION_ERROR);
            }
        }
        else
        {
            DEBUG_LEAVE(lpCompletionKey);
            INET_ASSERT( lpOverlapped == g_lpCustomOverlapped );
            INET_ASSERT( (dwBytes == COMPLETION_BYTES_CUSTOM) ||
                          (dwBytes == COMPLETION_BYTES_EXITIOCP) );

            if (dwBytes == COMPLETION_BYTES_EXITIOCP)
            {
                INET_ASSERT (lpCompletionKey == NULL);
                break;
            }   

            bDeleteOverlapped = FALSE;
            pFsm = (CFsm*) lpCompletionKey;
            
#if INET_DEBUG
            InterlockedDecrement(&g_cCustomCompletions);
#endif
        }

runworkitem:
        if (pFsm)
        {
            INTERNET_HANDLE_BASE *pBase = ((INTERNET_HANDLE_BASE *)pFsm->GetMappedHandleObject());
            pBase->Reference();  // might go away if closehandle is called.

            lpThreadInfo->IsAsyncWorkerThread = TRUE;
            dwError = CFsm::RunWorkItem(pFsm);

            if (dwError != ERROR_IO_PENDING)
            {
                // If there are any pending async work items for this request,
                // then schedule the first one in the list.
                if (pBase->GetHandleType() == TypeHttpRequestHandle)
                {
                    HTTP_REQUEST_HANDLE_OBJECT *pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)pBase;
                    if (pRequest->LockAsync())
                    {
                        if (!pRequest->IsWorkItemListEmpty())
                        {
                            pRequest->ScheduleWorkItem();
                        }
                        else
                        {
                            pRequest->SetWorkItemInProgress(FALSE);
                        }
                        pRequest->UnlockAsync();
                    }
                    else
                    {
                        // Need to report an error even if async item was
                        // successful if we can't check for pending work items.
                        dwError = (dwError == ERROR_SUCCESS ?
                                ERROR_NOT_ENOUGH_MEMORY : dwError);
                    }
                }
            }
            pBase->Dereference();
            // Must stay marked as being on an async worker thread until after
            // releasing the reference in order to prevent confusion in the async count.
            lpThreadInfo->IsAsyncWorkerThread = FALSE;
        }
        else
        {
            INET_ASSERT (pFsm);
        }

        if (!lpThreadInfo)
        {
            lpThreadInfo = InternetGetThreadInfo();
        }

        if (lpThreadInfo && lpThreadInfo->fExitThread)
        {
            //exit this thread after dequeuing as many available completions as possible.
            fExitThread = TRUE;
        }
        
        if (bDeleteOverlapped)
        {
            lpWrapOverlapped->Dereference();//VENKATKBUG - move it up later, but for now keep it here for debugging.
        }
    }

    if (fExitThread)
    {
        if (GeneralInitCritSec.Lock())
        {
            if (g_pAsyncCount && !g_pAsyncCount->GetRef())
            {
                //Additional check to make sure we don't go and knock off a freshly created set of globals.
                //These won't be leaked - would already have been deleted in the renewed InitializeIOCPSupport call.
                TerminateIOCPGlobals();
            }
            GeneralInitCritSec.Unlock();
        }
    }
    
    return dwError;
}

/*
 * called from InitalizeAsyncSupport and synchronized there
 *
 * also, don't bother to cleanup - if there's an error TerminateIOCPSupport is called.
 */

DWORD
InitializeIOCPSupport(
    VOID
    )
{
    int dwNumIOCPThreads = g_cNumIOCPThreads;

    if (!dwNumIOCPThreads)
    {
        SYSTEM_INFO sSysInfo;
        memset(&sSysInfo, 0, sizeof(SYSTEM_INFO));
        GetSystemInfo(&sSysInfo);
        if (sSysInfo.dwNumberOfProcessors)
            dwNumIOCPThreads = sSysInfo.dwNumberOfProcessors;

        if (!dwNumIOCPThreads)
        {
            dwNumIOCPThreads = WINHTTP_GLOBAL_IOCP_THREADS_BACKUP;
        }
    }
    g_cNumIOCPThreads = dwNumIOCPThreads;

#if INET_DEBUG
    g_cWSACompletions = 0;
    g_cCustomCompletions = 0;
#endif

    DWORD dwError = ERROR_SUCCESS;

    //May be left over from previous run.
    if (g_hCompletionPort)
    {
        CloseHandle(g_hCompletionPort);
        g_hCompletionPort = NULL;
    };

    if (g_lpCustomOverlapped)
    {
        delete g_lpCustomOverlapped;
        g_lpCustomOverlapped = NULL;
    }
    
    g_hCompletionPort = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, 0);

    if (!g_hCompletionPort)
    {
        dwError = GetLastError();
        goto quit;
    }

    g_lpCustomOverlapped = New OVERLAPPED();

    if (!g_lpCustomOverlapped)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    memset(g_lpCustomOverlapped, 0, sizeof(OVERLAPPED));

    p_ThreadHandleArray = New HANDLE[dwNumIOCPThreads];
    p_ThreadIdArray = New DWORD[dwNumIOCPThreads];

    if (!p_ThreadHandleArray || !p_ThreadIdArray)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }
        
    for (int i=0; i<dwNumIOCPThreads; i++)
    {
        BOOL bSuccess;
        DWORD dwThreadId;
        HANDLE hThread;

        hThread = CreateThread(
                    NULL,
                    0,
                    (LPTHREAD_START_ROUTINE)IOCompletionThreadFunc,
                    NULL,
                    0,
                    &dwThreadId
                    );
        
        if (hThread)
        {   
            p_ThreadHandleArray[p_iNumIOCPThreads++] = hThread;
            p_ThreadIdArray[i] = dwThreadId;
        }
        else
        {
            //successfully queued functions terminated in TerminateIOCPSupport   
            dwError = GetLastError();
            break;
        }
        
    }

quit:
    return dwError;
}


VOID
TerminateIOCPSupport(
    VOID
    )
{
    DWORD dwWaitResult;
    int iNumThreadsToEnd = p_iNumIOCPThreads;
    HANDLE* pThreadHandleArray = p_ThreadHandleArray;
    DWORD fDeleteHandleArray = FALSE;
    BOOL fTerminatingOnWorker = FALSE;
    
    if (!p_ThreadHandleArray)
        goto quit;

#if INET_DEBUG
    if (g_cWSACompletions || g_cCustomCompletions)
    {
        INET_ASSERT(FALSE);
        WaitForMultipleObjects(p_iNumIOCPThreads, p_ThreadHandleArray, TRUE, 500);
    }
#endif

    LPINTERNET_THREAD_INFO lpThreadInfo;

    lpThreadInfo = InternetGetThreadInfo();

    if (!lpThreadInfo)
    {
        goto quit;
    }

    if (lpThreadInfo->IsAsyncWorkerThread)
    {
        //can't terminate the worker thread we're on.
        --iNumThreadsToEnd;
        fTerminatingOnWorker = TRUE;

        lpThreadInfo->fExitThread = TRUE;
        
        if (iNumThreadsToEnd)
        {
            int iIndex = -1;
            DWORD dwThreadId = GetCurrentThreadId();

            //verify we're on a worker thread.
            for (int i=0; i<p_iNumIOCPThreads; i++)
            {
                if (p_ThreadIdArray[i] == dwThreadId)
                {
                    iIndex = i;
                    break;
                }
            }
            
            if (iIndex != -1)
            {
                pThreadHandleArray = New HANDLE[iNumThreadsToEnd];

                if (!pThreadHandleArray)
                {
                    goto quit;
                }
                fDeleteHandleArray = TRUE;
                
                int i=0;
                for (int j=0; j<p_iNumIOCPThreads; j++)
                {
                    if (j != iIndex)
                    {
                        pThreadHandleArray[i++] = p_ThreadHandleArray[j]; 
                    }
                }
            }
            else
            {
                INET_ASSERT(FALSE);
            }
        }
        else
        {
            goto quit;
        }
    }
    
    for (int i=0; i<iNumThreadsToEnd; i++)
    {
        BOOL bSuccess = PostQueuedCompletionStatus(g_hCompletionPort,
                                            COMPLETION_BYTES_EXITIOCP,
                                            NULL,
                                            g_lpCustomOverlapped
                                            );
        INET_ASSERT (bSuccess);
    }

    dwWaitResult = WaitForMultipleObjects(iNumThreadsToEnd, pThreadHandleArray, TRUE, 2000);

    if ((dwWaitResult == WAIT_TIMEOUT) || (dwWaitResult == WAIT_FAILED))
    {
        goto forceTerminate;
    }
    else
    {
        INET_ASSERT ( ((LONG)dwWaitResult >= WAIT_OBJECT_0) && ((LONG)dwWaitResult < (WAIT_OBJECT_0+p_iNumIOCPThreads)));
    }

quit:
    INET_ASSERT ((g_cWSACompletions == 0) &&
                 (g_cCustomCompletions == 0));
                 
    if (p_ThreadHandleArray)
    {
        for (int i=0; i<p_iNumIOCPThreads; i++)
        {
            CloseHandle(p_ThreadHandleArray[i]);
        }
    
        delete [] p_ThreadHandleArray;
        p_ThreadHandleArray = NULL;
    }
    if (p_ThreadIdArray)
    {
        delete [] p_ThreadIdArray;
        p_ThreadIdArray = NULL;
    }
    if (fDeleteHandleArray)
    {
        delete [] pThreadHandleArray;
    }
    if (fTerminatingOnWorker)
    {
        //don't delete these globals since they may be in use on this last thread.
        TerminateIOCPGlobals();
    }
    p_iNumIOCPThreads = 0;
    
    return;

forceTerminate:
    for (int i=0; i<iNumThreadsToEnd; i++)
    {
        if (WaitForSingleObject(pThreadHandleArray[i], 0) != WAIT_OBJECT_0)
        {
            TerminateThread(pThreadHandleArray[i], -1);
        }
    }
    goto quit;
}


DWORD
InitializeAsyncSupport(
    VOID
    )

/*++

Routine Description:

    Create async select thread object

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS


        Failure -

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "InitializeAsyncSupport",
                 NULL
                 ));

    DWORD error = ERROR_WINHTTP_SHUTDOWN;

    if (!InDllCleanup) {

        if (!GeneralInitCritSec.Lock())
        {
            error = ERROR_NOT_ENOUGH_MEMORY;
            goto quit;
        }

        if (!InDllCleanup) {
            if (p_AsyncThread == NULL) {

                HANDLE  hThreadToken = NULL;
                //
                // If the current thread is impersonating, then grab its access token
                // and revert the current thread (so it is nolonger impersonating).
                // After creating the worker thread, we will make the main thread
                // impersonate again. Apparently you should not call CreateThread
                // while impersonating.
                //
                if (OpenThreadToken(GetCurrentThread(), (TOKEN_IMPERSONATE | TOKEN_READ),
                        FALSE,
                        &hThreadToken))
                {
                    INET_ASSERT(hThreadToken != 0);

                    RevertToSelf();
                }

                p_AsyncThread = New ICAsyncThread();
                if (p_AsyncThread == NULL) {
                    error = ERROR_NOT_ENOUGH_MEMORY;
                } else {
                    error = p_AsyncThread->GetError();
                    if (error == ERROR_SUCCESS)
                        error = InitializeIOCPSupport();
                    if (error != ERROR_SUCCESS) {
                        TerminateAsyncSupport(TRUE);
                    }
                }

                if (hThreadToken)
                {
                    SetThreadToken(NULL, hThreadToken);

                    CloseHandle(hThreadToken);
                }


            } else {
                error = ERROR_SUCCESS;
            }
        }
        GeneralInitCritSec.Unlock();
    }

quit:
    DEBUG_LEAVE(error);

    return error;
}


VOID
TerminateAsyncSupport(
    BOOL bCleanUp
    )

/*++

Routine Description:

    Terminates async support

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 None,
                 "TerminateAsyncSupport",
                 NULL
                 ));

    ICAsyncThread * pThread;
    
    if (GeneralInitCritSec.Lock())
    {
        TerminateIOCPSupport();
        
        pThread = (ICAsyncThread *)InterlockedExchangePointer((PVOID*)&p_AsyncThread,
                                                       (PVOID)NULL
                              );
        
        if (pThread != NULL) 
        {
            if (bCleanUp)
                pThread->SetCleanUp();
            delete pThread;
        }

        GeneralInitCritSec.Unlock();
    }
    
    DEBUG_LEAVE(0);
}



BOOL
RemoveFsmFromAsyncList(
    IN CFsm * pFsm
    )
{
    BOOL bSuccess = TRUE;
    if (p_AsyncThread != NULL) 
    {
        bSuccess = p_AsyncThread->RemoveFsmFromAsyncList(pFsm);
    }

    return bSuccess;
}


DWORD
QueueSocketWorkItem(
    IN CFsm * pFsm,
    IN SOCKET Socket
    )

/*++

Routine Description:

    Adds a blocked socket operation/work item to the blocked queue

Arguments:

    pFsm    - in-progress socket operation (FSM)

    Socket  - socket handle to wait on

Return Value:

    DWORD
        Success - ERROR_IO_PENDING

        Failure - ERROR_WINHTTP_INTERNAL_ERROR

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "QueueSocketWorkItem",
                 "%#x, %#x",
                 pFsm,
                 Socket
                 ));

    DWORD error = ERROR_WINHTTP_INTERNAL_ERROR;

    if (p_AsyncThread != NULL) {
        pFsm->SetSocket(Socket);
        error = p_AsyncThread->QueueSocketWorkItem(pFsm);
        if (error == ERROR_SUCCESS) {
            error = ERROR_IO_PENDING;
        }
    }

    INET_ASSERT(error != ERROR_WINHTTP_INTERNAL_ERROR);

    DEBUG_LEAVE(error);

    return error;
}



DWORD
BlockWorkItem(
    IN CFsm * pFsm,
    IN DWORD_PTR dwBlockId,
    IN DWORD dwTimeout
    )

/*++

Routine Description:

    Blocks a work item

Arguments:

    pFsm        - work item to block

    dwBlockId   - block on this id

    dwTimeout   - for this number of milliseconds

Return Value:

    DWORD
        Error   - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "BlockWorkItem",
                 "%#x, %#x, %d",
                 pFsm,
                 dwBlockId,
                 dwTimeout
                 ));

    DWORD error = ERROR_WINHTTP_INTERNAL_ERROR;

    if (p_AsyncThread != NULL) {
        error = p_AsyncThread->BlockWorkItem(pFsm, dwBlockId, dwTimeout);
    }

    INET_ASSERT(error != ERROR_WINHTTP_INTERNAL_ERROR);

    DEBUG_LEAVE(error);

    return error;
}


DWORD
UnblockWorkItems(
    IN DWORD dwCount,
    IN DWORD_PTR dwBlockId,
    IN DWORD dwError,
    IN LONG lPriority
    )

/*++

Routine Description:

    Unblocks 1 or more work items

Arguments:

    dwCount     - unblock this many work items

    dwBlockId   - that are blocked on this id

    dwError     - with this error

    lPriority   - new priority unless default value of TP_NO_PRIORITY_CHANGE

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Int,
                 "UnblockWorkItems",
                 "%d, %#x, %d (%s), %d",
                 dwCount,
                 dwBlockId,
                 dwError,
                 InternetMapError(dwError),
                 lPriority
                 ));

    DWORD dwUnblocked = 0;

    if (p_AsyncThread != NULL) {
        dwUnblocked = p_AsyncThread->UnblockWorkItems(dwCount,
                                                      dwBlockId,
                                                      dwError,
                                                      lPriority
                                                      );
    }

    DEBUG_LEAVE(dwUnblocked);

    return dwUnblocked;
}


DWORD
CheckForBlockedWorkItems(
    IN DWORD dwCount,
    IN DWORD_PTR dwBlockId
    )

/*++

Routine Description:

    Checks if there are any items blocked on dwBlockId

Arguments:

    dwCount     - number of items to look for

    dwBlockId   - blocked on this id

Return Value:

    DWORD
        Number of blocked items found

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Int,
                 "CheckForBlockedWorkItems",
                 "%d, %#x",
                 dwCount,
                 dwBlockId
                 ));

    DWORD dwFound = 0;

    if (p_AsyncThread != NULL) {
        dwFound = p_AsyncThread->CheckForBlockedWorkItems(dwCount, dwBlockId);
    }

    DEBUG_LEAVE(dwFound);

    return dwFound;
}

//
// private functions
//

//
// ICAsyncThread methods
//


ICAsyncThread::~ICAsyncThread(
    VOID
    )

/*++

Routine Description:

    ICAsyncThread destructor. If we are being dynamically unloaded, signal the
    selecter thread and allow it to cleanup. Else the thread is already dead and
    we just need to reclaim the resources

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 None,
                 "ICAsyncThread::~ICAsyncThread",
                 NULL
                 ));

    SetTerminating();
    if (GlobalDynaUnload || m_bCleanUp) {
        InterruptSelect();

        //
        // Assuming the async thread was successfully created, the above clean-up
        // will have put it in a state where it's going to exit.  Need to wait
        // for it to exit before returning from here so it doesn't get scheduled
        // after wininet has been unloaded.
        //
        if(m_hThread)
        {
            DWORD dwRes = WaitForSingleObject(m_hThread, 5 * 1000);
            INET_ASSERT(dwRes == WAIT_OBJECT_0);
        }
    }
    DestroySelectSocket();

    if(m_hThread)
    {
        CloseHandle(m_hThread);
    }

    DEBUG_LEAVE(0);
}


DWORD
ICAsyncThread::QueueSocketWorkItem(
    IN CFsm * pFsm
    )

/*++

Routine Description:

    Add the work-item waiting on a blocked socket to the blocked queue.
    Interrupt the SelectThread to alert it to new work

Arguments:

    pFsm    - blocked work-item to queue

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_WINHTTP_INTERNAL_ERROR

Async Issues: VENKATK_BUG
    1. Reduce contention for m_BlockedQueue by:
        maintaining sorted queue for timeout-only fsms.
    2. Don't call InterruptSelect() for timeout queueing
    3. check if content can be moved to per-fsm instead of
        global queue..
--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "ICAsyncThread::QueueSocketWorkItem",
                 "%#x",
                 pFsm
                 ));

    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
    DWORD error = ERROR_WINHTTP_INTERNAL_ERROR;

    INET_ASSERT(lpThreadInfo != NULL);

    if (lpThreadInfo != NULL) {
        pFsm->StartTimer();
        error = m_BlockedQueue.Insert((CPriorityListEntry *)pFsm->List());
        lpThreadInfo->Fsm = NULL;
        InterruptSelect();
    }

    DEBUG_LEAVE(error);

    return error;
}


BOOL
ICAsyncThread::RemoveFsmFromAsyncList(
    IN CFsm * pFsm
    )
{
    BOOL bSuccess = FALSE;
    if (m_BlockedQueue.Acquire())
    {
        if (pFsm->IsOnAsyncList())
        {
            m_BlockedQueue.Remove((CPriorityListEntry *)pFsm);
            pFsm->SetOnAsyncList(FALSE);
            bSuccess = TRUE;
        }
        m_BlockedQueue.Release();
    }
    
    return bSuccess;
}


DWORD
ICAsyncThread::BlockWorkItem(
    IN CFsm * pFsm,
    IN DWORD_PTR dwBlockId,
    IN DWORD dwTimeout
    )

/*++

Routine Description:

    Blocks a work item (FSM)

Arguments:

    pFsm        - work item (FSM) to block

    dwBlockId   - block on this

    dwTimeout   - for this amount of time (mSec)

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "ICAsyncThread::BlockWorkItem",
                 "%#x [%d], %#x, %d",
                 pFsm,
                 pFsm->GetPriority(),
                 dwBlockId,
                 dwTimeout
                 ));

    DWORD error = error = ERROR_WINHTTP_INTERNAL_ERROR;
    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

    INET_ASSERT(lpThreadInfo != NULL);

    if (lpThreadInfo != NULL) {
        pFsm->SetBlockId(dwBlockId);
        pFsm->SetTimeout(dwTimeout);

        RESET_FSM_OWNED(pFsm);

        DEBUG_PRINT(ASYNC,
                    INFO,
                    ("!!! FSM %#x unowned\n",
                    pFsm
                    ));

        error = m_BlockedQueue.Insert((CPriorityListEntry *)pFsm->List());
        lpThreadInfo->Fsm = NULL;
    }

    DEBUG_LEAVE(error);
    return error;
}


DWORD
ICAsyncThread::UnblockWorkItems(
    IN DWORD dwCount,
    IN DWORD_PTR dwBlockId,
    IN DWORD dwError,
    IN LONG lPriority
    )

/*++

Routine Description:

    Unblock a nunber of work items waiting on a block id

Arguments:

    dwCount     - unblock this many work items

    dwBlockId   - unblock work items waiting on this id

    dwError     - unblock work items with this error code

    lPriority   - if not TP_NO_PRIORITY_CHANGE, change priority to this value

Return Value:

    DWORD
        Number of work items unblocked

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Int,
                 "ICAsyncThread::UnblockWorkItems",
                 "%d, %#x, %d (%s), %d",
                 dwCount,
                 dwBlockId,
                 dwError,
                 InternetMapError(dwError),
                 lPriority
                 ));

    DWORD dwUnblocked = 0;

    if (!m_BlockedQueue.Acquire())
        goto quit;

    CPriorityListEntry * pCur = (CPriorityListEntry *)m_BlockedQueue.Head();
    CPriorityListEntry * pPrev = (CPriorityListEntry *)m_BlockedQueue.Self();

    while ((dwCount != 0) && (pCur != (CPriorityListEntry *)m_BlockedQueue.Self())) {

        CFsm * pFsm = ContainingFsm((LPVOID)pCur);

        //CHECK_FSM_UNOWNED(pFsm);

        if (pFsm->IsBlockedOn(dwBlockId)) {
            m_BlockedQueue.Remove((CPriorityListEntry *)pFsm);
            pFsm->SetError(dwError);
            if (lPriority != TP_NO_PRIORITY_CHANGE) {
                pFsm->SetPriority(lPriority);
            }
//dprintf("UNBLOCKED %s FSM %#x state %s socket %#x\n", pFsm->MapType(), pFsm, pFsm->MapState(), pFsm->GetSocket());
            pFsm->QueueWorkItem();
            ++dwUnblocked;
            --dwCount;
        } else {
            pPrev = pCur;
        }
        pCur = (CPriorityListEntry *)pPrev->Next();
    }
    m_BlockedQueue.Release();

quit:
    DEBUG_LEAVE(dwUnblocked);

    return dwUnblocked;
}


DWORD
ICAsyncThread::CheckForBlockedWorkItems(
    IN DWORD dwCount,
    IN DWORD_PTR dwBlockId
    )

/*++

Routine Description:

    Examines to see if a blocked FSM is still blocked in order to prevent
        wasted processing if it isn't.

Arguments:

    dwCount     - unblock this many work items

    dwBlockId   - unblock work items waiting on this id

Return Value:

    DWORD
        Number of work items that are currently blocked

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Int,
                 "ICAsyncThread::CheckForBlockedWorkItems",
                 "%d, %#x",
                 dwCount,
                 dwBlockId
                 ));

    DWORD dwFound = 0;

    if (!m_BlockedQueue.Acquire())
        goto quit;

    CPriorityListEntry * pCur = (CPriorityListEntry *)m_BlockedQueue.Head();
    CPriorityListEntry * pPrev = (CPriorityListEntry *)m_BlockedQueue.Self();

    while ((dwCount != 0) && (pCur != (CPriorityListEntry *)m_BlockedQueue.Self())) {

        CFsm * pFsm = ContainingFsm((LPVOID)pCur);

        if (pFsm->IsBlockedOn(dwBlockId)) {
            ++dwFound;
            --dwCount;
        }
        pCur = (CPriorityListEntry *)pCur->Next();
    }
    m_BlockedQueue.Release();

quit:
    DEBUG_LEAVE(dwFound);

    return dwFound;
}


DWORD
ICAsyncThread::SelectThreadWrapper(
    IN ICAsyncThread * pThread
    )

/*++

Routine Description:

    Kicks off select thread as member function of pThread object

Arguments:

    pThread - pointer to thread object

Return Value:

    DWORD
        return code from SelectThread (not used)

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "ICAsyncThread::SelectThreadWrapper",
                 "%#x",
                 pThread
                 ));

    DWORD error = pThread->SelectThread();

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICAsyncThread::SelectThread(
    VOID
    )

/*++

Routine Description:

    Waits for completed items on blocked queue to finish, either due to timeout,
    invalidated request handle or successful or error completion of the socket
    operation.

    Completed items are put on the work queue and a worker signalled to process
    it

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    //
    // we need thread info for debug output
    //

    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

    if (lpThreadInfo == NULL) {

        DEBUG_PRINT(ASYNC,
                    FATAL,
                    ("Can't get thread info block\n"
                    ));

        INET_ASSERT(FALSE);

        return ERROR_WINHTTP_INTERNAL_ERROR;
    }

    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "ICAsyncThread::SelectThread",
                 NULL
                 ));

    //
    // have to create select socket in this thread or winsock blocks main thread
    // on Win95 when autodial enabled
    //

    DWORD error = CreateSelectSocket();

    if (error != ERROR_SUCCESS) {

        DEBUG_LEAVE(error);

        return error;
    }

    DWORD ticks = GetTickCountWrap();

    while (!IsTerminating()) {

        //
        // run through the blocked items finding sockets to wait on and minimum
        // time to wait. If we find any items already timed out or invalidated
        // then remove them and put on the work queue
        //

        if (!m_BlockedQueue.Acquire())
        {
            // wait and try again when more memory might be available
            goto wait_again;
        }

        PLIST_ENTRY pEntry;
        PLIST_ENTRY pPrev;

        pPrev = m_BlockedQueue.Self();

        //
        // BUGBUG - queue limited by size of FD_SET
        //

        struct fd_set read_fds;
        int nTimeouts = 0;
        struct fd_set write_fds;
        struct fd_set except_fds;
        int n = 0;
        BOOL bLazy = FALSE;
        DWORD timeout = 0xffffffff;
        DWORD timeNow = GetTickCountWrap();

        FD_ZERO(&read_fds);
        FD_ZERO(&write_fds);
        FD_ZERO(&except_fds);

        CFsm * pFsm;

        for (pEntry = m_BlockedQueue.Head();
             pEntry != m_BlockedQueue.Self();
             pEntry = ((CPriorityListEntry *)pPrev)->Next()) {

            pFsm = ContainingFsm((LPVOID)pEntry);
            if (pFsm->IsInvalid() || pFsm->IsTimedOut(timeNow)) {

                DEBUG_PRINT(ASYNC,
                            INFO,
                            ("%s FSM %#x %s\n",
                            pFsm->MapType(),
                            pFsm,
                            pFsm->IsInvalid() ? "invalid" : "timed out"
                            ));

                m_BlockedQueue.Remove((CPriorityListEntry *)pEntry);

                if (pFsm->IsOnAsyncList())
                {
                    INET_ASSERT( (pFsm->GetAction() == FSM_ACTION_SEND) ||
                                    (pFsm->GetAction() == FSM_ACTION_RECEIVE) );
                                 
                    ((INTERNET_HANDLE_BASE *)pFsm->GetMappedHandleObject())->AbortSocket();
                    
                    pFsm->SetErrorState(pFsm->IsInvalid()
                                        ? ERROR_WINHTTP_OPERATION_CANCELLED
                                        : ERROR_WINHTTP_TIMEOUT
                                        );
                                        
                    pFsm->SetOnAsyncList(FALSE);
                    continue;
                }

                pFsm->SetErrorState(pFsm->IsInvalid()
                                        ? ERROR_WINHTTP_OPERATION_CANCELLED
                                        : ERROR_WINHTTP_TIMEOUT
                                        );
                pFsm->ResetSocket();
                pFsm->QueueWorkItem();
                continue;
            }
            else if (pFsm->IsOnAsyncList())
            {
                INET_ASSERT (pFsm->IsActive());
                ++nTimeouts;
            }
            else if (pFsm->IsActive()) 
            {
                SOCKET sock = pFsm->GetSocket();

                if (pFsm->GetAction() == FSM_ACTION_RECEIVE) 
                {
                    DEBUG_PRINT(ASYNC,
                                INFO,
                                ("FSM %#x READ waiting on socket %#x\n",
                                pFsm,
                                sock
                                ));

                    FD_SET(sock, &read_fds);
                } 
                else 
                {
                    //
                    // connect() & send()
                    //
                    DEBUG_PRINT(ASYNC,
                                INFO,
                                ("%s FSM %#x WRITE waiting on socket %#x\n",
                                pFsm->MapType(),
                                pFsm,
                                sock
                                ));

                    FD_SET(sock, &write_fds);
                }

                //
                // all sockets are checked for exception
                //
                FD_SET(sock, &except_fds);
                ++n;

//DWORD t;
//if ((t = pFsm->GetElapsedTime()) > 10) {
//    dprintf("%s FSM %#x socket %#x on queue %d mSec times-out in %d\n",
//    pFsm->MapType(),
//    pFsm,
//    sock,
//    t,
//    pFsm->GetTimeout() - GetTickCount());
//}
            }// if pFsm->IsActive()

            DWORD interval = pFsm->GetTimeout() - timeNow;

            //VENKATKBUG - check negative interval issue?
            if (interval < timeout) {
                timeout = interval;
//dprintf("min timeout = %d\n", timeout);
            }
            pPrev = pEntry;
        }

        m_BlockedQueue.Release();

wait_again:
        //
        // BUGBUG - wait for default (5 secs) timeout if nothing currently on
        //          list
        //
        if ((n == 0) && (nTimeouts == 0))
        {
            timeout = 5000;
            bLazy = TRUE;
        }

        INET_ASSERT(n < FD_SETSIZE);

        FD_SET(m_SelectSocket, &read_fds);
        ++n;

        struct timeval to;

        to.tv_sec = timeout / 1000;
        to.tv_usec = (timeout % 1000) * 1000;

        DEBUG_PRINT(ASYNC,
                    INFO,
                    ("waiting %d mSec (%d.%06d) for select(). %d sockets\n",
                    timeout,
                    to.tv_sec,
                    to.tv_usec,
                    n
                    ));

        //SuspendCAP();

        if (IsTerminating()) {
            break;
        }
        n = PERF_Select(n, &read_fds, &write_fds, &except_fds, &to);
        if (IsTerminating()) {
            break;
        }

        //ResumeCAP();

        DEBUG_PRINT(ASYNC,
                    INFO,
                    ("select() returns %d\n",
                    n
                    ));

        //
        // if the only thing that's happened is that a new request has been
        // added to the list then rebuild the list and re-select
        //

        if ((n == 1) && FD_ISSET(m_SelectSocket, &read_fds)) {
            if (!DrainSelectSocket() && !IsTerminating()) {
                RecreateSelectSocket();
            }
            continue;
        }

        //
        // if any items are completed (either successfully or with an error)
        // or timed out or invalidated then put them on the work queue
        //


        if ((n>=0) || (nTimeouts >= 0))
        {
            if (m_BlockedQueue.Acquire())
            {

                pPrev = m_BlockedQueue.Self();
                timeNow = GetTickCountWrap();

                for (pEntry = m_BlockedQueue.Head();
                     pEntry != m_BlockedQueue.Self();
                     pEntry = ((CPriorityListEntry *)pPrev)->Next()) 
                {
                    DWORD dwEntryError;
                    BOOL bComplete = FALSE;
                    LONG lPriority = TP_NO_PRIORITY_CHANGE;

                    pFsm = ContainingFsm((LPVOID)pEntry);
                    if (pFsm->IsInvalid()) {

                        DEBUG_PRINT(ASYNC,
                                    INFO,
                                    ("%s FSM %#x invalid\n",
                                    pFsm->MapType(),
                                    pFsm
                                    ));

                        dwEntryError = ERROR_WINHTTP_OPERATION_CANCELLED;
                        bComplete = TRUE;
                    } else if (pFsm->IsTimedOut(timeNow)) {

                        DEBUG_PRINT(ASYNC,
                                    INFO,
                                    ("%s FSM %#x timed out\n",
                                    pFsm->MapType(),
                                    pFsm
                                    ));

                        dwEntryError = ERROR_WINHTTP_TIMEOUT;
                        bComplete = TRUE;
                    } else if (pFsm->IsActive()) {

                        SOCKET sock = pFsm->GetSocket();

                        if (FD_ISSET(sock, &except_fds)) {

                            DEBUG_PRINT(ASYNC,
                                        INFO,
                                        ("%s FSM %#x socket %#x exception\n",
                                        pFsm->MapType(),
                                        pFsm,
                                        sock
                                        ));

                            switch (pFsm->GetAction()) {
                            case FSM_ACTION_CONNECT:
                                dwEntryError = ERROR_WINHTTP_CANNOT_CONNECT;
                                break;

                            case FSM_ACTION_SEND:
                            case FSM_ACTION_RECEIVE:
                                INET_ASSERT (! pFsm->IsOnAsyncList());
                            
                                dwEntryError = ERROR_WINHTTP_CONNECTION_ERROR;
                                break;

                            default:

                                INET_ASSERT(FALSE);

                                break;
                            }
                            bComplete = TRUE;
                        } else if (FD_ISSET(sock, &read_fds)
                        || FD_ISSET(sock, &write_fds)) {

                            DEBUG_PRINT(ASYNC,
                                        INFO,
                                        ("%s FSM %#x socket %#x completed\n",
                                        pFsm->MapType(),
                                        pFsm,
                                        sock
                                        ));

                            dwEntryError = ERROR_SUCCESS;
                            bComplete = TRUE;

                            //
                            // BUGBUG - the priority needs to be boosted
                            //

                        }
                    }
                    if (bComplete) 
                    {
                        m_BlockedQueue.Remove((CPriorityListEntry *)pFsm);
                        if (dwEntryError != ERROR_SUCCESS) 
                        {
                            if (pFsm->IsOnAsyncList())
                            {
                                INET_ASSERT( (pFsm->GetAction() == FSM_ACTION_SEND) ||
                                                (pFsm->GetAction() == FSM_ACTION_RECEIVE) );
                                            
                                INET_ASSERT( (dwEntryError == ERROR_WINHTTP_TIMEOUT) ||
                                             (dwEntryError == ERROR_WINHTTP_OPERATION_CANCELLED) );
                                         
                                ((INTERNET_HANDLE_BASE *)pFsm->GetMappedHandleObject())->AbortSocket();
                            
                                //INET_ASSERT (FALSE && "ICASYNC aborting FSM!");
                                pFsm->SetErrorState(dwEntryError);//VENKATKBUG - ?? to do?
                                pFsm->SetOnAsyncList(FALSE);
                                continue;
                            }
                            pFsm->SetErrorState(dwEntryError);
                        } 
                        else 
                        {
                            INET_ASSERT (! (pFsm->IsOnAsyncList()) );
                                        
                            pFsm->SetError(ERROR_SUCCESS);
                            pFsm->SetState(pFsm->GetNextState());
                        }
                        pFsm->SetPriority(lPriority);

//dprintf("%s FSM %#x socket %#x signalled, time on queue = %d\n", pFsm->MapType(), pFsm, pFsm->GetSocket(), pFsm->StopTimer());
                        //
                        // no longer waiting on this socket handle
                        //

                        pFsm->ResetSocket();

                        //
                        // BUGBUG - if the next operation will complete quickly
                        //          (FSM_HINT_QUICK) then we should run it here
                        //          instead of queuing to another thread
                        //

                        pFsm->QueueWorkItem();
                    } 
                    else 
                    {
                        pPrev = pEntry;
                    }
                }//loop: for (pEntry = m_BlockedQueue.Head();pEntry != m_BlockedQueue.Self();pEntry = ((CPriorityListEntry *)pPrev)->Next()) 
                m_BlockedQueue.Release();
            }// if (m_BlockedQueue.Acquire())
            else
            {
                error = ERROR_NOT_ENOUGH_MEMORY;
            }
        } 
        else // if! n >= 0
        {
            error = _I_WSAGetLastError();

            DEBUG_PRINT(ASYNC,
                        ERROR,
                        ("select() returns %d (%s)\n",
                        error,
                        InternetMapError(error)
                        ));

            //
            // WSAENOTSOCK can happen if the socket was cancelled just
            // before we waited on it. We can also get WSAEINTR if
            // select() is terminated early (by APC)
            //

            INET_ASSERT((error == WSAENOTSOCK) || (error == WSAEINTR) || (error == WSAEBADF));

            if (error == WSAEINTR) {
                continue;
            }

            //
            // when running on a portable (& probably desktops also), if we
            // suspend & resume, the select socket can be invalidated. We
            // need to recognize this situation and handle it
            //

            FD_ZERO(&read_fds);
            FD_ZERO(&write_fds);
            FD_ZERO(&except_fds);

            FD_SET(m_SelectSocket, &read_fds);

            to.tv_sec = 0;
            to.tv_usec = 0;
            n = _I_select(1, &read_fds, &write_fds, &except_fds, &to);
            if (n < 0) {

                //
                // the select socket is dead. Throw it away & create a new
                // one. We should pick up any blocked requests that tried
                // unsuccessfully to interrupt the old select socket
                //

                RecreateSelectSocket();
            } else {

                //
                // some socket(s) other than the select socket has become
                // invalid. Cancel the corresponding request(s)
                //
            }
        } // if! n >= 0

        //
        // perform timed events
        //
        // BUGBUG - need variable for 5000
        //

        if ((GetTickCountWrap() - ticks) >= 5000) {
            if( bLazy == TRUE && !InDllCleanup && !IsTerminating())
            {
#ifndef WININET_SERVER_CORE
                //
                // wake background task mgr
                // this may involve one of the background workitem
                // to be queued and get executed
                //
                NotifyBackgroundTaskMgr();
#endif
            }
#ifndef WININET_SERVER_CORE //now per-session
            PurgeServerInfoList(FALSE);
#endif
            ticks = GetTickCountWrap();
        }
    }
    //REDUNDANT: TerminateAsyncSupport();

    DEBUG_LEAVE(error);
//dprintf("!!! Waiter FSM is done\n");
    return error;
}


DWORD
ICAsyncThread::CreateSelectSocket(
    VOID
    )

/*++

Routine Description:

    In order to not have to keep inefficiently polling select() with a short
    time-out, we create a 'trick' datagram socket that we can use to interrupt
    select() with: this is a local socket, and if we send something to ourself
    then select() will complete (assuming one of the sockets we are waiting on
    is the one we create here)

    N.B. Sockets support must be initialized by the time we get here

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - mapped socket error

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "ICAsyncThread::CreateSelectSocket",
                 NULL
                 ));

    INET_ASSERT(m_SelectSocket == INVALID_SOCKET);

    DWORD error;
    SOCKET sock;

    sock = _I_socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if (sock == INVALID_SOCKET) {

        DEBUG_PRINT(ASYNC,
                    ERROR,
                    ("socket() failed\n"
                    ));

        goto socket_error;
    }

    SOCKADDR_IN sockAddr;

    sockAddr.sin_family = AF_INET;
    sockAddr.sin_port = 0;
    *(LPDWORD)&sockAddr.sin_addr = _I_htonl(INADDR_LOOPBACK);
    memset(&sockAddr.sin_zero, 0, sizeof(sockAddr.sin_zero));

    int rc;

    DEBUG_PRINT(ASYNC,
                INFO,
                ("binding socket %#x to address %d.%d.%d.%d\n",
                sock,
                ((LPBYTE)&sockAddr.sin_addr)[0] & 0xff,
                ((LPBYTE)&sockAddr.sin_addr)[1] & 0xff,
                ((LPBYTE)&sockAddr.sin_addr)[2] & 0xff,
                ((LPBYTE)&sockAddr.sin_addr)[3] & 0xff
                ));

    rc = _I_bind(sock, (LPSOCKADDR)&sockAddr, sizeof(sockAddr));
    if (rc == SOCKET_ERROR) {

        DEBUG_PRINT(ASYNC,
                    ERROR,
                    ("bind() failed\n"
                    ));

        goto socket_error;
    }

    int namelen;
    SOCKADDR sockname;
    namelen = sizeof(sockname);

    rc = _I_getsockname(sock, &sockname, &namelen);
    if (rc == SOCKET_ERROR) {

        DEBUG_PRINT(ASYNC,
                    ERROR,
                    ("getsockname() failed\n"
                    ));

        goto socket_error;
    }

    DEBUG_PRINT(ASYNC,
                INFO,
                ("connecting to address %d.%d.%d.%d\n",
                ((LPBYTE)&sockname.sa_data)[2] & 0xff,
                ((LPBYTE)&sockname.sa_data)[3] & 0xff,
                ((LPBYTE)&sockname.sa_data)[4] & 0xff,
                ((LPBYTE)&sockname.sa_data)[5] & 0xff
                ));

    rc = _I_connect(sock, &sockname, namelen);
    if (rc == SOCKET_ERROR) {

        DEBUG_PRINT(ASYNC,
                    ERROR,
                    ("connect() failed\n"
                    ));

        goto socket_error;
    }

    m_SelectSocket = sock;
    error = ERROR_SUCCESS;

quit:

    DEBUG_LEAVE(error);

    return error;

socket_error:

    error = MapInternetError(_I_WSAGetLastError());
    DestroySelectSocket();
    goto quit;
}


VOID
ICAsyncThread::DestroySelectSocket(
    VOID
    )

/*++

Routine Description:

    Just closes SelectSocket (if we think its open)

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 None,
                 "ICAsyncThread::DestroySelectSocket",
                 NULL
                 ));

    if (m_SelectSocket != INVALID_SOCKET) {
        _I_closesocket(m_SelectSocket);
        m_SelectSocket = INVALID_SOCKET;
    }

    DEBUG_LEAVE(0);
}


VOID
ICAsyncThread::RecreateSelectSocket(
    VOID
    )

/*++

Routine Description:

    Attempt to destroy & recreate select socket. Required when socket is killed
    due to suspend, e.g.

    Since the underlying net components may take a while to restart, we loop up
    to 12 times, waiting up to ~16 secs (~32 secs cumulative)

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 None,
                 "ICAsyncThread::RecreateSelectSocket",
                 NULL
                 ));

    DestroySelectSocket();

    DEBUG_PRINT(ASYNC,
                INFO,
                ("current interrupt count = %d\n",
                m_lSelectInterrupts
                ));

    m_lSelectInterrupts = -1;

    int iterations = 12;
    DWORD time = 8;
    DWORD error;

    do {
        error = CreateSelectSocket();
        if (error != ERROR_SUCCESS) {
            PERF_Sleep(time);
            time <<= 1;
        }
    } while ((error != ERROR_SUCCESS) && --iterations);

    DEBUG_LEAVE(0);
}


VOID
ICAsyncThread::InterruptSelect(
    VOID
    )

/*++

Routine Description:

    We interrupt a waiting select() by sending a small amount of data to ourself
    on the 'trick datagram socket'

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 None,
                 "ICAsyncThread::InterruptSelect",
                 NULL
                 ));

    //
    // if the async select socket is already created then interrupt it. If it is
    // not yet created then it probably means that the async scheduler thread
    // hasn't gotten around to it yet, ipso facto the async scheduler can't be
    // stuck in a select(), hence its okay to skip
    //

    if (m_SelectSocket != INVALID_SOCKET) {
        if (InterlockedIncrement(&m_lSelectInterrupts) == 0) {
            if (_I_send != NULL) {
#if INET_DEBUG
                int nSent =
#endif
                _I_send(m_SelectSocket, gszBang, 1, 0);

#if INET_DEBUG
                if (nSent < 0) {

                    DWORD error = _I_WSAGetLastError();

                    DEBUG_PRINT(ASYNC,
                                INFO,
                                ("send(%#x) returns %s (%d)\n",
                                m_SelectSocket,
                                InternetMapError(error),
                                error
                                ));

                }

                INET_ASSERT(!InDllCleanup ? (nSent == 1) : TRUE);
#endif
            }
        } else {
            InterlockedDecrement(&m_lSelectInterrupts);

            DEBUG_PRINT(ASYNC,
                        INFO,
                        ("select() already interrupted, count = %d\n",
                        m_lSelectInterrupts
                        ));

        }
    } else {

        DEBUG_PRINT(ASYNC,
                    WARNING,
                    ("select socket not yet created\n"
                    ));

    }

    DEBUG_LEAVE(0);
}


BOOL
ICAsyncThread::DrainSelectSocket(
    VOID
    )

/*++

Routine Description:

    Just reads the data written to the async select socket in order to wake up
    select()

Arguments:

    None.

Return Value:

    BOOL
        TRUE    - successfully drained

        FALSE   - error occurred

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Bool,
                 "ICAsyncThread::DrainSelectSocket",
                 NULL
                 ));

    BOOL bSuccess = TRUE;

    if (m_SelectSocket != INVALID_SOCKET) {

        //
        // reduce the interrupt count. Threads making async requests will cause
        // the select() to be interrupted again
        //

        InterlockedDecrement(&m_lSelectInterrupts);

        char buf[32];
        int nReceived;

        nReceived = _I_recv(m_SelectSocket, buf, sizeof(buf), 0);

#ifdef unix
        if(nReceived > -1)
        {
#endif /* unix */

        //INET_ASSERT(nReceived == 1);
        //INET_ASSERT(buf[0] == '!');

#ifdef unix
        }
#endif /* unix */

        if (nReceived < 0) {

            DWORD error = _I_WSAGetLastError();

            INET_ASSERT(error != ERROR_SUCCESS);

            DEBUG_PRINT(ASYNC,
                        ERROR,
                        ("recv() returns %s [%d]\n",
                        InternetMapError(error),
                        error
                        ));

            bSuccess = FALSE;
        }
    } else {

        DEBUG_PRINT(ASYNC,
                    INFO,
                    ("m_SelectSocket == INVALID_SOCKET\n"
                    ));

        bSuccess = FALSE;
    }

    DEBUG_LEAVE(bSuccess);

    return bSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\common\icstring.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    icstring.hxx

Abstract:

    Contains ICSTRING class methods. Split from ICSTRING.HXX (inline methods)

    Contents:
        ICSTRING::ICSTRING(ICSTRING&)
        ICSTRING::~ICSTRING()
        ICSTRING::operator=(LPSTR)
        ICSTRING::operator=(ICSTRING&)
        ICSTRING::operator+=(LPSTR)
        ICSTRING::operator+=(char)
        ICSTRING::strncat(LPVOID, DWORD)
        ICSTRING::CreateStringBuffer(LPVOID, DWORD, DWORD)
        ICSTRING::CreateOffsetString(DWORD, DWORD)
        ICSTRING::CopyTo(LPSTR)
        ICSTRING::CopyTo(LPSTR, LPSTR)
        ICSTRING::CopyTo(LPSTR, DWORD)
        ICSTRING::CopyTo(LPSTR, LPDWORD)

Author:

    Richard L Firth (rfirth) 18-Dec-1995

Revision History:

    18-Dec-1995 rfirth
        Created

--*/

#include <wininetp.h>

//
// methods
//

//
//ICSTRING::ICSTRING(
//    IN ICSTRING& String
//    )
//
///*++
//
//Routine Description:
//
//    copy constructor. We now create an entirely new string (used to be just a
//    reference of the rvalue)
//
//Arguments:
//
//    String  - to copy
//
//Return Value:
//
//    None.
//
//--*/
//
//{
//    //
//    // can't already have string in lvalue, & rvalue mustn't be an offset string
//    //
//
//    INET_ASSERT(!HaveString());
//    INET_ASSERT(!String.IsOffset());
//    INET_ASSERT(!String.IsError());
//
//    *this = String.StringAddress();
//}


ICSTRING::~ICSTRING(
    VOID
    )

/*++

Routine Description:

    destructor

Arguments:

    None.

Return Value:

    None.

--*/

{
    //
    // can only free the string if it is not a reference. Offset type
    // implies reference
    //

    if (!IsReference() && (_String != NULL)) {

        INET_ASSERT(!IsOffset());

        (VOID)ResizeBuffer((HLOCAL)_String, 0, FALSE);
    }
}


ICSTRING&
ICSTRING::operator=(
    IN LPSTR String
    )

/*++

Routine Description:

    Copy/assigment. Copies a string to this object. If NULL, frees up the
    current buffer

Arguments:

    String  - to be assigned

Return Value:

    ICSTRING&

--*/

{
    //
    // if this is an offset string then there's not much to do
    //

    if (IsOffset()) {
        Initialize();
        return *this;
    }

    //
    // string MUST NOT be a copy (we'll free the real string pointer, owned
    // by another object) and SHOULD NOT be copied itself (the objects with
    // copies of the string will potentially have a bad pointer)
    //

    INET_ASSERT((String == NULL) ? TRUE : !IsReference());
    INET_ASSERT(!IsReferenced());

    //
    // if the pointer is NULL or the string is empty then we are freeing the
    // string pointer
    //

    DWORD len;

    if (String == NULL) {
        len = 0;
    } else {
        len = ::strlen(String);
        if (len != 0) {
            INET_ASSERT(len < 0xffffffff);
            ++len;
        }
    }

    //
    // free or grow the buffer, depending on requirements
    //

    if ((len > _BufferLength) || ((len == 0) && (_String != NULL))) {
        _String = (LPSTR)ResizeBuffer((HLOCAL)_String, len, FALSE);
        _BufferLength = (_String != NULL) ? len : 0;
    }
    if (_String != NULL) {

        INET_ASSERT(len != 0);

        memcpy((LPVOID)_String, (LPVOID)String, len);
        _StringLength = len - 1;
        SetHaveString(TRUE);
        SetError(FALSE);
    } else {
        _StringLength = 0;
        SetHaveString(FALSE);
        SetError(len != 0); // an error might have occurred
    }
    return *this;
}


ICSTRING&
ICSTRING::operator=(
    IN ICSTRING& String
    )

/*++

Routine Description:

    Copy/assignment. Makes new copy of object (used to just make a reference)

Arguments:

    String  - ICSTRING object to be assigned

Return Value:

    ICSTRING&

--*/

{
    INET_ASSERT(!IsReferenced());
    INET_ASSERT(!String.IsReferenced());
    INET_ASSERT(!String.IsError());

    //
    // if we're copying an offset, make sure that any string we may already
    // have is freed
    //

    if (String.IsOffset()) {
        if (_String != NULL) {
            ResizeBuffer(_String, 0, FALSE);
        }
        _String = String._String;
        _StringLength = String._StringLength;
        _BufferLength = String._BufferLength;
        _Union.Dword = String._Union.Dword;
    } else {

        INET_ASSERT(!IsOffset() && !String.IsOffset());

        //
        // use string assignment to correctly setup this object
        //

        *this = String.StringAddress();
    }
    return *this;
}


VOID
ICSTRING::operator+=(
    IN LPSTR String
    )

/*++

Routine Description:

    Concatenates a string to the buffer. Reallocates it if necessary. String
    CANNOT be NULL

Arguments:

    String  - to concatenate

Return Value:

    None.

--*/

{
    INET_ASSERT(!IsReference());
    INET_ASSERT(!IsReferenced());
    INET_ASSERT(!IsOffset());
    INET_ASSERT(String != NULL);

    if (IsError()) {
        return;
    }

    if (*String == '\0') {
        return;
    }

    DWORD len = ::strlen(String);
    DWORD newlen = _StringLength + len + 1;

    INET_ASSERT ((newlen > _StringLength) && (newlen > len));

    if (_BufferLength < newlen) {
        _String = (LPSTR)ResizeBuffer((HLOCAL)_String, newlen, FALSE);

        INET_ASSERT((_String == NULL) ? (newlen == 0) : TRUE);

        _BufferLength = newlen;
    }
    if (_String != NULL) {
        memcpy((LPVOID)((LPBYTE)_String + _StringLength),
               (LPVOID)String,
               len + 1
               );
        _StringLength += len;
    } else {
        _StringLength = 0;
        _BufferLength = 0;
        SetError(TRUE);
    }
}


VOID
ICSTRING::operator+=(
    IN char Ch
    )

/*++

Routine Description:

    Concatenates a character to the buffer. Reallocates it if necessary. Ch
    CAN be '\0'

Arguments:

    Ch  - to concatenate

Return Value:

    None.

--*/

{
    INET_ASSERT(!IsReference());
    INET_ASSERT(!IsReferenced());
    INET_ASSERT(!IsOffset());

    if (IsError()) {
        return;
    }

    DWORD newlen = _StringLength + 2;

    INET_ASSERT (newlen > _StringLength);
    
    if (_BufferLength < newlen) {
        _String = (LPSTR)ResizeBuffer((HLOCAL)_String, newlen, FALSE);

        INET_ASSERT((_String == NULL) ? (newlen == 0) : TRUE);

        _BufferLength = newlen;
    }
    if (_String != NULL) {
        _String[_StringLength] = Ch;
        ++_StringLength;
        _String[_StringLength] = '\0';
    } else {
        _StringLength = 0;
        _BufferLength = 0;
        SetError(TRUE);
    }
}


VOID
ICSTRING::Strncat(
    IN LPVOID Pointer,
    IN DWORD Length
    )

/*++

Routine Description:

    Copies Length characters from Pointer to the end of _String

Arguments:

    Pointer - place to copy from

    Length  - number of characters to copy

Return Value:

    None.

--*/

{
    if (IsError()) {
        return;
    }

    INET_ASSERT(Pointer != NULL);
    INET_ASSERT(Length != 0);
    INET_ASSERT(_String != NULL);
    INET_ASSERT(!IsReference());
    INET_ASSERT(!IsReferenced());

    DWORD newLength;

    newLength = _StringLength + Length + 1;

    INET_ASSERT ((newLength > _StringLength) && (newLength > Length));
    
    if (_BufferLength < newLength) {
        _String = (LPSTR)ResizeBuffer((HLOCAL)_String, newLength, FALSE);
        _BufferLength = newLength;
    }
    if (_String != NULL) {
        memcpy((LPVOID)&_String[_StringLength], Pointer, Length);
        _StringLength += Length;

        INET_ASSERT(_StringLength < _BufferLength);

        _String[_StringLength] = '\0';
    } else {
        _StringLength = 0;
        _BufferLength = 0;
        SetError(TRUE);
    }
}


VOID
ICSTRING::CreateStringBuffer(
    IN LPVOID Pointer,
    IN DWORD StringLength,
    IN DWORD BufferLength
    )

/*++

Routine Description:

    In order to avoid reallocations, if we know the size of the buffer we
    want for several strcat()'s, e.g., we can allocate it once, copy the
    initial string here, then perform multiple concatenate operations (+=)

Arguments:

    Pointer         - place to start copying from

    StringLength    - length of string

    BufferLength    - length of buffer required

Return Value:

    None.

--*/

{
    INET_ASSERT(Pointer != NULL);
    INET_ASSERT(BufferLength > StringLength);
    INET_ASSERT(BufferLength != 0);

    //
    // if we currently have an offset string then initialize to a non-offset
    //

    if (IsOffset()) {
        Initialize();
    }
    _String = (LPSTR)ResizeBuffer(_String, BufferLength, FALSE);
    if (_String != NULL) {
        _StringLength = StringLength;
        _BufferLength = BufferLength;
        memcpy((LPVOID)_String, Pointer, _StringLength);
        _String[_StringLength] = '\0';
        SetHaveString(TRUE);
        SetReference(FALSE);
        SetReferenced(FALSE);
        SetOffset(FALSE);
        SetError(FALSE);
    } else {
        SetError(TRUE);
    }
}


VOID
ICSTRING::CreateOffsetString(
    IN DWORD Offset,
    IN DWORD Length
    )

/*++

Routine Description:

    Create a reference ICSTRING that is an offset within another buffer

Arguments:

    Offset  - offset into buffer

    Length  - of string

Return Value:

    None.

--*/

{
    _String = (LPSTR)(DWORD_PTR)Offset;
    _StringLength = Length;
    _BufferLength = Length;
    ZapFlags();
    SetHaveString(TRUE);    // ICSTRING initialized with non-NULL
    SetReference(TRUE);     // reference to another string buffer
    SetOffset(TRUE);        // offset from base
    SetError(FALSE);
}


VOID
ICSTRING::CopyTo(
    IN LPSTR Buffer
    )

/*++

Routine Description:

    Copies source _String to destination Buffer

Arguments:

    Buffer  - place to copy to

Return Value:

    None.

--*/

{
    INET_ASSERT(Buffer != NULL);
    INET_ASSERT(!IsOffset());

    memcpy((LPVOID)Buffer, (LPVOID)_String, _StringLength);
    Buffer[_StringLength] = '\0';
}


VOID
ICSTRING::CopyTo(
    IN LPSTR Base,
    IN LPSTR Buffer
    )

/*++

Routine Description:

    Copies a based (offset) string from source Base + _String to destination
    Buffer

Arguments:

    Base    - value for base

    Buffer  - place to write string

Return Value:

    None.

--*/

{
    INET_ASSERT(Buffer != NULL);
    //INET_ASSERT(IsOffset() ? (Base != NULL) : (Base == NULL));

    memcpy((LPVOID)Buffer,
           IsOffset() ? (Base + (DWORD_PTR)_String) : _String,
           _StringLength
           );
    Buffer[_StringLength] = '\0';
}


VOID
ICSTRING::CopyTo(
    IN LPSTR Buffer,
    IN DWORD Length
    )

/*++

Routine Description:

    Copies at most Length characters from source _String to destination
    Buffer

Arguments:

    Buffer  - place to write string

    Length  - number of characters to copy

Return Value:

    None.

--*/

{
    INET_ASSERT(Buffer != NULL);
    INET_ASSERT(!IsOffset());

    DWORD length = min(Length - 1, _StringLength);

    memcpy((LPVOID)Buffer, (LPVOID)_String, length);
    Buffer[length] = '\0';
}


VOID
ICSTRING::CopyTo(
    IN LPSTR Buffer,
    IN OUT LPDWORD Length
    )

/*++

Routine Description:

    Copies at most *Length characters from source _String to destination
    Buffer. Updates *Length to be number of characters copied, not including
    terminating NUL

Arguments:

    Buffer  - place to write string

    Length  - IN: length of buffer
              OUT: number of characters copied

Return Value:

    None.

--*/

{
    INET_ASSERT(Buffer != NULL);
    INET_ASSERT(!IsOffset());

    DWORD length = min(*Length - 1, _StringLength);

    memcpy((LPVOID)Buffer, (LPVOID)_String, length);
    Buffer[length] = '\0';
    *Length = length;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\common\icsocket.cxx ===
/*++

Copyright (c) 1995-1997 Microsoft Corporation

Module Name:

    icsocket.cxx

Abstract:

    Contains sockets functions and ICSocket methods

    Contents:
        ContainingICSocket
        MapNetAddressToName
        ICSocket::ICSocket
        ICSocket::~ICSocket
        ICSocket::Destroy
        ICSocket::Reference
        ICSocket::Dereference
        ICSocket::EnableSocks
        ICSocket::Connect
        CFsm_SocketConnect::RunSM
        ICSocket::Connect_Start
        ICSocket::Connect_Continue
        ICSocket::Connect_Error
        ICSocket::Connect_Finish
        ICSocket::SocksConnect
        ICSocket::Disconnect
        ICSocket::Close
        ICSocket::Abort
        ICSocket::Shutdown
        ICSocket::IsReset
        ICSocket::SetTimeout
        ICSocket::SetLinger
        ICSocket::SetNonBlockingMode
        ICSocket::GetBufferLength(SOCKET_BUFFER_ID)
        ICSocket::GetBufferLength(SOCKET_BUFFER_ID, LPDWORD)
        ICSocket::SetBufferLength
        ICSocket::SetSendCoalescing
        SetSourcePort
        ICSocket::Send
        CFsm_SocketSend::RunSM
        ICSocket::Send_Start
        ICSocket::SendTo
        ICSocket::Receive
        CFsm_SocketReceive::RunSM
        ICSocket::Receive_Start
        ICSocket::Receive_Continue
        ICSocket::AllocateQueryBuffer
        //ICSocket::FreeQueryBuffer
        //ICSocket::ReceiveFrom
        ICSocket::DataAvailable
        //ICSocket::DataAvailable2
        ICSocket::WaitForReceive
        //ICSocket::GetBytesAvailable
        ICSocket::CreateSocket
        ICSocket::GetSockName
        ICSocket::Listen
        ICSocket::DirectConnect
        ICSocket::SelectAccept

Author:

    Richard L Firth (rfirth) 08-Apr-1997

Environment:

    Win32 user mode

Revision History:

    08-Apr-1997 rfirth
        Created from ixport.cxx

--*/

#include <wininetp.h>
#include <perfdiag.hxx>

//
// private prototypes
//

//
// functions
//

#if INET_DEBUG

PRIVATE LPSTR MapFamily(int family) {
    switch (family) {
    case AF_UNSPEC:     return "AF_UNSPEC";
    case AF_UNIX:       return "AF_UNIX";
    case AF_INET:       return "AF_INET";
    case AF_IMPLINK:    return "AF_IMPLINK";
    case AF_PUP:        return "AF_PUP";
    case AF_CHAOS:      return "AF_CHAOS";
    case AF_IPX:        return "AF_IPX";
    case AF_OSI:        return "AF_OSI";
    case AF_ECMA:       return "AF_ECMA";
    case AF_DATAKIT:    return "AF_DATAKIT";
    case AF_CCITT:      return "AF_CCITT";
    case AF_SNA:        return "AF_SNA";
    case AF_DECnet:     return "AF_DECnet";
    case AF_DLI:        return "AF_DLI";
    case AF_LAT:        return "AF_LAT";
    case AF_HYLINK:     return "AF_HYLINK";
    case AF_APPLETALK:  return "AF_APPLETALK";
    case AF_NETBIOS:    return "AF_NETBIOS";
#if defined(AF_VOICEVIEW)
    case AF_VOICEVIEW:  return "AF_VOICEVIEW";
#endif /* AF_VOICEVIEW */
#if defined(AF_FIREFOX)
    case AF_FIREFOX:    return "AF_FIREFOX";
#endif /* AF_FIREFOX */
#if defined(AF_UNKNOWN1)
    case AF_UNKNOWN1:   return "AF_UNKNOWN1";
#endif /* AF_UNKNOWN1 */
#if defined(AF_BAN)
    case AF_BAN:        return "AF_BAN";
#endif /* AF_BAN */
    }
    return "?";
}

PRIVATE LPSTR MapSock(int sock) {
    switch (sock) {
    case SOCK_STREAM:       return "SOCK_STREAM";
    case SOCK_DGRAM:        return "SOCK_DGRAM";
    case SOCK_RAW:          return "SOCK_RAW";
    case SOCK_RDM:          return "SOCK_RDM";
    case SOCK_SEQPACKET:    return "SOCK_SEQPACKET";
    }
    return "?";
}

PRIVATE LPSTR MapProto(int proto) {
    switch (proto) {
    case IPPROTO_IP:    return "IPPROTO_IP";
    case IPPROTO_ICMP:  return "IPPROTO_ICMP";
    case IPPROTO_IGMP:  return "IPPROTO_IGMP";
    case IPPROTO_GGP:   return "IPPROTO_GGP";
    case IPPROTO_TCP:   return "IPPROTO_TCP";
    case IPPROTO_PUP:   return "IPPROTO_PUP";
    case IPPROTO_UDP:   return "IPPROTO_UDP";
    case IPPROTO_IDP:   return "IPPROTO_IDP";
    case IPPROTO_ND:    return "IPPROTO_ND";
    }
    return "?";
}

#endif // INET_DEBUG



ICSocket *
ContainingICSocket(
    LPVOID lpAddress
    )

/*++

Routine Description:

    Returns address of start of ICSocket (i.e. vtable) given address of list

Arguments:

    lpAddress   - address of m_List part of ICSocket

Return Value:

    ICSocket *  - address of start of ICSocket object (also ICSecureSocket)

--*/

{
    return CONTAINING_RECORD(lpAddress, ICSocket, m_List);
}

//
// ICSocket methods
//


ICSocket::ICSocket(
    VOID
    )

/*++

Routine Description:

    ICSocket constructor

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "ICSocket::ICSocket",
                 "{%#x}",
                 this
                 ));

    SIGN_ICSOCKET();

    m_List.Flink = NULL;
    m_List.Blink = NULL;
    m_dwTimeout = 0;
    m_fTimeoutWraps = 0;
    m_Socket = INVALID_SOCKET;
    m_dwFlags = 0;
    m_bAborted = FALSE;
    m_SocksAddress = 0;
    m_SocksPort = 0;
    m_ReferenceCount = 1;
    _pCurrentFsm = NULL;

    _lpWrapOverlappedSend = NULL;
    _lpWrapOverlappedRecv = NULL;

    DEBUG_LEAVE(0);
}


ICSocket::~ICSocket()

/*++

Routine Description:

    ICSocket destructor. Virtual function

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "ICSocket::~ICSocket",
                 "{%#x [sock=%#x, port=%d, ref=%d]}",
                 this,
                 GetSocket(),
                 GetSourcePort(),
                 ReferenceCount()
                 ));

    CHECK_ICSOCKET();

    INET_ASSERT(!IsOnList());
    INET_ASSERT(m_ReferenceCount == 0);

    if (IsOpen()) {
        SetLinger(FALSE, 0);
        Shutdown(SD_BOTH);
        Close();
    }

    if (_lpWrapOverlappedSend)
        _lpWrapOverlappedSend->Dereference();

    if (_lpWrapOverlappedRecv)
        _lpWrapOverlappedRecv->Dereference();
        
    DEBUG_LEAVE(0);
}


VOID
ICSocket::Destroy(
    VOID
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "ICSocket::Destroy",
                 "{%#x [%#x/%d]}",
                 this,
                 GetSocket(),
                 GetSourcePort()
                 ));

    INET_ASSERT(ReferenceCount() == 1);

    m_ReferenceCount = 0;
    delete this;

    DEBUG_LEAVE(0);
}


VOID
ICSocket::Reference(
    VOID
    )

/*++

Routine Description:

    Just increases the reference count

Arguments:

    None.

Return Value:

    None.

--*/

{
    CHECK_ICSOCKET();

    InterlockedIncrement(&m_ReferenceCount);
}


BOOL
ICSocket::Dereference(
    VOID
    )

/*++

Routine Description:

    Reduces the reference count. If it goes to zero, the object is deleted

Arguments:

    None.

Return Value:

    BOOL
        TRUE    - object deleted

        FALSE   - object still alive

--*/

{
    CHECK_ICSOCKET();

    if (InterlockedDecrement(&m_ReferenceCount) == 0) {

        INET_ASSERT(m_ReferenceCount == 0);

        delete this;
        return TRUE;
    }
    return FALSE;
}


PRIVATE
DWORD
ICSocket::EnableSocks(
    IN LPSTR lpSocksHost,
    IN INTERNET_PORT ipSocksPort
    )

/*++

Routine Description:

    Set SOCKS gateway IP address and port in this socket object

Arguments:

    lpSocksHost - IP address or host name of SOCKS host

    ipSocksPort - port address of SOCKS host

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_WINHTTP_NAME_NOT_RESOLVED
                    failed to resolve SOCKS host name

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::EnableSocks",
                 "{%#x/%d} %q, %d",
                 GetSocket(),
                 GetSourcePort(),
                 lpSocksHost,
                 ipSocksPort
                 ));

    DWORD error = ERROR_SUCCESS;

    m_SocksPort = ipSocksPort;
    m_SocksAddress = _I_inet_addr(lpSocksHost);
    if (m_SocksAddress == INADDR_NONE) {    // 0xffffffff

        LPHOSTENT lpHostent = _I_gethostbyname(lpSocksHost);

        if (lpHostent != NULL) {
            m_SocksAddress = **(LPDWORD*)&lpHostent->h_addr_list[0];
        } else {
            m_SocksAddress = 0;
            error = ERROR_WINHTTP_NAME_NOT_RESOLVED;
        }
    }

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("SOCKS address = %d.%d.%d.%d:%d\n",
                ((BYTE*)&m_SocksAddress)[0] & 0xff,
                ((BYTE*)&m_SocksAddress)[1] & 0xff,
                ((BYTE*)&m_SocksAddress)[2] & 0xff,
                ((BYTE*)&m_SocksAddress)[3] & 0xff,
                m_SocksPort
                ));

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::SocketConnect(
    IN LONG Timeout,
    IN INT Retries,
    IN DWORD dwFlags,
    IN CServerInfo *pServerInfo
    )

/*++

Routine Description:

    Initiate connection with server

Arguments:

    Timeout - maximum amount of time (mSec) to wait for connection

    Retries - maximum number of attempts to connect

    dwFlags - flags controlling request

    pServerInfo - Server Info to connect with

Return Value:

    DWORD
        Success - ERROR_SUCCESS

                  ERROR_IO_PENDING
                    Operation will complete asynchronously

        Failure - ERROR_NOT_ENOUGH_MEMORY
                    Couldn't create FSM

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::SocketConnect",
                 "{%#x [%#x]} %d, %d, %#x, %x",
                 this,
                 m_Socket,
                 Timeout,
                 Retries,
                 dwFlags,
                 pServerInfo
                 ));


    DWORD error;

    CFsm_SocketConnect * pFsm;

    pFsm = New CFsm_SocketConnect(Timeout, Retries, dwFlags, this);

    if ( pFsm )
    {
        pFsm->SetServerInfo(pServerInfo);
    }

    error = DoFsm(pFsm);

    DEBUG_LEAVE(error);

    return error;
}



DWORD
ICSocket::Connect(
    IN LONG Timeout,
    IN INT Retries,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Initiate connection with server

Arguments:

    Timeout - maximum amount of time (mSec) to wait for connection

    Retries - maximum number of attempts to connect

    dwFlags - flags controlling request

Return Value:

    DWORD
        Success - ERROR_SUCCESS

                  ERROR_IO_PENDING
                    Operation will complete asynchronously

        Failure - ERROR_NOT_ENOUGH_MEMORY
                    Couldn't create FSM

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::Connect",
                 "{%#x [%#x]} %d, %d, %#x",
                 this,
                 m_Socket,
                 Timeout,
                 Retries,
                 dwFlags
                 ));

#ifdef TEST_CODE
    Timeout *= 20;
    Retries *= 20;
#endif

    DWORD error;

    error = DoFsm(New CFsm_SocketConnect(Timeout, Retries, dwFlags, this));

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_SocketConnect::RunSM(
    IN CFsm * Fsm
    )

/*++

Routine Description:

    Runs next CFsm_SocketConnect state

Arguments:

    Fsm - FSM controlling operation

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CFsm_SocketConnect::RunSM",
                 "%#x",
                 Fsm
                 ));

    ICSocket * pSocket = (ICSocket *)Fsm->GetContext();
    CFsm_SocketConnect * stateMachine = (CFsm_SocketConnect *)Fsm;
    DWORD error;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
        error = pSocket->Connect_Start(stateMachine);
        break;

    case FSM_STATE_CONTINUE:
        error = pSocket->Connect_Continue(stateMachine);
        break;

    case FSM_STATE_ERROR:
        error = pSocket->Connect_Error(stateMachine);
        break;

    default:
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_WINHTTP_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::Connect_Start(
    IN CFsm_SocketConnect * Fsm
    )

/*++

Routine Description:

    Starts a socket connect operation - creates a socket and connects it to a
    server using the address information returned by GetServiceAddress(). There
    may be several addresses to try. We return as soon as we successfully
    generate a connection, or after we have tried <Retries> attempts, or until
    <Timeout> milliseconds have elapsed

Arguments:

    Fsm - socket connect FSM

Return Value:

    DWORD
        Success - ERROR_SUCCESS

                  ERROR_IO_PENDING
                    Operation will complete asynchronously

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::Connect_Start",
                 "{%#x [%#x]}, %#x(%d, %d, %#x)",
                 this,
                 m_Socket,
                 Fsm,
                 Fsm->m_Timeout,
                 Fsm->m_Retries,
                 Fsm->m_dwFlags
                 ));

    PERF_ENTER(Connect_Start);

    CFsm_SocketConnect & fsm = *Fsm;
    LPINTERNET_THREAD_INFO lpThreadInfo = fsm.GetThreadInfo();

    INET_ASSERT(lpThreadInfo != NULL);

    DWORD error = ERROR_SUCCESS;
    int serr = SOCKET_ERROR;

    BOOL fSynchronous = FALSE;

    INET_ASSERT(IsClosed());

    //
    // ensure the next state is CONTINUE. It may be INIT because we could have
    // been looping through bad addresses (if sufficient timeout & retries)
    //

    fsm.SetNextState(FSM_STATE_CONTINUE);

    //
    // get address to use. If exhausted, re-resolve
    //

    if (fsm.GetFunctionState() == FSM_STATE_2) {
        fsm.SetFunctionState(FSM_STATE_1);
        goto resolve_continue;
    }
    if (!fsm.m_pServerInfo->GetNextAddress(&fsm.m_dwResolutionId,
                                           &fsm.m_dwAddressIndex,
                                           GetPort(),
                                           fsm.m_pAddress
                                           )) {
        if (fsm.m_bResolved) {
            error = ERROR_WINHTTP_CANNOT_CONNECT;
        } else {
            fsm.SetFunctionState(FSM_STATE_2);
            fsm.SetNextState(FSM_STATE_INIT);
            fsm.m_dwAddressIndex = -1;
            error = fsm.m_pServerInfo->ResolveHost(&fsm.m_dwResolutionId,
                                                   fsm.m_dwFlags
                                                   );
            if (error == ERROR_IO_PENDING) {
                goto quit;
            }

resolve_continue:

            fsm.m_bResolved = TRUE;
            if (error == ERROR_SUCCESS) {
                if (!fsm.m_pServerInfo->GetNextAddress(&fsm.m_dwResolutionId,
                                                       &fsm.m_dwAddressIndex,
                                                       GetPort(),
                                                       fsm.m_pAddress
                                                       )) {
                    error = ERROR_WINHTTP_CANNOT_CONNECT;
                }
            }
            else if (error == ERROR_WINHTTP_NAME_NOT_RESOLVED)
            {
                fsm.SetNextState(FSM_STATE_CONTINUE);
                goto quit; // exit out NOW with ERROR_WINHTTP_NAME_NOT_RESOLVED, instead of CANNOT_CONNECT
            }
        }
    }
    if (error != ERROR_SUCCESS) {

        //
        // name resolution failed - done
        //

        goto quit;
    }

    //
    // update port for keep-alive info
    //

    SetPort(_I_ntohs(((LPSOCKADDR_IN)fsm.m_pAddress->RemoteAddr.lpSockaddr)->sin_port));

    //
    // BUGBUG - this code was supplying AF_UNSPEC to socket(), which should
    //          be okay, but because of a bug in the Win95 wsipx driver
    //          which manifests itself when we call bind(), we must send in
    //          the address family supplied in the local socket address by
    //          GetAddressByName()
    //

    int protocol;
    DWORD dwConnFlags;

    protocol = fsm.m_pAddress->iProtocol;

    m_Socket = _I_socket(fsm.m_pAddress->LocalAddr.lpSockaddr->sa_family,
                         fsm.m_pAddress->iSocketType,
                         protocol
                         );
    if (m_Socket == INVALID_SOCKET) {

        DEBUG_PRINT(SOCKETS,
                    ERROR,
                    ("failed to create socket\n"
                    ));

        goto check_socket_error;
    }

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("created socket %#x\n",
                m_Socket
                ));

    //
    // inform the app that we are connecting to the server (but only on the
    // first attempt)
    //

    //if ((fsm.m_dwFlags & SF_INDICATE) && (error == ERROR_SUCCESS)) {
    if (fsm.m_dwFlags & SF_INDICATE) {
        error = InternetIndicateStatusAddress(WINHTTP_CALLBACK_STATUS_CONNECTING_TO_SERVER,
                                      fsm.m_pAddress->RemoteAddr.lpSockaddr,
                                      fsm.m_pAddress->RemoteAddr.iSockaddrLength
                                      );
        if (error != ERROR_SUCCESS)
        {
            INET_ASSERT(error = ERROR_WINHTTP_OPERATION_CANCELLED);
            fsm.SetNextState(FSM_STATE_DONE);
            goto quit;
        }   
    }

    //
    // if requested to, put the socket in non-blocking mode
    //

    if (fsm.m_dwFlags & SF_NON_BLOCKING
    && (GlobalRunningNovellClient32 ? GlobalNonBlockingClient32 : TRUE)) {
        error = SetNonBlockingMode(TRUE);
        if (error != ERROR_SUCCESS) {
            fsm.SetErrorState(error);
            goto quit;
        }
    }

    //
    // bind the socket to the local address
    //

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("binding to local address %d.%d.%d.%d, port %d, index %d\n",
                ((LPBYTE)fsm.m_pAddress->LocalAddr.lpSockaddr)[4] & 0xff,
                ((LPBYTE)fsm.m_pAddress->LocalAddr.lpSockaddr)[5] & 0xff,
                ((LPBYTE)fsm.m_pAddress->LocalAddr.lpSockaddr)[6] & 0xff,
                ((LPBYTE)fsm.m_pAddress->LocalAddr.lpSockaddr)[7] & 0xff,
                _I_ntohs(((LPSOCKADDR_IN)fsm.m_pAddress->LocalAddr.lpSockaddr)->sin_port),
                fsm.m_dwAddressIndex
                ));

    serr = _I_bind(m_Socket,
                   fsm.m_pAddress->LocalAddr.lpSockaddr,
                   fsm.m_pAddress->LocalAddr.iSockaddrLength
                   );
    if (serr == SOCKET_ERROR) {

        DEBUG_PRINT(SOCKETS,
                    ERROR,
                    ("failed to bind socket %#x\n",
                    m_Socket
                    ));

        goto check_socket_error;
    }

    //
    // Socket successfully created and bound - now, if async,
    // associate IOCP with this socket.
    //
    if (fsm.m_dwFlags & SF_NON_BLOCKING)
    {
        DEBUG_ENTER((DBG_API,
                         Dword,
                         "***CreateIoCompletionPort",
                         "(m_Socket)%#x, (hcomp)%#x, (icsocket-compkey)%#x, %#x, (app handle)%#x, (fsm)%#x, (mapped handle obj)%#x",
                         m_Socket,
                         g_hCompletionPort,
                         this,
                         0,
                         fsm.GetAppHandle(),
                         fsm,
                         fsm.GetMappedHandleObject()
                         ));
                         
        HANDLE hCompPort = CreateIoCompletionPort(  (HANDLE)m_Socket,
                                                    g_hCompletionPort,
                                                    (ULONG_PTR)this,
                                                    0 );

        DEBUG_LEAVE(hCompPort);
        
        INET_ASSERT (hCompPort == g_hCompletionPort);
        if (!hCompPort)
        {
            error = GetLastError();
            fsm.SetErrorState(error);
            goto quit;
        }
    }  
    //
    // record source port (useful for matching with net sniff)
    //

    SetSourcePort();

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("socket %#x bound to port %d (%#x)\n",
                m_Socket,
                m_SourcePort,
                m_SourcePort
                ));

    //
    // let another thread know the socket to cancel if it wants to kill
    // this operation
    //

    INET_ASSERT(fsm.GetMappedHandleObject() != NULL);

    if (fsm.GetMappedHandleObject() != NULL) {
        fsm.GetMappedHandleObject()->SetAbortHandle(this);
    }

    //
    // try to connect to the next address
    //

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("connecting %#x/%d to remote address %d.%d.%d.%d, port %d, index %d\n",
                m_Socket,
                m_SourcePort,
                ((LPBYTE)fsm.m_pAddress->RemoteAddr.lpSockaddr)[4] & 0xff,
                ((LPBYTE)fsm.m_pAddress->RemoteAddr.lpSockaddr)[5] & 0xff,
                ((LPBYTE)fsm.m_pAddress->RemoteAddr.lpSockaddr)[6] & 0xff,
                ((LPBYTE)fsm.m_pAddress->RemoteAddr.lpSockaddr)[7] & 0xff,
                _I_ntohs(((LPSOCKADDR_IN)fsm.m_pAddress->RemoteAddr.lpSockaddr)->sin_port),
                fsm.m_dwAddressIndex
                ));

    fsm.SetNextState(FSM_STATE_CONTINUE);
    fsm.StartTimer();

#ifdef TEST_CODE
    SetLastError(-1);
    serr = -1;
#else
    //if we are running in blocking mode (ie synchronous case) w/ timeout, unblock for 
    //the connect so we can enforce the timeout.
    if (!(fsm.m_dwFlags & SF_NON_BLOCKING) 
        && (fsm.GetTimeout() != INFINITE)) 
    {
        fSynchronous = TRUE;
        error = SetNonBlockingMode(TRUE);
        if (error != ERROR_SUCCESS) 
        {
            fsm.SetErrorState(error);
            goto quit;
        }
    }
    
    if (IsSocks()) {
        serr = SocksConnect((LPSOCKADDR_IN)fsm.m_pAddress->RemoteAddr.lpSockaddr,
                            fsm.m_pAddress->RemoteAddr.iSockaddrLength
                            );
    } else {
        serr = _I_connect(m_Socket,
                          fsm.m_pAddress->RemoteAddr.lpSockaddr,
                          fsm.m_pAddress->RemoteAddr.iSockaddrLength
                          );
    }
#endif

    //
    // here if a socket operation failed, in which case serr will be SOCKET_ERROR
    //

check_socket_error:

    if (serr == 0) {

        //
        // successful (probably synchronous) connect completion
        //

        //
        // in the sync case, we just call the continue handler. No need to
        // return to the state handler
        //

        Connect_Continue(Fsm);
        goto quit;
    }

    //
    // here if a socket operation failed. We have to read the socket error in
    // this thread before doing anything else or we'll lose the error. We handle
    // it in Connect_Error()
    //

    error = _I_WSAGetLastError();

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("connect(%#x) returns %d\n",
                m_Socket,
                error
                ));

    if (fSynchronous && (error == WSAEWOULDBLOCK))
    {
        int n = 1;
        BOOL bComplete = FALSE;
        
        struct fd_set write_fds;
        struct fd_set except_fds;
        
        FD_ZERO(&write_fds);
        FD_ZERO(&except_fds);
        
        SOCKET sock = m_Socket;

        // connect() & send()

        DEBUG_PRINT(ASYNC,
                    INFO,
                    ("%s FSM %#x WRITE waiting on socket %#x\n",
                    fsm.MapType(),
                    &fsm,
                    sock
                    ));

        FD_SET(sock, &write_fds);
        
        // all sockets are checked for exception
        FD_SET(sock, &except_fds);
        
        LONG timeout = fsm.GetTimeout();
        struct timeval to;
        struct timeval* pto;

        if (timeout != INFINITE)
        {
            to.tv_sec = timeout / 1000;
            to.tv_usec = (timeout % 1000) * 1000;
            pto = &to;
        }
        else
        {
            pto = NULL;
        }
        
        DEBUG_PRINT(ASYNC,
                    INFO,
                    ("waiting %d mSec (%d.%06d) for select(). %d sockets\n",
                    timeout,
                    pto ? to.tv_sec : -1,
                    pto ? to.tv_usec : -1,
                    n
                    ));
                    
        n = PERF_Select(n, NULL, &write_fds, &except_fds, pto);

        DEBUG_PRINT(ASYNC,
                    INFO,
                    ("select() returns %d\n",
                    n
                    ));

        error = ERROR_WINHTTP_CANNOT_CONNECT;

        if (n == 0)
        {
            INET_ASSERT (pto != NULL);
            
            error = ERROR_WINHTTP_TIMEOUT;
        }
        else if (n > 0) 
        {
            if (FD_ISSET(sock, &except_fds)) 
            {
                DEBUG_PRINT(ASYNC,
                            INFO,
                            ("%s FSM %#x socket %#x exception\n",
                            fsm.MapType(),
                            fsm,
                            sock
                            ));                
            } 
            else if (FD_ISSET(sock, &write_fds)) 
            {
                DEBUG_PRINT(ASYNC,
                            INFO,
                            ("%s FSM %#x socket %#x completed\n",
                            fsm.MapType(),
                            fsm,
                            sock
                            ));

                error = ERROR_SUCCESS;
            }
            else
            {
                INET_ASSERT (FALSE);
            }
        } //n >= 0
        else
        {
            error = MapInternetError(_I_WSAGetLastError());
        }
        
        //Now set the socket back to blocking mode.
        //  If we run into an error doing that, then fall out of the connect loop 
        //  Else we'll fall into the Connect_Continue->Connect_Error codepath, which
        //  will also account for count-outs and timeouts.
        DWORD dwError;
        if ((dwError = SetNonBlockingMode(FALSE)) != ERROR_SUCCESS)
        {
            error = MapInternetError(dwError);
            fsm.SetErrorState(error);
            goto quit;
        }

    } //fSynchronous

    //
    // if we are using non-blocking sockets then we need to wait until the
    // connect has completed, or an error occurs.
    // If we got any status other than WSAEWOULDBLOCK then we have to handle
    // the error
    //

    if (IsNonBlocking() && (error == WSAEWOULDBLOCK)) {

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("connect() blocked, socket %#x, port %d\n",
                    m_Socket,
                    m_SourcePort
                    ));

        fsm.SetAction(FSM_ACTION_CONNECT);

        DWORD timeout = GetTimeoutValue(WINHTTP_OPTION_CONNECT_TIMEOUT);
        INTERNET_HANDLE_OBJECT * pObject = fsm.GetMappedHandleObject();
        
#ifndef WININET_SERVER_CORE //no cache
        if (pObject != NULL) {
            if (pObject->IsFromCacheTimeoutSet()
            && (pObject->GetObjectType() == TypeHttpRequestHandle)
            && ((HTTP_REQUEST_HANDLE_OBJECT *)pObject)->CanRetrieveFromCache()) {
                timeout = GetTimeoutValue(WINHTTP_OPTION_FROM_CACHE_TIMEOUT);

                DWORD connectTime = fsm.m_pServerInfo->GetConnectTime();

                if (connectTime == 0) {
                    connectTime = timeout;
                }
                timeout += connectTime;
            }
        }
#endif //no cache

        fsm.SetTimeout(timeout);
        fsm.SetNextState(FSM_STATE_CONTINUE);

        //
        // after we set the state to waiting, and get ERROR_IO_PENDING from
        // QueueSocketWorkItem() then we can no longer touch this FSM until
        // it completes asynchronously
        //

        //
        // perf - test the socket. If this completes quickly we don't take a
        // context switch
        //

        //error = WaitForReceive(0);
        //if (error == ERROR_WINHTTP_TIMEOUT) {
            error = QueueSocketWorkItem(Fsm, m_Socket);
        //}
        if (error == ERROR_SUCCESS) {

            //
            // in the unlikely event the request completed quickly and
            // successfully
            //

            serr = 0;
            goto check_socket_error;
        } else if (error == ERROR_IO_PENDING) {

            //
            // the request is pending. We already set waiting state
            //

            goto quit;
        }

        //
        // if here then QueueSocketWorkItem() returned some other error
        //

    } 
    else
    {

        //
        // some other socket error occurred. Convert to INTERNET error
        //

        //
        // Also okay to be here for successful synchronous connect with timeout.
        //
        if (error)
            fsm.SetErrorState(MapInternetError(error));
        error = Connect_Continue(Fsm);
    }

    fsm.SetErrorState(error);

quit:

    //
    // we are done if not pending AND we will not re-enter this state in order
    // to re-do the name resolution/find another address
    //

    if ((error != ERROR_IO_PENDING) && (fsm.GetNextState() != FSM_STATE_INIT)) 
    {
        fsm.SetDone();

        PERF_LEAVE(Connect_Start);
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::Connect_Continue(
    IN CFsm_SocketConnect * Fsm
    )

/*++

Routine Description:

    Performs common processing after connect completion or failure

Arguments:

    Fsm - reference to socket connect finite state machine

Return Value:

    DWORD
        Success - ERROR_SUCCESS

                  ERROR_IO_PENDING
                    Operation will complete asynchronously

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::Connect_Continue",
                 "{%#x [%#x/%d]}, %#x(%d, %d, %#x)",
                 this,
                 GetSocket(),
                 GetSourcePort(),
                 Fsm,
                 Fsm->m_Timeout,
                 Fsm->m_Retries,
                 Fsm->m_dwFlags
                 ));

    PERF_ENTER(Connect_Continue);

    CFsm_SocketConnect & fsm = *Fsm;
    fsm.StopTimer();

//    INET_ASSERT((fsm.GetMappedHandleObject() != NULL)
//        ? (fsm.GetMappedHandleObject()->GetAbortHandle() != NULL)
//        : TRUE);

    DWORD error = fsm.GetError();

    //INET_ASSERT(error != SOCKET_ERROR);

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("connect() resumed, socket %#x, port %d\n",
                m_Socket,
                m_SourcePort
                ));

    //
    // check for aborted request
    //

    if (IsAborted()) 
    {
        error = ERROR_WINHTTP_OPERATION_CANCELLED;
    }
    
    if (error == ERROR_SUCCESS) {

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("socket %#x/port %d connected; time = %d mSec\n",
                    m_Socket,
                    m_SourcePort,
                    fsm.ReadTimer()
                    ));

        error = Connect_Finish(Fsm);
    } else {

        DEBUG_PRINT(SOCKETS,
                    ERROR,
                    ("failed to connect socket %#x/port %d: error %s\n",
                    m_Socket,
                    m_SourcePort,
                    InternetMapError(error)
                    ));

        fsm.SetError(error);
        error = Connect_Error(Fsm);
    }

    PERF_LEAVE(Connect_Continue);

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::Connect_Error(
    IN CFsm_SocketConnect * Fsm
    )

/*++

Routine Description:

    Called to handle a connect error. Either causes the FSM to terminate or
    prepares the FSM to try another connection

Arguments:

    Fsm - socket connect FSM

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::Connect_Error",
                 "{%#x [%#x/%d]}, %#x(%d, %d, %#x)",
                 this,
                 GetSocket(),
                 GetSourcePort(),
                 Fsm,
                 Fsm->m_Timeout,
                 Fsm->m_Retries,
                 Fsm->m_dwFlags
                 ));

    PERF_ENTER(Connect_Error);

    CFsm_SocketConnect & fsm = *Fsm;

    fsm.StopTimer();

    INTERNET_HANDLE_OBJECT * pObject = fsm.GetMappedHandleObject();

    //
    // no longer performing socket operation - clear abort handle
    //

    INET_ASSERT(pObject != NULL);

    if (pObject != NULL) {
        pObject->ResetAbortHandle();
    }

    DWORD error = fsm.GetError();
    BOOL bRestartable = FALSE;

    //INET_ASSERT(error != SOCKET_ERROR);
    INET_ASSERT(error != ERROR_SUCCESS);

    //
    // check for aborted request - this overrides any socket error
    //

    if (IsAborted() || error == ERROR_WINHTTP_OPERATION_CANCELLED) 
    {
        error = ERROR_WINHTTP_OPERATION_CANCELLED;
    }
    else if (fsm.IsCountedOut()
               || fsm.IsTimedOut()  // entire request timeout
               || (error == ERROR_WINHTTP_TIMEOUT)) 
    {  // just this request t/o

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("counted out or timed out\n"
                    ));
                    
        // VENKATK_BUG verify this:
        // CANNOT_CONNECT takes precedence over TIMEOUT
        //
        if (fsm.IsTimedOut()) 
        {
            error = ERROR_WINHTTP_TIMEOUT;
        } 
        else if (fsm.IsCountedOut()) 
        {
            error = ERROR_WINHTTP_CANNOT_CONNECT;
        }
    } 
    else if (error != ERROR_NOT_ENOUGH_MEMORY)
    {

        //
        // not aborted, timed-out, counted-out, or offline. We can try again
        //

        bRestartable = TRUE;
    }

    //
    // if the socket is open, close it and try the next connection. Invalidate
    // the address we tried
    //

    if (IsOpen()) 
    {
        Close();
    }

    DWORD mappedError = fsm.GetMappedError();

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("mapped error = %d [%s]\n",
                mappedError,
                InternetMapError(mappedError)
                ));

    //
    // don't invalidate address if from-cache-if-net-fail timeout
    //

    BOOL bInvalidate = TRUE;

    if ((pObject != NULL) && pObject->IsFromCacheTimeoutSet()) 
    {
        bInvalidate = FALSE;
    }
    
    if ((mappedError == WSAENETUNREACH)
        || (mappedError == WSAETIMEDOUT)
        || ((error == ERROR_WINHTTP_TIMEOUT) && bInvalidate)
        || (error == ERROR_WINHTTP_CANNOT_CONNECT)
#ifdef TEST_CODE
        || (error == (DWORD)-1)
#endif
        ) 
    {
        fsm.m_pServerInfo->InvalidateAddress(fsm.m_dwResolutionId,
                                             fsm.m_dwAddressIndex
                                             );
    }

    //
    // if the operation was cancelled or we lost connectivity then quit
    //

    if (bRestartable) 
    {
        fsm.SetNextState(FSM_STATE_INIT);
    } 
    else 
    {
        fsm.SetDone(error);

        PERF_LEAVE(Connect_Error);
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::Connect_Finish(
    IN CFsm_SocketConnect * Fsm
    )

/*++

Routine Description:

    Called when the connection has been successfully established

Arguments:

    Fsm - socket connect FSM

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::Connect_Finish",
                 "{%#x [%#x/%d]}, %#x(%d, %d, %#x)",
                 this,
                 GetSocket(),
                 GetSourcePort(),
                 Fsm,
                 Fsm->m_Timeout,
                 Fsm->m_Retries,
                 Fsm->m_dwFlags
                 ));

    PERF_ENTER(Connect_Finish);

    CFsm_SocketConnect & fsm = *Fsm;

    INET_ASSERT(IsOpen());

    //
    // store the average connect time to this server in our CServerInfo
    //

    if (fsm.m_pServerInfo != NULL) {
        fsm.m_pServerInfo->UpdateConnectTime(fsm.ReadTimer());
    }
    if (fsm.m_pOriginServer != NULL) {
        fsm.m_pOriginServer->UpdateConnectTime(fsm.ReadTimer());
    }

#ifdef TEST_CODE
    BOOL optval;
    int optlen = sizeof(optval);
    int serr = _I_getsockopt(GetSocket(),
                             IPPROTO_TCP,
                             TCP_NODELAY,
                             (char FAR *)&optval,
                             &optlen
                             );

    if (serr != 0) {
        DEBUG_PRINT(SOCKETS,
                    ERROR,
                    ("getsockopt(TCP_NODELAY) returns %s (%d)\n",
                    InternetMapError(_I_WSAGetLastError()),
                    _I_WSAGetLastError()
                    ));
    }
#endif

    //
    // no longer performing socket operation - clear abort handle
    //

    INET_ASSERT(fsm.GetMappedHandleObject() != NULL);

    if (fsm.GetMappedHandleObject() != NULL) {
        fsm.GetMappedHandleObject()->ResetAbortHandle();
    }

    //
    // set the send & receive buffer sizes if not -1 (meaning don't change)
    //

    DWORD bufferLength;

    bufferLength = GetBufferLength(ReceiveBuffer);
    if (bufferLength != (DWORD)-1) {
        SetBufferLength(ReceiveBuffer, bufferLength);
    }
    bufferLength = GetBufferLength(SendBuffer);
    if (bufferLength != (DWORD)-1) {
        SetBufferLength(SendBuffer, bufferLength);
    }

    //
    // disable send coalescing
    //

    SetSendCoalescing(FALSE);

    //
    // let the app know we connected to the server successfully
    //

    if (fsm.m_dwFlags & SF_INDICATE) {
        InternetIndicateStatusAddress(WINHTTP_CALLBACK_STATUS_CONNECTED_TO_SERVER,
                                      fsm.m_pAddress->RemoteAddr.lpSockaddr,
                                      fsm.m_pAddress->RemoteAddr.iSockaddrLength
                                      );
    }

    fsm.SetDone();

    PERF_LEAVE(Connect_Finish);

    DEBUG_LEAVE(ERROR_SUCCESS);

    return ERROR_SUCCESS;
}


int
ICSocket::SocksConnect(
    IN LPSOCKADDR_IN pSockaddr,
    IN INT nLen
    )

/*++

Routine Description:

    Connect to remote host via SOCKS proxy. Modified from original. If we are
    here then we are going specifically via a known SOCKS proxy. There is now
    only one Hosts object, containing a single SOCKD socks proxy address and
    user name

    N.B. Irrespective of whether we are non-blocking, this function executes
    in blocking mode (we expect that we are on an intranet and complete quickly)

Arguments:

    pSockaddr   - address of remote host (on other side of SOCKS firewall)

    nLen        - length of *pSockaddr

Return Value:

    int
        Success - 0

        Failure - -1

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Int,
                 "ICSocket::SocksConnect",
                 "{%#x} %#x, %d",
                 GetSocket(),
                 pSockaddr,
                 nLen
                 ));

    //
    // BUGBUG - should check if the socket type is SOCK_STREAM or if we have
    //          already connected this socket. This code was part of original
    //          general purpose solution. We don't need it
    //

    //
    // initialize sockaddr for connecting to SOCKS firewall
    //

    struct sockaddr_in sin;

    sin.sin_family = AF_INET;
    sin.sin_port = _I_htons(m_SocksPort);
    sin.sin_addr.s_addr = m_SocksAddress;
    memset(&sin.sin_zero, 0, sizeof(sin.sin_zero));

    //
    // initialize SOCKS request packet
    //

    struct {
        unsigned char VN;
        unsigned char CD;
        unsigned short DSTPORT;
        unsigned long  DSTIP;
        char UserId[255];
    } request;

    request.VN = 4;
    request.CD = 1;
    request.DSTPORT = pSockaddr->sin_port;
    request.DSTIP = pSockaddr->sin_addr.s_addr;

    DWORD length = sizeof(request.UserId);

    length += 8 + 1; // 8 == sizeof fixed portion of request;
                     // +1 for additional '\0'

    //
    // put socket into blocking mode
    //

    BOOL non_blocking = IsNonBlocking();

    if (non_blocking) {
        SetNonBlockingMode(FALSE);
    }

    //
    // communicate with SOCKS firewall: send SOCKS request & receive response
    //

    int serr = _I_connect(m_Socket, (LPSOCKADDR)&sin, sizeof(sin));

    if (serr != SOCKET_ERROR) {
        serr = _I_send(m_Socket, (char *)&request, length, 0);
        if (serr == (int)length) {

            char response[256];


            serr = _I_recv(m_Socket, (char *)response, sizeof(response), 0);
            if( serr == 1 ) {
                // need to read at least 2 bytes
                DEBUG_PRINT(SOCKETS,
                            ERROR,
                            ("need to read one more byte\n"));
                serr = _I_recv(  
                    m_Socket, (char *)(&response[1]), sizeof(response) - 1, 0);
            }

            if (serr != SOCKET_ERROR) {
                if (response[1] != 90) {
                    serr = SOCKET_ERROR;
                }

            } else {

                DEBUG_PRINT(SOCKETS,
                            ERROR,
                            ("recv(%#x) returns %d\n",
                            m_Socket,
                            _I_WSAGetLastError()
                            ));

            }
        } else {

            DEBUG_PRINT(SOCKETS,
                        ERROR,
                        ("send(%#x) returns %d\n",
                        m_Socket,
                        _I_WSAGetLastError()
                        ));

            serr = SOCKET_ERROR;
        }
    } else {

        DEBUG_PRINT(SOCKETS,
                    ERROR,
                    ("connect(%#x) returns %d\n",
                    m_Socket,
                    _I_WSAGetLastError()
                    ));

    }

    //
    // if originally non-blocking, make socket non-blocking again
    //

    if (non_blocking) {
        SetNonBlockingMode(TRUE);
    }

    //
    // if success, mark the socket as being connected through firewall
    //

    if (serr == SOCKET_ERROR) {
        _I_WSASetLastError(WSAECONNREFUSED);
    }

    DEBUG_LEAVE(serr);

    return serr;
}


DWORD
ICSocket::Disconnect(
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Undoes the work of ConnectSocket - i.e. closes a connected socket. We make
    callbacks to inform the app that this socket is being closed

Arguments:

    dwFlags - controlling operation

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::Disconnect",
                 "{%#x/%d} %#x",
                 GetSocket(),
                 GetSourcePort(),
                 dwFlags
                 ));

    //
    // let the app know we are closing the connection
    //

    if (dwFlags & SF_INDICATE) {
        InternetIndicateStatus(WINHTTP_CALLBACK_STATUS_CLOSING_CONNECTION, NULL, 0);
    }

    DWORD error = Close();

    if ((error == ERROR_SUCCESS) && (dwFlags & SF_INDICATE)) {

        //
        // let the app know the connection is closed
        //

        InternetIndicateStatus(WINHTTP_CALLBACK_STATUS_CONNECTION_CLOSED, NULL, 0);
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::Close(
    VOID
    )

/*++

Routine Description:

    Closes a connected socket. Assumes that any linger or shutdown etc.
    requirements have already been applied to the socket

Arguments:

    none.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::Close",
                 "{%#x/%d}",
                 GetSocket(),
                 GetSourcePort()
                 ));

    DWORD error = ERROR_SUCCESS;

    if (IsOpen()) {
//dprintf("**** closing %#x\n", m_Socket);

        int serr;

        __try {
            serr = _I_closesocket(m_Socket);
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            serr = 0;
        }
        ENDEXCEPT
        error = (serr == SOCKET_ERROR)
            ? MapInternetError(_I_WSAGetLastError())
            : ERROR_SUCCESS;
    }

    //
    // the socket is now closed
    //

    m_Socket = INVALID_SOCKET;

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::Abort(
    VOID
    )

/*++

Routine Description:

    Aborts a socket by simply closing it

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::Abort",
                 "{%#x/%d}",
                 GetSocket(),
                 GetSourcePort()
                 ));

    DWORD error = Close();

    if (error == ERROR_SUCCESS) {
        SetAborted();
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::Shutdown(
    IN DWORD dwControl
    )

/*++

Routine Description:

    Stops any more send/receives from the socket

Arguments:

    dwControl   - 0 to stop receives, 1 to stop sends, 2 to stop both

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::Shutdown",
                 "{%#x/%d}",
                 GetSocket(),
                 GetSourcePort()
                 ));

    DWORD error = ERROR_SUCCESS;

    if (IsOpen()) {

        int serr = _I_shutdown(m_Socket, dwControl);

        if (serr == SOCKET_ERROR) {

            //
            // map any sockets error to WinInet error
            //

            error = MapInternetError(_I_WSAGetLastError());
        }
    }

    DEBUG_LEAVE(error);

    return error;
}


BOOL
ICSocket::IsReset(
    VOID
    )

/*++

Routine Description:

    Determines if the socket has been closed. We peek the socket for 1 byte. If
    the socket is in blocking mode, we temporarily switch to non-blocking to
    perform the test - we don't want to block, nor remove any data from the
    socket

Arguments:

    None.

Return Value:

    BOOL
        TRUE    - socket reset (closed by server)

        FALSE   - socket alive

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Bool,
                 "ICSocket::IsReset",
                 "{%#x [%#x/%d]}",
                 this,
                 GetSocket(),
                 GetSourcePort()
                 ));

    CHECK_ICSOCKET();

    BOOL bReset = FALSE;
    BOOL bSetBlocking = FALSE;

    if (IsOpen()) {
        if (!IsNonBlocking()) {
            SetNonBlockingMode(TRUE);
            bSetBlocking = TRUE;
        }

        char ch;
#ifndef unix
        int n = _I_recv(m_Socket, &ch, 1, MSG_PEEK);
        if (n < 0) {

            DWORD error = _I_WSAGetLastError();

            if (error != WSAEWOULDBLOCK) {

                DEBUG_PRINT(SOCKETS,
                            INFO,
                            ("recv() returns %s (%d)\n",
                            InternetMapError(error),
                            error
                            ));

                n = 0;
            }
        }
        if (n == 0) {
#else
        DWORD dwAvail = 0;
        int n = _I_ioctlsocket(m_Socket,FIONREAD,&dwAvail);
        if (n != 0) {
#endif /* unix */
            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("socket %#x/port %d is reset\n",
                        m_Socket,
                        m_SourcePort
                        ));

            bReset = TRUE;
        }
        if (bSetBlocking) {
            SetNonBlockingMode(FALSE);
        }
    } else {
        bReset = TRUE;
    }

    DEBUG_LEAVE(bReset);

    return bReset;
}


DWORD
ICSocket::SetTimeout(
    IN DWORD Type,
    IN int Timeout
    )

/*++

Routine Description:

    Sets a timeout value for a connected socket

Arguments:

    Type            - type of timeout to set - send, or receive

    Timeout         - timeout value to set

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::SetTimeout",
                 "{%#x/%d} %s (%d), %d",
                 GetSocket(),
                 GetSourcePort(),
                 (Type == SEND_TIMEOUT) ? "SEND_TIMEOUT"
                    : (Type == RECEIVE_TIMEOUT) ? "RECEIVE_TIMEOUT"
                    : "?",
                 Type,
                 Timeout
                 ));

    INET_ASSERT((Type == SEND_TIMEOUT) || (Type == RECEIVE_TIMEOUT));

    if (Timeout == INFINITE)
    {
        Timeout = 0;
    }
    
    int serr = _I_setsockopt(m_Socket,
                             SOL_SOCKET,
                             (Type == SEND_TIMEOUT)
                                ? SO_SNDTIMEO
                                : SO_RCVTIMEO,
                             (const char FAR *)&Timeout,
                             sizeof(Timeout)
                             );

    DWORD error = ERROR_SUCCESS;

    if (serr == SOCKET_ERROR) {
        if (IsAborted()) {
            error = ERROR_WINHTTP_OPERATION_CANCELLED;
        } else {
            error = MapInternetError(_I_WSAGetLastError());
        }
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::SetLinger(
    IN BOOL Linger,
    IN int Timeout
    )

/*++

Routine Description:

    Sets the linger option for a connected socket

Arguments:

    Linger  - FALSE if the caller wants immediate shutdown of the socket
              when closed, or TRUE if we are to wait around until
              queued data has been sent

    Timeout - timeout value to use if Linger is TRUE

Return Value:

    DWORD
        Success - ERROR_SUCESS

        Failure - WSA error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::SetLinger",
                 "{%#x/%d} %B, %d",
                 GetSocket(),
                 GetSourcePort(),
                 Linger,
                 Timeout
                 ));

    DWORD error = ERROR_SUCCESS;

    if (IsAborted()) {
        error = ERROR_WINHTTP_OPERATION_CANCELLED;
    } else if (IsOpen()) {

        LINGER linger;

        INET_ASSERT(Timeout <= USHRT_MAX);

        linger.l_onoff = (u_short)(Linger ? 1 : 0);
        linger.l_linger = (u_short)Timeout;


        //
        // in some shutdown situations, we are hitting exception in winsock
        // on win95 (!). Handle exception
        //

        __try {
            if (_I_setsockopt(m_Socket,
                              SOL_SOCKET,
                              SO_LINGER,
                              (const char FAR *)&linger,
                              sizeof(linger)
                              ) == SOCKET_ERROR) {
                error = MapInternetError(_I_WSAGetLastError());
            }
        } __except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // do nothing except catch exception in retail
            //

            DEBUG_PRINT(SOCKETS,
                        ERROR,
                        ("exception closing socket %#x/%d\n",
                        GetSocket(),
                        GetSourcePort()
                        ));

            INET_ASSERT(IsOpen());

        }
        ENDEXCEPT
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::SetNonBlockingMode(
    IN BOOL bNonBlocking
    )

/*++

Routine Description:

    Sets socket non-blocking/blocking mode

Arguments:

    bNonBlocking    - TRUE if non-blocking, FALSE if blocking

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error mapped to INTERNET error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::SetNonBlockingMode",
                 "{%#x/%d} %B",
                 GetSocket(),
                 GetSourcePort(),
                 bNonBlocking
                 ));

    u_long on = (bNonBlocking) ? 1 : 0;
    DWORD error = ERROR_SUCCESS;

    if (_I_ioctlsocket(m_Socket, FIONBIO, &on) == 0) {
        if (on) {
            m_dwFlags |= SF_NON_BLOCKING;
        } else {
            m_dwFlags &= ~SF_NON_BLOCKING;
        }
    } else {

        DEBUG_PRINT(SOCKETS,
                    ERROR,
                    ("failed to put socket %#x/port %d into %sblocking mode\n",
                    m_Socket,
                    m_SourcePort,
                    on ? "non-" : ""
                    ));

        if (IsAborted()) {
            error = ERROR_WINHTTP_OPERATION_CANCELLED;
        } else {
            error = MapInternetError(_I_WSAGetLastError());
        }
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::GetBufferLength(
    IN SOCKET_BUFFER_ID SocketBufferId
    )

/*++

Routine Description:

    Returns the send or receive buffer length for this socket object

Arguments:

    SocketBufferId  - which buffer length to return

Return Value:

    DWORD

--*/

{
    //
    // BUGBUG - RLF 04/29/96
    //
    // This function should access first the current object, then the parent
    // object, then the globals for this data
    //

    switch (SocketBufferId) {
    case ReceiveBuffer:
        return GlobalSocketReceiveBufferLength;

    case SendBuffer:
        return GlobalSocketSendBufferLength;
    }
    return (DWORD)-1;
}


DWORD
ICSocket::GetBufferLength(
    IN SOCKET_BUFFER_ID SocketBufferId,
    OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    Gets the socket send or receive buffer length (if supported)

Arguments:

    SocketBufferId      - which buffer to set

    lpdwBufferLength    - where to write length

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Int,
                 "ICSocket::GetBufferLength",
                 "{%#x/%d} %s, %#x",
                 GetSocket(),
                 GetSourcePort(),
                 (SocketBufferId == ReceiveBuffer)
                    ? "ReceiveBuffer"
                    : ((SocketBufferId == SendBuffer)
                        ? "SendBuffer"
                        : "?")
                 ));

    DWORD size = sizeof(*lpdwBufferLength);

    int serr = _I_getsockopt(m_Socket,
                             SOL_SOCKET,
                             SocketBufferId,
                             (char FAR *)lpdwBufferLength,
                             (int FAR *)&size
                             );

    DWORD error;

    if (serr != SOCKET_ERROR) {
        error = ERROR_SUCCESS;
    } else {
        error = MapInternetError(_I_WSAGetLastError());
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::SetBufferLength(
    IN SOCKET_BUFFER_ID SocketBufferId,
    IN DWORD dwBufferLength
    )

/*++

Routine Description:

    Sets the socket send or receive buffer length

Arguments:

    SocketBufferId  - which buffer to set

    dwBufferLength  - length to set it to

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error mapped to INTERNET error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::SetBufferLength",
                 "{%#x/%d} %s, %d",
                 GetSocket(),
                 GetSourcePort(),
                 (SocketBufferId == ReceiveBuffer)
                    ? "ReceiveBuffer"
                    : (SocketBufferId == SendBuffer)
                        ? "SendBuffer"
                        : "?",
                 dwBufferLength
                 ));

    INET_ASSERT((int)dwBufferLength >= 0);

    DWORD size = sizeof(dwBufferLength);

    int serr = _I_setsockopt(m_Socket,
                             SOL_SOCKET,
                             SocketBufferId,
                             (const char FAR *)&dwBufferLength,
                             (int)size
                             );

    DWORD error = ERROR_SUCCESS;

    if (serr == SOCKET_ERROR) {
        if (IsAborted()) {
            error = ERROR_WINHTTP_OPERATION_CANCELLED;
        } else {
            error = MapInternetError(_I_WSAGetLastError());
        }
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::SetSendCoalescing(
    IN BOOL bOnOff
    )

/*++

Routine Description:

    Enables or disables Nagle algorithm

Arguments:

    bOnOff  - FALSE to disable, TRUE to enable

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::SetSendCoalescing",
                 "{%#x/%d} %B",
                 GetSocket(),
                 GetSourcePort(),
                 bOnOff
                 ));

    int optval = bOnOff ? 0 : 1;
    int serr = _I_setsockopt(m_Socket,
                             IPPROTO_TCP,
                             TCP_NODELAY,
                             (const char FAR *)&optval,
                             sizeof(optval)
                             );

    DWORD error = ERROR_SUCCESS;

    if (serr == SOCKET_ERROR) {
        if (IsAborted()) {
            error = ERROR_WINHTTP_OPERATION_CANCELLED;
        } else {
            error = MapInternetError(_I_WSAGetLastError());
        }
    }

    DEBUG_LEAVE(error);

    return error;
}


VOID
ICSocket::SetSourcePort(
    VOID
    )

/*++

Routine Description:

    Record the port we are connected to locally. Useful for debugging & matching
    up socket with net sniff

Arguments:

    None.

Return Value:

    None.

--*/

{
    SOCKADDR_IN address;
    int namelen = sizeof(address);

    if (_I_getsockname(GetSocket(), (LPSOCKADDR)&address, &namelen) == 0) {
        m_SourcePort = (INTERNET_PORT)_I_ntohs(address.sin_port);
    } else {
        m_SourcePort = 0;
    }
}


DWORD
ICSocket::Send(
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Sends data over connected socket

Arguments:

    lpBuffer        - pointer to buffer containing data to send

    dwBufferLength  - length of lpBuffer in bytes

    dwFlags         - flags controlling send:

                        SF_INDICATE     - make status callbacks to the app when
                                          we are starting to send data and when
                                          we finish

Return Value:

    DWORD
        Success - ERROR_SUCCESS

                  ERROR_IO_PENDING
                    Operation will complete asynchronously

        Failure - ERROR_NOT_ENOUGH_MEMORY
                    Couldn't create FSM

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::Send",
                 "{%#x [%#x/%d]} %#x, %d, %#x",
                 this,
                 GetSocket(),
                 GetSourcePort(),
                 lpBuffer,
                 dwBufferLength,
                 dwFlags
                 ));

    INET_ASSERT(lpBuffer != NULL);
    INET_ASSERT((int)dwBufferLength > 0);

    DWORD error = DoFsm(New CFsm_SocketSend(lpBuffer,
                                            dwBufferLength,
                                            dwFlags,
                                            this
                                            ));

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_SocketSend::RunSM(
    IN CFsm * Fsm
    )

/*++

Routine Description:

    Runs next CFsm_SocketSend state

Arguments:

    Fsm - socket send FSM

Return Value:

    DWORD
        Success - ERROR_SUCCESS

                  ERROR_IO_PENDING
                    Operation will complete asynchronously

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CFsm_SocketSend::RunSM",
                 "%#x",
                 Fsm
                 ));

    ICSocket * pSocket = (ICSocket *)Fsm->GetContext();
    CFsm_SocketSend * stateMachine = (CFsm_SocketSend *)Fsm;
    DWORD error;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
    case FSM_STATE_ERROR:
        error = pSocket->Send_Start(stateMachine);
        break;

    default:
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_WINHTTP_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::Send_Start(
    IN CFsm_SocketSend * Fsm
    )

/*++

Routine Description:

    Continues send request - sends the data

Arguments:

    Fsm - socket send FSM

Return Value:

    DWORD
        Success - ERROR_SUCCESS

                  ERROR_IO_PENDING
                    Operation will complete asynchronously

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::Send_Start",
                 "{%#x [%#x/%d]} %#x(%#x, %d, %#x)",
                 this,
                 GetSocket(),
                 GetSourcePort(),
                 Fsm,
                 Fsm->m_lpBuffer,
                 Fsm->m_dwBufferLength,
                 Fsm->m_dwFlags
                 ));

    CFsm_SocketSend & fsm = *Fsm;
    DWORD error = fsm.GetError();
    FSM_STATE state = fsm.GetState();
    INTERNET_HANDLE_OBJECT * pObject = fsm.GetMappedHandleObject();

    if (error != ERROR_SUCCESS) 
    {
        goto quit;
    }
    if (state == FSM_STATE_INIT) {
        if (!(m_dwFlags & (SF_ENCRYPT | SF_DECRYPT))) {

            DEBUG_DUMP_API(SOCKETS,
                           "sending data:\n",
                           fsm.m_lpBuffer,
                           fsm.m_dwBufferLength
                           );

        }

        if (pObject != NULL) {
            pObject->SetAbortHandle(this);
        }
        
        if (fsm.m_dwFlags & SF_INDICATE) {
            error = InternetIndicateStatus(WINHTTP_CALLBACK_STATUS_SENDING_REQUEST, NULL, 0);

            if (error != ERROR_SUCCESS)
            {
                INET_ASSERT(error == ERROR_WINHTTP_OPERATION_CANCELLED);
                goto quit;
            }
        }

        fsm.StartTimer();
    }
    
    while (fsm.m_dwBufferLength != 0) 
    {
        //
        // the socket may have already been aborted
        //

        if (IsAborted()) {
            error = ERROR_WINHTTP_OPERATION_CANCELLED;
            break;
        }

        if (fsm.m_pServerInfo != NULL) {
            fsm.m_pServerInfo->SetLastActiveTime();
        }

        DWORD dwSendSize;
#define GLOBAL_MAX_SEND_LENGTH_DEFAULT (4*1024*1024)
        if (fsm.m_dwBufferLength > GLOBAL_MAX_SEND_LENGTH_DEFAULT)
        {
            dwSendSize = GLOBAL_MAX_SEND_LENGTH_DEFAULT;
        }
        else
        {
            dwSendSize = fsm.m_dwBufferLength;
        }
        
        int nSent;
        
        if (IsNonBlocking()) 
        {
            if (fsm.bIOCPInited)
            {
                fsm.bIOCPInited = FALSE;

                if (fsm.bIOCPSuccess)
                {
                    //send completed successfully
                    DEBUG_PRINT(SOCKETS,
                                INFO,
                                ("WSASend sent %d bytes @ %#x to socket %#x/port %d\n",
                                fsm.dwBytesTransferred,
                                fsm.m_lpBuffer,
                                m_Socket,
                                m_SourcePort
                                ));
                                
                    error = ERROR_SUCCESS;

                    nSent = (int)fsm.dwBytesTransferred;
                    fsm.m_iTotalSent = nSent;
                    fsm.m_lpBuffer = (LPBYTE)fsm.m_lpBuffer + nSent;
                    fsm.m_dwBufferLength -= nSent;
                    continue;
                }
                else
                {
                    //
                    // map any sockets error to WinInet error and terminate this
                    // request
                    //

                    //VENKATKBUG - handle retrieable errors such as WSAWOULDBLOCK
                    
                    DEBUG_PRINT(SOCKETS,
                                ERROR,
                                ("send() returns %d (%s)\n",
                                error,
                                InternetMapError(error)
                                ));

                    error = MapInternetError(error);
                    break;
                }
            }// if fsm.bIOCPInited()
    
                
            WSABUF wsabuf;
            wsabuf.len = dwSendSize; //fsm.m_dwBufferLength;
            wsabuf.buf = (char FAR *)fsm.m_lpBuffer;
            int nError;

            if (!_lpWrapOverlappedSend)
            {
                _lpWrapOverlappedSend = New CWrapOverlapped();

                if (!_lpWrapOverlappedSend)
                {
                    error = ERROR_NOT_ENOUGH_MEMORY;
                    goto quit;
                }
            }

            CWrapOverlapped* lpWrapOverlapped = _lpWrapOverlappedSend;
            LPWSAOVERLAPPED lpOverlapped = _lpWrapOverlappedSend->GetOverlapped();
            memset(lpOverlapped, 0, sizeof(WSAOVERLAPPED));
            
            CFsm* pFsmOld = GetAndSetCurrentFsm(&fsm);
            INET_ASSERT (pFsmOld == NULL);

            fsm.bIOCPInited = TRUE;

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("calling WSASend() blocked, socket %#x, port %d\n",
                        m_Socket,
                        m_SourcePort
                        ));

            fsm.SetAction(FSM_ACTION_SEND);

            DWORD timeout = GetTimeoutValue(WINHTTP_OPTION_SEND_TIMEOUT);

            if (timeout != INFINITE)
            {
                fsm.SetTimeout(timeout);
                fsm.SetOnAsyncList(TRUE);
                error = QueueSocketWorkItem(Fsm, m_Socket);
                
                INET_ASSERT (error == ERROR_IO_PENDING);
                if (error != ERROR_IO_PENDING)
                {
                    // 2 causes - both irrecoverable
                    // 1. no global pointer to ICAsyncThread
                    // OR 2. no threadinfo or SelectThread.
                    // so bail!
                    GetAndSetCurrentFsm(NULL);
                    fsm.bIOCPInited = FALSE;
                    fsm.SetOnAsyncList(FALSE);
                    fsm.SetErrorState(error);
                    goto quit;
                }
            }

            _lpWrapOverlappedSend->Reference(); // to keep this ICSocket=>the Overlapped struct valid beyong the WSASend() call.
            _lpWrapOverlappedSend->Reference(); // to make sure it stays alive for the IOCP to get the fsm off it.
            
            DEBUG_ENTER((DBG_API,
                             Dword,
                             "***WSASend",
                             "(m_Socket)%#x, (wsabuf.buf)%#x, (wsabuf.len)%#x, (this)%#x, (overlapped)%#x, (fsm)%#x",
                             m_Socket,
                             wsabuf.buf,
                             wsabuf.len,
                             this,
                             lpOverlapped,
                             &fsm
                             ));
                             
            nError = _I_WSASend(m_Socket,
                            &wsabuf,
                            1,
                            (LPDWORD)&nSent,
                            0,
                            lpOverlapped,
                            NULL);


            DEBUG_LEAVE(nError);                        

            lpWrapOverlapped->Dereference(); // release the WSASend reference.
            
            DEBUG_PRINT(SOCKETS,
                        ERROR,
                        ("WSASend() returns %d (%s) with nSent=%d bytes\n",
                        nError,
                        InternetMapError(nError),
                        nSent
                        ));

            if (nError == 0)
            {
#if INET_DEBUG
                InterlockedIncrement(&g_cWSACompletions);
#endif
                 error = ERROR_IO_PENDING;
                 break;
            }
            else
            {
                INET_ASSERT (nError == SOCKET_ERROR);

                error = _I_WSAGetLastError();

                if (error == WSA_IO_PENDING) 
                {
#if INET_DEBUG
                    InterlockedIncrement(&g_cWSACompletions);
#endif
                    error = ERROR_IO_PENDING;
                    break;
                } 
                else
                {
                    // no IOCompletion here.
                    // VENKATKBUG: remove this assert later, only informational.
                    // DWORD dwError = error; //dummy for debugging
                    // INET_ASSERT (FALSE);
                    if (fsm.HasTimeout())
                    {
                        if (!RemoveFsmFromAsyncList(&fsm))
                        {
                            //failure! the select thread already enforced timeout and updated state
                            //informational assert.
                            //VENKATK_BUG-enable later INET_ASSERT (FALSE && "COOL: select enforced timeout");
                        }
                    }

                    GetAndSetCurrentFsm(NULL);
                    lpWrapOverlapped->Dereference(); // release the IOCP-based reference.
                    
                    //
                    // check first to see if the error was due to the socket being
                    // closed as a result of the request being cancelled
                    //
                    if (IsAborted()) 
                    {
                        error = ERROR_WINHTTP_OPERATION_CANCELLED;
                        break;
                    }
                    
                    //
                    // map any sockets error to WinInet error and terminate this
                    // request
                    //

                    //VENKATKBUG - handle retrieable errors such as WSAWOULDBLOCK
                    error = MapInternetError(error);
                    break;
                }
            }//if! nError == 0
        }
        else// if IsNonBlocking()
        {
            nSent = _I_send(m_Socket,
                                (char FAR *)fsm.m_lpBuffer,
                                dwSendSize, //fsm.m_dwBufferLength,
                                0
                                );

            if (nSent != SOCKET_ERROR) 
            {
                DEBUG_PRINT(SOCKETS,
                            INFO,
                            ("sent %d bytes @ %#x to socket %#x/port %d\n",
                            nSent,
                            fsm.m_lpBuffer,
                            m_Socket,
                            m_SourcePort
                            ));

                fsm.m_iTotalSent += nSent;
                fsm.m_lpBuffer = (LPBYTE)fsm.m_lpBuffer + nSent;
                fsm.m_dwBufferLength -= nSent;
            } 
            else 
            {
                //
                // check first to see if the error was due to the socket being
                // closed as a result of the request being cancelled
                //

                if (IsAborted()) 
                {
                    error = ERROR_WINHTTP_OPERATION_CANCELLED;
                    break;
                } 
                else 
                {
                    error = _I_WSAGetLastError();
                    //
                    // map any sockets error to WinHttp error and terminate this
                    // request
                    //

                    DEBUG_PRINT(SOCKETS,
                                ERROR,
                                ("send() returns %d (%s)\n",
                                error,
                                InternetMapError(error)
                                ));

                    error = MapInternetError(error);
                    break;
                }
            }// if! nSent!=SOCKET_ERROR
        }// if! IsNonBlocking()
    }// while fsm.m_dwBufferLength != 0

quit:

    if (error != ERROR_IO_PENDING) {
        fsm.StopTimer();
        if (fsm.GetMappedHandleObject() != NULL) {
            fsm.GetMappedHandleObject()->ResetAbortHandle();
        }
        if (IsAborted()) {
            error = ERROR_WINHTTP_OPERATION_CANCELLED;
        } else if (error == ERROR_SUCCESS) {
            if (fsm.m_dwFlags & SF_INDICATE) 
            {
                INT iTotalSent = fsm.m_iTotalSent;
                InternetIndicateStatus(WINHTTP_CALLBACK_STATUS_REQUEST_SENT,
                                       &iTotalSent,
                                       sizeof(iTotalSent)
                                       );
            }
            if (fsm.m_pServerInfo != NULL) {
                //fsm.m_pServerInfo->UpdateSendTime(fsm.ReadTimer());
            }
        }
        fsm.SetDone(error);
    }

    DEBUG_LEAVE(error);

    return error;
}

//
//DWORD
//ICSocket::SendTo(
//    IN LPSOCKADDR lpDestination,
//    IN DWORD dwDestinationLength,
//    IN LPVOID lpBuffer,
//    IN DWORD dwBufferLength,
//    OUT LPDWORD lpdwBytesSent,
//    IN DWORD dwWinsockFlags,
//    IN DWORD dwFlags
//    )
//
///*++
//
//Routine Description:
//
//    Wrapper for sendto()
//
//Arguments:
//
//    lpDestination       - pointer to remote address to send to
//
//    dwDestinationLength - length of *lpDestination
//
//    lpBuffer            - pointer to buffer containing data to send
//
//    dwBufferLength      - number of bytes to send from lpBuffer
//
//    lpdwBytesSent       - number of bytes sent to destination
//
//    dwWinsockFlags      - flags to pass through to sendto()
//
//    dwFlags             - ICSocket flags
//
//Return Value:
//
//    DWORD
//        Success - ERROR_SUCCESS
//
//        Failure - ERROR_WINHTTP_OPERATION_CANCELLED
//                    The operation was cancelled by the caller
//
//                  ERROR_WINHTTP_TIMEOUT
//                    The operation timed out
//
//                  ERROR_WINHTTP_CONNECTION_ERROR
//                    An error occurred. We approximate to connection reset
//
//                  WSA error
//                    Some other sockets error occurred
//
//--*/
//
//{
//    DEBUG_ENTER((DBG_SOCKETS,
//                 Dword,
//                 "ICSocket::SendTo",
//                 "{%#x} %#x, %d, %#x, %d, %#x, %#x, %#x",
//                 m_Socket,
//                 lpDestination,
//                 dwDestinationLength,
//                 lpBuffer,
//                 dwBufferLength,
//                 lpdwBytesSent,
//                 dwWinsockFlags,
//                 dwFlags
//                 ));
//
//    INET_ASSERT(IsSocketValid());
//    INET_ASSERT(lpdwBytesSent != NULL);
//
//    int totalSent = 0;
//    DWORD error = ERROR_SUCCESS;
//    INTERNET_HANDLE_OBJECT * pObject = NULL;
//    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
//    BOOL fNonBlocking;
//
//    if (IsAborted()) {
//        error = ERROR_WINHTTP_OPERATION_CANCELLED;
//        goto quit;
//    }
//
//    if (lpThreadInfo == NULL) {
//
//        INET_ASSERT(FALSE);
//
//        error = ERROR_WINHTTP_INTERNAL_ERROR;
//        goto quit;
//    }
//
//    fNonBlocking = lpThreadInfo->IsAsyncWorkerThread;
//
//    //
//    // set the cancel socket in the object
//    //
//
//    pObject = (INTERNET_HANDLE_OBJECT * )lpThreadInfo->hObjectMapped;
//    if (pObject != NULL) {
//        pObject->SetAbortHandle(this);
//    }
//
//    //
//    // if we are in async (== non-blocking) mode, let the async request
//    // scheduler know what operation we will be waiting on
//    //
//
//    if (fNonBlocking) {
//
//        INET_ASSERT(lpThreadInfo->lpArb != NULL);
//
//        SET_ARB_SOCKET_OPERATION(lpThreadInfo->lpArb, m_Socket, SEND);
//    }
//
//    if (dwFlags & SF_INDICATE) {
//
//        //
//        // let the app know we are starting to send data
//        //
//
//        InternetIndicateStatus(INTERNET_STATUS_SENDING_REQUEST,
//                               NULL,
//                               0
//                               );
//    }
//
//    DEBUG_DUMP(SOCKETS,
//               "sending data:\n",
//               lpBuffer,
//               dwBufferLength
//               );
//
//    int nSent;
//
//    //
//    // loop until all data sent
//    //
//
//    do {
//
//        nSent = _I_sendto(m_Socket,
//                          (char FAR *)lpBuffer + totalSent,
//                          dwBufferLength,
//                          dwWinsockFlags,
//                          lpDestination,
//                          dwDestinationLength
//                          );
//        if (nSent != SOCKET_ERROR) {
//
//            DEBUG_PRINT(SOCKETS,
//                        INFO,
//                        ("sent %d bytes @ %#x on socket %#x\n",
//                        nSent,
//                        (LPBYTE)lpBuffer + totalSent,
//                        m_Socket
//                        ));
//
//            INET_ASSERT(nSent > 0);
//
//            totalSent += nSent;
//            dwBufferLength -= nSent;
//        } else {
//            error = _I_WSAGetLastError();
//            if ((error == WSAEWOULDBLOCK) && fNonBlocking) {
//
//                INET_ASSERT(_dwFlags & SF_NON_BLOCKING);
//
//                DEBUG_PRINT(SOCKETS,
//                            INFO,
//                            ("sendto(%#x) would block\n",
//                            m_Socket
//                            ));
//
//                lpThreadInfo->lpArb->Header.dwResultCode = ERROR_SUCCESS;
//
//                SwitchToAsyncScheduler(m_Socket);
//
//                error = lpThreadInfo->lpArb->Header.dwResultCode;
//
//                DEBUG_PRINT(SOCKETS,
//                            INFO,
//                            ("sendto(%#x) resumed, returns %s\n",
//                            m_Socket,
//                            InternetMapError(error)
//                            ));
//
//                if (error != ERROR_SUCCESS) {
//                }
//            } else {
//
//                //
//                // some other error
//                //
//
//                error = MapInternetError(error);
//            }
//        }
//
//        INET_ASSERT((int)dwBufferLength >= 0);
//
//    } while ((dwBufferLength != 0) && (error == ERROR_SUCCESS));
//
//    if ((dwFlags & SF_INDICATE) && (error == ERROR_SUCCESS)) {
//
//        //
//        // let the app know we have finished sending
//        //
//
//        InternetIndicateStatus(INTERNET_STATUS_REQUEST_SENT,
//                               &totalSent,
//                               sizeof(totalSent)
//                               );
//    }
//
//    //
//    // if we are in async (== non-blocking) mode, let the async request
//    // scheduler know that we no longer require this socket
//    //
//
//    if (fNonBlocking) {
//
//        INET_ASSERT(lpThreadInfo->lpArb != NULL);
//
//        SET_ARB_SOCKET_OPERATION(lpThreadInfo->lpArb, INVALID_SOCKET, SEND);
//    }
//
//quit:
//
//    *lpdwBytesSent = totalSent;
//
//    //
//    // no longer performing operation on this socket
//    //
//
//    if (pObject != NULL) {
//        pObject->ResetAbortHandle();
//
//        //
//        // if the operation has been cancelled, then this error overrides any
//        // other
//        //
//
//        //if (pObject->IsInvalidated()) {
//        //    error = pObject->GetError();
//        //    if (error == ERROR_SUCCESS) {
//        //        error = ERROR_WINHTTP_OPERATION_CANCELLED;
//        //    }
//        //}
//        if (IsAborted()) {
//            error = ERROR_WINHTTP_OPERATION_CANCELLED;
//        }
//    }
//
//    INET_ASSERT((pObject != NULL) ? (pObject->GetAbortHandle() == NULL) : TRUE);
//
//    DEBUG_LEAVE(error);
//
//    return error;
//}


DWORD
ICSocket::Receive(
    IN OUT LPVOID * lplpBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN OUT LPDWORD lpdwBufferRemaining,
    IN OUT LPDWORD lpdwBytesReceived,
    IN DWORD dwExtraSpace,
    IN DWORD dwFlags,
    OUT LPBOOL lpbEof
    )

/*++

Routine Description:

    Receives data from connected socket. Depending on flags settings, we will
    perform a single receive, loop until we have filled the buffer and/or loop
    until we have received all the data.

    This function returns user data, so if the stream we are receiving from is
    encrypted, we must decrypt the data before returning. This may require
    receiving more data than the user expects because we have to decrypt at
    message boundaries

    This function is intended to be called in a loop. The buffer pointer and
    buffer sizes are intended to be updated by each successive call to this
    function, and should therefore have the same values the next time this
    function is called

Arguments:

    lplpBuffer          - pointer to pointer to users buffer. If supplied, the
                          buffer should be LMEM_FIXED

    lpdwBufferLength    - size of buffer

    lpdwBufferRemaining - number of bytes left in the buffer

    lpdwBytesReceived   - number of bytes received

    dwExtraSpace        - number of additional bytes caller wants at end of
                          buffer (only useful if resizing AND only applied at
                          end of receive)

    dwFlags             - flags controlling receive:

                            SF_EXPAND       - lpBuffer can be expanded to fit
                                              data

                            SF_COMPRESS     - if set, we will shrink the buffer
                                              to compress out any unused space

                            SF_RECEIVE_ALL  - if set, this function will loop
                                              until all data received, or the
                                              supplied buffer is filled

                            SF_INDICATE     - if set, we will make status
                                              callbacks to the app when we are
                                              starting to receive data, and when
                                              we finish

                            SF_WAIT         - (used with SF_NON_BLOCKING). Even
                                              though the socket is non-blocking,
                                              the caller wants us to not
                                              relinquish control under the
                                              request has been satisfied

    lpbEof              - TRUE if we got end-of-connection indication
                          (recv() returns 0)

Return Value:

    DWORD
        Success - ERROR_SUCCESS

                  ERROR_IO_PENDING
                    Operation will complete asynchronously

        Failure - ERROR_NOT_ENOUGH_MEMORY
                    Couldn't allocate/grow buffer

                  ERROR_INSUFFICIENT_BUFFER
                    The initial buffer was insufficient (i.e. caller supplied
                    buffer pointer was NULL, or we ran out of buffer space and
                    are not allowed to resize it)

                  WSA error
                    Sockets error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::Receive",
                 "%#x [%#x], %#x [%d], %#x [%d], %#x [%d], %d, %#x, %#x [%B]",
                 lplpBuffer,
                 *lplpBuffer,
                 lpdwBufferLength,
                 *lpdwBufferLength,
                 lpdwBufferRemaining,
                 *lpdwBufferRemaining,
                 lpdwBytesReceived,
                 *lpdwBytesReceived,
                 dwExtraSpace,
                 dwFlags,
                 lpbEof,
                 *lpbEof
                 ));

    INET_ASSERT((int)*lpdwBufferLength >= 0);
    INET_ASSERT((int)*lpdwBufferRemaining >= 0);
    INET_ASSERT((int)*lpdwBytesReceived >= 0);

#define SF_MUTEX_FLAGS  (SF_RECEIVE_ALL | SF_NO_WAIT)

    INET_ASSERT((dwFlags & SF_MUTEX_FLAGS) != SF_MUTEX_FLAGS);

    DWORD error = DoFsm(New CFsm_SocketReceive(lplpBuffer,
                                               lpdwBufferLength,
                                               lpdwBufferRemaining,
                                               lpdwBytesReceived,
                                               dwExtraSpace,
                                               dwFlags,
                                               lpbEof,
                                               this
                                               ));

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_SocketReceive::RunSM(
    IN CFsm * Fsm
    )

/*++

Routine Description:

    Runs next CFsm_SocketReceive state

Arguments:

    Fsm - socket receive FSM

Return Value:

    DWORD
        Success - ERROR_SUCCESS

                  ERROR_IO_PENDING
                    Operation will complete asynchronously

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CFsm_SocketReceive::RunSM",
                 "%#x",
                 Fsm
                 ));

    ICSocket * pSocket = (ICSocket *)Fsm->GetContext();
    CFsm_SocketReceive * stateMachine = (CFsm_SocketReceive *)Fsm;
    DWORD error;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
        error = pSocket->Receive_Start(stateMachine);
        break;

    case FSM_STATE_CONTINUE:
    case FSM_STATE_ERROR:
        error = pSocket->Receive_Continue(stateMachine);
        break;

    default:
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_WINHTTP_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::Receive_Start(
    IN CFsm_SocketReceive * Fsm
    )

/*++

Routine Description:

    Initiates a receive request - grows the buffer if required and kicks off the
    first receive operation

Arguments:

    Fsm - reference to FSM controlling operation

Return Value:

    DWORD
        Success - ERROR_SUCCESS

                  ERROR_IO_PENDING
                    Operation will complete asynchronously

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::Receive_Start",
                 "{%#x [%#x/%d]} %#x(%#x [%#x], %#x [%d], %#x [%d], %#x [%d], %d, %#x, %#x [%B])",
                 this,
                 GetSocket(),
                 GetSourcePort(),
                 Fsm,
                 Fsm->m_lplpBuffer,
                 *Fsm->m_lplpBuffer,
                 Fsm->m_lpdwBufferLength,
                 *Fsm->m_lpdwBufferLength,
                 Fsm->m_lpdwBufferRemaining,
                 *Fsm->m_lpdwBufferRemaining,
                 Fsm->m_lpdwBytesReceived,
                 *Fsm->m_lpdwBytesReceived,
                 Fsm->m_dwExtraSpace,
                 Fsm->m_dwFlags,
                 Fsm->m_lpbEof,
                 *Fsm->m_lpbEof
                 ));

    CFsm_SocketReceive & fsm = *Fsm;
    DWORD error = ERROR_SUCCESS;

    //
    // if we weren't given a buffer, but the caller told us its okay to resize
    // then we allocate the initial buffer
    //

    if ((fsm.m_dwBufferLength == 0) || (fsm.m_dwBufferLeft == 0)) {

        INET_ASSERT((fsm.m_dwBufferLength == 0) ? (fsm.m_dwBufferLeft == 0) : TRUE);

        if (fsm.m_dwFlags & SF_EXPAND) {

            //
            // allocate a fixed memory buffer
            //

            //
            // BUGBUG - the initial buffer size should come from the handle
            //          object
            //

            fsm.m_dwBufferLeft = DEFAULT_RECEIVE_BUFFER_INCREMENT;
            if (fsm.m_dwBufferLength == 0) {
                fsm.m_bAllocated = TRUE;
            }
            fsm.m_dwBufferLength += fsm.m_dwBufferLeft;

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("resizing %#x to %d\n",
                        fsm.m_hBuffer,
                        fsm.m_dwBufferLength
                        ));

            fsm.m_hBuffer = ResizeBuffer(fsm.m_hBuffer, fsm.m_dwBufferLength, FALSE);
            if (fsm.m_hBuffer == (HLOCAL)NULL) {
                error = GetLastError();

                INET_ASSERT(error != ERROR_SUCCESS);

                fsm.m_bAllocated = FALSE;
            }
        } else {

            //
            // the caller didn't say its okay to resize
            //

            error = ERROR_INSUFFICIENT_BUFFER;
        }
    } else if (fsm.m_hBuffer == (HLOCAL)NULL) {
        error = ERROR_INSUFFICIENT_BUFFER;
    }
    if (error == ERROR_SUCCESS) {
        if (fsm.GetMappedHandleObject() != NULL) {
            fsm.GetMappedHandleObject()->SetAbortHandle(this);
        }

        //
        // keep the app informed (if requested to do so)
        //

        if (fsm.m_dwFlags & SF_INDICATE) {
            error = InternetIndicateStatus(WINHTTP_CALLBACK_STATUS_RECEIVING_RESPONSE, NULL, 0);

            if (error != ERROR_SUCCESS)
            {
                INET_ASSERT(error == ERROR_WINHTTP_OPERATION_CANCELLED);
                fsm.SetError(error);
            }
        }

        //
        // kick off the receive request. If we complete synchronously (with
        // an error or successfully), then call the finish handler here
        //

        error = Receive_Continue(Fsm);
    } else {
        fsm.SetDone();
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::Receive_Continue(
    IN CFsm_SocketReceive * Fsm
    )

/*++

Routine Description:

    Receives data from connected socket. Depending on flags settings, we will
    perform a single receive, loop until we have filled the buffer and/or loop
    until we have received all the data.

Arguments:

    Fsm - reference to FSM controlling operation

Return Value:

    DWORD
        Success - ERROR_SUCCESS

                  ERROR_IO_PENDING
                    Operation will complete asynchronously

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::Receive_Continue",
                 "{%#x [%#x/%d]} %#x(%#x [%#x], %#x [%d], %#x [%d], %#x [%d], %d, %#x, %#x [%B])",
                 this,
                 GetSocket(),
                 GetSourcePort(),
                 Fsm,
                 Fsm->m_lplpBuffer,
                 *Fsm->m_lplpBuffer,
                 Fsm->m_lpdwBufferLength,
                 *Fsm->m_lpdwBufferLength,
                 Fsm->m_lpdwBufferRemaining,
                 *Fsm->m_lpdwBufferRemaining,
                 Fsm->m_lpdwBytesReceived,
                 *Fsm->m_lpdwBytesReceived,
                 Fsm->m_dwExtraSpace,
                 Fsm->m_dwFlags,
                 Fsm->m_lpbEof,
                 *Fsm->m_lpbEof
                 ));

    CFsm_SocketReceive & fsm = *Fsm;
    DWORD error = fsm.GetError();
    INTERNET_HANDLE_OBJECT * pObject = fsm.GetMappedHandleObject();

    if (error != ERROR_SUCCESS) {
        goto error_exit;
    }

    fsm.m_lpBuffer = (LPBYTE)fsm.m_hBuffer + fsm.m_dwBytesReceived;

    //
    // receive some data
    //

    do 
    {
        if (fsm.m_pServerInfo != NULL) 
        {
            fsm.m_pServerInfo->SetLastActiveTime();
        }

        INET_ASSERT((int)fsm.m_dwBufferLeft > 0);

        int nRead;

        if (IsNonBlocking()) 
        {
            if (fsm.bIOCPInited)
            {
                fsm.bIOCPInited = FALSE;
                nRead = fsm.dwBytesTransferred;
                
                if (fsm.bIOCPSuccess)
                {
                    if (nRead == 0) 
                    {
                        //
                        // done
                        //
                        DEBUG_PRINT(SOCKETS,
                                    INFO,
                                    ("EOF connection %#x/port %d\n",
                                    m_Socket,
                                    m_SourcePort
                                    ));

                        fsm.m_bEof = TRUE;
                        break;
                    } 
                    else if (nRead > 0) 
                    {

                        DEBUG_PRINT(SOCKETS,
                                    INFO,
                                    ("received %d bytes from socket %#x/port %d\n",
                                    nRead,
                                    m_Socket,
                                    m_SourcePort
                                    ));

                        fsm.m_dwBytesReceived += nRead;
                        fsm.m_dwBytesRead += nRead;
                        fsm.m_lpBuffer += nRead;
                        fsm.m_dwBufferLeft -= nRead;

                        //
                        // if SF_RECEIVE_ALL is not set then the caller just wants us to
                        // perform a single receive. We're done
                        //

                        if (!(fsm.m_dwFlags & SF_RECEIVE_ALL) ) 
                        {
                            break;
                        }
                        //
                        // if we've filled the current buffer, then either we're done, or
                        // the caller wants us to receive the entire response, in which
                        // case we attempt to grow the buffer and receive the next part
                        // of the message. Note that we may have already received the
                        // entire response if it just happened to be the same size as our
                        // buffer
                        //

                        // BUGBUG [arthurbi] we're broken for SSL/PCT case !!!
                        //  We need to handle expanding the buffer.
                        //

                        if (fsm.m_dwBufferLeft == 0) 
                        {
                            //
                            // BUGBUG - RLF - why are we testing for SF_DECRYPT here?
                            //

                            if (!(fsm.m_dwFlags & SF_EXPAND) || (m_dwFlags & SF_DECRYPT)) 
                            {
                                break;
                            } 
                            else 
                            {
                                //
                                // BUGBUG - the buffer increment should come from the handle
                                //          object
                                //

                                fsm.m_dwBufferLeft = DEFAULT_RECEIVE_BUFFER_INCREMENT;
                                fsm.m_dwBufferLength += DEFAULT_RECEIVE_BUFFER_INCREMENT;

                                DEBUG_PRINT(SOCKETS,
                                            INFO,
                                            ("resizing %#x to %d\n",
                                            fsm.m_hBuffer,
                                            fsm.m_dwBufferLength
                                            ));

                                fsm.m_hBuffer = ResizeBuffer(fsm.m_hBuffer,
                                                             fsm.m_dwBufferLength,
                                                             FALSE
                                                             );
                                if (fsm.m_hBuffer != NULL) 
                                {
                                    fsm.m_lpBuffer = (LPBYTE)fsm.m_hBuffer + fsm.m_dwBytesReceived;
                                }
                                else 
                                {
                                    error = GetLastError();
                                    INET_ASSERT(error != ERROR_SUCCESS);

                                    fsm.m_dwBytesReceived = 0;
                                    fsm.m_dwBufferLength = 0;
                                    fsm.m_dwBufferLeft = 0;
                                }
                            }
                        }// if fsm.m_dwBufferLeft == 0
                    }// if nRead >= 0
                }// if fsm.bIOCPSuccess
                else 
                {
                    error = fsm.dwIOCPError;
                    // a real error occurred. We need to get out
                    //

                    error = MapInternetError(error);

                    //VENKATKBUG_ remove this assert later - only informational
                    INET_ASSERT (FALSE && "IOCPError");
                    break;
                }// if! fsm.bSuccess

                continue; //for any fall-thrus.
            } // if fsm.bIOCPInited
            
            int nError;
            WSABUF wsabuf;
            wsabuf.len = fsm.m_dwBufferLeft;
            wsabuf.buf = (char FAR *)fsm.m_lpBuffer;
            DWORD dwFlags = 0;

            if (!_lpWrapOverlappedRecv)
            {
                _lpWrapOverlappedRecv = New CWrapOverlapped();

                if (!_lpWrapOverlappedRecv)
                {
                    error = ERROR_NOT_ENOUGH_MEMORY;
                    fsm.SetErrorState(error);
                    goto error_exit;
                }
            }
            
            CWrapOverlapped* lpWrapOverlapped = _lpWrapOverlappedRecv;
            LPWSAOVERLAPPED lpOverlapped = _lpWrapOverlappedRecv->GetOverlapped();
            memset(lpOverlapped, 0, sizeof(WSAOVERLAPPED));

            CFsm* pFsmOld = GetAndSetCurrentFsm(&fsm);
            INET_ASSERT (pFsmOld == NULL);
            
            fsm.bIOCPInited = TRUE;

            fsm.SetAction(FSM_ACTION_RECEIVE);

            DWORD timeout = GetTimeoutValue(WINHTTP_OPTION_RECEIVE_TIMEOUT);

            if (timeout != INFINITE)
            {
                fsm.SetTimeout(timeout);
                fsm.SetOnAsyncList(TRUE);
                error = QueueSocketWorkItem(Fsm, m_Socket);

                INET_ASSERT (error == ERROR_IO_PENDING);

                if (error != ERROR_IO_PENDING)
                {
                    // 2 causes - both irrecoverable
                    // 1. no global pointer to ICAsyncThread
                    // OR 2. no threadinfo or SelectThread.
                    // so bail!
                    fsm.bIOCPInited = FALSE;
                    GetAndSetCurrentFsm(NULL);
                    fsm.SetOnAsyncList(FALSE);
                    fsm.SetErrorState(error);
                    goto error_exit;
                }
            }

            _lpWrapOverlappedRecv->Reference(); // to keep this ICSocket=>the Overlapped struct valid beyong the WSARecv() call.
            _lpWrapOverlappedRecv->Reference(); // to make sure it stays alive for the IOCP to get the fsm off it.
            
            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("calling WSARecv() blocked, socket %#x/port %d\n",
                        m_Socket,
                        m_SourcePort
                        ));

            DEBUG_ENTER((DBG_API,
                             Dword,
                             "***WSARecv",
                             "(m_Socket)%#x, (wsabuf.buf)%#x, (wsabuf.len)%#x, (this)%#x, (overlapped)%#x, (fsm)%#x",
                             m_Socket,
                             wsabuf.buf,
                             wsabuf.len,
                             this,
                             lpOverlapped,
                             &fsm
                             ));

            nError = _I_WSARecv(m_Socket,
                                &wsabuf,
                                1,
                                (LPDWORD)&nRead,
                                &dwFlags,
                                lpOverlapped,
                                NULL);     
        
            DEBUG_LEAVE(nError);

            lpWrapOverlapped->Dereference(); // release the first reference.
            
            DEBUG_PRINT(SOCKETS,
                        ERROR,
                        ("WSARecv() returns %d (%s) with nRead=%d bytes\n",
                        nError,
                        InternetMapError(nError),
                        nRead
                        ));

            //VENKATKBUG - omitting hackorama, but may need to put it in just the same.

            if (nError == 0)
            {
#if INET_DEBUG
                InterlockedIncrement(&g_cWSACompletions);
#endif
                 error = ERROR_IO_PENDING;
                 break;
            }
            else // if! nError == 0
            {
                INET_ASSERT (nError == SOCKET_ERROR);
                
                error = _I_WSAGetLastError();
                if (error == WSA_IO_PENDING)
                {
#if INET_DEBUG
                    InterlockedIncrement(&g_cWSACompletions);
#endif
                    error = ERROR_IO_PENDING;
                    break;
                }
                else
                {
                    // no IOCompletion here.
                    // VENKATKBUG_ strictly informational assert - remove later.
                    // DWORD dwError = error; //dummy for debugging
                    // INET_ASSERT (FALSE);
                    if (fsm.HasTimeout())
                    {
                        if (!RemoveFsmFromAsyncList(&fsm))
                        {
                            //failure! the select thread already enforced timeout and updated state
                            //informational assert.
                            //VENKATK_BUG-enable later INET_ASSERT (FALSE && "COOL: select enforced timeout");
                        }
                    }

                    lpWrapOverlapped->Dereference(); // release the IOCP-based reference.
                    GetAndSetCurrentFsm(NULL);
                    
                    //cannot handle SF_NO_WAIT and SF_WAIT
                    error = MapInternetError(error);

                    //VENKATKBUG - retry for certain error types.
                    break;
                }
            } // if! nError == 0
        }
        else //if IsNonBlocking()
        {
            nRead = _I_recv(m_Socket,
                            (char FAR *)fsm.m_lpBuffer,
                            (int)fsm.m_dwBufferLeft,
                            0
                            );
                            
            //
            // hackorama # 95, subparagraph 13
            //
            // RLF 07/15/96
            //
            // On Win95 (wouldn't you know it?) in low-memory conditions, we can get
            // into a situation where one or more pages of our receive buffer is
            // filled with zeroes.
            //
            // The reason this happens is that the winsock VxD creates an alias to
            // our buffer, locks the buffer & writes into it, then marks the alias
            // dirty, but not the original buffer. If the buffer is paged out then
            // back in, one or more pages are zeroed because the O/S didn't know
            // they had been written to; it decides to initialize the pages with
            // zeroes.
            //
            // We try to circumvent this by immediately probing each page (we read
            // a byte then write it back).
            //
            // This doesn't fix the problem, just makes the window a lot smaller.
            // However, apart from writing a device driver or modifying the VxD,
            // there's not much else we can do
            //

            ProbeWriteBuffer(fsm.m_lpBuffer, fsm.m_dwBufferLeft);

            if (nRead == 0) 
            {
                //
                // done
                //

                DEBUG_PRINT(SOCKETS,
                            INFO,
                            ("EOF connection %#x/port %d\n",
                            m_Socket,
                            m_SourcePort
                            ));

                fsm.m_bEof = TRUE;
                break;
            } 
            else if (nRead > 0) 
            {
                DEBUG_PRINT(SOCKETS,
                            INFO,
                            ("received %d bytes from socket %#x/port %d\n",
                            nRead,
                            m_Socket,
                            m_SourcePort
                            ));

                fsm.m_dwBytesReceived += nRead;
                fsm.m_dwBytesRead += nRead;
                fsm.m_lpBuffer += nRead;
                fsm.m_dwBufferLeft -= nRead;

                //
                // if SF_RECEIVE_ALL is not set then the caller just wants us to
                // perform a single receive. We're done
                //

                if (!(fsm.m_dwFlags & SF_RECEIVE_ALL) ) 
                {
                    break;
                }

                //
                // if we've filled the current buffer, then either we're done, or
                // the caller wants us to receive the entire response, in which
                // case we attempt to grow the buffer and receive the next part
                // of the message. Note that we may have already received the
                // entire response if it just happened to be the same size as our
                // buffer
                //

                // BUGBUG [arthurbi] we're broken for SSL/PCT case !!!
                //  We need to handle expanding the buffer.
                //

                if (fsm.m_dwBufferLeft == 0) 
                {
                    //
                    // BUGBUG - RLF - why are we testing for SF_DECRYPT here?
                    //

                    if (!(fsm.m_dwFlags & SF_EXPAND) || (m_dwFlags & SF_DECRYPT)) 
                    {
                        break;
                    } 
                    else 
                    {
                        //
                        // BUGBUG - the buffer increment should come from the handle
                        //          object
                        //

                        fsm.m_dwBufferLeft = DEFAULT_RECEIVE_BUFFER_INCREMENT;
                        fsm.m_dwBufferLength += DEFAULT_RECEIVE_BUFFER_INCREMENT;

                        DEBUG_PRINT(SOCKETS,
                                    INFO,
                                    ("resizing %#x to %d\n",
                                    fsm.m_hBuffer,
                                    fsm.m_dwBufferLength
                                    ));

                        fsm.m_hBuffer = ResizeBuffer(fsm.m_hBuffer,
                                                     fsm.m_dwBufferLength,
                                                     FALSE
                                                     );
                        if (fsm.m_hBuffer != NULL) 
                        {
                            fsm.m_lpBuffer = (LPBYTE)fsm.m_hBuffer + fsm.m_dwBytesReceived;
                        } 
                        else 
                        {
                            error = GetLastError();

                            INET_ASSERT(error != ERROR_SUCCESS);

                            fsm.m_dwBytesReceived = 0;
                            fsm.m_dwBufferLength = 0;
                            fsm.m_dwBufferLeft = 0;
                        }
                    }
                }//if fsm.m_dwBufferLeft == 0
            } 
            else //if nRead >= 0
            {
                if (IsAborted()) 
                {
                    error = ERROR_WINHTTP_OPERATION_CANCELLED;
                    break;
                } 
                else 
                {
                    error = _I_WSAGetLastError();
                    //
                    // a real error occurred. We need to get out
                    //

                    DEBUG_PRINT(SOCKETS,
                                ERROR,
                                ("recv() on socket %#x/port %d returns %d\n",
                                m_Socket,
                                m_SourcePort,
                                error
                                ));

                    error = MapInternetError(error);
                    break;
                }
            }//if! nRead >= 0
        }// if! IsNonBlocking()
    } 
    while (error == ERROR_SUCCESS);

error_exit:

    //
    // get correct error based on settings
    //

    if (error == ERROR_IO_PENDING) 
    {
        goto done;
    } 
    else if (IsAborted()) 
    {
        error = ERROR_WINHTTP_OPERATION_CANCELLED;
    }

    if (pObject != NULL) {
        pObject->ResetAbortHandle();
    }

    if (error == ERROR_SUCCESS) {

        //
        // inform the app that we finished, and tell it how much we received
        // this time
        //

        if (fsm.m_dwFlags & SF_INDICATE) {
            DWORD dwBytesRead = fsm.m_dwBytesRead;
            InternetIndicateStatus(WINHTTP_CALLBACK_STATUS_RESPONSE_RECEIVED,
                                   &dwBytesRead,
                                   sizeof(dwBytesRead)
                                   );
        }

        //
        // if we received the entire response and the caller specified
        // SF_COMPRESS then we shrink the buffer to fit. We may end up growing
        // the buffer to contain dwExtraSpace if it is not zero and we just
        // happened to fill the current buffer
        //

        if (fsm.m_bEof && (fsm.m_dwFlags & SF_COMPRESS)) {

            fsm.m_dwBufferLeft = fsm.m_dwExtraSpace;

            //
            // include any extra that the caller required
            //

            fsm.m_dwBufferLength = fsm.m_dwBytesReceived + fsm.m_dwExtraSpace;

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("shrinking buffer %#x to %d (%#x) bytes (includes %d extra)\n",
                        fsm.m_hBuffer,
                        fsm.m_dwBufferLength,
                        fsm.m_dwBufferLength,
                        fsm.m_dwExtraSpace
                        ));

            fsm.m_hBuffer = ResizeBuffer(fsm.m_hBuffer,
                                         fsm.m_dwBufferLength,
                                         FALSE
                                         );

            INET_ASSERT((fsm.m_hBuffer == NULL)
                        ? ((fsm.m_dwBytesReceived + fsm.m_dwExtraSpace) == 0)
                        : TRUE
                        );

        }

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("read %d bytes @ %#x from socket %#x/port %d\n",
                    fsm.m_dwBytesRead,
                    (LPBYTE)fsm.m_hBuffer + *fsm.m_lpdwBytesReceived,
                    m_Socket,
                    m_SourcePort
                    ));

        DEBUG_DUMP_API(SOCKETS,
                       "received data:\n",
                       (LPBYTE)fsm.m_hBuffer + *fsm.m_lpdwBytesReceived,
                       fsm.m_dwBytesRead
                       );

    } else if (fsm.m_bAllocated && (fsm.m_hBuffer != NULL)) {

        //
        // if we failed but allocated a buffer then we need to free it (we were
        // leaking this buffer if the request was cancelled)
        //

        fsm.m_hBuffer = FREE_MEMORY(fsm.m_hBuffer);

        INET_ASSERT(fsm.m_hBuffer == NULL);

        fsm.m_dwBufferLength = 0;
        fsm.m_dwBufferLeft = 0;
        fsm.m_dwBytesReceived = 0;
        fsm.m_bEof = TRUE;
    }

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("returning: lpBuffer=%#x, bufferLength=%d, bufferLeft=%d, bytesReceived=%d\n",
                fsm.m_hBuffer,
                fsm.m_dwBufferLength,
                fsm.m_dwBufferLeft,
                fsm.m_dwBytesReceived
                ));

    //
    // update output parameters
    //

    *fsm.m_lplpBuffer = (LPVOID)fsm.m_hBuffer;
    *fsm.m_lpdwBufferLength = fsm.m_dwBufferLength;
    *fsm.m_lpdwBufferRemaining = fsm.m_dwBufferLeft;
    *fsm.m_lpdwBytesReceived = fsm.m_dwBytesReceived;
    *fsm.m_lpbEof = fsm.m_bEof;

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone(error);
    }

done:

    DEBUG_LEAVE(error);

    return error;
}

//
//DWORD
//ICSocket::ReceiveFrom(
//    IN LPVOID lpBuffer,
//    IN DWORD dwBufferLength,
//    OUT LPDWORD lpdwBytesReceived,
//    OUT LPSOCKADDR lpDestination OPTIONAL,
//    IN OUT LPDWORD lpdwDestinationLength OPTIONAL,
//    IN DWORD dwTimeout,
//    IN DWORD dwWinsockFlags,
//    IN DWORD dwFlags
//    )
//
///*++
//
//Routine Description:
//
//    Wrapper for recvfrom()
//
//Arguments:
//
//    lpBuffer                - pointer to buffer where data returned
//
//    dwBufferLength          - size of lpBuffer in bytes
//
//    lpdwBytesReceived       - pointer to returned number of bytes received
//
//    lpDestination           - pointer to returned destination address
//
//    lpdwDestinationLength   - IN: size of lpDestination buffer
//                              OUT: length of returned destination address info
//
//    dwTimeout               - number of milliseconds to wait for response
//
//    dwWinsockFlags          - flags to pass through to recvfrom()
//
//    dwFlags                 - ICSocket flags
//
//Return Value:
//
//    DWORD
//        Success - ERROR_SUCCESS
//
//        Failure - ERROR_WINHTTP_OPERATION_CANCELLED
//                    The operation was cancelled by the caller
//
//                  ERROR_WINHTTP_TIMEOUT
//                    The operation timed out
//
//                  ERROR_WINHTTP_CONNECTION_ERROR
//                    An error occurred. We approximate to connection reset
//
//                  WSA error
//                    Some other sockets error occurred
//
//--*/
//
//{
//    DEBUG_ENTER((DBG_SOCKETS,
//                 Dword,
//                 "ICSocket::ReceiveFrom",
//                 "{%#x} %#x, %d, %#x, %#x, %#x [%d], %d, %#x, %#x",
//                 m_Socket,
//                 lpBuffer,
//                 dwBufferLength,
//                 lpdwBytesReceived,
//                 lpDestination,
//                 lpdwDestinationLength,
//                 lpdwDestinationLength ? *lpdwDestinationLength : 0,
//                 dwTimeout,
//                 dwWinsockFlags,
//                 dwFlags
//                 ));
//
//    //INET_ASSERT(IsSocketValid());
//    INET_ASSERT(lpdwBytesReceived != NULL);
//
//    //
//    // most ICSocket flags not allowed for this operation
//    //
//
//    INET_ASSERT(!(dwFlags
//                  & (SF_ENCRYPT
//                     | SF_DECRYPT
//                     | SF_EXPAND
//                     | SF_COMPRESS
//                     | SF_SENDING_DATA
//                     | SF_SCH_REDO
//                     )
//                  )
//                );
//
//    DWORD error = ERROR_SUCCESS;
//    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
//    BOOL bStopOfflineTimer = FALSE;
//    BOOL fNonBlocking;
//    DWORD bytesReceived;
//    INTERNET_HANDLE_OBJECT * pObject = NULL;
//
//    if (lpThreadInfo == NULL) {
//
//        INET_ASSERT(FALSE);
//
//        error = ERROR_WINHTTP_INTERNAL_ERROR;
//        goto quit;
//    }
//
//    //
//    // the socket may have already been aborted
//    //
//
//    if (IsAborted()) {
//        error = ERROR_WINHTTP_OPERATION_CANCELLED;
//        goto quit;
//    }
//
//    //
//    // let another thread know the socket to cancel if it wants to kill this
//    // operation
//    //
//
//    pObject = (INTERNET_HANDLE_OBJECT * )lpThreadInfo->hObjectMapped;
//    if (pObject != NULL) {
//        pObject->SetAbortHandle(this);
//    }
//
//    //
//    // keep the app informed (if requested to do so)
//    //
//
//    if (dwFlags & SF_INDICATE) {
//        InternetIndicateStatus(INTERNET_STATUS_RECEIVING_RESPONSE,
//                               NULL,
//                               0
//                               );
//    }
//
//    //
//    // if we are in async (== non-blocking) mode, let the async request
//    // scheduler know what operation we will be waiting on
//    //
//
//    fNonBlocking = lpThreadInfo->IsAsyncWorkerThread;
//    if (fNonBlocking) {
//
//        INET_ASSERT(lpThreadInfo->lpArb != NULL);
//
//        SET_ARB_SOCKET_OPERATION_TIMEOUT(lpThreadInfo->lpArb,
//                                         m_Socket,
//                                         RECEIVE,
//                                         dwTimeout
//                                         );
//
//        DWORD timerError = StartOfflineTimerForArb(lpThreadInfo->lpArb);
//
//        INET_ASSERT(timerError == ERROR_SUCCESS);
//
//        bStopOfflineTimer = (timerError == ERROR_SUCCESS) ? TRUE : FALSE;
//    }
//
//    int nBytes;
//
//    bytesReceived = 0;
//
//    do {
//
//        nBytes = _I_recvfrom(m_Socket,
//                             (char FAR *)lpBuffer + bytesReceived,
//                             dwBufferLength,
//                             dwWinsockFlags,
//                             lpDestination,
//                             (int FAR *)lpdwDestinationLength
//                             );
//        if (nBytes != SOCKET_ERROR) {
//
//            DEBUG_PRINT(SOCKETS,
//                        INFO,
//                        ("received %d bytes from socket %#x\n",
//                        nBytes,
//                        m_Socket
//                        ));
//
//            INET_ASSERT(nBytes > 0);
//
//            bytesReceived += nBytes;
//            dwBufferLength -= nBytes;
//
//            //
//            // for recvfrom(), we quit as soon as we get some data
//            //
//
//            error = ERROR_SUCCESS;
//            break;
//        } else {
//            error = _I_WSAGetLastError();
//            if ((error == WSAEWOULDBLOCK) && fNonBlocking) {
//
//                INET_ASSERT(_dwFlags & SF_NON_BLOCKING);
//
//                //
//                // if this function is called expedited (we expect the request
//                // to complete quickly) then we test to see if it already
//                // completed before switching to the async scheduler
//                //
//
//                BOOL switchFiber = TRUE;
//
//                if (dwFlags & SF_EXPEDITED) {
//                    error = WaitForReceive(1);
//
//                    //
//                    // if the socket is already readable then we don't switch
//                    // fibers (only to virtually immediately come back here,
//                    // incurring a couple of thread switches
//                    //
//
//                    if (error == ERROR_SUCCESS) {
//                        switchFiber = FALSE;
//
//                        //
//                        // use this error to go round loop once again
//                        //
//
//                        error = WSAEWOULDBLOCK;
//                    }
//                }
//                if (switchFiber) {
//
//                    DEBUG_PRINT(SOCKETS,
//                                INFO,
//                                ("recvfrom(%#x) blocked\n",
//                                m_Socket
//                                ));
//
//                    lpThreadInfo->lpArb->Header.dwResultCode = ERROR_SUCCESS;
//
//                    SwitchToAsyncScheduler(m_Socket);
//
//                    error = lpThreadInfo->lpArb->Header.dwResultCode;
//
//                    DEBUG_PRINT(SOCKETS,
//                                INFO,
//                                ("recvfrom(%#x) resumed, returns %s\n",
//                                m_Socket,
//                                InternetMapError(error)
//                                ));
//
//                    if (error != ERROR_SUCCESS) {
//                    } else {
//
//                        //
//                        // use this error to force another loop now we believe
//                        // we have the data
//                        //
//
//                        error = WSAEWOULDBLOCK;
//                    }
//                }
//            } else {
//
//                //
//                // real error
//                //
//
//                error = MapInternetError(error);
//            }
//        }
//    } while (error == WSAEWOULDBLOCK);
//
//    if (error == ERROR_SUCCESS) {
//
//        DEBUG_DUMP(SOCKETS,
//                   "received data:\n",
//                   lpBuffer,
//                   bytesReceived
//                   );
//
//    }
//
//    if (fNonBlocking) {
//
//        INET_ASSERT(lpThreadInfo->lpArb != NULL);
//
//        SET_ARB_SOCKET_OPERATION(lpThreadInfo->lpArb, INVALID_SOCKET, RECEIVE);
//
//        if (bStopOfflineTimer) {
//            StopOfflineTimerForArb(lpThreadInfo->lpArb);
//        }
//    }
//
//    //
//    // inform the app that we finished, and tell it how much we received this
//    // time
//    //
//
//    if ((dwFlags & SF_INDICATE) && (error == ERROR_SUCCESS)) {
//        InternetIndicateStatus(INTERNET_STATUS_RESPONSE_RECEIVED,
//                               &bytesReceived,
//                               sizeof(bytesReceived)
//                               );
//    }
//
//    *lpdwBytesReceived = bytesReceived;
//
//    if (pObject != NULL) {
//        pObject->ResetAbortHandle();
//
//        //
//        // if the operation has been cancelled, then this error overrides any
//        // other
//        //
//
//        //if (pObject->IsInvalidated()) {
//        //    error = pObject->GetError();
//        //    if (error == ERROR_SUCCESS) {
//        //        error = ERROR_WINHTTP_OPERATION_CANCELLED;
//        //    }
//        //}
//        if (IsAborted()) {
//            error = ERROR_WINHTTP_OPERATION_CANCELLED;
//        }
//    }
//
//quit:
//
//    INET_ASSERT((pObject != NULL) ? (pObject->GetAbortHandle() == NULL) : TRUE);
//
//    DEBUG_LEAVE(error);
//
//    return error;
//}
//

DWORD
ICSocket::DataAvailable(
    OUT LPDWORD lpdwBytesAvailable
    )

/*++

Routine Description:

    Determines the amount of data available to be read on the socket

Arguments:

    lpdwBytesAvailable  - pointer to returned data available


Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::DataAvailable",
                 "%#x",
                 lpdwBytesAvailable
                 ));

    //
    // sanity check parameters
    //

    INET_ASSERT(m_Socket != INVALID_SOCKET);
    INET_ASSERT(lpdwBytesAvailable != NULL);

    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
    DWORD error;

    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto quit;
    }

    //
    // the socket may already be aborted
    //

    if (IsAborted()) {
        error = ERROR_WINHTTP_OPERATION_CANCELLED;
        goto quit;
    }

    //
    // if we're in async mode, we have to perform a zero-length receive in order
    // to get the information from the socket
    //

    int nRead;

    //
    // we actually have to peek a non-zero number of bytes because on Win95,
    // attempting to perform a receive of 0 bytes (to put the socket in blocked
    // read mode) results in zero bytes being returned, and the socket never
    // blocks
    //

    nRead = _I_recv(m_Socket, NULL, 0, 0);

    //
    // N.B. buf[] will only ever be used if there is data to peek right now
    //

    char buf[1];

    PERF_LOG(PE_PEEK_RECEIVE_START,
             m_Socket,
             lpThreadInfo->ThreadId,
             lpThreadInfo->hObject
             );

    nRead = _I_recv(m_Socket, buf, sizeof(buf), MSG_PEEK);
    if (nRead == SOCKET_ERROR) {
        error = _I_WSAGetLastError();
        if ((error == WSAEWOULDBLOCK) && (m_dwFlags & SF_NON_BLOCKING)) {

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("peek(1) blocked, socket %#x\n",
                        m_Socket
                        ));

            PERF_LOG(PE_PEEK_RECEIVE_END,
                     m_Socket,
                     lpThreadInfo->ThreadId,
                     lpThreadInfo->hObject
                     );

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("peek(1) resumed, socket %#x, returns %s\n",
                        m_Socket,
                        InternetMapError(error)
                        ));
        }
    /*} else if ((nRead == 0) && !(m_dwFlags & SF_NON_BLOCKING)) {

        PERF_LOG(PE_PEEK_RECEIVE_END,
                 m_Socket,
                 lpThreadInfo->ThreadId,
                 lpThreadInfo->hObject
                 );

        //
        // nothing to peek right now. If the socket is in blocking mode then
        // we wait here until there is something to receive
        //

        error = WaitForReceive(INFINITE);*/
    } else {

        PERF_LOG(PE_PEEK_RECEIVE_END,
                 m_Socket,
                 lpThreadInfo->ThreadId,
                 lpThreadInfo->hObject
                 );

        //
        // nRead == 0 but non-blocking, or nRead > 0
        //

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("peek(1) returns %d\n",
                    nRead
                    ));

        error = ERROR_SUCCESS;
    }

    if (error == ERROR_SUCCESS) {

        //
        // now we can get the amount from the socket
        //

        error = (DWORD)_I_ioctlsocket(m_Socket,
                                      FIONREAD,
                                      (u_long FAR *)lpdwBytesAvailable
                                      );

        //
        // N.B. assumes ioctlsocket() returns 0 on success == ERROR_SUCCESS
        //

        if (error == SOCKET_ERROR) {
            error = _I_WSAGetLastError();
        } else {

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("ioctlsocket(FIONREAD) returns %d\n",
                        *lpdwBytesAvailable
                        ));

        }
    }

    //
    // map any sockets error to WinInet error
    //

    if (error != ERROR_SUCCESS) {
        error = MapInternetError(error);
    }

quit:

    DEBUG_LEAVE(error);

    return error;
}

//
//DWORD
//ICSocket::DataAvailable2(
//    OUT LPVOID lpBuffer,
//    IN DWORD dwBufferLength,
//    OUT LPDWORD lpdwBytesAvailable
//    )
//
///*++
//
//Routine Description:
//
//    Determines the amount of data available to be read on the socket
//
//Arguments:
//
//    lplpBuffer          - pointer to pointer to buffer where data read
//
//    dwBufferLength      - size of the buffer
//
//    lpdwBytesAvailable  - pointer to returned data available
//
//
//Return Value:
//
//    DWORD
//        Success - ERROR_SUCCESS
//
//        Failure - WSA error
//
//--*/
//
//{
//    DEBUG_ENTER((DBG_SOCKETS,
//                 Dword,
//                 "ICSocket::DataAvailable2",
//                 "%#x, %d, %#x",
//                 lpBuffer,
//                 dwBufferLength,
//                 lpdwBytesAvailable
//                 ));
//
//    //
//    // sanity check parameters
//    //
//
//    INET_ASSERT(lpdwBytesAvailable != NULL);
//
//    //
//    // we're about to receive data from the socket. The amount of data currently
//    // on hand must be 0
//    //
//
//    INET_ASSERT(*lpdwBytesAvailable == 0);
//    INET_ASSERT(lpBuffer != NULL);
//
//    DWORD error;
//
//    //
//    // new scheme: actually read the data from sockets into our buffer. This is
//    // the only way on Win95 to determine the correct number of bytes available.
//    // We only perform a single receive
//    //
//
//    DWORD bufferLeft = dwBufferLength;
//    BOOL eof;
//
//    error = Receive(&lpBuffer,
//                    &dwBufferLength,
//                    &bufferLeft,  // don't care about this
//                    lpdwBytesAvailable,
//                    0,
//                    0,
//                    &eof          // don't care about this either
//                    );
//
//    DEBUG_LEAVE(error);
//
//    return error;
//}


DWORD
ICSocket::WaitForReceive(
    IN DWORD Timeout
    )

/*++

Routine Description:

    Waits until a receive socket becomes unblocked (readable)

Arguments:

    Timeout - milliseconds to wait, or INFINITE

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error
                    sockets error

                  ERROR_WINHTTP_TIMEOUT
                    Receive timed out

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::WaitForReceive",
                 "{%#x} %d",
                 m_Socket,
                 Timeout
                 ));

    struct fd_set read_fds;
    struct fd_set except_fds;

    FD_ZERO(&read_fds);
    FD_ZERO(&except_fds);

    FD_SET(m_Socket, &read_fds);
    FD_SET(m_Socket, &except_fds);

    int n;

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("waiting on socket %#x\n",
                m_Socket
                ));

    TIMEVAL timeout;
    LPTIMEVAL lpTimeout;

    if (Timeout != INFINITE) {
        timeout.tv_sec  = Timeout / 1000;
        timeout.tv_usec = (Timeout % 1000) * 1000;
        lpTimeout = &timeout;
    } else {
        lpTimeout = NULL;
    }

    n = _I_select(0, &read_fds, NULL, &except_fds, lpTimeout);

    DWORD error;

    if (n == SOCKET_ERROR) {

        //
        // real error?
        //

        error = _I_WSAGetLastError();

        DEBUG_PRINT(SOCKETS,
                    ERROR,
                    ("select() returns %d\n",
                    error
                    ));

        INET_ASSERT(FALSE);

        error = MapInternetError(error);
    } else if (n != 0) {
        if (FD_ISSET(m_Socket, &except_fds)) {

            DEBUG_PRINT(SOCKETS,
                        ERROR,
                        ("socket %#x exception\n",
                        m_Socket
                        ));

            error = ERROR_WINHTTP_CONNECTION_ERROR;
        } else {

            //
            // it *must* be unblocked (i.e. readable)
            //

            INET_ASSERT(FD_ISSET(m_Socket, &read_fds));

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("socket %#x unblocked\n",
                        m_Socket
                        ));

            error = ERROR_SUCCESS;
        }
    } else {

        DEBUG_PRINT(SOCKETS,
                    ERROR,
                    ("timed out\n"
                    ));

        error = ERROR_WINHTTP_TIMEOUT;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::AllocateQueryBuffer(
    OUT LPVOID * lplpBuffer,
    OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    Allocates a query buffer for the socket

Arguments:

    lplpBuffer          - returned pointer to allocated query buffer

    lpdwBufferLength    - returned length of allocated query buffer

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::AllocateQueryBuffer",
                 "{%#x/%d} %#x, %#x",
                 GetSocket(),
                 GetSourcePort(),
                 lplpBuffer,
                 lpdwBufferLength
                 ));

    DWORD error;
    DWORD bufferLength;
    DWORD size = sizeof(bufferLength);

    int serr = _I_getsockopt(m_Socket,
                             SOL_SOCKET,
                             SO_RCVBUF,
                             (char FAR *)&bufferLength,
                             (int FAR *)&size
                             );
    if (serr != SOCKET_ERROR) {
        bufferLength = min(bufferLength, DEFAULT_SOCKET_QUERY_BUFFER_LENGTH);
        if (bufferLength == 0) {
            bufferLength = DEFAULT_SOCKET_QUERY_BUFFER_LENGTH;
        }
        *lplpBuffer = (LPVOID)ALLOCATE_MEMORY(LMEM_FIXED, bufferLength);
        if (*lplpBuffer != NULL) {
            *lpdwBufferLength = bufferLength;
            error = ERROR_SUCCESS;
        } else {
            error = ERROR_NOT_ENOUGH_MEMORY;
        }
    } else {
        error = MapInternetError(_I_WSAGetLastError());
    }

    DEBUG_LEAVE(error);

    return error;
}

//
//VOID
//ICSocket::FreeQueryBuffer(
//    IN LPVOID lpBuffer
//    )
//
///*++
//
//Routine Description:
//
//    description-of-function.
//
//Arguments:
//
//    lpBuffer    -
//
//Return Value:
//
//    None.
//
//--*/
//
//{
//    lpBuffer = (LPVOID)FREE_MEMORY((HLOCAL)lpBuffer);
//
//    INET_ASSERT(lpBuffer == NULL);
//}

//
//DWORD
//ICSocket::GetBytesAvailable(
//    OUT LPDWORD lpdwBytesAvailable
//    )
//
///*++
//
//Routine Description:
//
//    Determines amount of data available to be read from socket
//
//Arguments:
//
//    lpdwBytesAvailable  - pointer to returned available length
//
//Return Value:
//
//    DWORD
//        Success - ERROR_SUCCESS
//
//        Failure -
//
//--*/
//
//{
//    DEBUG_ENTER((DBG_SOCKETS,
//                 Dword,
//                 "ICSocket::GetBytesAvailable",
//                 "{%#x} %#x",
//                 m_Socket,
//                 lpdwBytesAvailable
//                 ));
//
//    //INET_ASSERT(m_Socket != INVALID_SOCKET);
//    INET_ASSERT(lpdwBytesAvailable != NULL);
//
//    //
//    // get the amount from the socket. If the socket has been reset or shutdown
//    // by the server then we expect to get an error, else 0 (== ERROR_SUCCESS)
//    //
//
//    DWORD error = (DWORD)_I_ioctlsocket(m_Socket,
//                                        FIONREAD,
//                                        (u_long FAR *)lpdwBytesAvailable
//                                        );
//    if (error == SOCKET_ERROR) {
//        error = _I_WSAGetLastError();
//    } else {
//
//        DEBUG_PRINT(SOCKETS,
//                    INFO,
//                    ("ioctlsocket(FIONREAD) returns %d\n",
//                    *lpdwBytesAvailable
//                    ));
//
//    }
//
//    DEBUG_LEAVE(error);
//
//    return error;
//}
//

DWORD
ICSocket::CreateSocket(
    IN DWORD dwFlags,
    IN int nAddressFamily,
    IN int nType,
    IN int nProtocol
    )

/*++

Routine Description:

    Opens a socket handle for this ICSocket object

Arguments:

    dwFlags         - flags to use for new socket

    nAddressFamily  - parameter to socket()

    nType           - parameter to socket()

    nProtocol       - parameter to socket()

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error mapped to INTERNET error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::CreateSocket",
                 "%#x, %s (%d), %s (%d), %s (%d)",
                 dwFlags,
                 MapFamily(nAddressFamily),
                 nAddressFamily,
                 MapSock(nType),
                 nType,
                 MapProto(nProtocol),
                 nProtocol
                 ));

    INET_ASSERT(m_Socket == INVALID_SOCKET);

    int serr;
    DWORD error;
    DWORD dwConnFlags;

    m_Socket = _I_socket(nAddressFamily, nType, nProtocol);
    if (m_Socket == INVALID_SOCKET) {

        DEBUG_PRINT(SOCKETS,
                    ERROR,
                    ("failed to create socket\n"
                    ));

        goto socket_error;
    }

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("created socket %#x\n",
                m_Socket
                ));

    if (dwFlags & SF_NON_BLOCKING) {
        INET_ASSERT(FALSE);

        error = SetNonBlockingMode(TRUE);
        if (error == ERROR_SUCCESS) {

            //
            //  ICSocket is non-blocking socket object
            //

            m_dwFlags |= SF_NON_BLOCKING;
        } else {
            goto close_socket;
        }
    }

    //
    // bind our data socket to an endpoint, so that we know an address to
    // tell the FTP server
    //

    SOCKADDR_IN ourDataAddr;

    ourDataAddr.sin_family = AF_INET;
    *((long *)&ourDataAddr.sin_addr) = INADDR_ANY;
    ourDataAddr.sin_port = 0;

    serr = _I_bind(m_Socket,
                   (PSOCKADDR)&ourDataAddr,
                   sizeof(ourDataAddr)
                   );

    if (serr == SOCKET_ERROR) {
        goto socket_error;
    }

    error = ERROR_SUCCESS;

quit:

    DEBUG_LEAVE(error);

    return error;

socket_error:

    error = MapInternetError(_I_WSAGetLastError());

close_socket:

    Close();
    m_dwFlags &= ~SF_NON_BLOCKING;
    goto quit;
}


DWORD
ICSocket::GetSockName(
    PSOCKADDR psaSockName
    )
{
    INET_ASSERT(m_Socket != INVALID_SOCKET);
    INET_ASSERT(psaSockName);

    int serr;
    int cbAddrLen;
    DWORD error;

    serr = ERROR_SUCCESS;
    error = ERROR_SUCCESS;

    //
    // get the address info .
    //

    cbAddrLen = sizeof(SOCKADDR_IN);


    serr = _I_getsockname(m_Socket,
                          psaSockName,
                          &cbAddrLen
                          );


    if ( serr == SOCKET_ERROR )
    {
        error = _I_WSAGetLastError();
    }

    return error;
}


DWORD
ICSocket::Listen(
    VOID
    )
{
    INET_ASSERT(m_Socket != INVALID_SOCKET);

    DWORD error = ERROR_SUCCESS;

    //
    // Listen on the socket.
    //

    if (_I_listen(m_Socket, 1) == SOCKET_ERROR) {
        error = _I_WSAGetLastError();
    }
    return error;
}


DWORD
ICSocket::DirectConnect(
    PSOCKADDR psaRemoteSock
    )

/*++

Routine Description:

    Connects a ICSocket to the remote address

Arguments:

    psaRemoteSock   - pointer to remote socket address (TCP/IP!)

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error mapped to INTERNET error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::DirectConnectSocket",
                 "{%#x} %#x",
                 m_Socket,
                 psaRemoteSock
                 ));

    INET_ASSERT(m_Socket != INVALID_SOCKET);

    DWORD error;
    BOOL bStopOfflineTimer = FALSE;

    //
    // we need the thread info for async processing
    //

    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto quit;
    }

    BOOL isAsync;

    isAsync = lpThreadInfo->IsAsyncWorkerThread;

    //
    // BUGBUG - this is essentially common to ConnectSocket()
    //

    //
    // let another thread know the socket to cancel if it wants to kill
    // this operation
    //

    INTERNET_HANDLE_OBJECT * pObject;

    pObject = (INTERNET_HANDLE_OBJECT * )lpThreadInfo->hObjectMapped;
    if (pObject != NULL) {
        pObject->SetAbortHandle(this);
    }

#if defined(UNIX) && defined(ux10)
    DEBUG_PRINT(SOCKETS,
                INFO,
                ("connecting to remote address %d.%d.%d.%d, port %d\n",
                ((LPBYTE)&((LPSOCKADDR_IN)psaRemoteSock)->sin_addr)[0],
                ((LPBYTE)&((LPSOCKADDR_IN)psaRemoteSock)->sin_addr)[1],
                ((LPBYTE)&((LPSOCKADDR_IN)psaRemoteSock)->sin_addr)[2],
                ((LPBYTE)&((LPSOCKADDR_IN)psaRemoteSock)->sin_addr)[3],
                _I_ntohs(((LPSOCKADDR_IN)psaRemoteSock)->sin_port)
                ));
#else
    DEBUG_PRINT(SOCKETS,
                INFO,
                ("connecting to remote address %d.%d.%d.%d, port %d\n",
                ((LPSOCKADDR_IN)psaRemoteSock)->sin_addr.S_un.S_un_b.s_b1,
                ((LPSOCKADDR_IN)psaRemoteSock)->sin_addr.S_un.S_un_b.s_b2,
                ((LPSOCKADDR_IN)psaRemoteSock)->sin_addr.S_un.S_un_b.s_b3,
                ((LPSOCKADDR_IN)psaRemoteSock)->sin_addr.S_un.S_un_b.s_b4,
                _I_ntohs(((LPSOCKADDR_IN)psaRemoteSock)->sin_port)
                ));
#endif

    DWORD connectTime;

    connectTime = GetTickCountWrap();

    int serr;

    PERF_LOG(PE_CONNECT_START,
             m_Socket,
             lpThreadInfo->ThreadId,
             lpThreadInfo->hObject
             );

    if (IsSocks()) {
        serr = SocksConnect((LPSOCKADDR_IN)psaRemoteSock, sizeof(SOCKADDR_IN));
    } else {
        serr = _I_connect(m_Socket, psaRemoteSock, sizeof(SOCKADDR_IN));
    }
    if (serr != 0) {
        error = _I_WSAGetLastError();

        //
        // if we are using non-blocking sockets then we need to wait until
        // the connect has completed, or an error occurs
        //

        if (isAsync) {
            if (error == WSAEWOULDBLOCK) {

                DEBUG_PRINT(SOCKETS,
                            INFO,
                            ("connect() blocked, socket %#x\n",
                            m_Socket
                            ));

                PERF_LOG(PE_CONNECT_END,
                         m_Socket,
                         lpThreadInfo->ThreadId,
                         lpThreadInfo->hObject
                         );

                connectTime = (GetTickCountWrap() - connectTime);

                DEBUG_PRINT(SOCKETS,
                            INFO,
                            ("connect() resumed, socket %#x, returns %s\n",
                            m_Socket,
                            InternetMapError(error)
                            ));
            } else {

                DEBUG_PRINT(SOCKETS,
                            ERROR,
                            ("failed to connect non-blocking socket %#x, error %d\n",
                            m_Socket,
                            error
                            ));

            }
        } else {

            DEBUG_PRINT(SOCKETS,
                        ERROR,
                        ("failed to connect blocking socket %#x, error %d\n",
                        m_Socket,
                        error
                        ));

        }
    } else {

        PERF_LOG(PE_CONNECT_END,
                 m_Socket,
                 lpThreadInfo->ThreadId,
                 lpThreadInfo->hObject
                 );

        connectTime = (GetTickCountWrap() - connectTime);

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("socket %#x connected, time = %d mSec\n",
                    m_Socket,
                    connectTime
                    ));

        error = ERROR_SUCCESS;
    }

    if (error != ERROR_SUCCESS) {
        error = MapInternetError(error);
    }

    if (pObject != NULL) {
        pObject->ResetAbortHandle();

        //
        // if the operation has been cancelled, then this error overrides any
        // other
        //

        if (pObject->IsInvalidated()) {
            error = pObject->GetError();
            if (error == ERROR_SUCCESS) {
                error = ERROR_WINHTTP_OPERATION_CANCELLED;
            }
        }
        if (IsAborted()) {
            error = ERROR_WINHTTP_OPERATION_CANCELLED;
        }
    }

quit:

    INET_ASSERT((pObject != NULL) ? (pObject->GetAbortHandle() == NULL) : TRUE);

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::SelectAccept(
    IN ICSocket & acceptSocket,
    IN DWORD dwTimeout
    )

/*++

Routine Description:

    Wait until listening socket has connection to accept. We use the socket
    handle in this ICSocket object to accept a connection & create a socket
    handle in another ICSocket object (in acceptSocket)

Arguments:

    acceptSocket    - socket object to wait on

    dwTimeout       - number of milliseconds to wait

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error mapped to INTERNET error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::SelectAccept",
                 "%#x, %d",
                 &acceptSocket,
                 dwTimeout
                 ));

    DWORD error;
    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto quit;
    }

    fd_set read_fds;
    fd_set except_fds;

    FD_ZERO(&read_fds);
    FD_ZERO(&except_fds);
    FD_SET(m_Socket, &read_fds);
    FD_SET(m_Socket, &except_fds);

    TIMEVAL timeout;

    timeout.tv_sec  = dwTimeout / 1000;
    timeout.tv_usec = dwTimeout % 1000;

    int n;

    n = _I_select(0, &read_fds, NULL, &except_fds, &timeout);
    if (n == 1) {
        if (FD_ISSET(m_Socket, &read_fds)) {
            error = ERROR_SUCCESS;
        } else if (FD_ISSET(m_Socket, &except_fds)) {
            error = ERROR_WINHTTP_CANNOT_CONNECT;

            DEBUG_PRINT(FTP,
                        ERROR,
                        ("select(): listening socket %#x in error (%d)\n",
                        m_Socket,
                        error
                        ));

            INET_ASSERT(acceptSocket.m_Socket == INVALID_SOCKET);
        } else {
            // Fix PREFIX warning (uninitialized error variable); this case should not happen.
            error = ERROR_WINHTTP_INTERNAL_ERROR;
        }
    } else if (n == 0) {

        //
        // timeout
        //

        error = ERROR_WINHTTP_TIMEOUT;

        DEBUG_PRINT(FTP,
                    WARNING,
                    ("select() timed out (%d.%d)\n",
                    timeout.tv_sec,
                    timeout.tv_usec
                    ));

        INET_ASSERT(acceptSocket.m_Socket == INVALID_SOCKET);

    } else {

        //
        // socket error
        //

        DEBUG_PRINT(FTP,
                    ERROR,
                    ("select() returns %d\n",
                    _I_WSAGetLastError()
                    ));

        INET_ASSERT(acceptSocket.m_Socket == INVALID_SOCKET);

        goto socket_error;
    }

    //
    // if we have a success indication then accept the connection; it may still
    // fail
    //

    if (error == ERROR_SUCCESS) {
        acceptSocket.m_Socket = _I_accept(m_Socket, NULL, NULL);
        if (acceptSocket.m_Socket != INVALID_SOCKET) {

            //
            // copy non-blocking indication to new socket
            //

            INET_ASSERT(!(m_dwFlags & SF_NON_BLOCKING));
            //acceptSocket.m_dwFlags |= (m_dwFlags & SF_NON_BLOCKING);
        } else {

            DEBUG_PRINT(FTP,
                        ERROR,
                        ("accept() returns %d\n",
                        error
                        ));

            goto socket_error;
        }
    }

quit:

    DEBUG_LEAVE(error);

    return error;

socket_error:

    error = MapInternetError(_I_WSAGetLastError());
    goto quit;
}


LPSTR
MapNetAddressToName(
    IN INTERNET_HANDLE_OBJECT* pSessionObject,
    IN LPSTR lpszAddress,
    OUT LPSTR * lplpszMappedName
    )

/*++

Routine Description:

    Given a network address, tries to map it to the corresponding host name. We
    consult the name resolution cache to determine this

Arguments:

    lpszAddress         - pointer to network address to map

    lplpszMappedName    - pointer to pointer to mapped name. Caller must free

Return Value:

    LPSTR
        Success - pointer to mapped name

        Failure - NULL

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                Pointer,
                "MapNetAddressToName",
                "%q, %#x",
                lpszAddress,
                lplpszMappedName
                ));

    INET_ASSERT(lpszAddress != NULL);
    INET_ASSERT(lplpszMappedName != NULL);

    LPSTR lpszMappedName = NULL;

    //
    // now try to find the address in the cache. If it's not in the cache then
    // we don't resolve it, simply return the address
    //

    //
    // BUGBUG - if required, we need to resolve the name, but we need to know
    //          whether the address can be resolved on the intranet
    //

    DWORD ipAddr = _I_inet_addr(lpszAddress);

    //
    // inet_addr() shouldn't fail - we should have called IsNetAddress() already
    //

    //INET_ASSERT(ipAddr != INADDR_NONE);

    if (ipAddr != INADDR_NONE) {

        LPHOSTENT lpHostent;
        DWORD ttl;

        if (pSessionObject && pSessionObject->GetResolverCache()->GetResolverCacheList() &&
            QueryHostentCache(pSessionObject->GetResolverCache()->GetResolverCacheList(), NULL, (LPBYTE)&ipAddr, &lpHostent, &ttl)) {

            INET_ASSERT(lpHostent != NULL);

            lpszAddress = lpszMappedName = NewString(lpHostent->h_name);
            ReleaseHostentCacheEntry(pSessionObject->GetResolverCache()->GetResolverCacheList(), lpHostent);
        }
    }

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("mapped name is %q\n",
                lpszAddress
                ));

    DEBUG_LEAVE(lpszAddress);

    *lplpszMappedName = lpszMappedName;

    return lpszAddress;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\common\handle.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    handle.cxx

Abstract:

    Contains functions to allocate and deallocate handle values

    Contents:
        HandleInitialize
        HandleTerminate
        AllocateHandle
        FreeHandle
        MapHandleToAddress
        DereferenceObject

Author:

    Richard L Firth (rfirth) 31-Oct-1994

Revision History:

    12-Mar-2001 rajeevd
        Gutted

    11-Jan-1996 rfirth
        Use fixed memory instead of moveable (Win95 has a bug w/ LocalUnlock)

    31-Oct-1994 rfirth
        Created
--*/

#include <wininetp.h>


//
// private prototypes
//

DEBUG_ONLY (PRIVATE void LogHandleClassSizes(); )

//
// functions
//

DWORD HandleInitialize (VOID)
{
    DEBUG_ONLY (LogHandleClassSizes(); )
    return ERROR_SUCCESS;
}


VOID HandleTerminate(VOID)
{
    // nothing to do
}


DWORD AllocateHandle (IN LPVOID Address,OUT LPHINTERNET lpHandle)
{
    HINTERNET Handle = (HINTERNET) Address;
    *lpHandle = Handle;
    return ERROR_SUCCESS;
}


DWORD FreeHandle(IN HINTERNET Handle)
{
    return ERROR_SUCCESS;
}


DWORD
MapHandleToAddress(
    IN HINTERNET Handle,
    OUT LPVOID * lpAddress,
    IN BOOL Invalidate
    )

/*++

Routine Description:

    The handle object represented by Handle is referenced

    Assumes:    1. only HINTERNETs visible at the API are presented to this
                   function.
                   
Arguments:

    Handle      - handle value generated by AllocateHandle()

    lpAddress   - place to store mapped address. If the handle has been closed
                  and unmapped, NULL is returned. If the handle is still
                  mapped, even though it has been invalidated, its address will
                  be returned, and its reference count incremented

    Invalidate  - TRUE if we are invalidating this handle

Return Value:

    LPVOID
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_HANDLE
                    if *lpAddress == NULL then the handle has been closed and
                    unmapped, else it is still mapped, but invalidated. In
                    this case, we incremented the reference count

--*/

{
    DEBUG_ENTER((DBG_HANDLE,
                Dword,
                "MapHandleToAddress",
                "%#x, %#x, %B",
                Handle,
                lpAddress,
                Invalidate
                ));

    DWORD error;

    // Cast the handle to an address and validate
    LPVOID address = (LPVOID) Handle;
    if (address)
    {
        error = ((HANDLE_OBJECT *)address)->IsValid(TypeWildHandle);
    }
    else
    {
        error = ERROR_INVALID_HANDLE;
    }
    
    if (error != ERROR_SUCCESS)
    {
        DEBUG_PRINT(HANDLE,
                    ERROR,
                    ("invalid handle object: %#x [%#x]\n",
                    Handle,
                    address
                    ));
        error = ERROR_INVALID_HANDLE;
        address = NULL;
        goto quit;
    }

    // Attempt to increment the reference count on the handle.
    
    error = ((HANDLE_OBJECT *)address)->Reference();
    DEBUG_PRINT(HANDLE, ERROR, ("Reference() returns %d\n", error));
    switch (error)
    {
        case ERROR_SUCCESS: // handle was refcounted but is not tombstoned

            if (Invalidate)
            {
                // we were called from a handle close API.
                // Subsequent API calls will discover that the
                // handle is already invalidated and will quit
                ((HANDLE_OBJECT *)address)->Invalidate();
            }
            break;

        case ERROR_INVALID_HANDLE: // handle was refcounted but was tombstoned.
        
            break;

        default:
            INET_ASSERT (false);

        // intentional fall through
            
        case ERROR_ACCESS_DENIED: // handle is being destroyed
            
            DEBUG_PRINT(HANDLE,
                        ERROR,
                        ("Reference() failed - handle %#x [%#x] about to be deleted\n",
                        Handle,
                        address
                        ));
                        
            error = ERROR_INVALID_HANDLE;
            address = NULL;
            break;
    }

 quit:
    *lpAddress = address;
    DEBUG_LEAVE(error);
    return error;
}


DWORD
DereferenceObject(
    IN LPVOID lpObject
    )

/*++

Routine Description:

    Undoes the reference added to the handle object by MapHandleToAddress(). May
    result in the handle object being deleted

Arguments:

    lpObject    - address of object to dereference. This MUST be the mapped
                  object address as returned by MapHandleToAddress()

Return Value:

    DWORD
        Success - ERROR_SUCCESS
                    The handle object was destroyed

        Failure - ERROR_INVALID_HANDLE
                    The object was not a valid handle

--*/

{
    DEBUG_ENTER((DBG_HANDLE,
                Dword,
                "DereferenceObject",
                "%#x",
                lpObject
                ));

    INET_ASSERT(lpObject != NULL);

    HANDLE_OBJECT * object = (HANDLE_OBJECT *)lpObject;
    DWORD error = object->IsValid(TypeWildHandle);

    // Serialize with MapHandleToAddress
    
    if (error == ERROR_SUCCESS)
    {
        object->Dereference();
    }
    else
    {
        //
        // IsValid() should never return an error if the reference counts
        // are correct
        //
        INET_ASSERT(FALSE);
    }

    DEBUG_LEAVE(error);

    return error;
}


#if INET_DEBUG
PRIVATE
void
LogHandleClassSizes()
{
    DEBUG_PRINT(HANDLE,
                INFO,
                ("sizeof(HANDLE_OBJECT)                  = %d bytes\n",
                 sizeof(HANDLE_OBJECT)
                ));
    DEBUG_PRINT(HANDLE,
                INFO,
                ("sizeof(INTERNET_HANDLE_OBJECT)         = %d bytes\n",
                 sizeof(INTERNET_HANDLE_OBJECT)
                ));
    DEBUG_PRINT(HANDLE,
                INFO,
                ("sizeof(INTERNET_CONNECT_HANDLE_OBJECT) = %d bytes\n",
                 sizeof(INTERNET_CONNECT_HANDLE_OBJECT)
                ));
    DEBUG_PRINT(HANDLE,
                INFO,
                ("sizeof(HTTP_REQUEST_HANDLE_OBJECT)     = %d bytes\n",
                 sizeof(HTTP_REQUEST_HANDLE_OBJECT)
                ));
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\common\iwinsock.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    iwinsock.cxx

Abstract:

    Contains functions to load sockets DLL and entry points. Functions and data
    in this module take care of indirecting sockets calls, hence _I_ in front
    of the function name

    Contents:
        IwinsockInitialize
        IwinsockTerminate
        LoadWinsock
        UnloadWinsock
        SafeCloseSocket

Author:

    Richard L Firth (rfirth) 12-Apr-1995

Environment:

    Win32(s) user-mode DLL

Revision History:

    12-Apr-1995 rfirth
        Created

    08-May-1996 arthurbi
        Added support for Socks Firewalls.

    05-Mar-1998 rfirth
        Moved SOCKS support into ICSocket class. Removed SOCKS library
        loading/unloading from this module (revert to pre-SOCKS)

--*/

#include <wininetp.h>

#if defined(__cplusplus)
extern "C" {
#endif

//#define RLF_DEBUG   1

#if INET_DEBUG

#ifdef RLF_DEBUG
#define DPRINTF dprintf
#else
#define DPRINTF (void)
#endif

BOOL
InitDebugSock(
    VOID
    );

VOID
TerminateDebugSock(
    VOID
    );

#else
#define DPRINTF (void)
#endif

//
// private types
//

typedef struct {
    LPSTR FunctionOrdinal;
    FARPROC * FunctionAddress;
} SOCKETS_FUNCTION;


//
// global data
//

GLOBAL
SOCKET
(PASCAL FAR * _I_accept)(
    SOCKET s,
    struct sockaddr FAR *addr,
    int FAR *addrlen
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_bind)(
    SOCKET s,
    const struct sockaddr FAR *addr,
    int namelen
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_closesocket)(
    SOCKET s
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_connect)(
    SOCKET s,
    const struct sockaddr FAR *name,
    int namelen
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_gethostname)(
    char FAR * name,
    int namelen
    ) = NULL;

GLOBAL
LPHOSTENT
(PASCAL FAR * _I_gethostbyname)(
    LPSTR lpHostName
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_getsockname)(
    SOCKET s,
    struct sockaddr FAR *name,
    int FAR * namelen
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_getsockopt)(
    SOCKET s,
    int level,
    int optname,
    char FAR * optval,
    int FAR *optlen
    );

GLOBAL
u_long
(PASCAL FAR * _I_htonl)(
    u_long hostlong
    ) = NULL;

GLOBAL
u_short
(PASCAL FAR * _I_htons)(
    u_short hostshort
    ) = NULL;

GLOBAL
unsigned long
(PASCAL FAR * _I_inet_addr)(
    const char FAR * cp
    ) = NULL;

GLOBAL
char FAR *
(PASCAL FAR * _I_inet_ntoa)(
    struct in_addr in
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_ioctlsocket)(
    SOCKET s,
    long cmd,
    u_long FAR *argp
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_listen)(
    SOCKET s,
    int backlog
    ) = NULL;

GLOBAL
u_short
(PASCAL FAR * _I_ntohs)(
    u_short netshort
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_recv)(
    SOCKET s,
    char FAR * buf,
    int len,
    int flags
    ) = NULL;

GLOBAL
int 
(PASCAL FAR * _I_WSARecv)(
    SOCKET s,                                               
    LPWSABUF lpBuffers,                                     
    DWORD dwBufferCount,                                    
    LPDWORD lpNumberOfBytesRecvd,                           
    LPDWORD lpFlags,                                        
    LPWSAOVERLAPPED lpOverlapped,                           
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine  
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_recvfrom)(
    SOCKET s,
    char FAR * buf,
    int len,
    int flags,
    struct sockaddr FAR *from, 
    int FAR * fromlen
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_select)(
    int nfds,
    fd_set FAR *readfds,
    fd_set FAR *writefds,
    fd_set FAR *exceptfds,
    const struct timeval FAR *timeout
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_send)(
    SOCKET s,
    const char FAR * buf,
    int len,
    int flags
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_WSASend)(
    SOCKET s,                                                  
    LPWSABUF lpBuffers,                                     
    DWORD dwBufferCount,                                    
    LPDWORD lpNumberOfBytesSent,                            
    DWORD dwFlags,                                          
    LPWSAOVERLAPPED lpOverlapped,                           
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine  
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_sendto)(
    SOCKET s,
    const char FAR * buf,
    int len,
    int flags,
    const struct sockaddr FAR *to, 
    int tolen
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_setsockopt)(
    SOCKET s,
    int level,
    int optname,
    const char FAR * optval,
    int optlen
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_shutdown)(
    SOCKET s,
    int how
    ) = NULL;

GLOBAL
SOCKET
(PASCAL FAR * _I_socket)(
    int af,
    int type,
    int protocol
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_WSAStartup)(
    WORD wVersionRequired,
    LPWSADATA lpWSAData
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_WSACleanup)(
    void
    ) = NULL;

//VENKATKBUG-remove later - for now trap any errors 
GLOBAL
int
(PASCAL FAR * __I_WSAGetLastError)(
    void
    ) = NULL;


int
___I_WSAGetLastError(
    VOID
    )
{
    int nError = __I_WSAGetLastError();
/*
    VENKATK_BUG - OK to have WSAENOTSOCK - could happen for timeout situations.
    INET_ASSERT (nError != WSAENOTSOCK);
 */
    return nError;
}


GLOBAL
int
(PASCAL FAR * _I_WSAGetLastError)(
    void
    ) = ___I_WSAGetLastError;
    
GLOBAL
void
(PASCAL FAR * _I_WSASetLastError)(
    int iError
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I___WSAFDIsSet)(
    SOCKET,
    fd_set FAR *
    ) = NULL;

#if INET_DEBUG

void SetupSocketsTracing(void);

#endif

//
// private data
//

//
// InitializationLock - protects against multiple threads loading WSOCK32.DLL
// and entry points
//

PRIVATE CCritSec InitializationLock;

//
// hWinsock - NULL when WSOCK32.DLL is not loaded
//

PRIVATE HINSTANCE hWinsock = NULL;

//
// WinsockLoadCount - the number of times we have made calls to LoadWinsock()
// and UnloadWinsock(). When this reaches 0 (again), we can unload the Winsock
// DLL for real
//

PRIVATE DWORD WinsockLoadCount = 0;

//
// SocketsFunctions - this is the list of entry points in WSOCK32.DLL that we
// need to load for WININET.DLL
//

PRIVATE
SOCKETS_FUNCTION
SocketsFunctions[] = {
    "accept",           (FARPROC*)&_I_accept,
    "bind",             (FARPROC*)&_I_bind,
    "closesocket",      (FARPROC*)&_I_closesocket,
    "connect",          (FARPROC*)&_I_connect,
    "getsockname",      (FARPROC*)&_I_getsockname,
    "getsockopt",       (FARPROC*)&_I_getsockopt,
    "htonl",            (FARPROC*)&_I_htonl,
    "htons",            (FARPROC*)&_I_htons,

    "inet_addr",        (FARPROC*)&_I_inet_addr,
    "inet_ntoa",        (FARPROC*)&_I_inet_ntoa,
    "ioctlsocket",      (FARPROC*)&_I_ioctlsocket,

    "listen",           (FARPROC*)&_I_listen,
    "ntohs",            (FARPROC*)&_I_ntohs,
    "recv",             (FARPROC*)&_I_recv,
    "recvfrom",         (FARPROC*)&_I_recvfrom,
    "select",           (FARPROC*)&_I_select,
    "send",             (FARPROC*)&_I_send,
    "sendto",           (FARPROC*)&_I_sendto,
    "setsockopt",       (FARPROC*)&_I_setsockopt,
    "shutdown",         (FARPROC*)&_I_shutdown,
    "socket",           (FARPROC*)&_I_socket,
    "gethostbyname",    (FARPROC*)&_I_gethostbyname,
    "gethostname",      (FARPROC*)&_I_gethostname,
    "WSAGetLastError",  (FARPROC*)&__I_WSAGetLastError,
    "WSASetLastError",  (FARPROC*)&_I_WSASetLastError,
    "WSAStartup",       (FARPROC*)&_I_WSAStartup,
    "WSACleanup",       (FARPROC*)&_I_WSACleanup,
    "__WSAFDIsSet",     (FARPROC*)&_I___WSAFDIsSet,
    "WSARecv",          (FARPROC*)&_I_WSARecv,
    "WSASend",          (FARPROC*)&_I_WSASend
};


//
// private prototypes
//

#if INET_DEBUG

void SetupSocketsTracing(void);

#endif

//
// functions
//


BOOL
IwinsockInitialize(
    VOID
    )

/*++

Routine Description:

    Performs initialization/resource allocation for this module

Arguments:

    None.

Return Value:

    None.

--*/

{
    BOOL fResult;
    //
    // initialize the critical section that protects against multiple threads
    // trying to initialize Winsock
    //

    fResult = InitializationLock.Init();

#if INET_DEBUG
    if (fResult)
        fResult = InitDebugSock();
#endif

    return fResult;
}


VOID
IwinsockTerminate(
    VOID
    )

/*++

Routine Description:

    Performs termination & resource cleanup for this module

Arguments:

    None.

Return Value:

    None.

--*/

{
    InitializationLock.FreeLock();

#if INET_DEBUG
    TerminateDebugSock();
#endif
}


DWORD
LoadWinsock(
    VOID
    )

/*++

Routine Description:

    Dynamically loads Windows sockets library

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - Win32 error
                    e.g. LoadLibrary() failure

                  WSA error
                    e.g. WSAStartup() failure

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                Dword,
                "LoadWinsock",
                NULL
                ));

    DWORD error = ERROR_SUCCESS;

    //
    // ensure no 2 threads are trying to modify the loaded state of winsock at
    // the same time
    //

    if (!InitializationLock.Lock())
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    if (hWinsock == NULL) {

        BOOL failed = FALSE;

        //
        // BUGBUG - read this value from registry
        //

        hWinsock = LoadLibrary("ws2_32");
        
        if (hWinsock == NULL) {
            
            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("failed to load ws2_32.dll"));
            
            hWinsock = LoadLibrary("wsock32");
        }
        
        if (hWinsock != NULL) {

            //
            // load the entry points
            //

            for (int i = 0; i < ARRAY_ELEMENTS(SocketsFunctions); ++i) {

                FARPROC farProc;

                farProc = GetProcAddress(
                                hWinsock,
                                (LPCSTR)SocketsFunctions[i].FunctionOrdinal
                                );
                if (farProc == NULL) {
                    failed = TRUE;
                    break;
                }
                *SocketsFunctions[i].FunctionAddress = farProc;
            }
            if (!failed) {

                //
                // although we need a WSADATA for WSAStartup(), it is an
                // expendible structure (not required for any other sockets
                // calls)
                //

                WSADATA wsaData;

                error = _I_WSAStartup(0x0101, &wsaData);
                if (error == ERROR_SUCCESS) {

                    DEBUG_PRINT(SOCKETS,
                                INFO,
                                ("winsock description: %q\n",
                                wsaData.szDescription
                                ));

                    int stringLen;

                    stringLen = lstrlen(wsaData.szDescription);
                    if (strnistr(wsaData.szDescription, "novell", stringLen)
                    && strnistr(wsaData.szDescription, "wsock32", stringLen)) {

                        DEBUG_PRINT(SOCKETS,
                                    INFO,
                                    ("running on Novell Client32 stack\n"
                                    ));

                        GlobalRunningNovellClient32 = TRUE;
                    }
#if INET_DEBUG
                    SetupSocketsTracing();
#endif
                } else {
                    failed = TRUE;
                }
            }
        } else {
            failed = TRUE;
        }

        //
        // if we failed to find an entry point or WSAStartup() returned an error
        // then unload the library
        //

        if (failed) {

            //
            // important: there should be no API calls between determining the
            // failure and coming here to get the error code
            //
            // if error == ERROR_SUCCESS then we have to get the last error, else
            // it is the error returned by WSAStartup()
            //

            if (error == ERROR_SUCCESS) {
                error = GetLastError();

                INET_ASSERT(error != ERROR_SUCCESS);

            }
            UnloadWinsock();
        }
    } else {

        //
        // just increment the number of times we have called LoadWinsock()
        // without a corresponding call to UnloadWinsock();
        //

        ++WinsockLoadCount;
    }

    InitializationLock.Unlock();

    //
    // if we failed for any reason, need to report that TCP/IP not available
    //

    if (error != ERROR_SUCCESS) {
        error = ERROR_NOT_SUPPORTED;
    }

quit:
    DEBUG_LEAVE(error);

    return error;
}


VOID
UnloadWinsock(
    VOID
    )

/*++

Routine Description:

    Unloads winsock DLL and prepares hWinsock and SocketsFunctions[] for reload

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 None,
                 "UnloadWinsock",
                 NULL
                 ));

    //
    // ensure no 2 threads are trying to modify the loaded state of winsock at
    // the same time
    //

    if (!InitializationLock.Lock())
    {
        goto quit;
    }

    //
    // only unload the DLL if it has been mapped into process memory
    //

    if (hWinsock != NULL) {

        //
        // and only if this is the last load instance
        //

        if (WinsockLoadCount == 0) {

            INET_ASSERT(_I_WSACleanup != NULL);

            if (_I_WSACleanup != NULL) {

                //
                // need to terminate async support too - it is reliant on
                // Winsock
                //

                //called only from LoadWinsock which is called only from INTERNET_HANDLE_OBJECT()
                //so not in dynamic unload, so alrite to cleanup.
                TerminateAsyncSupport(TRUE);

                int serr = _I_WSACleanup();

                if (serr != 0) {

                    DEBUG_PRINT(SOCKETS,
                                ERROR,
                                ("WSACleanup() returns %d; WSA error = %d\n",
                                serr,
                                (_I_WSAGetLastError != NULL)
                                    ? _I_WSAGetLastError()
                                    : -1
                                ));

                }
            }
            for (int i = 0; i < ARRAY_ELEMENTS(SocketsFunctions); ++i) {
                *SocketsFunctions[i].FunctionAddress = (FARPROC)NULL;
            }
            FreeLibrary(hWinsock);
            hWinsock = NULL;
        } else {

            //
            // if there have been multiple virtual loads, then just reduce the
            // load count
            //

            --WinsockLoadCount;
        }
    }

    InitializationLock.Unlock();

quit:
    DEBUG_LEAVE(0);
}


DWORD
SafeCloseSocket(
    IN SOCKET Socket
    )

/*++

Routine Description:

    closesocket() call protected by exception handler in case winsock DLL has
    been unloaded by system before Wininet DLL unloaded

Arguments:

    Socket  - socket handle to close

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - socket error mapped to ERROR_WINHTTP_ error

--*/

{
    int serr;

    __try {
        serr = _I_closesocket(Socket);
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        serr = 0;
    }
    ENDEXCEPT
    return (serr == SOCKET_ERROR)
        ? MapInternetError(_I_WSAGetLastError())
        : ERROR_SUCCESS;
}

CWrapOverlapped* GetWrapOverlappedObject(LPVOID lpAddress)
{
    return CONTAINING_RECORD(lpAddress, CWrapOverlapped, m_Overlapped);
}

#if INET_DEBUG

//
// debug data types
//

SOCKET
PASCAL FAR
_II_socket(
    int af,
    int type,
    int protocol
    );

int
PASCAL FAR
_II_closesocket(
    SOCKET s
    );

SOCKET
PASCAL FAR
_II_accept(
    SOCKET s,
    struct sockaddr FAR *addr,
    int FAR *addrlen
    );

GLOBAL
SOCKET
(PASCAL FAR * _P_accept)(
    SOCKET s,
    struct sockaddr FAR *addr,
    int FAR *addrlen
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _P_closesocket)(
    SOCKET s
    ) = NULL;

GLOBAL
SOCKET
(PASCAL FAR * _P_socket)(
    int af,
    int type,
    int protocol
    ) = NULL;

#define MAX_STACK_TRACE     5
#define MAX_SOCK_ENTRIES    1000

typedef struct _DEBUG_SOCK_ENTRY {
    SOCKET Socket;
    DWORD StackTraceLength;
    PVOID StackTrace[ MAX_STACK_TRACE ];
} DEBUG_SOCK_ENTRY, *LPDEBUG_SOCK_ENTRY;

CCritSec DebugSockLock;
DEBUG_SOCK_ENTRY GlobalSockEntry[MAX_SOCK_ENTRIES];

DWORD GlobalSocketsCount = 0;


#define LOCK_DEBUG_SOCK()   (DebugSockLock.Lock())
#define UNLOCK_DEBUG_SOCK() (DebugSockLock.Unlock())

HINSTANCE NtDllHandle;

typedef USHORT (*RTL_CAPTURE_STACK_BACK_TRACE)(
   IN ULONG FramesToSkip,
   IN ULONG FramesToCapture,
   OUT PVOID *BackTrace,
   OUT PULONG BackTraceHash
   );

RTL_CAPTURE_STACK_BACK_TRACE pRtlCaptureStackBackTrace;

BOOL
InitDebugSock(
    VOID
    )
{
    memset( GlobalSockEntry, 0x0, sizeof(GlobalSockEntry) );
    GlobalSocketsCount = 0;

    if (!DebugSockLock.Init())
    {
        INET_ASSERT(FALSE);
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}

VOID
TerminateDebugSock(
    VOID
    )
{
    DebugSockLock.FreeLock();
}

VOID
SetupSocketsTracing(
    VOID
    )
{
    if (!(InternetDebugCategoryFlags & DBG_TRACE_SOCKETS)) {
        return ;
    }
    if (!IsPlatformWinNT()) {
        return ;
    }
    if ((NtDllHandle = LoadLibrary("ntdll.dll")) == NULL) {
        return ;
    }
    if ((pRtlCaptureStackBackTrace =
        (RTL_CAPTURE_STACK_BACK_TRACE)
            GetProcAddress(NtDllHandle, "RtlCaptureStackBackTrace")) == NULL) {
        FreeLibrary(NtDllHandle);
        return ;
    }

//#ifdef DONT_DO_FOR_NOW
    _P_accept = _I_accept;
    _I_accept = _II_accept;
    _P_closesocket = _I_closesocket;
    _I_closesocket = _II_closesocket;
    _P_socket = _I_socket;
    _I_socket = _II_socket;
//#endif
}

VOID
AddSockEntry(
    SOCKET S
    )
{
    DWORD i;
    DWORD Hash;

    if (!(InternetDebugCategoryFlags & DBG_TRACE_SOCKETS)) {
        return ;
    }

    LOCK_DEBUG_SOCK();

    //
    // search for a free entry.
    //

    for( i = 0; i < MAX_SOCK_ENTRIES; i++ ) {

        if( GlobalSockEntry[i].Socket == 0 ) {

            DWORD Hash;

            //
            // found a free entry.
            //

            GlobalSockEntry[i].Socket = S;

            //
            // get caller stack.
            //

#if i386
            Hash = 0;

            GlobalSockEntry[i].StackTraceLength =
                pRtlCaptureStackBackTrace(
                    2,
                    MAX_STACK_TRACE,
                    GlobalSockEntry[i].StackTrace,
                    &Hash );
#else // i386
            GlobalSockEntry[i].StackTraceLength = 0;
#endif // i386


            GlobalSocketsCount++;

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("socket count = %ld\n",
                        GlobalSocketsCount
                        ));

            DPRINTF("%d sockets\n", GlobalSocketsCount);

            UNLOCK_DEBUG_SOCK();
            return;
        }
    }

    //
    // we have reached a high handle limit, which is unusal, needs to be
    // debugged.
    //

    INET_ASSERT( FALSE );
    UNLOCK_DEBUG_SOCK();

    return;
}

VOID
RemoveSockEntry(
    SOCKET S
    )
{
    DWORD i;

    if (!(InternetDebugCategoryFlags & DBG_TRACE_SOCKETS)) {
        return ;
    }

    LOCK_DEBUG_SOCK();

    for( i = 0; i < MAX_SOCK_ENTRIES; i++ ) {

        if( GlobalSockEntry[i].Socket == S ) {

            //
            // found the entry. Free it now.
            //

            memset( &GlobalSockEntry[i], 0x0, sizeof(DEBUG_SOCK_ENTRY) );

            GlobalSocketsCount--;

#ifdef IWINSOCK_DEBUG_PRINT

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("count(%ld), RemoveSock(%lx)\n",
                        GlobalSocketsCount,
                        S
                        ));

#endif // IWINSOCK_DEBUG_PRINT

            DPRINTF("%d sockets\n", GlobalSocketsCount);

            UNLOCK_DEBUG_SOCK();
            return;
        }
    }

#ifdef IWINSOCK_DEBUG_PRINT

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("count(%ld), UnknownSock(%lx)\n",
                GlobalSocketsCount,
                S
                ));

#endif // IWINSOCK_DEBUG_PRINT

    //
    // socket entry is not found.
    //

    // INET_ASSERT( FALSE );

    UNLOCK_DEBUG_SOCK();
    return;
}

SOCKET
PASCAL FAR
_II_socket(
    int af,
    int type,
    int protocol
    )
{
    SOCKET S;

    S = _P_socket( af, type, protocol );
    AddSockEntry( S );
    return( S );
}

int
PASCAL FAR
_II_closesocket(
    SOCKET s
    )
{
    int Ret;

    RemoveSockEntry( s );
    Ret = _P_closesocket( s );
    return( Ret );
}

SOCKET
PASCAL FAR
_II_accept(
    SOCKET s,
    struct sockaddr FAR *addr,
    int FAR *addrlen
    )
{
    SOCKET S;

    S = _P_accept( s, addr, addrlen );
    AddSockEntry( S );
    return( S );

}

VOID
IWinsockCheckSockets(
    VOID
    )
{
    DEBUG_PRINT(SOCKETS,
                INFO,
                ("GlobalSocketsCount = %d\n",
                GlobalSocketsCount
                ));

    for (DWORD i = 0; i < MAX_SOCK_ENTRIES; ++i) {

        SOCKET sock;

        if ((sock = GlobalSockEntry[i].Socket) != 0) {

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("Socket %#x\n",
                        sock
                        ));

        }
    }
}

#endif // INET_DEBUG

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\common\fsm.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    fsm.cxx

Abstract:

    Contains CFsm class implementation

    Contents:
        ContainingFsm
        DoFsm
        CFsm::CFsm
        CFsm::~CFsm
        CFsm::Push
        CFsm::Pop
        CFsm::QueueWorkItem
        CFsm::RunWorkItem
        CFsm::Run
        [CFsm::MapType]
        [CFsm::StateName]

Author:

     Richard L Firth (rfirth) 11-Apr-1997

Environment:

    Win32 user-mode DLL

Revision History:

    11-Apr-1997 rfirth
        Created

--*/

#include <wininetp.h>
#include <perfdiag.hxx>

#ifdef USE_DINARES_FSM_ALLOC_CACHE

CCritSec                FsmAllocCritSec;
void *                  FsmAllocList;
size_t                  FsmAllocSize;

#endif

#if INET_DEBUG

struct { int size; char* name; } class_sizes[] = {
    sizeof(CFsm), "CFsm",
    sizeof(CFsm_ResolveHost), "CFsm_ResolveHost",
    sizeof(CFsm_InternetParseUrl), "CFsm_InternetParseUrl",
    sizeof(CFsm_InternetQueryDataAvailable), "CFsm_InternetQueryDataAvailable",
    sizeof(CFsm_InternetWriteFile), "CFsm_InternetWriteFile",
    sizeof(CFsm_InternetReadFile), "CFsm_InternetReadFile",
    sizeof(CFsm_SocketConnect), "CFsm_SocketConnect",
    sizeof(CFsm_SocketSend), "CFsm_SocketSend",
    sizeof(CFsm_SocketReceive), "CFsm_SocketReceive",
    //sizeof(CFsm_SocketDataAvailable), "CFsm_SocketDataAvailable",
    sizeof(CFsm_SecureConnect), "CFsm_SecureConnect",
    sizeof(CFsm_SecureHandshake), "CFsm_SecureHandshake",
    sizeof(CFsm_SecureNegotiate), "CFsm_SecureNegotiate",
    sizeof(CFsm_NegotiateLoop), "CFsm_NegotiateLoop",
    sizeof(CFsm_SecureSend), "CFsm_SecureSend",
    sizeof(CFsm_SecureReceive), "CFsm_SecureReceive",
    sizeof(CFsm_GetConnection), "CFsm_GetConnection",
    sizeof(CFsm_HttpSendRequest), "CFsm_HttpSendRequest",
    sizeof(CFsm_MakeConnection), "CFsm_MakeConnection",
    sizeof(CFsm_OpenConnection), "CFsm_OpenConnection",
    sizeof(CFsm_OpenProxyTunnel), "CFsm_OpenProxyTunnel",
    sizeof(CFsm_SendRequest), "CFsm_SendRequest",
    sizeof(CFsm_ReceiveResponse), "CFsm_ReceiveResponse",
    sizeof(CFsm_HttpReadData), "CFsm_HttpReadData",
    sizeof(CFsm_HttpWriteData), "CFsm_HttpWriteData",
    sizeof(CFsm_ReadData), "CFsm_ReadData",
    sizeof(CFsm_HttpQueryAvailable), "CFsm_HttpQueryAvailable",
    sizeof(CFsm_DrainResponse), "CFsm_DrainResponse",
    sizeof(CFsm_Redirect), "CFsm_Redirect",
    sizeof(CFsm_ReadLoop), "CFsm_ReadLoop",
    sizeof(CFsm_ParseHttpUrl), "CFsm_ParseHttpUrl",
    sizeof(CFsm_OpenUrl), "CFsm_OpenUrl",
    sizeof(CFsm_ParseUrlForHttp), "CFsm_ParseUrlForHttp",
    sizeof(CFsm_ReadFile), "CFsm_ReadFile",
    sizeof(CFsm_ReadFileEx), "CFsm_ReadFileEx",
    //sizeof(CFsm_WriteFile), "CFsm_WriteFile",
    sizeof(CFsm_BackgroundTask), "CFsm_BackgroundTask",
    sizeof(CFsm_QueryAvailable), "CFsm_QueryAvailable"
};

void dump_class_sizes() {
    for (int i = 0; i < ARRAY_ELEMENTS(class_sizes); ++i) {
        DEBUG_PRINT(ASYNC,INFO,("%s = %d\n", class_sizes[i].name, class_sizes[i].size));
    }
}

#endif

//
// functions
//

//
// This is Dinarte's experiement for reducing Mem alloc on
//  creating FSMs.
//

#ifdef USE_DINARES_FSM_ALLOC_CACHE


VOID
FsmInitialize(
    VOID
    )

/*++

Routine Description:

    Performs initialization required by functions in this module

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - return code from LocalAlloc

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                None,
                "FsmInitialize",
                NULL
                ));

    FsmAllocCritSec.Init();

    FsmAllocSize = sizeof(CFsm);
    if (FsmAllocSize < sizeof(CFsm_ResolveHost))
        FsmAllocSize = sizeof(CFsm_ResolveHost);
    if (FsmAllocSize < sizeof(CFsm_SocketConnect))
        FsmAllocSize = sizeof(CFsm_SocketConnect);
    if (FsmAllocSize < sizeof(CFsm_SocketSend))
        FsmAllocSize = sizeof(CFsm_SocketSend);
    if (FsmAllocSize < sizeof(CFsm_SocketReceive))
        FsmAllocSize = sizeof(CFsm_SocketReceive);
    if (FsmAllocSize < sizeof(CFsm_SecureConnect))
        FsmAllocSize = sizeof(CFsm_SecureConnect);
    if (FsmAllocSize < sizeof(CFsm_SecureHandshake))
        FsmAllocSize = sizeof(CFsm_SecureHandshake);
    if (FsmAllocSize < sizeof(CFsm_SecureNegotiate))
        FsmAllocSize = sizeof(CFsm_SecureNegotiate);
    if (FsmAllocSize < sizeof(CFsm_NegotiateLoop))
        FsmAllocSize = sizeof(CFsm_NegotiateLoop);
    if (FsmAllocSize < sizeof(CFsm_SecureSend))
        FsmAllocSize = sizeof(CFsm_SecureSend);
    if (FsmAllocSize < sizeof(CFsm_SecureReceive))
        FsmAllocSize = sizeof(CFsm_SecureReceive);
    if (FsmAllocSize < sizeof(CFsm_GetConnection))
        FsmAllocSize = sizeof(CFsm_GetConnection);
    if (FsmAllocSize < sizeof(CFsm_HttpSendRequest))
        FsmAllocSize = sizeof(CFsm_HttpSendRequest);
    if (FsmAllocSize < sizeof(CFsm_MakeConnection))
        FsmAllocSize = sizeof(CFsm_MakeConnection);
    if (FsmAllocSize < sizeof(CFsm_OpenConnection))
        FsmAllocSize = sizeof(CFsm_OpenConnection);
    if (FsmAllocSize < sizeof(CFsm_OpenProxyTunnel))
        FsmAllocSize = sizeof(CFsm_OpenProxyTunnel);
    if (FsmAllocSize < sizeof(CFsm_SendRequest))
        FsmAllocSize = sizeof(CFsm_SendRequest);
    if (FsmAllocSize < sizeof(CFsm_ReceiveResponse))
        FsmAllocSize = sizeof(CFsm_ReceiveResponse);
    if (FsmAllocSize < sizeof(CFsm_HttpReadData))
        FsmAllocSize = sizeof(CFsm_HttpReadData);
    if (FsmAllocSize < sizeof(CFsm_HttpWriteData))
        FsmAllocSize = sizeof(CFsm_HttpWriteData);
    if (FsmAllocSize < sizeof(CFsm_ReadData))
        FsmAllocSize = sizeof(CFsm_ReadData);
    if (FsmAllocSize < sizeof(CFsm_HttpQueryAvailable))
        FsmAllocSize = sizeof(CFsm_HttpQueryAvailable);
    if (FsmAllocSize < sizeof(CFsm_DrainResponse))
        FsmAllocSize = sizeof(CFsm_DrainResponse);
    if (FsmAllocSize < sizeof(CFsm_Redirect))
        FsmAllocSize = sizeof(CFsm_Redirect);
    if (FsmAllocSize < sizeof(CFsm_ReadLoop))
        FsmAllocSize = sizeof(CFsm_ReadLoop);
    if (FsmAllocSize < sizeof(CFsm_ParseHttpUrl))
        FsmAllocSize = sizeof(CFsm_ParseHttpUrl);
    if (FsmAllocSize < sizeof(CFsm_OpenUrl))
        FsmAllocSize = sizeof(CFsm_OpenUrl);
    if (FsmAllocSize < sizeof(CFsm_ParseUrlForHttp))
        FsmAllocSize = sizeof(CFsm_ParseUrlForHttp);
    if (FsmAllocSize < sizeof(CFsm_ReadFile))
        FsmAllocSize = sizeof(CFsm_ReadFile);
    if (FsmAllocSize < sizeof(CFsm_ReadFileEx))
        FsmAllocSize = sizeof(CFsm_ReadFileEx);
    if (FsmAllocSize < sizeof(CFsm_QueryAvailable))
        FsmAllocSize = sizeof(CFsm_QueryAvailable);

    //
    // Pre-allocate a pool of state-machines for locality of reference
    //

    for (int cPreAlloc = 8192 / FsmAllocSize; cPreAlloc > 0; --cPreAlloc)
    {
        void * pFsm = (void *)ALLOCATE_FIXED_MEMORY(FsmAllocSize);

        if (pFsm == NULL)
            break;

        *(void **)pFsm = FsmAllocList;
        FsmAllocList = pFsm;
    }
}


VOID
FsmTerminate(
    VOID
    )

/*++

Routine Description:

    Obverse of FsmInitialize - frees any system resources allocated by
    FsmInitialize

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                None,
                "FsmTerminate",
                NULL
                ));

    //
    // there shouldn't be any other threads active when this function is called
    // but we'll grab the critical section anyway, just to make sure
    //

    if (FsmAllocCritSec.Lock())
    {

        while (FsmAllocList)
        {
            void * pFsm = FsmAllocList;
            FsmAllocList = *(void **)pFsm;
            FREE_MEMORY((HLOCAL)pFsm);
        }

        FsmAllocCritSec.Unlock();
    }

    //
    // delete the critical section
    //

    FsmAllocCritSec.FreeLock();

    DEBUG_LEAVE(0);
}

#endif


CFsm *
ContainingFsm(
    IN LPVOID lpAddress
    )

/*++

Routine Description:

    Returns address of start of CFsm object, including vtable

Arguments:

    lpAddress   - pointer to list inside CFsm object

Return Value:

    CFsm *  - pointer to start of object

--*/

{
    return CONTAINING_RECORD(lpAddress, CFsm, m_ListEntry);
}


//DWORD
//RunAll(
//    VOID
//    )
//{
//    DWORD error;
//    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
//
//    if (lpThreadInfo != NULL) {
//        while (lpThreadInfo->Fsm != NULL) {
//            lpThreadInfo->Fsm->Run();
//        }
//    } else {
//        error = ERROR_WINHTTP_INTERNAL_ERROR;
//    }
//    return error;
//}


DWORD
DoFsm(
    IN CFsm * pFsm
    )

/*++

Routine Description:

    Common FSM run processing

Arguments:

    pFsm    - FSM to run (maybe NULL if new failed)

Return Value:

    DWORD   - return code from running FSM

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "DoFsm",
                 "%#x (%s)",
                 pFsm,
                 pFsm->MapType()
                 ));

    DWORD error;
    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

    INET_ASSERT(lpThreadInfo != NULL);

    if (lpThreadInfo != NULL) {
        if (pFsm != NULL) {
            error = pFsm->GetError();
            if (error == ERROR_SUCCESS) {
                error = pFsm->Run(lpThreadInfo, NULL, NULL);
            } else {

                INET_ASSERT(FALSE);

                delete pFsm;
            }
        } else {
            error = ERROR_NOT_ENOUGH_MEMORY;
        }
    } else {
        error = ERROR_WINHTTP_INTERNAL_ERROR;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
DoAsyncFsm(
    IN CFsm * pFsm,
    IN HTTP_REQUEST_HANDLE_OBJECT *pRequest
    )

/*++

Routine Description:

    Common FSM run processing for asynchronous requests which
    are starting new fsm chains.

Arguments:

    pFsm     - FSM to run (maybe NULL if new failed)

    pRequest - When not NULL, the FSM will be checked and placed
               into a blocked queue if an async work item on the
               request item is already in progress.  It's assumed
               this is only called for async request objects.

Return Value:

    DWORD   - return code from running FSM

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "DoAsyncFsm",
                 "%#x (%s)",
                 pFsm,
                 pFsm->MapType()
                 ));

    DWORD error;
    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

    INET_ASSERT(lpThreadInfo != NULL);

    if (lpThreadInfo != NULL) {
        if (pFsm != NULL) {
            error = pFsm->GetError();
            if (error == ERROR_SUCCESS) {
                if (pRequest) {
                    if (pRequest->LockAsync())
                    {
                        if (pRequest->IsWorkItemInProgress())
                        {
                            // Wait until current and blocked work items are finished.
                            error = pRequest->BlockWorkItem(pFsm);
                            if (error == ERROR_SUCCESS)
                            {
                                error = ERROR_IO_PENDING;
                            }
                        }
                        else
                        {
                            pRequest->SetWorkItemInProgress(TRUE);
                            pFsm->SetPushPop(TRUE);
                            pFsm->Push();
                            error = pFsm->QueueWorkItem();
                        }
                        pRequest->UnlockAsync();
                    }
                    else
                    {
                        delete pFsm;
                        pFsm = NULL;
                        error = ERROR_NOT_ENOUGH_MEMORY;
                    }
                }
                else {
                    error = pFsm->Run(lpThreadInfo, NULL, NULL);
                }
            } else {

                INET_ASSERT(FALSE);

                delete pFsm;
            }
        } else {
            error = ERROR_NOT_ENOUGH_MEMORY;
        }
    } else {
        error = ERROR_WINHTTP_INTERNAL_ERROR;
    }

    DEBUG_LEAVE(error);

    return error;
}


//
// methods
//


//
// This is Dinarte's experiement for reducing Mem alloc on
//  creating FSMs. Not used right now.
//

#ifdef USE_DINARES_FSM_ALLOC_CACHE


void *
CFsm::operator new(
    IN size_t Size
    )

/*++

Routine Description:

    Allocates memory for the new state-machine from a special memory pool.

Arguments:

    Size        - size of the state-machine

Return Value:

    None.

--*/

{
    VOID * pFsm = NULL;

    if (FsmAllocCritSec.Lock())
    {
        // Only alloc from the list if we can synchronize access to it.

        pFsm = FsmAllocList;

        if (pFsm)
        {
            FsmAllocList = *(void **)pFsm;
        }

        FsmAllocCritSec.Unlock();
    }

    if (pFsm == NULL)
    {
        INET_ASSERT(Size <= FsmAllocSize);

        pFsm = (void *)ALLOCATE_FIXED_MEMORY(FsmAllocSize);
    }

    return(pFsm);
}


VOID
CFsm::operator delete(
    IN VOID * pFsm
    )

/*++

Routine Description:

    Deallocates memory for the state-machine by adding it to a special
    memory pool.

Arguments:

    pFsm        - pointer to the state-machine

Return Value:

    None.

--*/

{
    if (pFsm)
    {
        if (FsmAllocCritSec.Lock())
        {
            *(void **)pFsm = FsmAllocList;
            FsmAllocList = pFsm;

            FsmAllocCritSec.Unlock();
        }
        // else leak?
    }
}
#endif


CFsm::CFsm(
    IN DWORD (* lpfnHandler)(CFsm *),
    IN LPVOID lpvContext,
    IN BOOL fPushPop /* = TRUE */
    ) : CPriorityListEntry(0)

/*++

Routine Description:

    CFsm constructor. This gets called many times since its the base of all the
    derived FSMs

Arguments:

    lpfnHandler - state-machine handler

    lpvContext  - callee context

Return Value:

    None.

--*/

{
#if INET_DEBUG
    static bool b = TRUE;
    if (b) {
        dump_class_sizes();
        b=FALSE;
    }
#endif

    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "CFsm::CFsm",
                 "{%#x}",
                 this
                 ));

    INIT_FSM();

    m_lpThreadInfo = InternetGetThreadInfo();
    if (m_lpThreadInfo == NULL) {

        INET_ASSERT(m_lpThreadInfo != NULL);

        SetError(ERROR_WINHTTP_INTERNAL_ERROR);

        DEBUG_LEAVE(0);

        return;
    }
    m_hObject = m_lpThreadInfo->hObject;
    m_hObjectMapped = (INTERNET_HANDLE_OBJECT *)m_lpThreadInfo->hObjectMapped;
    m_dwContext = m_hObjectMapped->GetContext();
    m_dwMappedErrorCode = m_lpThreadInfo->dwMappedErrorCode;
    m_State = FSM_STATE_INIT;
    m_NextState = FSM_STATE_CONTINUE;
    m_FunctionState = FSM_STATE_BAD;
    m_lpfnHandler = lpfnHandler;
    m_lpvContext = lpvContext;
    SetError(ERROR_SUCCESS);
    m_bPushPop = fPushPop;
    if (fPushPop)
        Push();
    m_Hint = FSM_HINT_SLOW;
    m_Socket = INVALID_SOCKET;
    m_Action = FSM_ACTION_NONE;
    m_dwBlockId = 0;
    m_dwTimeout = INFINITE;
    m_fTimeoutWraps = FALSE;
    m_dwTimer = 0;
    m_bTimerStarted = FALSE;
    m_bIsBlockingFsm = FALSE;
    m_bIsApi = FALSE;
    m_ApiType = ApiType_None;
    m_dwApiData = 0;
    m_ApiResult.Handle = NULL;
    m_bHasTimeout = FALSE;
    m_bOnAsyncList = FALSE;

    DEBUG_LEAVE(0);
}


CFsm::~CFsm()

/*++

Routine Description:

    CFsm desctructor

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "CFsm::~CFsm",
                 "{%#x}",
                 this
                 ));

    CHECK_FSM();
    CHECK_OWNED();

    if (m_bPushPop)
        Pop();    

#ifdef STRESS_BUG_DEBUG
    m_Link = (CFsm *) (DWORD_PTR) 0xFEFEFEFE;
    m_dwError = 0xFEFEFEFE;
    m_lpThreadInfo = (LPINTERNET_THREAD_INFO) (DWORD_PTR) 0xFEFEFEFE;
    m_dwContext = 0xFEFEFEFE;
    m_hObject = (HINTERNET)(DWORD_PTR) 0xFEFEFEFE;
#endif

    DEBUG_LEAVE(0);
}


VOID
CFsm::Push(
    VOID
    )

/*++

Routine Description:

    Adds this FSM to the head of the queue

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 None,
                 "CFsm::Push",
                 "{%#x (%s:%s)}",
                 this,
                 MapState(),
                 MapFunctionState()
                 ));

    CHECK_FSM();
    CHECK_UNOWNED();
    INET_ASSERT(m_lpThreadInfo != NULL);
    CHECK_INTERNET_THREAD_INFO(m_lpThreadInfo);

    m_Link = m_lpThreadInfo->Fsm;
    m_lpThreadInfo->Fsm = this;

    CHECK_FSM_OWNED(m_Link);
    RESET_FSM_OWNED(m_Link);

    DEBUG_PRINT(ASYNC,
                INFO,
                ("!!! FSM %#x unowned\n", m_Link
                ));

    SET_OWNED();

    DEBUG_PRINT(ASYNC,
                INFO,
                ("!!! FSM %#x owned by %#x\n",
                this,
                GetCurrentThreadId()
                ));

    DEBUG_LEAVE(0);
}


VOID
CFsm::Pop(
    VOID
    )

/*++

Routine Description:

    Puts the next FSM (if any) at the head of the queue

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 None,
                 "CFsm::Pop",
                 "{%#x (%s:%s)}",
                 this,
                 MapState(),
                 MapFunctionState()
                 ));

    INET_ASSERT(m_lpThreadInfo != NULL);
    CHECK_INTERNET_THREAD_INFO(m_lpThreadInfo);
    CHECK_FSM();
    CHECK_OWNED();
    CHECK_FSM_UNOWNED(m_Link);

    CFsm * pNextFsm = m_Link;

    m_lpThreadInfo->Fsm = pNextFsm;

    SET_FSM_OWNED(pNextFsm);

    DEBUG_PRINT(ASYNC,
                INFO,
                ("!!! FSM %#x owned by %#x\n",
                pNextFsm,
                GetCurrentThreadId()
                ));

    if (pNextFsm != NULL) {
        pNextFsm->SetState(pNextFsm->GetNextState());
        pNextFsm->SetError(GetError());

        DEBUG_PRINT(ASYNC,
                    INFO,
                    ("next FSM %#x (%s), state %s, function-state %s\n",
                    pNextFsm,
                    pNextFsm->MapType(),
                    pNextFsm->MapState(),
                    pNextFsm->MapFunctionState()
                    ));

    } else {

        DEBUG_PRINT(ASYNC,
                    INFO,
                    ("last FSM\n"
                    ));

    }

    DEBUG_LEAVE(0);
}


DWORD
CFsm::QueueWorkItem(
    VOID
    )

/*++

Routine Description:

    Queues this FSM to worker thread for processing. Worker thread callback is
    CFsm::RunWorkItem

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - return code from SHQueueUserWorkItem

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "CFsm::QueueWorkItem",
                 "{%#x [%s, socket %#x, block id %#x, timeout %#x, error %d, state %s:%s]}",
                 this,
                 MapType(),
                 GetSocket(),
                 GetBlockId(),
                 GetTimeout(),
                 GetError(),
                 MapState(),
                 MapFunctionState()
                 ));

    DWORD error = ERROR_IO_PENDING;

    RESET_OWNED();
    
    DEBUG_PRINT(SOCKETS,
                INFO,
                ("Posting IO completion with 0x%x\n",
                this
                ));


    DEBUG_ENTER((DBG_API,
                     Bool,
                     "***PostQueuedCompletionStatus",
                     "(hComp)%#x, (# bytes)%#x, (completionkey)%#x, (overlapped)%#x",
                     g_hCompletionPort,
                     COMPLETION_BYTES_CUSTOM,
                     this,
                     g_lpCustomOverlapped
                     ));

    if (PostQueuedCompletionStatus(g_hCompletionPort,
                                    COMPLETION_BYTES_CUSTOM,
                                    ULONG_PTR (this),
                                    g_lpCustomOverlapped
                                    ))
    {
        DEBUG_LEAVE(TRUE);  
#if INET_DEBUG
        InterlockedIncrement(&g_cCustomCompletions);
#endif
        LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

        INET_ASSERT(lpThreadInfo != NULL);

        if (lpThreadInfo != NULL)
            lpThreadInfo->Fsm = NULL;
    }
    else
    {
        DEBUG_LEAVE(FALSE);  
        
        error = GetLastError();
    }

    INET_ASSERT(error == ERROR_IO_PENDING);

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm::RunWorkItem(
    IN CFsm * pFsm
    )

/*++

Routine Description:

    Run the current work item to the next block state or completion. This
    (class static) function is called in the context of a system thread pool
    callback function

Arguments:

    pFsm    - pointer to FSM to run

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_WINHTTP_INTERNAL_ERROR

--*/

{
    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

    INET_ASSERT(lpThreadInfo != NULL);

    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        return ERROR_WINHTTP_INTERNAL_ERROR;
    }

    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "RunWorkItem",
                 "%#x",
                 pFsm
                 ));

    PERF_ENTER(Worker);

    DWORD error;

    DEBUG_PRINT(ASYNC,
                INFO,
                ("%s Fsm %#x: socket %#x, block id %#x, timeout %#x, error %d\n",
                pFsm->MapType(),
                pFsm,
                pFsm->GetSocket(),
                pFsm->GetBlockId(),
                pFsm->GetTimeout(),
                pFsm->GetError()
                ));

    INTERNET_HANDLE_BASE *pSession = (INTERNET_HANDLE_BASE *)(pFsm->GetMappedHandle());
    HANDLE ThreadToken = pSession->GetThreadToken();
    HANDLE ThreadHandle = GetCurrentThread();
    if (ThreadToken)
    {
        if (::SetThreadToken(&ThreadHandle,
                         &ThreadToken) == FALSE)
        {
            ThreadToken = 0;
        }

    }

    while (TRUE) {

        INET_ASSERT(pFsm != NULL);

        BOOL bIsApi = pFsm->IsApi();
        API_TYPE apiType = pFsm->GetApiType();
        FSM_TYPE fsmType = pFsm->GetType();

        lpThreadInfo->Fsm = pFsm;

        SET_FSM_OWNED(pFsm);

        // We could pass back a pointer from CFsm::Run in the case of READ_COMPLETE, so to account for
        // 64-bit, we need a bigger area:
        LPVOID      dwResultExtended = 0;
        DWORD       &dwResult= *(DWORD *)&dwResultExtended;
        DWORD       dwApiData= 0;

        if (pFsm->IsInvalid())
        {
            pFsm->SetErrorState(ERROR_WINHTTP_OPERATION_CANCELLED);
            pFsm->Run(lpThreadInfo, &dwResult, &dwApiData);
            error = ERROR_WINHTTP_OPERATION_CANCELLED;
        }
        else
        {
            error = pFsm->Run(lpThreadInfo, &dwResult, &dwApiData);
        }

        //
        // We should follow the following rules for this.
        //
        //  1)  If Operation Failed
        //
        //      error != ERROR_SUCCESS && dwResult == 0
        //
        //  To assign fields of INTERNET_ASYNC_RESULT, do:
        //
        //      INTERNET_ASYNC_RESULT.dwResult = 0
        //      INTERNET_ASYNC_RESULT.dwError = error
                
        //  2) If operation Succeeded
        //
        //  error == ERROR_SUCCESS && dwResult != 0
        //
        //  To assign fields of INTERNET_ASYNC_RESULT, do:
        //
        //      if( ApiReturnType == HINTERNET )
        //          INTERNET_ASYNC_RESULT.dwResult = (HINTERNET)dwApiResult
        //      else
        //          if( ApiReturnType == BOOL )
        //              INTERNET_ASYNC_RESULT.dwResult = TRUE
        //          endif
        //      endif
        //
        //      INTERNET_ASYNC_RESULT.dwError = dwApiData

        DEBUG_PRINT(ASYNC,
                    INFO,
                    ("dwResult = %d [%#x], dwApiData=%d [%#x], apiType = %s, error = %d\n",
                    dwResult, dwResult,
                    dwApiData, dwApiData,
                    (apiType==ApiType_Handle)?"HANDLE":"BOOL",
                    error));



        if (error == ERROR_IO_PENDING) {
            break;
        }
        pFsm = lpThreadInfo->Fsm;
        if (pFsm == NULL) {
            if (bIsApi
            && ((INTERNET_HANDLE_OBJECT *)lpThreadInfo->hObjectMapped)
                ->IsAsyncHandle()) {

                INET_ASSERT((apiType == ApiType_Handle)
                            || (apiType == ApiType_Bool));

                WINHTTP_ASYNC_RESULT asyncResult;


		/*
                asyncResult.dwResult = (apiType == ApiType_Handle)
                                     ? dwResult
                                     : (BOOL)(error == ERROR_SUCCESS);
		*/

                asyncResult.dwResult = (error == ERROR_SUCCESS
                                            ?((apiType == ApiType_Handle)
                                                ? dwResult
                                                : TRUE)
                                            :0);

                //
                // InternetQueryDataAvailable uses dwApiData to return the
                // number of bytes available, in addition to returning the
                // the value through the lpdwNumberOfBytesAvailable parameter
                //

                asyncResult.dwError = (error == ERROR_SUCCESS)
                                        ? dwApiData
                                        : error;
                SetLastError(error);

                //INET_ASSERT(((INTERNET_HANDLE_OBJECT *)lpThreadInfo->hObjectMapped)
                //            ->GetObjectType() == TypeHttpRequestHandle);

                DWORD dwStatus;
                DWORD dwFailureAPI = API_UNKNOWN;

                LPVOID lpvStatusInformation = (LPVOID)&asyncResult;
                DWORD dwStatusInformationLength = sizeof(asyncResult);
                switch(fsmType)
                {
                    case FSM_TYPE_HTTP_SEND_REQUEST:
                        if (dwResult == AR_HTTP_BEGIN_SEND_REQUEST)
                        {
                            dwStatus = WINHTTP_CALLBACK_STATUS_SENDREQUEST_COMPLETE;
                            dwFailureAPI = API_SEND_REQUEST;
                        }
                        else
                        {
                            dwStatus = WINHTTP_CALLBACK_STATUS_HEADERS_AVAILABLE;
                            dwFailureAPI = API_RECEIVE_RESPONSE;
                        }
                        break;
                        
                    case FSM_TYPE_QUERY_DATA_AVAILABLE:
                        dwStatus = WINHTTP_CALLBACK_STATUS_DATA_AVAILABLE;
                        if(error == ERROR_SUCCESS)
                        {
                            lpvStatusInformation = NULL;
                            dwStatusInformationLength = dwApiData;
                        }
                        else
                            dwFailureAPI = API_QUERY_DATA_AVAILABLE;
                        
                        break;
                    

                    // completion for WinHttpReadData:
                    case FSM_TYPE_READ_FILE:
                        dwStatus = WINHTTP_CALLBACK_STATUS_READ_COMPLETE;
                        if(error == ERROR_SUCCESS)
                        {
                            lpvStatusInformation = dwResultExtended;
                            dwStatusInformationLength = dwApiData;
                        }
                        else
                            dwFailureAPI = API_READ_DATA;
                       
                        break;
                    case FSM_TYPE_HTTP_WRITE:
                        dwStatus = WINHTTP_CALLBACK_STATUS_WRITE_COMPLETE;
                        dwFailureAPI = API_WRITE_DATA;
                        break;
                    default:
                        // Shouldn't hit this, if it does, we should see if a more appropriate notification is needed:
                        INET_ASSERT(FALSE);
                        dwStatus = WINHTTP_CALLBACK_STATUS_REQUEST_COMPLETE;
                        break;
                }

                if(error != ERROR_SUCCESS)
                {
                    dwStatus = WINHTTP_CALLBACK_STATUS_REQUEST_ERROR;
                    asyncResult.dwResult = dwFailureAPI;
                    // asyncResult.dwError contains the error code as appropriate.
                }
                
                InternetIndicateStatus(dwStatus,
                                       lpvStatusInformation,
                                       dwStatusInformationLength
                                       );

                //INET_ASSERT(((INTERNET_HANDLE_OBJECT *)lpThreadInfo->hObjectMapped)
                //            ->GetObjectType() == TypeHttpRequestHandle);

                DereferenceObject((LPVOID)lpThreadInfo->hObjectMapped);
            }
            break;
        } else if (bIsApi) {

            //
            // completing an async API that is not the last in the chain.
            // Typically, HttpSendRequest() within InternetOpenUrl()
            //

            DereferenceObject((LPVOID)lpThreadInfo->hObjectMapped);
        }
    }

    if (ThreadToken)
    {
        RevertToSelf();
    }

    PERF_LEAVE(Worker);

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm::Run(
    IN LPINTERNET_THREAD_INFO lpThreadInfo,
    OUT DWORD  *lpdwApiResult OPTIONAL,
    OUT DWORD  *lpdwApiData OPTIONAL
    )

/*++

Routine Description:

    Runs the state handler for this FSM

Arguments:

    lpThreadInfo    - INTERNET_THREAD_INFO for this thread

    lpdwApiResult   - where optional API result is written

    lpdwApiData     - where optional API data iswritten

Return Value:

    DWORD   - return code from state handler

--*/

{

    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "CFsm::Run",
                 "%#x, %#x [%#x], %#x [%#x]",
                 lpThreadInfo,
                 lpdwApiResult,
                 (lpdwApiResult?*lpdwApiResult:NULL),
                 lpdwApiData,
                 (lpdwApiData?*lpdwApiData:NULL)
                 ));

    CHECK_FSM();
    CHECK_OWNED();
    INET_ASSERT(lpThreadInfo != NULL);
    INET_ASSERT(lpThreadInfo->Fsm != NULL);

    DWORD error = ERROR_SUCCESS;

    _InternetSetObjectHandle(lpThreadInfo, m_hObject, m_hObjectMapped);

    m_lpThreadInfo = lpThreadInfo;

    while (TRUE) {

        DEBUG_PRINT(ASYNC,
                    INFO,
                    ("%s Fsm %#x state %s (%d) function-state %s (%d) error %s (%d)\n",
                    MapType(),
                    this,
                    MapState(),
                    GetState(),
                    MapFunctionState(),
                    GetFunctionState(),
                    InternetMapError(GetError()),
                    GetError()
                    ));

        error = (*m_lpfnHandler)(this);

        if (error == ERROR_IO_PENDING) {
            break;
        }
        
        SetError(error);
        SetMappedError(lpThreadInfo->dwMappedErrorCode);
        if (IsDone()) {

            DEBUG_PRINT(ASYNC,
                        INFO,
                        ("%s Fsm %#x done, next is %s %#x\n",
                        MapType(),
                        this,
                        m_Link ? m_Link->MapType() : "",
                        m_Link
                        ));

            if (lpdwApiResult != NULL) {
                *lpdwApiResult = GetApiResult();
            }
            if (lpdwApiData != NULL) {
                *lpdwApiData = GetApiData();
            }

            // This needs to happen only when the FSM is the top-level FSM, so we don't have to
            // touch the rest of the logic where CFsm::Run is called. We first save the values for
            // the FSMs we're interested in, in temporary variables. Then, once the FSM is destroyed
            // we check the LPINTERNET_THREAD_INFO to see if this was indeed the top-level-FSM.
            // If so, we jam the values saved into the parameters passed into Run. In this case,
            // we know that CFsm::RunWorkItem is the one that has called, so CFsm::RunWorkItem
            // knows how to interpret the values.

            // Stage#1:
            DWORD dwBytes = 0;
            LPVOID lpBufferExtended = 0;
            DWORD &lpBuffer = *(DWORD *)&lpBufferExtended;
            FSM_TYPE fsmType = GetType();
            if(fsmType == FSM_TYPE_HTTP_SEND_REQUEST)
                lpBuffer = (((CFsm_HttpSendRequest *)this)->m_arRequest);
                
            if(error == ERROR_SUCCESS)
            {
                switch(fsmType)
                {
                    case FSM_TYPE_QUERY_DATA_AVAILABLE:
                        dwBytes = *(((CFsm_QueryAvailable *)this)->m_lpdwNumberOfBytesAvailable);
                        break;

                    // completion for WinHttpReadData:
                    case FSM_TYPE_READ_FILE:
                        lpBufferExtended = (LPVOID) (((CFsm_ReadFile *)this)->m_lpBuffer);
                        dwBytes = *(((CFsm_ReadFile *)this)->m_lpdwNumberOfBytesRead);
                        break;
                }
            }
            // End Stage#1 

            DEBUG_PRINT(ASYNC,
                        INFO,
                        ("Fsm %#x finished with lpdwApiResult = %#x[%#x], lpdwApiData = %#x[%#x]\n",
                        this,
                		lpdwApiResult,
                		(lpdwApiResult == NULL)?NULL:*lpdwApiResult,
                		lpdwApiData,
                		(lpdwApiData == NULL)?NULL:*lpdwApiData
                		));

            INET_ASSERT (!IsOnAsyncList());
            delete this;

            // Stage#2:
            if (lpThreadInfo->Fsm == NULL) {
                // top-level completion:
                if(fsmType == FSM_TYPE_HTTP_SEND_REQUEST)
                    if (lpdwApiResult != NULL)
                        *lpdwApiResult = lpBuffer;
                    
                if(error == ERROR_SUCCESS)
                {
                    switch(fsmType)
                    {
                        case FSM_TYPE_QUERY_DATA_AVAILABLE:
                            if (lpdwApiData != NULL)
                                *lpdwApiData = dwBytes;
                            break;

                        // completion for WinHttpReadData:
                        case FSM_TYPE_READ_FILE:
                            if (lpdwApiResult != NULL)
                            {
                                LPVOID  &lpApiResultExtended = *(LPVOID *)lpdwApiResult;
                                lpApiResultExtended = lpBufferExtended;
                            }
                            if (lpdwApiData != NULL)
                                *lpdwApiData = dwBytes;
                            break;
                    }
                }
            }
            // End Stage#2


            break;
        }
        SetState(GetNextState());
    }

    DEBUG_LEAVE(error);

    return error;
}

#if INET_DEBUG

#if !defined(CASE_OF)
#define CASE_OF(x) case x: return #x
#endif

DEBUG_FUNCTION
LPSTR
CFsm::MapType(
    VOID
    ) {
    switch (m_Type) {
    case FSM_TYPE_NONE:                     return "NONE";
    case FSM_TYPE_WAIT_FOR_COMPLETION:      return "WAIT_FOR_COMPLETION";
    case FSM_TYPE_RESOLVE_HOST:             return "RESOLVE_HOST";
    case FSM_TYPE_SOCKET_CONNECT:           return "SOCKET_CONNECT";
    case FSM_TYPE_SOCKET_SEND:              return "SOCKET_SEND";
    case FSM_TYPE_SOCKET_RECEIVE:           return "SOCKET_RECEIVE";
    case FSM_TYPE_SOCKET_QUERY_AVAILABLE:   return "SOCKET_QUERY_AVAILABLE";
    case FSM_TYPE_SECURE_CONNECT:           return "SECURE_CONNECT";
    case FSM_TYPE_SECURE_HANDSHAKE:         return "SECURE_HANDSHAKE";
    case FSM_TYPE_SECURE_NEGOTIATE:         return "SECURE_NEGOTIATE";
    case FSM_TYPE_NEGOTIATE_LOOP:           return "NEGOTIATE_LOOP";
    case FSM_TYPE_SECURE_SEND:              return "SECURE_SEND";
    case FSM_TYPE_SECURE_RECEIVE:           return "SECURE_RECEIVE";
    case FSM_TYPE_GET_CONNECTION:           return "GET_CONNECTION";
    case FSM_TYPE_HTTP_SEND_REQUEST:        return "HTTP_SEND_REQUEST";
    case FSM_TYPE_MAKE_CONNECTION:          return "MAKE_CONNECTION";
    case FSM_TYPE_OPEN_CONNECTION:          return "OPEN_CONNECTION";
    case FSM_TYPE_OPEN_PROXY_TUNNEL:        return "OPEN_PROXY_TUNNEL";
    case FSM_TYPE_SEND_REQUEST:             return "SEND_REQUEST";
    case FSM_TYPE_RECEIVE_RESPONSE:         return "RECEIVE_RESPONSE";
    case FSM_TYPE_HTTP_READ:                return "HTTP_READ";
    case FSM_TYPE_HTTP_WRITE:               return "HTTP_WRITE";
    case FSM_TYPE_READ_DATA:                return "READ_DATA";
    case FSM_TYPE_HTTP_QUERY_AVAILABLE:     return "HTTP_QUERY_AVAILABLE";
    case FSM_TYPE_DRAIN_RESPONSE:           return "DRAIN_RESPONSE";
    case FSM_TYPE_REDIRECT:                 return "REDIRECT";
    case FSM_TYPE_READ_LOOP:                return "READ_LOOP";
    case FSM_TYPE_PARSE_HTTP_URL:           return "PARSE_HTTP_URL";
    case FSM_TYPE_PARSE_URL_FOR_HTTP:       return "PARSE_URL_FOR_HTTP";
    case FSM_TYPE_READ_FILE:                return "READ_FILE";
    case FSM_TYPE_READ_FILE_EX:             return "READ_FILE_EX";
    case FSM_TYPE_WRITE_FILE:               return "WRITE_FILE";
    case FSM_TYPE_QUERY_DATA_AVAILABLE:     return "QUERY_DATA_AVAILABLE";
    case FSM_TYPE_FTP_CONNECT:              return "FTP_CONNECT";
    case FSM_TYPE_FTP_FIND_FIRST_FILE:      return "FTP_FIND_FIRST_FILE";
    case FSM_TYPE_FTP_GET_FILE:             return "FTP_GET_FILE";
    case FSM_TYPE_FTP_PUT_FILE:             return "FTP_PUT_FILE";
    case FSM_TYPE_FTP_DELETE_FILE:          return "FTP_DELETE_FILE";
    case FSM_TYPE_FTP_RENAME_FILE:          return "FTP_RENAME_FILE";
    case FSM_TYPE_FTP_OPEN_FILE:            return "FTP_OPEN_FILE";
    case FSM_TYPE_FTP_CREATE_DIRECTORY:     return "FTP_CREATE_DIRECTORY";
    case FSM_TYPE_FTP_REMOVE_DIRECTORY:     return "FTP_REMOVE_DIRECTORY";
    case FSM_TYPE_FTP_SET_CURRENT_DIRECTORY:    return "FTP_SET_CURRENT_DIRECTORY";
    case FSM_TYPE_FTP_GET_CURRENT_DIRECTORY:    return "FTP_GET_CURRENT_DIRECTORY";
    case FSM_TYPE_GOPHER_FIND_FIRST_FILE:   return "GOPHER_FIND_FIRST_FILE";
    case FSM_TYPE_GOPHER_OPEN_FILE:         return "GOPHER_OPEN_FILE";
    case FSM_TYPE_GOPHER_GET_ATTRIBUTE:     return "GOPHER_GET_ATTRIBUTE";
    case FSM_TYPE_INTERNET_PARSE_URL:       return "INTERNET_PARSE_URL";
    case FSM_TYPE_INTERNET_FIND_NEXT_FILE:  return "INTERNET_FIND_NEXT_FILE";
    case FSM_TYPE_INTERNET_QUERY_DATA_AVAILABLE:    return "INTERNET_QUERY_DATA_AVAILABLE";
    case FSM_TYPE_INTERNET_WRITE_FILE:      return "INTERNET_WRITE_FILE";
    case FSM_TYPE_INTERNET_READ_FILE:       return "INTERNET_READ_FILE";
    }
    return "?";
}

DEBUG_FUNCTION
LPSTR
CFsm::StateName(
    IN DWORD State
    ) {
    switch (State) {
    CASE_OF(FSM_STATE_BAD);
    CASE_OF(FSM_STATE_INIT);
    CASE_OF(FSM_STATE_WAIT);
    CASE_OF(FSM_STATE_DONE);
    CASE_OF(FSM_STATE_ERROR);
    CASE_OF(FSM_STATE_CONTINUE);
    CASE_OF(FSM_STATE_FINISH);
    CASE_OF(FSM_STATE_1);
    CASE_OF(FSM_STATE_2);
    CASE_OF(FSM_STATE_3);
    CASE_OF(FSM_STATE_4);
    CASE_OF(FSM_STATE_5);
    CASE_OF(FSM_STATE_6);
    CASE_OF(FSM_STATE_7);
    CASE_OF(FSM_STATE_8);
    CASE_OF(FSM_STATE_9);
    CASE_OF(FSM_STATE_10);
    }
    return "?";
}

#endif // INET_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\common\caddrlst.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    caddrlst.cxx

Abstract:

    Contains CAddressList class definition

    Contents:
        CAddressList::FreeList
        CAddressList::SetList
        CAddressList::SetList
        CAddressList::GetNextAddress
        CAddressList::InvalidateAddress
        CAddressList::ResolveHost
        CFsm_ResolveHost::RunSM
        (CAddressList::IPAddressToAddressList)
        (CAddressList::HostentToAddressList)

Author:

    Richard L Firth (rfirth) 19-Apr-1997

Environment:

    Win32 user-mode DLL

Revision History:

    19-Apr-1997 rfirth
        Created

    28-Jan-1998 rfirth
        No longer randomly index address list. NT5 and Win98 are modified to
        return the address list in decreasing order of desirability by RTT/
        route

--*/

#include <wininetp.h>
#include <perfdiag.hxx>

//#define TEST_CODE

//Thread-procedure for async gethostbyname
DWORD WINAPI AsyncGetHostByName(LPVOID lpParameter);

//The destructor is called only when all refcounts have dropped to 0.
// i.e. when the INTERNET_HANDLE_OBJECT has released its reference, 
//      AND when all the GHBN threads are done.
//  At this point, we can flush the hostent cache and terminate list.
CResolverCache::~CResolverCache()
{
    FlushHostentCache(&_ResolverCache);
    TerminateSerializedList(&_ResolverCache);

    if (_pHandlesList)
        delete _pHandlesList;
}

void CResolverCache::ForceEmptyAndDeleteHandlesList()
{
    INET_ASSERT(_pHandlesList);
        
    _pHandlesList->LockList();

    CListItem* pItem = _pHandlesList->GetHead();

    while(pItem)
    {
        CListItem* pNext = pItem->GetNext();

        (((CGetHostItem*)pItem)->ForceDelete());
        delete pItem;
        _pHandlesList->ReduceCount();

        pItem = pNext;
    }

    //it's not going to be reused after this, so head and tail don't have to be set to NULL
    // on _pHandlesList
    _pHandlesList->UnlockList();
}

void CResolverCache::EmptyHandlesList()
{
    if (_pHandlesList)
    {
        _pHandlesList->LockList();

        CListItem* pItem = _pHandlesList->GetHead();

        while(pItem)
        {
            CListItem* pNext = pItem->GetNext();

            (((CGetHostItem*)pItem)->WaitDelete());
            delete pItem;
            _pHandlesList->ReduceCount();

            pItem = pNext;
        }

        //it's not going to be reused after this, so head and tail don't have to be set to NULL
        // on _pHandlesList
        _pHandlesList->UnlockList();
    }
}

void CResolverCache::TrimHandlesListSize(ULONG nTrimSize)
{        
    _pHandlesList->LockList();

    if (_pHandlesList->GetCount() >= nTrimSize)
    {
        CListItem* pItem = _pHandlesList->GetHead();
        CListItem* pPrev = NULL;

        while(pItem)
        {
            CListItem* pNext = pItem->GetNext();
            
            if (((CGetHostItem*)pItem)->CanBeDeleted())
            {
                if (pPrev)
                {
                	pPrev->SetNext(pNext);
                }
                else
                {
                    //The item being removed WAS the head.
                	_pHandlesList->SetHead(pNext);
                }

                if (!pNext)
                {
                    //The item being removed WAS the tail.
                    _pHandlesList->SetTail(pPrev);
                }
	
                delete pItem;
                _pHandlesList->ReduceCount();
            }
            else
            {  
                pPrev = pItem;
            }
            
            pItem = pNext;
        }
    }

    _pHandlesList->UnlockList();
}

BOOL CResolverCache::AddToHandlesList(HANDLE hThread, CGetHostItem* pGetHostItem)
{
    BOOL bRetval = TRUE;

    INET_ASSERT(_pHandlesList);
    pGetHostItem->SetThreadHandle(hThread);
    
    TrimHandlesListSize();
    _pHandlesList->AddToTail(pGetHostItem);

    return bRetval;    
}

DWORD WINAPI AsyncGetHostByName(LPVOID lpParameter)
{
#ifdef WINHTTP_FOR_MSXML
    //
    // MSXML needs to initialize is thread local storage data.
    // It does not do this during DLL_THREAD_ATTACH, so our
    // worker thread must explicitly call into MSXML to initialize
    // its TLS for this thread.
    //
    InitializeMsxmlTLS();
#endif

    CGetHostItem* pGetHostItem = (CGetHostItem*)lpParameter;
    LPSTR lpszHostName = pGetHostItem->GetHostName();
    LPHOSTENT lpHostEnt;
    DWORD dwError = 0;

    if (!(lpHostEnt = _I_gethostbyname(lpszHostName)))
    {
        dwError = _I_WSAGetLastError();
    }
    else
    {
        VOID* pAlloc = pGetHostItem->GetAllocPointer();
        CacheHostent((pGetHostItem->GetResolverCache())->GetResolverCacheList(), lpszHostName, lpHostEnt, LIVE_DEFAULT, &pAlloc, pGetHostItem->GetAllocSize());
        if (pAlloc)
        {
            //pAlloc is overwritten to NULL in CacheHostent if the memory is used,
            //we need to delete the alloced memory only if non-NULL
            pGetHostItem->SetDelete();
        }
    }

    return dwError;
}

//
// methods
//

VOID
CAddressList::FreeList(
    VOID
    )

/*++

Routine Description:

    Free address list

Arguments:

    None.

Return Value:

    None.

--*/

{
    if (m_Addresses != NULL) {
        m_Addresses = (LPRESOLVED_ADDRESS)FREE_MEMORY((HLOCAL)m_Addresses);

        INET_ASSERT(m_Addresses == NULL);

        m_AddressCount = 0;
        m_BadAddressCount = 0;
        m_CurrentAddress = 0;
    }
}


DWORD
CAddressList::SetList(
    IN DWORD dwIpAddress
    )

/*++

Routine Description:

    Sets the list contents from the IP address

Arguments:

    dwIpAddress - IP address from which to create list contents

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    if (!Acquire())
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    FreeList();

    DWORD error = IPAddressToAddressList(dwIpAddress);

    Release();

    return error;
}


DWORD
CAddressList::SetList(
    IN LPHOSTENT lpHostent
    )

/*++

Routine Description:

    Sets the list contents from the hostent

Arguments:

    lpHostent   - pointer to hostent containing resolved addresses to add

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    if (!Acquire())
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    FreeList();

    DWORD error = HostentToAddressList(lpHostent);

    Release();

    return error;
}


BOOL
CAddressList::GetNextAddress(
    OUT LPDWORD lpdwResolutionId,
    IN OUT LPDWORD lpdwIndex,
    IN INTERNET_PORT nPort,
    OUT LPCSADDR_INFO lpAddressInfo
    )

/*++

Routine Description:

    Get next address to use when connecting. If we already have a preferred
    address, use that. We make a copy of the address to use in the caller's
    data space

Arguments:

    lpdwResolutionId    - used to determine whether the address list has been
                          resolved between calls

    lpdwIndex           - IN: current index tried; -1 if we want to try default
                          OUT: index of address address returned if successful

    nPort               - which port we want to connect to

    lpAddressInfo       - pointer to returned address if successful

Return Value:

    BOOL
        TRUE    - lpResolvedAddress contains resolved address to use

        FALSE   - need to (re-)resolve name

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Bool,
                 "CAddressList::GetNextAddress",
                 "%#x [%d], %#x [%d], %d, %#x",
                 lpdwResolutionId,
                 *lpdwResolutionId,
                 lpdwIndex,
                 *lpdwIndex,
                 nPort,
                 lpAddressInfo
                 ));

    PERF_ENTER(GetNextAddress);

    BOOL bOk = TRUE;

    //
    // if we tried all the addresses and failed already, re-resolve the name
    //

    if (!Acquire())
    {
        bOk = FALSE;
        goto quit;
    }

    if (m_BadAddressCount < m_AddressCount) {
        if (*lpdwIndex != (DWORD)-1) {

            INET_ASSERT(m_BadAddressCount < m_AddressCount);

            INT i = 0;

            m_CurrentAddress = *lpdwIndex;

            INET_ASSERT((m_CurrentAddress >= 0)
                        && (m_CurrentAddress < m_AddressCount));

            if ((m_CurrentAddress < 0) || (m_CurrentAddress >= m_AddressCount)) {
                m_CurrentAddress = 0;
            }
            do {
                NextAddress();
                if (++i == m_AddressCount) {
                    bOk = FALSE;
                    break;
                }
            } while (!IsCurrentAddressValid());
        }

        //
        // check to make sure this address hasn't expired
        //

        //if (!CheckHostentCacheTtl()) {
        //    bOk = FALSE;
        //}
    } else {

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("exhausted %d addresses\n",
                    m_BadAddressCount
                    ));

        bOk = FALSE;
    }
    if (bOk) {

        DWORD dwLocalLength = LocalSockaddrLength();
        LPBYTE lpRemoteAddr = (LPBYTE)(lpAddressInfo + 1) + dwLocalLength;

        memcpy(lpAddressInfo + 1, LocalSockaddr(), dwLocalLength);
        memcpy(lpRemoteAddr, RemoteSockaddr(), RemoteSockaddrLength());
        lpAddressInfo->LocalAddr.lpSockaddr = (LPSOCKADDR)(lpAddressInfo + 1);
        lpAddressInfo->LocalAddr.iSockaddrLength = dwLocalLength;
        lpAddressInfo->RemoteAddr.lpSockaddr = (LPSOCKADDR)lpRemoteAddr;
        lpAddressInfo->RemoteAddr.iSockaddrLength = RemoteSockaddrLength();
        lpAddressInfo->iSocketType = SocketType();
        lpAddressInfo->iProtocol = Protocol();
        ((LPSOCKADDR_IN)lpAddressInfo->RemoteAddr.lpSockaddr)->sin_port =
            _I_htons((unsigned short)nPort);
        *lpdwIndex = m_CurrentAddress;

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("current address = %d.%d.%d.%d\n",
                    ((LPBYTE)RemoteSockaddr())[4] & 0xff,
                    ((LPBYTE)RemoteSockaddr())[5] & 0xff,
                    ((LPBYTE)RemoteSockaddr())[6] & 0xff,
                    ((LPBYTE)RemoteSockaddr())[7] & 0xff
                    ));

//dprintf("returning address %d.%d.%d.%d, index %d:%d\n",
//        ((LPBYTE)RemoteSockaddr())[4] & 0xff,
//        ((LPBYTE)RemoteSockaddr())[5] & 0xff,
//        ((LPBYTE)RemoteSockaddr())[6] & 0xff,
//        ((LPBYTE)RemoteSockaddr())[7] & 0xff,
//        m_ResolutionId,
//        m_CurrentAddress
//        );
    }
    *lpdwResolutionId = m_ResolutionId;

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("ResolutionId = %d, Index = %d\n",
                m_ResolutionId,
                m_CurrentAddress
                ));

    Release();

quit:
    PERF_LEAVE(GetNextAddress);

    DEBUG_LEAVE(bOk);

    return bOk;
}
	

VOID
CAddressList::InvalidateAddress(
    IN DWORD dwResolutionId,
    IN DWORD dwAddressIndex
    )

/*++

Routine Description:

    We failed to create a connection. Invalidate the address so other requests
    will try another address

Arguments:

    dwResolutionId  - used to ensure coherency of address list

    dwAddressIndex  - which address to invalidate

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 None,
                 "CAddressList::InvalidateAddress",
                 "%d, %d",
                 dwResolutionId,
                 dwAddressIndex
                 ));
//dprintf("invalidating %d.%d.%d.%d, index %d:%d\n",
//        ((LPBYTE)RemoteSockaddr())[4] & 0xff,
//        ((LPBYTE)RemoteSockaddr())[5] & 0xff,
//        ((LPBYTE)RemoteSockaddr())[6] & 0xff,
//        ((LPBYTE)RemoteSockaddr())[7] & 0xff,
//        dwResolutionId,
//        dwAddressIndex
//        );
    if (!Acquire())
        goto quit;  // just take the hit of trying again, if we can.

    //
    // only do this if the list is the same age as when the caller last tried
    // an address
    //

    if (dwResolutionId == m_ResolutionId) {

        INET_ASSERT(((INT)dwAddressIndex >= 0)
                    && ((INT)dwAddressIndex < m_AddressCount));

        if (dwAddressIndex < (DWORD)m_AddressCount) {
            m_Addresses[dwAddressIndex].IsValid = FALSE;

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("invalidated address %d.%d.%d.%d\n",
                        ((LPBYTE)RemoteSockaddr())[4] & 0xff,
                        ((LPBYTE)RemoteSockaddr())[5] & 0xff,
                        ((LPBYTE)RemoteSockaddr())[6] & 0xff,
                        ((LPBYTE)RemoteSockaddr())[7] & 0xff
                        ));

            INET_ASSERT(m_BadAddressCount <= m_AddressCount);

            if (m_BadAddressCount < m_AddressCount) {
                ++m_BadAddressCount;
                if (m_BadAddressCount < m_AddressCount) {
                    for (int i = 0;
                         !IsCurrentAddressValid() && (i < m_AddressCount);
                         ++i) {
                        NextAddress();
                    }
                }
            }
        }
    }
    Release();

quit:

    DEBUG_LEAVE(0);
}


DWORD
CAddressList::ResolveHost(
    IN LPSTR lpszHostName,
    IN OUT LPDWORD lpdwResolutionId,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Resolves host name (or (IP-)address)

    BUGBUG: Ideally, we don't want to keep hold of worker threads if we are in
            the blocking gethostbyname() call. But correctly handling this is
            difficult, so we always block the thread while we are resolving.
            For this reason, an async request being run on an app thread should
            have switched to a worker thread before calling this function.

Arguments:

    lpszHostName        - host name (or IP-address) to resolve

    lpdwResolutionId    - used to determine whether entry changed

    dwFlags             - controlling request:

                            SF_INDICATE - if set, make indications via callback

                            SF_FORCE    - if set, force (re-)resolve

Return Value:

    DWORD
        Success - ERROR_SUCCESS
                    Name successfully resolved

        Failure - ERROR_WINHTTP_NAME_NOT_RESOLVED
                    Couldn't resolve the name

                  ERROR_NOT_ENOUGH_MEMORY
                    Couldn't allocate memory for the FSM
--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CAddressList::ResolveHost",
                 "%q, %d, %#x",
                 lpszHostName,
                 *lpdwResolutionId,
                 dwFlags
                 ));

    DWORD error;

    error = DoFsm(New CFsm_ResolveHost(lpszHostName,
                                       lpdwResolutionId,
                                       dwFlags,
                                       this
                                       ));

//quit:

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_ResolveHost::RunSM(
    IN CFsm * Fsm
    )
{
    DEBUG_ENTER((DBG_SESSION,
                 Dword,
                 "CFsm_ResolveHost::RunSM",
                 "%#x",
                 Fsm
                 ));

    CAddressList * pAddressList = (CAddressList *)Fsm->GetContext();
    CFsm_ResolveHost * stateMachine = (CFsm_ResolveHost *)Fsm;
    DWORD error;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = pAddressList->ResolveHost_Fsm(stateMachine);
        break;

    case FSM_STATE_ERROR:
        error = Fsm->GetError();
        Fsm->SetDone();
        break;

    default:
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_WINHTTP_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CAddressList::ResolveHost_Fsm(
    IN CFsm_ResolveHost * Fsm
    )
{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CAddressList::ResolveHost_Fsm",
                 "%#x(%q, %#x [%d], %#x)",
                 Fsm,
                 Fsm->m_lpszHostName,
                 Fsm->m_lpdwResolutionId,
                 *Fsm->m_lpdwResolutionId,
                 Fsm->m_dwFlags
                 ));

    PERF_ENTER(ResolveHost);

    //
    // restore variables from FSM object
    //

    CFsm_ResolveHost & fsm = *Fsm;
    LPSTR lpszHostName = fsm.m_lpszHostName;
    LPDWORD lpdwResolutionId = fsm.m_lpdwResolutionId;
    DWORD dwFlags = fsm.m_dwFlags;
    LPINTERNET_THREAD_INFO lpThreadInfo = fsm.GetThreadInfo();
    INTERNET_HANDLE_BASE * pHandle = fsm.GetMappedHandleObject();
    DWORD error = ERROR_SUCCESS;
    CResolverCache* pResolverCache = GetRootHandle(pHandle)->GetResolverCache();
    DWORD dwWaitTime;
    LPHOSTENT lpHostent = NULL;
    DWORD ttl;

    
    //
    // BUGBUG - RLF 04/23/97
    //
    // This is sub-optimal. We want to block worker FSMs and free up the worker
    // thread. Sync client threads can wait. However, since a clash is not very
    // likely, we'll block all threads for now and come up with a better
    // solution later (XTLock).
    //
    // Don't have time to implement the proper solution now
    //

    if (!Acquire())
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    //
    // if the resolution id is different then the name has already been resolved
    //

    if (*lpdwResolutionId != m_ResolutionId) 
    {
        goto done;
    }

    //
    // if we're an app thread making an async request then go async now rather
    // than risk blocking the app thread. This will be the typical scenario for
    // IE, and we care about little else
    //
    // BUGBUG - RLF 05/20/97
    //
    // We should really lock & test the cache first, but let's do that after
    // Beta2 (its perf work)
    //

    // It cannot happen that this condition be true.
    // WinHttpSendRequest would have queued an async fsm if it was async to begin with.
    INET_ASSERT(lpThreadInfo->IsAsyncWorkerThread
                || !pHandle->IsAsyncHandle());
/*
    if (!lpThreadInfo->IsAsyncWorkerThread
        && pHandle->IsAsyncHandle()
        && (fsm.GetAppContext() != NULL)) 
    {

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("async request on app thread - jumping to hyper-drive\n"
                    ));

        error = Fsm->QueueWorkItem();
        goto done;
    }
 */
    //
    // throw out current list (if any)
    //

    FreeList();

    //
    // let the app know we are resolving the name
    //

    if (dwFlags & SF_INDICATE) 
    {
        error = InternetIndicateStatusString(WINHTTP_CALLBACK_STATUS_RESOLVING_NAME,
                                        lpszHostName,
                                        TRUE/*bCopyBuffer*/
                                        );
                                        
        //bail out if aborted before network operation.
        if (error != ERROR_SUCCESS)
        {
            INET_ASSERT(error == ERROR_WINHTTP_OPERATION_CANCELLED);
            goto done;
        }
    }

    //
    // figure out if we're being asked to resolve a name or an address. If
    // inet_addr() succeeds then we were given a string representation of an
    // address
    //

    DWORD ipAddr;
//dprintf("resolving %q\n", lpszHostName);
    ipAddr = _I_inet_addr(lpszHostName);
    if (ipAddr != INADDR_NONE) 
    {

        //
        // IP address was passed in. Simply convert to address list and quit
        //

        error = SetList(ipAddr);
        goto quit;
    }

    //
    // 255.255.255.255 (or 65535.65535 or 16777215.255) would never work anyway
    //

    INET_ASSERT(lstrcmp(lpszHostName, "255.255.255.255"));

    //
    // now try to find the name or address in the cache. If it's not in the
    // cache then resolve it
    //

    if (!(dwFlags & SF_FORCE)
    && QueryHostentCache(pResolverCache->GetResolverCacheList(), lpszHostName, NULL, &lpHostent, &ttl)) 
    {
        error = SetList(lpHostent);
        ReleaseHostentCacheEntry(pResolverCache->GetResolverCacheList(), lpHostent);
        ++m_ResolutionId;
        goto quit;
    }
    
    //
    // if we call winsock gethostbyname() then we don't get to find out the
    // time-to-live as returned by DNS, so we have to use the default value
    // (LIVE_DEFAULT)
    //
    
    dwWaitTime = GetTimeoutValue(WINHTTP_OPTION_RESOLVE_TIMEOUT);

    // if a resolve timeout is specified by the application, then honor it.
    // If anything fails in the async pathway, DON'T default to sync GHBN.
    if (dwWaitTime != INFINITE)
    {
        DWORD dwThreadId;
        LPSTR lpszCopyHostName = NewString(lpszHostName);
        
        if (lpszCopyHostName)
        {
#define SZ_AVG_RESOLVER_ENTRY_BYTES 512
            VOID* pAlloc = ALLOCATE_MEMORY(LMEM_FIXED, SZ_AVG_RESOLVER_ENTRY_BYTES);
            CGetHostItem* pGetHostItem = New CGetHostItem(lpszCopyHostName, pResolverCache, pAlloc, pAlloc?SZ_AVG_RESOLVER_ENTRY_BYTES:0);

            if (!pGetHostItem)
            {
                FREE_FIXED_MEMORY(lpszCopyHostName);
                goto failed;
            }
            
            HANDLE hThread = 0;

            WRAP_REVERT_USER(CreateThread, (NULL, 0, &AsyncGetHostByName,
            					pGetHostItem, 0, &dwThreadId), hThread);

            // HANDLE hThread = CreateThread(NULL, 0, &AsyncGetHostByName,
            //					pGetHostItem, 0, &dwThreadId);

            if (!hThread)
            {
                delete pGetHostItem;
                goto failed;
            }
            
            DWORD dwWaitResponse = WaitForSingleObject(hThread, dwWaitTime);

            if (dwWaitResponse == WAIT_OBJECT_0)
            {
                DWORD dwError;
                BOOL fRet = GetExitCodeThread(hThread, &dwError); //want to use this error?

                INET_ASSERT(dwError != STILL_ACTIVE);

                if (fRet && !dwError && QueryHostentCache(pResolverCache->GetResolverCacheList(), lpszCopyHostName, NULL, &lpHostent, &ttl))
                {
                    error = SetList(lpHostent);
                    ReleaseHostentCacheEntry(pResolverCache->GetResolverCacheList(), lpHostent);
                    ++m_ResolutionId;
                }

                CloseHandle(hThread);
                delete pGetHostItem;

                DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("%q %sresolved\n",
                    lpszHostName,
                    lpHostent ? "" : "NOT "
                    ));					
            }				
            else //(dwWaitResponse == WAIT_TIMEOUT)
            {
            	//let thread die and if it successfully resolved host, it can add to cache.
                pResolverCache->AddToHandlesList(hThread, pGetHostItem);
            }
        } //lpszCopyHostName
    }// dwWaitTime (specified on this handle)
    else
    {
        //synchronous get host by name
        
        lpHostent = _I_gethostbyname(lpszHostName);

        DEBUG_PRINT(SOCKETS,
            INFO,
            ("%q %sresolved\n",
            lpszHostName,
            lpHostent ? "" : "NOT "
            ));

        if (lpHostent != NULL) 
        {
            CacheHostent(pResolverCache->GetResolverCacheList(), lpszHostName, lpHostent, LIVE_DEFAULT);
            error = SetList(lpHostent);
            ++m_ResolutionId;
        }
    }
    
failed:

    if (!lpHostent)
    {
        error = ERROR_WINHTTP_NAME_NOT_RESOLVED;
    }

quit:

    if ((error == ERROR_SUCCESS) && (dwFlags & SF_INDICATE)) {

        //
        // inform the app that we have resolved the name
        //

        InternetIndicateStatusAddress(WINHTTP_CALLBACK_STATUS_NAME_RESOLVED,
                                      RemoteSockaddr(),
                                      RemoteSockaddrLength()
                                      );
    }
    *lpdwResolutionId = m_ResolutionId;

done:

    Release();

exit:

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();
        //PERF_LEAVE(ResolveHost);
    }

    PERF_LEAVE(ResolveHost);

    DEBUG_LEAVE(error);

    return error;
}

//
// private methods
//


PRIVATE
DWORD
CAddressList::IPAddressToAddressList(
    IN DWORD ipAddr
    )

/*++

Routine Description:

    Converts an IP-address to a RESOLVED_ADDRESS

Arguments:

    ipAddr  - IP address to convert

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    LPRESOLVED_ADDRESS address = (LPRESOLVED_ADDRESS)ALLOCATE_MEMORY(
                                                        LMEM_FIXED,
                                                        sizeof(RESOLVED_ADDRESS)

                                                        //
                                                        // 1 local and 1 remote
                                                        // socket address
                                                        //

                                                        + 2 * sizeof(SOCKADDR)
                                                        );
    if (address == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    LPBYTE lpVariable;
    LPSOCKADDR_IN lpSin;

    lpVariable = (LPBYTE)address + (sizeof(RESOLVED_ADDRESS));

    //
    // for each IP address in the hostent, build a CSADDR_INFO structure:
    // create a local SOCKADDR containing only the address family (AF_INET),
    // everything else is zeroed; create a remote SOCKADDR containing the
    // address family (AF_INET), zero port value and the IP address
    // presented in the arguments
    //

    address->AddrInfo.LocalAddr.lpSockaddr = (LPSOCKADDR)lpVariable;
    address->AddrInfo.LocalAddr.iSockaddrLength = sizeof(SOCKADDR);
    lpSin = (LPSOCKADDR_IN)lpVariable;
    lpVariable += sizeof(*lpSin);
    lpSin->sin_family = AF_INET;
    lpSin->sin_port = 0;
    *(LPDWORD)&lpSin->sin_addr = INADDR_ANY;
    memset(lpSin->sin_zero, 0, sizeof(lpSin->sin_zero));

    address->AddrInfo.RemoteAddr.lpSockaddr = (LPSOCKADDR)lpVariable;
    address->AddrInfo.RemoteAddr.iSockaddrLength = sizeof(SOCKADDR);
    lpSin = (LPSOCKADDR_IN)lpVariable;
    lpVariable += sizeof(*lpSin);
    lpSin->sin_family = AF_INET;
    lpSin->sin_port = 0;
    *(LPDWORD)&lpSin->sin_addr = ipAddr;
    memset(lpSin->sin_zero, 0, sizeof(lpSin->sin_zero));

    address->AddrInfo.iSocketType = SOCK_STREAM;
    address->AddrInfo.iProtocol = IPPROTO_TCP;
    address->IsValid = TRUE;

    //
    // update the object
    //

    INET_ASSERT(m_AddressCount == 0);
    INET_ASSERT(m_Addresses == NULL);

    m_AddressCount = 1;
    m_BadAddressCount = 0;
    m_Addresses = address;
    m_CurrentAddress = 0;   // only one to choose from
    return ERROR_SUCCESS;
}


PRIVATE
DWORD
CAddressList::HostentToAddressList(
    IN LPHOSTENT lpHostent
    )

/*++

Routine Description:

    Converts a HOSTENT structure to an array of RESOLVED_ADDRESSs

Arguments:

    lpHostent   - pointer to HOSTENT to convert

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    INET_ASSERT(lpHostent != NULL);

    LPBYTE * addressList = (LPBYTE *)lpHostent->h_addr_list;

    INET_ASSERT(addressList[0]);

    //
    // first off, figure out how many addresses there are in the hostent
    //

    int nAddrs;

    if (fDontUseDNSLoadBalancing) {
        nAddrs = 1;
    } else {
        for (nAddrs = 0; addressList[nAddrs] != NULL; ++nAddrs) {
            /* NOTHING */
        }
#ifdef TEST_CODE
        nAddrs = 4;
#endif
    }

    LPRESOLVED_ADDRESS addresses = (LPRESOLVED_ADDRESS)ALLOCATE_MEMORY(
                                                LMEM_FIXED,
                                                nAddrs * (sizeof(RESOLVED_ADDRESS)

                                                //
                                                // need 1 local and 1 remote socket
                                                // address for each
                                                //

                                                + 2 * sizeof(SOCKADDR))
                                                );
    if (addresses == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // for each IP address in the hostent, build a RESOLVED_ADDRESS structure:
    // create a local SOCKADDR containing only the address family (AF_INET),
    // everything else is zeroed; create a remote SOCKADDR containing the
    // address family (AF_INET), zero port value, and the IP address from
    // the hostent presented in the arguments
    //

    LPBYTE lpVariable = (LPBYTE)addresses + (nAddrs * sizeof(RESOLVED_ADDRESS));
    LPSOCKADDR_IN lpSin;

    for (int i = 0; i < nAddrs; ++i) {

        addresses[i].AddrInfo.LocalAddr.lpSockaddr = (LPSOCKADDR)lpVariable;
        addresses[i].AddrInfo.LocalAddr.iSockaddrLength = sizeof(SOCKADDR);
        lpSin = (LPSOCKADDR_IN)lpVariable;
        lpVariable += sizeof(*lpSin);
        lpSin->sin_family = AF_INET;
        lpSin->sin_port = 0;
        *(LPDWORD)&lpSin->sin_addr = INADDR_ANY;
        memset(lpSin->sin_zero, 0, sizeof(lpSin->sin_zero));
        addresses[i].AddrInfo.RemoteAddr.lpSockaddr = (LPSOCKADDR)lpVariable;
        addresses[i].AddrInfo.RemoteAddr.iSockaddrLength = sizeof(SOCKADDR);
        lpSin = (LPSOCKADDR_IN)lpVariable;
        lpVariable += sizeof(*lpSin);
        lpSin->sin_family = AF_INET;
        lpSin->sin_port = 0;
#ifdef TEST_CODE
        //if (i) {
            *(LPDWORD)&lpSin->sin_addr = 0x04030201;
            //*(LPDWORD)&lpSin->sin_addr = 0x1cfe379d;
        //}
#else
        *(LPDWORD)&lpSin->sin_addr = *(LPDWORD)addressList[i];
#endif
        memset(lpSin->sin_zero, 0, sizeof(lpSin->sin_zero));

        addresses[i].AddrInfo.iSocketType = SOCK_STREAM;
        addresses[i].AddrInfo.iProtocol = IPPROTO_TCP;
        addresses[i].IsValid = TRUE;
    }
#ifdef TEST_CODE
    *((LPDWORD)&((LPSOCKADDR_IN)addresses[3].AddrInfo.RemoteAddr.lpSockaddr)->sin_addr) = *(LPDWORD)addressList[0];
    //((LPSOCKADDR_IN)addresses[7].AddrInfo.RemoteAddr.lpSockaddr)->sin_addr = ((LPSOCKADDR_IN)addresses[0].AddrInfo.RemoteAddr.lpSockaddr)->sin_addr;
    //*((LPDWORD)&((LPSOCKADDR_IN)addresses[0].AddrInfo.RemoteAddr.lpSockaddr)->sin_addr) = 0x04030201;
#endif

    //
    // update the object
    //

    INET_ASSERT(m_AddressCount == 0);
    INET_ASSERT(m_Addresses == NULL);

    m_AddressCount = nAddrs;
    m_BadAddressCount = 0;
    m_Addresses = addresses;
    m_CurrentAddress = 0;
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\common\priolist.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    priolist.cxx

Abstract:

    Contains prioritized, serialized list class implementation

    Contents:
        CPriorityList::Insert
        CPriorityList::Remove

Author:

    Richard L Firth (rfirth) 03-May-1997

Notes:

    Properly, the CPriorityList class should extend a CSerializedList class, but
    we don't currently have one, just a serialized list type (common\serialst.cxx).

    WARNING: Code in this module makes assumptions about the contents of a
    SERIALIZED_LIST

Revision History:

    03-May-1997 rfirth
        Created

--*/

#include <wininetp.h>

//
// class methods
//


DWORD
CPriorityList::Insert(
    IN CPriorityListEntry * pEntry
    )

/*++

Routine Description:

    Insert prioritized list entry into prioritized, serialized list

Arguments:

    pEntry  - pointer to prioritized list entry to add

Return Value:

    ERROR_SUCCESS

    ERROR_NOT_ENOUGH_MEMORY - returned when lock can't be acquired.

--*/

{
    DEBUG_ENTER((DBG_UTIL,
                 None,
                 "CPriorityList::Insert",
                 "{%#x} %#x",
                 this,
                 pEntry
                 ));

    DWORD error = ERROR_SUCCESS;

    if (!Acquire())
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    INET_ASSERT(!IsOnSerializedList(&m_List, pEntry->List()));
    INET_ASSERT(pEntry->Next() == NULL);
    INET_ASSERT(pEntry->Prev() == NULL);

    CPriorityListEntry * pCur;

    for (pCur = (CPriorityListEntry *)m_List.List.Flink;
         pCur != (CPriorityListEntry *)&m_List.List.Flink;
         pCur = (CPriorityListEntry *)pCur->Next()) {

        if (pCur->GetPriority() < pEntry->GetPriority()) {
            break;
        }
    }
    InsertHeadList(pCur->Prev(), pEntry->List());
    ++m_List.ElementCount;
    Release();

quit:
    DEBUG_LEAVE(error);

    return error;
}


DWORD
CPriorityList::Remove(
    IN CPriorityListEntry * pEntry
    )

/*++

Routine Description:

    Remove entry from prioritized serialized list

Arguments:

    pEntry  - address of entry to remove

Return Value:

    ERROR_SUCCESS

    ERROR_NOT_ENOUGH_MEMORY - returned when lock can't be acquired.
                              Note:  All current cases have already acquired the lock

--*/

{
    DEBUG_ENTER((DBG_UTIL,
                 None,
                 "CPriorityList::Remove",
                 "{%#x} %#x",
                 this,
                 pEntry
                 ));

    DWORD dwError = ERROR_SUCCESS;

    if (Acquire())
    {

        INET_ASSERT(IsOnSerializedList(&m_List, pEntry->List()));

        pEntry->Remove();
        --m_List.ElementCount;
        Release();
    }
    else
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
    }

    DEBUG_LEAVE(dwError);
    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\common\reslock.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    reslock.cxx

Abstract:

    Contains methods for RESOURCE_LOCK class

    Contents:
        RESOURCE_LOCK::Acquire()
        RESOURCE_LOCK::Release()

Author:

    Richard L Firth (rfirth) 18-Jun-1996

Revision History:

    18-Jun-1996 rfirth
        Created

--*/

#include <wininetp.h>

//
// class members
//

#ifdef OLD_VERSION


BOOL
RESOURCE_LOCK::Acquire(
    IN BOOL bExclusiveMode
    )

/*++

Routine Description:

    Acquires the resource protected by this lock. Acquires for non-exclusive
    (read) or exclusive (write) ownership

Arguments:

    bExclusiveMode  - TRUE if we are acquiring the resource for exclusive
                      (write) ownership

Return Value:

    BOOL
        TRUE    - resource is acquired

        FALSE   - failed to acquire resource (timeout?)

--*/

{
    DEBUG_ENTER((DBG_RESLOCK,
                Bool,
                "RESOURCE_LOCK::Acquire",
                "%B",
                bExclusiveMode
                ));

    INET_ASSERT(this != NULL);
    //INET_ASSERT(IsInitialized());
    //INET_ASSERT(IsValid());

    if (!IsInitialized()) {

        DEBUG_LEAVE(FALSE);

        return FALSE;
    }

    BOOL acquired = TRUE;

    //_CritSect.Lock();
    if (bExclusiveMode) {

        //
        // acquired for exclusive ownership (write access). Set the owning
        // thread id and wait for the last current reader to release. Note
        // that if we're being re-entered, the Lock() has already
        // done the work of checking the thread id and updating re-entrancy
        // counts, so if its already not zero, we know it must be us
        //

        ++_WriteCount;
        if (_ThreadId == 0) {
            _ThreadId = GetCurrentThreadId();
#if INET_DEBUG
            INET_ASSERT(_ThreadId != _ThreadIdReader);
#endif
            acquired = Wait(_hWriteEvent);
            _CritSect.Lock();
        } else {

            INET_ASSERT(_ThreadId == GetCurrentThreadId());

        }
    } else {

        //
        // don't allow re-entry if already held for exclusive access
        //

        INET_ASSERT(_ThreadId == 0);

        //
        // acquired for non-exclusive ownership (read access). Just increase
        // the number of active readers. If this is the first then inhibit the
        // writer
        //

        if (InterlockedIncrement(&_Readers) == 0) {
#if INET_DEBUG
            if (_ThreadIdReader == 0) {
                _ThreadIdReader = GetCurrentThreadId();
            }
#endif
            ResetEvent(_hWriteEvent);
        }

        //
        // reader doesn't need to keep hold of critical section
        //

        //_CritSect.Unlock();
    }

    DEBUG_LEAVE(acquired);

    return acquired;
}


VOID
RESOURCE_LOCK::Release(
    VOID
    )

/*++

Routine Description:

    Releases a resource previously acquired by RESOURCE_LOCK::Acquire()

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_RESLOCK,
                None,
                "RESOURCE_LOCK::Release",
                NULL
                ));

    INET_ASSERT(this != NULL);
    //INET_ASSERT(IsInitialized());
    //INET_ASSERT(IsValid());

    if (!IsInitialized()) {

        DEBUG_LEAVE(0);

        return;
    }

    if ((_ThreadId != 0) && (_ThreadId == GetCurrentThreadId())) {

        INET_ASSERT(_WriteCount > 0);

        if (--_WriteCount == 0) {

            //
            // we acquired _hWriteEvent; signal it to allow next writer to continue
            //

            SetEvent(_hWriteEvent);

            //
            // this resource no longer owned for exclusive access
            //

            _ThreadId = 0;
        }
        _CritSect.Unlock();
    } else if (InterlockedDecrement(&_Readers) < 0) {

        INET_ASSERT(_Readers >= -1);

        //
        // we are last currently active reader; allow waiting writer to continue
        //

#if INET_DEBUG
        if (_ThreadIdReader == GetCurrentThreadId()) {
            _ThreadIdReader = 0;
        }
#endif
        SetEvent(_hWriteEvent);
    }

    DEBUG_LEAVE(0);
}

#else

BOOL
RESOURCE_LOCK::Acquire(
    IN BOOL bExclusiveMode
    )
{
    DEBUG_ENTER((DBG_RESLOCK,
                Bool,
                "RESOURCE_LOCK::Acquire",
                "%B",
                bExclusiveMode
                ));

    BOOL fReturn = TRUE;

    if (!IsInitialized()) {

        fReturn = FALSE;
        goto quit;
    }

    if (bExclusiveMode) {
        do {

            DEBUG_PRINT(RESLOCK,
                        INFO,
                        ("Waiting on WriteEvent\n")
                        );

            if (_ThreadId != GetCurrentThreadId()) {
                Wait(_hWriteEvent);
            }
            
            if (!_CritSect.Lock())
            {
                DEBUG_PRINT(RESLOCK,
                            ERROR,
                            ("Failed to obtain critsec lock after waiting on WriteEvent\n")
                            );
                fReturn = FALSE;
                break;
            }

            INET_ASSERT((_ThreadId == 0) || (_ThreadId == GetCurrentThreadId()));

            if ((_Readers == -1)
                && ((_ThreadId == 0) || (_ThreadId == GetCurrentThreadId()))) {
                _ThreadId = GetCurrentThreadId();
                if (++_WriteCount == 1) {
                    ResetEvent(_hWriteEvent);
                }
                break;
            }

            DEBUG_PRINT(RESLOCK,
                        INFO,
                        ("trying again\n")
                        );

            _CritSect.Unlock();
        } while ( 1 );
    } else {
        if (_CritSect.Lock()) {
            if (++_Readers == 0) {

                DEBUG_PRINT(RESLOCK,
                            INFO,
                            ("Resetting WriteEvent\n")
                            );

                ResetEvent(_hWriteEvent);
            }
            _CritSect.Unlock();
        }
        else {
            DEBUG_PRINT(RESLOCK,
                        ERROR,
                        ("Failed to obtain critsec lock after waiting on WriteEvent\n")
                        );
            fReturn = FALSE;
        }
    }

quit:
    DEBUG_LEAVE(fReturn);

    return fReturn;
}

VOID
RESOURCE_LOCK::Release(
    VOID
    )
{
    DEBUG_ENTER((DBG_RESLOCK,
                None,
                "RESOURCE_LOCK::Release",
                NULL
                ));

    if (IsInitialized()) {
        if (_ThreadId == GetCurrentThreadId()) {

            DEBUG_PRINT(RESLOCK,
                        INFO,
                        ("Clearing writer\n")
                        );

            if (--_WriteCount == 0) {
                _ThreadId = 0;
                SetEvent(_hWriteEvent);
            }
            _CritSect.Unlock();
        } else {
            if (_CritSect.Lock()) {
                if (--_Readers == -1) {

                    DEBUG_PRINT(RESLOCK,
                                INFO,
                                ("Setting WriteEvent\n")
                                );

                    SetEvent(_hWriteEvent);
                }
                _CritSect.Unlock();
            }
            else {
                DEBUG_PRINT(RESLOCK,
                            INFO,
                            ("Couldn't set WriteEvent due to not enough memory\n")
                            );
            }
        }
    }

    DEBUG_LEAVE(0);
}

#endif // OLD_VERSION
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\common\rescache.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    rescache.cxx

Abstract:

    Contains functions which manipulate hostent cache for winsock gethostbyObject
    calls

    Contents:
        QueryHostentCache
        CacheHostent
        FlushHostentCache
        ReleaseHostentCacheEntry
        ThrowOutHostentCacheEntry
        (RemoveCacheEntry)
        (ResolverCacheHit)
        (HostentMatch)
        (CreateCacheEntry)
        (CompareHostentNames)
        (BytesInHostent)
        (CopyHostentToBuffer)

Author:

    Richard L Firth (rfirth) 10-Jul-1994

Environment:

    Win-16/32 user level

Revision History:

    rfirth 10-Jul-1994
        Created

--*/

//
// includes
//

#include "wininetp.h"

//
// private manifests
//

//
// private macros
//

#define SET_EXPIRATION_TIME(cacheEntry)

//
// private data
//

PRIVATE BOOL HostentCacheInitialized = FALSE;

//
// DnsCachingEnabled - caching is enabled by default
//

PRIVATE BOOL DnsCachingEnabled = TRUE;

//
// DnsCacheTimeout - number of seconds before a cache entry expires. This value
// is added to the current time (in seconds) to get the expiry time
//

PRIVATE DWORD DnsCacheTimeout = DEFAULT_DNS_CACHE_TIMEOUT;

//
// MaximumDnsCacheEntries - the maximum number of RESOLVER_CACHE_ENTRYs in the
// cache before we start throwing out the LRU
//

PRIVATE LONG MaximumDnsCacheEntries = DEFAULT_DNS_CACHE_ENTRIES;

//
// ResolverCache - serialized list of RESOLVER_CACHE_ENTRYs, kept in MRU order.
// We only need to remove the tail of the list to remove the LRU entry
//

//
// private prototypes
//

PRIVATE
VOID
RemoveCacheEntry(
    IN SERIALIZED_LIST* pResolverCache,
    IN LPRESOLVER_CACHE_ENTRY lpCacheEntry
    );

PRIVATE
BOOL
ResolverCacheHit(
    IN LPRESOLVER_CACHE_ENTRY lpCacheEntry,
    IN LPSTR Name OPTIONAL,
    IN LPBYTE Address OPTIONAL
    );

PRIVATE
BOOL
HostentMatch(
    IN LPHOSTENT Hostent,
    IN LPSTR Name OPTIONAL,
    IN LPBYTE Address OPTIONAL
    );

PRIVATE
LPRESOLVER_CACHE_ENTRY
CreateCacheEntry(
    IN LPSTR lpszHostName,
    IN LPHOSTENT Hostent,
    IN DWORD TimeToLive,
    IN VOID** pAlloc=NULL,
    IN DWORD dwAllocSize=0
    );

PRIVATE
BOOL
CompareHostentNames(
    IN LPHOSTENT Hostent,
    IN LPSTR Name
    );

PRIVATE
DWORD
BytesInHostent(
    IN LPHOSTENT Hostent
    );

PRIVATE
DWORD
CopyHostentToBuffer(
    OUT PCHAR Buffer,
    IN UINT BufferLength,
    IN PHOSTENT Hostent
    );

#if INET_DEBUG

PRIVATE
DEBUG_FUNCTION
LPSTR
CacheTimestr(
    IN DWORD Time
    );

PRIVATE
DEBUG_FUNCTION
LPSTR
CacheHostentStr(
    IN LPHOSTENT Hostent
    );

PRIVATE
DEBUG_FUNCTION
LPSTR
CacheMapIpAddress(
    IN LPBYTE Address
    );

#endif

//
// functions
//


BOOL
QueryHostentCache(
    SERIALIZED_LIST* pResolverCache,
    IN LPSTR Name OPTIONAL,
    IN LPBYTE Address OPTIONAL,
    OUT LPHOSTENT * Hostent,
    OUT LPDWORD TimeToLive
    )

/*++

Routine Description:

    Checks if Name is stored in the last resolved name cache. If the entry is
    found, but has expired then it is removed from the cache

Arguments:

    Name        - pointer to name string

    Address     - pointer to IP address

    Hostent     - pointer to returned pointer to hostent

    TimeToLive  - pointer to returned time to live

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Bool,
                 "QueryHostentCache",
                 "%q, %s, %#x, %#x",
                 Name,
                 CacheMapIpAddress(Address),
                 Hostent,
                 TimeToLive
                 ));

    BOOL found;

    if (!DnsCachingEnabled || !LockSerializedList(pResolverCache))
    {
        DEBUG_PRINT(SOCKETS,
                    WARNING,
                    ("DNS caching disabled or unable to serialize access\n"
                    ));

        *Hostent = NULL;
        found = FALSE;
        goto quit;
    }

    LPRESOLVER_CACHE_ENTRY cacheEntry;
    LPRESOLVER_CACHE_ENTRY previousEntry;
    DWORD timeNow;

    cacheEntry = (LPRESOLVER_CACHE_ENTRY)HeadOfSerializedList(pResolverCache);
    timeNow = (DWORD)time(NULL);

    while (cacheEntry != (LPRESOLVER_CACHE_ENTRY)SlSelf(pResolverCache)) {

        //
        // on every cache lookup, purge any stale entries. LIVE_FOREVER means
        // that we don't expect the entry's net address to expire, but it
        // DOESN'T mean that we can't throw out the entry if its the LRU and
        // we're at maximum cache capacity. We can't do this if the item is
        // still in-use. In this case, we mark it stale
        //

        if ((cacheEntry->ExpirationTime != LIVE_FOREVER)
        && (cacheEntry->ExpirationTime <= timeNow)) {

            //
            // if reference count not zero then another thread is using
            // this entry - mark as stale else delete it
            //

            if (cacheEntry->ReferenceCount != 0) {

                INET_ASSERT(cacheEntry->State == ENTRY_IN_USE);

                cacheEntry->State = ENTRY_DELETE;
            } else {

                //
                // this entry is stale; throw it out
                // "my hovercraft is full of eels"
                //

                DEBUG_PRINT(SOCKETS,
                            INFO,
                            ("throwing out stale DNS entry %q, expiry = %s\n",
                            cacheEntry->Hostent.h_name,
                            CacheTimestr(cacheEntry->ExpirationTime)
                            ));

                //
                // BUGBUG - what happens if ExpirationTime == timeNow?
                //

                previousEntry = (LPRESOLVER_CACHE_ENTRY)cacheEntry->ListEntry.Blink;
                RemoveCacheEntry(pResolverCache, cacheEntry);
                cacheEntry = previousEntry;
            }
        } else if (ResolverCacheHit(cacheEntry, Name, Address)
        && ((cacheEntry->State == ENTRY_UNUSED)
        || (cacheEntry->State == ENTRY_IN_USE))) {

            //
            // we found the entry, and it still has time to live. Make it the
            // head of the list (MRU first), set the state to in-use and increase
            // the reference count
            //

            if (RemoveFromSerializedList(pResolverCache, &cacheEntry->ListEntry))
            {
                if (InsertAtHeadOfSerializedList(pResolverCache, &cacheEntry->ListEntry))
                {
                    cacheEntry->State = ENTRY_IN_USE;
                    ++cacheEntry->ReferenceCount;
                    *Hostent = &cacheEntry->Hostent;
                    found = TRUE;


                    DEBUG_PRINT(SOCKETS,
                                INFO,
                                ("entry found in DNS cache\n"
                                ));
                }
                else
                {
                    DEBUG_PRINT(SOCKETS,
                                INFO,
                                ("entry found in DNS cache, but removed due to not enough memory\n"
                                ));
                }
            }

            goto done;
        }
        cacheEntry = (LPRESOLVER_CACHE_ENTRY)cacheEntry->ListEntry.Flink;
    }

    *Hostent = NULL;
    found = FALSE;

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("didn't find entry in DNS cache\n"
                ));

done:

    UnlockSerializedList(pResolverCache);

quit:

    DEBUG_LEAVE(found);

    return found;
}


VOID
CacheHostent(
    SERIALIZED_LIST* pResolverCache,
    IN LPSTR lpszHostName,
    IN LPHOSTENT Hostent,
    IN DWORD TimeToLive,
    IN VOID** pAlloc,
    IN DWORD dwAllocSize
    )

/*++

Routine Description:

    Adds a hostent structure to the cache. Creates a new structure and links it
    into the cache list, displacing the LRU entry if required. If we cannot
    create the entry, no action is taken, no errors returned

Arguments:

    lpszHostName    - the name we originally requested be resolved. May be
                      different than the names returned by the resolver, e.g.
                      "proxy" => "proxy1.microsoft.com, proxy2.microsoft.com"

    Hostent         - pointer to hostent to add to cache

    TimeToLive      - amount of time this information has to live. Can be:

                        LIVE_FOREVER    - don't timeout (but can be discarded)

                        LIVE_DEFAULT    - use the default value

                        anything else   - number of seconds to live

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 None,
                 "CacheHostent",
                 "%q, %#x, %d",
                 lpszHostName,
                 Hostent,
                 TimeToLive
                 ));

    if (!DnsCachingEnabled || !LockSerializedList(pResolverCache))
    {
        DEBUG_PRINT(SOCKETS,
                    WARNING,
                    ("DNS caching disabled or unable to serialize access\n"
                    ));

        goto quit;
    }

    //
    // check that the entry is not already in the cache - 2 or more threads may
    // have been simultaneously resolving the same name
    //

    LPHOSTENT lpHostent;
    DWORD ttl;

    INET_ASSERT(lpszHostName != NULL);

    if (!QueryHostentCache(pResolverCache, lpszHostName, NULL, &lpHostent, &ttl)) {

        LPRESOLVER_CACHE_ENTRY cacheEntry;

        //
        // remove as many entries as we can beginning at the tail of the list.
        // We try to remove enough to get the cache size back below the limit.
        // This may consist of removing expired entries or entries marked as
        // DELETE. If there are expired, in-use entries then we mark them as
        // DELETE. This may result in the cache list growing until those threads
        // which have referenced cache entries release them
        //

        cacheEntry = (LPRESOLVER_CACHE_ENTRY)TailOfSerializedList(pResolverCache);

        while ((pResolverCache->ElementCount >= MaximumDnsCacheEntries)
        && (cacheEntry != (LPRESOLVER_CACHE_ENTRY)SlSelf(pResolverCache))) {

            //
            // cache has maximum entries: throw out the Least Recently Used (its
            // the one at the back of the queue, ma'am) but only if no-one else
            // is currently accessing it
            //

            if ((cacheEntry->State != ENTRY_IN_USE)
            && (cacheEntry->ReferenceCount == 0)) {

                INET_ASSERT((cacheEntry->State == ENTRY_UNUSED)
                            || (cacheEntry->State == ENTRY_DELETE));

                DEBUG_PRINT(SOCKETS,
                            INFO,
                            ("throwing out LRU %q\n",
                            cacheEntry->Hostent.h_name
                            ));

                LPRESOLVER_CACHE_ENTRY nextEntry;

                nextEntry = (LPRESOLVER_CACHE_ENTRY)cacheEntry->ListEntry.Flink;
                RemoveCacheEntry(pResolverCache, cacheEntry);
                cacheEntry = nextEntry;
            } else if (cacheEntry->State == ENTRY_IN_USE) {

                //
                // this entry needs to be freed when it is released
                //

                cacheEntry->State = ENTRY_DELETE;
            }
            cacheEntry = (LPRESOLVER_CACHE_ENTRY)cacheEntry->ListEntry.Blink;
        }

        //
        // add the entry at the head of the queue - it is the Most Recently Used
        // after all. If we fail to allocate memory, its no problem: it'll just
        // take a little longer if this entry would have been hit before we needed
        // to throw out another entry
        //

        if (cacheEntry = CreateCacheEntry(lpszHostName, Hostent, TimeToLive, pAlloc, dwAllocSize)) {

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("caching %q, expiry = %s\n",
                        CacheHostentStr(&cacheEntry->Hostent),
                        CacheTimestr(cacheEntry->ExpirationTime)
                        ));

            if (!InsertAtHeadOfSerializedList(pResolverCache, &cacheEntry->ListEntry))
            {
                DEBUG_PRINT(SOCKETS,
                            INFO,
                            ("Unable to cache new entry due to not enough memory\n"
                            ));
            }
        }
    } else {

        //
        // this entry is already in the cache. 2 or more threads must have been
        // resolving the same name simultaneously. We just bump the expiration
        // time to the more recent value
        //

        DEBUG_PRINT(SOCKETS,
                    WARNING,
                    ("found %q already in the cache!?\n",
                    Hostent->h_name
                    ));

        ReleaseHostentCacheEntry(pResolverCache, lpHostent);

    }

    UnlockSerializedList(pResolverCache);

quit:

    DEBUG_LEAVE(0);
}


VOID
FlushHostentCache(
    SERIALIZED_LIST* pResolverCache
    )

/*++

Routine Description:

    Removes all entries in DNS hostent cache

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 None,
                 "FlushHostentCache",
                 NULL
                 ));

    LPRESOLVER_CACHE_ENTRY cacheEntry;
    LPRESOLVER_CACHE_ENTRY previousEntry;

    if (LockSerializedList(pResolverCache))
    {
        previousEntry = (LPRESOLVER_CACHE_ENTRY)SlSelf(pResolverCache);
        cacheEntry = (LPRESOLVER_CACHE_ENTRY)HeadOfSerializedList(pResolverCache);
        while (cacheEntry != (LPRESOLVER_CACHE_ENTRY)SlSelf(pResolverCache)) {
            if (cacheEntry->State == ENTRY_UNUSED) {
                RemoveCacheEntry(pResolverCache, cacheEntry);
            } else {

                DEBUG_PRINT(SOCKETS,
                            WARNING,
                            ("cache entry %#x (%q) still in-use\n",
                            cacheEntry->HostName
                            ));

                cacheEntry->State = ENTRY_DELETE;
                previousEntry = cacheEntry;
            }
            cacheEntry = (LPRESOLVER_CACHE_ENTRY)previousEntry->ListEntry.Flink;
        }

        UnlockSerializedList(pResolverCache);
    }

    DEBUG_LEAVE(0);
}


VOID
ReleaseHostentCacheEntry(
    SERIALIZED_LIST* pResolverCache,
    IN LPHOSTENT lpHostent
    )

/*++

Routine Description:

    Either mark a hostent unused or if it is stale, delete it

Arguments:

    lpHostent   - pointer to hostent to free

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 None,
                 "ReleaseHostentCacheEntry",
                 "%#x",
                 lpHostent
                 ));

    LPRESOLVER_CACHE_ENTRY cacheEntry = CONTAINING_RECORD(lpHostent,
                                                          RESOLVER_CACHE_ENTRY,
                                                          Hostent
                                                          );

    if (LockSerializedList(pResolverCache))
    {

        //
        // reference count should never go below zero!
        //

        INET_ASSERT(cacheEntry->ReferenceCount > 0);

        if (--cacheEntry->ReferenceCount <= 0) {

            //
            // last releaser gets to decide what to do - mark unused or delete
            //

            if (cacheEntry->State == ENTRY_IN_USE) {
                cacheEntry->State = ENTRY_UNUSED;
            } else if (cacheEntry->State == ENTRY_DELETE) {

                //
                // entry is already stale - throw it out
                //

                RemoveCacheEntry(pResolverCache, cacheEntry);
            } else {

                //
                // unused? or bogus value? Someone changed state while refcount
                // not zero?
                //

                INET_ASSERT((cacheEntry->State == ENTRY_IN_USE)
                            || (cacheEntry->State == ENTRY_DELETE));

            }
        }

        UnlockSerializedList(pResolverCache);
    }

    DEBUG_LEAVE(0);
}


VOID
ThrowOutHostentCacheEntry(
    SERIALIZED_LIST* pResolverCache,
    IN LPHOSTENT lpHostent
    )

/*++

Routine Description:

    Removes this entry from the DNS cache, based on the host name. We assume
    that the entry came from the cache, so unless it has been already purged,
    we should be able to throw it out

Arguments:

    lpHostent   - pointer to host entry containing details (name) of entry to
                  throw out

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 None,
                 "ThrowOutHostentCacheEntry",
                 "%#x [%q]",
                 lpHostent,
                 lpHostent->h_name
                 ));

    if (DnsCachingEnabled && LockSerializedList(pResolverCache)) {

        LPRESOLVER_CACHE_ENTRY cacheEntry;

        cacheEntry = (LPRESOLVER_CACHE_ENTRY)HeadOfSerializedList(pResolverCache);
        while (cacheEntry != (LPRESOLVER_CACHE_ENTRY)SlSelf(pResolverCache)) {
            if (HostentMatch(&cacheEntry->Hostent, lpHostent->h_name, NULL)) {

                //
                // if the entry is unused then we can delete it, else we have
                // to leave it to the thread with the last reference
                //

                if (cacheEntry->State == ENTRY_UNUSED) {
                    RemoveCacheEntry(pResolverCache, cacheEntry);
                } else {
                    cacheEntry->State = ENTRY_DELETE;
                }
                break;
            }
        }

        UnlockSerializedList(pResolverCache);
    } else {

        DEBUG_PRINT(SOCKETS,
                    WARNING,
                    ("DNS caching disabled or unable to serialize access\n"
                    ));

    }

    DEBUG_LEAVE(0);
}


PRIVATE
VOID
RemoveCacheEntry(
    SERIALIZED_LIST* pResolverCache,
    IN LPRESOLVER_CACHE_ENTRY lpCacheEntry
    )

/*++

Routine Description:

    Takes a cache entry off the list and frees it

    N.B.: This function must be called with the resolver cache serialized list
    already locked

Arguments:

    lpCacheEntry    - currently queued entry to remove

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 None,
                 "RemoveCacheEntry",
                 "%#x",
                 lpCacheEntry
                 ));

    if (RemoveFromSerializedList(pResolverCache, &lpCacheEntry->ListEntry))
    {

        INET_ASSERT(lpCacheEntry->ReferenceCount == 0);
        INET_ASSERT((lpCacheEntry->State == ENTRY_UNUSED)
                    || (lpCacheEntry->State == ENTRY_DELETE));

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("throwing out %q, expiry = %s\n",
                    CacheHostentStr(&lpCacheEntry->Hostent),
                    CacheTimestr(lpCacheEntry->ExpirationTime)
                    ));

        lpCacheEntry = (LPRESOLVER_CACHE_ENTRY)FREE_MEMORY((HLOCAL)lpCacheEntry);

        INET_ASSERT(lpCacheEntry == NULL);

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("CurrentDnsCacheEntries = %d\n",
                    pResolverCache->ElementCount
                    ));

        INET_ASSERT((pResolverCache->ElementCount >= 0)
                    && (pResolverCache->ElementCount <= MaximumDnsCacheEntries));
    }
    else
    {
        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("unable to throw out %q due to insufficient resources, expiry = %s\n",
                    CacheHostentStr(&lpCacheEntry->Hostent),
                    CacheTimestr(lpCacheEntry->ExpirationTime)
                    ));
    }

    DEBUG_LEAVE(0);
}


PRIVATE
BOOL
ResolverCacheHit(
    IN LPRESOLVER_CACHE_ENTRY lpCacheEntry,
    IN LPSTR Name OPTIONAL,
    IN LPBYTE Address OPTIONAL
    )

/*++

Routine Description:

    Checks this RESOLVER_CACHE_ENTRY for a match with Name or Address. If Name,
    can match with name or alias(es) in hostent, or with originally resolved
    name

Arguments:

    lpCacheEntry    - pointer to RESOLVER_CACHE_ENTRY to check

    Name            - optional name to check

    Address         - optional server address to check

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Bool,
                 "ResolverCacheHit",
                 "%#x, %q, %s",
                 lpCacheEntry,
                 Name,
                 CacheMapIpAddress(Address)
                 ));

    BOOL found;

    if ((Name != NULL)
    && (lpCacheEntry->HostName != NULL)
    && (lstrcmpi(lpCacheEntry->HostName, Name) == 0)) {

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("matched name %q\n",
                    lpCacheEntry->HostName
                    ));

        found = TRUE;
    } else {
        found = FALSE;
    }
    if (!found) {
        found = HostentMatch(&lpCacheEntry->Hostent, Name, Address);
    }

    DEBUG_LEAVE(found);

    return found;
}


PRIVATE
BOOL
HostentMatch(
    IN LPHOSTENT Hostent,
    IN LPSTR Name OPTIONAL,
    IN LPBYTE Address OPTIONAL
    )

/*++

Routine Description:

    Compares a hostent structure for a match with a host name or address

Arguments:

    Hostent - pointer to hostent to compare

    Name    - pointer to name string

    Address - pointer to IP address in network byte order

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Bool,
                 "HostentMatch",
                 "%#x, %q, %s",
                 Hostent,
                 Name,
                 CacheMapIpAddress(Address)
                 ));

    BOOL found;

    if (Name) {
        found = CompareHostentNames(Hostent, Name);
    } else {

        LPBYTE* addressList = (LPBYTE*)Hostent->h_addr_list;
        LPBYTE address;

        found = FALSE;

        while (address = *addressList++) {
            if (*(LPDWORD)address == *(LPDWORD)Address) {

                DEBUG_PRINT(SOCKETS,
                            INFO,
                            ("matched %s\n",
                            CacheMapIpAddress(address)
                            ));

                found = TRUE;
                break;
            }
        }
    }

    if (found) {

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("hostent = %q\n",
                    CacheHostentStr(Hostent)
                    ));

    }

    DEBUG_LEAVE(found);

    return found;
}


PRIVATE
LPRESOLVER_CACHE_ENTRY
CreateCacheEntry(
    IN LPSTR lpszHostName,
    IN LPHOSTENT Hostent,
    IN DWORD TimeToLive,
    IN VOID** pAlloc,
    IN DWORD dwAllocSize
    )

/*++

Routine Description:

    Allocates a RESOLVER_CACHE_ENTRY and packs it with the hostent information
    and sets the ExpirationTime

Arguments:

    lpszHostName    - name we resolved

    Hostent         - pointer to hostent to add

    TimeToLive      - amount of time before this hostent expires

Return Value:

    LPRESOLVER_CACHE_ENTRY

--*/

{
    LPRESOLVER_CACHE_ENTRY cacheEntry;
    UINT hostentSize;

    //
    // BytesInHostent gives us the size of the fixed and variable parts of the
    // hostent structure
    //

    hostentSize = (UINT)BytesInHostent(Hostent);

    INET_ASSERT(lpszHostName != NULL);

    //
    // only copy lpszHostName if it is different to the names in the hostent
    //

    UINT hostNameSize;

    if (!CompareHostentNames(Hostent, lpszHostName)) {
        hostNameSize = lstrlen(lpszHostName) + 1;
    } else {
        hostNameSize = 0;
    }

    //
    // allocate space for the cache entry (take off the size of the fixed part
    // of the hostent - BytesInHostent already accounted for it)
    //

    DWORD dwSize = sizeof(RESOLVER_CACHE_ENTRY)
                 - sizeof(HOSTENT)
                 + hostentSize
                 + hostNameSize;

    if (dwSize <= dwAllocSize)
    {
        cacheEntry = (LPRESOLVER_CACHE_ENTRY)(*pAlloc);
        *pAlloc = NULL;
    }
    else
    {
        cacheEntry = (LPRESOLVER_CACHE_ENTRY)ALLOCATE_MEMORY(LMEM_FIXED,
                                                             dwSize
                                                             );
    }
    
    if (cacheEntry != NULL) {
        CopyHostentToBuffer((PCHAR)&cacheEntry->Hostent, hostentSize, Hostent);

        //
        // copy the host name to the end of the buffer if required
        //

        if (hostNameSize != 0) {
            cacheEntry->HostName = (LPSTR)&cacheEntry->Hostent + hostentSize;
            RtlCopyMemory(cacheEntry->HostName, lpszHostName, hostNameSize);
        } else {
            cacheEntry->HostName = NULL;
        }

        //
        // calculate the expiration time as the current time (in seconds since
        // 1/1/70) + number of seconds to live OR indefinite if TimeToLive is
        // specified as LIVE_FOREVER, which is what we use if the host
        // information didn't originate from DNS
        //

        cacheEntry->ExpirationTime = (DWORD)((TimeToLive == LIVE_FOREVER)
                                        ? LIVE_FOREVER
                                        : time(NULL)
                                            + ((TimeToLive == LIVE_DEFAULT)
                                                ? DnsCacheTimeout
                                                : TimeToLive));

        //
        // the entry state is initially unused
        //

        cacheEntry->State = ENTRY_UNUSED;

        //
        // and reference is zero
        //

        cacheEntry->ReferenceCount = 0;
    }

    return cacheEntry;
}


PRIVATE
BOOL
CompareHostentNames(
    IN LPHOSTENT Hostent,
    IN LPSTR Name
    )

/*++

Routine Description:

    Compares a prospective host name against all names in a hostent

Arguments:

    Hostent - pointer to hostent containing names to compare

    Name    - prospective host name

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Bool,
                 "CompareHostentNames",
                 "%#x, %q",
                 Hostent,
                 Name
                 ));

    BOOL found;

    if (!lstrcmpi(Hostent->h_name, Name)) {

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("matched name %q\n",
                    Hostent->h_name
                    ));

        found = TRUE;
        goto done;
    }

    LPSTR alias;
    LPSTR* aliasList;

    aliasList = Hostent->h_aliases;
    while (alias = *aliasList++) {
        if (!lstrcmpi(alias, Name)) {

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("matched alias %q\n",
                        alias
                        ));

            found = TRUE;
            goto done;
        }
    }

    DEBUG_PRINT(SOCKETS,
                WARNING,
                ("%q not matched\n",
                Name
                ));

    found = FALSE;

done:

    DEBUG_LEAVE(found);

    return found;
}


PRIVATE
DWORD
BytesInHostent(
    IN LPHOSTENT Hostent
    )
{
    DWORD total;
    int i;

    total = sizeof(HOSTENT);
    total += lstrlen(Hostent->h_name) + 1;

    //
    // Account for the NULL terminator pointers at the end of the
    // alias and address arrays.
    //

    total += sizeof(char *) + sizeof(char *);

    for (i = 0; Hostent->h_aliases[i] != NULL; i++) {
        total += lstrlen(Hostent->h_aliases[i]) + 1 + sizeof(char *);
    }

    for (i = 0; Hostent->h_addr_list[i] != NULL; i++) {
        total += Hostent->h_length + sizeof(char *);
    }

    //
    // Pad the answer to an eight-byte boundary.
    //

    return (total + 7) & ~7;
}


PRIVATE
DWORD
CopyHostentToBuffer (
    OUT PCHAR Buffer,
    IN UINT BufferLength,
    IN LPHOSTENT Hostent
    )
{
    UINT requiredBufferLength;
    UINT bytesFilled;
    PCHAR currentLocation = Buffer;
    UINT aliasCount;
    UINT addressCount;
    UINT i;
    PHOSTENT outputHostent = (PHOSTENT)Buffer;

    //
    // Determine how many bytes are needed to fully copy the structure.
    //

    requiredBufferLength = (UINT)BytesInHostent(Hostent);

    //
    // Zero the user buffer.
    //

    if ( (DWORD)BufferLength > requiredBufferLength ) {
        RtlZeroMemory( Buffer, requiredBufferLength );
    } else {
        RtlZeroMemory( Buffer, BufferLength );
    }

    //
    // Copy over the hostent structure if it fits.
    //

    bytesFilled = sizeof(*Hostent);

    if ( bytesFilled > (DWORD)BufferLength ) {
        return requiredBufferLength;
    }

    RtlCopyMemory( currentLocation, Hostent, sizeof(*Hostent) );
    currentLocation = Buffer + bytesFilled;

    outputHostent->h_name = NULL;
    outputHostent->h_aliases = NULL;
    outputHostent->h_addr_list = NULL;

    //
    // Count the host's aliases and set up an array to hold pointers to
    // them.
    //

    for ( aliasCount = 0;
          Hostent->h_aliases[aliasCount] != NULL;
          aliasCount++ );

    bytesFilled += (aliasCount+1) * sizeof(char FAR *);

    if ( bytesFilled > (DWORD)BufferLength ) {
        Hostent->h_aliases = NULL;
        return requiredBufferLength;
    }

    outputHostent->h_aliases = (char FAR * FAR *)currentLocation;
    currentLocation = Buffer + bytesFilled;

    //
    // Count the host's addresses and set up an array to hold pointers to
    // them.
    //

    for ( addressCount = 0;
          Hostent->h_addr_list[addressCount] != NULL;
          addressCount++ );

    bytesFilled += (addressCount+1) * sizeof(void FAR *);

    if ( bytesFilled > (DWORD)BufferLength ) {
        Hostent->h_addr_list = NULL;
        return requiredBufferLength;
    }

    outputHostent->h_addr_list = (char FAR * FAR *)currentLocation;
    currentLocation = Buffer + bytesFilled;

    //
    // Start filling in addresses.  Do addresses before filling in the
    // host name and aliases in order to avoid alignment problems.
    //

    for ( i = 0; i < addressCount; i++ ) {

        bytesFilled += Hostent->h_length;

        if ( bytesFilled > (DWORD)BufferLength ) {
            outputHostent->h_addr_list[i] = NULL;
            return requiredBufferLength;
        }

        outputHostent->h_addr_list[i] = currentLocation;

        RtlCopyMemory(
            currentLocation,
            Hostent->h_addr_list[i],
            Hostent->h_length
            );

        currentLocation = Buffer + bytesFilled;
    }

    outputHostent->h_addr_list[i] = NULL;

    //
    // Copy the host name if it fits.
    //

    bytesFilled += lstrlen(Hostent->h_name) + 1;

    if ( bytesFilled > (DWORD)BufferLength ) {
        return requiredBufferLength;
    }

    outputHostent->h_name = currentLocation;

    RtlCopyMemory(currentLocation, Hostent->h_name, lstrlen(Hostent->h_name) + 1);
    currentLocation = Buffer + bytesFilled;

    //
    // Start filling in aliases.
    //

    for ( i = 0; i < aliasCount; i++ ) {

        bytesFilled += lstrlen(Hostent->h_aliases[i]) + 1;

        if ( bytesFilled > (DWORD)BufferLength ) {
            outputHostent->h_aliases[i] = NULL;
            return requiredBufferLength;
        }

        outputHostent->h_aliases[i] = currentLocation;

        RtlCopyMemory(
            currentLocation,
            Hostent->h_aliases[i],
            lstrlen(Hostent->h_aliases[i]) + 1
            );

        currentLocation = Buffer + bytesFilled;
    }

    outputHostent->h_aliases[i] = NULL;

    return requiredBufferLength;
}

#if INET_DEBUG

//
// CAVEAT - can only call these functions once per printf() etc. because of
//          static buffers (but still thread-safe)
//

PRIVATE
DEBUG_FUNCTION
LPSTR
CacheTimestr(IN DWORD Time) {

    //
    // previous code - writes formatted human-sensible date/time to buffer
    //

    //LPSTR p;
    //
    ////
    //// remove the LF from the time string returned by ctime()
    ////
    //
    //p = ctime((const time_t *)&Time);
    //p[strlen(p) - 1] = '\0';
    //return p;

    //
    // abbreviated CRT version - just write # seconds since 1970 to buffer
    //

    static char buf[16];

    wsprintf(buf, "%d", Time);
    return (LPSTR)buf;
}

PRIVATE
DEBUG_FUNCTION
LPSTR
CacheHostentStr(IN LPHOSTENT Hostent) {

    static char buf[1024];
    LPSTR p;

    p = buf;
    p += wsprintf(p, "n=%s", Hostent->h_name);

    for (LPSTR * aliases = (LPSTR *)Hostent->h_aliases; *aliases; ++aliases) {
        p += wsprintf(p, ", a=%s", *aliases);
    }

    for (LPBYTE * addrs = (LPBYTE *)Hostent->h_addr_list; *addrs; ++addrs) {
        p += wsprintf(p,
                      ", i=%s",
                      CacheMapIpAddress(*addrs)
                      );
    }

    return (LPSTR)buf;
}

PRIVATE
DEBUG_FUNCTION
LPSTR
CacheMapIpAddress(IN LPBYTE Address) {

    if (!Address) {
        return "";
    }

    static char buf[16];

    wsprintf(buf,
             "%d.%d.%d.%d",
             Address[0] & 0xff,
             Address[1] & 0xff,
             Address[2] & 0xff,
             Address[3] & 0xff
             );

    return (LPSTR)buf;
}

#endif

#if defined(RNR_SUPPORTED)

/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    rescache.c

Abstract:

    Contains name resolution cache

    Contents:

Author:

    Shishir Pardikar    2-14-96

Environment:

    Win32 user mode

Revision History:

        2-14-96 shishirp
        Created

--*/

//
//BUGBUG: This include should be removed, duplicate of above
//
#ifndef SPX_SUPPORT
#include <wininetp.h>
#endif


//
// private manifests
//

#define NAMERES_CACHE_USED            0x00000001
#define NAMERES_CACHE_USES_GUID       0x00000002

#define ENTERCRIT_NAMERESCACHE()  (vcritNameresCache.Lock())
#define LEAVECRIT_NAMERESCACHE()  (vcritNameresCache.Unlock())
#define IS_EMPTY(indx)            ((vlpNameresCache[(indx)].dwFlags & NAMERES_CACHE_USED) == 0)
#define USES_GUID(indx)           ((vlpNameresCache[(indx)].dwFlags & NAMERES_CACHE_USES_GUID))

// number of cache entries
#define DEFAULT_NAMERES_CACHE_ENTRIES   10

// expiry time for an addresslist
#define DEFAULT_EXPIRY_DELTA            (24 * 60 * 60 * (LONGLONG)10000000)


//
//  structure definition
//

typedef struct tagNAMERES_CACHE {
    DWORD               dwFlags;       // general flags to be used as needed
    DWORD               dwNameSpace;   // namespace ??
    GUID                sGuid;         // GUID describing service type
    LPSTR               lpszName;      // ptr to name that needs resolution
    FILETIME            ftLastUsedTime;    // last accesstime, mainly for purging
    FILETIME            ftCreationTime;// When it was created
    ADDRESS_INFO_LIST   sAddrList;     // List of address (defined in ixport.h)
} NAMERES_CACHE, far *LPNAMERES_CACHE;





//
// private variables for name resolution cache
//


// Name cache size allocated in init
LPNAMERES_CACHE vlpNameresCache = NULL;

// Number of elements allowed in the nameres cache
int vcntNameresCacheEntries = DEFAULT_NAMERES_CACHE_ENTRIES;


// time in 100ns after which an address is expired
LONGLONG vftExpiryDelta = DEFAULT_EXPIRY_DELTA;

BOOL vfNameresCacheInited = FALSE;

// serialization
CCritSec vcritNameresCache;

//
// private function prototypes
//


PRIVATE
DWORD
CreateNameresCacheEntry(
    int     indx,
    DWORD   dwNameSpace,
    LPGUID  lpGuid,
    LPSTR   lpszName,
    INT     cntAddresses,
    LPCSADDR_INFO  lpCsaddrInfo
);


PRIVATE
DWORD
DeleteNameresCacheEntry(
    int indx
);


PRIVATE
int
FindNameresCacheEntry(
    DWORD   dwNameSpace,
    LPGUID  lpGuid,
    LPSTR   lpszName
);


PRIVATE
int
FindNameresCacheEntryByAddr(
    int cntAddr,
    LPCSADDR_INFO lpCsaddrInfo
);

PRIVATE
int
PurgeEntries(
    BOOL    fForce  // purge atleast one entry
);


PRIVATE
DWORD
CopyCsaddr(
    LPCSADDR_INFO   lpSrc,
    int             cntAddr,
    LPCSADDR_INFO   *lplpDst
);

//
// functions
//


DWORD
InitNameresCache(
    VOID
)
/*++

Routine Description:

    Init name resolution cache. This routine a) allocates a table of
    name cache entries b)

Arguments:

    None.

Return Value:

    ERROR_SUCCESS if successful.

--*/
{


    if (vfNameresCacheInited)
    {
        return (ERROR_SUCCESS);
    }

    // first try to alloc the memory, if it fails just quit
    vlpNameresCache = (LPNAMERES_CACHE)ALLOCATE_MEMORY(
                        LPTR,
                        vcntNameresCacheEntries * sizeof(NAMERES_CACHE)
                        );

    if (!vlpNameresCache)
    {
        return (ERROR_NOT_ENOUGH_MEMORY);
    }

    if (!vcritNameresCache.Init() || !ENTERCRIT_NAMERESCACHE())
    {
        FREE_MEMORY(vlpNameresCache);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    vfNameresCacheInited = TRUE;

    LEAVECRIT_NAMERESCACHE();

    return (ERROR_SUCCESS);

}


DWORD
AddNameresCacheEntry(
    DWORD    dwNameSpace,
    LPGUID   lpGuid,
    LPSTR    lpName,
    int      cntAddresses,
    LPCSADDR_INFO  lpCsaddrInfo
)
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if successful.

--*/
{
    int indx;
    DWORD dwError = ERROR_SUCCESS;

    if (!vfNameresCacheInited) {
        return (ERROR_INVALID_PARAMETER);
    }

    if (!ENTERCRIT_NAMERESCACHE())
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    indx = FindNameresCacheEntry(dwNameSpace, lpGuid, lpName);

    // if indx is valid, delete the entry, do some purging too
    if (indx != -1) {
        DeleteNameresCacheEntry(indx);
        PurgeEntries(FALSE);
    }
    else {
        // create atleast one hole
        indx = PurgeEntries(TRUE);
    }

    INET_ASSERT((indx >=0 && (indx < vcntNameresCacheEntries)));

    dwError = CreateNameresCacheEntry(indx,
                            dwNameSpace,
                            lpGuid,
                            lpName,
                            cntAddresses,
                            lpCsaddrInfo);

    LEAVECRIT_NAMERESCACHE();

    return (dwError);
}




DWORD
RemoveNameresCacheEntry(
    DWORD    dwNameSpace,
    LPGUID   lpGuid,
    LPSTR    lpszName
)
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if successful.

--*/
{
    int indx;
    DWORD dwError = ERROR_INVALID_PARAMETER;

    if (vfNameresCacheInited) {

        if (!ENTERCRIT_NAMERESCACHE())
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto quit;
        }

        indx = FindNameresCacheEntry(dwNameSpace, lpGuid, lpszName);

        if (indx != -1) {

            DeleteNameresCacheEntry(indx);

            dwError = ERROR_SUCCESS;
        }
        else {
            dwError = ERROR_FILE_NOT_FOUND; //yuk
        }

        LEAVECRIT_NAMERESCACHE();
    }
quit:
    return (dwError);
}


#ifdef MAYBE

DWORD
RemoveNameresCacheEntryByAddr(
    int cntAddresses,
    LPCSADDR_INFO lpCsaddrInfo
)
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if successful.

--*/
{
    int indx;
    DWORD dwError = ERROR_INVALID_PARAMETER;

    if (vfNameresCacheInited) {
        if (!ENTERCRIT_NAMERESCACHE())
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto quit;
        }


        indx = FindNameresCacheEntryByAddr(cntAddresses, lpCsaddrInfo);

        if (indx != -1) {

            DeleteNameresCacheEntry(indx);

            dwError = ERROR_SUCCESS;
        }
        else {
            dwError = ERROR_FILE_NOT_FOUND;
        }

        LEAVECRIT_NAMERESCACHE();
    }
quit:
    return (dwError);

}
#endif //MAYBE

DWORD
GetNameresCacheEntry(
    DWORD    dwNameSpace,
    LPGUID   lpGuid,
    LPSTR    lpName,
    INT      *lpcntAddresses,
    LPCSADDR_INFO  *lplpCsaddrInfo
)
/*++

Routine Description:

    This routine looks up the cache and returns the list of addresses
    corresponding to lpGuid/lpName.

Arguments:


Return Value:

    ERROR_SUCCESS if successful.

--*/
{
    int indx;
    DWORD   dwError = ERROR_FILE_NOT_FOUND; // poor error

    if (!vfNameresCacheInited) {
        return (ERROR_INVALID_PARAMETER);
    }

    if (!ENTERCRIT_NAMERESCACHE())
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    // is this entry already cached?
    indx = FindNameresCacheEntry(dwNameSpace, lpGuid, lpName);


    if (indx != -1) {
        // yes, let use give back the info

        *lpcntAddresses = vlpNameresCache[indx].sAddrList.AddressCount;

        if ((dwError = CopyCsaddr(vlpNameresCache[indx].sAddrList.Addresses, *lpcntAddresses, lplpCsaddrInfo))
            != ERROR_SUCCESS) {

            goto bailout;
        }
        // update the last used time, we will use this to
        // age out the entries

        GetCurrentGmtTime(&(vlpNameresCache[indx].ftLastUsedTime));
        dwError = ERROR_SUCCESS;
    }

bailout:

    LEAVECRIT_NAMERESCACHE();

quit:
    return (dwError);
}


DWORD
DeinitNameresCache(
    VOID
)
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if successful.

--*/
{
    int i;

    if (vfNameresCacheInited) {
        if (!ENTERCRIT_NAMERESCACHE())
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        for (i = 0; i < vcntNameresCacheEntries; ++i) {
            if (!IS_EMPTY(i)) {
                DeleteNameresCacheEntry(i);
            }
        }

        FREE_MEMORY(vlpNameresCache);

        vlpNameresCache = NULL;

        vfNameresCacheInited = FALSE;

        LEAVECRIT_NAMERESCACHE();
        vcritNameresCache.FreeLock();
    }
    return (ERROR_SUCCESS);
}


PRIVATE
DWORD
CreateNameresCacheEntry(
    int     indx,
    DWORD   dwNameSpace,
    LPGUID  lpGuid,
    LPSTR   lpszName,
    int     cntAddresses,
    LPCSADDR_INFO  lpCsaddrInfo
)
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if successful.

--*/
{
    DWORD dwError = ERROR_NOT_ENOUGH_MEMORY;

    INET_ASSERT((indx >=0 && (indx < vcntNameresCacheEntries)));

    INET_ASSERT(IS_EMPTY(indx));


    memset(&vlpNameresCache[indx], 0, sizeof(vlpNameresCache[indx]));

    // we could get a name or a guid
    // do it for name first before doing it for GUID

    // BUGBUG in future we should consider name+GUID+port
    if (lpszName) {
       vlpNameresCache[indx].lpszName = (LPSTR)ALLOCATE_MEMORY(LPTR, lstrlen(lpszName)+1);
       if (!vlpNameresCache[indx].lpszName) {
           goto bailout;
       }
       strcpy(vlpNameresCache[indx].lpszName, lpszName);
    }
    else if (lpGuid) {
        INET_ASSERT(FALSE); // rigth now. In future this should go away
        memcpy(&(vlpNameresCache[indx].sGuid), lpGuid, sizeof(GUID));
        vlpNameresCache[indx].dwFlags |= NAMERES_CACHE_USES_GUID;
    }
    else {
        dwError = ERROR_INVALID_PARAMETER;
        goto bailout;
    }

    INET_ASSERT(cntAddresses > 0);

    if (CopyCsaddr(lpCsaddrInfo, cntAddresses, &(vlpNameresCache[indx].sAddrList.Addresses))
        != ERROR_SUCCESS) {
        goto bailout;
    }

    vlpNameresCache[indx].sAddrList.AddressCount = cntAddresses;

    // mark this as being non-empty
    vlpNameresCache[indx].dwFlags |= NAMERES_CACHE_USED;

    // set the creation and last-used times as now

    GetCurrentGmtTime(&(vlpNameresCache[indx].ftCreationTime));
    vlpNameresCache[indx].ftLastUsedTime = vlpNameresCache[indx].ftCreationTime ;

    dwError = ERROR_SUCCESS;

bailout:

    if (dwError != ERROR_SUCCESS) {
        if (vlpNameresCache[indx].sAddrList.Addresses) {
            FREE_MEMORY(vlpNameresCache[indx].sAddrList.Addresses);
            vlpNameresCache[indx].sAddrList.Addresses = NULL;
        }
        if (vlpNameresCache[indx].lpszName) {
            FREE_MEMORY(vlpNameresCache[indx].lpszName);
            vlpNameresCache[indx].lpszName = NULL;
        }
        memset(&vlpNameresCache[indx], 0, sizeof(vlpNameresCache[indx]));
    }

    return (dwError);
}


PRIVATE
DWORD
DeleteNameresCacheEntry(
    int indx
)
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if successful.

--*/
{
    INET_ASSERT((indx >=0) && (indx < vcntNameresCacheEntries));

    if (vlpNameresCache[indx].lpszName) {
        FREE_MEMORY(vlpNameresCache[indx].lpszName);
    }

    INET_ASSERT(vlpNameresCache[indx].sAddrList.Addresses);

    FREE_MEMORY(vlpNameresCache[indx].sAddrList.Addresses);

    memset(&vlpNameresCache[indx], 0, sizeof(NAMERES_CACHE));

    return (ERROR_SUCCESS);
}

#ifdef MAYBE

PRIVATE
int
FindNameresCacheEntryByAddr(
    int cntAddr,
    LPCSADDR_INFO lpCsaddrInfo
)
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if successful.

--*/
{
    int i;

    for (i = 0; i < vcntNameresCacheEntries; ++i) {
        if (!IS_EMPTY(i) && // not empty
            (vlpNameresCache[i].sAddrList.AddressCount == cntAddr) && // count is the same
            (!memcmp(vlpNameresCache[i].sAddrList.Addresses,    // list matches
                     lpCsaddrInfo,
                     cntAddr * sizeof(CSADDR_INFO)))) {
            return (i);
        }
    }
    return (-1);
}
#endif //MAYBE


PRIVATE
int
FindNameresCacheEntry(
    DWORD   dwNameSpace,
    LPGUID  lpGuid,
    LPSTR   lpszName
)
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if successful.

--*/
{
    int i;

    for (i = 0; i < vcntNameresCacheEntries; ++i) {
        if (!IS_EMPTY(i)) {
            if (vlpNameresCache[i].dwNameSpace == dwNameSpace) {
                if (!USES_GUID(i)) {

                    INET_ASSERT(vlpNameresCache[i].lpszName);

                    if (lpszName &&
                        !lstrcmpi(lpszName, vlpNameresCache[i].lpszName)) {
                        return (i);
                    }
                }
                else{

                    if (lpGuid && !memcmp(lpGuid, &vlpNameresCache[i].sGuid, sizeof(GUID))) {
                        return (i);
                    }
                }
            }
        }
    }
    return (-1);
}


PRIVATE
int
PurgeEntries(
    BOOL    fForce  // purge atleast one entry
)
/*++

Routine Description:


Arguments:


Return Value:

    index of a free entry

--*/
{
    int i, indxlru = -1, indxHole=-1;
    FILETIME ft;
    BOOL fFoundHole = FALSE;

    GetCurrentGmtTime(&ft);

    for (i = 0; i < vcntNameresCacheEntries; ++i) {
        if (!IS_EMPTY(i)) {

            // purge stale entries
            if ( (FT2LL(ft) - FT2LL(vlpNameresCache[i].ftCreationTime))
                    > FT2LL(vftExpiryDelta)) {
                DeleteNameresCacheEntry(i);
                indxHole = i;
            }
            else if (FT2LL(vlpNameresCache[i].ftLastUsedTime) <= FT2LL(ft)) {
                ft = vlpNameresCache[i].ftLastUsedTime;
                indxlru = i; // LRU entry if we need to purge it
            }
        }
        else {
            indxHole = i;
        }
    }

    // if there is no hole, purge the LRU entry if forced
    if (indxHole == -1) {

        INET_ASSERT(indxlru != -1);

        if (fForce) {
            DeleteNameresCacheEntry(indxlru);
            indxHole = indxlru;
        }
    }
    return (indxHole);
}

PRIVATE
DWORD
CopyCsaddr(
    LPCSADDR_INFO   lpSrc,
    int             cntAddr,
    LPCSADDR_INFO   *lplpDst
)
{
    int i;
    LPCSADDR_INFO lpDst;
    UINT uSize;


    // BUGBUG assumes the way Compressaddress (ixport.cxx) allocates memory
    uSize = LocalSize(lpSrc);
    if (!uSize) {
        return (GetLastError());
    }

    *lplpDst = (LPCSADDR_INFO)ALLOCATE_MEMORY(LPTR, uSize);

    if (!*lplpDst) {
        return (ERROR_NOT_ENOUGH_MEMORY);
    }

    lpDst = *lplpDst;


    memcpy(lpDst, lpSrc, uSize);

    // now start doing fixups
    for (i=0; i<cntAddr; ++i) {
        lpDst[i].LocalAddr.lpSockaddr = (LPSOCKADDR)((LPBYTE)lpDst+((DWORD)(lpSrc[i].LocalAddr.lpSockaddr) - (DWORD)lpSrc));
        lpDst[i].RemoteAddr.lpSockaddr = (LPSOCKADDR)((LPBYTE)lpDst+((DWORD)(lpSrc[i].RemoteAddr.lpSockaddr) - (DWORD)lpSrc));
    }
    return (ERROR_SUCCESS);
}

#endif // defined(RNR_SUPPORTED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\common\ssocket.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    ssocket.cxx

Abstract:

    Contains secure sockets functions and ICSecureSocket methods

    Contents:
        SecurityPkgInitialize
        ReadCertificateIntoCertInfoStruct
        ChkCertificateCommonNameIsValid
        ChkCertificateExpired
        ICSecureSocket::ICSecureSocket
        ICSecureSocket::~ICSecureSocket
        ICSecureSocket::Connect
        CFsm_SecureConnect::RunSM
        ICSecureSocket::Connect_Fsm
        ICSecureSocket::SecureHandshakeWithServer
        CFsm_SecureHandshake::RunSM
        ICSecureSocket::SecureHandshake_Fsm
        ICSecureSocket::NegotiateSecConnection
        CFsm_SecureNegotiate::RunSM
        ICSecureSocket::SecureNegotiate_Fsm
        ICSecureSocket::SSPINegotiateLoop
        CFsm_NegotiateLoop::RunSM
        ICSecureSocket::NegotiateLoop_Fsm
        ICSecureSocket::Disconnect
        ICSecureSocket::Send
        CFsm_SecureSend::RunSM
        ICSecureSocket::Send_Fsm
        ICSecureSocket::Receive
        CFsm_SecureReceive::RunSM
        ICSecureSocket::Receive_Fsm
        ICSecureSocket::SetHostName
        (ICSecureSocket::EncryptData)
        (ICSecureSocket::DecryptData)
        (ICSecureSocket::TerminateSecConnection)
        ICSecureSocket::GetCertInfo

Author:

    Richard L Firth (rfirth) 08-Apr-1997

Environment:

    Win32 user mode

Revision History:

    08-Apr-1997 rfirth
        Created from ixport.cxx

--*/

#include <wininetp.h>
#include <perfdiag.hxx>
#include <ierrui.hxx>

extern "C" {

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntsecapi.h>

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <softpub.h>

}

//
//
//  List of encryption packages:  PCT, SSL, etc
//

//
// BUGBUG [arthurbi] The SSL and PCT package names
//  are hard coded into the stucture below.  We need
//  to be more flexible in case someone write a FOO security
//  package.
//

// BUGBUG:  Don't change the order of the packages below.  some old SSL2 sites deny the UNISP
// provider, and if we walk down the list to PCT1 or SSL3, things hang.
struct _SEC_PROVIDER SecProviders[] =
{
    UNISP_NAME, INVALID_CRED_VALUE , ENC_CAPS_PCT | ENC_CAPS_SSL | ENC_CAPS_SCHANNEL_CREDS, FALSE, SP_PROT_CLIENTS, NULL,
    UNISP_NAME, INVALID_CRED_VALUE , ENC_CAPS_SSL | ENC_CAPS_SCHANNEL_CREDS, FALSE, SP_PROT_SSL2_CLIENT, NULL,
//    PCT1SP_NAME, INVALID_CRED_VALUE , ENC_CAPS_PCT| ENC_CAPS_SCHANNEL_CREDS, FALSE, SP_PROT_PCT1_CLIENT, NULL,
//    SSL3SP_NAME, INVALID_CRED_VALUE , ENC_CAPS_SSL| ENC_CAPS_SCHANNEL_CREDS, FALSE, SP_PROT_SSL3_CLIENT, NULL,
    NULL,        INVALID_CRED_VALUE , FALSE,        FALSE, 0
};



//
// dwEncFlags - Global Status of calling and initalizing the SCHANNEL and various
//   other encyrption support DLL & APIs.  Failure in the process will
//   cause this to be set to an error state, success prevents re-initalizaiton
//

DWORD dwEncFlags = 0;

//
// GlobalSecureProtocolsCopy - Copy of the current protocols the user wants to use
//   changing them allows us to restrict to specific protocols
//
DWORD GlobalSecureProtocolsCopy = DEFAULT_SECURE_PROTOCOLS;


#ifdef SECPKG_ATTR_PROTO_INFO
PRIVATE
LPTSTR
ProtoInfoToString(
    IN const PSecPkgContext_ProtoInfo pProtoInfo);
#endif

//
// general security package functions
//
BOOL
SecurityPkgInitialize(
    BOOL fForce
    )
/*++

Routine Description:

    This function finds a list of security packages that are supported
    on the client's machine, check if pct or ssl is supported, and
    create a credential handle for each supported pkg.

Arguments:

    None

Return Value:

    TRUE if at least one security pkg is found; otherwise FALSE

--*/
{
    TimeStamp         tsExpiry;
    SECURITY_STATUS   scRet;
    PSecPkgInfo       pPackageInfo = NULL;
    ULONG             cPackages;
    ULONG             fCapabilities;
    ULONG             i;
    ULONG             j;
    DWORD             cProviders = 0;

    SCHANNEL_CRED DefaultCredData = {SCHANNEL_CRED_VERSION,
                                     0,
                                     NULL,
                                     0,
                                     0,
                                     NULL,
                                     0,
                                     NULL,
                                     SP_PROT_CLIENTS,
                                     0,
                                     0,
                                     0,
                                     SCH_CRED_MANUAL_CRED_VALIDATION |
                                     SCH_CRED_NO_DEFAULT_CREDS
                                    };

    //
    // Set new DWORD for our copy of the global protocol settings.
    //
    bool    fSame = (GlobalSecureProtocolsCopy==GlobalSecureProtocols);
    GlobalSecureProtocolsCopy = GlobalSecureProtocols;

    //
    //  check if this routine has been called.  if yes, return TRUE
    //  if we've found a supported pkg; otherwise FALSE
    //

    if ( dwEncFlags == ENC_CAPS_NOT_INSTALLED )
       return FALSE;
    else if ((dwEncFlags&ENC_CAPS_TYPE_MASK) && fSame && !fForce)
       return TRUE;

    //
    //  Initialize dwEncFlags
    //

    dwEncFlags = ENC_CAPS_NOT_INSTALLED;

    //
    //  Check if at least one security package is supported
    //


    scRet = g_EnumerateSecurityPackages( &cPackages,
                                         &pPackageInfo );

    if ( scRet != STATUS_SUCCESS )
    {
        DEBUG_PRINT(API,
                    ERROR,
                    ("EnumerateSecurityPackages failed, error %lx\n",
                    scRet
                    ));

        SetLastError( scRet );
        return FALSE;
    }

    for ( i = 0; i < cPackages ; i++ )
    {
        //
        //  Use only if the package name is the PCT/SSL package
        //

        fCapabilities = pPackageInfo[i].fCapabilities;

        if ( fCapabilities & SECPKG_FLAG_STREAM )
        {
            //
            //  Check if the package supports server side authentication
            //  and all recv/sent messages are tamper proof
            //

            if ( fCapabilities & SECPKG_FLAG_CLIENT_ONLY ||
                 !(fCapabilities & SECPKG_FLAG_PRIVACY ))
            {
                continue;
            }

            //
            //  Check if the pkg matches one of our known packages
            //

            for ( j = 0; SecProviders[j].pszName != NULL; j++ )
            {
                if ( !stricmp( pPackageInfo[i].Name, SecProviders[j].pszName ) )
                {
                    CredHandle OldCred;
                    PVOID pCredData = NULL;

                    //
                    //  Create a credential handle for each supported pkg
                    //

                    INET_ASSERT((SecProviders[j].dwFlags & ENC_CAPS_SCHANNEL_CREDS));

                    pCredData = &DefaultCredData;

                    if (SecProviders[j].pCertCtxt != NULL) {
                        DefaultCredData.cCreds = 1;
                        DefaultCredData.paCred = &SecProviders[j].pCertCtxt;
                    }

                    //
                    // Enable Supported protocols in the Default Cred Data, then acquire the Credential
                    //

                    DefaultCredData.grbitEnabledProtocols = (GlobalSecureProtocols & SecProviders[j].dwProtocolFlags);

                    OldCred.dwUpper = SecProviders[j].hCreds.dwUpper;
                    OldCred.dwLower = SecProviders[j].hCreds.dwLower;

                    // Zero out previous credentials
                    SecProviders[j].hCreds.dwUpper = SecProviders[j].hCreds.dwLower = 0;

                    WRAP_REVERT_USER(g_AcquireCredentialsHandle,
                                     (NULL,
                                      SecProviders[j].pszName, // Package
                                      SECPKG_CRED_OUTBOUND,
                                      NULL,
                                      pCredData,
                                      NULL,
                                      NULL,
                                      &(SecProviders[j].hCreds), // Handle
                                      &tsExpiry),
                                     scRet);

                    if(!IS_CRED_INVALID(&OldCred))
                    {
                        WRAP_REVERT_USER_VOID(g_FreeCredentialsHandle, (&OldCred));
                    }

                    DefaultCredData.cCreds = 0;
                    DefaultCredData.paCred = NULL;

                    if ( scRet != STATUS_SUCCESS )
                    {
                        DEBUG_PRINT(API,
                                    WARNING,
                                    ("AcquireCredentialHandle failed, error %lx\n",
                                    scRet
                                    ));

                        SecProviders[j].fEnabled = FALSE;

                        SecProviders[j].hCreds.dwUpper = 0xffffffff;
                        SecProviders[j].hCreds.dwLower = 0xffffffff;


                    }
                    else
                    {
                        DEBUG_PRINT(
                             API,
                             INFO,
                             ("AcquireCredentialHandle() supports %s, acquires %x:%x\n",
                             SecProviders[j].pszName,
                             SecProviders[j].hCreds.dwUpper,
                             SecProviders[j].hCreds.dwLower
                             ));

                        SecProviders[j].fEnabled = TRUE;
                        cProviders++;
                        dwEncFlags |= SecProviders[j].dwFlags;
                    }
                }
            }
        }
    }

    if ( !cProviders )
    {
        //
        //  No security packages were found, return FALSE to caller
        //

        DEBUG_PRINT(API,
                    ERROR,
                    ("No security packages were found, error %lx\n",
                    SEC_E_SECPKG_NOT_FOUND
                    ));

        g_FreeContextBuffer( pPackageInfo );

        SetLastError( (DWORD) SEC_E_SECPKG_NOT_FOUND );

        return FALSE;
    }

    //
    //  Successfully found a security package(s)
    //

    return TRUE;
}


DWORD
QuerySecurityInfo(
                  IN CtxtHandle *hContext,
                  OUT LPINTERNET_SECURITY_INFO pInfo,
                  IN LPDWORD lpdwStatusFlag)
{
    SECURITY_STATUS      scRet;

    scRet = g_QueryContextAttributes(hContext,
                                     SECPKG_ATTR_REMOTE_CERT_CONTEXT,
                                     &pInfo->pCertificate );

    if (scRet == ERROR_SUCCESS)
    {
        scRet = g_QueryContextAttributes(hContext,
                                     SECPKG_ATTR_CONNECTION_INFO,
                                     &pInfo->dwProtocol );

        if (scRet == ERROR_SUCCESS)
        {
            pInfo->dwSize = sizeof(INTERNET_SECURITY_INFO);
        }
    }
    
    if (scRet != ERROR_SUCCESS)
    {
        //
        // Map the SSPI error.
        //
        return MapInternetError((DWORD) scRet, lpdwStatusFlag);
    }
    return ERROR_SUCCESS;
}

// Helper function to detect Fortezza connections.
BOOL IsCertificateFortezza(PCCERT_CONTEXT pCertContext)
{
    INET_ASSERT(pCertContext != NULL);
    if (pCertContext == NULL)
        return FALSE;

    LPSTR pszOid = pCertContext->pCertInfo->SubjectPublicKeyInfo.Algorithm.pszObjId;

    if (pszOid)
    {
        if (strcmp(pszOid, szOID_INFOSEC_mosaicUpdatedSig) == 0 ||
             strcmp(pszOid, szOID_INFOSEC_mosaicKMandUpdSig) == 0)
        {
            return TRUE;
        }
    }
    return FALSE;
}


LONG WinVerifySecureChannel(HWND hwnd, WINTRUST_DATA *pWTD)
/*++

Routine Description:

    Wininet's wrapper for secure channel WinVerifyTrust calls.

Arguments:

    hWnd - in case WinVerifyTrust needs to do UI.
    pWTD - pointer to WINTRUST_DATA containing details about the
           secure channel. Passed to WinVerifyTrust.
Return Value:

    WIN32 error code.

--*/
{
    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
    BOOL async;
    LONG  lResult;
    BOOL  bFortezza;
    GUID  gHTTPS = HTTPSPROV_ACTION;

    if (lpThreadInfo != NULL) {
        async = _InternetGetAsync(lpThreadInfo);
        _InternetSetAsync(lpThreadInfo, FALSE);
    }

    bFortezza = IsCertificateFortezza(pWTD->pCert->psCertContext);

    if (bFortezza && g_CryptInstallDefaultContext == NULL)
    {
        // HACK: we have no way to verify a connection without
        // a crypt32 which has the new APIs exposed. Till IE5 picks up
        // the new crypto bits we will assume Fortezza connections
        // verify correctly.
        lResult = ERROR_SUCCESS;
    }
    else
    {
        HCRYPTDEFAULTCONTEXT hCryptDefaultContext = NULL;

        if (bFortezza)
        {
            if (!g_CryptInstallDefaultContext(
                        GlobalFortezzaCryptProv,
                        CRYPT_DEFAULT_CONTEXT_CERT_SIGN_OID,
                        szOID_INFOSEC_mosaicUpdatedSig,         // check with John Banes
                        0,                                      // dwFlags
                        NULL,                                   // pvReserved
                        &hCryptDefaultContext
                        ))
            {
                lResult = GetLastError();
                goto quit;
            }
        }

        WRAP_REVERT_USER(g_WinVerifyTrust, (hwnd, &gHTTPS, pWTD), lResult);

        DEBUG_PUT(("WinVerifyTrust returned: %x\n", lResult));

        if (hCryptDefaultContext)
        {
            // Ignore error code while freeing since we can't do anything
            // meaningful about it here.
            BOOL bResult;
            bResult = g_CryptUninstallDefaultContext(
                        hCryptDefaultContext,
                        0,
                        NULL);
            INET_ASSERT(bResult);
        }
    }

quit:

    if (lpThreadInfo != NULL) {
        _InternetSetAsync(lpThreadInfo, async);
    }
    return lResult;
}


//
// ICSecureSocket methods
//


ICSecureSocket::ICSecureSocket(void)

/*++

Routine Description:

    ICSecureSocket constructor

Arguments:


Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "ICSecureSocket::ICSecureSocket",
                 "{%#x}",
                 this
                 ));

    SIGN_SECURE_SOCKET();

    m_hContext.dwLower = m_hContext.dwUpper = 0;
    m_dwProviderIndex = 0;
    m_dwFlags |= SF_SECURE;
    m_lpszHostName = NULL;
    m_pdblbufBuffer = NULL;
    m_pSecurityInfo = NULL;
    m_pCertCache    = NULL;

    DEBUG_LEAVE(0);
}


ICSecureSocket::~ICSecureSocket()

/*++

Routine Description:

    ICSecureSocket destructor. Virtual function

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "ICSecureSocket::~ICSecureSocket",
                 "{%#x [%q, sock=%#x, port=%d]}",
                 this,
                 GetHostName(),
                 GetSocket(),
                 GetSourcePort()
                 ));

    CHECK_SECURE_SOCKET();

    if (IsSecure())
    {
        if (m_pdblbufBuffer != NULL) {
            delete m_pdblbufBuffer;
        }

        // Free security context associated with this object if it's
        // still allocated.
        TerminateSecConnection();


        /* SCLE ref */
        SetSecurityEntry(NULL);
        if (m_lpszHostName != NULL) {
            m_lpszHostName = (LPSTR)FREE_MEMORY(m_lpszHostName);
            INET_ASSERT(m_lpszHostName == NULL);
        }
        //if ( _pCertChainList )
        //    delete _pCertChainList;
    }

    DEBUG_LEAVE(0);
}


DWORD
ICSecureSocket::Connect(
    IN LONG Timeout,
    IN INT Retries,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Initiate secure connection with server

Arguments:

    Timeout - maximum amount of time (mSec) to wait for connection

    Retries - maximum number of attempts to connect

    dwFlags - flags controlling request

Return Value:

    DWORD
        Success - ERROR_SUCCESS

                  ERROR_IO_PENDING
                    Operation will complete asynchronously

        Failure - ERROR_NOT_ENOUGH_MEMORY
                    Couldn't create FSM

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::Connect",
                 "{%#x [%#x]} %d, %d, %#x",
                 this,
                 m_Socket,
                 Timeout,
                 Retries,
                 dwFlags
                 ));

    DWORD error;

    // might be http CONNECT that will morph into an established tunnel
    if (IsSecure())
    {
        error = DoFsm(New CFsm_SecureConnect(Timeout,
                                               Retries,
                                               dwFlags,
                                               this
                                               ));
    }
    else
    {
        // thunk to non-secure connect
        error = ICSocket::Connect(Timeout,
                                  Retries,
                                  dwFlags
                                  );
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_SecureConnect::RunSM(
    IN CFsm * Fsm
    )
{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CFsm_SecureConnect::RunSM",
                 "%#x",
                 Fsm
                 ));

    ICSecureSocket * pSecureSocket = (ICSecureSocket *)Fsm->GetContext();
    CFsm_SecureConnect * stateMachine = (CFsm_SecureConnect *)Fsm;
    DWORD error;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = pSecureSocket->Connect_Fsm(stateMachine);
        break;

    default:
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_WINHTTP_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSecureSocket::Connect_Fsm(
    IN CFsm_SecureConnect * Fsm
    )
{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::Connect_Fsm",
                 "%#x",
                 Fsm
                 ));

    CFsm_SecureConnect & fsm = *Fsm;
    DWORD error = fsm.GetError();

    if (fsm.GetState() != FSM_STATE_INIT) {
        switch (fsm.GetFunctionState()) {
        case FSM_STATE_2:
            goto connect_continue;

        case FSM_STATE_3:
            goto negotiate_continue;

        default:
            error = ERROR_WINHTTP_INTERNAL_ERROR;

            INET_ASSERT(FALSE);

            goto quit;
        }
    }

    m_dwProviderIndex = 0;

    //
    // Hack for SSL2 Client Hello, set to FALSE,
    //  but if we fail on the first recv, fReOpenSocket
    //  is set to TRUE.
    //

    do {

        //
        // Attempt to do the connect
        //

        fsm.SetFunctionState(FSM_STATE_2);
        error = ICSocket::Connect(fsm.m_Timeout, fsm.m_Retries, fsm.m_dwFlags);

connect_continue:

        if (error != ERROR_SUCCESS) {
            break;
        }
        if (m_dwFlags & SF_ENCRYPT) {
            fsm.SetFunctionState(FSM_STATE_3);
            error = SecureHandshakeWithServer(fsm.m_dwFlags, &fsm.m_bAttemptReconnect);
            if (error == ERROR_IO_PENDING) {
                break;
            }

negotiate_continue:

            //
            // SSL2 hack for old IIS servers.
            //  We re-open the socket, and call again.
            //

            if ((error != ERROR_SUCCESS) && fsm.m_bAttemptReconnect) {
                Disconnect(fsm.m_dwFlags);
            }
        }
    } while (fsm.m_bAttemptReconnect);

quit:

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();
        if ((error != ERROR_SUCCESS) && IsOpen()) {
            Disconnect(fsm.m_dwFlags);
        }
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSecureSocket::SecureHandshakeWithServer(
    IN DWORD dwFlags,
    OUT LPBOOL lpbAttemptReconnect
    )

/*++

Routine Description:

    For SSL/PCT or some secure channel this function attempts to use
    an arbitrary Socket for handshaking with a server. The assumption
    is made that caller can recall this function on failure

Arguments:

    dwFlags             -

    lpbAttemptReconnect -

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                Dword,
                "ICSecureSocket::SecureHandshakeWithServer",
                "%#x, %#x [%B]",
                dwFlags,
                lpbAttemptReconnect,
                *lpbAttemptReconnect
                ));

    INET_ASSERT(IsSecure());

    DWORD error = DoFsm(New CFsm_SecureHandshake(dwFlags,
                                                 lpbAttemptReconnect,
                                                 this
                                                 ));

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_SecureHandshake::RunSM(
    IN CFsm * Fsm
    )
{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CFsm_SecureHandshake::RunSM",
                 "%#x",
                 Fsm
                 ));

    ICSecureSocket * pSecureSocket = (ICSecureSocket *)Fsm->GetContext();
    CFsm_SecureHandshake * stateMachine = (CFsm_SecureHandshake *)Fsm;
    DWORD error;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = pSecureSocket->SecureHandshake_Fsm(stateMachine);
        break;

    default:
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_WINHTTP_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSecureSocket::SecureHandshake_Fsm(
    IN CFsm_SecureHandshake * Fsm
    )
{


    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::SecureHandshake_Fsm",
                 "%#x",
                 Fsm
                 ));

    CFsm_SecureHandshake & fsm = *Fsm;
    DWORD error = fsm.GetError();
    DWORD dwSecureFlags;
    DWORD dwCertFlags;
    BOOL fErrorInvalidCa;

    if (fsm.GetState() != FSM_STATE_INIT) {
        switch (fsm.GetFunctionState()) {
        case FSM_STATE_2:
            goto negotiate_continue;

        default:
            error = ERROR_WINHTTP_INTERNAL_ERROR;

            INET_ASSERT(FALSE);

            goto quit;
        }
    }

    //INET_ASSERT(fsm.m_dwFlags & SF_ENCRYPT);
    INET_ASSERT(m_Socket != INVALID_SOCKET);

    *fsm.m_lpbAttemptReconnect = FALSE;

    error = ERROR_SUCCESS;

    //
    // Save Off Flags in our Internal Object.
    //   Treat SF_ENCRYPT just like SF_DECRYPT
    //

    m_dwFlags |= SF_DECRYPT;
    m_dwFlags |= fsm.m_dwFlags;

    INET_ASSERT(!(m_dwFlags
                & ~(SF_NON_BLOCKING
                    | SF_SECURE
                    | SF_ENCRYPT
                    | SF_DECRYPT
                    | SF_INDICATE
                    | SF_SENDING_DATA
                    )));

    //
    // Allocate Internal Buffer for SSL/PCT data.
    //

    if (m_pdblbufBuffer == NULL) {

        BOOL fInitSuccess;

        m_pdblbufBuffer = New DBLBUFFER();
        if (m_pdblbufBuffer == NULL) {
            error = ERROR_NOT_ENOUGH_MEMORY;
            goto quit;
        }
        fInitSuccess = m_pdblbufBuffer->InitBuffer(TRUE);
        if (!fInitSuccess) {
            error = ERROR_NOT_ENOUGH_MEMORY;
            goto quit;
        }
    }

    // First make sure the security dlls are loaded.
    error = LoadSecurity();

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    // If the user has the Fortezza CSP but has not logged on to the card yet.
    // return back an error to indicate that we need to put up additional UI.

    // if (IsFortezzaInstalled( ) && !AttemptedFortezzaLogin( ))
    //{
    //    error = ERROR_WINHTTP_FORTEZZA_LOGIN_NEEDED;
    //    goto quit;
    //}

    //
    //  dwEncFlags is a global flag set to the
    //  supported security pkg mask
    //

    if (!LOCK_SECURITY())
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    if (dwEncFlags == ENC_CAPS_NOT_INSTALLED) {
         error = (DWORD)SEC_E_SECPKG_NOT_FOUND;
    } else if (dwEncFlags == 0) {


         //
         //  first time thru, do the load.
         //

         DEBUG_PRINT(SOCKETS,
                     INFO,
                     ("Loading security dll\n"
                     ));

        if ( !SecurityPkgInitialize() ) {
             error = GetLastError();
             UNLOCK_SECURITY();
             goto quit;
        }
    }

    UNLOCK_SECURITY();

    if ( error != ERROR_SUCCESS )
    {
        goto quit;
    }


    //
    // If we succeed in loading or and initalizing the Security DLLs, we
    //      attempt to negotiate the connection
    //

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("Negotiate secure channel\n"
                ));

    //
    // Turn of Encryption/Decryption before the handshake,
    // since the NegotiateSecConnection does its own Send and Recvs
    // of specialized data.
    //

    m_dwFlags &= ~(SF_ENCRYPT | SF_DECRYPT);
    fsm.SetFunctionState(FSM_STATE_2);
    error = NegotiateSecConnection(fsm.m_dwFlags,
                                   fsm.m_lpbAttemptReconnect
                                   );
    if (error == ERROR_IO_PENDING) {
        goto quit;
    }

negotiate_continue:

    m_dwFlags |= (SF_ENCRYPT | SF_DECRYPT);
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    //  Find out what size Key we're using, and set the flags
    //   acordingly.
    //

    dwSecureFlags = 0;
    if (m_pSecurityInfo && !m_pSecurityInfo->InCache()) {
        error = VerifyTrust();
        if (error != ERROR_SUCCESS) {
            goto quit;
        }
    }

    //
    // we've got a secure connection, set the flags.
    //

    SetSecure();

    if(m_pSecurityInfo)
    {
        INTERNET_SECURITY_INFO ciInfo;
        m_pSecurityInfo->CopyOut(ciInfo);

        if(ciInfo.dwCipherStrength < 56)
        {
            SetSecureFlags(SECURITY_FLAG_STRENGTH_WEAK);
        }
        else if (ciInfo.dwCipherStrength==80 &&
                 (ciInfo.aiCipher == CALG_SKIPJACK || ciInfo.aiCipher==CALG_TEK))
        {
            SetSecureFlags(SECURITY_FLAG_FORTEZZA);
        }
        else if(ciInfo.dwCipherStrength < 96)
        {
             SetSecureFlags(SECURITY_FLAG_STRENGTH_MEDIUM);
        }
        else
        {
             SetSecureFlags(SECURITY_FLAG_STRENGTH_STRONG);
        }
        if(ciInfo.pCertificate)
        {
            WRAP_REVERT_USER_VOID(CertFreeCertificateContext, (ciInfo.pCertificate));
            ciInfo.pCertificate = NULL;
        }
    }

quit:

    if (error != ERROR_IO_PENDING)
    {
        fsm.SetDone();
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSecureSocket::VerifyTrust(
    )

/*++

Routine Description:

    This function establishes a secure channel with the server by
    performing the security handshake protocol.  It will walk
    the list of installed security packages until it finds a package
    that succeeds in the security handshake.  If one package fails
    it is up to the caller to re-call NegotiateSecConnection with
    a re-opened socket so another socket can attempt the connection.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/
{

    // We've done our handshake, now update the security info
    INTERNET_SECURITY_INFO ciCert;
    DWORD dwCertFlags = 0;
    WINTRUST_DATA           sWTD;
    WINTRUST_CERT_INFO      sWTCI;
    HTTPSPolicyCallbackData polHttps;
    DWORD                   cbServerName;
    DWORD error;
    DWORD dwStatusFlag = 0;
    HINTERNET  hInternet;
    HINTERNET  hInternetMapped;
    LPINTERNET_THREAD_INFO lpThreadInfo = NULL;

    DWORD dwFlags = 0;    // HTTPS policy flags to ignore errors

    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::VerifyTrust",
                 "{%#x",
                 this
                 ));

    // HACK HACK: 67640
    // WinVerifyTrust can do a nested HttpSendRequest which causes the hObject's on the 
    // thread to get messed up. This happens only when the ceritificate has a URL for 
    // a CRL in it. We save and restore these values to workaround the problem.
    // Need to work out a better solution to handle this but it is too close to ship to 
    // try anything with greater code impact. 
    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo != NULL)
    {
        hInternet = lpThreadInfo->hObject;
        hInternetMapped = lpThreadInfo->hObjectMapped;
    }


    error = QuerySecurityInfo(&m_hContext, &ciCert, &dwStatusFlag);
    if (error != ERROR_SUCCESS)
    {
        if (m_pSecurityInfo)
            m_pSecurityInfo->SetStatusFlags(dwStatusFlag);
        goto quit;
    }

    if(m_pSecurityInfo)
    {
        *m_pSecurityInfo = &ciCert;
        // Other flags have been filtered already, but make sure revocation
        // flag is removed, so it isn't passed to WVT.
        dwCertFlags = m_pSecurityInfo->GetSecureFlags() &
                ~(SECURITY_FLAG_CHECK_REVOCATION | SECURITY_FLAG_BREAK_ON_STATUS_SECURE_FAILURE);
    }
    if (ciCert.pCertificate == NULL)
    {
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto quit;
    }

    memset(&sWTD, 0x00, sizeof(WINTRUST_DATA));
    sWTD.cbStruct               = sizeof(WINTRUST_DATA);
    sWTD.dwUIChoice             = WTD_UI_NONE;
    sWTD.pPolicyCallbackData    = (LPVOID)&polHttps;
    sWTD.dwUnionChoice          = WTD_CHOICE_CERT;
    sWTD.pCert                  = &sWTCI;
    sWTD.pwszURLReference       = NULL;
    if (m_pSecurityInfo &&
        (m_pSecurityInfo->GetSecureFlags() & SECURITY_FLAG_CHECK_REVOCATION))
    {
        sWTD.fdwRevocationChecks = WTD_REVOKE_WHOLECHAIN;
    }
    else
    {
        sWTD.fdwRevocationChecks = 0;
    }

    memset(&sWTCI, 0x00, sizeof(WINTRUST_CERT_INFO));
    sWTCI.cbStruct              = sizeof(WINTRUST_CERT_INFO);
    sWTCI.psCertContext         = (CERT_CONTEXT *)ciCert.pCertificate;
    sWTCI.chStores              = 1;
    sWTCI.pahStores  = (HCERTSTORE *)&ciCert.pCertificate->hCertStore;


    memset(&polHttps, 0x00, sizeof(HTTPSPolicyCallbackData));
    polHttps.cbStruct =  sizeof(HTTPSPolicyCallbackData);
    polHttps.dwAuthType = AUTHTYPE_SERVER;
    polHttps.fdwChecks = dwCertFlags;
    
    cbServerName = MultiByteToWideChar(CP_ACP, 0, m_lpszHostName, -1, NULL, 0);

    polHttps.pwszServerName = New WCHAR[cbServerName+1];

    if(polHttps.pwszServerName == 0)
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    sWTCI.pcwszDisplayName      = polHttps.pwszServerName;

    cbServerName = MultiByteToWideChar(CP_ACP, 0, m_lpszHostName, -1, polHttps.pwszServerName, cbServerName);

    error = LoadWinTrust();
    if(ERROR_SUCCESS == error)
    {
        error = WinVerifySecureChannel(NULL, &sWTD);
    }

    error = MapInternetError(error, &dwStatusFlag);


    //
    // If there was problem with the certificate and the caller requested
    // combined SSL errors cycle through all possible certificate errors.
    //

    if (ERROR_SUCCESS != error && m_pSecurityInfo)
    {
        BOOL  fCertError = FALSE;
 
        do
        {
            if (dwStatusFlag & WINHTTP_CALLBACK_STATUS_FLAG_INVALID_CA)
            {
                polHttps.fdwChecks |=  DLG_FLAGS_IGNORE_INVALID_CA;
                dwFlags |= DLG_FLAGS_INVALID_CA;
                m_pSecurityInfo->SetStatusFlags(WINHTTP_CALLBACK_STATUS_FLAG_INVALID_CA);
                if (!(dwCertFlags & SECURITY_FLAG_IGNORE_UNKNOWN_CA))
                    fCertError = TRUE;
            }
            else if (dwStatusFlag & WINHTTP_CALLBACK_STATUS_FLAG_CERT_CN_INVALID)
            {
                polHttps.fdwChecks |= DLG_FLAGS_IGNORE_CERT_CN_INVALID;
                dwFlags |= DLG_FLAGS_SEC_CERT_CN_INVALID;
                m_pSecurityInfo->SetStatusFlags(WINHTTP_CALLBACK_STATUS_FLAG_CERT_CN_INVALID);
                if (!(dwCertFlags & INTERNET_FLAG_IGNORE_CERT_CN_INVALID))
                    fCertError = TRUE;
            }
            else if (dwStatusFlag & WINHTTP_CALLBACK_STATUS_FLAG_CERT_DATE_INVALID)
            {
                polHttps.fdwChecks |= DLG_FLAGS_IGNORE_CERT_DATE_INVALID;
                dwFlags |= DLG_FLAGS_SEC_CERT_DATE_INVALID;
                m_pSecurityInfo->SetStatusFlags(WINHTTP_CALLBACK_STATUS_FLAG_CERT_DATE_INVALID);
                if (!(dwCertFlags & INTERNET_FLAG_IGNORE_CERT_DATE_INVALID))
                    fCertError = TRUE;
            }
            else if (dwStatusFlag & WINHTTP_CALLBACK_STATUS_FLAG_CERT_REVOKED)
            {
                // In wininet, we break out on revoked and only pass it back.
                // This is because the UI is broken into only 2 buckets, and
                // revoked takes precedence.
                sWTD.fdwRevocationChecks = 0;
                m_pSecurityInfo->SetStatusFlags(WINHTTP_CALLBACK_STATUS_FLAG_CERT_REVOKED);
                fCertError = TRUE;
            }
            else if (dwStatusFlag & WINHTTP_CALLBACK_STATUS_FLAG_CERT_REV_FAILED)
            {
                // In wininet, this was handled outside the loop as a special
                // case.  There's no need for that now, so OR the error in and
                // continue.
                sWTD.fdwRevocationChecks = 0;
                dwFlags |= DLG_FLAGS_SEC_CERT_REV_FAILED;
                m_pSecurityInfo->SetStatusFlags(WINHTTP_CALLBACK_STATUS_FLAG_CERT_REV_FAILED);
                fCertError = TRUE;
            }
            else
            {
                //
                // Pass all other errors through.
                //

                break;
            }

            error = WinVerifySecureChannel(NULL, &sWTD);

            error = MapInternetError(error, &dwStatusFlag);

        } while (ERROR_SUCCESS != error);

        //
        // Change the error only if one of the known certifciate errors was
        // encountered.
        //

        if (m_pSecurityInfo->GetStatusFlags())
        {
            // Just send a status notification if there's an error,
            // and let the app decide if this should be closed as a failure.
            if (lpThreadInfo)
            {
                WINHTTP_STATUS_CALLBACK appCallback = NULL;
                RGetStatusCallback(hInternetMapped, &appCallback);
                if (appCallback)
                {
                    DWORD dwStatusFlags = m_pSecurityInfo->GetStatusFlags();
                    // Report SSL status of all errors found
                    InternetIndicateStatus(WINHTTP_CALLBACK_STATUS_SECURE_FAILURE,
                                           &dwStatusFlags,
                                           sizeof(dwStatusFlags)
                                           );

                }
            }
            // ...except if the client told us upfront to fail.
            if (fCertError &&
                   (m_pSecurityInfo->GetSecureFlags() &
                    SECURITY_FLAG_BREAK_ON_STATUS_SECURE_FAILURE))
            {
                error = ERROR_WINHTTP_SECURE_FAILURE;
            }
            else
            {
                error = SUCCESS;
            }
            m_pSecurityInfo->SetSecureFlags(dwFlags);
        }
    }

    delete polHttps.pwszServerName;

    if(ciCert.pCertificate)
    {
        WRAP_REVERT_USER_VOID(CertFreeCertificateContext, (ciCert.pCertificate));
    }

    if (error != ERROR_SUCCESS)
    {
        goto quit;
    }

    if(m_pSecurityInfo && (!m_pSecurityInfo->InCache()))
    {
        // Add it to the cache if it's not already there.
        /* SCLE ref */

        // Use global or session cache, depending on the settings
        // This was mapped when initializing the socket with SetHostName
        if (m_pCertCache)
            m_pCertCache->Add(m_pSecurityInfo);
    }

quit:                                 
    if (lpThreadInfo != NULL) {
        _InternetSetObjectHandle(lpThreadInfo, hInternet, hInternetMapped);
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSecureSocket::NegotiateSecConnection(
    IN DWORD dwFlags,
    OUT LPBOOL lpbAttemptReconnect
    )

/*++

Routine Description:

    This function establishes a secure channel with the server by
    performing the security handshake protocol.  It will walk
    the list of installed security packages until it finds a package
    that succeeds in the security handshake.  If one package fails
    it is up to the caller to re-call NegotiateSecConnection with
    a re-opened socket so another socket can attempt the connection.

Arguments:

    dwFlags    - Socket Flags that may need to be passed on to Socket Calls
                (needed to support Async I/O)

    lpbAttemptReconnect - on return, if this value is TRUE, the caller should call
                          this function again, and it will try another protocol.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::NegotiateSecConnection",
                 "{%#x [%#x]} %#x, %#x [%B]",
                 this,
                 m_Socket,
                 dwFlags,
                 lpbAttemptReconnect,
                 *lpbAttemptReconnect
                 ));

    INET_ASSERT(IsSecure());

    DWORD error = DoFsm(New CFsm_SecureNegotiate(dwFlags,
                                                 lpbAttemptReconnect,
                                                 this
                                                 ));

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_SecureNegotiate::RunSM(
    IN CFsm * Fsm
    )
{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CFsm_SecureNegotiate::RunSM",
                 "%#x",
                 Fsm
                 ));

    ICSecureSocket * pSecureSocket = (ICSecureSocket *)Fsm->GetContext();
    CFsm_SecureNegotiate * stateMachine = (CFsm_SecureNegotiate *)Fsm;
    DWORD error;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = pSecureSocket->SecureNegotiate_Fsm(stateMachine);
        break;

    default:
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_WINHTTP_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSecureSocket::SecureNegotiate_Fsm(
    IN CFsm_SecureNegotiate * Fsm
    )
{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::SecureNegotiate_Fsm",
                 "%#x",
                 Fsm
                 ));

    CFsm_SecureNegotiate & fsm = *Fsm;
    DWORD error = fsm.GetError();
    DWORD dwSSPIFlags = 0;
    DWORD dwStatusFlag = 0;

    if (fsm.GetState() != FSM_STATE_INIT) {
        switch (fsm.GetFunctionState()) {
        case FSM_STATE_2:
            goto send_continue;

        case FSM_STATE_3:
            goto negotiate_loop_continue;

        default:
            error = ERROR_WINHTTP_INTERNAL_ERROR;

            INET_ASSERT(FALSE);

            goto quit;
        }
    }

    INET_ASSERT(IsOpen());

    *fsm.m_lpbAttemptReconnect = FALSE;

    //
    // set OutBuffer for InitializeSecurityContext call
    //

    fsm.m_OutBuffer.cBuffers = 1;
    fsm.m_OutBuffer.pBuffers = fsm.m_OutBuffers;
    fsm.m_OutBuffer.ulVersion = SECBUFFER_VERSION;

    if(GlobalSecureProtocols != GlobalSecureProtocolsCopy)
    {
        if (LOCK_SECURITY())
        {
            //ReInit the credentials if our settings have changed.
            SecurityPkgInitialize();
            UNLOCK_SECURITY();
        }
        else
        {
            error = ERROR_NOT_ENOUGH_MEMORY;
            goto error_exit;
        }
    }

    //
    // Pick the provider we're going to use.
    //

    while ((SecProviders[GetProviderIndex()].pszName != NULL)
           && ( !SecProviders[GetProviderIndex()].fEnabled
             || !(SecProviders[GetProviderIndex()].dwProtocolFlags & GlobalSecureProtocols) ) ) {

        //
        // Next provider
        //

        SetProviderIndex(GetProviderIndex() + 1);
    }

    if (SecProviders[GetProviderIndex()].pszName == NULL) {

        //
        // BUGBUG shouldn't we error out here?
        //

        SetProviderIndex(0);
        goto error_exit;
    }

    DWORD i;

    i = GetProviderIndex();

    DEBUG_PRINT(API,
                INFO,
                ("Starting handshake protocol with pkg %d - %s\n",
                i,
                SecProviders[i].pszName
                ));


    //
    // 1. initiate a client HELLO message and generate a token
    //

    fsm.m_OutBuffers[0].pvBuffer = NULL;
    fsm.m_OutBuffers[0].BufferType = SECBUFFER_TOKEN;

    SECURITY_STATUS scRet;
    DWORD ContextAttr;
    TimeStamp tsExpiry;

    fsm.m_bDoingClientAuth = FALSE;

    // Resynchronize the certificate store to catch
    // recently installed certificates
    if (g_hMyCertStore)
    {
        WRAP_REVERT_USER_VOID(CertControlStore,
                              (g_hMyCertStore, 0, CERT_STORE_CTRL_AUTO_RESYNC, NULL));
    }

    //
    // We need a credential handle,
    //  if we're doing client do the magic to get a specialized
    //  one otherwise use the standard global one.
    //

    if ( IsCredClear(fsm.m_hCreds) )
    {
        fsm.m_hCreds = SecProviders[i].hCreds;

        if (GetCertContextArray())
        {
            if (GetCertContextArray()->GetSelectedCertContext())
            {
                error = CliAuthSelectCredential(
                            &m_hContext,
                            SecProviders[i].pszName,
                            GetCertContextArray(),
                            &fsm.m_hCreds,
                            &dwStatusFlag);

                if (error != ERROR_SUCCESS) {
                    goto quit;
                }

                fsm.m_bDoingClientAuth = TRUE;
            }

            dwSSPIFlags |= ISC_REQ_USE_SUPPLIED_CREDS;
        }
    }

    // Force a full handshake when per session and entry isn't in the cache.
    if (m_pCertCache != &GlobalCertCache && !m_pSecurityInfo->InCache())
        dwSSPIFlags |= ISC_REQ_USE_SESSION_KEY;

    WRAP_REVERT_USER(g_InitializeSecurityContext,
                     (&fsm.m_hCreds,
                     NULL,
                     (LPSTR)GetHostName(),
                     ISC_REQ_SEQUENCE_DETECT
                     | ISC_REQ_REPLAY_DETECT
                     | ISC_REQ_CONFIDENTIALITY
                     | ISC_REQ_ALLOCATE_MEMORY
                     | dwSSPIFlags,
                     0,
                     SECURITY_NATIVE_DREP,
                     NULL,       // default, don't do hack.
                     0,
                     &m_hContext,
                     &fsm.m_OutBuffer, // address where output data go
                     &ContextAttr,
                     &tsExpiry),
                     scRet);

    DEBUG_PRINT(API,
                INFO,
                ("1. InitializeSecurityContext returned %s [%x]. hContext = %#x:%#x\n",
                InternetMapSSPIError((DWORD)scRet),
                scRet,
                m_hContext.dwUpper,
                m_hContext.dwLower
                ));

    if (scRet == SEC_E_INVALID_HANDLE) {
         SecProviders[i].fEnabled = FALSE;
    }
    if (scRet == SEC_E_INVALID_TOKEN) {
        error = ERROR_WINHTTP_CANNOT_CONNECT;
    } else {

        //
        // Turn the error in to one we understand */
        //

        error = MapInternetError((DWORD)scRet, &dwStatusFlag);
    }
    if (scRet != SEC_I_CONTINUE_NEEDED) {
        goto error_exit;
    }

    DEBUG_PRINT(API,
                INFO,
                ("1. OutBuffer is <%x, %d, %x>\n",
                fsm.m_OutBuffers[0].pvBuffer,
                fsm.m_OutBuffers[0].cbBuffer,
                fsm.m_OutBuffers[0].BufferType
                ));

    if ((fsm.m_OutBuffers[0].cbBuffer != 0)
    && (fsm.m_OutBuffers[0].pvBuffer != NULL)) {

        //
        // Send response to server if there is one
        //

        fsm.SetFunctionState(FSM_STATE_2);
        error = ICSocket::Send(fsm.m_OutBuffers[0].pvBuffer,
                               fsm.m_OutBuffers[0].cbBuffer,
                               0
                               );
        if (error == ERROR_IO_PENDING) {
            goto quit;
        }

send_continue:

        g_FreeContextBuffer(fsm.m_OutBuffers[0].pvBuffer);
        fsm.m_OutBuffers[0].pvBuffer = NULL;
        if (error != ERROR_SUCCESS) {

            //
            // We should deal with this better
            //

            goto error_exit;
        }
    }

    fsm.SetFunctionState(FSM_STATE_3);
    error = SSPINegotiateLoop(NULL, fsm.m_dwFlags, fsm.m_hCreds, TRUE, fsm.m_bDoingClientAuth);

    //
    // We're not actually deleting the handle, rather we're no longer keeping
    //  a reference to the Credential handle in our fsm after we hand it off
    //

    if ( fsm.m_bDoingClientAuth )
    {
        ClearCreds(fsm.m_hCreds);
        fsm.m_bDoingClientAuth = FALSE;
    }
    if (error == ERROR_IO_PENDING) {
        goto quit;
    }

negotiate_loop_continue:
error_exit:

    if (error == ERROR_WINHTTP_SECURE_FAILURE && m_pSecurityInfo)
        m_pSecurityInfo->SetStatusFlags(dwStatusFlag);
    
    if (error == ERROR_WINHTTP_CANNOT_CONNECT) {

        //
        // error was a CANNOT_CONNECT, so try the next protocol.
        //

        SetProviderIndex(GetProviderIndex() + 1);

        if (SecProviders[GetProviderIndex()].pszName == NULL) {
            SetProviderIndex(0);
            *fsm.m_lpbAttemptReconnect = FALSE;
        } else {
            *fsm.m_lpbAttemptReconnect = TRUE;
        }
    }

quit:

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSecureSocket::SSPINegotiateLoop(
    OUT DBLBUFFER * pdblbufBuffer,
    IN DWORD dwFlags,
    CredHandle hCreds,
    IN BOOL bDoInitialRead,
    IN BOOL bDoingClientAuth
    )

/*++

Routine Description:

    This function completes the handshakes needed to establish a
    security protocol.  The initial handshakes are either generated
    by NegotiateSecureConnection, when generating a new connection, or
    during a receive when a REDO request is received.

Arguments:

    pdblbufBuffer - an input buffer into which to put any Extra data left over
                    after the handshake.  This data is assumed to be application
                    data, and will be decrypted later.

    dwFlags    - Socket Flags that may need to be passed on to Socket Calls
                (needed to support Async I/O)

    bDoInitialRead - if TRUE, this function will do a read before calling
                     InitializeSecurityContext, otherwise, it passes in 0 bytes of data.

Return Value:

    ERROR_SUCCESS - we successfully completed our connection.
    ERROR_WINHTTP_CANNOT_CONNECT - The connection was dropped on us, possibly because we used a bad
                                    protocol.  Try the next protocol.

    ERROR_*                       - Other internet error, disconnect.


Comments:

    BUGBUG (hack alert) [arthurbi]
    Do to a bug in IIS 1.0 Servers we cannot connect because
    we send a "Client SSL 3 Message".  This message confuses the
    server and causes it to close the socket.  The fix is to
    reopen the socket and send a "Client SSL 2 Message."  Newer
    versions of the server will be fixed.


--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::SSPINegotiateLoop",
                 "{%#x [%#x]} %#x, %#x, %B",
                 this,
                 m_Socket,
                 pdblbufBuffer,
                 dwFlags,
                 bDoInitialRead
                 ));

    INET_ASSERT(IsSecure());

    DWORD error = DoFsm(New CFsm_NegotiateLoop(pdblbufBuffer,
                                               dwFlags,
                                               bDoInitialRead,
                                               bDoingClientAuth,
                                               hCreds,
                                               this
                                               ));

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_NegotiateLoop::RunSM(
    IN CFsm * Fsm
    )
{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CFsm_NegotiateLoop::RunSM",
                 "%#x",
                 Fsm
                 ));

    ICSecureSocket * pSecureSocket = (ICSecureSocket *)Fsm->GetContext();
    CFsm_NegotiateLoop * stateMachine = (CFsm_NegotiateLoop *)Fsm;
    DWORD error;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = pSecureSocket->NegotiateLoop_Fsm(stateMachine);
        break;

    default:
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_WINHTTP_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSecureSocket::NegotiateLoop_Fsm(
    IN CFsm_NegotiateLoop * Fsm
    )
{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::NegotiateLoop_Fsm",
                 "%#x",
                 Fsm
                 ));

    CFsm_NegotiateLoop & fsm = *Fsm;
    DWORD error = fsm.GetError();
    DWORD dwStatus = 0;

    if (fsm.GetState() != FSM_STATE_INIT) {
        switch (fsm.GetFunctionState()) {
        case FSM_STATE_2:
            goto receive_continue;

        case FSM_STATE_3:
            goto send_continue;

        default:
            error = ERROR_WINHTTP_INTERNAL_ERROR;

            INET_ASSERT(FALSE);

            goto quit;
        }
    }

    INET_ASSERT(IsOpen());

    fsm.m_dwProviderIndex = GetProviderIndex();

    fsm.m_dwSSPIFlags = ISC_REQ_SEQUENCE_DETECT
                      | ISC_REQ_REPLAY_DETECT
                      | ISC_REQ_CONFIDENTIALITY
                      | ISC_REQ_ALLOCATE_MEMORY
                      | ISC_RET_EXTENDED_ERROR;

    //
    // set OutBuffer for InitializeSecurityContext call
    //

    fsm.m_OutBuffer.cBuffers = 1;
    fsm.m_OutBuffer.pBuffers = fsm.m_OutBuffers;
    fsm.m_OutBuffer.ulVersion = SECBUFFER_VERSION;

    //
    // If we have a selected cert chain, then try to
    // generate a credential from that list.
    //

    if (IsCredClear(fsm.m_hCreds))
    {
        fsm.m_hCreds = SecProviders[fsm.m_dwProviderIndex].hCreds;

        if ( GetCertContextArray() &&
             GetCertContextArray()->GetSelectedCertContext() )
        {
            error = CliAuthSelectCredential(
                        &m_hContext,
                        SecProviders[fsm.m_dwProviderIndex].pszName,
                        GetCertContextArray(),
                        &fsm.m_hCreds,
                        &dwStatus);

            if (error != ERROR_SUCCESS) {
                goto quit;
            }

            fsm.m_bDoingClientAuth = TRUE;
        }
    }

    if (fsm.m_bDoingClientAuth ||
        GetCertContextArray() )
    {
        fsm.m_dwSSPIFlags |= ISC_REQ_USE_SUPPLIED_CREDS;
    }

    // Force a full handshake when per session and entry isn't in the cache.
    if (m_pCertCache == &GlobalCertCache && !m_pSecurityInfo->InCache())
        fsm.m_dwSSPIFlags |= ISC_REQ_USE_SESSION_KEY;

    fsm.m_scRet = SEC_I_CONTINUE_NEEDED;

    while (fsm.m_scRet == SEC_I_CONTINUE_NEEDED ||
           fsm.m_scRet == SEC_E_INCOMPLETE_MESSAGE ||
           fsm.m_scRet == SEC_I_INCOMPLETE_CREDENTIALS) {

        //
        //  send to target server
        //  if we've got a SEC_E_INCOMPLETE_MESSAGE we need to do a read
        //  again because we didn't get the entire message we expected from
        //  the server.
        //


        //
        //  receive response from server and pass token into security pkg
        //    BUT only if we haven't already received extra data
        //    from SSPI which we need to process in lu of actual data
        //    data from WinSock, and if the package has not returned
        //    one of the defined warnings that indicates that we should
        //    pass the previous buffer again.
        //


        // Make sure fsm.m_lpszBuffer holds the input data to be passed
        // to initialize security context.  There are 4 cases:
        // 1) We have Extra Data, so we don't need to do a socket receive
        // 2) We were called during a re-negotiate, so if this is the first
        //    time through the loop, we have 0 bytes.
        // 3) We are recovering from a SEC_I_INCOMPLETE_CREDENTIALS, so
        //    use the same buffer again.
        // 4) We do a SocketReceive
        // We'll indicate 1 and 3 by having the fsm.m_dwBytesReceived count being the number of bytes
        // left in the buffer to be re-sent or sent to the sspi call.
        // If bytes-received is zero, then either we are doing a Redo, or we need to receive
        // data.  fsm.m_bDoRead let's us know if for some reason we should do or not do this read



        if ((0 == fsm.m_dwBytesReceived) || (fsm.m_scRet == SEC_E_INCOMPLETE_MESSAGE)) {
            if (fsm.m_bDoRead) {
                fsm.SetFunctionState(FSM_STATE_2);
                error = ICSocket::Receive((LPVOID *)&fsm.m_lpszBuffer,
                                          &fsm.m_dwBufferLength,
                                          &fsm.m_dwBufferLeft,
                                          &fsm.m_dwBytesReceived,
                                          0,
                                          SF_EXPAND,
                                          &fsm.m_bEofReceive
                                          );
                if (error == ERROR_IO_PENDING) {
                    goto done;
                }

receive_continue:

                if ((error != ERROR_SUCCESS) || fsm.m_bEofReceive) {

                    DEBUG_PRINT(API,
                                ERROR,
                                ("SocketReceive failed\n"
                                ));

                    if (error == ERROR_SUCCESS) {
                        error = ERROR_WINHTTP_CANNOT_CONNECT;
                    }
                    break;
                }
            } else {
                fsm.m_bDoRead = TRUE;
            }
        }

        if (fsm.m_scRet == SEC_I_INCOMPLETE_CREDENTIALS) {

            CERT_CONTEXT_ARRAY* pCertContextArray;

            //
            // If've already done Client Auth, and it fails again
            //  then we fail.
            //

            if (fsm.m_bDoingClientAuth) {
                error = ERROR_CANCELLED;
                goto quit;
            }

            //
            // If we don't already have a cert chain list,
            // then get one, and make our selection
            //

            INET_ASSERT(!GetCertContextArray());

            pCertContextArray = NULL;

            //delete pCertChainList;
            //SetCertChainList(NULL);

            error = CliAuthAcquireCertContexts(
                        &m_hContext,
                        SecProviders[fsm.m_dwProviderIndex].pszName,
                        &pCertContextArray,
                        &dwStatus
                        );

            SetCertContextArray(pCertContextArray);

            if (error == ERROR_SUCCESS) {
                error = ERROR_WINHTTP_CLIENT_AUTH_CERT_NEEDED;
            }

            fsm.m_scRet = error;
            break;
        }

        //
        // InBuffers[1] is for getting extra data that
        //  SSPI/SCHANNEL doesn't proccess on this
        //  run around the loop.
        //

        fsm.m_InBuffers[0].pvBuffer   = fsm.m_lpszBuffer;
        fsm.m_InBuffers[0].cbBuffer   = fsm.m_dwBytesReceived;
        fsm.m_InBuffers[0].BufferType = SECBUFFER_TOKEN;

        fsm.m_InBuffers[1].pvBuffer   = NULL;
        fsm.m_InBuffers[1].cbBuffer   = 0;
        fsm.m_InBuffers[1].BufferType = SECBUFFER_EMPTY;

        //
        // Initialize these so if we fail, pvBuffer contains NULL,
        // so we don't try to free random garbage at the quit
        //

        fsm.m_OutBuffers[0].pvBuffer   = NULL;
        fsm.m_OutBuffers[0].BufferType = SECBUFFER_TOKEN;
        fsm.m_OutBuffers[0].cbBuffer   = 0;

        SecBufferDesc InBuffer;

        InBuffer.cBuffers        = 2;
        InBuffer.pBuffers        = fsm.m_InBuffers;
        InBuffer.ulVersion       = SECBUFFER_VERSION;

        DWORD ContextAttr;
        TimeStamp tsExpiry;

        WRAP_REVERT_USER(g_InitializeSecurityContext,
                         (&fsm.m_hCreds,
                          &m_hContext,
                          NULL,
                          fsm.m_dwSSPIFlags,
                          0,
                          SECURITY_NATIVE_DREP,
                          &InBuffer,
                          0,
                          NULL,
                          &fsm.m_OutBuffer,
                          &ContextAttr,
                          &tsExpiry),
                         fsm.m_scRet);

        DEBUG_PRINT(API,
                    INFO,
                    ("3. InitializeSecurityContext returned %s [%x]\n",
                    InternetMapSSPIError((DWORD)fsm.m_scRet),
                    fsm.m_scRet
                    ));

        if (fsm.m_scRet == STATUS_SUCCESS ||
             fsm.m_scRet == SEC_I_CONTINUE_NEEDED ||
             (FAILED(fsm.m_scRet) && (0 != (ContextAttr & ISC_RET_EXTENDED_ERROR))))
        {
            if  (fsm.m_OutBuffers[0].cbBuffer != 0    &&
                 fsm.m_OutBuffers[0].pvBuffer != NULL )
            {

                //
                // Send response to server if there is one
                //

                fsm.SetFunctionState(FSM_STATE_3);
                error = ICSocket::Send(fsm.m_OutBuffers[0].pvBuffer,
                                       fsm.m_OutBuffers[0].cbBuffer,
                                       0
                                       );
                if (error == ERROR_IO_PENDING) {
                    goto done;
                }

send_continue:

                g_FreeContextBuffer(fsm.m_OutBuffers[0].pvBuffer);
                fsm.m_OutBuffers[0].pvBuffer = NULL;
            }
        }


        if ( fsm.m_scRet == STATUS_SUCCESS )
        {
            DEBUG_PRINT(API,
                     INFO,
                    ("NegotiateSecConnection succeeded.\n"));


            if (fsm.m_pdblbufBuffer)
            {
                if ( fsm.m_InBuffers[1].BufferType == SECBUFFER_EXTRA )
                {

                    fsm.m_pdblbufBuffer->CopyIn(
                        (LPBYTE) (fsm.m_lpszBuffer + (fsm.m_dwBytesReceived - fsm.m_InBuffers[1].cbBuffer)),
                        fsm.m_InBuffers[1].cbBuffer
                        );

                }
                else
                {
                    fsm.m_pdblbufBuffer->SetInputBufferSize(0);
                }
            }



            //
            // Bail out to quit
            //

            break;
        }
        else if (FAILED(fsm.m_scRet) && (fsm.m_scRet != SEC_E_INCOMPLETE_MESSAGE))
        {

             //
             //  free security context handle and delete the local
             //  data structures associated with the handle and
             //  try another pkg if available
             //

             DEBUG_PRINT(API,
                         INFO,
                         ("3. InitializeSecurityContext failed, %lx\n",
                         fsm.m_scRet
                         ));


             // Turn the error in to one we understand */
             error = MapInternetError((DWORD)fsm.m_scRet, &dwStatus);

             TerminateSecConnection();
             /* Break out to try next protocol */
             break;
        }

        if ((fsm.m_scRet != SEC_E_INCOMPLETE_MESSAGE)
        && (fsm.m_scRet != SEC_I_INCOMPLETE_CREDENTIALS)) {

            DEBUG_PRINT(API,
                        INFO,
                        ("3. OutBuffer is <%x, %d, %x>\n",
                        fsm.m_OutBuffers[0].pvBuffer,
                        fsm.m_OutBuffers[0].cbBuffer,
                        fsm.m_OutBuffers[0].BufferType
                        ));

            if (fsm.m_InBuffers[1].BufferType == SECBUFFER_EXTRA) {

                //
                // skip next recv and set up buffers
                //  so InitalizeSecurityContext pulls its
                //  info from the Extra it returned previously.
                //

                DEBUG_PRINT(API,
                         INFO,
                         ("Got SECBUFFER_EXTRA, moving %d bytes to front of buffer\n",
                         fsm.m_InBuffers[1].cbBuffer
                         ));

                INET_ASSERT(fsm.m_InBuffers[1].cbBuffer > 0);

                MoveMemory(
                        fsm.m_lpszBuffer,             // dest
                        fsm.m_lpszBuffer + (fsm.m_dwBytesReceived - fsm.m_InBuffers[1].cbBuffer),
                        fsm.m_InBuffers[1].cbBuffer   // size
                        );

                fsm.m_dwBytesReceived = fsm.m_InBuffers[1].cbBuffer;
                fsm.m_dwBufferLeft   = fsm.m_dwBufferLength - fsm.m_dwBytesReceived;
            } else {

                //
                // prepare for next receive
                //

                fsm.m_dwBufferLeft = fsm.m_dwBufferLength;
                fsm.m_dwBytesReceived = 0;
            }
        }
    }

quit:

    if (fsm.m_lpszBuffer != NULL)
    {
         fsm.m_lpszBuffer = (LPSTR)FREE_MEMORY(fsm.m_lpszBuffer);
         INET_ASSERT(fsm.m_lpszBuffer == NULL);
    }

done:

    if (error != ERROR_IO_PENDING)
    {
        DWORD dwStatus;
        if (m_pSecurityInfo && (dwStatus = m_pSecurityInfo->GetStatusFlags()))
        {
            // Report SSL status of all errors found
            DWORD dwStatus = m_pSecurityInfo->GetStatusFlags();
            InternetIndicateStatus(WINHTTP_CALLBACK_STATUS_SECURE_FAILURE,
                                   &dwStatus,
                                   sizeof(dwStatus)
                                   );
        }
        fsm.SetDone();
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSecureSocket::Disconnect(
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Undoes the work of ConnectSocket - i.e. closes a connected socket. We make
    callbacks to inform the app that this socket is being closed

Arguments:

    dwFlags - controlling operation

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::Disconnect",
                 "{%#x} %#x",
                 m_Socket,
                 dwFlags
                 ));

    DWORD error = ICSocket::Disconnect(dwFlags);

    //
    // delete security context handle for the connection
    //

    if ((m_dwFlags & (SF_ENCRYPT | SF_DECRYPT))
    && dwEncFlags != ENC_CAPS_NOT_INSTALLED) {
        TerminateSecConnection();
    }

    //
    // Zero out the pending input buffer
    //

    if (m_pdblbufBuffer != NULL) {
        m_pdblbufBuffer->SetInputBufferSize(0);
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSecureSocket::Send(
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Sends data over a secure connection

Arguments:

    lpBuffer        - pointer to user data to send

    dwBufferLength  - length of user data

    dwFlags         - flags controlling operation

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::Send",
                 "{%#x [%#x]} %#x, %d, %#x",
                 this,
                 m_Socket,
                 lpBuffer,
                 dwBufferLength,
                 dwFlags
                 ));

    INET_ASSERT(lpBuffer != NULL);
    INET_ASSERT((int)dwBufferLength > 0);

    DWORD error;

    if (IsSecure())  // might be attempting http CONNECT
    {
        error = DoFsm(New CFsm_SecureSend(lpBuffer,
                                          dwBufferLength,
                                          dwFlags,
                                          this
                                          ));
    }
    else
    {
        // thunk to non-secure send
        error = ICSocket::Send(lpBuffer,
                               dwBufferLength,
                               dwFlags
                               );
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_SecureSend::RunSM(
    IN CFsm * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CFsm_SecureSend::RunSM",
                 "%#x",
                 Fsm
                 ));

    ICSecureSocket * pSecureSocket = (ICSecureSocket *)Fsm->GetContext();
    CFsm_SecureSend * stateMachine = (CFsm_SecureSend *)Fsm;
    DWORD error;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = pSecureSocket->Send_Fsm(stateMachine);
        break;

    default:
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_WINHTTP_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSecureSocket::Send_Fsm(
    IN CFsm_SecureSend * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::Send_Fsm",
                 "%#x",
                 Fsm
                 ));

    CFsm_SecureSend & fsm = *Fsm;
    DWORD error = fsm.GetError();

    if (fsm.GetState() == FSM_STATE_INIT) {

        //
        // Log The Data BEFORE we Encrypt It ( if we do )
        //

        DEBUG_DUMP_API(SOCKETS,
                       "sending data:\n",
                       fsm.m_lpBuffer,
                       fsm.m_dwBufferLength
                       );

    }

    while (((int)fsm.m_dwBufferLength > 0) && (error == ERROR_SUCCESS)) {

        LPVOID lpBuffer;
        DWORD dwLength;
        DWORD dwBytes;

        if (m_dwFlags & SF_ENCRYPT) {

            DWORD dwBytesEncrypted;

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("Encrypting data..\n"
                        ));

            error = EncryptData(fsm.m_lpBuffer,
                                fsm.m_dwBufferLength,
                                &fsm.m_lpCryptBuffer,
                                &fsm.m_dwCryptBufferLength,
                                &dwBytesEncrypted
                                );
            if (error != ERROR_SUCCESS) {
                break;
            }

            INET_ASSERT(fsm.m_lpCryptBuffer != NULL);
            INET_ASSERT((int)fsm.m_dwCryptBufferLength > 0);
            INET_ASSERT(dwBytesEncrypted <= fsm.m_dwBufferLength);

            lpBuffer = fsm.m_lpCryptBuffer;
            dwLength = fsm.m_dwCryptBufferLength;
            dwBytes = dwBytesEncrypted;
        } else {
            lpBuffer = fsm.m_lpBuffer;
            dwLength = fsm.m_dwBufferLength;
            dwBytes = dwLength;
        }

        fsm.m_lpBuffer = (LPVOID)((LPBYTE)fsm.m_lpBuffer + dwBytes);
        fsm.m_dwBufferLength -= dwBytes;

        error = ICSocket::Send(lpBuffer, dwLength, fsm.m_dwFlags);
        if (error != ERROR_SUCCESS) {
            break;
        }
    }

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();

        //
        // Free Encryption Buffer if doing SSL/PCT
        //

        if (fsm.m_lpCryptBuffer != NULL ) {
            fsm.m_lpCryptBuffer = (LPVOID)FREE_MEMORY(fsm.m_lpCryptBuffer);
            INET_ASSERT(fsm.m_lpCryptBuffer == NULL);
        }
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSecureSocket::Receive(
    IN OUT LPVOID* lplpBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN OUT LPDWORD lpdwBufferRemaining,
    IN OUT LPDWORD lpdwBytesReceived,
    IN DWORD dwExtraSpace,
    IN DWORD dwFlags,
    OUT LPBOOL lpbEof
    )

/*++

Routine Description:

    Receives and decrypts data from a secure connection

Arguments:

    lplpBuffer          - see ICSocket::Receive
    lpdwBufferLength    -
    lpdwBufferRemaining -
    lpdwBytesReceived   -
    dwExtraSpace        -
    dwFlags             -
    lpbEof              -

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    INET_ASSERT(lplpBuffer != NULL);
    INET_ASSERT(lpdwBufferLength != NULL);
    INET_ASSERT((*lpdwBufferLength == 0) ? (dwFlags & SF_EXPAND) : TRUE);

    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::Receive",
                 "%#x [%#x], %#x [%d], %#x [%d], %#x [%d], %d, %#x, %#x [%B]",
                 lplpBuffer,
                 *lplpBuffer,
                 lpdwBufferLength,
                 *lpdwBufferLength,
                 lpdwBufferRemaining,
                 *lpdwBufferRemaining,
                 lpdwBytesReceived,
                 *lpdwBytesReceived,
                 dwExtraSpace,
                 dwFlags,
                 lpbEof,
                 *lpbEof
                 ));

    DWORD error;

    // Thunk to non-secure if establishing via a CONNECT
    if (IsSecure())
    {
        error = DoFsm(New CFsm_SecureReceive(lplpBuffer,
                                             lpdwBufferLength,
                                             lpdwBufferRemaining,
                                             lpdwBytesReceived,
                                             dwExtraSpace,
                                             dwFlags,
                                             lpbEof,
                                             this
                                             ));
    }
    else
    {
        error = ICSocket::Receive(lplpBuffer,
                                  lpdwBufferLength,
                                  lpdwBufferRemaining,
                                  lpdwBytesReceived,
                                  dwExtraSpace,
                                  dwFlags,
                                  lpbEof
                                  );
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_SecureReceive::RunSM(
    IN CFsm * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CFsm_SecureReceive::RunSM",
                 "%#x",
                 Fsm
                 ));

    ICSecureSocket * pSecureSocket = (ICSecureSocket *)Fsm->GetContext();
    CFsm_SecureReceive * stateMachine = (CFsm_SecureReceive *)Fsm;
    DWORD error;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = pSecureSocket->Receive_Fsm(stateMachine);
        break;

    default:
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_WINHTTP_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSecureSocket::Receive_Fsm(
    IN CFsm_SecureReceive * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::Receive_Fsm",
                 "%#x",
                 Fsm
                 ));

    //INET_ASSERT(m_dwFlags & SF_DECRYPT);

    CFsm_SecureReceive & fsm = *Fsm;
    DWORD error = fsm.GetError();
    LPVOID * lplpBuffer;
    LPDWORD lpdwBufferLength;
    LPDWORD lpdwBufferLeft;
    LPDWORD lpdwBytesReceived;

    if (fsm.GetState() != FSM_STATE_INIT) {
        switch (fsm.GetFunctionState()) {
        case FSM_STATE_2:
            goto negotiate_continue;

        case FSM_STATE_3:
            goto receive_continue;

        default:
            error = ERROR_WINHTTP_INTERNAL_ERROR;

            INET_ASSERT(FALSE);

            goto quit;
        }
    }

    //
    // if we weren't given a buffer, but the caller told us its okay to resize
    // then we allocate the initial buffer
    //

    if ((fsm.m_dwBufferLength == 0) || (fsm.m_dwBufferLeft == 0)) {

        INET_ASSERT((fsm.m_dwBufferLength == 0) ? (fsm.m_dwBufferLeft == 0) : TRUE);

        if (fsm.m_dwFlags & SF_EXPAND) {

            //
            // allocate a fixed memory buffer
            //

            //
            // BUGBUG - the initial buffer 