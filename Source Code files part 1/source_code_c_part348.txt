Count++ );

            Status = kmxlRegOpenKey(
                hAllControlsKey,
                sz,
                &hControlKey
                );
            if( !NT_SUCCESS( Status ) ) {
                break;
            } // if

            Status = kmxlRegQueryValue(
                hControlKey,
                CHANNEL_COUNT_VALUE_NAME,
                &NumChannels,
                sizeof( NumChannels ),
                &ResultLength
                );
            if( !NT_SUCCESS( Status ) ) {
                if( pControl->Control.cMultipleItems == 0 ) {
                    //
                    // Controls that have multiple items (such as MUXes)
                    // don't have channel counts.  If this control does
                    // not have multiple items, then there is a problem
                    // in the registry.
                    //
                    kmxlRegCloseKey( hControlKey );
                    pControl = kmxlNextControl( pControl );
                    continue;
                }
            } // if

            if( ( NumChannels != pControl->NumChannels ) &&
                ( pControl->Control.cMultipleItems == 0 ) ) {
                DPF(DL_TRACE|FA_PERSIST,( "the number of channels for control %d on line %x is invalid.",
                    pControl->Control.dwControlID,
                    pLine->Line.dwLineID
                    ) );
                bInvalidTopology = TRUE;
                goto exit;
            }

            Status = kmxlRegQueryValue(
                hControlKey,
                CONTROL_TYPE_VALUE_NAME,
                &Value,
                sizeof( Value ),
                &ResultLength
                );
            if( !NT_SUCCESS( Status ) ) {
                kmxlRegCloseKey( hControlKey );
                pControl = kmxlNextControl( pControl );
                continue;
            } // if

            if( Value != pControl->Control.dwControlType ) {
                kmxlRegCloseKey( hControlKey );
                pControl = kmxlNextControl( pControl );
                continue;
            } // if

            Status = kmxlRegQueryValue(
                hControlKey,
                CONTROL_MULTIPLEITEMS_VALUE_NAME,
                &Value,
                sizeof( Value ),
                &ResultLength
                );
            if( !NT_SUCCESS( Status ) ) {
                bInvalidTopology = TRUE;
                DPF(DL_TRACE|FA_PERSIST, ( "cMultipleItems value not found!" ) );
                goto exit;
            }

            if( Value != pControl->Control.cMultipleItems ) {
                bInvalidTopology = TRUE;
                DPF(DL_TRACE|FA_PERSIST, ( "cMultipleItems does not match for control %x!",
                    pControl->Control.dwControlID
                    ) );
                goto exit;
            }

            //
            // Allocate memory for the data structures and
            // set the value.
            //

            if( pControl->Control.dwControlType == MIXERCONTROL_CONTROLTYPE_MUX ) {

                if( !NT_SUCCESS( AudioAllocateMemory_Paged(pControl->Control.cMultipleItems *
                                                              sizeof( MIXERCONTROLDETAILS_UNSIGNED ),
                                                           TAG_Audd_DETAILS,
                                                           ZERO_FILL_MEMORY,
                                                           &paDetails ) ) )
                {
                    kmxlRegCloseKey( hControlKey );
                    pControl = kmxlNextControl( pControl );
                    continue;
                }

                for( Value = 0; Value < pControl->Control.cMultipleItems; Value++ ) {
                    swprintf( sz, MULTIPLEITEM_VALUE_NAME_FORMAT, Value );

                    Status = kmxlRegQueryValue(
                        hControlKey,
                        sz,
                        &paDetails[ Value ].dwValue,
                        sizeof( paDetails[ Value ].dwValue ),
                        &ResultLength
                        );
                    if( !NT_SUCCESS( Status ) ) {
                        break;
                    }
                }


            } else {

                if( !NT_SUCCESS( AudioAllocateMemory_Paged(NumChannels * sizeof( MIXERCONTROLDETAILS_UNSIGNED ),
                                                           TAG_Audd_DETAILS,
                                                           ZERO_FILL_MEMORY,
                                                           &paDetails ) ) )
                {
                    kmxlRegCloseKey( hControlKey );
                    pControl = kmxlNextControl( pControl );
                    continue;
                } // if

                for( Value = 0; Value < NumChannels; Value++ ) {

                    //  check to see if the persisted values are valid for all channels
                    if ( ( pControl->Control.dwControlType == MIXERCONTROL_CONTROLTYPE_MUTE ) &&
                         ( bValidMultichannel == FALSE ) )
                    {
                        swprintf( sz, CHANNEL_VALUE_NAME_FORMAT, 0 );  // Lock the persistance key to the first channel.
                                                                       // This is the only channel that we know is valid
                                                                       // at this time.
                    }
                    else
                    {
                        swprintf( sz, CHANNEL_VALUE_NAME_FORMAT, Value );
                    }

                    Status = kmxlRegQueryValue(
                        hControlKey,
                        sz,
                        &paDetails[ Value ].dwValue,
                        sizeof( paDetails[ Value ].dwValue ),
                        &ResultLength
                        );
                    if( !NT_SUCCESS( Status ) ) {
                        break;
                    } // if

                } // for( Value );
            }

            if( NT_SUCCESS( Status ) ) {
            
                //
                // This correction code should be here along with in the control
                // creation code.  Basically, if we're reading something from the 
                // registry that doesn't conform, we fix it up, but, chances are
                // it should be in the correct form.
                //
                if (pControl->pChannelStepping) {

                    pChannelStepping = pControl->pChannelStepping;
                    for (j = 0; j < pControl->NumChannels; j++, pChannelStepping++) {
                        /*
                        ASSERT ( pChannelStepping->MinValue >= -150*65536 && pChannelStepping->MinValue <= 150*65536 );
                        ASSERT ( pChannelStepping->MaxValue >= -150*65536 && pChannelStepping->MaxValue <= 150*65536 );
                        ASSERT ( pChannelStepping->Steps >= 0 && pChannelStepping->Steps <= 65535 );
                        */

                        if (!(pChannelStepping->MinValue >= -150*65536 && pChannelStepping->MinValue <= 150*65536)) {
                            DPF(DL_WARNING|FA_PERSIST,
                                ("MinValue %X of Control %X of type %X on Line %X Channel %X is out of range!",
                                pChannelStepping->MinValue,
                                pControl->Control.dwControlID,
                                pControl->Control.dwControlType,
                                pLine->Line.dwLineID,
                                j) );
                            pChannelStepping->MinValue = DEFAULT_RANGE_MIN;
                        }
                        if (!(pChannelStepping->MaxValue >= -150*65536 && pChannelStepping->MaxValue <= 150*65536)) {
                            DPF(DL_WARNING|FA_PERSIST,
                                ("MaxValue %X of Control %X of type %X on Line %X Channel %X is out of range!",
                                pChannelStepping->MaxValue,
                                pControl->Control.dwControlID,
                                pControl->Control.dwControlType,
                                pLine->Line.dwLineID,
                                j) );
                            pChannelStepping->MaxValue = DEFAULT_RANGE_MAX;
                        }
                        if (!(pChannelStepping->Steps >= 0 && pChannelStepping->Steps <= 65535)) {
                            DPF(DL_TRACE|FA_PERSIST,
                                ("Steps %X of Control %X of type %X on Line %X Channel %X is out of range!",
                                pChannelStepping->Steps,
                                pControl->Control.dwControlID,
                                pControl->Control.dwControlType,
                                pLine->Line.dwLineID,
                                j) );
                            pChannelStepping->Steps    = DEFAULT_RANGE_STEPS;
                            pControl->Control.Metrics.cSteps = DEFAULT_RANGE_STEPS;
                        }
                    }
                }

                kmxlSetCurrentControlValue(
                    pfo,
                    pmxd,
                    pLine,
                    pControl,
                    paDetails
                );

            }

            AudioFreeMemory_Unknown( &paDetails );
            kmxlRegCloseKey( hControlKey );
            pControl = kmxlNextControl( pControl );
        } // while( pControl );


        kmxlRegCloseKey( hAllControlsKey );
        kmxlRegCloseKey( hLineKey );

    } // for( i );

exit:

    if( hLineKey ) {
        kmxlRegCloseKey( hLineKey );
    }

    if( hMixerKey ) {
        kmxlRegCloseKey( hMixerKey );
    }

    if( bInvalidTopology ) {
        DPF(DL_TRACE|FA_PERSIST,( "Invalid topology persisted or key not found.  Rebuilding." ) );
        Status = kmxlRegOpenMixerKey( pfo, pmxd, &hMixerKey );
        if( NT_SUCCESS( Status ) ) {
            ZwDeleteKey( hMixerKey );
        }

        return( kmxlPersistAll( pfo, pmxd ) );
    }

    return( STATUS_SUCCESS );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlFindLineForControl
//
//

PMXLLINE
kmxlFindLineForControl(
    IN PMXLCONTROL pControl,
    IN LINELIST    listLines
)
{
    PMXLLINE    pLine;
    PMXLCONTROL pTControl;

    PAGED_CODE();
    if( pControl == NULL ) {
        return( NULL );
    }

    if( listLines == NULL ) {
        return( NULL );
    }

    pLine = kmxlFirstInList( listLines );
    while( pLine ) {

        pTControl = kmxlFirstInList( pLine->Controls );
        while( pTControl ) {
            if( pTControl == pControl ) {
                return( pLine );
            }

            pTControl = kmxlNextControl( pTControl );
        }
        pLine = kmxlNextLine( pLine );
    }

    return( NULL );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlPersistSingleControl
//
//

NTSTATUS
kmxlPersistSingleControl(
    IN PFILE_OBJECT pfo,        // The instance to retrieve
    IN PMIXERDEVICE pmxd,       // Mixer device info
    IN PMXLCONTROL  pControl,   // The control to persist
    IN PVOID        paDetails   // The channel values to persist
)
{
    NTSTATUS    Status;
    HANDLE      hMixerKey = NULL,
                hLineKey = NULL,
                hAllControlsKey = NULL,
                hControlKey = NULL;
    PMXLLINE    pTLine, pLine;
    PMXLCONTROL pTControl;
    ULONG       LineNum, ControlNum, i, Channels;
    WCHAR       sz[ 16 ];
    BOOL        bPersistAll = FALSE;
    BOOL        bValidMultichannel = FALSE;
    ULONG       ResultLength;

    PAGED_CODE();
    Status = kmxlRegOpenMixerKey( pfo, pmxd, &hMixerKey );
    if( !NT_SUCCESS( Status ) ) {
        return( kmxlPersistAll( pfo, pmxd ) );
    }

    //
    //  If we've never written out valid multichannel mixer settings, go ahead and
    //  do it here.
    //
    Status = kmxlRegQueryValue(
        hMixerKey,
        VALID_MULTICHANNEL_MIXER_VALUE_NAME,
        &bValidMultichannel,
        sizeof( bValidMultichannel ),
        &ResultLength
        );
    if( !NT_SUCCESS( Status ) || !(bValidMultichannel) ) {
        return( kmxlPersistAll( pfo, pmxd ) );
    }

    pLine = kmxlFindLineForControl( pControl, pmxd->listLines );
    if( pLine == NULL ) {
        Status = STATUS_INVALID_PARAMETER;
        DPF(DL_WARNING|FA_PERSIST,("KmxlFindLineForControl failed Status=%X",Status) );
        goto exit;
    }

    LineNum = 0;
    pTLine = kmxlFirstInList( pmxd->listLines );
    while( pTLine ) {

        if( pTLine == pLine ) {

            swprintf( sz, LINE_KEY_NAME_FORMAT, LineNum );
            Status = kmxlRegOpenKey( hMixerKey, sz, &hLineKey );
            if( !NT_SUCCESS( Status ) ) {
                bPersistAll = TRUE;
                goto exit;
            }

            Status = kmxlRegOpenKey( hLineKey, CONTROLS_KEY_NAME, &hAllControlsKey );
            if( !NT_SUCCESS( Status ) ) {
                bPersistAll = TRUE;
                goto exit;
            }

            ControlNum = 0;
            pTControl = kmxlFirstInList( pTLine->Controls );
            while( pTControl ) {

                if( pTControl == pControl ) {

                    swprintf( sz, CONTROL_KEY_NAME_FORMAT, ControlNum );
                    Status = kmxlRegOpenKey( hAllControlsKey, sz, &hControlKey );
                    if( !NT_SUCCESS( Status ) ) {
                        bPersistAll = TRUE;
                        goto exit;
                    }

                    kmxlRegSetValue(
                        hControlKey,
                        CONTROL_TYPE_VALUE_NAME,
                        REG_DWORD,
                        &pControl->Control.dwControlType,
                        sizeof( pControl->Control.dwControlType )
                        );

                    Status = kmxlGetCurrentControlValue(
                        pfo,
                        pmxd,
                        pLine,
                        pControl,
                        &paDetails
                        );

                    if( NT_SUCCESS( Status ) ) {

                        if( pControl->Control.dwControlType == MIXERCONTROL_CONTROLTYPE_MUX ) {
                            for( i = 0; i < pControl->Control.cMultipleItems; i++ ) {

                                swprintf( sz, MULTIPLEITEM_VALUE_NAME_FORMAT, i );

                                Status = kmxlRegSetValue(
                                    hControlKey,
                                    sz,
                                    REG_DWORD,
                                    &((PMIXERCONTROLDETAILS_UNSIGNED) paDetails)[ i ],
                                    sizeof( ((PMIXERCONTROLDETAILS_UNSIGNED) paDetails)[ i ] )
                                    );

                            }

                        } else {

                            Channels = pControl->NumChannels;

                            kmxlRegSetValue(
                                hControlKey,
                                CHANNEL_COUNT_VALUE_NAME,
                                REG_DWORD,
                                &Channels,
                                sizeof( Channels )
                                );

                            for( i = 0; i < Channels; i++ ) {
                                swprintf( sz, CHANNEL_VALUE_NAME_FORMAT, i );

                                Status = kmxlRegSetValue(
                                    hControlKey,
                                    sz,
                                    REG_DWORD,
                                    &((PMIXERCONTROLDETAILS_UNSIGNED) paDetails)[ i ],
                                    sizeof( ((PMIXERCONTROLDETAILS_UNSIGNED) paDetails)[ i ] )
                                    );
                            }
                        }
                        AudioFreeMemory_Unknown( &paDetails );
                    }
                    goto exit;

                } else {
                    pTControl = kmxlNextControl( pTControl );
                    ++ControlNum;
                }
            }

            Status = STATUS_SUCCESS;
            goto exit;

        } else {
            pTLine = kmxlNextLine( pTLine );
            ++LineNum;
        }

    }

    Status = STATUS_OBJECT_NAME_NOT_FOUND;
    DPF(DL_WARNING|FA_PERSIST,("kmxlPersistSingleControl failing Status=%X",Status) );

exit:

    if( hMixerKey ) {
        kmxlRegCloseKey( hMixerKey );
    }

    if( hLineKey ) {
        kmxlRegCloseKey( hLineKey );
    }

    if( hAllControlsKey ) {
        kmxlRegCloseKey( hAllControlsKey );
    }

    if( hControlKey ) {
        kmxlRegCloseKey( hControlKey );
    }

    if( bPersistAll ) {
        return( kmxlPersistAll( pfo, pmxd ) );
    }

    RETURN( Status );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlPersistControl
//
//

NTSTATUS
kmxlPersistControl(
    IN PFILE_OBJECT pfo,        // The instance to retrieve
    IN PMIXERDEVICE pmxd,       // Mixer device info
    IN PMXLCONTROL  pControl,   // The control to persist
    IN PVOID        paDetails   // The channel values to persist
)
{
    PMXLLINE    pLine;
    PMXLCONTROL pCtrl;
    NTSTATUS    Status;
    NTSTATUS    OverallStatus;


    PAGED_CODE();
    OverallStatus=STATUS_SUCCESS;

    //
    // Persist the control that just changed.  Do not abort if this persist fails.
    //

    Status = kmxlPersistSingleControl( pfo, pmxd, pControl, paDetails );
    if( !NT_SUCCESS( Status ) ) {
        OverallStatus=Status;
        }

    //
    // Check all other controls and see if another control shares the same
    // node ID.  If so, persist that control with the new value also.
    // Again, do not abort if any of the persists fail.  Simply return the last
    // error status.
    //

    pLine = kmxlFirstInList( pmxd->listLines );
    while( pLine ) {

        pCtrl = kmxlFirstInList( pLine->Controls );
        while( pCtrl ) {

            if( pCtrl->Id==pControl->Id && pCtrl!=pControl ) {
                Status = kmxlPersistSingleControl( pfo, pmxd, pCtrl, paDetails );
                if( !NT_SUCCESS( Status ) ) {
                    OverallStatus=Status;
                }
            }

            pCtrl = kmxlNextControl( pCtrl );
        }

        pLine = kmxlNextLine( pLine );

    }

    RETURN( OverallStatus );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\legacy\wdmaud.sys\robust.h ===
//
// These are bit value flags
//
typedef enum AudioAllocateMemoryFlags {
    DEFAULT_MEMORY   = 0x00, // Standard ExAllocatePool call
    ZERO_FILL_MEMORY = 0x01, // Zero the memory
    QUOTA_MEMORY     = 0x02, // ExAllocatePoolWithQuota call
    LIMIT_MEMORY     = 0x04, // Never allocation more then 1/4 Meg
    FIXED_MEMORY     = 0x08, // Use locked memory
    PAGED_MEMORY     = 0x10  // use pageable memory
} AAMFLAGS;

/*
#define DEFAULT_MEMORY    0x00 // Standard ExAllocatePool call
#define ZERO_FILL_MEMORY  0x01 // Zero the memory
#define QUOTA_MEMORY      0x02 // ExAllocatePoolWithQuota call
#define LIMIT_MEMORY      0x04 // Never allocation more then 1/4 Meg
#define FIXED_MEMORY      0x08 // Use locked memory
#define PAGED_MEMORY      0x10 // use pageable memory
*/

#define AudioAllocateMemory_Fixed(b,t,f,p) AudioAllocateMemory(b,t,f|FIXED_MEMORY,p)
#define AudioAllocateMemory_Paged(b,t,f,p) AudioAllocateMemory(b,t,f|PAGED_MEMORY,p)

NTSTATUS
AudioAllocateMemory(
    IN SIZE_T   bytes,
    IN ULONG    tag,
    IN AAMFLAGS dwFlags,
    OUT PVOID  *pptr
    );

#define UNKNOWN_SIZE MAXULONG_PTR

#define AudioFreeMemory_Unknown(pMem) AudioFreeMemory(UNKNOWN_SIZE, pMem)

void
AudioFreeMemory(
    IN SIZE_T bytes,
    OUT PVOID *pptr
    );




//
// Validation routines
//
#define AUDIO_BUGCHECK_CODE 0x000000AD

#define AUDIO_NOT_AT_PASSIVE_LEVEL     0x00000000
#define AUDIO_NOT_BELOW_DISPATCH_LEVEL 0x00000001
#define AUDIO_INVALID_IRQL_LEVEL       0x00000002

//
// BugCheck AD
// Param1:     AUDIO_STRUCTURE_VALIDATION
// Param2:     ptr
// Param3:     ntstatus code
//
#define AUDIO_STRUCTURE_VALIDATION     0x00000003

//
// BugCheck AD
// Param1:     AUDIO_MEMORY_ALLOCATION_OVERWRITE
// Param2:     ptr
//
#define AUDIO_MEMORY_ALLOCATION_OVERWRITE 0x00000004

//
// BugCheck AD
// Param1:     AUDIO_NESTED_MUTEX_SITUATION
// Param2:     pkmutex
// Param3:     lMutexState
//
#define AUDIO_NESTED_MUTEX_SITUATION 0x00000005
     
//
// BugCheck AD
// Param1:     AUDIO_ABSURD_ALLOCATION_ATTEMPTED
// Param2:     
// Param3:     
//
#define AUDIO_ABSURD_ALLOCATION_ATTEMPTED 0x00000006
     
//
// Used to smoke out pre-emption issues on the checked build.
//
NTSYSAPI NTSTATUS NTAPI ZwYieldExecution (VOID);

void
PagedCode(
    void
    );

#define PagedData PagedCode

void
ValidatePassiveLevel(
    void
    );

void
AudioPerformYield(
    void
    );

#define AudioEnterMutex_Exclusive(pmutex) AudioEnterMutex(pmutex,TRUE)
#define AudioEnterMutex_Nestable(pmutex)  AudioEnterMutex(pmutex,FALSE)

NTSTATUS
AudioEnterMutex(
    IN PKMUTEX pmutex,
    IN BOOL    bExclusive
    );

void
AudioLeaveMutex(
    IN PKMUTEX pmutex
    );

void
AudioObDereferenceObject(
    IN PVOID pvObject
    );

void
AudioIoCompleteRequest(
    IN PIRP  pIrp, 
    IN CCHAR PriorityBoost
    );


#if 0
void
AudioEnterSpinLock(
    IN  PKSPIN_LOCK pSpinLock,
    OUT PKIRQL      pOldIrql
    );

void
AudioLeaveSpinLock(
    IN PKSPIN_LOCK pSpinLock,
    IN KIRQL       OldIrql
    );

NTSTATUS
AudioIoCallDriver ( 
    IN PDEVICE_OBJECT pDevice,
    IN PIRP pIrp
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\legacy\wdmaud.sys\robust.c ===
#include "wdmsys.h"

#pragma LOCKED_CODE
#pragma LOCKED_DATA


//
// Robust checking enables bugchecks in the retail version of this component.
//
BOOL gbRobustChecking = FALSE;

#if 0
//
// PagedCode:  This routine should be used in routines that touch pageable
// code and data.  Notice that this is not the PAGED_CODE() macro so that it
// will be in the retail code.
//
void
PagedCode(
    void
    )
{
    if( KeGetCurrentIrql() > APC_LEVEL )
    {
        KeBugCheckEx(AUDIO_BUGCHECK_CODE,AUDIO_NOT_BELOW_DISPATCH_LEVEL,0,0,0);
    }
}

void
ValidatePassiveLevel(
    void
    )
{
    if( KeGetCurrentIrql() != PASSIVE_LEVEL )
    {
        KeBugCheckEx(AUDIO_BUGCHECK_CODE,AUDIO_NOT_AT_PASSIVE_LEVEL,0,0,0);
    }
}

//
// If bExclusive is TRUE, the caller wants to know if the mutex is acquired multiple
// times on the same thread.  If they don't want this checking done, they should 
// set bExclusive to FALSE.
//
NTSTATUS
AudioEnterMutex(
    IN PKMUTEX pmutex,
    IN BOOL    bExclusive
    )
{
    PRKTHREAD pkt;
    NTSTATUS  Status;
    LONG      lMutexState;

    Status = KeWaitForSingleObject ( pmutex,Executive,KernelMode,FALSE,NULL ) ;
    if( gbRobustChecking && bExclusive )
    {
        //
        // After entering the mutex, we sanity check our nested count, but we
        // only do this if we need to.  If the caller said that they designed the
        // code only for exclusive access, we'll bugcheck if we get nested.
        // 
        if( (lMutexState = KeReadStateMutex(pmutex)) < 0 )
        {
            //
            // Every time you acquire a mutex the state will be decremented.  1 means
            // that it's available, 0 means it's held, -1 means this is the second time
            // it's acquired, -2 means it's the third and so on.  Thus, if we're nested
            // on this thread, we'll end up here.
            //
            KeBugCheckEx(AUDIO_BUGCHECK_CODE,
                         AUDIO_NESTED_MUTEX_SITUATION,
                         (ULONG_PTR)pmutex,
                         lMutexState,
                         0);
        }
    }
    return Status;
}

//
// This routine yields if we're at PASSIVE_LEVEL
//
void
AudioPerformYield(
    void
    )
{
    PRKTHREAD pthrd;
    KPRIORITY kpriority;

    //
    // After releasing the mutex we want to yield execution to all other threads
    // on the machine to try to expose preemption windows.
    //
    if( ( gbRobustChecking ) && 
        ( KeGetCurrentIrql() == PASSIVE_LEVEL ) )
    {
        if( (pthrd = KeGetCurrentThread()) )
        {
            kpriority = KeQueryPriorityThread(KeGetCurrentThread());
            //
            // Lower this thrread's priority so another thread will
            // get scheduled.
            //
            KeSetPriorityThread(pthrd,1); // Is that low enough?

            //
            // This might be overkill, but yield.
            //
            ZwYieldExecution();

            //
            // Now restore the priority for this thread and party on.
            //
            KeSetPriorityThread(pthrd,kpriority);
        }

    }
}

void
AudioLeaveMutex(
    IN PKMUTEX pmutex
    )
{
    PRKTHREAD pthrd;
    KPRIORITY kpriority;

    KeReleaseMutex ( pmutex, FALSE ) ;

    AudioPerformYield();
}

NTSTATUS
AudioIoCallDriver (
    IN PDEVICE_OBJECT pDevice,
    IN PIRP           pIrp 
    )
{
    NTSTATUS Status;

    Status = IoCallDriver(pDevice,pIrp);

    AudioPerformYield();

    return Status;
}


void
AudioEnterSpinLock(
    IN  PKSPIN_LOCK pSpinLock,
    OUT PKIRQL      pOldIrql
    )
{
    //
    // KeAcquireSpinLock can only be called less then or equal to dispatch level.
    // let's verify that here.
    //
    if( ( gbRobustChecking ) &&    
        ( KeGetCurrentIrql() > DISPATCH_LEVEL ) )
    {
        KeBugCheckEx(AUDIO_BUGCHECK_CODE,
                     AUDIO_INVALID_IRQL_LEVEL,
                     0,
                     0,
                     0);
    }

    KeAcquireSpinLock ( pSpinLock, pOldIrql ) ;
}

void
AudioLeaveSpinLock(
    IN PKSPIN_LOCK pSpinLock,
    IN KIRQL       OldIrql
    )
{
    KeReleaseSpinLock ( pSpinLock, OldIrql ) ;
    AudioPerformYield();
}


void
AudioObDereferenceObject(
    IN PVOID pvObject
    )
{
    ObDereferenceObject(pvObject);
    AudioPerformYield();
}

void
AudioIoCompleteRequest(
    IN PIRP  pIrp, 
    IN CCHAR PriorityBoost
    )
{
    IoCompleteRequest(pIrp,PriorityBoost);

    AudioPerformYield();
}
#endif

#define MEMORY_LIMIT_CHECK 262144

//
// This routine assumes that pptr points to a memory location that currently
// contains a NULL value.  Thus, on failure, this routine does not have to
// write back a NULL value.
//
// Entry:
// if dwFlags contains:
//#define DEFAULT_MEMORY    0x00 // Standard ExAllocatePool call
//#define ZERO_FILL_MEMORY  0x01 // Zero the memory
//#define QUOTA_MEMORY      0x02 // ExAllocatePoolWithQuota call
//#define LIMIT_MEMORY      0x04 // Never allocation more then 1/4 Meg
//#define FIXED_MEMORY      0x08 // Use locked memory
//#define PAGED_MEMORY      0x10 // use pageable memory
//
NTSTATUS
AudioAllocateMemory(
    IN SIZE_T    bytes,
    IN ULONG     tag,
    IN AAMFLAGS  dwFlags,
    OUT PVOID   *pptr
    )
{
    NTSTATUS Status;
    POOL_TYPE pooltype;
    PVOID pInit;
    KIRQL irql;
    PVOID ptr = NULL;

    ASSERT(*pptr == NULL);

    if( 0 == bytes )
    {
        //
        // The code should never be asking for zero bytes.  The core will bugcheck
        // on a call like this.  In debug mode we'll assert.  In retail, we'll
        // return an error.
        //
        ASSERT(0);
        Status = STATUS_INSUFFICIENT_RESOURCES;
    } else {

        if( dwFlags & FIXED_MEMORY )
            pooltype = NonPagedPool;
        else
            pooltype = PagedPool;

        //
        // Allocating pageable memory at DISPATCH_LEVEL is a bad thing to do.
        // here we make sure that is not the case.
        //
        if( ( (irql = KeGetCurrentIrql()) > DISPATCH_LEVEL ) || 
            ((DISPATCH_LEVEL == irql ) && (NonPagedPool != pooltype)) )
        {
            //
            // Either way, we've got an error, bugcheck or exit.
            //
            if( gbRobustChecking )
            {
                KeBugCheckEx(AUDIO_BUGCHECK_CODE,AUDIO_INVALID_IRQL_LEVEL,0,0,0);
            } else {
                //
                // If we can't bugcheck, then we're going to return an error
                // in this case.
                //
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto exit;
            }
        }
        //
        // Let's see if the caller has asked to limit the allocation to a "reasonable" 
        // number of bytes.  If so, "reasonable" is 1/4 meg.
        //
        if( ( dwFlags & LIMIT_MEMORY ) && ( bytes > MEMORY_LIMIT_CHECK ) )
        {
            //
            // For some reason, this allocation is trying to allocate more then was designed.
            // Why is the caller allocating so much?
            //
            if( gbRobustChecking )
                KeBugCheckEx(AUDIO_BUGCHECK_CODE,AUDIO_ABSURD_ALLOCATION_ATTEMPTED,0,0,0);

            //
            // Checked build will assert if robust checking is not enabled.
            //
            ASSERT("Memory Allocation Unreasonable!");
        }

        //
        // Allocate the memory, NULL is returned on failure in the normal case, an exception
        // is raised with quota.  ptr is NULLed out above for the Quota routine.
        //
        if( dwFlags & QUOTA_MEMORY )
        {
            //
            // Caller wants to charge the allocation to the current user context.
            //
            try
            {

                ptr = ExAllocatePoolWithQuotaTag(pooltype,bytes,tag);

            }except (EXCEPTION_EXECUTE_HANDLER) {

                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        } else {
            //
            // Don't want to assign this memory to the quota.
            //
            ptr = ExAllocatePoolWithTag(pooltype, bytes, tag);
        }

        if( ptr )
        {
            if( dwFlags & ZERO_FILL_MEMORY )
            {
                RtlFillMemory( ptr,bytes,0 );
            }
            //
            // Never allocate over the top of an existing pointer.  Interlock exchange
            // with the location.  This interlock updates the location in the caller.
            //
            if( pInit = InterlockedExchangePointer(pptr,ptr) )
            {
                //
                // If we get a return value from this exchange it means that there
                // was already a pointer in the location that we added a pointer too.
                // If this is the case, most likely we overwrote a valid memory 
                // pointer.  With robust checking we don't want this to happen.
                //
                if( gbRobustChecking )
                {
                    KeBugCheckEx(AUDIO_BUGCHECK_CODE,
                                 AUDIO_MEMORY_ALLOCATION_OVERWRITE,
                                 (ULONG_PTR)pInit,
                                 0,0);
                }
                //
                // If we end up here, we've overwritten a memory pointer with a 
                // successful memory allocation.  Or ASSERT at the top of this
                // function should have fired.  In any case, we can return success
                // and how that nothing bad happens.
                //
            }
            Status = STATUS_SUCCESS;
        } else {
            //
            // Our memory allocation failed.  *pptr should still be NULL
            // return error.
            //
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
exit:
    return Status;
}

//
// This routine is safe to call with a NULL memory pointer.  It will return
// STATUS_UNSUCCESSFUL and do nothing if passed a NULL pointer.  Also, this routine
// reads the location atomically so it should be safe in a multiproc environment.
//
void
AudioFreeMemory(
    IN SIZE_T  bytes,
    IN OUT PVOID *pptr
    )
{
    PVOID    pFree;
    KIRQL    irql;

    //
    // Interlockedexhchange the pointer will NULL, validate that it's non-NULL
    // trash the memory if needed and then free the pointer.
    //
    pFree = InterlockedExchangePointer(pptr,NULL);
    if( pFree )
    {
        //
        // We have a pointer to free.
        //
        if( gbRobustChecking )
        {
            //
            // The docs say that we need to be careful how we call the free routine
            // with regard to IRQlevel.  Thus, if we're being robust we'll do this
            // extra work.
            //
            if( (irql = KeGetCurrentIrql()) > DISPATCH_LEVEL )
            {
                KeBugCheckEx(AUDIO_BUGCHECK_CODE,AUDIO_INVALID_IRQL_LEVEL,0,0,0);
            }

            //
            // Under debug we're going to put 'k's in the memory location in order
            // to make extra sure that no one is using this memory.
            //
            if( UNKNOWN_SIZE != bytes )
            {
                RtlFillMemory( pFree,bytes,'k' );
            }
        }

        //
        // Now we actually free the memory.
        //
        ExFreePool(pFree);

    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\sysaudio\cinstanc.h ===
//---------------------------------------------------------------------------
//
//  Module:   		ins.h
//
//  Description:	KS Instance base class definition
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Globals
//---------------------------------------------------------------------------

extern "C" const KSDISPATCH_TABLE DispatchTable;

//---------------------------------------------------------------------------
// Classes
//---------------------------------------------------------------------------

typedef class CInstance
{
    friend class ListDoubleField<CInstance>;
public:
    CInstance(
        IN PPARENT_INSTANCE pParentInstance
    );

    ~CInstance(
    );

    static NTSTATUS
    DispatchClose(
        IN PDEVICE_OBJECT pDeviceObject,
        IN PIRP pIrp
    );

    static NTSTATUS
    DispatchForwardIrp(
        IN PDEVICE_OBJECT pDeviceObject,
        IN PIRP pIrp
    );

    VOID
    Invalidate(
    );

    PFILE_OBJECT 
    GetNextFileObject(
    )
    {
        return(pNextFileObject);
    };

    PPIN_INSTANCE
    GetParentInstance(			// inline body in pins.h
    );

    NTSTATUS
    SetNextFileObject(
        HANDLE handle
    )
    {
        //
        // SECURITY NOTE:
        // This call is OK because the handle comes always from a trusted 
        // source.
        //
        return(ObReferenceObjectByHandle(
          handle,
          GENERIC_READ | GENERIC_WRITE,
          NULL,
          KernelMode,
          (PVOID*)&pNextFileObject,
          NULL));
    };

    NTSTATUS
    DispatchCreate(
        IN PIRP pIrp,
        IN UTIL_PFN pfnDispatchCreate,
        IN OUT PVOID pReference,
        IN ULONG cCreateItems = 0,
        IN PKSOBJECT_CREATE_ITEM pCreateItems = NULL,
        IN const KSDISPATCH_TABLE *pDispatchTable = &DispatchTable
    );

    VOID GrabInstanceMutex()
    {
        ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);
        AssertStatus(
          KeWaitForMutexObject(pMutex, Executive, KernelMode, FALSE, NULL));
    };

    VOID ReleaseInstanceMutex()
    {
        ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);
        KeReleaseMutex(pMutex, FALSE);
    };

private:
    VOID
    AddList(
        CListDouble *pld
    )
    {
        ldiNext.AddList(pld);
    };

    VOID
    RemoveList(
    )
    {
        ldiNext.RemoveList();
    };
    //
    // This pointer to the dispatch table is used in the common
    // dispatch routines  to route the IRP to the appropriate
    // handlers.  This structure is referenced by the device driver
    // with IoGetCurrentIrpStackLocation( pIrp ) -> FsContext
    //
    PVOID pObjectHeader;
    PFILE_OBJECT pParentFileObject;
    PDEVICE_OBJECT pNextDeviceObject;
    PPARENT_INSTANCE pParentInstance;
    PFILE_OBJECT pNextFileObject;
    CLIST_DOUBLE_ITEM ldiNext;
    KMUTEX *pMutex;
public:
    DefineSignature(0x534e4943);			// CINS

} INSTANCE, *PINSTANCE;

//---------------------------------------------------------------------------

typedef ListDoubleField<INSTANCE> LIST_INSTANCE, *PLIST_INSTANCE;

//---------------------------------------------------------------------------

typedef class CParentInstance
{
    friend class CInstance;
public:
    VOID
    Invalidate(
    );

    BOOL
    IsChildInstance(
    )
    {
        return(lstChildInstance.IsLstEmpty());
    };

    LIST_INSTANCE lstChildInstance;
    DefineSignature(0x52415043);			// CPAR

} PARENT_INSTANCE, *PPARENT_INSTANCE;

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\sysaudio\cinstanc.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   ins.cpp
//
//  Description:
//
//	KS Instance base class definitions
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//  To Do:     Date	  Author      Comment
//
//@@END_MSINTERNAL
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

DEFINE_KSDISPATCH_TABLE(
    DispatchTable,
    CInstance::DispatchForwardIrp,		// Ioctl
    DispatchInvalidDeviceRequest,		// Read
    DispatchInvalidDeviceRequest,		// Write
    DispatchInvalidDeviceRequest,		// Flush
    CInstance::DispatchClose,			// Close
    DispatchInvalidDeviceRequest,		// QuerySecurity
    DispatchInvalidDeviceRequest,		// SetSeturity
    DispatchFastIoDeviceControlFailure,		// FastDeviceIoControl
    DispatchFastReadFailure,			// FastRead
    DispatchFastWriteFailure			// FastWrite
);


//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

CInstance::CInstance(
    IN PPARENT_INSTANCE pParentInstance
)
{
    Assert(pParentInstance);
    this->pObjectHeader = NULL;
    this->pParentInstance = pParentInstance;
    AddList(&pParentInstance->lstChildInstance);
}

CInstance::~CInstance(
)
{
    Assert(this);
    RemoveList();

    // IMPORTANT : Caller must acquire gmutex.
    //

    // "RemoveRef" from file object
    if(pNextFileObject != NULL) {
        ObDereferenceObject(pNextFileObject);
        pNextFileObject = NULL;
    }
    if(pObjectHeader != NULL) {
        KsFreeObjectHeader(pObjectHeader);
    }
    // "RemoveRef" from parent file object
    if(pParentFileObject != NULL) {
        ObDereferenceObject(pParentFileObject);
    }
    // Clean up pin mutex
    if(pMutex != NULL) {
        ExFreePool(pMutex);
    }
}

NTSTATUS
CInstance::DispatchCreate(
    IN PIRP pIrp,
    IN UTIL_PFN pfnDispatchCreate,
    IN OUT PVOID pReference,
    IN ULONG cCreateItems,
    IN PKSOBJECT_CREATE_ITEM pCreateItems OPTIONAL,
    IN const KSDISPATCH_TABLE *pDispatchTable OPTIONAL
)
{
    PIO_STACK_LOCATION pIrpStack;
    NTSTATUS Status;

    Assert(this);
    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
    pParentFileObject = pIrpStack->FileObject->RelatedFileObject;
    ObReferenceObject(pParentFileObject);

    pMutex = (KMUTEX *)ExAllocatePoolWithTag(
      NonPagedPool,
      sizeof(KMUTEX),
      POOLTAG_SYSA);
    if(pMutex == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }

    KeInitializeMutex(pMutex, 0);

    Status = KsAllocateObjectHeader(
      &pObjectHeader,
      cCreateItems,
      pCreateItems,
      pIrp,
      pDispatchTable);

    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }
    Status = pfnDispatchCreate(this, pReference);
    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
    pNextDeviceObject = IoGetRelatedDeviceObject(pNextFileObject);

    //
    // ISSUE: 05/10/02 ALPERS
    // Windows does not support dynamically adjusting StackSizes on the fly.
    // The only place we are supposed to change this is in AddDevice.
    // This must be fixed later.
    //
    // 
    // Never make the StackSize smaller. It can cause unexpected problems
    // if there are devices with deeper stacks.
    //
    if (pIrpStack->DeviceObject->StackSize < pNextDeviceObject->StackSize) {
        pIrpStack->DeviceObject->StackSize = pNextDeviceObject->StackSize;
    }
    pIrpStack->FileObject->FsContext = this;
exit:
    return(Status);
}

VOID 
CInstance::Invalidate(
)
{
    Assert(this);

    GrabInstanceMutex();

    DPF1(50, "CInstance::Invalidate %08x", this);

    // "RemoveRef" from file object
    if(pNextFileObject != NULL) {
        ObDereferenceObject(pNextFileObject);
    }
    pNextFileObject = NULL;

    ReleaseInstanceMutex();
}

VOID
CParentInstance::Invalidate(
)
{
    PINSTANCE pInstance;

    Assert(this);
    FOR_EACH_LIST_ITEM_DELETE(&lstChildInstance, pInstance) {
        pInstance->Invalidate();
    } END_EACH_LIST_ITEM
}

NTSTATUS
CInstance::DispatchClose(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
)
{
    PIO_STACK_LOCATION pIrpStack;
    PINSTANCE pInstance;

    //
    // ISSUE: 02/26/02 ALPERS
    // Why do we need the global mutex here. Can't we do it with 
    // instance mutex?
    //

    ::GrabMutex();

    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );
    pInstance = (PINSTANCE)pIrpStack->FileObject->FsContext;
    Assert(pInstance);
    pIrpStack->FileObject->FsContext = NULL;
    delete pInstance;

    ::ReleaseMutex();

    pIrp->IoStatus.Information = 0;
    pIrp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);
    return(STATUS_SUCCESS);
}

#pragma LOCKED_CODE
#pragma LOCKED_DATA

NTSTATUS
CInstance::DispatchForwardIrp(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
)
{
    PIO_STACK_LOCATION pIrpStack;
    PFILE_OBJECT pNextFileObject;
    PINSTANCE pInstance;
    NTSTATUS Status = STATUS_SUCCESS;

#ifdef DEBUG
    DumpIoctl(pIrp, "ForwardIrp", DBG_IOCTL_LOG);
#endif
    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
    pInstance = (PINSTANCE)pIrpStack->FileObject->FsContext;

    // Use gMutex instead of instance mutex. The instance mutex
    // is not used in any of the dispatch handlers, therefore will
    // not synchronize DispatchForwardIrp with other DispatchHandlers in
    // CPinInstance.
    // Grab mutex for a very short time to check the validity of CInstance.
    // If it is valid, IoCallDriver is called. This does not need 
    // synchronization
    //

    ::GrabMutex();
    
    Assert(pInstance);
    pNextFileObject = pInstance->pNextFileObject;

    if(pNextFileObject == NULL) {
        DPF(60, "DispatchIoControl: pNextFileObject == NULL");
        Status = pIrp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
        IoCompleteRequest(pIrp, IO_NO_INCREMENT);
    }

    ::ReleaseMutex();

    //
    // ISSUE: 02/21/02 ALPERS
    // This is totally wrong. How would sysaudio know that the pNextDeviceObject
    // and sysaudio has the same DeviceStack.
    // Sysaudio should allocate a new IRP and send the new IRP down to
    // pNextDeviceObject.
    //
    // This code path is executed for IOCTL_KS_READ_STREAM, 
    // IOCTL_KS_WRITE_STREAM and IOCTL_KS_RESET_STATE requests.
    // 
    // In order to solve the problem mentioned above sysaudio has to 
    // create new irps, pend/queue original irp and complete irps 
    // asynchronously.
    // There is no infrastructure to do it in sysaudio. And this is 
    // not directly related to security.
    //
    if (NT_SUCCESS(Status)) {
        pIrpStack->FileObject = pNextFileObject;
        IoSkipCurrentIrpStackLocation(pIrp);
        AssertFileObject(pIrpStack->FileObject);
        Status = IoCallDriver(pInstance->pNextDeviceObject, pIrp);
    }
    
    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\sysaudio\ci.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   ci.cpp
//
//  Description:
//
//	Connect Info Class
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//  To Do:     Date	  Author      Comment
//
//@@END_MSINTERNAL
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

NTSTATUS
CConnectInfo::Create(
    PCONNECT_NODE pConnectNode,
    PLOGICAL_FILTER_NODE pLogicalFilterNode,
    PCONNECT_INFO pConnectInfoNext,
    PGRAPH_PIN_INFO pGraphPinInfo,
    ULONG ulFlagsCurrent,
    PGRAPH_NODE pGraphNode
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PCONNECT_INFO pConnectInfo;

    Assert(pGraphNode);
    Assert(pConnectNode);

    FOR_EACH_LIST_ITEM(&pGraphNode->lstConnectInfo, pConnectInfo) {

        if(pConnectInfo->pPinInfoSource ==
           pConnectNode->pPinNodeSource->pPinInfo &&
           pConnectInfo->pPinInfoSink ==
           pConnectNode->pPinNodeSink->pPinInfo) {

            if(pConnectInfo->pConnectInfoNext->IsSameGraph(pConnectInfoNext)) {
                pConnectInfo->AddRef();
                ASSERT(NT_SUCCESS(Status));
                goto exit;
            }
        }

    } END_EACH_LIST_ITEM

    pConnectInfo = new CONNECT_INFO(
      pConnectNode,
      pConnectInfoNext,
      pGraphPinInfo,
      pGraphNode);

    if(pConnectInfo == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }
    if(ulFlagsCurrent & LFN_FLAGS_CONNECT_NORMAL_TOPOLOGY) {
        BOOL fReserve = FALSE;

        if(pLogicalFilterNode->GetOrder() <= ORDER_MIXER) {
            pConnectInfo->ulFlags |= CI_FLAGS_LIMIT_FORMAT;
        }
        else {
            pConnectInfo->ulFlags |= CI_FLAGS_CONNECT_TOP_DOWN;
        }
        //
        // Reserve pins for the filters below the mixer or splitter (if one)
        //
        if(ulFlagsCurrent & LFN_FLAGS_CONNECT_CAPTURE) {
            if(pLogicalFilterNode->GetOrder() <= ORDER_SPLITTER) {
                pConnectInfo->ulFlags |= CI_FLAGS_REUSE_FILTER_INSTANCE;
                if(gcSplitters > 0) {
                    fReserve = TRUE;
                }
            }
        }
        if(ulFlagsCurrent & LFN_FLAGS_CONNECT_RENDER) {
            if(pLogicalFilterNode->GetOrder() <= ORDER_MIXER) {
                pConnectInfo->ulFlags |= CI_FLAGS_REUSE_FILTER_INSTANCE;
                if(gcMixers > 0) {
                    fReserve = TRUE;
                }
            }
        }
        if(fReserve) {
            Status = pConnectInfo->ReservePinInstance(pGraphNode);
            if(!NT_SUCCESS(Status)) {
                Trap();
                goto exit;
            }
        }
    }
    DPF2(80, "CConnectInfo::Create %08x GN %08x", pConnectInfo, pGraphNode);
exit:
    pConnectNode->pConnectInfo = pConnectInfo;
    return(Status);
}

CConnectInfo::CConnectInfo(
    PCONNECT_NODE pConnectNode,
    PCONNECT_INFO pConnectInfoNext,
    PGRAPH_PIN_INFO pGraphPinInfo,
    PGRAPH_NODE pGraphNode
)
{
    Assert(pGraphNode);
    Assert(pConnectNode);

    this->pPinInfoSource = pConnectNode->pPinNodeSource->pPinInfo;
    this->pPinInfoSink = pConnectNode->pPinNodeSink->pPinInfo;
    this->pGraphPinInfo = pGraphPinInfo;
    pGraphPinInfo->AddRef();
    this->pConnectInfoNext = pConnectInfoNext;
    pConnectInfoNext->AddRef();
    AddList(&pGraphNode->lstConnectInfo);
    AddRef();
    DPF2(80, "CConnectInfo: %08x GN %08x", this, pGraphNode);
}

CConnectInfo::~CConnectInfo(
)
{
    DPF1(80, "~CConnectInfo: %08x", this);
    Assert(this);
    RemoveList();
    pGraphPinInfo->Destroy();
    pConnectInfoNext->Destroy();
}

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\sysaudio\ci.h ===
//---------------------------------------------------------------------------
//
//  Module:   		ci.h
//
//  Description:	Connect Info Class
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Constants and Macros
//---------------------------------------------------------------------------

#define	CI_FLAGS_CONNECT_TOP_DOWN	0x00000001
#define	CI_FLAGS_LIMIT_FORMAT		0x00000002
#define	CI_FLAGS_REUSE_FILTER_INSTANCE	0x00000004

//---------------------------------------------------------------------------
// Class
//---------------------------------------------------------------------------

typedef class CConnectInfo : public CListDoubleItem
{
    friend class CConnectNode;
private:
    CConnectInfo(
	PCONNECT_NODE pConnectNode,
	PCONNECT_INFO pConnectInfoNext,
	PGRAPH_PIN_INFO pGraphPinInfo,
	PGRAPH_NODE pGraphNode
    );

    ~CConnectInfo(
    );

public:
    static NTSTATUS
    Create(
	PCONNECT_NODE pConnectNode,
	PLOGICAL_FILTER_NODE pLogicalFilterNode,
	PCONNECT_INFO pConnectInfoNext,
	PGRAPH_PIN_INFO pGraphPinInfo,
	ULONG ulFlagsCurrent,
	PGRAPH_NODE pGraphNode
    );

    ENUMFUNC
    Destroy(
    )
    {
	if(this != NULL) {
	    Assert(this);
	    ASSERT(cReference > 0);

	    if(--cReference == 0) {
		delete this;
	    }
	}
	return(STATUS_CONTINUE);
    };

    VOID 
    AddRef(
    )
    {
	if(this != NULL) {
	    Assert(this);
	    ++cReference;
	}
    };

    PKSPIN_CINSTANCES
    GetPinInstances(
    )
    {
	Assert(this);
	return(pGraphPinInfo->GetPinInstances());
    };

    BOOL
    IsPinInstances(
    )
    {
	Assert(this);
	return(pGraphPinInfo->IsPinInstances());
    };

    VOID
    AddPinInstance(
    )
    {
	Assert(this);
	if(pPinInfoSink == pGraphPinInfo->GetPinInfo()) {
	    pGraphPinInfo->AddPinInstance();
	}
    };

    VOID
    RemovePinInstance(
    )
    {
	Assert(this);
	if(pPinInfoSink == pGraphPinInfo->GetPinInfo()) {
	    pGraphPinInfo->RemovePinInstance();
	}
    };

    NTSTATUS
    ReservePinInstance(
	PGRAPH_NODE pGraphNode
    )
    {
	Assert(this);
	ASSERT(pPinInfoSink == pGraphPinInfo->pPinInfo);

	pGraphPinInfo->ReservePinInstance();
	pGraphPinInfo->Destroy();

	return(CGraphPinInfo::Create(
	  &pGraphPinInfo,
	  pPinInfoSink,
	  GPI_FLAGS_RESERVE_PIN_INSTANCE,
	  pGraphNode));
    };

    PCONNECT_INFO
    GetNextConnectInfo(
    )
    {
	Assert(this);
	return(pConnectInfoNext);
    };

    BOOL
    IsSameGraph(
	PCONNECT_INFO pConnectInfo
    )
    {
	PCONNECT_INFO pConnectInfo1, pConnectInfo2;
	BOOL fSameGraph;

	for(pConnectInfo1 = this, pConnectInfo2 = pConnectInfo;

	   (fSameGraph = (pConnectInfo1 == pConnectInfo2)) && 
	    pConnectInfo1 != NULL && pConnectInfo2 != NULL;

	    pConnectInfo1 = pConnectInfo1->GetNextConnectInfo(),
	    pConnectInfo2 = pConnectInfo2->GetNextConnectInfo()) {

	    Assert(pConnectInfo1);
	    Assert(pConnectInfo2);
	}
	return(fSameGraph);
    };

    BOOL
    IsTopDown(
    )
    {
	Assert(this);
	return(ulFlags & CI_FLAGS_CONNECT_TOP_DOWN);
    };

    BOOL
    IsLimitFormat(
    )
    {
	Assert(this);
	return(ulFlags & CI_FLAGS_LIMIT_FORMAT);
    };

    BOOL
    IsReuseFilterInstance(
    )
    {
	Assert(this);
	return(ulFlags & CI_FLAGS_REUSE_FILTER_INSTANCE);
    };

    BOOL
    IsPinInstanceReserved(
    )
    {
	Assert(this);
	Assert(pGraphPinInfo);
	return(pGraphPinInfo->ulFlags & GPI_FLAGS_RESERVE_PIN_INSTANCE);
    };

private:
    LONG cReference;
    ULONG ulFlags;
    PCONNECT_INFO pConnectInfoNext;
    PCONNECT_NODE_INSTANCE pConnectNodeInstance;
    PGRAPH_PIN_INFO pGraphPinInfo;
public:
    PPIN_INFO pPinInfoSource;
    PPIN_INFO pPinInfoSink;
    DefineSignature(0x20204943);				// CI

} CONNECT_INFO, *PCONNECT_INFO;

//---------------------------------------------------------------------------

typedef ListDouble<CONNECT_INFO> LIST_CONNECT_INFO;

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\legacy\wdmaud.sys\wave.c ===
/****************************************************************************
 *
 *   wave.c
 *
 *   Wave routines for wdmaud.sys
 *
 *   Copyright (C) Microsoft Corporation, 1997 - 1999  All Rights Reserved.
 *
 *   History
 *                S.Mohanraj (MohanS)
 *                M.McLaughlin (MikeM)
 *      5-19-97 - Noel Cross (NoelC)
 *
 ***************************************************************************/

#include "wdmsys.h"

//
// This is just a scratch location that is never used for anything
// but a parameter to core functions.
//                
IO_STATUS_BLOCK gIoStatusBlock ;

VOID
SetVolumeDpc(
    IN PKDPC pDpc,
    IN PVOID DefferedContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
);

VOID
SetVolumeWorker(
    IN PWAVEDEVICE pDevice,
    IN PVOID pNotUsed
);

VOID
WaitForOutStandingIo(
    IN PWAVEDEVICE        pWaveDevice,
    IN PWAVE_PIN_INSTANCE pCurWavePin
    );

//
// Check whether the waveformat is supported by kmixer
// purpose of this is to decide whether to use WaveQueued
// OR Standard Streaming
//

BOOL 
PcmWaveFormat(
    LPWAVEFORMATEX lpFormat
)
{

    PWAVEFORMATEXTENSIBLE pWaveExtended;
    WORD wFormatTag;

    PAGED_CODE();
    if (lpFormat->wFormatTag == WAVE_FORMAT_PCM) {
        return (TRUE);
    }

    if (lpFormat->wFormatTag == WAVE_FORMAT_IEEE_FLOAT) {
        return (TRUE);
    }

    if (lpFormat->wFormatTag == WAVE_FORMAT_EXTENSIBLE) {
        pWaveExtended = (PWAVEFORMATEXTENSIBLE) lpFormat;
        if (IS_VALID_WAVEFORMATEX_GUID(&pWaveExtended->SubFormat)) {
            wFormatTag = EXTRACT_WAVEFORMATEX_ID(&pWaveExtended->SubFormat);
            if (wFormatTag == WAVE_FORMAT_PCM) {
                return (TRUE);
            }
            if (wFormatTag == WAVE_FORMAT_IEEE_FLOAT) {
                return (TRUE);
            }
        }
    }

    return (FALSE);
}

BOOL 
IsValidFormatTag(
    PKSDATARANGE_AUDIO  pDataRange,
    LPWAVEFORMATEX      lpFormat
)
{
    PAGED_CODE();
    //
    //  See if we have a majorformat and subformat that
    //  we want
    //
    if ( IsEqualGUID( &KSDATAFORMAT_TYPE_AUDIO,
                      &pDataRange->DataRange.MajorFormat) )
    {
        if (WAVE_FORMAT_EXTENSIBLE == lpFormat->wFormatTag)
        {
            PWAVEFORMATEXTENSIBLE lpFormatExtensible;

            lpFormatExtensible = (PWAVEFORMATEXTENSIBLE)lpFormat;
            if ( IsEqualGUID( &pDataRange->DataRange.SubFormat,
                              &lpFormatExtensible->SubFormat) )
            {
                return TRUE;
            }
        }
        else
        {
            if ( (EXTRACT_WAVEFORMATEX_ID(&pDataRange->DataRange.SubFormat) ==
                 lpFormat->wFormatTag) )
            {
                return TRUE;
            }
        }
    }

    DPF(DL_TRACE|FA_WAVE,("Invalid Format Tag") );
    return FALSE;
}

BOOL 
IsValidSampleFrequency(
    PKSDATARANGE_AUDIO  pDataRange,
    DWORD               nSamplesPerSec
)
{
    PAGED_CODE();
    //
    //  See if this datarange support the requested frequency
    //
    if (pDataRange->MinimumSampleFrequency <= nSamplesPerSec &&
        pDataRange->MaximumSampleFrequency >= nSamplesPerSec)
    {
        return TRUE;
    }
    else
    {
        DPF(DL_MAX|FA_WAVE,("Invalid Sample Frequency") );
        return FALSE;
    }
}

BOOL 
IsValidBitsPerSample(
    PKSDATARANGE_AUDIO  pDataRange,
    LPWAVEFORMATEX      lpFormat
)
{
    PAGED_CODE();
    //
    //  See if this datarange support the requested frequency
    //
    if (pDataRange->MinimumBitsPerSample <= lpFormat->wBitsPerSample &&
        pDataRange->MaximumBitsPerSample >= lpFormat->wBitsPerSample)
    {
        if ( (lpFormat->wFormatTag == WAVE_FORMAT_PCM) &&
             (lpFormat->wBitsPerSample > 32) )
        {
            DPF(DL_TRACE|FA_WAVE,("Invalid BitsPerSample") );
            return FALSE;
        }
        else if ( (lpFormat->wFormatTag == WAVE_FORMAT_IEEE_FLOAT) &&
                  (lpFormat->wBitsPerSample != 32) )
        {
            DPF(DL_TRACE|FA_WAVE,("Invalid BitsPerSample") );
            return FALSE;
        }

        return TRUE;
    }
    else
    {
        DPF(DL_TRACE|FA_WAVE,("Invalid BitsPerSample") );
        return FALSE;
    }
}

BOOL 
IsValidChannels(
    PKSDATARANGE_AUDIO  pDataRange,
    LPWAVEFORMATEX      lpFormat
)
{
    PAGED_CODE();
    //
    //  See if this datarange support the requested frequency
    //
    if (pDataRange->MaximumChannels >= lpFormat->nChannels)
    {
        if ( ( (lpFormat->wFormatTag == WAVE_FORMAT_PCM) ||
               (lpFormat->wFormatTag == WAVE_FORMAT_IEEE_FLOAT) ) &&
             (lpFormat->nChannels > 2) )
        {
            DPF(DL_TRACE|FA_WAVE,("Invalid Channel") );
            return FALSE;
        }

        return TRUE;
    }
    else
    {
        DPF(DL_TRACE|FA_WAVE,("Invalid Channel") );
        return FALSE;
    }
}

NTSTATUS 
OpenWavePin(
    PWDMACONTEXT        pWdmaContext,
    ULONG               DeviceNumber,
    LPWAVEFORMATEX      lpFormat,
    HANDLE32            DeviceHandle,
    DWORD               dwFlags,
    ULONG               DataFlow // DataFlow is either in or out.
)
{
    PWAVE_PIN_INSTANCE  pNewWavePin = NULL;
    PWAVE_PIN_INSTANCE  pCurWavePin;
    PKSPIN_CONNECT              pConnect = NULL;
    PKSDATAFORMAT_WAVEFORMATEX  pWaveDataFormat;
    ULONG                       RegionSize;
    PCONTROLS_LIST              pControlList = NULL;
    ULONG                       Device;
    ULONG                       PinId;
    NTSTATUS            Status = STATUS_INVALID_DEVICE_REQUEST;


    PAGED_CODE();
    //
    //  Let's do this quickly and get out of here
    //
    if (WAVE_FORMAT_QUERY & dwFlags)
    {
        PDATARANGES         AudioDataRanges;
        PKSDATARANGE_AUDIO  pDataRange;
        ULONG               d;

        //
        // WaveOut call?  If so, use waveout info
        //
        if( KSPIN_DATAFLOW_IN == DataFlow )
            AudioDataRanges = pWdmaContext->WaveOutDevs[DeviceNumber].AudioDataRanges;
        else 
            AudioDataRanges = pWdmaContext->WaveInDevs[DeviceNumber].AudioDataRanges;

        pDataRange = (PKSDATARANGE_AUDIO)&AudioDataRanges->aDataRanges[0];

        for(d = 0; d < AudioDataRanges->Count; d++)
        {
            if ( (IsValidFormatTag(pDataRange,lpFormat)) &&
                 (IsValidSampleFrequency(pDataRange,lpFormat->nSamplesPerSec)) &&
                 (IsValidBitsPerSample(pDataRange,lpFormat)) &&
                 (IsValidChannels(pDataRange,lpFormat)) )
            {
                //
                //  Found a good data range, successful query
                //
                Status = STATUS_SUCCESS;
                break;
            }

            // Get the pointer to the next data range
            (PUCHAR)pDataRange += ((pDataRange->DataRange.FormatSize +
              FILE_QUAD_ALIGNMENT) & ~FILE_QUAD_ALIGNMENT);
        }

        goto exit;
    }

    //
    //  Need to allocate a pin instance for multiple wave
    //  opens on the same device
    //
    Status = AudioAllocateMemory_Fixed(sizeof(WAVE_PIN_INSTANCE),
                                       TAG_Audi_PIN,
                                       ZERO_FILL_MEMORY,
                                       &pNewWavePin);
    if(!NT_SUCCESS(Status))
    {
        goto exit;
    }

    //
    // Copy the application supplied waveformat so we can
    // use in the worker thread context. Don't need to zero
    // memory because we copy into the structure below.
    //
    Status = AudioAllocateMemory_Fixed((lpFormat->wFormatTag == WAVE_FORMAT_PCM) ?
                                          sizeof( PCMWAVEFORMAT ) :
                                          sizeof( WAVEFORMATEX ) + lpFormat->cbSize, 
                                       TAG_AudF_FORMAT,
                                       DEFAULT_MEMORY,
                                       &pNewWavePin->lpFormat);
    if(!NT_SUCCESS(Status))
    {
        AudioFreeMemory(sizeof(WAVE_PIN_INSTANCE),&pNewWavePin);
        goto exit;
    }

    RtlCopyMemory( pNewWavePin->lpFormat,
                   lpFormat,
                   (lpFormat->wFormatTag == WAVE_FORMAT_PCM) ?
                   sizeof( PCMWAVEFORMAT ) :
                   sizeof( WAVEFORMATEX ) + lpFormat->cbSize);

    pNewWavePin->DataFlow = DataFlow;
    pNewWavePin->dwFlags = dwFlags;
    pNewWavePin->DeviceNumber = DeviceNumber;
    pNewWavePin->WaveHandle = DeviceHandle;
    pNewWavePin->Next = NULL;
    pNewWavePin->NumPendingIos = 0;
    pNewWavePin->StoppingSource = FALSE;
    pNewWavePin->PausingSource = FALSE;
    pNewWavePin->dwSig = WAVE_PIN_INSTANCE_SIGNATURE;
    if( KSPIN_DATAFLOW_IN == DataFlow )
        pNewWavePin->pWaveDevice = &pWdmaContext->WaveOutDevs[DeviceNumber];
    else 
        pNewWavePin->pWaveDevice = &pWdmaContext->WaveInDevs[DeviceNumber];

    KeInitializeEvent ( &pNewWavePin->StopEvent,
                       SynchronizationEvent,
                       FALSE ) ;

    KeInitializeEvent ( &pNewWavePin->PauseEvent,
                       SynchronizationEvent,
                       FALSE ) ;

    KeInitializeSpinLock(&pNewWavePin->WavePinSpinLock);

    if( KSPIN_DATAFLOW_IN == DataFlow )
    {
        if (NULL == pWdmaContext->WaveOutDevs[DeviceNumber].pWavePin)
        {
            pWdmaContext->WaveOutDevs[DeviceNumber].pWavePin = pNewWavePin;

        } else {

            for (pCurWavePin = pWdmaContext->WaveOutDevs[DeviceNumber].pWavePin;
                 pCurWavePin->Next != NULL; )
            {
                 pCurWavePin = pCurWavePin->Next;
            }

            pCurWavePin->Next = pNewWavePin;

            DPF(DL_TRACE|FA_WAVE, ("Opening another waveout pin"));

        }
    } else {
        if (NULL == pWdmaContext->WaveInDevs[DeviceNumber].pWavePin)
        {
            pWdmaContext->WaveInDevs[DeviceNumber].pWavePin = pNewWavePin;

        } else {

            for (pCurWavePin = pWdmaContext->WaveInDevs[DeviceNumber].pWavePin;
                 pCurWavePin->Next != NULL; )
            {
                 pCurWavePin = pCurWavePin->Next;
            }

            pCurWavePin->Next = pNewWavePin;

            DPF(DL_TRACE|FA_WAVE, ("Opening another wavein pin"));
        }
    }

    //
    // We only support one client at a time.
    //
    ASSERT( !pNewWavePin->fGraphRunning );

    //
    //  We need to allocate enough memory to handle the
    //  extended waveformat structure
    //
    if (WAVE_FORMAT_PCM == lpFormat->wFormatTag)
    {
        RegionSize = sizeof(KSPIN_CONNECT) + sizeof(KSDATAFORMAT_WAVEFORMATEX);
    }
    else
    {
        RegionSize = sizeof(KSPIN_CONNECT) +
                     sizeof(KSDATAFORMAT_WAVEFORMATEX) +
                     lpFormat->cbSize;
    }

    Status = AudioAllocateMemory_Fixed(RegionSize, 
                                       TAG_Audt_CONNECT,
                                       ZERO_FILL_MEMORY,
                                       &pConnect);
    if(!NT_SUCCESS(Status))
    {
       DPF(DL_WARNING|FA_WAVE, ("pConnect not valid"));
       goto exit;
    }

    pWaveDataFormat = (PKSDATAFORMAT_WAVEFORMATEX)(pConnect + 1);

    //
    // Use WAVE_QUEUED for PCM waveOut and Standard Streaming for WaveIn
    // and non-PCM waveOut
    //
    if ( pNewWavePin->DataFlow == KSPIN_DATAFLOW_IN )
    {
       if (PcmWaveFormat(lpFormat)) { // if it is KMIXER supported waveformat
           pConnect->Interface.Set = KSINTERFACESETID_Media;
           pConnect->Interface.Id = KSINTERFACE_MEDIA_WAVE_QUEUED;
           pNewWavePin->fWaveQueued = TRUE;

       } else {

           pConnect->Interface.Set = KSINTERFACESETID_Standard;
           pConnect->Interface.Id = KSINTERFACE_STANDARD_STREAMING;
           pNewWavePin->fWaveQueued = FALSE;
       }
       pConnect->Interface.Flags = 0;
       PinId = pNewWavePin->pWaveDevice->PinId;
       Device = pNewWavePin->pWaveDevice->Device;

    } else {

       pConnect->Interface.Set = KSINTERFACESETID_Standard;
       pConnect->Interface.Id = KSINTERFACE_STANDARD_STREAMING;
       pConnect->Interface.Flags = 0;
       PinId = pNewWavePin->pWaveDevice->PinId;
       Device = pNewWavePin->pWaveDevice->Device;
    }
    pConnect->Medium.Set = KSMEDIUMSETID_Standard;
    pConnect->Medium.Id = KSMEDIUM_STANDARD_DEVIO;
    pConnect->Medium.Flags = 0 ;
    pConnect->Priority.PriorityClass = KSPRIORITY_NORMAL;
    pConnect->Priority.PrioritySubClass = 1;

    pWaveDataFormat->DataFormat.MajorFormat = KSDATAFORMAT_TYPE_AUDIO;
    if (WAVE_FORMAT_EXTENSIBLE == lpFormat->wFormatTag)
    {
        PWAVEFORMATEXTENSIBLE lpFormatExtensible;

        lpFormatExtensible = (PWAVEFORMATEXTENSIBLE)lpFormat;
        pWaveDataFormat->DataFormat.SubFormat = lpFormatExtensible->SubFormat;
    }
    else
    {
        INIT_WAVEFORMATEX_GUID( &pWaveDataFormat->DataFormat.SubFormat,
                                lpFormat->wFormatTag );
    }
    pWaveDataFormat->DataFormat.Specifier = KSDATAFORMAT_SPECIFIER_WAVEFORMATEX;
    pWaveDataFormat->DataFormat.Flags = 0 ;
    pWaveDataFormat->DataFormat.FormatSize = RegionSize - sizeof(KSPIN_CONNECT);
    pWaveDataFormat->DataFormat.SampleSize = lpFormat->nBlockAlign ;
    pWaveDataFormat->DataFormat.Reserved = 0 ;

    //
    //  Copy over the whole waveformat structure
    //
    RtlCopyMemory( &pWaveDataFormat->WaveFormatEx,
                   lpFormat,
                   (lpFormat->wFormatTag == WAVE_FORMAT_PCM) ?
                   sizeof( PCMWAVEFORMAT ) :
                   sizeof( WAVEFORMATEX ) + lpFormat->cbSize);

    Status = AudioAllocateMemory_Fixed(( sizeof(CONTROLS_LIST)+
                                        ((MAX_WAVE_CONTROLS-1)*sizeof(CONTROL_NODE)) ),
                                       TAG_AudC_CONTROL,
                                       ZERO_FILL_MEMORY,
                                       &pControlList) ;
    if(!NT_SUCCESS(Status))
    {
       AudioFreeMemory_Unknown( &pConnect );
       DPF(DL_WARNING|FA_WAVE, ("Could not allocate ControlList"));
       goto exit;
    }

    pControlList->Count = MAX_WAVE_CONTROLS ;

    pControlList->Controls[WAVE_CONTROL_VOLUME].Control = KSNODETYPE_VOLUME ;
    pControlList->Controls[WAVE_CONTROL_RATE].Control = KSNODETYPE_SRC ;
    pControlList->Controls[WAVE_CONTROL_QUALITY].Control = KSNODETYPE_SRC ;
    pNewWavePin->pControlList = pControlList ;

    //
    // Open a pin
    //
    Status = OpenSysAudioPin(Device,
                             PinId,
                             pNewWavePin->DataFlow,
                             pConnect,
                             &pNewWavePin->pFileObject,
                             &pNewWavePin->pDeviceObject,
                             pNewWavePin->pControlList);

    AudioFreeMemory_Unknown( &pConnect );

    if(!NT_SUCCESS(Status))
    {
        CloseTheWavePin(pNewWavePin->pWaveDevice, pNewWavePin->WaveHandle);
        goto exit;
    }

    if ( pNewWavePin->DataFlow == KSPIN_DATAFLOW_IN ) {

        Status = AttachVirtualSource(pNewWavePin->pFileObject, pNewWavePin->pWaveDevice->pWdmaContext->VirtualWavePinId);

        if (!NT_SUCCESS(Status))
        {
            CloseTheWavePin(pNewWavePin->pWaveDevice, pNewWavePin->WaveHandle);
            goto exit;
        }
    }

    //
    // Now we've gotten through everything so we can mark this one as running.
    // We do it here because of the close path.  In that path fGraphRunning gets
    // decremented and the assert fires in the checked build.
    //
    pNewWavePin->fGraphRunning=TRUE;

    //
    // Why do we set this to KSSTATE_STOP and then change it to KSSTATE_PAUSE?  If
    // StatePin is able to successfully change the state to KSSTATE_PAUSE, the 
    // PinState will get updated to KSSTATE_PAUSE.
    //
    pNewWavePin->PinState = KSSTATE_STOP;
    StatePin(pNewWavePin->pFileObject, KSSTATE_PAUSE, &pNewWavePin->PinState);

exit:
    RETURN( Status ); 
}

void
CloseTheWavePin(
    PWAVEDEVICE pWaveDevice,
    HANDLE32    DeviceHandle
    )
{
    PWAVE_PIN_INSTANCE *ppCur;
    PWAVE_PIN_INSTANCE pCurFree;

    PAGED_CODE();

    //
    // Remove from device chain.  Notice that ppCur gets the address of the 
    // location of pWaveDevice->pWavePin.  Thus, the *ppCur = (*ppCur)->Next
    // assignment below updates the pWaveDevice->pWavePin location if we
    // close the first pin.
    //
    for (ppCur = &pWaveDevice->pWavePin;
         *ppCur != NULL;
         ppCur = &(*ppCur)->Next)
    {
        if ( NULL == DeviceHandle || (*ppCur)->WaveHandle == DeviceHandle )
        {
            //
            // Note that if there is outstanding Io we can not close the pin
            // until it's all come back.  Thus, we'll need to tell the device
            // to stop and then wait for the Io here.
            //
            if( (*ppCur)->pFileObject )
            {
                //
                // We will never have outstanding Io if we don't have a file object
                // to send it too.
                //
                WaitForOutStandingIo(pWaveDevice,*ppCur);
            }

            CloseWavePin ( *ppCur );

            pCurFree = *ppCur;
            *ppCur = (*ppCur)->Next;

            AudioFreeMemory( sizeof(WAVE_PIN_INSTANCE), &pCurFree );
            break;
        }
    }
}

//
// This routine can not fail!
//
VOID 
CloseWavePin(
    PWAVE_PIN_INSTANCE pWavePin
)
{
    ASSERT(pWavePin->NumPendingIos==0);

    PAGED_CODE();

    //
    // This routine can get called on the error path thus fGraphRunning may be FALSE.
    // In either case, we will need to close sysaudio and free memory.
    //
    pWavePin->fGraphRunning = FALSE;

    // Close the file object (pFileObject, if it exists)
    if(pWavePin->pFileObject)
    {
        CloseSysAudio(pWavePin->pWaveDevice->pWdmaContext, pWavePin->pFileObject);
        pWavePin->pFileObject = NULL;
    }

    //
    // AudioFreeMemory_Unknown NULLs out this location after freeing the memory.
    //
    AudioFreeMemory_Unknown ( &pWavePin->lpFormat );
    AudioFreeMemory_Unknown ( &pWavePin->pControlList ) ;
    //
    // Caller needs to free pWavePin if it wants to.
    //
}

#pragma LOCKED_CODE
#pragma LOCKED_DATA

//
// This routine is used rather then an InterlockedIncrement and InterlockedDecrement
// because the routine that needs to determine what to do based on this information
// needs to perform multiple checks on different variables to determine exactly what
// to do.  Thus, we need a "critical section" for NumPendingIos.  Also, SpinLocks
// must be called from locked code.  :)
//
void
LockedWaveIoCount(
    PWAVE_PIN_INSTANCE  pCurWavePin,
    BOOL bIncrease
    )
{
    KIRQL OldIrql;

    KeAcquireSpinLock(&pCurWavePin->WavePinSpinLock,&OldIrql);

    if( bIncrease )
        pCurWavePin->NumPendingIos++;
    else 
        pCurWavePin->NumPendingIos--;
    
    KeReleaseSpinLock(&pCurWavePin->WavePinSpinLock, OldIrql);
}

void
CompleteNumPendingIos(
    PWAVE_PIN_INSTANCE pCurWavePin
    )
{
    KIRQL                   OldIrql;

    if( pCurWavePin )
    {
        KeAcquireSpinLock(&pCurWavePin->WavePinSpinLock,&OldIrql);
        //
        // We always decrement NumPendingIos and then perform the comparisons.
        // If the count goes to zero, we're the last IRP so we need to check
        // to see if we need to signal any waiting thread.
        //
        if( ( --pCurWavePin->NumPendingIos == 0 ) && pCurWavePin->StoppingSource )
        {
            //
            // If this Io is the last one to come through, and we're currently
            // sitting waiting for the reset to finish, then we signal it here.
            //
            KeSetEvent ( &pCurWavePin->StopEvent, 0, FALSE ) ;
        }

        //
        // Upon leaving this spinlock, pCurWavePin can be freed by the close
        // routine if NumPendingIos went to zero!
        //
        KeReleaseSpinLock(&pCurWavePin->WavePinSpinLock, OldIrql);
    }
    //
    // Must not touch pCurWavePin after this!
    //
}


void
UnmapWriteContext(
    PWRITE_CONTEXT pWriteContext
    )
{
    wdmaudUnmapBuffer(pWriteContext->pBufferMdl);
    AudioFreeMemory_Unknown(&pWriteContext->pCapturedWaveHdr);
    AudioFreeMemory(sizeof(WRITE_CONTEXT),&pWriteContext);
}

void
FreeWriteContext(
    PWRITE_CONTEXT pWriteContext,
    NTSTATUS       IrpStatus
    )
{
    PIRP                    UserIrp;
    PWDMAPENDINGIRP_CONTEXT pPendingIrpContext;

    //
    //  grab the parent IRP from the reserved field
    //
    UserIrp = (PIRP)pWriteContext->whInstance.wh.reserved;
    pPendingIrpContext = pWriteContext->pPendingIrpContext;

    UnmapWriteContext( pWriteContext );

    if( UserIrp )
        wdmaudUnprepareIrp( UserIrp,IrpStatus,0,pPendingIrpContext);
}

//
// This is the Irp completion routine.
//
NTSTATUS 
wqWriteWaveCallBack(
    PDEVICE_OBJECT  pDeviceObject,
    PIRP            pIrp,
    IN PWAVEHDR     pWriteData
)
{
    PWAVE_PIN_INSTANCE      pCurWavePin;
    PMDL                    Mdl;
    PMDL                    nextMdl;
    PIRP                    UserIrp;
    PWDMAPENDINGIRP_CONTEXT pPendingIrpContext;
    PWRITE_CONTEXT          pWriteContext = (PWRITE_CONTEXT)pWriteData;

    ASSERT(pWriteData);

    pCurWavePin = pWriteContext->whInstance.pWaveInstance;

    DPF(DL_TRACE|FA_WAVE, ("R%d: 0x%08x", pCurWavePin->NumPendingIos,pIrp));

    //
    // After we get our pCurWavePin, we don't need the write context any longer.
    //
    FreeWriteContext(pWriteContext, pIrp->IoStatus.Status);

    //
    // Consider putting this in a routine.
    //
    if (pIrp->MdlAddress != NULL)
    {
        //
        // Unlock any pages that may be described by MDLs.
        //
        Mdl = pIrp->MdlAddress;
        while (Mdl != NULL)
        {
            MmUnlockPages( Mdl );
            Mdl = Mdl->Next;
        }
    }

    if (pIrp->MdlAddress != NULL)
    {
        for (Mdl = pIrp->MdlAddress; Mdl != (PMDL) NULL; Mdl = nextMdl)
        {
            nextMdl = Mdl->Next;
            if (Mdl->MdlFlags & MDL_PARTIAL_HAS_BEEN_MAPPED)
            {
                ASSERT( Mdl->MdlFlags & MDL_PARTIAL );
                MmUnmapLockedPages( Mdl->MappedSystemVa, Mdl );
            }
            else if (!(Mdl->MdlFlags & MDL_PARTIAL))
            {
                ASSERT(!(Mdl->MdlFlags & MDL_MAPPED_TO_SYSTEM_VA ));
            }
            AudioFreeMemory_Unknown( &Mdl );
        }
    }

    IoFreeIrp( pIrp );

    CompleteNumPendingIos( pCurWavePin );

    return ( STATUS_MORE_PROCESSING_REQUIRED );
}

//
// Consider combining ssWriteWaveCallback and wqWriteWaveCallBack.  They look
// like the same routine!
//
NTSTATUS 
ssWriteWaveCallBack(
    PDEVICE_OBJECT  pDeviceObject,
    PIRP            pIrp,
    IN PSTREAM_HEADER_EX pStreamHeader
)
{
    PWAVE_PIN_INSTANCE      pCurWavePin;
    PIRP                    UserIrp;
    PWDMAPENDINGIRP_CONTEXT pPendingIrpContext;
    PWRITE_CONTEXT          pWriteContext = (PWRITE_CONTEXT)pStreamHeader->pWaveHdr;

    ASSERT(pWriteContext);

    pCurWavePin = pWriteContext->whInstance.pWaveInstance;

    DPF(DL_TRACE|FA_WAVE, ("R%d: 0x%08x", pCurWavePin->NumPendingIos,pIrp));

    FreeWriteContext( pWriteContext, pIrp->IoStatus.Status );

    CompleteNumPendingIos( pCurWavePin );

    return STATUS_SUCCESS;
}

#pragma PAGEABLE_CODE
#pragma PAGEABLE_DATA

//
// Walk the list and if we find a matching pin, write it back for the caller.
//
NTSTATUS
FindRunningPin(
    IN PWAVEDEVICE          pWaveDevice,
    IN HANDLE32             DeviceHandle,
    OUT PWAVE_PIN_INSTANCE* ppCurWavePin
    )
{
    PWAVE_PIN_INSTANCE pCurWavePin;
    NTSTATUS           Status = STATUS_INVALID_DEVICE_REQUEST;

    //
    // Prepare for the error condition.
    //
    *ppCurWavePin = NULL;
    //
    //  find the right pin based off of the wave handle
    //
    for (pCurWavePin = pWaveDevice->pWavePin;
         pCurWavePin != NULL;
         pCurWavePin = pCurWavePin->Next)
    {
        if (pCurWavePin->WaveHandle == DeviceHandle)
        {
            if (pCurWavePin->fGraphRunning)
            {
                //
                // Write back the pointer and return success
                //
                *ppCurWavePin = pCurWavePin;
                Status = STATUS_SUCCESS;
            } else {
                DPF(DL_WARNING|FA_WAVE,("Invalid fGraphRunning") );
                Status = STATUS_DEVICE_NOT_READY;
            }
            return Status;
        }
    }
    return Status;
}

//
// WriteWaveOutPin walks the device list like the other routines.
//
// pUserIrp is the Irp on which this call from user mode was made.  It's
// always going to be valid.  We don't need to check it.
//
// This routine needs to set pCompletedIrp to either TRUE or FALSE.  If
// TRUE, the Irp was successfully marked STATUS_PENDING and it will get
// completed later.  If FALSE, there was some type of error that prevented
// us from submitting the Irp.  The caller to this routine will need to
// handle freeing the Irp.
//
//
// This routine should be the one storing the user's irp in the reserved field.
// Not the caller.
// pWriteContext->whInstance.wh.reserved = (DWORD_PTR)pIrp;  // store to complete later
//
NTSTATUS 
WriteWaveOutPin(
    PWAVEDEVICE       pWaveOutDevice,
    HANDLE32          DeviceHandle,
    LPWAVEHDR         pWriteData,
    PSTREAM_HEADER_EX pStreamHeader,
    PIRP              pUserIrp,
    PWDMACONTEXT      pContext,
    BOOL             *pCompletedIrp
)
{
    PWAVE_PIN_INSTANCE      pCurWavePin;
    PWRITE_CONTEXT          pWriteContext = (PWRITE_CONTEXT)pWriteData;
    PWDMAPENDINGIRP_CONTEXT pPendingIrpContext;
    NTSTATUS                Status;

    PAGED_CODE();

    //
    // We assumee that pCompletedIrp is FALSE on entry.
    //
    ASSERT( *pCompletedIrp == FALSE );

    Status = FindRunningPin(pWaveOutDevice,DeviceHandle,&pCurWavePin);
    if( NT_SUCCESS(Status) )
    {
        if (pCurWavePin->fWaveQueued) 
        {
            PIO_STACK_LOCATION      pIrpStack;
            LARGE_INTEGER           StartingOffset;
            PIRP                    pIrp = NULL;

            //
            //  Can't use KsStreamIo because these are not
            //  true stream headers.  Sending down headers
            //  using the WAVE_QUEUED interface
            //
            StartingOffset.QuadPart = 0;
            pIrp = IoBuildAsynchronousFsdRequest(IRP_MJ_WRITE,
                                                 pCurWavePin->pDeviceObject,
                                                 (PVOID)pWriteContext,
                                                 sizeof(WAVEHDR),
                                                 &StartingOffset,
                                                 &gIoStatusBlock);
            if( pIrp )
            {
                Status = wdmaudPrepareIrp( pUserIrp, 
                                           WaveOutDevice, 
                                           pContext, 
                                           &pPendingIrpContext );
                if( NT_SUCCESS(Status) )
                {
                    //
                    // The Irp was successfully marked STATUS_PENDING and put in
                    // our queue.  Now let's send it.
                    //

                    pWriteContext->whInstance.pWaveInstance = pCurWavePin;
                    pWriteContext->pPendingIrpContext = pPendingIrpContext;

                    pIrp->RequestorMode = KernelMode;
                    pIrp->Tail.Overlay.OriginalFileObject = pCurWavePin->pFileObject;

                    pIrpStack = IoGetNextIrpStackLocation(pIrp);
                    pIrpStack->FileObject = pCurWavePin->pFileObject;

                    IoSetCompletionRoutine(pIrp,
                                           wqWriteWaveCallBack,
                                           pWriteData,
                                           TRUE,TRUE,TRUE);

                    //
                    // one more IRP pending
                    //
                    LockedWaveIoCount(pCurWavePin,INCREASE);
                    DPF(DL_TRACE|FA_WAVE, ("A%d", pCurWavePin->NumPendingIos));

                    //
                    // We don't need to check the return code because the
                    // completion routine will ALWAYS be called.  See 
                    // IoSetCompletionRoutine(...TRUE,TRUE,TRUE).
                    //
                    IofCallDriver( pCurWavePin->pDeviceObject, pIrp );

                    //
                    // At this point, the Irp may have been completed and our 
                    // callback routine will have been called.  We can not touch
                    // the irp after this call.  The Callback routine Completes
                    // the Irp and unprepares the user's Irp.
                    //
                    *pCompletedIrp = TRUE;

                    //
                    // In wdmaudPrepareIrp we call IoCsqInsertIrp which calls
                    // IoMarkIrpPending, thus we must always return STATUS_PENDING.
                    //
                    return STATUS_PENDING;

                } else {
                    //
                    // We where not successful at putting the Irp in the queue.
                    // cleanup and indicated that we did not complete the Irp.
                    // The status will have been set by wdmaudPrepareIrp.

                    DPF(DL_WARNING|FA_WAVE,("wdmaudPrepareIrp failed Status=%X",Status) );
                }
            } else {
                //
                // Could not create a Irp to send down - error out!
                //
                DPF(DL_WARNING|FA_WAVE,("IoBuildAsynchronousFsdRequest failed") );
                Status = STATUS_UNSUCCESSFUL;

                //
                // We can't get an Irp to schedule.  Cleanup memory
                // and return.  The caller will complete the Irp.
                //
            }

        } else {

            //
            // If it's not wave queued we need to make sure that it's a PCM
            // looped call.
            //
            if ( (pWriteData->dwFlags & (WHDR_BEGINLOOP|WHDR_ENDLOOP)) ) 
            {
                //
                // Error out non-PCM looped calls
                //
                Status = STATUS_NOT_IMPLEMENTED;

            } else {

                //
                // The graph is running so we can use it.  Proceed.
                //
                Status = wdmaudPrepareIrp( pUserIrp, WaveOutDevice, pContext, &pPendingIrpContext );
                if( NT_SUCCESS(Status) )
                {
                    //
                    // The Irp was successfully marked STATUS_PENDING and put in
                    // our queue.  Now let's send it.
                    //

                    pWriteContext->whInstance.pWaveInstance = pCurWavePin;
                    pWriteContext->pPendingIrpContext = pPendingIrpContext;

                    //
                    // one more IRP pending
                    //
                    LockedWaveIoCount(pCurWavePin,INCREASE);
                    DPF(DL_TRACE|FA_WAVE, ("A%d", pCurWavePin->NumPendingIos));

                    pStreamHeader->pWavePin = pCurWavePin;
                    pStreamHeader->Header.FrameExtent       = pWriteData->dwBufferLength ;
                    pStreamHeader->Header.DataUsed          = pWriteData->dwBufferLength;
                    pStreamHeader->Header.OptionsFlags      = 0 ;
                    pStreamHeader->Header.Size              = sizeof( KSSTREAM_HEADER );
                    pStreamHeader->Header.TypeSpecificFlags = 0;
                    pStreamHeader->pWaveHdr = pWriteData;  // store so we can use later

                    Status = KsStreamIo(pCurWavePin->pFileObject,
                                        NULL,                   // Event
                                        NULL,                   // PortContext
                                        ssWriteWaveCallBack,
                                        pStreamHeader,              // CompletionContext
                                        KsInvokeOnSuccess | KsInvokeOnCancel | KsInvokeOnError,
                                        &gIoStatusBlock,
                                        &pStreamHeader->Header,
                                        sizeof( KSSTREAM_HEADER ),
                                        KSSTREAM_WRITE,
                                        KernelMode );                    

                    //
                    // At this point, the Irp may have been completed and our 
                    // callback routine will have been called.  We can not touch
                    // the irp after this call.  The Callback routine Completes
                    // the Irp and unprepares the user's Irp.
                    //
                    *pCompletedIrp = TRUE;

                    //
                    // In wdmaudPrepareIrp we call IoCsqInsertIrp which calls
                    // IoMarkIrpPending, thus we must always return STATUS_PENDING.
                    // also, we don't want to clean up anything.... just return.
                    //
                    return STATUS_PENDING;

                    //
                    // Warning: If, for any reason, the completion routine is not called
                    // for this Irp, wdmaud.sys will hang.  It's been discovered that 
                    // KsStreamIo may error out in low memory conditions.  There is an
                    // outstanding bug to address this.
                    //


                } else {
                    //
                    // We where not successful at putting the Irp in the queue.
                    // cleanup and indicated that we did not complete the Irp.
                    // The Status was set by wdmaudPrepareIrp.

                    DPF(DL_WARNING|FA_WAVE,("wdmaudPrepareIrp failed Status=%X",Status) );
                }
            }
        }
    } 
    //
    // All error paths end up here.  All error paths should cleanup the
    // memory so we don't leak.
    //

    UnmapWriteContext( pWriteContext );

    RETURN( Status );
}

//
// These next three routines all perform the same type of walk and checks.
// They should be combined into one walk routine and a callback.
//
NTSTATUS 
PosWavePin(
    PWAVEDEVICE     pWaveDevice,
    HANDLE32        DeviceHandle,
    PWAVEPOSITION   pWavePos
)
{
    PWAVE_PIN_INSTANCE pCurWavePin;
    KSAUDIO_POSITION   AudioPosition;
    NTSTATUS           Status;

    PAGED_CODE();

    Status = FindRunningPin(pWaveDevice,DeviceHandle,&pCurWavePin);
    if( NT_SUCCESS(Status) )
    {
        if ( pWavePos->Operation == KSPROPERTY_TYPE_SET )
        {
            AudioPosition.WriteOffset = pWavePos->BytePos;
        }

        Status = PinProperty(pCurWavePin->pFileObject,
                             &KSPROPSETID_Audio,
                             KSPROPERTY_AUDIO_POSITION,
                             pWavePos->Operation,
                             sizeof(AudioPosition),
                             &AudioPosition);

        if (NT_SUCCESS(Status))
        {
            pWavePos->BytePos = (DWORD)AudioPosition.PlayOffset;
        }
    }
    RETURN( Status );
}

NTSTATUS 
BreakLoopWaveOutPin(
    PWAVEDEVICE pWaveOutDevice,
    HANDLE32    DeviceHandle
)
{
    PWAVE_PIN_INSTANCE pCurWavePin;
    NTSTATUS           Status;

    PAGED_CODE();

    Status = FindRunningPin(pWaveOutDevice,DeviceHandle,&pCurWavePin);
    if( NT_SUCCESS(Status) )
    {
        if (pCurWavePin->fWaveQueued) {
            Status = PinMethod ( pCurWavePin->pFileObject,
                                 &KSMETHODSETID_Wave_Queued,
                                 KSMETHOD_WAVE_QUEUED_BREAKLOOP,
                                 KSMETHOD_TYPE_WRITE,    // TODO :: change to TYPE_NONE
                                 0,
                                 NULL ) ;
        }
        else {
            //
            // Error out non-pcm loop related commands
            //
            Status = STATUS_NOT_IMPLEMENTED;
        }
    }

    RETURN( Status );
}

NTSTATUS
ResetWaveOutPin(
    PWAVEDEVICE pWaveOutDevice,
    HANDLE32    DeviceHandle
)
{
    PWAVE_PIN_INSTANCE pCurWavePin;
    NTSTATUS           Status;
    KSRESET            ResetValue ;

    PAGED_CODE();

    Status = FindRunningPin(pWaveOutDevice,DeviceHandle,&pCurWavePin);
    if( NT_SUCCESS(Status))
    {
        pCurWavePin->StoppingSource = TRUE ;

        ResetValue = KSRESET_BEGIN ;
        Status = ResetWavePin(pCurWavePin, &ResetValue) ;

        //
        // If the driver fails to reset will will not wait for the
        // Irps to complete.  But, that would be bad in the
        // CleanupWavePins case because we're going to free
        // the memory when we return from this call.  Thus,
        // will choose a hang over a bugcheck and wait for
        // the Irps to complete.
        //

        if ( pCurWavePin->NumPendingIos )
        {
            DPF(DL_TRACE|FA_WAVE, ("Start waiting for stop to complete"));
            KeWaitForSingleObject ( &pCurWavePin->StopEvent,
                                    Executive,
                                    KernelMode,
                                    FALSE,
                                    NULL ) ;
        }
        DPF(DL_TRACE|FA_WAVE, ("Done waiting for stop to complete"));
        ResetValue = KSRESET_END ;
        ResetWavePin(pCurWavePin, &ResetValue) ;

        //
        // Why do we have this KeClearEvent ???
        //
        KeClearEvent ( &pCurWavePin->StopEvent );

        pCurWavePin->StoppingSource = FALSE ;
    }

    RETURN( Status );
}

//
// The only difference between this and StatePin is KSPROPERTY_CONNECTION_STATE
// and IOCTL_KS_RESET_STATE. Consider using StatePin if possible.
//
NTSTATUS 
ResetWavePin(
    PWAVE_PIN_INSTANCE pWavePin,
    KSRESET            *pResetValue
)
{
    NTSTATUS    Status = STATUS_SUCCESS;
    ULONG       BytesReturned ;

    PAGED_CODE();
    if (!pWavePin->fGraphRunning)
    {
        DPF(DL_WARNING|FA_WAVE,("Invalid fGraphRunning") );
        RETURN( STATUS_INVALID_DEVICE_REQUEST );
    }

    DPF(DL_TRACE|FA_SYSAUDIO,("IOCTL_KS_RESET_STATE pResetValue=%X",pResetValue) );

    Status = KsSynchronousIoControlDevice(pWavePin->pFileObject,
                                          KernelMode,
                                          IOCTL_KS_RESET_STATE,
                                          pResetValue,
                                          sizeof(KSRESET),
                                          NULL,
                                          0,
                                          &BytesReturned);

    DPF(DL_TRACE|FA_SYSAUDIO,("IOCTL_KS_RESET_STATE result=%X",Status) );

    RETURN( Status );
}

//
// Looks the same, different flavor.
//
NTSTATUS 
StateWavePin(
    PWAVEDEVICE pWaveInDevice,
    HANDLE32    DeviceHandle,
    KSSTATE     State
)
{
    PWAVE_PIN_INSTANCE pCurWavePin;
    NTSTATUS           Status;

    PAGED_CODE();

    Status = FindRunningPin(pWaveInDevice,DeviceHandle,&pCurWavePin);
    if( NT_SUCCESS(Status) )
    {
        if( pCurWavePin->DataFlow == KSPIN_DATAFLOW_OUT )
        {
            //
            // We have an In pin.
            //
            //
            //  On a waveInStop, one more buffer needs to make
            //  it up to the application before the device can
            //  stop.  The caveat is that if the buffer is
            //  large it might take awhile for the stop to happen.
            //
            //  Don't return let this extra buffer complete if the
            //  device is already in a paused state.
            //
            if( (KSSTATE_PAUSE == State) &&
                (KSSTATE_PAUSE != pCurWavePin->PinState) )
            {
                pCurWavePin->PausingSource = TRUE ;

                if ( pCurWavePin->NumPendingIos )
                {
                    DPF(DL_TRACE|FA_WAVE, ("Waiting for PauseEvent..."));
                    KeWaitForSingleObject ( &pCurWavePin->PauseEvent,
                                            Executive,
                                            KernelMode,
                                            FALSE,
                                            NULL ) ;
                    DPF(DL_TRACE|FA_WAVE, ("...Done waiting for PauseEvent"));
                }

                KeClearEvent ( &pCurWavePin->PauseEvent );

                pCurWavePin->PausingSource = FALSE ;
            }

            Status = StatePin ( pCurWavePin->pFileObject, State, &pCurWavePin->PinState ) ;

            if ( NT_SUCCESS(Status) )
            {
                ASSERT(pCurWavePin->PinState == State);

                if ( KSSTATE_STOP == State )
                {
                    Status = StatePin( pCurWavePin->pFileObject,KSSTATE_PAUSE,&pCurWavePin->PinState);
                }
            }
        } else {
            //
            // We have an out pin.
            //
            Status = StatePin ( pCurWavePin->pFileObject, State, &pCurWavePin->PinState ) ;
        }
    }

    RETURN( Status );
}

#pragma LOCKED_CODE
#pragma LOCKED_DATA

void
UnmapStreamHeader(
    PSTREAM_HEADER_EX pStreamHeader
    )
{
    wdmaudUnmapBuffer(pStreamHeader->pBufferMdl);
    wdmaudUnmapBuffer(pStreamHeader->pHeaderMdl);
    AudioFreeMemory_Unknown(&pStreamHeader->pWaveHdrAligned);
    AudioFreeMemory(sizeof(STREAM_HEADER_EX),&pStreamHeader);
}

void
FreeStreamHeader(
    PSTREAM_HEADER_EX pStreamHeader,
    NTSTATUS IrpStatus
    )
{
    PIRP                    UserIrp;
    PWDMAPENDINGIRP_CONTEXT pPendingIrpContext;

    UserIrp = pStreamHeader->pIrp;

    ASSERT(UserIrp);

    pPendingIrpContext = pStreamHeader->pPendingIrpContext;

    UnmapStreamHeader( pStreamHeader );

    wdmaudUnprepareIrp( UserIrp,IrpStatus,sizeof(DEVICEINFO),pPendingIrpContext );
}


//
// This is the read Irp completion routine.
//
NTSTATUS 
ReadWaveCallBack(
    PDEVICE_OBJECT          pDeviceObject,
    PIRP                    pIrp,
    IN PSTREAM_HEADER_EX    pStreamHeader
)
{
    // cast the reserved field to the parent IRP that we stored in here
    PWAVE_PIN_INSTANCE      pCurWavePin;
    NTSTATUS                Status;
    KIRQL                   OldIrql;

    //
    // Must get the current pin before we free the stream header structure.
    //
    pCurWavePin = pStreamHeader->pWavePin;

    //
    //  Get the dataused and fill the bytes recorded field
    //
    if (pIrp->IoStatus.Status == STATUS_CANCELLED)
        pStreamHeader->pWaveHdrAligned->dwBytesRecorded = 0L;
    else
        pStreamHeader->pWaveHdrAligned->dwBytesRecorded = pStreamHeader->Header.DataUsed;

    //
    //  Copy back the contents of the captured buffer
    //
    try
    {
        RtlCopyMemory( pStreamHeader->pdwBytesRecorded,
                       &pStreamHeader->pWaveHdrAligned->dwBytesRecorded,
                       sizeof(DWORD));
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        DPF(DL_WARNING|FA_WAVE, ("Couldn't copy waveheader (0x%08x)", GetExceptionCode()) );
    }

    FreeStreamHeader( pStreamHeader, pIrp->IoStatus.Status );

    if ( pCurWavePin )
    {
        //
        // Need to lock this code so we can decrement and check and set an event
        // with no preemption windows.
        //
        KeAcquireSpinLock(&pCurWavePin->WavePinSpinLock, &OldIrql);

        //
        // We always decrement NumPendingIos before doing any comparisons.  This
        // is so that we're consistant.
        //
        pCurWavePin->NumPendingIos--;

        if( pCurWavePin->PausingSource )
        {
            //
            //  Let this I/O squeeze out of the queue on a waveInStop
            //
            KeSetEvent ( &pCurWavePin->PauseEvent, 0, FALSE ) ;
        }

        //
        // If the count went to zero, we're the last IRP so we need to check
        // to see if we need to signal any waiting thread.
        //
        if( (pCurWavePin->NumPendingIos == 0) && pCurWavePin->StoppingSource )
        {
            //
            // Because we do not block (FALSE), we can call KeSetEvent in this 
            // Lock.
            //
            KeSetEvent ( &pCurWavePin->StopEvent, 0, FALSE ) ;
        }

        //
        // Upon leaving this spinlock, pCurWavePin can be freed by the close
        // routine if NumPendingIos went to zero!
        //
        KeReleaseSpinLock(&pCurWavePin->WavePinSpinLock, OldIrql);
    }

    return STATUS_SUCCESS;
}

#pragma PAGEABLE_CODE
#pragma PAGEABLE_DATA

//
// pUserIrp will always be valid when this call is made.  It is the Irp
// that we got for the user mode request.
//
// pStreamHeader is alway going to be valid.
//
NTSTATUS 
ReadWaveInPin(
    PWAVEDEVICE         pWaveInDevice,
    HANDLE32            DeviceHandle,
    PSTREAM_HEADER_EX   pStreamHeader,
    PIRP                pUserIrp,
    PWDMACONTEXT        pContext,
    BOOL               *pCompletedIrp
)
{
    PWAVE_PIN_INSTANCE      pCurWavePin;
    PWDMAPENDINGIRP_CONTEXT pPendingIrpContext;
    NTSTATUS                Status;

    PAGED_CODE();

    //
    // We assumee that pCompletedIrp is FALSE on entry.
    //
    ASSERT( *pCompletedIrp == FALSE );

    Status = FindRunningPin(pWaveInDevice,DeviceHandle,&pCurWavePin);
    if( NT_SUCCESS(Status) )
    {
        Status = wdmaudPrepareIrp( pUserIrp, WaveInDevice, pContext, &pPendingIrpContext );
        if( NT_SUCCESS(Status) )
        {
            pStreamHeader->pWavePin = pCurWavePin;
            pStreamHeader->pPendingIrpContext = pPendingIrpContext;
            ASSERT(pPendingIrpContext);

            pStreamHeader->Header.OptionsFlags = 0 ;
            pStreamHeader->Header.Size = sizeof( KSSTREAM_HEADER );
            pStreamHeader->Header.TypeSpecificFlags = 0;

            LockedWaveIoCount(pCurWavePin,INCREASE);

            DPF(DL_TRACE|FA_WAVE, ("A%d: 0x%08x", pCurWavePin->NumPendingIos,
                                                          pStreamHeader));

            Status = KsStreamIo(pCurWavePin->pFileObject,
                                NULL,                   // Event
                                NULL,                   // PortContext
                                ReadWaveCallBack,
                                pStreamHeader,              // CompletionContext
                                KsInvokeOnSuccess | KsInvokeOnCancel | KsInvokeOnError,
                                &gIoStatusBlock,
                                &pStreamHeader->Header,
                                sizeof( KSSTREAM_HEADER ),
                                KSSTREAM_READ,
                                KernelMode );

            //
            // In wdmaudPrepareIrp we call IoCsqInsertIrp which calls
            // IoMarkIrpPending, thus we must always return STATUS_PENDING.
            // And we completed the Irp.
            //
            *pCompletedIrp = TRUE;

            return STATUS_PENDING;

            //
            // Warning: If, for any reason, the completion routine is not called
            // for this Irp, wdmaud.sys will hang.  It's been discovered that 
            // KsStreamIo may error out in low memory conditions.  There is an
            // outstanding bug to address this.
            //


        } else {
            //
            // wdmaudPrepareIrp would have set Status for this error path
            //
            DPF(DL_WARNING|FA_WAVE,("wdmaudPrepareIrp failed Status=%X",Status) );
        }
    }

    //
    // All error paths lead here.
    //
    UnmapStreamHeader( pStreamHeader );

    RETURN( Status );
}

NTSTATUS
FindVolumeControl(
    IN PWDMACONTEXT pWdmaContext,
    IN PCWSTR DeviceInterface,
    IN DWORD DeviceType
)
{
    PCOMMONDEVICE *papCommonDevice;
    PWAVEDEVICE paWaveOutDevs;
    PMIDIDEVICE paMidiOutDevs;
    PAUXDEVICE paAuxDevs;
    ULONG DeviceNumber;
    ULONG MixerIndex;
    NTSTATUS Status;

    PAGED_CODE();
    papCommonDevice = &pWdmaContext->apCommonDevice[DeviceType][0];
    paWaveOutDevs = pWdmaContext->WaveOutDevs;
    paMidiOutDevs = pWdmaContext->MidiOutDevs;
    paAuxDevs = pWdmaContext->AuxDevs;

    for( DeviceNumber = 0; DeviceNumber < MAXNUMDEVS; DeviceNumber++ ) {

        if(papCommonDevice[DeviceNumber]->Device == UNUSED_DEVICE) {
            continue;
        }

        if(MyWcsicmp(papCommonDevice[DeviceNumber]->DeviceInterface, DeviceInterface)) {
            continue;
        }

        MixerIndex = FindMixerForDevNode(pWdmaContext->MixerDevs, DeviceInterface);
        if ( (MixerIndex == UNUSED_DEVICE) || (pWdmaContext->MixerDevs[MixerIndex].pwstrName == NULL) ) {
            continue;
        }

        switch(DeviceType) {

            case WaveOutDevice:
                Status = IsVolumeControl(
                  pWdmaContext,
                  DeviceInterface,
                  MIXERLINE_COMPONENTTYPE_SRC_WAVEOUT,
                  &paWaveOutDevs[ DeviceNumber ].dwVolumeID,
                  &paWaveOutDevs[ DeviceNumber ].cChannels);

                if(!NT_SUCCESS(Status)) {
                    break;
                }

                if( paWaveOutDevs[ DeviceNumber ].pTimer == NULL ) {
                    Status = AudioAllocateMemory_Fixed(sizeof(KTIMER),
                                                       TAG_AudT_TIMER,
                                                       ZERO_FILL_MEMORY,
                                                       &paWaveOutDevs[ DeviceNumber ].pTimer);

                    if(!NT_SUCCESS(Status)) {
                        return Status;
                    }

                    KeInitializeTimerEx( paWaveOutDevs[ DeviceNumber ].pTimer,
                                         NotificationTimer
                                         );
                }

                if( paWaveOutDevs[ DeviceNumber ].pDpc == NULL ) {
                    Status = AudioAllocateMemory_Fixed(sizeof(KDPC),
                                                       TAG_AudE_EVENT,
                                                       ZERO_FILL_MEMORY,
                                                       &paWaveOutDevs[ DeviceNumber ].pDpc);

                    if(!NT_SUCCESS(Status)) {
                        return Status;
                    }

                    KeInitializeDpc( paWaveOutDevs[ DeviceNumber ].pDpc,
                                     SetVolumeDpc,
                                     &paWaveOutDevs[ DeviceNumber ]
                                     );

                    // Initialize the left and right channels to goofy values.
                    // This signifies that the cache is invalid

                    paWaveOutDevs[ DeviceNumber ].LeftVolume = 0x4321;
                    paWaveOutDevs[ DeviceNumber ].RightVolume = 0x6789;
                    paWaveOutDevs[ DeviceNumber ].fNeedToSetVol = FALSE;
                }
                break;

            case MidiOutDevice:
                Status = IsVolumeControl(
                  pWdmaContext,
                  DeviceInterface,
                  MIXERLINE_COMPONENTTYPE_SRC_SYNTHESIZER,
                  &paMidiOutDevs[ DeviceNumber ].dwVolumeID,
                  &paMidiOutDevs[ DeviceNumber ].cChannels);
                break;

            case AuxDevice:
                Status = IsVolumeControl(
                  pWdmaContext,
                  DeviceInterface,
                  MIXERLINE_COMPONENTTYPE_SRC_COMPACTDISC,
                  &paAuxDevs[ DeviceNumber ].dwVolumeID,
                  &paAuxDevs[ DeviceNumber ].cChannels);
                break;
        }

    } // while

    return( STATUS_SUCCESS );
}

NTSTATUS
IsVolumeControl(
    IN PWDMACONTEXT pWdmaContext,
    IN PCWSTR DeviceInterface,
    IN DWORD dwComponentType,
    IN PDWORD pdwControlID,
    IN PDWORD pcChannels
)
{
    MIXERLINE         ml;
    MIXERLINECONTROLS mlc;
    MIXERCONTROL      mc;
    MMRESULT          mmr;

    PAGED_CODE();
    ml.dwComponentType = dwComponentType;
    ml.cbStruct = sizeof( MIXERLINE );

    mmr = kmxlGetLineInfo( pWdmaContext,
                           DeviceInterface,
                           &ml,
                           MIXER_GETLINEINFOF_COMPONENTTYPE
                         );
    if( mmr != MMSYSERR_NOERROR ) {
        DPF(DL_WARNING|FA_WAVE,("kmxlGetLineInfo failed mmr=%X",mmr) );
        RETURN( STATUS_UNSUCCESSFUL );
    }

    mlc.cbStruct      = sizeof( MIXERLINECONTROLS );
    mlc.dwLineID      = ml.dwLineID;
    mlc.dwControlType = MIXERCONTROL_CONTROLTYPE_VOLUME;
    mlc.cControls     = 1;
    mlc.cbmxctrl      = sizeof( MIXERCONTROL );
    mlc.pamxctrl      = &mc;

    mmr = kmxlGetLineControls(
        pWdmaContext,
        DeviceInterface,
        &mlc,
        MIXER_GETLINECONTROLSF_ONEBYTYPE
        );
    if( mmr != MMSYSERR_NOERROR ) {
        DPF(DL_WARNING|FA_WAVE,( "kmxlGetLineControls failed mmr=%x!", mmr ) );
        return( STATUS_UNSUCCESSFUL );
    }
    *pdwControlID = mc.dwControlID;
    *pcChannels  = ml.cChannels;
    return( STATUS_SUCCESS );
}

#pragma LOCKED_CODE

NTSTATUS
MapMmSysError(
    IN MMRESULT mmr
)
{
    if ( (mmr == MMSYSERR_INVALPARAM) ||
         (mmr == MIXERR_INVALCONTROL) ) {
        return (STATUS_INVALID_PARAMETER);
    }

    if (mmr == MMSYSERR_NOTSUPPORTED) {
        return (STATUS_NOT_SUPPORTED);
    }

    if (mmr == MMSYSERR_NOMEM) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    if (mmr == MMSYSERR_NOERROR) {
        return(STATUS_SUCCESS);
    }

    return(STATUS_UNSUCCESSFUL);
}


NTSTATUS
SetVolume(
    PWDMACONTEXT pWdmaContext,
    IN DWORD DeviceNumber,
    IN DWORD DeviceType,
    IN DWORD LeftChannel,
    IN DWORD RightChannel
)
{
    MIXERCONTROLDETAILS          mcd;
    MIXERCONTROLDETAILS_UNSIGNED mcd_u[ 2 ];
    LARGE_INTEGER                li;

    if( DeviceNumber == (ULONG) -1 ) {
        RETURN( STATUS_INVALID_PARAMETER );
    }

    if( DeviceType == WaveOutDevice ) {
        PWAVEDEVICE paWaveOutDevs = pWdmaContext->WaveOutDevs;

        mcd_u[ 0 ].dwValue = LeftChannel;
        mcd_u[ 1 ].dwValue = RightChannel;

        mcd.cbStruct       = sizeof( MIXERCONTROLDETAILS );
        mcd.dwControlID    = paWaveOutDevs[ DeviceNumber ].dwVolumeID;
        mcd.cChannels      = paWaveOutDevs[ DeviceNumber ].cChannels;
        mcd.cMultipleItems = 0;
        mcd.cbDetails      = mcd.cChannels *
                                sizeof( MIXERCONTROLDETAILS_UNSIGNED );
        mcd.paDetails      = &mcd_u[0];

        return( MapMmSysError(kmxlSetControlDetails( pWdmaContext,
                                       paWaveOutDevs[ DeviceNumber ].DeviceInterface,
                                       &mcd,
                                       0
                                     ))
              );
    }

    if( DeviceType == MidiOutDevice ) {
        PMIDIDEVICE paMidiOutDevs = pWdmaContext->MidiOutDevs;

        //
        //  We don't support volume changes on a MIDIPORT
        //
        if ( paMidiOutDevs[ DeviceNumber ].MusicDataRanges ) {
            WORD wTechnology;

            wTechnology = GetMidiTechnology( (PKSDATARANGE_MUSIC)
              &paMidiOutDevs[ DeviceNumber ].MusicDataRanges->aDataRanges[0] );

            if (wTechnology == MOD_MIDIPORT) {
                RETURN( STATUS_INVALID_DEVICE_REQUEST );
            }
        }

        mcd_u[ 0 ].dwValue = LeftChannel;
        mcd_u[ 1 ].dwValue = RightChannel;

        mcd.cbStruct       = sizeof( MIXERCONTROLDETAILS );
        mcd.dwControlID    = paMidiOutDevs[ DeviceNumber ].dwVolumeID;
        mcd.cChannels      = paMidiOutDevs[ DeviceNumber ].cChannels;
        mcd.cMultipleItems = 0;
        mcd.cbDetails      = mcd.cChannels *
                                sizeof( MIXERCONTROLDETAILS_UNSIGNED );
        mcd.paDetails      = &mcd_u[0];

        return( MapMmSysError(kmxlSetControlDetails( pWdmaContext,
                                       paMidiOutDevs[ DeviceNumber ].DeviceInterface,
                                       &mcd,
                                       0
                                     ))
              );
    }

    if( DeviceType == AuxDevice ) {
        PAUXDEVICE paAuxDevs = pWdmaContext->AuxDevs;

        mcd_u[ 0 ].dwValue = LeftChannel;
        mcd_u[ 1 ].dwValue = RightChannel;

        mcd.cbStruct       = sizeof( MIXERCONTROLDETAILS );
        mcd.dwControlID    = paAuxDevs[ DeviceNumber ].dwVolumeID;
        mcd.cChannels      = paAuxDevs[ DeviceNumber ].cChannels;
        mcd.cMultipleItems = 0;
        mcd.cbDetails      = mcd.cChannels *
                                 sizeof( MIXERCONTROLDETAILS_UNSIGNED );
        mcd.paDetails      = &mcd_u[0];

        return( MapMmSysError(kmxlSetControlDetails( pWdmaContext,
                                       paAuxDevs[ DeviceNumber ].DeviceInterface,
                                       &mcd,
                                       0
                                     ))
              );
     }

     return( STATUS_SUCCESS );
}

VOID
SetVolumeDpc(
    IN PKDPC pDpc,
    IN PWAVEDEVICE pWaveDevice,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
)
{
    QueueWorkList(pWaveDevice->pWdmaContext, SetVolumeWorker, pWaveDevice, NULL ) ;
}

VOID
SetVolumeWorker(
    IN PWAVEDEVICE pDevice,
    IN PVOID pNotUsed
)
{
    MIXERCONTROLDETAILS          mcd;
    MIXERCONTROLDETAILS_UNSIGNED mcd_u[ 2 ];

    DPF(DL_TRACE|FA_WAVE,( "Left %X Right %X",
               pDevice->LeftVolume,
               pDevice->RightVolume ) );

    pDevice->fNeedToSetVol = FALSE;

    mcd_u[ 0 ].dwValue = pDevice->LeftVolume;
    mcd_u[ 1 ].dwValue = pDevice->RightVolume;

    mcd.cbStruct       = sizeof( MIXERCONTROLDETAILS );
    mcd.dwControlID    = pDevice->dwVolumeID;
    mcd.cChannels      = pDevice->cChannels;
    mcd.cMultipleItems = 0;
    mcd.cbDetails      = mcd.cChannels * sizeof( MIXERCONTROLDETAILS_UNSIGNED );
    mcd.paDetails      = &mcd_u[0];

    kmxlSetControlDetails( pDevice->pWdmaContext,
                           pDevice->DeviceInterface,
                           &mcd,
                           0
                         );
}

#pragma PAGEABLE_CODE

NTSTATUS
GetVolume(
    IN  PWDMACONTEXT pWdmaContext,
    IN  DWORD DeviceNumber,
    IN  DWORD  DeviceType,
    OUT PDWORD LeftChannel,
    OUT PDWORD RightChannel
)
{
    MIXERCONTROLDETAILS          mcd;
    MIXERCONTROLDETAILS_UNSIGNED mcd_u[ 2 ];
    MMRESULT                     mmr;

    PAGED_CODE();
    if( DeviceType == WaveOutDevice ) {
        PWAVEDEVICE pWaveOutDevice = &pWdmaContext->WaveOutDevs[DeviceNumber];

         if( ( pWaveOutDevice->LeftVolume != 0x4321 ) &&
             ( pWaveOutDevice->RightVolume != 0x6789 ) ) {

              *LeftChannel = pWaveOutDevice->LeftVolume;
              *RightChannel = pWaveOutDevice->RightVolume;
              return( STATUS_SUCCESS );

         } else {

              mcd.cbStruct       = sizeof( MIXERCONTROLDETAILS );
              mcd.dwControlID    = pWaveOutDevice->dwVolumeID;
              mcd.cChannels      = pWaveOutDevice->cChannels;
              mcd.cMultipleItems = 0;
              mcd.cbDetails      = mcd.cChannels *
                                    sizeof( MIXERCONTROLDETAILS_UNSIGNED );
              mcd.paDetails      = &mcd_u[0];

              mmr = kmxlGetControlDetails( pWdmaContext,
                                           pWaveOutDevice->DeviceInterface,
                                           &mcd,
                                           0 );

              if( mmr == MMSYSERR_NOERROR )
              {
                *LeftChannel  = mcd_u[ 0 ].dwValue;
                *RightChannel = mcd_u[ 1 ].dwValue;
              }

              return( MapMmSysError(mmr) );
         }

    }

    if( DeviceType == MidiOutDevice ) {
        PMIDIDEVICE pMidiOutDevice = &pWdmaContext->MidiOutDevs[DeviceNumber];

        //
        //  We don't support volume changes on a MIDIPORT
        //
        if ( pMidiOutDevice->MusicDataRanges ) {
            WORD wTechnology;

            wTechnology = GetMidiTechnology( (PKSDATARANGE_MUSIC)
              &pMidiOutDevice->MusicDataRanges->aDataRanges[0] );

            if (wTechnology == MOD_MIDIPORT) {
                RETURN( STATUS_INVALID_DEVICE_REQUEST );
            }
        }

        mcd.cbStruct       = sizeof( MIXERCONTROLDETAILS );
        mcd.dwControlID    = pMidiOutDevice->dwVolumeID;
        mcd.cChannels      = pMidiOutDevice->cChannels;
        mcd.cMultipleItems = 0;
        mcd.cbDetails      = mcd.cChannels *
                               sizeof( MIXERCONTROLDETAILS_UNSIGNED );
        mcd.paDetails      = &mcd_u[0];

        mmr = kmxlGetControlDetails( pWdmaContext,
                                     pMidiOutDevice->DeviceInterface,
                                     &mcd,
                                     0 );

        if( mmr == MMSYSERR_NOERROR )
        {
            *LeftChannel  = mcd_u[ 0 ].dwValue;
            *RightChannel = mcd_u[ 1 ].dwValue;
        }

        return( MapMmSysError(mmr) );
    }

    if( DeviceType == AuxDevice ) {
        PAUXDEVICE pAuxDevice = &pWdmaContext->AuxDevs[DeviceNumber];

        mcd.cbStruct       = sizeof( MIXERCONTROLDETAILS );
        mcd.dwControlID    = pAuxDevice->dwVolumeID;
        mcd.cChannels      = pAuxDevice->cChannels;
        mcd.cMultipleItems = 0;
        mcd.cbDetails      = mcd.cChannels *
                               sizeof( MIXERCONTROLDETAILS_UNSIGNED );
        mcd.paDetails      = &mcd_u[0];

        mmr = kmxlGetControlDetails( pWdmaContext,
                                     pAuxDevice->DeviceInterface,
                                     &mcd,
                                     0 );

        if( mmr == MMSYSERR_NOERROR )
        {
           *LeftChannel  = mcd_u[ 0 ].dwValue;
           *RightChannel = mcd_u[ 1 ].dwValue;
        }

        return( MapMmSysError(mmr) );
    }
    RETURN( STATUS_INVALID_PARAMETER );
}

//
// This routine waits for the Io to complete on the device after telling
// the device to stop.
//
VOID
WaitForOutStandingIo(
    IN PWAVEDEVICE        pWaveDevice,
    IN PWAVE_PIN_INSTANCE pCurWavePin
    )
{
    if( pCurWavePin->DataFlow == KSPIN_DATAFLOW_IN)
    {
        //
        // We have a wave out pin to close.  Force pending data
        // to come back on running pins.  Non-running pins are
        // ignored on this call.
        //
        ResetWaveOutPin( pWaveDevice, pCurWavePin->WaveHandle);

    } else {
        //
        // We have a wave in pin to close
        //
        pCurWavePin->StoppingSource = TRUE ;

        //
        // We can not fail on this path.  Doesn't look like we need to make sure
        // that we're running here.
        //
        StatePin ( pCurWavePin->pFileObject, KSSTATE_STOP, &pCurWavePin->PinState ) ;

        //
        // Regardless of the return code we're going to wait for all the 
        // irps to complete.  If the driver do not successfuly complete
        // the irps, we will hang waiting for them here.
        //

        if( pCurWavePin->NumPendingIos )
        {
            KeWaitForSingleObject ( &pCurWavePin->StopEvent,
                                    Executive,
                                    KernelMode,
                                    FALSE,
                                    NULL ) ;
        }

        //
        // Why do we have this KeClearEvent???
        //
        KeClearEvent ( &pCurWavePin->StopEvent );

        pCurWavePin->StoppingSource = FALSE ;
    }
}

//
// Replaces CleanupWaveOutPins and CleanupWaveInPins.
//
VOID 
CleanupWavePins(
    IN PWAVEDEVICE pWaveDevice
)
{
    PWAVE_PIN_INSTANCE pCurWavePin;
    PWAVE_PIN_INSTANCE pFreeWavePin;

    PAGED_CODE();

    while (pCurWavePin = pWaveDevice->pWavePin)
    {
        DPF(DL_TRACE|FA_WAVE, ("0x%08x", pCurWavePin));

        WaitForOutStandingIo(pWaveDevice,pCurWavePin);

        CloseWavePin( pCurWavePin );

        pFreeWavePin = pCurWavePin;
        pWaveDevice->pWavePin = pCurWavePin->Next;

        AudioFreeMemory( sizeof(WAVE_PIN_INSTANCE),&pFreeWavePin );
    }


}

VOID 
CleanupWaveDevices(
    IN  PWDMACONTEXT pWdmaContext
)
{
    DWORD              DeviceNumber;

    PAGED_CODE();
    for (DeviceNumber = 0; DeviceNumber < MAXNUMDEVS; DeviceNumber++)
    {
        //
        //  Handle waveout devices first...
        //
        if (pWdmaContext->apCommonDevice[WaveOutDevice][DeviceNumber]->Device != UNUSED_DEVICE)
        {
            if ( pWdmaContext->WaveOutDevs[DeviceNumber].pTimer != NULL)
                KeCancelTimer(pWdmaContext->WaveOutDevs[DeviceNumber].pTimer);

            CleanupWavePins(&pWdmaContext->WaveOutDevs[DeviceNumber]);

            //
            // Sense we have removed it from the list, the other routine that would do
            // the same thing (RemoveDevNode) will also attempt to remove it from the
            // the list because the value it non-null.  Thus, the only safe thing that
            // we can do here is free the memory.
            //
            // Note: This routine will only get called when the handle to the driver is
            // closed.
            //

            AudioFreeMemory_Unknown(&pWdmaContext->WaveOutDevs[DeviceNumber].pTimer);
        }

        //
        //  ...then handle wavein devices
        //
        if (pWdmaContext->apCommonDevice[WaveInDevice][DeviceNumber]->Device != UNUSED_DEVICE)
        {
            CleanupWavePins(&pWdmaContext->WaveInDevs[DeviceNumber]);
        }
    }
}

#pragma LOCKED_CODE
#pragma LOCKED_DATA

//
// --------------------------------------------------------------------------------
//
// The following routines are used by more then just wave.c
//
// --------------------------------------------------------------------------------
//

NTSTATUS 
wdmaudPrepareIrp(
    PIRP                     pIrp,
    ULONG                    IrpDeviceType,
    PWDMACONTEXT             pContext,
    PWDMAPENDINGIRP_CONTEXT *ppPendingIrpContext
)
{
    return AddIrpToPendingList( pIrp,
                                IrpDeviceType,
                                pContext,
                                ppPendingIrpContext );
}

NTSTATUS 
wdmaudUnprepareIrp(
    PIRP                    pIrp,
    NTSTATUS                IrpStatus,
    ULONG_PTR               Information,
    PWDMAPENDINGIRP_CONTEXT pPendingIrpContext
)
{
    NTSTATUS Status;

    // Note that the IrpContext may have been zero'ed out already because the cancel
    // routine has already been called.  The cancel safe queue API zeroes out the Irp
    // field in the context when it performs a cancel.
    Status = RemoveIrpFromPendingList( pPendingIrpContext );
    if (NT_SUCCESS(Status)) {

        pIrp->IoStatus.Status = IrpStatus;

        if (Information) {
            pIrp->IoStatus.Information = Information;
        }

        IoCompleteRequest( pIrp, IO_NO_INCREMENT );
    }

    RETURN( Status );
}


#pragma PAGEABLE_CODE
#pragma PAGEABLE_DATA

//
// StatePin - This is used by both Midi and Wave functionality.
//
// On success State will get updated to the new state.  Must make sure that
// fGraphRunning is TRUE before calling this routine.
//
// call like: 
// if( pWavePin->fGraphRunning )
//     StatePin(pWavePin->pFileObject, KSSTATE_PAUSE, &pWavePin->State);
//
NTSTATUS 
StatePin(
    IN PFILE_OBJECT pFileObject,
    IN KSSTATE      State,
    OUT PKSSTATE    pResultingState
)
{
    NTSTATUS Status;

    PAGED_CODE();

    Status = PinProperty(pFileObject,
                         &KSPROPSETID_Connection,
                         KSPROPERTY_CONNECTION_STATE,
                         KSPROPERTY_TYPE_SET,
                         sizeof(State),
                         &State);
    if(NT_SUCCESS(Status))
    {
        *pResultingState = State;
    }
    RETURN( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\legacy\wdmaud.sys\sysaudio.c ===
/****************************************************************************
 *
 *   sysaudio.c
 *
 *   System Audio Device (SAD) interfaces
 *
 *   Copyright (C) Microsoft Corporation, 1997 - 1999  All Rights Reserved.
 *
 *   History
 *      5-12-97 - Mike McLaughlin (MikeM)
 *      5-19-97 - Noel Cross (NoelC)
 *
 ***************************************************************************/

#include "wdmsys.h"
#include <wdmguid.h>

static const WCHAR MediaCategories[] = L"\\Registry\\Machine\\SYSTEM\\CurrentControlSet\\Control\\MediaCategories\\";
static const WCHAR NodeNameValue[] =   L"Name";

#pragma PAGEABLE_DATA

ULONG gMidiPreferredDeviceNumber = MAXULONG;
ULONG gWavePreferredSysaudioDevice = MAXULONG;

#pragma PAGEABLE_CODE
#pragma PAGEABLE_DATA

int MyWcsicmp(const wchar_t *pwstr1, const wchar_t *pwstr2)
{
    PAGED_CODE();
    if (!pwstr1) {
        DPF( DL_TRACE|FA_SYSAUDIO,("pwstr1 == NULL"));
        return (-1);
    }

    if (!pwstr2) {
        DPF( DL_TRACE|FA_SYSAUDIO, ("pwstr2 == NULL"));
        return (-1);
    }

    return _wcsicmp(pwstr1, pwstr2);
}

extern
DWORD
_cdecl
_NtKernPhysicalDeviceObjectToDevNode(
        IN PDEVICE_OBJECT PhysicalDeviceObject
);

#ifndef IO_NO_PARAMETER_CHECKING
#define IO_NO_PARAMETER_CHECKING        0x0100
NTKERNELAPI NTSTATUS IoCreateFile
(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER AllocationSize OPTIONAL,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG Disposition,
    IN ULONG CreateOptions,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength,
    IN CREATE_FILE_TYPE CreateFileType,
    IN PVOID ExtraCreateParameters OPTIONAL,
    IN ULONG Options
    );
#endif // !IO_NO_PARAMETER_CHECKING

NTSTATUS OpenSysAudioPin
(
    ULONG          Device,
    ULONG          PinId,
    KSPIN_DATAFLOW DataFlowRequested,
    PKSPIN_CONNECT pPinConnect,
    PFILE_OBJECT *ppFileObjectPin,
    PDEVICE_OBJECT *ppDeviceObjectPin,
    PCONTROLS_LIST pControlList
)
{
    PFILE_OBJECT pFileObjectDevice = NULL;
    KSPIN_COMMUNICATION Communication;
    HANDLE hDevice = NULL;
    HANDLE hPin = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();
    Status = OpenSysAudio(&hDevice, &pFileObjectDevice);

    if(!NT_SUCCESS(Status))
    {
        goto exit;
    }

    //
    // Set the default renderer
    //
    Status = SetSysAudioProperty(pFileObjectDevice,
                                 KSPROPERTY_SYSAUDIO_DEVICE_INSTANCE,
                                 sizeof(Device),
                                 &Device);
    if(!NT_SUCCESS(Status))
    {
        goto exit;
    }

    Status = GetPinProperty(pFileObjectDevice,
                            KSPROPERTY_PIN_COMMUNICATION,
                            PinId,
                            sizeof(KSPIN_COMMUNICATION),
                            &Communication);
    if(!NT_SUCCESS(Status))
    {
        goto exit;
    }

    if(Communication != KSPIN_COMMUNICATION_SINK &&
       Communication != KSPIN_COMMUNICATION_BOTH)
    {
        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto exit;
    }

    pPinConnect->PinId = PinId;
    pPinConnect->PinToHandle = NULL;

    if (DataFlowRequested == KSPIN_DATAFLOW_OUT)
    {
        Status = KsCreatePin(hDevice,
                             pPinConnect,
                             GENERIC_READ,
                             &hPin);
    }
    else // KSPIN_DATAFLOW_OUT
    {
        Status = KsCreatePin(hDevice,
                             pPinConnect,
                             GENERIC_WRITE,
                             &hPin);
    }

    if(!NT_SUCCESS(Status))
    {
        if(STATUS_NO_MATCH == Status)
        {
            Status = STATUS_INVALID_DEVICE_REQUEST;
        }
        hPin = NULL;
        goto exit;
    }

    Status = ObReferenceObjectByHandle(hPin,
                                       GENERIC_READ | GENERIC_WRITE,
                                       NULL,
                                       KernelMode,
                                       ppFileObjectPin,
                                       NULL);
    if(!NT_SUCCESS(Status))
    {
        DPF(DL_WARNING|FA_SYSAUDIO,("ObReferenceObjectByHandle failed Status=%X",Status) ); 
        goto exit;
    }

    GetControlNodes ( pFileObjectDevice,
                      *ppFileObjectPin,
                      PinId,
                      pControlList ) ;

    *ppDeviceObjectPin = IoGetRelatedDeviceObject(*ppFileObjectPin);

exit:
    if(hPin != NULL)
    {
        NtClose(hPin);
    }
    if(pFileObjectDevice != NULL)
    {
        ObDereferenceObject(pFileObjectDevice);
    }
    if(hDevice != NULL)
    {
        NtClose(hDevice);
    }
    RETURN(Status);
}

VOID CloseSysAudio
(
    PWDMACONTEXT pWdmaContext,
    PFILE_OBJECT pFileObjectPin
)
{
    ULONG d;

    PAGED_CODE();
    ObDereferenceObject(pFileObjectPin);
    UpdatePreferredDevice(pWdmaContext);
}

NTSTATUS OpenSysAudio
(
    PHANDLE pHandle,
    PFILE_OBJECT *ppFileObject
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PWSTR pwstrSymbolicLinkList = NULL;
    PWSTR pwstr;

    PAGED_CODE();
    ASSERT(*pHandle == NULL);
    ASSERT(*ppFileObject == NULL);

    Status = IoGetDeviceInterfaces(
      &KSCATEGORY_SYSAUDIO,
      NULL,
      0,
      &pwstrSymbolicLinkList);

    if(!NT_SUCCESS(Status)) {
        DPF( DL_TRACE|FA_SYSAUDIO, ("IoGetDeviceInterfaces failed: Status=%08x", Status));
        goto exit;
    }

    // There is a double UNICODE_NULL at the end of the list
    pwstr = pwstrSymbolicLinkList;
    while(*pwstr != UNICODE_NULL) {

        Status = OpenDevice(pwstr, pHandle);
        if(NT_SUCCESS(Status)) {
            break;
        }
        ASSERT(*pHandle == NULL);

        // Get next symbolic link
        while(*pwstr++ != UNICODE_NULL);
    }

    if( NULL == *pHandle ) 
    {
        goto exit;
    }

    //
    //  Security-Penetration issue:
    //
    //  It has been brought up that using this handle is a security issue since in the time
    //  between creating the handle and now, the handle might be pointing to a different
    //  fileobject altogether.  I am assured that as long as I don't touch any of the fields
    //  in the file object and only send 'safe' Ioctls, this will not be a problem.
    //
    Status = ObReferenceObjectByHandle(
      *pHandle,
      FILE_READ_DATA | FILE_WRITE_DATA,
      *IoFileObjectType,
      ExGetPreviousMode(),
      ppFileObject,
      NULL);

    if(!NT_SUCCESS(Status)) {
        DPF( DL_TRACE|FA_SYSAUDIO, ("ObReferenceObjectByHandle failed: Status=%08x", Status));
        goto exit;
    }
exit:
    if(!NT_SUCCESS(Status)) {
        if(*ppFileObject != NULL) {
            ObDereferenceObject(*ppFileObject);
            *ppFileObject = NULL;
        }
        if(*pHandle != NULL) {
            NtClose(*pHandle);
            *pHandle = NULL;
        }
    }
    AudioFreeMemory_Unknown(&pwstrSymbolicLinkList);
    RETURN(Status);
}

NTSTATUS OpenDevice
(
    PWSTR pwstrDevice,
    PHANDLE pHandle
)
{
    IO_STATUS_BLOCK     IoStatusBlock;
    UNICODE_STRING      UnicodeDeviceString;
    OBJECT_ATTRIBUTES   ObjectAttributes;

    PAGED_CODE();
    RtlInitUnicodeString(&UnicodeDeviceString, pwstrDevice);

    InitializeObjectAttributes(
      &ObjectAttributes,
      &UnicodeDeviceString,
      0,
      NULL,
      NULL);

    return(IoCreateFile(
        pHandle,
        GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
        &ObjectAttributes,
        &IoStatusBlock,
        NULL,
        0,
        0,
        FILE_OPEN,
        FILE_SYNCHRONOUS_IO_NONALERT,
        NULL,
        0,
        CreateFileTypeNone,
        NULL,
        IO_FORCE_ACCESS_CHECK | IO_NO_PARAMETER_CHECKING));
}

NTSTATUS GetPinProperty
(
    PFILE_OBJECT pFileObject,
    ULONG PropertyId,
    ULONG PinId,
    ULONG cbProperty,
    PVOID pProperty
)
{
    ULONG BytesReturned;
    KSP_PIN Property;
    NTSTATUS Status = STATUS_INVALID_PARAMETER;

    PAGED_CODE();
    if (pFileObject)
    {
        Property.Property.Set = KSPROPSETID_Pin;
        Property.Property.Id = PropertyId;
        Property.Property.Flags = KSPROPERTY_TYPE_GET;
        Property.PinId = PinId;
        Property.Reserved = 0;

        DPF( DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY Property.Id=%X, PinId=%X",
                                   PropertyId, PinId) );

        Status = KsSynchronousIoControlDevice(
          pFileObject,
          KernelMode,
          IOCTL_KS_PROPERTY,
          &Property,
          sizeof(Property),
          pProperty,
          cbProperty,
          &BytesReturned);

        DPF( DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY results Status=%X, pProperty=%X,cbProperty=%X,BytesRet=%d",
                                   Status,pProperty,cbProperty,BytesReturned) );

        if(!NT_SUCCESS(Status)) {
            DPF(DL_WARNING|FA_SYSAUDIO,("Property query failed Status=%X",Status) );
            goto exit;
        }
        ASSERT(BytesReturned == cbProperty);
    }
exit:
    RETURN(Status);
}

NTSTATUS GetPinPropertyEx
(
    PFILE_OBJECT    pFileObject,
    ULONG           PropertyId,
    ULONG           PinId,
    PVOID           *ppProperty
)
{
    ULONG       BytesReturned;
    NTSTATUS    Status = STATUS_INVALID_PARAMETER;
    KSP_PIN     Pin;

    PAGED_CODE();
    if (pFileObject)
    {
        Pin.Property.Set    = KSPROPSETID_Pin;
        Pin.Property.Id     = PropertyId;
        Pin.Property.Flags  = KSPROPERTY_TYPE_GET;
        Pin.PinId           = PinId;
        Pin.Reserved        = 0;

        DPF( DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY Property.Id=%X, PinId=%X",
                                   PropertyId, PinId) );

        Status = KsSynchronousIoControlDevice(
          pFileObject,
          KernelMode,
          IOCTL_KS_PROPERTY,
          &Pin,
          sizeof(KSP_PIN),
          NULL,
          0,
          &BytesReturned);

        DPF( DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY results Status=%X,BytesRet=%d",
                                   Status,BytesReturned) );

        ASSERT(!NT_SUCCESS(Status));
        if(Status != STATUS_BUFFER_OVERFLOW) {
            //
            // The driver should have returned the number of bytes that we needed 
            // to allocate and STATUS_BUFFER_OVERFLOW.  But, if they returned a
            // successful error code, we must not return success.  Thus, we're making
            // up a new return code - STATUS_INVALID_BUFFER_SIZE.
            //
            if( NT_SUCCESS(Status) )
                Status = STATUS_INVALID_BUFFER_SIZE;

            goto exit;
        }

        if(BytesReturned == 0)
        {
            Status = STATUS_BUFFER_TOO_SMALL;
            goto exit;
        }

        Status = AudioAllocateMemory_Paged(BytesReturned,
                                           TAG_AudQ_PROPERTY,
                                           ZERO_FILL_MEMORY,
                                           ppProperty  );
        if(!NT_SUCCESS(Status))
        {
            goto exit;
        }

        DPF( DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY Property.Id=%X, PinId=%X",
                                   PropertyId, PinId) );

        Status = KsSynchronousIoControlDevice(
          pFileObject,
          KernelMode,
          IOCTL_KS_PROPERTY,
          &Pin,
          sizeof(KSP_PIN),
          *ppProperty,
          BytesReturned,
          &BytesReturned);

        DPF( DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY results Status=%X,BytesRet=%d",
                                   Status,BytesReturned) );

        if(!NT_SUCCESS(Status))
        {
            AudioFreeMemory_Unknown(ppProperty);
            goto exit;
        }
    }

exit:
    if( !NT_SUCCESS(Status) )
    {
        *ppProperty = NULL;
    }

    RETURN(Status);
}

VOID GetControlNodes
(
   PFILE_OBJECT   pDeviceFileObject,
   PFILE_OBJECT   pPinFileObject,
   ULONG          PinId,
   PCONTROLS_LIST pControlList
)
{
   ULONG   i ;

   PAGED_CODE();
   if ( pControlList == NULL )
   {
       return ;
   }

   for ( i = 0; i < pControlList->Count; i++ ) \
   {
       pControlList->Controls[i].NodeId =
                   ControlNodeFromGuid (
                            pDeviceFileObject,
                            pPinFileObject,
                            PinId,
                            &pControlList->Controls[i].Control ) ;
   }
}

ULONG ControlNodeFromGuid
(
   PFILE_OBJECT  pDeviceFileObject,
   PFILE_OBJECT  pPinFileObject,
   ULONG         PinId,
   GUID*         NodeType
)
{
   ULONG                   NumNodes, NumConnections ;
   ULONG                   FirstConnectionIndex ;
   PKSMULTIPLE_ITEM        pNodeItems, pConnectionItems ;
   GUID*                   pNodes ;
   PKSTOPOLOGY_CONNECTION  pConnections, pConnection ;
   ULONG                   NodeId ;

   PAGED_CODE();
   // assume there are no nodes
   NodeId = INVALID_NODE ;
   pNodeItems = NULL ;
   pConnectionItems = NULL ;

   // Get the array of Node GUIDs
   pNodeItems = GetTopologyProperty ( pDeviceFileObject,
                                  KSPROPERTY_TOPOLOGY_NODES ) ;

   if ( pNodeItems == NULL )
   {
       DPF(DL_WARNING|FA_SYSAUDIO,("GetTopologyProperty NODES failed") );
       goto exit ;
   }

   NumNodes = pNodeItems->Count ;
   pNodes = (GUID *)(pNodeItems+1) ;

   // Get the array of Connections
   pConnectionItems = GetTopologyProperty ( pDeviceFileObject,
                                        KSPROPERTY_TOPOLOGY_CONNECTIONS ) ;

   if ( pConnectionItems == NULL )
   {
       DPF(DL_WARNING|FA_SYSAUDIO,("GetTopologyProperty CONNECTIONS failed") );
       goto exit ;
   }
   NumConnections = pConnectionItems->Count ;
   pConnections = (PKSTOPOLOGY_CONNECTION)(pConnectionItems+1) ;

   // First get the start connection for the given PinId

   FirstConnectionIndex = GetFirstConnectionIndex ( pPinFileObject ) ;

   if ( FirstConnectionIndex == 0xffffffff )
   {
       DPF(DL_WARNING|FA_SYSAUDIO,("GetFirstConnectionIndex failed") );
       goto exit ;
   }
   pConnection = pConnections + FirstConnectionIndex ;

   ASSERT ( pConnection ) ;

   // NOTE : Assumes DataFlowOut. Need to modify if we want to support
   //        Volume for wavein pins.

   while ((pConnection) && (pConnection->ToNode != KSFILTER_NODE) )
   {
       if ( pConnection->ToNode >= NumNodes )
       {
           ASSERT ( 0 ) ;
       }
       else
       {
           if (IsEqualGUID(&pNodes[pConnection->ToNode], NodeType))
           {
               NodeId = pConnection->ToNode ;
               break ;
           }
       }
       pConnection = FindConnection ( pConnections,
                                     NumConnections,
                                     pConnection->ToNode,
                                     0,
                                     WILD_CARD,
                                     WILD_CARD ) ;
   }

exit:
   AudioFreeMemory_Unknown( &pConnectionItems ) ;
   AudioFreeMemory_Unknown( &pNodeItems ) ;
   return ( NodeId ) ;
}

PVOID GetTopologyProperty
(
   PFILE_OBJECT  pDeviceFileObject,
   ULONG         PropertyId
)
{
   KSPROPERTY              Property ;
   PVOID                   pBuf = NULL;
   ULONG                   BytesReturned ;
   NTSTATUS                Status = STATUS_INVALID_PARAMETER;

   PAGED_CODE();
   BytesReturned = 0;
   pBuf = NULL ;

   if (pDeviceFileObject)
   {
       Property.Set = KSPROPSETID_Topology ;
       Property.Id = PropertyId ;
       Property.Flags = KSPROPERTY_TYPE_GET;

       DPF( DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY Property.Id=%X",
                                  PropertyId) );

       Status = KsSynchronousIoControlDevice(
         pDeviceFileObject,
         KernelMode,
         IOCTL_KS_PROPERTY,
         &Property,
         sizeof(Property),
         NULL,
         0,
         &BytesReturned);

       DPF( DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY results Status=%X, BytesRet=%d",
                                  Status,BytesReturned) );

       ASSERT(!NT_SUCCESS(Status));
       if(Status != STATUS_BUFFER_OVERFLOW) {
           DPF(DL_WARNING|FA_SYSAUDIO,("Failed Property query Status=%X",Status) );
           goto exit;
       }

       Status = AudioAllocateMemory_Paged(BytesReturned,
                                          TAG_Audq_PROPERTY,
                                          ZERO_FILL_MEMORY|LIMIT_MEMORY,
                                          &pBuf );
       if(!NT_SUCCESS(Status))
       {
           goto exit;
       }

       DPF( DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY Property.Id=%X",
                                  PropertyId) );

       Status = KsSynchronousIoControlDevice(
         pDeviceFileObject,
         KernelMode,
         IOCTL_KS_PROPERTY,
         &Property,
         sizeof(Property),
         pBuf,
         BytesReturned,
         &BytesReturned);

       DPF( DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY results Status=%X,pBuf=%X,BytesRet=%d",
                                  Status,pBuf,BytesReturned) );

       if(!NT_SUCCESS(Status))
       {
           DPF(DL_WARNING|FA_SYSAUDIO,("Failed Property query Status=%X",Status) );
           AudioFreeMemory_Unknown ( &pBuf ) ;
           goto exit;
       }
   }
exit:
   return pBuf ;
}

PKSTOPOLOGY_CONNECTION FindConnection
(
   PKSTOPOLOGY_CONNECTION pConnections,
   ULONG                  NumConnections,
   ULONG                  FromNode,
   ULONG                  FromPin,
   ULONG                  ToNode,
   ULONG                  ToPin
)
{
   PKSTOPOLOGY_CONNECTION pConnection ;
   ULONG i ;

   PAGED_CODE();
   pConnection = pConnections ;

   for ( i = 0; i < NumConnections; i++ )
   {
       if ( ((FromNode == WILD_CARD) || (FromNode == pConnection->FromNode)) &&
            ((FromPin == WILD_CARD) || (FromPin == pConnection->FromNodePin)) &&
            ((ToNode == WILD_CARD) || (ToNode == pConnection->ToNode)) &&
            ((ToPin == WILD_CARD) || (ToPin == pConnection->ToNodePin)) )
           return pConnection ;
       pConnection++ ;
   }
   return ( NULL ) ;
}

ULONG GetFirstConnectionIndex
(
   PFILE_OBJECT pPinFileObject
)
{
   KSPROPERTY              Property ;
   ULONG                   Index = 0xffffffff;
   ULONG                   BytesReturned ;
   NTSTATUS                Status = STATUS_INVALID_PARAMETER ;

   PAGED_CODE();
   if (pPinFileObject)
   {
       Property.Set = KSPROPSETID_Sysaudio_Pin ;
       Property.Id = KSPROPERTY_SYSAUDIO_TOPOLOGY_CONNECTION_INDEX ;
       Property.Flags = KSPROPERTY_TYPE_GET;

       DPF( DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY Property.Id=%X",
                                  Property.Id) );

       Status = KsSynchronousIoControlDevice(
         pPinFileObject,
         KernelMode,
         IOCTL_KS_PROPERTY,
         &Property,
         sizeof(Property),
         &Index,
         sizeof ( Index ),
         &BytesReturned);

       DPF( DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY results Status=%X, Index=%X,BytesRet=%d",
                                  Status,Index,BytesReturned) );
   }

   if(!NT_SUCCESS(Status))
   {
       DPF(DL_WARNING|FA_SYSAUDIO,("Failed Property query Status=%X",Status) );
       return ( 0xffffffff ) ;
   }
   return ( Index ) ;
}

VOID UpdatePreferredDevice
(
    PWDMACONTEXT pWdmaContext
)
{
    ULONG d;
    PAGED_CODE();
    //
    // This causes the preferred sysaudio device to be queried if there
    // are no open midi out streams.
    //
    for(d = 0; d < MAXNUMDEVS; d++)
    {
        if(pWdmaContext->MidiOutDevs[d].Device != UNUSED_DEVICE &&
           pWdmaContext->MidiOutDevs[d].pMidiPin                &&
           pWdmaContext->MidiOutDevs[d].pMidiPin->fGraphRunning)
        {
            return;
        }
    }
    pWdmaContext->PreferredSysaudioWaveDevice = gWavePreferredSysaudioDevice;
}

NTSTATUS SetPreferredDevice
(
    PWDMACONTEXT pContext,
    LPDEVICEINFO pDeviceInfo
)
{
    SYSAUDIO_PREFERRED_DEVICE Preferred;
    ULONG TranslatedDeviceNumber;
    ULONG SysaudioDevice;
    ULONG BytesReturned;
    NTSTATUS Status;

    PAGED_CODE();
    if(pContext->pFileObjectSysaudio == NULL) {
        Status = STATUS_SUCCESS;
        goto exit;
    }

    TranslatedDeviceNumber = wdmaudTranslateDeviceNumber(
      pContext,
      pDeviceInfo->DeviceType,
      pDeviceInfo->wstrDeviceInterface,
      pDeviceInfo->DeviceNumber);

    if(MAXULONG == TranslatedDeviceNumber) {
        DPF(DL_WARNING|FA_SYSAUDIO,("Invalid Device Number") );
        Status = STATUS_INVALID_PARAMETER;
        goto exit;
    }
    SysaudioDevice = pContext->apCommonDevice
      [pDeviceInfo->DeviceType][TranslatedDeviceNumber]->Device;

    switch(pDeviceInfo->DeviceType) {
        case WaveOutDevice:
            Preferred.Index = KSPROPERTY_SYSAUDIO_PLAYBACK_DEFAULT;
            gWavePreferredSysaudioDevice = SysaudioDevice;
            UpdatePreferredDevice(pContext);
            break;

        case WaveInDevice:
            Preferred.Index = KSPROPERTY_SYSAUDIO_RECORD_DEFAULT;
            break;

        case MidiOutDevice:
            Preferred.Index = KSPROPERTY_SYSAUDIO_MIDI_DEFAULT;
            gMidiPreferredDeviceNumber = TranslatedDeviceNumber;
            break;

        default:
            Status = STATUS_SUCCESS;
            goto exit;
    }
    Preferred.Property.Set = KSPROPSETID_Sysaudio;
    Preferred.Property.Id = KSPROPERTY_SYSAUDIO_PREFERRED_DEVICE;
    Preferred.Property.Flags = KSPROPERTY_TYPE_SET;

    if(pDeviceInfo->dwFlags == 0) {
        Preferred.Flags = 0;
    }
    else {
        Preferred.Flags = SYSAUDIO_FLAGS_CLEAR_PREFERRED;
        if(pDeviceInfo->DeviceType == WaveOutDevice) {
            gWavePreferredSysaudioDevice = MAXULONG;
        }
        else if(pDeviceInfo->DeviceType == MidiOutDevice) {
            gMidiPreferredDeviceNumber = MAXULONG;
        }
    }

    DPF( DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY Property.Id=%X, Preferred=%X",
                               Preferred,Preferred.Property.Id) );

    Status = KsSynchronousIoControlDevice(
      pContext->pFileObjectSysaudio,
      KernelMode,
      IOCTL_KS_PROPERTY,
      &Preferred,
      sizeof(Preferred),
      &SysaudioDevice,
      sizeof(SysaudioDevice),
      &BytesReturned);

    DPF( DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY results Status=%X, SysaudioDevice=%X,BytesRet=%d",
                               Status,SysaudioDevice,BytesReturned) );

    if(!NT_SUCCESS(Status)) {
        DPF(DL_WARNING|FA_SYSAUDIO,("Property Query failed Status=%X",Status) );
        goto exit;
    }
    if(pDeviceInfo->DeviceType == WaveOutDevice &&
       gMidiPreferredDeviceNumber != MAXULONG) {
        ULONG d;

        d = pContext->apCommonDevice[MidiOutDevice]
          [gMidiPreferredDeviceNumber]->PreferredDevice;

        if(d != MAXULONG &&
          (d == gMidiPreferredDeviceNumber ||
           pContext->apCommonDevice[MidiOutDevice][d]->PreferredDevice == d)) {

            Preferred.Index = KSPROPERTY_SYSAUDIO_MIDI_DEFAULT;

            DPF( DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY Property.Id=%X, Preferred=%X",
                                       Preferred,Preferred.Property.Id) );

            Status = KsSynchronousIoControlDevice(
              pContext->pFileObjectSysaudio,
              KernelMode,
              IOCTL_KS_PROPERTY,
              &Preferred,
              sizeof(Preferred),
              &SysaudioDevice,
              sizeof(SysaudioDevice),
              &BytesReturned);

            DPF( DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY results Status=%X, SysaudioDevice=%X,BytesRet=%d",
                                       Status,SysaudioDevice,BytesReturned) );

            if(!NT_SUCCESS(Status)) {
                DPF(DL_WARNING|FA_SYSAUDIO,("Property Query failed Status=%X",Status) );
                goto exit;
            }
        }
    }
exit:
    RETURN(Status);
}

NTSTATUS GetSysAudioProperty
(
    PFILE_OBJECT pFileObject,
    ULONG        PropertyId,
    ULONG        DeviceIndex,
    ULONG        cbProperty,
    PVOID        pProperty
)
{
    ULONG           BytesReturned;
    KSPROPERTYPLUS  Property;
    NTSTATUS        Status = STATUS_INVALID_PARAMETER;

    PAGED_CODE();
    if (pFileObject)
    {
        Property.Property.Set = KSPROPSETID_Sysaudio;
        Property.Property.Id = PropertyId;
        Property.Property.Flags = KSPROPERTY_TYPE_GET;
        Property.DeviceIndex = DeviceIndex;

        DPF( DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY Id=%X, DI=%X",PropertyId,DeviceIndex) );

        Status = KsSynchronousIoControlDevice(pFileObject,
                                              KernelMode,
                                              IOCTL_KS_PROPERTY,
                                              &Property,
                                              sizeof(Property),
                                              pProperty,
                                              cbProperty,
                                              &BytesReturned);

        DPF( DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY results Status=%X, pProperty=%X,cbProperty=%X,BytesRet=%d",
                                   Status,pProperty,cbProperty,BytesReturned) );
    }

    RETURN( Status );
}

NTSTATUS SetSysAudioProperty
(
    PFILE_OBJECT pFileObject,
    ULONG        PropertyId,
    ULONG        cbProperty,
    PVOID        pProperty
)
{
    ULONG      BytesReturned;
    KSPROPERTY Property;
    NTSTATUS   Status = STATUS_INVALID_PARAMETER;

    PAGED_CODE();
    if (pFileObject)
    {
        Property.Set = KSPROPSETID_Sysaudio;
        Property.Id = PropertyId;
        Property.Flags = KSPROPERTY_TYPE_SET;

        DPF( DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY Id=%X",
                                   PropertyId) );

        Status = KsSynchronousIoControlDevice(pFileObject,
                                              KernelMode,
                                              IOCTL_KS_PROPERTY,
                                              &Property,
                                              sizeof(Property),
                                              pProperty,
                                              cbProperty,
                                              &BytesReturned);

        DPF( DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY results Status=%X, pProperty=%X,cbProperty=%X,BytesRet=%d",
                                   Status,pProperty,cbProperty,BytesReturned) );
    }

    RETURN(Status);
}

DWORD wdmaudTranslateDeviceNumber
(
    PWDMACONTEXT pWdmaContext,
    DWORD        DeviceType,
    PCWSTR       DeviceInterface,
    DWORD        DeviceNumber
)
{
    PCOMMONDEVICE *ppCommonDevice;
    DWORD d, j;

    PAGED_CODE();
    ppCommonDevice = &pWdmaContext->apCommonDevice[DeviceType][0];

    for (d = 0; d < MAXNUMDEVS; d++ )
    {
        if (ppCommonDevice[d]->Device == UNUSED_DEVICE ||
            MyWcsicmp(ppCommonDevice[d]->DeviceInterface, DeviceInterface))
        {
            continue;
        }
        if(ppCommonDevice[d]->PreferredDevice == MAXULONG ||
           ppCommonDevice[d]->PreferredDevice == d)
        {
            if (DeviceNumber == 0)
            {
                if (ppCommonDevice[d]->PreferredDevice == d)
                {
                    if(pWdmaContext->PreferredSysaudioWaveDevice != MAXULONG)
                    {
                        for (j = 0; j < MAXNUMDEVS; j++)
                        {
                            if (j == d)
                                continue;

                            if (ppCommonDevice[j]->PreferredDevice == d &&
                                ppCommonDevice[j]->Device ==
                                  pWdmaContext->PreferredSysaudioWaveDevice)
                            {
                                return j;
                            }
                        }
                    }
                }
                return d;
            }
            else
            {
                DeviceNumber--;
            }
        }
    }

    return MAXULONG;
}

int
CmpStr(
    PWSTR pwstr1,
    PWSTR pwstr2
)
{
    PAGED_CODE();
    if(pwstr1 == NULL && pwstr2 == NULL) {
        return(0);
    }
    if(pwstr1 == NULL || pwstr2 == NULL) {
        return(1);
    }
    return(wcscmp(pwstr1, pwstr2));
}

NTSTATUS AddDevice
(
    PWDMACONTEXT    pWdmaContext,
    ULONG           Device,
    DWORD           DeviceType,
    PCWSTR          DeviceInterface,
    ULONG           PinId,
    PWSTR           pwstrName,
    BOOL            fUsePreferred,
    PDATARANGES     pDataRanges,
    PKSCOMPONENTID  ComponentId
)
{
    PCOMMONDEVICE      *papCommonDevice;
    DWORD               DeviceNumber;
    DWORD               d;
    PKSDATARANGE_MUSIC  MusicDataRange;

    PAGED_CODE();
    switch(DeviceType)
    {
        case MidiOutDevice:
            MusicDataRange = (PKSDATARANGE_MUSIC)&pDataRanges->aDataRanges[0];
            if ( !IsEqualGUID( &KSMUSIC_TECHNOLOGY_SWSYNTH, &MusicDataRange->Technology ) )
            {
                fUsePreferred = FALSE;
            }
            break;

        case MidiInDevice:
            fUsePreferred = FALSE;
            break;

        default:
            // Do nothing
            break;
    }

    DPF( DL_TRACE|FA_SYSAUDIO, ("D# %02x DT %02x DI %ls PI %02x %01x",
      Device, DeviceType, DeviceInterface, PinId, fUsePreferred));

    papCommonDevice = &pWdmaContext->apCommonDevice[DeviceType][0];

    for (DeviceNumber = 0; DeviceNumber < MAXNUMDEVS; DeviceNumber++)
    {
        if (papCommonDevice[DeviceNumber]->Device != UNUSED_DEVICE &&
            !MyWcsicmp(papCommonDevice[DeviceNumber]->DeviceInterface, DeviceInterface) &&
            !CmpStr(papCommonDevice[DeviceNumber]->pwstrName, pwstrName))
        {
            papCommonDevice[DeviceNumber]->Device = Device;
            papCommonDevice[DeviceNumber]->PinId = PinId;
            ASSERT(
              (!fUsePreferred &&
               papCommonDevice[DeviceNumber]->PreferredDevice ==
                MAXULONG) ||
              (fUsePreferred &&
               papCommonDevice[DeviceNumber]->PreferredDevice !=
                MAXULONG));
            break;
        }
    }

    if (DeviceNumber < MAXNUMDEVS)
    {
        // We found an existing device that matches this one.  We need to free
        // some stuff before setting up the new stuff
        AudioFreeMemory_Unknown(&papCommonDevice[DeviceNumber]->pwstrName);
        AudioFreeMemory_Unknown(&papCommonDevice[DeviceNumber]->DeviceInterface);
        AudioFreeMemory_Unknown(&papCommonDevice[DeviceNumber]->ComponentId);
        switch (DeviceType)
        {
            case WaveOutDevice:
                AudioFreeMemory_Unknown(&pWdmaContext->WaveOutDevs[DeviceNumber].AudioDataRanges);
                break;
            case WaveInDevice:
                AudioFreeMemory_Unknown(&pWdmaContext->WaveInDevs[DeviceNumber].AudioDataRanges);
                break;
            case MidiOutDevice:
                AudioFreeMemory_Unknown(&pWdmaContext->MidiOutDevs[DeviceNumber].MusicDataRanges);
                break;
            case MidiInDevice:
                AudioFreeMemory_Unknown(&pWdmaContext->MidiInDevs[DeviceNumber].MusicDataRanges);
                break;
        }
    } else {
        // We didn't find an existing device that matches the new one.  Search
        // for an unused slot in our device lists
        for (DeviceNumber = 0; DeviceNumber < MAXNUMDEVS; DeviceNumber++)
        {
            if (papCommonDevice[DeviceNumber]->Device == UNUSED_DEVICE)
                break;
        }
    }

    if (DeviceNumber == MAXNUMDEVS)
        RETURN( STATUS_INSUFFICIENT_RESOURCES );

    if (!NT_SUCCESS(AudioAllocateMemory_Paged((wcslen(DeviceInterface)+1)*sizeof(WCHAR),
                                              TAG_AudD_DEVICEINFO,
                                              DEFAULT_MEMORY,
                                              &papCommonDevice[DeviceNumber]->DeviceInterface)))
    {
        RETURN( STATUS_INSUFFICIENT_RESOURCES );
    }
    wcscpy(papCommonDevice[DeviceNumber]->DeviceInterface, DeviceInterface);

    papCommonDevice[DeviceNumber]->Device = Device;
    papCommonDevice[DeviceNumber]->PinId = PinId;
    papCommonDevice[DeviceNumber]->pwstrName = pwstrName;
    papCommonDevice[DeviceNumber]->PreferredDevice = MAXULONG;
    papCommonDevice[DeviceNumber]->ComponentId = ComponentId;

    switch(DeviceType)
    {
        case WaveOutDevice:
            pWdmaContext->WaveOutDevs[DeviceNumber].AudioDataRanges = pDataRanges;
            break;

        case WaveInDevice:
            pWdmaContext->WaveInDevs[DeviceNumber].AudioDataRanges= pDataRanges;
            break;

        case MidiOutDevice:
            pWdmaContext->MidiOutDevs[DeviceNumber].MusicDataRanges = pDataRanges;
            break;

        case MidiInDevice:
            pWdmaContext->MidiInDevs[DeviceNumber].MusicDataRanges = pDataRanges;
            break;

        case AuxDevice:
            break;

        default:
            ASSERT(FALSE);
            RETURN(STATUS_INVALID_PARAMETER);
    }

    if (fUsePreferred)
    {
        papCommonDevice[DeviceNumber]->PreferredDevice =
          DeviceNumber;

        for (d = 0; d < MAXNUMDEVS; d++)
        {
            if (d == DeviceNumber)
                continue;

            if (papCommonDevice[d]->Device == UNUSED_DEVICE)
                continue;

            if (papCommonDevice[d]->PreferredDevice != d)
                continue;

            if(CmpStr(papCommonDevice[d]->pwstrName, pwstrName) != 0)
                continue;

            papCommonDevice[DeviceNumber]->PreferredDevice = d;
            ASSERT(papCommonDevice[d]->PreferredDevice == d);
            break;
        }
    }

    return STATUS_SUCCESS;
}

WORD GetMidiTechnology
(
    PKSDATARANGE_MUSIC   MusicDataRange
)
{
    WORD Technology = MOD_MIDIPORT; // default to MIDIPORT

    PAGED_CODE();
    if ( IsEqualGUID( &KSMUSIC_TECHNOLOGY_FMSYNTH,
                      &MusicDataRange->Technology ) )
    {
        Technology = MOD_FMSYNTH;
    }
    else if ( IsEqualGUID( &KSMUSIC_TECHNOLOGY_WAVETABLE,
                           &MusicDataRange->Technology ) )
    {
        Technology = MOD_WAVETABLE;
    }
    else if ( IsEqualGUID( &KSMUSIC_TECHNOLOGY_SWSYNTH,
                           &MusicDataRange->Technology ) )
    {
        Technology = MOD_SWSYNTH;
    }
    else if ( IsEqualGUID( &KSMUSIC_TECHNOLOGY_SQSYNTH,
                           &MusicDataRange->Technology ) )
    {
        Technology = MOD_SQSYNTH;
    }
    else if ( IsEqualGUID( &KSMUSIC_TECHNOLOGY_PORT,
                           &MusicDataRange->Technology ) )
    {
        Technology = MOD_MIDIPORT;
    }

    return Technology;
}

DWORD GetFormats
(
    PKSDATARANGE_AUDIO  AudioDataRange
)
{
    DWORD   dwSamples = 0;
    DWORD   dwChannels = 0;
    DWORD   dwBits = 0;

    PAGED_CODE();
    // The WAVE_FORMAT_XXXX flags are bit flags
    //
    // So we take advantage of that by determining three
    // sets of information:
    // - frequencies that are in the valid range
    // - valid bits per sample
    // - number of channels
    //
    // We than bitwise-AND the three values to get
    // the intersection of valid formats
    //

    // Is 11.025 KHz valid?
    if (AudioDataRange->MinimumSampleFrequency <= 11025 &&
        AudioDataRange->MaximumSampleFrequency >= 11025)
    {
        dwSamples |= WAVE_FORMAT_1M08 | WAVE_FORMAT_1S08 | WAVE_FORMAT_1M16 | WAVE_FORMAT_1S16;
    }

    // Is 22.05 KHz valid?
    if (AudioDataRange->MinimumSampleFrequency <= 22050 &&
        AudioDataRange->MaximumSampleFrequency >= 22050)
    {
        dwSamples |= WAVE_FORMAT_2M08 | WAVE_FORMAT_2S08 | WAVE_FORMAT_2M16 | WAVE_FORMAT_2S16;
    }

    // Is 44.1KHz valid?
    if (AudioDataRange->MinimumSampleFrequency <= 44100 &&
        AudioDataRange->MaximumSampleFrequency >= 44100)
    {
        dwSamples |= WAVE_FORMAT_44M08 | WAVE_FORMAT_44S08 | WAVE_FORMAT_44M16 | WAVE_FORMAT_44S16;
    }

    // Is 48 KHz valid?
    if (AudioDataRange->MinimumSampleFrequency <= 48000 &&
        AudioDataRange->MaximumSampleFrequency >= 48000)
    {
        dwSamples |= WAVE_FORMAT_48M08 | WAVE_FORMAT_48S08 | WAVE_FORMAT_48M16 | WAVE_FORMAT_48S16;
    }

    // Is 96 KHz valid?
    if (AudioDataRange->MinimumSampleFrequency <= 96000 &&
        AudioDataRange->MaximumSampleFrequency >= 96000)
    {
        dwSamples |= WAVE_FORMAT_96M08 | WAVE_FORMAT_96S08 | WAVE_FORMAT_96M16 | WAVE_FORMAT_96S16;
    }

    // Is 8 bit per sample valid?
    if (AudioDataRange->MinimumBitsPerSample <= 8 &&
        AudioDataRange->MaximumBitsPerSample >= 8)
    {
        dwBits |= WAVE_FORMAT_1M08  | WAVE_FORMAT_1S08  | WAVE_FORMAT_2M08  |
                  WAVE_FORMAT_2S08  | WAVE_FORMAT_44M08 | WAVE_FORMAT_44S08 |
                  WAVE_FORMAT_48M08 | WAVE_FORMAT_48S08 | WAVE_FORMAT_96M08 |
                  WAVE_FORMAT_96S08;
    }

    // Is 16 bits per sample valid?
    if (AudioDataRange->MinimumBitsPerSample <= 16 &&
        AudioDataRange->MaximumBitsPerSample >= 16)
    {
        dwBits |= WAVE_FORMAT_1M16  | WAVE_FORMAT_1S16  | WAVE_FORMAT_2M16  |
                  WAVE_FORMAT_2S16  | WAVE_FORMAT_44M16 | WAVE_FORMAT_44S16 |
                  WAVE_FORMAT_48M16 | WAVE_FORMAT_48S16 | WAVE_FORMAT_96M16 |
                  WAVE_FORMAT_96S16;
    }

    // Is one channel (aka mono sound) valid?
    if (AudioDataRange->MaximumChannels >= 1)
    {
        dwChannels |= WAVE_FORMAT_1M08  | WAVE_FORMAT_1M16  | WAVE_FORMAT_2M08  |
                      WAVE_FORMAT_2M16  | WAVE_FORMAT_44M08 | WAVE_FORMAT_44M16 |
                      WAVE_FORMAT_48M08 | WAVE_FORMAT_48M16 | WAVE_FORMAT_96M08 |
                      WAVE_FORMAT_48M16;
    }

    // Are two channels (aka stereo sound) valid?
    if (AudioDataRange->MaximumChannels >= 2)
    {
        dwChannels |= WAVE_FORMAT_1S08  | WAVE_FORMAT_1S16  | WAVE_FORMAT_2S08  |
                      WAVE_FORMAT_2S16  | WAVE_FORMAT_44S08 | WAVE_FORMAT_44S16 |
                      WAVE_FORMAT_48S08 | WAVE_FORMAT_48S16 | WAVE_FORMAT_96S08 |
                      WAVE_FORMAT_96S16;
    }

    dwSamples = dwSamples & dwBits & dwChannels;

    return dwSamples;
}

//
//  Assist with unicode conversions
//
VOID CopyUnicodeStringtoAnsiString
(
        LPSTR lpstr,
        LPCWSTR lpwstr,
        int len
)
{
        UNICODE_STRING SourceString;
        ANSI_STRING DestinationString;
        NTSTATUS Status;

        PAGED_CODE();
        RtlInitUnicodeString(&SourceString, lpwstr);

        Status = RtlUnicodeStringToAnsiString(&DestinationString, &SourceString, TRUE);

        if (NT_SUCCESS(Status)) {

                if (DestinationString.MaximumLength<len) {
                        len=DestinationString.MaximumLength;
                        }

                RtlCopyMemory(lpstr, DestinationString.Buffer, len);

                RtlFreeAnsiString(&DestinationString);

                lpstr[len-1]=0;

                }
        else if (len>0) {

                *lpstr=0;

                }

}

VOID CopyAnsiStringtoUnicodeString
(
    LPWSTR lpwstr,
    LPCSTR lpstr,
    int len
)
{

    PAGED_CODE();
while (len)
    {
        *lpwstr = (WCHAR) *lpstr;
        lpwstr++;
        lpstr++;
        len--;
    }

lpwstr--;
*lpwstr=0;

}


UINT GetCapsIndex
(
    PWDMACONTEXT    pWdmaContext,
    PWSTR           pwstrName,
    DWORD           DeviceType,
    DWORD           DeviceNumber
)
{
    PCOMMONDEVICE  *ppCommonDevice;
    UINT            MatchCount = 0;
    DWORD           d;

    PAGED_CODE();
    ppCommonDevice = &pWdmaContext->apCommonDevice[DeviceType][0];

    //
    //  Loop through all of the devices for a particular devicetype
    //
    for( d = 0; d < MAXNUMDEVS; d++ )
    {
        if (ppCommonDevice[d]->Device != UNUSED_DEVICE &&
            !CmpStr(ppCommonDevice[d]->pwstrName, pwstrName))
        {
            MatchCount++;
            if (DeviceNumber == d)
            {
                break;
            }
        }
    }

    //
    //  returns index of the friendly name.
    //
    return MatchCount;
}

NTSTATUS
ReadProductNameFromMediaCategories(
    IN REFGUID ProductNameGuid,
    OUT PWSTR *NameBuffer
    )
/*++

Routine Description:

    Queries the "Name" key from the specified category GUID.

Arguments:

    ProductNameGuid -
        The GUID to locate the name value for.

    NameBuffer -
        The place in which to put the value.
--*/
{
    OBJECT_ATTRIBUTES               ObjectAttributes;
    NTSTATUS                        Status;
    HANDLE                          CategoryKey;
    KEY_VALUE_PARTIAL_INFORMATION   PartialInfoHeader;
    WCHAR                           RegistryPath[sizeof(MediaCategories) + 39];
    UNICODE_STRING                  RegistryString;
    UNICODE_STRING                  ValueName;
    ULONG                           BytesReturned;

    PAGED_CODE();
    //
    // Build the registry key path to the specified category GUID.
    //
    Status = RtlStringFromGUID(ProductNameGuid, &RegistryString);
    if (!NT_SUCCESS(Status)) {
        RETURN( Status );
    }
    wcscpy(RegistryPath, MediaCategories);
    wcscat(RegistryPath, RegistryString.Buffer);
    RtlFreeUnicodeString(&RegistryString);
    RtlInitUnicodeString(&RegistryString, RegistryPath);
    InitializeObjectAttributes(&ObjectAttributes, 
                               &RegistryString, 
                               OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, 
                               NULL, 
                               NULL);
    if (!NT_SUCCESS(Status = ZwOpenKey(&CategoryKey, KEY_READ, &ObjectAttributes))) {
        RETURN( Status );
    }
    //
    // Read the "Name" value beneath this category key.
    //
    RtlInitUnicodeString(&ValueName, NodeNameValue);
    Status = ZwQueryValueKey(
        CategoryKey,
        &ValueName,
        KeyValuePartialInformation,
        &PartialInfoHeader,
        sizeof(PartialInfoHeader),
        &BytesReturned);
    //
    // Even if the read did not cause an overflow, just take the same
    // code path, as such a thing would not normally happen.
    //
    if ((Status == STATUS_BUFFER_OVERFLOW) || NT_SUCCESS(Status)) {
        PKEY_VALUE_PARTIAL_INFORMATION  PartialInfoBuffer = NULL;

        //
        // Allocate a buffer for the actual size of data needed.
        //
        Status = AudioAllocateMemory_Paged(BytesReturned,
                                           TAG_Audp_NAME,
                                           ZERO_FILL_MEMORY,
                                           &PartialInfoBuffer );
        if (NT_SUCCESS(Status)) {
            //
            // Retrieve the actual name.
            //
            Status = ZwQueryValueKey(
                CategoryKey,
                &ValueName,
                KeyValuePartialInformation,
                PartialInfoBuffer,
                BytesReturned,
                &BytesReturned);
            if (NT_SUCCESS(Status)) {
                //
                // Make sure that there is always a value.
                //
                if (!PartialInfoBuffer->DataLength || (PartialInfoBuffer->Type != REG_SZ)) {
                    Status = STATUS_UNSUCCESSFUL;
                } else {
                    Status = AudioAllocateMemory_Paged(PartialInfoBuffer->DataLength,
                                                       TAG_Audp_NAME,
                                                       DEFAULT_MEMORY,
                                                       NameBuffer );
                    if (NT_SUCCESS(Status)) {

                        RtlCopyMemory(
                            *NameBuffer,
                            PartialInfoBuffer->Data,
                            PartialInfoBuffer->DataLength);
                    }
                }
            }
            AudioFreeMemory_Unknown(&PartialInfoBuffer);
        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    ZwClose(CategoryKey);
    RETURN( Status );
}

WORD ChooseCorrectMid
(
    REFGUID     Manufacturer
)
{
    PAGED_CODE();
    if (IS_COMPATIBLE_MMREG_MID(Manufacturer))
    {
        return EXTRACT_MMREG_MID(Manufacturer);
    }
    else
    {
        return MM_UNMAPPED;
    }
}

WORD ChooseCorrectPid
(
    REFGUID     Product
)
{
    PAGED_CODE();
    if (IS_COMPATIBLE_MMREG_PID(Product))
    {
        return EXTRACT_MMREG_PID(Product);
    }
    else
    {
        return MM_PID_UNMAPPED;
    }
}

NTSTATUS FillWaveOutDevCaps
(
    PWDMACONTEXT    pWdmaContext,
    DWORD           DeviceNumber,
    LPBYTE          lpCaps,
    DWORD           dwSize
)
{
    WAVEOUTCAPS2W       wc2;
    WAVEDEVICE          WaveDevice;
    PDATARANGES         AudioDataRanges;
    PKSDATARANGE_AUDIO  pDataRange;
    ULONG               d;
    UINT                CapsIndex;
    WCHAR               szTemp[256];

    PAGED_CODE();
    WaveDevice = pWdmaContext->WaveOutDevs[DeviceNumber];

    //
    //  If available, use the ComponentId to gather information about the device.
    //  Otherwise, fall back to hardcoded devcaps.
    //
    if ( (WaveDevice.PreferredDevice == MAXULONG) &&
         (WaveDevice.ComponentId) )
    {
        wc2.NameGuid = WaveDevice.ComponentId->Name;

        wc2.wMid = ChooseCorrectMid(&WaveDevice.ComponentId->Manufacturer);
        wc2.ManufacturerGuid = WaveDevice.ComponentId->Manufacturer;

        wc2.wPid = ChooseCorrectPid(&WaveDevice.ComponentId->Product);
        wc2.ProductGuid = WaveDevice.ComponentId->Product;

        wc2.vDriverVersion = (WaveDevice.ComponentId->Version << 8) |
                             (WaveDevice.ComponentId->Revision & 0xFF);
    }
    else
    {
        wc2.NameGuid = GUID_NULL;

        wc2.wMid = MM_MICROSOFT;
        INIT_MMREG_MID( &wc2.ManufacturerGuid, wc2.wMid );

        wc2.wPid = MM_MSFT_WDMAUDIO_WAVEOUT;
        INIT_MMREG_PID( &wc2.ProductGuid, wc2.wPid );

        wc2.vDriverVersion = 0x050a;
    }

    //
    //  Assume that KMixer is sample accurate
    //
    wc2.dwSupport = WAVECAPS_VOLUME | WAVECAPS_LRVOLUME |
                    WAVECAPS_SAMPLEACCURATE ;

    //
    //  Compute the wChannels and dwFormats by consolidating the caps
    //  from each of the dataranges
    //
    wc2.wChannels = 0;
    wc2.dwFormats = 0;

    AudioDataRanges = WaveDevice.AudioDataRanges;
    pDataRange = (PKSDATARANGE_AUDIO)&AudioDataRanges->aDataRanges[0];

    for(d = 0; d < AudioDataRanges->Count; d++)
    {
        if (pDataRange->DataRange.FormatSize >= sizeof(KSDATARANGE_AUDIO))
        {
            //
            //  Only produce caps for PCM formats
            //
            if ( EXTRACT_WAVEFORMATEX_ID(&pDataRange->DataRange.SubFormat) ==
                 WAVE_FORMAT_PCM )
            {
                //  Get the largest number of supported channels
                if ( (WORD)pDataRange->MaximumChannels > wc2.wChannels)
                    wc2.wChannels = (WORD)pDataRange->MaximumChannels;

                wc2.dwFormats |= GetFormats( pDataRange );
            }
        }

        // Get the pointer to the next data range
        (PUCHAR)pDataRange += ((pDataRange->DataRange.FormatSize +
                                FILE_QUAD_ALIGNMENT) & ~FILE_QUAD_ALIGNMENT);
    }

    //
    //  Add an index in the form of "(%d)" to the end of the szPname string if two or more
    //  devices have the same name
    //
    ASSERT(WaveDevice.pwstrName);
    CapsIndex = GetCapsIndex( pWdmaContext, WaveDevice.pwstrName, WaveOutDevice, DeviceNumber );
    if (CapsIndex < 2)
    {
        wcsncpy(wc2.szPname, WaveDevice.pwstrName, MAXPNAMELEN);
    }
    else
    {
        swprintf(szTemp, STR_PNAME, WaveDevice.pwstrName, CapsIndex);
        wcsncpy(wc2.szPname, szTemp, MAXPNAMELEN);
    }
    wc2.szPname[MAXPNAMELEN-1] = UNICODE_NULL;

    //
    //  Copy the caps information into the caller supplied buffer
    //
    RtlCopyMemory(lpCaps, &wc2, min(dwSize, sizeof(wc2)));

    return STATUS_SUCCESS;
}

NTSTATUS FillWaveInDevCaps
(
    PWDMACONTEXT    pWdmaContext,
    DWORD           DeviceNumber,
    LPBYTE          lpCaps,
    DWORD           dwSize
)
{
    WAVEINCAPS2W        wc2;
    WAVEDEVICE          WaveDevice;
    PDATARANGES         AudioDataRanges;
    PKSDATARANGE_AUDIO  pDataRange;
    ULONG               d;
    UINT                CapsIndex;
    WCHAR               szTemp[256];

    PAGED_CODE();
    WaveDevice = pWdmaContext->WaveInDevs[DeviceNumber];

    //
    //  If available, use the ComponentId to gather information about the device.
    //  Otherwise, fall back to hardcoded devcaps.
    //
    if ( (WaveDevice.PreferredDevice == MAXULONG) &&
         (WaveDevice.ComponentId) )
    {
        wc2.NameGuid = WaveDevice.ComponentId->Name;

        wc2.wMid = ChooseCorrectMid(&WaveDevice.ComponentId->Manufacturer);
        wc2.ManufacturerGuid = WaveDevice.ComponentId->Manufacturer;

        wc2.wPid = ChooseCorrectPid(&WaveDevice.ComponentId->Product);
        wc2.ProductGuid = WaveDevice.ComponentId->Product;

        wc2.vDriverVersion = (WaveDevice.ComponentId->Version << 8) |
                             (WaveDevice.ComponentId->Revision & 0xFF);
    }
    else
    {
        wc2.NameGuid = GUID_NULL;

        wc2.wMid = MM_MICROSOFT;
        INIT_MMREG_MID( &wc2.ManufacturerGuid, wc2.wMid );

        wc2.wPid = MM_MSFT_WDMAUDIO_WAVEIN;
        INIT_MMREG_PID( &wc2.ProductGuid, wc2.wPid );

        wc2.vDriverVersion = 0x050a;
    }

    //
    //  Compute the wChannels and dwFormats by consolidating the caps
    //  from each of the dataranges
    //
    wc2.wChannels = 0;
    wc2.dwFormats = 0;

    AudioDataRanges = WaveDevice.AudioDataRanges;
    pDataRange = (PKSDATARANGE_AUDIO)&AudioDataRanges->aDataRanges[0];

    for(d = 0; d < AudioDataRanges->Count; d++)
    {
        if (pDataRange->DataRange.FormatSize >= sizeof(KSDATARANGE_AUDIO))
        {
            //
            //  Only produce caps for PCM formats
            //
            if ( EXTRACT_WAVEFORMATEX_ID(&pDataRange->DataRange.SubFormat) ==
                 WAVE_FORMAT_PCM )
            {
                //  Get the largest number of supported channels
                if ( (WORD)pDataRange->MaximumChannels > wc2.wChannels)
                    wc2.wChannels = (WORD)pDataRange->MaximumChannels;

                wc2.dwFormats |= GetFormats( pDataRange );
            }
        }

        // Get the pointer to the next data range
        (PUCHAR)pDataRange += ((pDataRange->DataRange.FormatSize +
                                FILE_QUAD_ALIGNMENT) & ~FILE_QUAD_ALIGNMENT);
    }

    //
    //  Add an index in the form of "(%d)" to the end of the szPname string if two or more
    //  devices have the same name
    //
    ASSERT(WaveDevice.pwstrName);
    CapsIndex = GetCapsIndex( pWdmaContext, WaveDevice.pwstrName, WaveInDevice, DeviceNumber );
    if (CapsIndex < 2)
    {
        wcsncpy(wc2.szPname, WaveDevice.pwstrName, MAXPNAMELEN);
    }
    else
    {
        swprintf(szTemp, STR_PNAME, WaveDevice.pwstrName, CapsIndex);
        wcsncpy(wc2.szPname, szTemp, MAXPNAMELEN);
    }
    wc2.szPname[MAXPNAMELEN-1] = UNICODE_NULL;

    //
    //  Copy the caps information into the caller supplied buffer
    //
    RtlCopyMemory(lpCaps, &wc2, min(dwSize, sizeof(wc2)));

    return STATUS_SUCCESS;
}

NTSTATUS FillMidiOutDevCaps
(
    PWDMACONTEXT    pWdmaContext,
    DWORD           DeviceNumber,
    LPBYTE          lpCaps,
    DWORD           dwSize
)
{
    MIDIOUTCAPS2W       mc2;
    MIDIDEVICE          MidiDevice;
    PDATARANGES         MusicDataRanges;
    PKSDATARANGE_MUSIC  pDataRange;
    UINT                CapsIndex;
    WCHAR               szTemp[256];

    PAGED_CODE();
    MidiDevice = pWdmaContext->MidiOutDevs[DeviceNumber];

    //
    //  If available, use the ComponentId to gather information about the device.
    //  Otherwise, fall back to hardcoded devcaps.
    //
    if ( (MidiDevice.PreferredDevice == MAXULONG) &&
         (MidiDevice.ComponentId) )
    {
        mc2.NameGuid = MidiDevice.ComponentId->Name;

        mc2.wMid = ChooseCorrectMid(&MidiDevice.ComponentId->Manufacturer);
        mc2.ManufacturerGuid = MidiDevice.ComponentId->Manufacturer;

        mc2.wPid = ChooseCorrectPid(&MidiDevice.ComponentId->Product);
        mc2.ProductGuid = MidiDevice.ComponentId->Product;

        mc2.vDriverVersion = (MidiDevice.ComponentId->Version << 8) |
                             (MidiDevice.ComponentId->Revision & 0xFF);
    }
    else
    {
        mc2.NameGuid = GUID_NULL;

        mc2.wMid = MM_MICROSOFT;
        INIT_MMREG_MID( &mc2.ManufacturerGuid, mc2.wMid );

        mc2.wPid = MM_MSFT_WDMAUDIO_MIDIOUT;
        INIT_MMREG_PID( &mc2.ProductGuid, mc2.wMid );

        mc2.vDriverVersion = 0x050a;
    }

    MusicDataRanges = MidiDevice.MusicDataRanges;
    pDataRange = (PKSDATARANGE_MUSIC)&MusicDataRanges->aDataRanges[0];

    //
    //  Use the first datarange.  Could cause problems for pins
    //  that support multiple music dataranges.
    //
    if (pDataRange->DataRange.FormatSize < sizeof(KSDATARANGE_MUSIC))
    {
        mc2.wTechnology = MOD_MIDIPORT;
        mc2.wVoices     = 0;
        mc2.wNotes      = 0;
        mc2.wChannelMask= 0;
    }
    else
    {
        mc2.wTechnology = GetMidiTechnology( pDataRange );
        mc2.wVoices     = (WORD)pDataRange->Channels;
        mc2.wNotes      = (WORD)pDataRange->Notes;
        mc2.wChannelMask= (WORD)pDataRange->ChannelMask;
    }

    mc2.dwSupport = 0L;
    if (mc2.wTechnology != MOD_MIDIPORT)
    {
        mc2.dwSupport |= MIDICAPS_VOLUME | MIDICAPS_LRVOLUME;
    }

    ASSERT(MidiDevice.pwstrName);
    CapsIndex = GetCapsIndex( pWdmaContext, MidiDevice.pwstrName, MidiOutDevice, DeviceNumber );
    if (CapsIndex < 2)
    {
        wcsncpy(mc2.szPname, MidiDevice.pwstrName, MAXPNAMELEN);
    }
    else
    {
        // Only add the index to the string if we need to
        swprintf(szTemp, STR_PNAME, MidiDevice.pwstrName, CapsIndex);
        wcsncpy(mc2.szPname, szTemp, MAXPNAMELEN);
    }
    mc2.szPname[MAXPNAMELEN-1] = UNICODE_NULL;

    RtlCopyMemory(lpCaps, &mc2, min(dwSize, sizeof(mc2)));

    return STATUS_SUCCESS;
}

NTSTATUS FillMidiInDevCaps
(
    PWDMACONTEXT    pWdmaContext,
    DWORD           DeviceNumber,
    LPBYTE          lpCaps,
    DWORD           dwSize
)
{
    MIDIINCAPS2W    mc2;
    MIDIDEVICE      MidiDevice;
    UINT            CapsIndex;
    WCHAR           szTemp[256];

    PAGED_CODE();
    MidiDevice = pWdmaContext->MidiInDevs[DeviceNumber];

    //
    //  If available, use the ComponentId to gather information about the device.
    //  Otherwise, fall back to hardcoded devcaps.
    //
    if ( (MidiDevice.PreferredDevice == MAXULONG) &&
         (MidiDevice.ComponentId) )
    {
        mc2.NameGuid = MidiDevice.ComponentId->Name;

        mc2.wMid = ChooseCorrectMid(&MidiDevice.ComponentId->Manufacturer);
        mc2.ManufacturerGuid = MidiDevice.ComponentId->Manufacturer;

        mc2.wPid = ChooseCorrectPid(&MidiDevice.ComponentId->Product);
        mc2.ProductGuid = MidiDevice.ComponentId->Product;

        mc2.vDriverVersion = (MidiDevice.ComponentId->Version << 8) |
                             (MidiDevice.ComponentId->Revision & 0xFF);
    }
    else
    {
        mc2.NameGuid = GUID_NULL;

        mc2.wMid = MM_MICROSOFT;
        INIT_MMREG_MID( &mc2.ManufacturerGuid, mc2.wMid );

        mc2.wPid = MM_MSFT_WDMAUDIO_MIDIIN;
        INIT_MMREG_PID( &mc2.ProductGuid, mc2.wPid );

        mc2.vDriverVersion = 0x050a;
    }

    mc2.dwSupport = 0L;   /* functionality supported by driver */

    ASSERT(MidiDevice.pwstrName);
    CapsIndex = GetCapsIndex( pWdmaContext, MidiDevice.pwstrName, MidiInDevice, DeviceNumber );
    if (CapsIndex < 2)
    {
        wcsncpy(mc2.szPname, MidiDevice.pwstrName, MAXPNAMELEN);
    }
    else
    {
        // Only add the index to the string if we need to
        swprintf(szTemp, STR_PNAME, MidiDevice.pwstrName, CapsIndex);
        wcsncpy(mc2.szPname, szTemp, MAXPNAMELEN);
    }
    mc2.szPname[MAXPNAMELEN-1] = UNICODE_NULL;

    RtlCopyMemory(lpCaps, &mc2, min(dwSize, sizeof(mc2)));

    return STATUS_SUCCESS;
}

NTSTATUS FillMixerDevCaps
(
    PWDMACONTEXT    pWdmaContext,
    DWORD           DeviceNumber,
    LPBYTE          lpCaps,
    DWORD           dwSize
)
{
    MIXERCAPS2W     mc2;
    MIXERDEVICE     Mixer;
    UINT            CapsIndex;
    WCHAR           szTemp[256];

    PAGED_CODE();
    Mixer = pWdmaContext->MixerDevs[DeviceNumber];

    //
    //  If available, use the ComponentId to gather information about the device.
    //  Otherwise, fall back to hardcoded devcaps.
    //
    if ( (Mixer.PreferredDevice == MAXULONG) &&
         (Mixer.ComponentId) )
    {
        mc2.NameGuid = Mixer.ComponentId->Name;

        mc2.wMid = ChooseCorrectMid(&Mixer.ComponentId->Manufacturer);
        mc2.ManufacturerGuid = Mixer.ComponentId->Manufacturer;

        mc2.wPid = ChooseCorrectPid(&Mixer.ComponentId->Product);
        mc2.ProductGuid = Mixer.ComponentId->Product;

        mc2.vDriverVersion = (Mixer.ComponentId->Version << 8) |
                             (Mixer.ComponentId->Revision & 0xFF);
    }
    else
    {
        mc2.NameGuid = GUID_NULL;

        mc2.wMid = MM_MICROSOFT;
        INIT_MMREG_MID( &mc2.ManufacturerGuid, mc2.wMid );

        mc2.wPid = MM_MSFT_WDMAUDIO_MIXER;
        INIT_MMREG_PID( &mc2.ProductGuid, mc2.wPid );

        mc2.vDriverVersion = 0x050a;
    }

    mc2.fdwSupport = 0L;     /* functionality supported by driver */
    mc2.cDestinations = kmxlGetNumDestinations( &Mixer );

    ASSERT(Mixer.pwstrName);
    CapsIndex = GetCapsIndex( pWdmaContext, Mixer.pwstrName, MixerDevice, DeviceNumber );
    if (CapsIndex < 2)
    {
        wcsncpy(mc2.szPname, Mixer.pwstrName, MAXPNAMELEN);
    }
    else
    {
        // Only add the index to the string if we need to
        swprintf(szTemp, STR_PNAME, Mixer.pwstrName, CapsIndex);
        wcsncpy(mc2.szPname, szTemp, MAXPNAMELEN);
    }
    mc2.szPname[MAXPNAMELEN-1] = UNICODE_NULL;

    RtlCopyMemory(lpCaps, &mc2, min(dwSize, sizeof(mc2)));

    return STATUS_SUCCESS;
}

NTSTATUS FillAuxDevCaps
(
    PWDMACONTEXT    pWdmaContext,
    DWORD           DeviceNumber,
    LPBYTE          lpCaps,
    DWORD           dwSize
)
{
    AUXCAPS2W   ac2;
    AUXDEVICE   AuxDev;
    UINT        CapsIndex;
    WCHAR       szTemp[256];

    PAGED_CODE();
    AuxDev = pWdmaContext->AuxDevs[DeviceNumber];

    //
    //  If available, use the ComponentId to gather information about the device.
    //  Otherwise, fall back to hardcoded devcaps.
    //
    if ( (AuxDev.PreferredDevice == MAXULONG) &&
         (AuxDev.ComponentId) )
    {
        ac2.NameGuid = AuxDev.ComponentId->Name;

        ac2.wMid = ChooseCorrectMid(&AuxDev.ComponentId->Manufacturer);
        ac2.ManufacturerGuid = AuxDev.ComponentId->Manufacturer;

        ac2.wPid = ChooseCorrectPid(&AuxDev.ComponentId->Product);
        ac2.ProductGuid = AuxDev.ComponentId->Product;

        ac2.vDriverVersion = (AuxDev.ComponentId->Version << 8) |
                             (AuxDev.ComponentId->Revision & 0xFF);
    }
    else
    {
        ac2.NameGuid = GUID_NULL;

        ac2.wMid = MM_MICROSOFT;
        INIT_MMREG_MID( &ac2.ManufacturerGuid, ac2.wMid );

        ac2.wPid = MM_MSFT_WDMAUDIO_AUX;
        INIT_MMREG_PID( &ac2.ProductGuid, ac2.wPid );

        ac2.vDriverVersion = 0x050a;
    }


    ac2.wTechnology = AUXCAPS_CDAUDIO ; // | AUXCAPS_AUXIN ;
    ac2.dwSupport = AUXCAPS_LRVOLUME | AUXCAPS_VOLUME;


    ASSERT(AuxDev.pwstrName);
    CapsIndex = GetCapsIndex( pWdmaContext, AuxDev.pwstrName, AuxDevice, DeviceNumber );
    if (CapsIndex < 2)
    {
        wcsncpy(ac2.szPname, AuxDev.pwstrName, MAXPNAMELEN);
    }
    else
    {
        // Only add the index to the string if we need to
        swprintf(szTemp, STR_PNAME, AuxDev.pwstrName, CapsIndex);
        wcsncpy(ac2.szPname, szTemp, MAXPNAMELEN);
    }
    ac2.szPname[MAXPNAMELEN-1] = UNICODE_NULL;

    RtlCopyMemory(lpCaps, &ac2, min(dwSize, sizeof(ac2)));

    return STATUS_SUCCESS;
}

NTSTATUS wdmaudGetDevCaps
(
    PWDMACONTEXT    pWdmaContext,
    DWORD           DeviceType,
    DWORD           DeviceNumber,
    LPBYTE          lpCaps,
    DWORD           dwSize
)
{
    NTSTATUS        Status = STATUS_SUCCESS;

    PAGED_CODE();
    ASSERT(DeviceType == WaveOutDevice ||
           DeviceType == WaveInDevice  ||
           DeviceType == MidiOutDevice ||
           DeviceType == MidiInDevice  ||
           DeviceType == MixerDevice   ||
           DeviceType == AuxDevice);

    switch(DeviceType) {
        case WaveOutDevice:
            Status = FillWaveOutDevCaps(pWdmaContext,DeviceNumber,lpCaps,dwSize);
            break;

        case WaveInDevice:
            Status = FillWaveInDevCaps(pWdmaContext,DeviceNumber,lpCaps,dwSize);
            break;

        case MidiOutDevice:
            Status = FillMidiOutDevCaps(pWdmaContext,DeviceNumber,lpCaps,dwSize);
            break;

        case MidiInDevice:
            Status = FillMidiInDevCaps(pWdmaContext,DeviceNumber,lpCaps,dwSize);
            break;

        case MixerDevice:
            Status = FillMixerDevCaps(pWdmaContext,DeviceNumber,lpCaps,dwSize);
            break;

        case AuxDevice:
            Status = FillAuxDevCaps(pWdmaContext,DeviceNumber,lpCaps,dwSize);
            break;

        default:
            ASSERT(0);
    }

    return Status;
}

BOOL IsEqualInterface
(
    PKSPIN_INTERFACE    pInterface1,
    PKSPIN_INTERFACE    pInterface2
)
{
    PAGED_CODE();
    return ( IsEqualGUID(&pInterface1->Set, &pInterface2->Set) &&
             (pInterface1->Id    == pInterface2->Id)           &&
             (pInterface1->Flags == pInterface2->Flags) );
}

/****************************************************************************
 *
 *      PnPCompletionRoutine - Finish the PnP Irp
 *
 *      Not Exported.
 *
 *      ENTRY:  Standard PIO_COMPLETION_ROUTINE.
 *
 *      EXIT:   Standard NT status.
 *
 ***************************************************************************/
NTSTATUS
PnPCompletionRoutine(PDEVICE_OBJECT pDeviceObject, PIRP pIrp, PVOID pContext)
{
    PAGED_CODE();
    //
    // Wake ourselves: the device has finally started/stopped.
    //
    KeSetEvent((PKEVENT)pContext, 0, FALSE);

    //
    // The completion itself never fails.
    //
    RETURN(STATUS_MORE_PROCESSING_REQUIRED);
}

/****************************************************************************
 *
 *      SynchronousCallDriver - Synchronously send a plug and play irp
 *
 *      Not exported.
 *
 *      ENTRY:  pfdo is the function device object.
 *
 *              pIrp is the IRP to send.
 *
 *              ppResult is filled in with the information value.
 *
 *      EXIT:   Standard NT status.
 *
 ***************************************************************************/
NTSTATUS
SynchronousCallDriver(PDEVICE_OBJECT pfdo, PIRP pIrp, PVOID *ppResult)
{
        NTSTATUS                ntStatus;
        KEVENT                  keEventObject;

        PAGED_CODE();
        //
        // Set the thread (should typically be msgsrv32's).
        //
        pIrp->Tail.Overlay.Thread=PsGetCurrentThread();

        //
        // Initialize the status block.
        //
        pIrp->IoStatus.Status=STATUS_NOT_SUPPORTED;

        //
        // Initialize our wait event, in case we need to wait.
        //
        KeInitializeEvent(      &keEventObject,
                                SynchronizationEvent,
                                FALSE);

        //
        // Set our completion routine so we can free the IRP and wake
        // ourselfs.
        //
        IoSetCompletionRoutine( pIrp,
                                PnPCompletionRoutine,
                                &keEventObject,
                                TRUE,
                                TRUE,
                                TRUE);

        //
        // Call the stack now.
        //
        ntStatus=IoCallDriver(pfdo, pIrp);

        //
        // Wait if it is pending.
        //
        if (ntStatus==STATUS_PENDING) {

                //
                // Wait for the completion.
                //
                ntStatus=KeWaitForSingleObject( &keEventObject,
                                                Executive,
                                                KernelMode,
                                                FALSE,
                                                (PLARGE_INTEGER) NULL );

                //
                // Three cases: timeout (which can't be since we pass null),
                // success or USER_APC (which I don't know what to do).
                //
                if (ntStatus==STATUS_USER_APC) {

//                      IopCancelAlertedRequest(&keEventObject, pIrp );
                }
        }

        //
        // Initialize the result, if requested.
        //
        if (ppResult)
                *ppResult=NULL;

        //
        // Otherwise return the result of the operation.
        //
        ntStatus=pIrp->IoStatus.Status;

        //
        // Fill in the result if requested.
        //
        if (ppResult)
                *ppResult=(PVOID)(pIrp->IoStatus.Information);

        RETURN(ntStatus);
}

BOOL IsPinForDevNode
(
    PFILE_OBJECT pFileObjectDevice,
    ULONG        Index,
    PCWSTR       DeviceInterface
)
{
    NTSTATUS            Status;
    WCHAR               szInterfaceName[256];
    BOOL                Result;

    PAGED_CODE();
    Status = GetSysAudioProperty(pFileObjectDevice,
                                 KSPROPERTY_SYSAUDIO_DEVICE_INTERFACE_NAME,
                                 Index,
                                 sizeof(szInterfaceName),
                                 szInterfaceName);
    if (NT_SUCCESS(Status))
    {
        // TODO: Eventually will not need to munge the strings
        PWSTR pszIn = NULL;
        PWSTR pszSysaudio = NULL;

        Status = AudioAllocateMemory_Paged((wcslen(DeviceInterface)+1) * sizeof(WCHAR),
                                           TAG_Audp_NAME,
                                           DEFAULT_MEMORY,
                                           &pszIn );
        if (NT_SUCCESS(Status))
        {
            Status = AudioAllocateMemory_Paged((wcslen(szInterfaceName)+1) * sizeof(WCHAR),
                                               TAG_Audp_NAME,
                                               DEFAULT_MEMORY,
                                               &pszSysaudio );
            if (NT_SUCCESS(Status))
            {
                PWCHAR pch;

                wcscpy(pszIn, DeviceInterface);
                wcscpy(pszSysaudio, szInterfaceName);

                // pszIn[1] = '\\';
                pszSysaudio[1] = '\\';

                // _DbgPrintF( DEBUGLVL_VERBOSE, ("IsPinForDevnode: Sysaudio returns interface name %ls", pszSysaudio));
                // _DbgPrintF( DEBUGLVL_VERBOSE, ("IsPinForDevnode: Comparing against %ls", pszIn));
                if (!MyWcsicmp(pszIn, pszSysaudio)) {
                    Result = TRUE;
                } else {
                    Result = FALSE;
                }
                AudioFreeMemory_Unknown(&pszSysaudio);
            } else {
                Result = FALSE;
            }
            AudioFreeMemory_Unknown(&pszIn);
        } else {
            Result = FALSE;
        }
    } else {
        Result = FALSE;
    }

    return Result;
}

ULONG FindMixerForDevNode(
    IN PMIXERDEVICE paMixerDevs,
    IN PCWSTR DeviceInterface
)
{
    ULONG i;

    PAGED_CODE();
    for( i = 0; i < MAXNUMDEVS; i++ ) {

        if( ( paMixerDevs[ i ].Device != UNUSED_DEVICE ) &&
            !MyWcsicmp( paMixerDevs[ i ].DeviceInterface, DeviceInterface ) )
        {
            return( i );
        }
    }

    return( UNUSED_DEVICE );
}

NTSTATUS InitializeAuxGetNumDevs
(
    PWDMACONTEXT pWdmaContext,
    PCWSTR DeviceInterface
)
{
    NTSTATUS Status;
    PWSTR pwstrNameAux = NULL;
    DWORD dw;
    ULONG MixerIndex;
    PKSCOMPONENTID ComponentId = NULL;

    PAGED_CODE();
    //
    // Get the name from the mixer device
    //
    MixerIndex = FindMixerForDevNode(pWdmaContext->MixerDevs, DeviceInterface);
    if ( (MixerIndex != UNUSED_DEVICE) && (pWdmaContext->MixerDevs[MixerIndex].pwstrName != NULL) )
    {
        //
        // Check for CD volume control
        //
        Status = IsVolumeControl( pWdmaContext,
                                  DeviceInterface,
                                  MIXERLINE_COMPONENTTYPE_SRC_COMPACTDISC,
                                  &dw,
                                  &dw );

        if(NT_SUCCESS(Status))
        {
            Status = AudioAllocateMemory_Paged((wcslen(pWdmaContext->MixerDevs[MixerIndex].pwstrName) + 1) * sizeof(WCHAR),
                                               TAG_Audp_NAME,
                                               DEFAULT_MEMORY,
                                               &pwstrNameAux);
            if (NT_SUCCESS(Status))
            {
                wcscpy(pwstrNameAux, pWdmaContext->MixerDevs[MixerIndex].pwstrName);

                if (pWdmaContext->MixerDevs[MixerIndex].ComponentId)
                {
                    Status = AudioAllocateMemory_Paged(sizeof(*ComponentId),
                                                       TAG_Audp_NAME,
                                                       DEFAULT_MEMORY,
                                                       &ComponentId);
                    if (NT_SUCCESS(Status))
                    {
                        RtlCopyMemory(ComponentId, pWdmaContext->MixerDevs[MixerIndex].ComponentId, sizeof(*ComponentId));
                    }
                }
                else
                {
                    ComponentId = NULL;
                }

                Status = AddDevice(pWdmaContext,
                                   0,
                                   AuxDevice,
                                   DeviceInterface,
                                   0,
                                   pwstrNameAux,
                                   FALSE,
                                   NULL,
                                   ComponentId);
                if (NT_SUCCESS(Status))
                {
                    FindVolumeControl(pWdmaContext, DeviceInterface, AuxDevice);
                } else {
                    AudioFreeMemory_Unknown(&ComponentId);
                    AudioFreeMemory_Unknown(&pwstrNameAux);
                }
            }
        }
    }

    // if anything fails, still return success so InitializeGetNumDevs
    // returns 0 devices
    return(STATUS_SUCCESS);
}

NTSTATUS InitializeMixerGetNumDevs
(
    IN PWDMACONTEXT pWdmaContext,
    IN PCWSTR DeviceInterface
)
{
    NTSTATUS Status;
    PMIXERDEVICE paMixerDevs;
    PWAVEDEVICE paWaveOutDevs;
    PWAVEDEVICE paWaveInDevs;
    ULONG i, j;

    PAGED_CODE();
    // WARNING !! WARNING !! WARNING !! WARNING !! WARNING !! WARNING
    //
    // This function makes a few assumptions.  If any of the assumptions
    // below change, this function must be updated accordingly!
    //
    // 1) Mixer devices are initialized after all other device classes.
    //
    // 2) SysAudio device numbers are the same for the different interfaces
    //    (WaveOut,WaveIn,MidiOut,MidiIn,Mixer) for a devnode.
    //
    // WARNING !! WARNING !! WARNING !! WARNING !! WARNING !! WARNING


    paWaveOutDevs = pWdmaContext->WaveOutDevs;
    paWaveInDevs = pWdmaContext->WaveInDevs;
    paMixerDevs = pWdmaContext->MixerDevs;

    for( i = 0; i < MAXNUMDEVS; i++ ) {

        //
        // Look for WaveOut interfaces
        //

        if( ( paWaveOutDevs[ i ].Device != UNUSED_DEVICE ) &&
            ( !MyWcsicmp(paWaveOutDevs[ i ].DeviceInterface, DeviceInterface) ) ) {

            for( j = 0; j < MAXNUMDEVS; j++ ) {

                //ASSERT(paMixerDevs[j].Device == UNUSED_DEVICE ?
                //       NULL == paMixerDevs[j].DeviceInterface :
                //      NULL != paMixerDevs[j].DeviceInterface);

                if( ( paMixerDevs[ j ].Device != UNUSED_DEVICE ) &&
                    ( !MyWcsicmp(paMixerDevs[ j ].DeviceInterface, DeviceInterface) ) )
                {
                    //
                    // We've found a devnode that has already been added
                    // to the mixer list.
                    //
                    kmxlDeInit(&paMixerDevs[j]);
                    paMixerDevs[ j ].Device = paWaveOutDevs[ i ].Device;
                    break;
                }

            } // for

            if( j == MAXNUMDEVS ) {

                for( j = 0; j < MAXNUMDEVS; j++ ) {
                    if( paMixerDevs[ j ].Device == UNUSED_DEVICE ) {
                        break;
                    }
                }

                if( j == MAXNUMDEVS ) {
                    RETURN( STATUS_INSUFFICIENT_RESOURCES );
                }

                Status = AudioAllocateMemory_Paged((wcslen(paWaveOutDevs[i].pwstrName) + 1) * sizeof(WCHAR),
                                                   TAG_Audp_NAME,
                                                   DEFAULT_MEMORY,
                                                   &paMixerDevs[j].pwstrName);
                if (NT_SUCCESS(Status))
                {
                    wcscpy(paMixerDevs[j].pwstrName, paWaveOutDevs[i].pwstrName);

                    Status = AudioAllocateMemory_Paged((wcslen(paWaveOutDevs[i].DeviceInterface) + 1) * sizeof(WCHAR),
                                                       TAG_AudD_DEVICEINFO,
                                                       DEFAULT_MEMORY,
                                                       &paMixerDevs[j].DeviceInterface);
                    if (NT_SUCCESS(Status))
                    {
                        wcscpy(paMixerDevs[j].DeviceInterface, paWaveOutDevs[i].DeviceInterface);
                        paMixerDevs[j].Device = paWaveOutDevs[i].Device;
                        paMixerDevs[j].PreferredDevice = paWaveOutDevs[i].PreferredDevice;

                        if (paWaveOutDevs[i].ComponentId)
                        {
                            Status = AudioAllocateMemory_Paged(sizeof(KSCOMPONENTID),
                                                               TAG_Audp_NAME,
                                                               DEFAULT_MEMORY,
                                                               &paMixerDevs[j].ComponentId);
                            if (NT_SUCCESS(Status))
                            {
                                RtlCopyMemory(paMixerDevs[j].ComponentId, paWaveOutDevs[i].ComponentId, sizeof(KSCOMPONENTID));
                            }
                        }
                        else
                        {
                            paMixerDevs[j].ComponentId = NULL;
                        }
                    } else {
                        AudioFreeMemory_Unknown(&paMixerDevs[j].pwstrName);
                    }
                }

                if (!NT_SUCCESS(Status)) {
                    RETURN( Status );
                }
            } // if

        } // if

        //
        // Loop for WaveIn interfaces.
        //

        if( ( paWaveInDevs[ i ].Device != UNUSED_DEVICE ) &&
            ( !MyWcsicmp(paWaveInDevs[ i ].DeviceInterface, DeviceInterface) ) ) {

            for( j = 0; j < MAXNUMDEVS; j++ ) {

                ASSERT(paMixerDevs[j].Device == UNUSED_DEVICE ?
                       NULL == paMixerDevs[j].DeviceInterface :
                       NULL != paMixerDevs[j].DeviceInterface);

                if( ( paMixerDevs[ j ].Device != UNUSED_DEVICE ) &&
                    ( !MyWcsicmp(paMixerDevs[ j ].DeviceInterface, DeviceInterface) ) )
                {
                    //
                    // We've found a devnode that has already been added
                    // to the mixer list.
                    //
                    kmxlDeInit(&paMixerDevs[j]);
                    paMixerDevs[ j ].Device = paWaveInDevs[ i ].Device;
                    break;
                }

            } // for

            if( j == MAXNUMDEVS ) {

                for( j = 0; j < MAXNUMDEVS; j++ ) {
                    if( paMixerDevs[ j ].Device == UNUSED_DEVICE ) {
                        break;
                    }
                }

                if( j == MAXNUMDEVS ) {
                    RETURN( STATUS_INSUFFICIENT_RESOURCES );
                }

                Status = AudioAllocateMemory_Paged((wcslen(paWaveInDevs[i].pwstrName) + 1) * sizeof(WCHAR),
                                                   TAG_AudD_DEVICEINFO,
                                                   DEFAULT_MEMORY,
                                                   &paMixerDevs[j].pwstrName);
                if (NT_SUCCESS(Status))
                {
                    wcscpy(paMixerDevs[j].pwstrName, paWaveInDevs[i].pwstrName);

                    Status = AudioAllocateMemory_Paged((wcslen(paWaveInDevs[i].DeviceInterface) + 1) * sizeof(WCHAR),
                                                       TAG_AudD_DEVICEINFO,
                                                       DEFAULT_MEMORY,
                                                       &paMixerDevs[j].DeviceInterface);
                    if (NT_SUCCESS(Status))
                    {
                        wcscpy(paMixerDevs[j].DeviceInterface, paWaveInDevs[i].DeviceInterface);
                        paMixerDevs[j].Device = paWaveInDevs[i].Device;
                        paMixerDevs[j].PreferredDevice = paWaveInDevs[i].PreferredDevice;

                        if (paWaveInDevs[i].ComponentId)
                        {
                            Status = AudioAllocateMemory_Paged(sizeof(KSCOMPONENTID),
                                                               TAG_Audp_NAME,
                                                               DEFAULT_MEMORY,
                                                               &paMixerDevs[j].ComponentId);
                            if (NT_SUCCESS(Status))
                            {
                                RtlCopyMemory(paMixerDevs[j].ComponentId, paWaveInDevs[i].ComponentId, sizeof(KSCOMPONENTID));
                            }
                        }
                        else
                        {
                            paMixerDevs[j].ComponentId = NULL;
                        }
                    } else {
                        AudioFreeMemory_Unknown(&paMixerDevs[j].pwstrName);
                    }
                }

                if (!NT_SUCCESS(Status)) {
                    RETURN( Status );
                }
            } // if

        } // if

    } // for

    return( STATUS_SUCCESS );
}

NTSTATUS InitializeGetNumDevs
(
    PWDMACONTEXT pWdmaContext,
    DWORD        DeviceType,
    PCWSTR       DeviceInterface,
    LPDWORD      lpNumberOfDevices
)
{
    NTSTATUS            Status=STATUS_SUCCESS;
    HANDLE              hDevice = NULL;
    PDATARANGES         pDataRanges = NULL;
    PIDENTIFIERS        pPinInterfaces = NULL;
    PFILE_OBJECT        pFileObjectDevice = NULL;
    KSPIN_INTERFACE     RequestedInterface;
    KSPIN_DATAFLOW      RequestedDataFlow;
    GUID                RequestedMajorFormat;
    GUID                RequestedSubFormat;
    GUID                guidCategory;
    ULONG               cPins;
    ULONG               PinId;
    ULONG               Device;
    ULONG               TotalDevices;
    ULONG               ulSize;
    DWORD               cDevs;
    ULONG               i;
    BOOL                fDeviceAdded = FALSE;

    PAGED_CODE();
    ASSERT(DeviceType == WaveOutDevice ||
           DeviceType == WaveInDevice  ||
           DeviceType == MidiOutDevice ||
           DeviceType == MidiInDevice  ||
           DeviceType == MixerDevice ||
           DeviceType == AuxDevice);

    DPF( DL_TRACE|FA_SYSAUDIO, ("Class = %d", DeviceType) );

    //
    //  Setup a structure to compare with the interfaces that
    //  we want to find the number of.
    //
    switch (DeviceType)
    {
        case WaveOutDevice:
            RequestedInterface.Set    = KSINTERFACESETID_Media;
            RequestedInterface.Id     = KSINTERFACE_MEDIA_WAVE_QUEUED;
            RequestedInterface.Flags  = 0;
            RequestedDataFlow         = KSPIN_DATAFLOW_IN;
            RequestedMajorFormat      = KSDATAFORMAT_TYPE_AUDIO;
            RequestedSubFormat        = KSDATAFORMAT_TYPE_WILDCARD;
            break;

        case WaveInDevice:
            RequestedInterface.Set    = KSINTERFACESETID_Standard;
            RequestedInterface.Id     = KSINTERFACE_STANDARD_STREAMING;
            RequestedInterface.Flags  = 0;
            RequestedDataFlow         = KSPIN_DATAFLOW_OUT;
            RequestedMajorFormat      = KSDATAFORMAT_TYPE_AUDIO;
            RequestedSubFormat        = KSDATAFORMAT_TYPE_WILDCARD;
            break;

        case MidiOutDevice:
            RequestedInterface.Set    = KSINTERFACESETID_Standard;
            RequestedInterface.Id     = KSINTERFACE_STANDARD_STREAMING;
            RequestedInterface.Flags  = 0;
            RequestedDataFlow         = KSPIN_DATAFLOW_IN;
            RequestedMajorFormat      = KSDATAFORMAT_TYPE_MUSIC;
            RequestedSubFormat        = KSDATAFORMAT_SUBTYPE_MIDI;
            break;

        case MidiInDevice:
            RequestedInterface.Set    = KSINTERFACESETID_Standard;
            RequestedInterface.Id     = KSINTERFACE_STANDARD_STREAMING;
            RequestedInterface.Flags  = 0;
            RequestedDataFlow         = KSPIN_DATAFLOW_OUT;
            RequestedMajorFormat      = KSDATAFORMAT_TYPE_MUSIC;
            RequestedSubFormat        = KSDATAFORMAT_SUBTYPE_MIDI;
            break;

        case MixerDevice:
            Status = InitializeMixerGetNumDevs( pWdmaContext, DeviceInterface );
            fDeviceAdded = NT_SUCCESS(Status);
            goto exit;

        case AuxDevice:
            Status = InitializeAuxGetNumDevs( pWdmaContext, DeviceInterface );
            fDeviceAdded = NT_SUCCESS(Status);
            goto exit;
    }
    
    //
    // Get a handle to sysaudio
    //
    Status = OpenSysAudio(&hDevice, &pFileObjectDevice);

    if(!NT_SUCCESS(Status))
    {    
        goto exit;
    }
    //
    // for every pin on every device see if the interface matches
    // the DeviceType requested from user mode
    //
    Status = GetSysAudioProperty(pFileObjectDevice,
                                 KSPROPERTY_SYSAUDIO_DEVICE_COUNT,
                                 0,  // not used
                                 sizeof(TotalDevices),
                                 &TotalDevices);
    if(!NT_SUCCESS(Status))
    {
        DPF(DL_WARNING|FA_SYSAUDIO,("GetSysAudioProperty failed Status=%X",Status) );
        goto exit;
    }

    for (Device = 0; Device < TotalDevices; Device++)
    {
        //
        // Set the default renderer
        //
        Status = SetSysAudioProperty(pFileObjectDevice,
                                     KSPROPERTY_SYSAUDIO_DEVICE_INSTANCE,
                                     sizeof(Device),
                                     &Device);
        if(!NT_SUCCESS(Status))
        {
            DPF(DL_WARNING|FA_SYSAUDIO,("GetSysAudioProperty failed Status=%X",Status) );
            goto exit;
        }

        //
        //  Verify that this device matches the DevNode
        //  being enumerated
        //
        if (!IsPinForDevNode(pFileObjectDevice,Device,DeviceInterface))
        {
            continue;
        }

        //
        // Get the number of pins on the default renderer
        //
        Status = GetPinProperty(pFileObjectDevice,
                                KSPROPERTY_PIN_CTYPES,
                                0,
                                sizeof(cPins),
                                &cPins);

        if(!NT_SUCCESS(Status))
        {
            DPF(DL_WARNING|FA_SYSAUDIO,("GetPinProperty failed Status=%X",Status) );
            goto exit;
        }

        for(PinId = cPins; PinId > 0; PinId--)
        {
            KSPIN_DATAFLOW         DataFlow;
            KSPIN_COMMUNICATION    CommunicationType;
            PKSDATARANGE           pDataRange;
            PWSTR                  pwstrName = NULL;
            PKSCOMPONENTID         ComponentId = NULL;
            BOOL                   fInterfaceFound;
            BOOL                   fUsePreferred;
            ULONG                  index;
            ULONG                  d;

            //
            //  Check the dataflow
            //
            Status = GetPinProperty(pFileObjectDevice,
                                    KSPROPERTY_PIN_DATAFLOW,
                                    PinId-1,
                                    sizeof(KSPIN_DATAFLOW),
                                    &DataFlow);

            if(!NT_SUCCESS(Status))
            {
                DPF(DL_WARNING|FA_SYSAUDIO,("GetPinProperty failed Status=%X",Status) );
                goto exit;
            }

            if(RequestedDataFlow != DataFlow)
            {
                continue;
            }

            //
            //  Check the communication type
            //
            Status = GetPinProperty(pFileObjectDevice,
                                    KSPROPERTY_PIN_COMMUNICATION,
                                    PinId-1,
                                    sizeof(KSPIN_COMMUNICATION),
                                    &CommunicationType);

            if(!NT_SUCCESS(Status))
            {
                DPF(DL_WARNING|FA_SYSAUDIO,("GetPinProperty failed Status=%X",Status) );
                goto exit;
            }

            if(KSPIN_COMMUNICATION_SINK != CommunicationType &&
               KSPIN_COMMUNICATION_BOTH != CommunicationType)
            {
                continue;
            }

            //
            //  Allocates memory on my behalf.  Free later!!!
            //
            Status = GetPinPropertyEx(pFileObjectDevice,
                                      KSPROPERTY_PIN_INTERFACES,
                                      PinId-1,
                                      &pPinInterfaces);
            //
            // GetPinPropertyEx can return STATUS_PROPSET_NOT_FOUND which we
            // expect.  Thus, if we get this error, we need to keep looking rather
            // then fail.  If it returns STATUS_PROPSET_NOT_FOUND pPinInterfaces
            // will be NULL thus we must not touch it.
            //
            // Thus, if not successful AND not a successful error -> error out.
            //
            if(!NT_SUCCESS(Status) && Status != STATUS_PROPSET_NOT_FOUND )
            {
                DPF(DL_WARNING|FA_SYSAUDIO,("GetPinPropertyEx failed Status=%X",Status) );
                goto exit;
            }

            if( pPinInterfaces )
            {

                //
                //  Find an interface that matches
                //
                fInterfaceFound = FALSE;
                for(index = 0; index < pPinInterfaces->Count; index++)
                {
                    if (IsEqualInterface(&RequestedInterface,
                                         &pPinInterfaces->aIdentifiers[index]))
                    {
                        fInterfaceFound = TRUE;
                        break;
                    }
                }
                //
                //  We're done with the memory, so free
                //
                AudioFreeMemory_Unknown(&pPinInterfaces);

                if (!fInterfaceFound)
                {
                    continue;
                }
            }


            //
            //  If the device exposes a component Id, get it and cache it in AddDevice
            //
            Status = AudioAllocateMemory_Paged(sizeof(*ComponentId),
                                               TAG_Audp_NAME,
                                               ZERO_FILL_MEMORY,
                                               &ComponentId);
            if(NT_SUCCESS(Status))
            {
                Status = GetSysAudioProperty(pFileObjectDevice,
                                             KSPROPERTY_SYSAUDIO_COMPONENT_ID,
                                             Device,
                                             sizeof(*ComponentId),
                                             ComponentId);
                //
                // WorkItem: It is highly likely that GetSysAudioProperty will
                // return STATUS_INVALID_DEVICE_REQUEST for this call.  Why?
                //
                if (!NT_SUCCESS(Status))
                {
                    // Not a failure
                    AudioFreeMemory_Unknown(&ComponentId);
                    ComponentId = NULL;
                }
            }

            fUsePreferred = FALSE;
            pwstrName = NULL;

            //  Get the friendly name for this device.
            //  - First see if it the category is KSCATEGORY_WDMAUD_USE_PIN_NAME because
            //    SWMIDI uses this and there should only be one instance of SWMIDI
            //    in the system.
            //
            //  - Next check to see if the pins provide names, without using the
            //    KSCATEGORY_WDMAUD_USE_PIN_NAME category.  If so, use the name provided
            //    by the pin.
            //
            //  - Lastly, use the friendly name for the device if it exists.
            //
            //  If all attempts to get a name fail, then this pin is not used by WDMAUD.
            Status = GetPinProperty(pFileObjectDevice,
                                    KSPROPERTY_PIN_CATEGORY,
                                    PinId-1,
                                    sizeof(GUID),
                                    &guidCategory);
            //
            // WorkItem: GetPinProperty returns code c0000225 - STATUS_INVALID_DEVICE_REQUEST
            // for this call.  Why?
            //

            if(NT_SUCCESS(Status))
            {
                if(IsEqualGUID(&KSCATEGORY_WDMAUD_USE_PIN_NAME, &guidCategory))
                {
                    Status = GetPinPropertyEx(pFileObjectDevice,
                                              KSPROPERTY_PIN_NAME,
                                              PinId-1,
                                              &pwstrName);
                    //
                    // GetPinPropertyEx can return STATUS_PROPSET_NOT_FOUND which we
                    // expect.  Thus, if we get this error, we need to keep looking rather
                    // then fail.  If it returns STATUS_PROPSET_NOT_FOUND pwstrName
                    // will be NULL thus we must not touch it.
                    //
                    // Thus, if successful or it's the successful error code -> success
                    //
                    if(NT_SUCCESS(Status) || Status == STATUS_PROPSET_NOT_FOUND)
                    {
                        fUsePreferred = TRUE;
                    }
                    else
                    {
                        ASSERT(pwstrName == NULL);
                    }
                }
            }

            // As long as this is not SWMIDI, first try reading the name from the component ID
            if ((fUsePreferred == FALSE) && (ComponentId != NULL))
            {
                ReadProductNameFromMediaCategories(&ComponentId->Name,
                                                   &pwstrName);
            }

            // If that didn't work, take the regular old friendly name
            if(pwstrName == NULL)
            {
                Status = GetSysAudioProperty(
                  pFileObjectDevice,
                  KSPROPERTY_SYSAUDIO_DEVICE_FRIENDLY_NAME,
                  Device,
                  sizeof(ulSize),
                  &ulSize);

                if(NT_SUCCESS(Status))
                {
                    Status = AudioAllocateMemory_Paged(ulSize,
                                                       TAG_Audp_NAME,
                                                       ZERO_FILL_MEMORY,
                                                       &pwstrName);
                    if(!NT_SUCCESS(Status))
                    {
                        goto exit;
                    }

                    Status = GetSysAudioProperty(
                      pFileObjectDevice,
                      KSPROPERTY_SYSAUDIO_DEVICE_FRIENDLY_NAME,
                      Device,
                      ulSize,
                      pwstrName);

                    if (!NT_SUCCESS(Status))
                    {
                        AudioFreeMemory_Unknown(&pwstrName);
                    }
                }

                //
                //  Last chance...don't use devices without names
                //
                if (pwstrName == NULL)
                {
                    AudioFreeMemory_Unknown(&ComponentId);
                    continue;
                }
            }

            //
            //  Allocates memory on my behalf.  Store these
            //  dataranges in the structure of the device if
            //  we find a match that is good.
            //
            Status = GetPinPropertyEx(pFileObjectDevice,
                                      KSPROPERTY_PIN_DATARANGES,
                                      PinId-1,
                                      &pDataRanges);
            //
            // GetPinPropertyEx can return STATUS_PROPSET_NOT_FOUND which we
            // expect.  Thus, if we get this error, we need to keep looking rather
            // then fail.  If it returns STATUS_PROPSET_NOT_FOUND pDataRanges
            // will be NULL thus we must not touch it.
            //
            // Thus, if not successful AND not a successful error -> error out.
            //
            if (!NT_SUCCESS(Status) && Status != STATUS_PROPSET_NOT_FOUND )
            {
                DPF(DL_WARNING|FA_SYSAUDIO,("GetPinPropertyEx failed Status=%X",Status) );
                goto exit;
            }

            if( pDataRanges )
            {
                //
                //  See if we have a majorformat and subformat that
                //  we want
                //
                pDataRange = &pDataRanges->aDataRanges[0];

                for(d = 0; d < pDataRanges->Count; d++)
                {
                    if (IsEqualGUID(&RequestedMajorFormat,
                                    &pDataRange->MajorFormat) &&
                       (IsEqualGUID(&RequestedSubFormat,
                                    &KSDATAFORMAT_TYPE_WILDCARD) ||
                        IsEqualGUID(&RequestedSubFormat,
                                    &pDataRange->SubFormat) ) )
                    {

                        DPF( DL_TRACE|FA_SYSAUDIO, ("Found device!!!") );

                        //
                        //  Store so that we can retrieve later on
                        //  an open or getcaps call
                        //

                        Status = AddDevice(pWdmaContext,
                                           Device,
                                           DeviceType,
                                           DeviceInterface,
                                           PinId-1,
                                           pwstrName,
                                           fUsePreferred,
                                           pDataRanges,
                                           ComponentId);

                        if (NT_SUCCESS(Status))
                        {
                            fDeviceAdded = TRUE;

                            //
                            //  Mark these NULL so that it doesn't get freed
                            //  at the end of the loop.
                            //
                            //  This memory will get freed when the devnode
                            //  is removed and the device entry gets cleaned
                            //  up in RemoveDevNode.
                            //
                            pwstrName = NULL;
                            pDataRanges = NULL;
                            ComponentId = NULL;
                        }

                        break;  // Don't need to check anymore dataranges
                    }

                    // Get the pointer to the next data range
                    (PUCHAR)pDataRange += ((pDataRange->FormatSize +
                      FILE_QUAD_ALIGNMENT) & ~FILE_QUAD_ALIGNMENT);

                }
            }

            //
            //  We're done with the memory, so free
            //
            AudioFreeMemory_Unknown(&pDataRanges);
            AudioFreeMemory_Unknown(&pwstrName);
            AudioFreeMemory_Unknown(&ComponentId);

        } // pin enumeration

    } // device enumeration
exit:
    //
    //  Close down sysaudio for now
    //
    AudioFreeMemory_Unknown(&pPinInterfaces);
    AudioFreeMemory_Unknown(&pDataRanges);

    if(pFileObjectDevice != NULL)
    {
        ObDereferenceObject(pFileObjectDevice);
    }
    if(hDevice != NULL)
    {
        NtClose(hDevice);
    }

    if(fDeviceAdded)
    {
        PCOMMONDEVICE *ppCommonDevice;
        ULONG cRealDevs;

        ppCommonDevice = &pWdmaContext->apCommonDevice[DeviceType][0];
        for (cRealDevs = cDevs = i = 0; i < MAXNUMDEVS; i++)
        {
            if (ppCommonDevice[i]->Device == UNUSED_DEVICE ||
                MyWcsicmp(ppCommonDevice[i]->DeviceInterface, DeviceInterface))
            {
                continue;
            }
            ++cRealDevs;
            if (ppCommonDevice[i]->PreferredDevice == MAXULONG ||
                ppCommonDevice[i]->PreferredDevice == i)
            {
                ++cDevs;
            }
        }
        if(cDevs == 0 && cRealDevs > 0) {
            *lpNumberOfDevices = MAXULONG;
        }
        else {
            *lpNumberOfDevices = cDevs;
        }
    }
    else
    {
        *lpNumberOfDevices = 0;
    }

    RETURN( Status );
}

NTSTATUS wdmaudGetNumDevs
(
    PWDMACONTEXT pContext,
    DWORD        DeviceType,
    PCWSTR       DeviceInterfaceIn,
    LPDWORD      lpNumberOfDevices
)
{
    PDEVNODE_LIST_ITEM pDevNodeListItem;
    NTSTATUS Status = STATUS_SUCCESS;
    LARGE_INTEGER li = {0, 0};
    PLIST_ENTRY ple;

    PAGED_CODE();
    ASSERT(DeviceType == WaveOutDevice ||
           DeviceType == WaveInDevice  ||
           DeviceType == MidiOutDevice ||
           DeviceType == MidiInDevice  ||
           DeviceType == MixerDevice ||
           DeviceType == AuxDevice);

    *lpNumberOfDevices = 0;

    //
    // Can't use WdmaGrabMutex/WdmaReleaseMutex here
    //

    ASSERT(Status == STATUS_SUCCESS);

    for(ple = pContext->DevNodeListHead.Flink; ple != &pContext->DevNodeListHead; ple = ple->Flink) {
        pDevNodeListItem = CONTAINING_RECORD(ple, DEVNODE_LIST_ITEM, Next);

        if(!MyWcsicmp(pDevNodeListItem->DeviceInterface, DeviceInterfaceIn)) {

            if(pDevNodeListItem->cDevices[DeviceType] == MAXULONG) {

                DPF( DL_TRACE|FA_SYSAUDIO, ("MAXULONG: %ls[%d]",
                  DeviceInterfaceIn,
                  DeviceType));

                //
                // This status code there are still some pending add or
                // remove devices so the actual number of devices can't
                // be returned.
                //
                Status = STATUS_DEVICE_OFF_LINE;
            }
            else {
                *lpNumberOfDevices = pDevNodeListItem->cDevices[DeviceType];
                ASSERT(Status == STATUS_SUCCESS);
            }
            goto exit;
        }
    }
    //
    // This status code there are still some pending add or
    // remove devices so the actual number of devices can't
    // be returned.
    //
    Status = STATUS_DEVICE_OFF_LINE;
exit:
    if(NT_SUCCESS(Status)) {
        DPF( DL_TRACE|FA_SYSAUDIO, ("SUCCESS %ls[%d] %d",
          DeviceInterfaceIn,
          DeviceType,
          *lpNumberOfDevices));
    }

    RETURN(Status);
}

NTSTATUS PinProperty
(
    PFILE_OBJECT        pFileObject,
    const GUID          *pPropertySet,
    ULONG               ulPropertyId,
    ULONG               ulFlags,
    ULONG               cbProperty,
    PVOID               pProperty
)
{
    KSPROPERTY  Property;
    ULONG       BytesReturned;
    NTSTATUS    Status = STATUS_INVALID_PARAMETER;

    PAGED_CODE();
    if (pFileObject)
    {
        Property.Set = *pPropertySet;
        Property.Id = ulPropertyId;
        Property.Flags = ulFlags;

        ASSERT( pFileObject || !"PinProperty called with invalid pFileObject");

        if (ulPropertyId == KSPROPERTY_CONNECTION_STATE)
        {
            DPF( DL_TRACE|FA_SYSAUDIO, ("State=%d",*(PKSSTATE)pProperty));
        }

        DPF( DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY Id=%X",ulPropertyId) );

        Status = KsSynchronousIoControlDevice(
          pFileObject,
          KernelMode,
          IOCTL_KS_PROPERTY,
          &Property,
          sizeof(Property),
          pProperty,
          cbProperty,
          &BytesReturned);

        DPF( DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY results Status=%X, pProperty=%X,cbProperty=%X,BytesRet=%d",
                                   Status,pProperty,cbProperty,BytesReturned) );

    }

    if(!NT_SUCCESS(Status))
    {
        DPF(DL_TRACE|FA_SYSAUDIO, ("FAILED SetState = %d",*(PKSSTATE)pProperty));
        goto exit;
    }
exit:
    RETURN(Status);
}

NTSTATUS PinMethod
(
    PFILE_OBJECT        pFileObject,
    const GUID          *pMethodSet,
    ULONG               ulMethodId,
    ULONG               ulFlags,
    ULONG               cbMethod,
    PVOID               pMethod
)
{
    KSMETHOD    Method;
    ULONG       BytesReturned;
    NTSTATUS    Status = STATUS_INVALID_PARAMETER;

    PAGED_CODE();
    if (pFileObject)
    {
        Method.Set = *pMethodSet;
        Method.Id = ulMethodId;
        Method.Flags = ulFlags;

        ASSERT( pFileObject || !"PinMethod called with invalid pFileObject");

        DPF( DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY Id=%X",ulMethodId) );

        Status = KsSynchronousIoControlDevice(
          pFileObject,
          KernelMode,
          IOCTL_KS_METHOD,
          &Method,
          sizeof(Method),
          pMethod,
          cbMethod,
          &BytesReturned);

        DPF( DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY results Status=%X, pMethod=%X,cbMethod=%X,BytesRet=%d",
                                   Status,pMethod,cbMethod,BytesReturned) );
    }

    if(!NT_SUCCESS(Status))
    {
        DPF(DL_WARNING|FA_SYSAUDIO,("Failed Status=%X",Status) );
        goto exit;
    }
exit:
    RETURN(Status);
}

NTSTATUS
AttachVirtualSource(
    PFILE_OBJECT pFileObject,
    ULONG ulPinId
)
{
    SYSAUDIO_ATTACH_VIRTUAL_SOURCE  AttachVirtualSource;
    NTSTATUS                        Status = STATUS_INVALID_PARAMETER;
    ULONG                           BytesReturned;

    PAGED_CODE();
    if (pFileObject)
    {
        if(ulPinId == MAXULONG) {
            DPF(DL_WARNING|FA_SYSAUDIO,("Invalid ulPinId=%X",ulPinId) );
            Status = STATUS_INVALID_DEVICE_REQUEST;
            goto exit;
        }
        AttachVirtualSource.Property.Set = KSPROPSETID_Sysaudio_Pin;
        AttachVirtualSource.Property.Id =
          KSPROPERTY_SYSAUDIO_ATTACH_VIRTUAL_SOURCE;
        AttachVirtualSource.Property.Flags = KSPROPERTY_TYPE_SET;
        AttachVirtualSource.MixerPinId = ulPinId;

        DPF( DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY Id=%X",
                                   AttachVirtualSource.Property.Id) );

        Status = KsSynchronousIoControlDevice(
          pFileObject,
          KernelMode,
          IOCTL_KS_PROPERTY,
          &AttachVirtualSource,
          sizeof(AttachVirtualSource),
          NULL,
          0,
          &BytesReturned);

        DPF( DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY results Status=%X,BytesRet=%d",
                                   Status,BytesReturned) );
    }

    if(!NT_SUCCESS(Status)) {
        DPF(DL_WARNING|FA_SYSAUDIO,("Failed Status=%X",Status) );
        goto exit;
    }
exit:
    RETURN(Status);
}

NTSTATUS
SysAudioPnPNotification(
    IN PVOID NotificationStructure,
    IN PVOID _Context
)
{
    PWDMACONTEXT pContext = (PWDMACONTEXT)_Context;
    PDEVICE_INTERFACE_CHANGE_NOTIFICATION pNotification;
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();
    ASSERT(pContext);

    DPF( DL_TRACE|FA_SYSAUDIO,("pWdmaContext=%08Xh", pContext) );

    pNotification =
      (PDEVICE_INTERFACE_CHANGE_NOTIFICATION)NotificationStructure;

    // The notification sends null terminated unicode strings
    if(IsEqualGUID(&pNotification->Event, &GUID_DEVICE_INTERFACE_ARRIVAL)) {
        Status = QueueWorkList(pContext, InitializeSysaudio, pContext, 0);
        if (!NT_SUCCESS(Status)) {
            // At this point pContext->fInitializeSysaudio will still be false because we never
            // ran the work item.  If we don't signal this event, IOCTL_WDMAUD_INIT will deadlock.
            ASSERT(pContext->fInitializeSysaudio == FALSE);

            KeSetEvent(&pContext->InitializedSysaudioEvent, 0, FALSE);
        }
    }
    return(Status);
}

NTSTATUS
InitializeSysaudio(
    PVOID Reference1,
    PVOID Reference2
)
{
    PWDMACONTEXT pWdmaContext = (PWDMACONTEXT)Reference1;
    SYSAUDIO_CREATE_VIRTUAL_SOURCE CreateVirtualSource;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG BytesReturned;
    KSEVENT Event;

    PAGED_CODE();
    ASSERT(pWdmaContext);

    DPF( DL_TRACE|FA_SYSAUDIO,("pWdmaContext=%08Xh", pWdmaContext) );

    if(pWdmaContext->SysaudioWorkerObject == NULL) {
        goto exit;
    }

    if( pWdmaContext->pFileObjectSysaudio == NULL )
    {
        pWdmaContext->pFileObjectSysaudio = kmxlOpenSysAudio();
        if( pWdmaContext->pFileObjectSysaudio == NULL )
        {
            DPF(DL_WARNING|FA_SYSAUDIO,("NULL pFileObjectSysaudio, pWdmaContext=%08X",pWdmaContext) );        
            goto exit;
        }
    }
    //
    // Initialize the wave and synth virtual source lines
    //

    CreateVirtualSource.Property.Set = KSPROPSETID_Sysaudio;
    CreateVirtualSource.Property.Flags = KSPROPERTY_TYPE_GET;

    if(pWdmaContext->VirtualWavePinId == MAXULONG) {
        CreateVirtualSource.Property.Id =
          KSPROPERTY_SYSAUDIO_CREATE_VIRTUAL_SOURCE_ONLY;
        CreateVirtualSource.PinCategory = KSNODETYPE_LEGACY_AUDIO_CONNECTOR;
        CreateVirtualSource.PinName = KSNODETYPE_LEGACY_AUDIO_CONNECTOR;

        DPF( DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY %X",CreateVirtualSource) );

        Status = KsSynchronousIoControlDevice(
          pWdmaContext->pFileObjectSysaudio,
          KernelMode,
          IOCTL_KS_PROPERTY,
          &CreateVirtualSource,
          sizeof(CreateVirtualSource),
          &pWdmaContext->VirtualWavePinId,
          sizeof(pWdmaContext->VirtualWavePinId),
          &BytesReturned);

        DPF( DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY results Status=%X,BytesRet=%d",
                                   Status,BytesReturned) );

        if(!NT_SUCCESS(Status)) {
            DPF(DL_WARNING|FA_SYSAUDIO,("Failed Property query Status=%X",Status) );
            goto exit;
        }
        ASSERT(BytesReturned == sizeof(pWdmaContext->VirtualWavePinId));
    }
    if(pWdmaContext->VirtualMidiPinId == MAXULONG) {
        CreateVirtualSource.Property.Id =
          KSPROPERTY_SYSAUDIO_CREATE_VIRTUAL_SOURCE;
        CreateVirtualSource.PinCategory = KSNODETYPE_SYNTHESIZER;
        CreateVirtualSource.PinName = KSNODETYPE_SWSYNTH;

        DPF( DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY %X",CreateVirtualSource) );

        Status = KsSynchronousIoControlDevice(
          pWdmaContext->pFileObjectSysaudio,
          KernelMode,
          IOCTL_KS_PROPERTY,
          &CreateVirtualSource,
          sizeof(CreateVirtualSource),
          &pWdmaContext->VirtualMidiPinId,
          sizeof(pWdmaContext->VirtualMidiPinId),
          &BytesReturned);

        DPF( DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY results Status=%X,BytesRet=%d",
                                   Status,BytesReturned) );

        if(!NT_SUCCESS(Status)) {
            DPF(DL_WARNING|FA_SYSAUDIO,("Failed Property query Status=%X",Status) );
            goto exit;
        }
        ASSERT(BytesReturned == sizeof(pWdmaContext->VirtualMidiPinId));
    }
    if(pWdmaContext->VirtualCDPinId == MAXULONG) {
        CreateVirtualSource.Property.Id =
          KSPROPERTY_SYSAUDIO_CREATE_VIRTUAL_SOURCE;
        CreateVirtualSource.PinCategory = KSNODETYPE_CD_PLAYER;
        CreateVirtualSource.PinName = KSNODETYPE_CD_PLAYER;

        DPF( DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY %X",CreateVirtualSource) );

        Status = KsSynchronousIoControlDevice(
          pWdmaContext->pFileObjectSysaudio,
          KernelMode,
          IOCTL_KS_PROPERTY,
          &CreateVirtualSource,
          sizeof(CreateVirtualSource),
          &pWdmaContext->VirtualCDPinId,
          sizeof(pWdmaContext->VirtualCDPinId),
          &BytesReturned);

        DPF( DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY results Status=%X,BytesRet=%d",
                                   Status,BytesReturned) );

        if(!NT_SUCCESS(Status)) {
            DPF(DL_WARNING|FA_SYSAUDIO,("Failed Property query Status=%X",Status) );
            goto exit;
        }
        ASSERT(BytesReturned == sizeof(pWdmaContext->VirtualCDPinId));
    }

    //
    // Initialize the device add/remove ks event
    //
    if(!pWdmaContext->fInitializeSysaudio) {

        Event.Set = KSEVENTSETID_Sysaudio;
        Event.Id = KSEVENT_SYSAUDIO_ADDREMOVE_DEVICE;
        Event.Flags = KSEVENT_TYPE_ENABLE;

        pWdmaContext->EventData.NotificationType = KSEVENTF_KSWORKITEM;
        pWdmaContext->EventData.KsWorkItem.WorkQueueItem =
          &pWdmaContext->SysaudioWorkItem;
        pWdmaContext->EventData.KsWorkItem.KsWorkerObject =
          pWdmaContext->SysaudioWorkerObject;
        pWdmaContext->EventData.KsWorkItem.Reserved = 0;

        DPF( DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY Event=%X",Event) );

        Status = KsSynchronousIoControlDevice(
          pWdmaContext->pFileObjectSysaudio,
          KernelMode,
          IOCTL_KS_ENABLE_EVENT,
          &Event,
          sizeof(Event),
          &pWdmaContext->EventData,
          sizeof(pWdmaContext->EventData),
          &BytesReturned);

        DPF( DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY results Status=%X,BytesRet=%d",
                                   Status,BytesReturned) );

        if(!NT_SUCCESS(Status)) {
            DPF(DL_WARNING|FA_SYSAUDIO,("Failed Property query Status=%X",Status) );
            goto exit;
        }
        pWdmaContext->fInitializeSysaudio = TRUE;
    }
exit:
    KeSetEvent(&pWdmaContext->InitializedSysaudioEvent, 0, FALSE);
    RETURN(Status);
}

VOID
UninitializeSysaudio(
    PWDMACONTEXT pWdmaContext
)
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;
    ULONG BytesReturned;

    PAGED_CODE();
    DPF( DL_TRACE|FA_SYSAUDIO, ("Entering") );
    if(pWdmaContext->pFileObjectSysaudio != NULL) {
        if(pWdmaContext->fInitializeSysaudio) {
            DPF( DL_TRACE|FA_SYSAUDIO,("KS_DISABLE_EVENT EventData=%X",
                                       pWdmaContext->EventData) );

            Status = KsSynchronousIoControlDevice(
              pWdmaContext->pFileObjectSysaudio,
              KernelMode,
              IOCTL_KS_DISABLE_EVENT,
              &pWdmaContext->EventData,
              sizeof(pWdmaContext->EventData),
              NULL,
              0,
              &BytesReturned);

            DPF( DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY results Status=%X,BytesRet=%d",
                                       Status,BytesReturned) );

            pWdmaContext->VirtualWavePinId = MAXULONG;
            pWdmaContext->VirtualMidiPinId = MAXULONG;
            pWdmaContext->VirtualCDPinId = MAXULONG;
            pWdmaContext->fInitializeSysaudio = FALSE;

            DPF( DL_TRACE|FA_SYSAUDIO,("Exiting %08x", Status));
        }
    }
}

NTSTATUS
AddDevNode(
    PWDMACONTEXT pContext,
    PCWSTR       DeviceInterfaceIn,
    UINT         DeviceType
)
{
    NTSTATUS Status=STATUS_SUCCESS;
    PDEVNODE_LIST_ITEM pDevNodeListItem = NULL;
    PLIST_ENTRY ple;
    ULONG t;

    PAGED_CODE();
    DPF( DL_TRACE|FA_SYSAUDIO,("%08x [%ls] %d", pContext, DeviceInterfaceIn, DeviceType));

    for(ple = pContext->DevNodeListHead.Flink; ple != &pContext->DevNodeListHead; ple = ple->Flink) {
        pDevNodeListItem = CONTAINING_RECORD(ple, DEVNODE_LIST_ITEM, Next);
        if(!MyWcsicmp(pDevNodeListItem->DeviceInterface, DeviceInterfaceIn)) {
            ++pDevNodeListItem->cReference;
            DPF( DL_TRACE|FA_SYSAUDIO, ("cReference is now %d", pDevNodeListItem->cReference));
            goto exit;
        }
    }

    //  Limit the number of devnodes that can be added
    if (pContext->DevNodeListCount > MAXDEVNODES) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }

    pDevNodeListItem = NULL;
    Status = AudioAllocateMemory_Paged(sizeof(DEVNODE_LIST_ITEM),
                                       TAG_AudN_NODE,
                                       ZERO_FILL_MEMORY,
                                       &pDevNodeListItem);
    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
    DPF( DL_TRACE|FA_SYSAUDIO, ("New pDevNodeListItem (%08x)", pDevNodeListItem));

    Status = AudioAllocateMemory_Paged((wcslen(DeviceInterfaceIn)+1)*sizeof(WCHAR),
                                       TAG_AudD_DEVICEINFO,
                                       ZERO_FILL_MEMORY,
                                       &pDevNodeListItem->DeviceInterface);
    if (!NT_SUCCESS(Status)) {
        AudioFreeMemory(sizeof(DEVNODE_LIST_ITEM),&pDevNodeListItem);
        goto exit;
    }

    wcscpy(pDevNodeListItem->DeviceInterface, DeviceInterfaceIn);
    pDevNodeListItem->cReference = 1;
    DPF( DL_TRACE|FA_SYSAUDIO, ("cReference is now 1"));

    for(t = 0; t < MAX_DEVICE_CLASS; t++) {
        pDevNodeListItem->cDevices[t] = MAXULONG;
        pDevNodeListItem->fAdded[t] = FALSE;
    }
    InsertTailList(&pContext->DevNodeListHead, &pDevNodeListItem->Next);
    pContext->DevNodeListCount++;
exit:
    if (pDevNodeListItem)
    {
        pDevNodeListItem->fAdded[DeviceType] = TRUE;
        Status=ProcessDevNodeListItem(pContext, pDevNodeListItem, DeviceType);
    }

    RETURN( Status );
}

VOID
RemoveDevNode(
    PWDMACONTEXT pWdmaContext,
    PCWSTR       DeviceInterfaceIn,
    UINT         DeviceType
)
{
    PDEVNODE_LIST_ITEM pDevNodeListItem;
    PLIST_ENTRY ple, pleNext;
    PCOMMONDEVICE *papCommonDevice;
    ULONG d, j;

    PAGED_CODE();
    DPF( DL_TRACE|FA_SYSAUDIO, ("%08x %ls %d", pWdmaContext, DeviceInterfaceIn, DeviceType));

    papCommonDevice = &pWdmaContext->apCommonDevice[DeviceType][0];

    for(ple = pWdmaContext->DevNodeListHead.Flink; ple != &pWdmaContext->DevNodeListHead; ple = pleNext) {
        pleNext = ple->Flink;
        pDevNodeListItem = CONTAINING_RECORD(ple, DEVNODE_LIST_ITEM, Next);
        if(!MyWcsicmp(pDevNodeListItem->DeviceInterface, DeviceInterfaceIn)) {

            for (d = 0; d < MAXNUMDEVS; d++) {

                if(papCommonDevice[d]->Device == UNUSED_DEVICE ||
                   MyWcsicmp(papCommonDevice[d]->DeviceInterface, DeviceInterfaceIn)) {
                    continue;
                }

                if(papCommonDevice[d]->PreferredDevice == d) {
                    ULONG p = MAXULONG;

                    for(j = 0; j < MAXNUMDEVS; j++) {

                        if(j == d)
                            continue;

                        if(papCommonDevice[j]->Device == UNUSED_DEVICE)
                            continue;

                        if(papCommonDevice[j]->PreferredDevice != d)
                            continue;

                        if(p == MAXULONG) {
                            p = j;
                        }
                        papCommonDevice[j]->PreferredDevice = p;
                    }
                }

                switch(DeviceType)
                {
                    case WaveOutDevice:
                        if ( pWdmaContext->WaveOutDevs[d].pTimer != NULL )
                            KeCancelTimer(pWdmaContext->WaveOutDevs[d].pTimer);

                        CleanupWavePins(&pWdmaContext->WaveOutDevs[d]);

                        AudioFreeMemory_Unknown(&pWdmaContext->WaveOutDevs[d].AudioDataRanges);
                        AudioFreeMemory_Unknown(&pWdmaContext->WaveOutDevs[d].pTimer);
                        AudioFreeMemory_Unknown(&pWdmaContext->WaveOutDevs[d].pDpc);
                        break;

                    case WaveInDevice:
                        CleanupWavePins(&pWdmaContext->WaveInDevs[d]);

                        AudioFreeMemory_Unknown(&pWdmaContext->WaveInDevs[d].AudioDataRanges);
                        break;

                    case MidiOutDevice:
                        CloseMidiDevicePin(&pWdmaContext->MidiOutDevs[d]);
                        AudioFreeMemory_Unknown(&pWdmaContext->MidiOutDevs[d].MusicDataRanges);
                        break;

                    case MidiInDevice:
                        CloseMidiDevicePin(&pWdmaContext->MidiInDevs[d]);
                        AudioFreeMemory_Unknown(&pWdmaContext->MidiInDevs[d].MusicDataRanges);
                        break;

                    case MixerDevice:
                        kmxlDeInit(&pWdmaContext->MixerDevs[d]);
                        break;
                }

                AudioFreeMemory_Unknown(&papCommonDevice[d]->pwstrName);
                AudioFreeMemory_Unknown(&papCommonDevice[d]->DeviceInterface);
                AudioFreeMemory_Unknown(&papCommonDevice[d]->ComponentId);

                papCommonDevice[d]->pwstrName = NULL;
                papCommonDevice[d]->DeviceInterface = NULL;
                papCommonDevice[d]->Device = UNUSED_DEVICE;
            }
            pDevNodeListItem->cDevices[DeviceType] = MAXULONG;
            pDevNodeListItem->fAdded[DeviceType] = FALSE;
            ASSERT(pDevNodeListItem->cReference > 0);

            if(--pDevNodeListItem->cReference > 0) {
                DPF( DL_TRACE|FA_SYSAUDIO, ("cReference is now %d", pDevNodeListItem->cReference));
                break;
            }

            DPF( DL_TRACE|FA_SYSAUDIO, ("Freeing %08x", pDevNodeListItem));
            RemoveEntryList(&pDevNodeListItem->Next);
            pWdmaContext->DevNodeListCount--;
            AudioFreeMemory_Unknown(&pDevNodeListItem->DeviceInterface);
            AudioFreeMemory_Unknown(&pDevNodeListItem);
            break;
        }
    }
}

VOID
SysaudioAddRemove(
    PWDMACONTEXT pContext
)
{
    PDEVNODE_LIST_ITEM pDevNodeListItem;
    PLIST_ENTRY ple;
    int t;

    PAGED_CODE();
    DPF( DL_TRACE|FA_SYSAUDIO, ("Entering"));
    WdmaGrabMutex(pContext);

    DPFASSERT(IsValidWdmaContext(pContext));

    if(pContext->SysaudioWorkerObject != NULL) {

    for(ple = pContext->DevNodeListHead.Flink;
        ple != &pContext->DevNodeListHead;
        ple = ple->Flink) {

        pDevNodeListItem = CONTAINING_RECORD(ple, DEVNODE_LIST_ITEM, Next);

        for(t = 0; t < MAX_DEVICE_CLASS; t++) {
        ProcessDevNodeListItem(pContext, pDevNodeListItem, t);
        }
    }
    }
    // Need this for to get more KS events
    pContext->SysaudioWorkItem.List.Blink = NULL;

    WdmaReleaseMutex(pContext);
    DPF(DL_TRACE|FA_SYSAUDIO, ("Exiting"));
}

NTSTATUS
ProcessDevNodeListItem
(
    PWDMACONTEXT pWdmaContext,
    PDEVNODE_LIST_ITEM pDevNodeListItem,
    ULONG DeviceType
)
{
    NTSTATUS Status=STATUS_SUCCESS;

    PAGED_CODE();
    if(!pWdmaContext->fInitializeSysaudio) {
        RETURN( STATUS_UNSUCCESSFUL );
    }
    if(!pDevNodeListItem->fAdded[DeviceType]) {
        ASSERT(pDevNodeListItem->cDevices[DeviceType] == MAXULONG);
        RETURN( Status );
    }
    DPF( DL_TRACE|FA_SYSAUDIO, ("%ls[%d]",
         pDevNodeListItem->DeviceInterface,
         DeviceType));

    Status=InitializeGetNumDevs(
      pWdmaContext,
      DeviceType,
      pDevNodeListItem->DeviceInterface,
      &pDevNodeListItem->cDevices[DeviceType]);

    if (!NT_SUCCESS(Status)) {
        RETURN( Status );
        }

    if(DeviceType == MixerDevice &&
       (pDevNodeListItem->fAdded[WaveOutDevice] ||
        pDevNodeListItem->fAdded[WaveInDevice])) {

        Status = kmxlInitializeMixer( pWdmaContext,
                                      pDevNodeListItem->DeviceInterface,
                                      pDevNodeListItem->cDevices[MixerDevice] );

        if(NT_SUCCESS(Status) && pDevNodeListItem->cDevices[MixerDevice]) {
            if(pDevNodeListItem->fAdded[WaveOutDevice]) {
                FindVolumeControl(pWdmaContext, pDevNodeListItem->DeviceInterface, WaveOutDevice);
            }
            if(pDevNodeListItem->fAdded[MidiOutDevice]) {
                FindVolumeControl(pWdmaContext, pDevNodeListItem->DeviceInterface, MidiOutDevice);
            }
        }
    }

    RETURN( Status );
}

#pragma LOCKED_CODE

NTSTATUS
QueueWorkList
(
    PWDMACONTEXT pContext,
    VOID (*Function)(
        PVOID Reference1,
        PVOID Reference2
    ),
    PVOID Reference1,
    PVOID Reference2
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PWORK_LIST_ITEM pWorkListItem = NULL;

    if(pContext->WorkListWorkerObject == NULL) {
    ASSERT(NT_SUCCESS(Status));
    goto exit;
    }

    Status = AudioAllocateMemory_Fixed(sizeof(WORK_LIST_ITEM),
                                       TAG_AudE_EVENT,
                                       ZERO_FILL_MEMORY,
                                       &pWorkListItem);
    if(!NT_SUCCESS(Status))
    {
        DPF( DL_TRACE|FA_SYSAUDIO, ("Failing QueueWorkList: %08x", Status));
        goto exit;
    }

    pWorkListItem->Reference1 = Reference1;
    pWorkListItem->Reference2 = Reference2;
    pWorkListItem->Function = Function;

    ExInterlockedInsertTailList(&pContext->WorkListHead,
                                &pWorkListItem->Next,
                                &pContext->WorkListSpinLock);

    if(InterlockedIncrement(&pContext->cPendingWorkList) == 1) {
        KsQueueWorkItem(pContext->WorkListWorkerObject, &pContext->WorkListWorkItem);
    }
exit:
    RETURN( Status );
}

VOID
WorkListWorker(
    PVOID pReference
)
{
    PWDMACONTEXT pContext = (PWDMACONTEXT)pReference;
    PWORK_LIST_ITEM pWorkListItem;
    PLIST_ENTRY ple;

    ASSERT(pContext);

    WdmaGrabMutex(pContext);

    while((ple = ExInterlockedRemoveHeadList(
        &pContext->WorkListHead,
        &pContext->WorkListSpinLock)) != NULL) 
    {

        pWorkListItem = CONTAINING_RECORD(ple, WORK_LIST_ITEM, Next);

        (*pWorkListItem->Function)(pWorkListItem->Reference1,pWorkListItem->Reference2);

        AudioFreeMemory(sizeof(sizeof(WORK_LIST_ITEM)),&pWorkListItem);

        if(InterlockedDecrement(&pContext->cPendingWorkList) == 0) {
            break;
        }
    }

    WdmaReleaseMutex(pContext);
}

VOID
WdmaGrabMutex(
    PWDMACONTEXT pWdmaContext
)
{
//    KeWaitForMutexObject(&pWdmaContext->wdmaContextMutex, Executive, KernelMode, FALSE, NULL);
    //
    // Turn off the APCDisable flag in the thread structure before going for our
    // mutex.  This will prevent us from getting suspeneded while holding this
    // mutex.
    //
    KeEnterCriticalRegion();
    KeWaitForMutexObject(&wdmaMutex, Executive, KernelMode, FALSE, NULL);
}

VOID
WdmaReleaseMutex(
    PWDMACONTEXT pWdmaContext
)
{
//    KeReleaseMutex(&pWdmaContext->wdmaContextMutex, FALSE);
    KeReleaseMutex(&wdmaMutex, FALSE);
    KeLeaveCriticalRegion();
}

VOID WdmaContextCleanup(PWDMACONTEXT pWdmaContext)
{
    LONG DeviceType;
    LONG DeviceNumber;
    PDEVNODE_LIST_ITEM pDevNodeListItem = NULL;
    PLIST_ENTRY ple;

    DPF( DL_TRACE|FA_SYSAUDIO, ("%08x", pWdmaContext));

    for (DeviceType = 0; DeviceType < MAX_DEVICE_CLASS; DeviceType++)
    {
        for (DeviceNumber = 0; DeviceNumber < MAXNUMDEVS; DeviceNumber++)
        {
            PCOMMONDEVICE pDevice;

            pDevice = pWdmaContext->apCommonDevice[DeviceType][DeviceNumber];

            ASSERT(pDevice);
            if (UNUSED_DEVICE != pDevice->Device)
            {
                LPWSTR DeviceInterface = NULL;
                NTSTATUS Status;

                ASSERT(pDevice->DeviceInterface);

                if (pDevice->DeviceInterface) {
                    Status = AudioAllocateMemory_Paged((wcslen(pDevice->DeviceInterface)+1)*sizeof(WCHAR),
                                                       TAG_AudD_DEVICEINFO,
                                                       DEFAULT_MEMORY,
                                                       &DeviceInterface);
                    if (NT_SUCCESS(Status))
                    {
                        wcscpy( DeviceInterface, pDevice->DeviceInterface );
                        RemoveDevNode(pWdmaContext, DeviceInterface, DeviceType);
                        AudioFreeMemory_Unknown(&DeviceInterface);
                    }
                }
            }
        }
    }

    //
    //  Cleanup any remaining devnode list items
    //
    while (!IsListEmpty(&pWdmaContext->DevNodeListHead))
    {
        ple = pWdmaContext->DevNodeListHead.Flink;
        pDevNodeListItem = CONTAINING_RECORD(ple, DEVNODE_LIST_ITEM, Next);
        DPF( DL_TRACE|FA_SYSAUDIO, ("Stray devnode list item = %08x", pDevNodeListItem));
        RemoveHeadList(&pWdmaContext->DevNodeListHead);
        pWdmaContext->DevNodeListCount--;
        AudioFreeMemory_Unknown(&pDevNodeListItem->DeviceInterface);
        AudioFreeMemory_Unknown(&pDevNodeListItem);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\legacy\wdmaud.sys\wdmsys.h ===
/****************************************************************************
 *
 *   wdmsys.h
 *
 *   Function declarations, etc. for WDMAUD.SYS
 *
 *   Copyright (C) Microsoft Corporation, 1997 - 1999  All Rights Reserved.
 *
 *   History
 *      5-19-97 - Noel Cross (NoelC)
 *
 ***************************************************************************/

#ifndef _WDMSYS_H_INCLUDED_
#define _WDMSYS_H_INCLUDED_

#ifdef UNDER_NT
#if DBG
#define DEBUG
#endif
#endif

#include <ntddk.h>
#include <windef.h>
#include <winerror.h>

#include <memory.h>
#include <stddef.h>
#include <stdio.h>
#include <limits.h>
#include <stdlib.h>
#include <tchar.h>
#include <conio.h>
#include <math.h>

// Make sure we will get correct multimedia structures from mmsystem.
#ifdef UNDER_NT
#ifndef _WIN32
#pragma message( "WARNING: _WIN32 not defined.  Build not valid for NT." )
#endif
#ifndef UNICODE
#pragma message( "WARNING: UNICODE not defined.  Build not valid for NT." )
#endif
#else
#pragma message( "WARNING: UNDER_NT not defined.  Build not valid for NT." )
#endif

#define NOBITMAP
#include <mmsystem.h>
#include <mmreg.h>
#include <mmddk.h>
#undef NOBITMAP
#include <ks.h>
#include <ksmediap.h>
#include <swenum.h>
#include <ksdebug.h>
#include <midi.h>
#include <wdmaud.h>
#include "mixer.h"
#include "robust.h"

#define INIT_CODE       code_seg("INIT", "CODE")
#define INIT_DATA       data_seg("INIT", "DATA")
#define LOCKED_CODE     code_seg(".text", "CODE")
#define LOCKED_DATA     data_seg(".data", "DATA")
#define PAGEABLE_CODE   code_seg("PAGE", "CODE")
#define PAGEABLE_DATA   data_seg("PAGEDATA", "DATA")

#pragma PAGEABLE_CODE
#pragma PAGEABLE_DATA

/***************************************************************************

 Constants

 ***************************************************************************/

#define PROFILE   // turn on to help with debugging

#define WAVE_CONTROL_VOLUME     0
#define WAVE_CONTROL_RATE       1
#define WAVE_CONTROL_QUALITY    2

#define MAX_WAVE_CONTROLS       3

#define MIDI_CONTROL_VOLUME     0

#define MAX_MIDI_CONTROLS       1

#define WILD_CARD               0xfffffffe
#define INVALID_NODE            0xffffffff

#define MAXNUMDEVS              32
#define MAXDEVNODES             100

#define STR_MODULENAME  "wdmaud.sys: "

#define STR_DEVICENAME  TEXT("\\Device\\wdmaud")
#define STR_LINKNAME    TEXT("\\DosDevices\\wdmaud")

#define STR_PNAME       TEXT("%s (%d)")

#ifdef DEBUG
#define CONTEXT_SIGNATURE     'XNOC' // CONteXt structure
#define MIXERDEVICE_SIGNATURE 'DXIM' // MIXerDevice structure 
#define MIXEROBJECT_SIGNATURE 'OXIM' // MIXerObject structure
#define HWLINK_SIGNATURE      'KLWH' //HWLINK signature
#endif

#define LIVE_CONTROL ((PMXLCONTROL)(-1))

#define INCREASE TRUE
#define DECREASE FALSE

/***************************************************************************

 structure definitions

 ***************************************************************************/

typedef struct _WDMAPENDINGIRP_QUEUE {
    LIST_ENTRY  WdmaPendingIrpListHead;
    KSPIN_LOCK  WdmaPendingIrpListSpinLock;
    IO_CSQ      Csq;
} WDMAPENDINGIRP_QUEUE, *PWDMAPENDINGIRP_QUEUE;

extern WDMAPENDINGIRP_QUEUE wdmaPendingIrpQueue;

typedef struct _WDMAPENDINGIRP_CONTEXT {
    IO_CSQ_IRP_CONTEXT IrpContext;
    ULONG IrpDeviceType;
    struct tag_WDMACONTEXT *pContext;
} WDMAPENDINGIRP_CONTEXT, *PWDMAPENDINGIRP_CONTEXT;

typedef struct tag_ALLOCATED_MDL_LIST_ITEM
{
    LIST_ENTRY              Next;
    PMDL                    pMdl;
    struct tag_WDMACONTEXT *pContext;

} ALLOCATED_MDL_LIST_ITEM , *PALLOCATED_MDL_LIST_ITEM;

//typedef struct tag_IOCTL_HISTORY_LIST_ITEM
//{
//    LIST_ENTRY              Next;
//    PIRP                    pIrp;
//    ULONG                   IoCode;
//    NTSTATUS                IoStatus;
//    struct tag_WDMACONTEXT *pContext;
//} IOCTL_HISTORY_LIST_ITEM , *PIOCTL_HISTORY_LIST_ITEM;

typedef struct device_instance
{
    PVOID           pDeviceHeader;
} DEVICE_INSTANCE, *PDEVICE_INSTANCE;

typedef struct _CONTROL_NODE
{
   GUID    Control;
   ULONG   NodeId;
   ULONG   Reserved;
} CONTROL_NODE, *PCONTROL_NODE;

typedef struct _CONTROLS_LIST
{
   ULONG   Count;
   ULONG   Reserved;
   CONTROL_NODE Controls[1];
} CONTROLS_LIST, *PCONTROLS_LIST;

typedef struct _WAVEPOSITION {
    DWORD               Operation;                     // Get / Set
    DWORD               BytePos;
} WAVEPOSITION, *PWAVEPOSITION, FAR *LPWAVEPOSITION;

typedef struct _DEVICEVOLUME {
    DWORD               Operation;                     // Get / Set
    DWORD               Channel;
    DWORD               Level;
} DEVICEVOLUME, *PDEVICEVOLUME, FAR *LPDEVICEVOLUME;

#define WAVE_PIN_INSTANCE_SIGNATURE ((ULONG)'SIPW') //WPIS

//
// This macro can be used with NT_SUCCESS to branch.  Effectively returns an
// NTSTATUS code.
//
#define IsValidWavePinInstance(pwpi) ((pwpi->dwSig == WAVE_PIN_INSTANCE_SIGNATURE) ? \
                                      STATUS_SUCCESS:STATUS_UNSUCCESSFUL)

//
// The Wave pin instance structure and the midi pin instance structure need to
// use a common header so that the duplicate servicing functions can be
// removed.
//
typedef struct _WAVEPININSTANCE
{
   PFILE_OBJECT             pFileObject;
   PDEVICE_OBJECT           pDeviceObject;
   struct tag_WAVEDEVICE   *pWaveDevice;

   KSPIN_LOCK               WavePinSpinLock;  // For State Changes

   BOOL                     fGraphRunning;

   KSSTATE                  PinState;
   KEVENT                   StopEvent;
   KEVENT                   PauseEvent;
   volatile ULONG           NumPendingIos;
   volatile BOOL            StoppingSource;  //  Flag which indicates
                                             //  that the pin is in the
                                             //  stopping process
   volatile BOOL            PausingSource;   //  Flag which indicates
                                             //  that the pin is in the
                                             //  pausing process
   ULONG                    DeviceNumber;
   ULONG                    DataFlow;
   BOOL                     fWaveQueued;
   LPWAVEFORMATEX           lpFormat;
   DWORD                    dwFlags;

   PCONTROLS_LIST           pControlList;

   HANDLE32                 WaveHandle;
   struct _WAVEPININSTANCE  *Next;

   DWORD                    dwSig;  //Used to validate structure.
} WAVE_PIN_INSTANCE, *PWAVE_PIN_INSTANCE;

typedef struct _midiinhdr
{
    LIST_ENTRY              Next;
    LPMIDIDATA              pMidiData;
    PIRP                    pIrp;
    PMDL                    pMdl;
    PWDMAPENDINGIRP_CONTEXT pPendingIrpContext;
} MIDIINHDR, *PMIDIINHDR;

#define MIDI_PIN_INSTANCE_SIGNATURE ((ULONG)'SIPM') //MPIS

//
// This macro can be used with NT_SUCCESS to branch.  Effectively returns a
// NTSTATUS code.
//
#define IsValidMidiPinInstance(pmpi) ((pmpi->dwSig == MIDI_PIN_INSTANCE_SIGNATURE) ? \
                                      STATUS_SUCCESS:STATUS_UNSUCCESSFUL)

typedef struct _MIDIPININSTANCE
{
   PFILE_OBJECT             pFileObject;
   PDEVICE_OBJECT           pDeviceObject;
   struct tag_MIDIDEVICE   *pMidiDevice;

   KSPIN_LOCK               MidiPinSpinLock; // For state changes

   BOOL                     fGraphRunning;

   KSSTATE                  PinState;
   KEVENT                   StopEvent;
   ULONG                    NumPendingIos;
   volatile BOOL            StoppingSource;  //  Flag which indicates
                                             //  that the pin is in the
                                             //  stopping process

   LIST_ENTRY               MidiInQueueListHead; // for midihdrs
   KSPIN_LOCK               MidiInQueueSpinLock;
   KSEVENT                  MidiInNotify;    // for notification of new midiin data
   WORK_QUEUE_ITEM          MidiInWorkItem;

   ULONG                    DeviceNumber;
   ULONG                    DataFlow;

   PCONTROLS_LIST           pControlList;

   ULONG                    LastTimeMs;
   ULONGLONG                LastTimeNs;

   BYTE                     bCurrentStatus;

   DWORD                    dwSig;  // Used to validate structure
} MIDI_PIN_INSTANCE, *PMIDI_PIN_INSTANCE;

#define STREAM_HEADER_EX_SIGNATURE ((ULONG)'XEHS') //SHEX

//
// This macro can be used with NT_SUCCESS to branch.  Effectively returns a
// NTSTATUS code.
//
#define IsValidStreamHeaderEx(pshex) ((pshex->dwSig == STREAM_HEADER_EX_SIGNATURE) ? \
                                      STATUS_SUCCESS:STATUS_UNSUCCESSFUL)

typedef struct _STREAM_HEADER_EX
{
    KSSTREAM_HEADER     Header;
    IO_STATUS_BLOCK     IoStatus;
    union
    {
        PDWORD          pdwBytesRecorded;
        PWAVEHDR        pWaveHdr;
        PMIDIHDR        pMidiHdr;
    };
    union
    {
        PWAVE_PIN_INSTANCE  pWavePin;
        PMIDI_PIN_INSTANCE  pMidiPin;
    };
    PIRP                    pIrp;
    PWAVEHDR                pWaveHdrAligned;
    PMDL                    pHeaderMdl;
    PMDL                    pBufferMdl;
    PWDMAPENDINGIRP_CONTEXT pPendingIrpContext;

    DWORD                   dwSig; //Used To validate structure.
} STREAM_HEADER_EX, *PSTREAM_HEADER_EX;

//
// make sure that this structure doesn't exceed the size of
// the midihdr, otherwise the write_context defintion in
// vxd.asm needs to be updated.
//
typedef struct _wavehdrex
{
    WAVEHDR             wh;
    PWAVE_PIN_INSTANCE  pWaveInstance;
} WAVEINSTANCEHDR, *PWAVEINSTANCEHDR;

#define WRITE_CONTEXT_SIGNATURE ((ULONG)'GSCW') //WCSG

//
// This macro can be used with NT_SUCCESS to branch.  Effectively returns a
// NTSTATUS code.
//
#define IsValidWriteContext(pwc) ((pwc->dwSig == WRITE_CONTEXT_SIGNATURE) ? \
                                      STATUS_SUCCESS:STATUS_UNSUCCESSFUL)
typedef struct write_context
{
    union
    {
        WAVEINSTANCEHDR     whInstance;
        MIDIHDR             mh;
    };
    DWORD                   ClientContext;
    DWORD                   ClientContext2;
    WORD                    CallbackOffset;
    WORD                    CallbackSegment;
    DWORD                   ClientThread;
    union
    {
        LPWAVEHDR           WaveHeaderLinearAddress;
        LPMIDIHDR           MidiHeaderLinearAddress;
    };
    PVOID                   pCapturedWaveHdr;
    PMDL                    pBufferMdl;
    PWDMAPENDINGIRP_CONTEXT pPendingIrpContext;

    DWORD                   dwSig; // Used to validate structure.
} WRITE_CONTEXT, *PWRITE_CONTEXT;

typedef struct tag_IDENTIFIERS
{
    KSMULTIPLE_ITEM;
    KSIDENTIFIER aIdentifiers[1];       // Array of identifiers
} IDENTIFIERS, *PIDENTIFIERS;

typedef struct tag_DATARANGES
{
    KSMULTIPLE_ITEM;
    KSDATARANGE aDataRanges[1];
} DATARANGES, *PDATARANGES;

typedef struct tag_KSPROPERTYPLUS
{
    KSPROPERTY Property;
    ULONG      DeviceIndex;
} KSPROPERTYPLUS, *PKSPROPERTYPLUS;

//
// COMMONDEVICE
//      DeviceInterface - the buffer for this string is allocated for all
//              classes except mixer.  For mixer, it is a pointer to a buffer
//              allocated for one of the wave classes.
//
typedef struct tag_COMMONDEVICE
{
    ULONG                  Device;
    ULONG                  PinId;
    PWSTR                  DeviceInterface;
    PWSTR                  pwstrName;
    ULONG                  PreferredDevice;
    struct tag_WDMACONTEXT *pWdmaContext;
    PKSCOMPONENTID         ComponentId;
} COMMONDEVICE, *PCOMMONDEVICE;

typedef struct tag_WAVEDEVICE
{
    COMMONDEVICE;
    PDATARANGES         AudioDataRanges;
    PWAVE_PIN_INSTANCE  pWavePin;
    DWORD               LeftVolume;      // only used for output
    DWORD               RightVolume;     // only used for output
    DWORD               dwVolumeID;      // only used for output
    DWORD               cChannels;       // only used for output
    PKTIMER             pTimer;          // only used for output
    PKDPC               pDpc;            // only used for output
    BOOL                fNeedToSetVol;   // only used for output
} WAVEDEVICE, *PWAVEDEVICE;

typedef struct tag_MIDIDEVICE
{
    COMMONDEVICE;
    PDATARANGES         MusicDataRanges;
    PMIDI_PIN_INSTANCE  pMidiPin;
    DWORD               dwVolumeID;     // only used for output
    DWORD               cChannels;      // only used for output
} MIDIDEVICE, *PMIDIDEVICE;

typedef struct tag_MIXERDEVICE
{
    COMMONDEVICE;
    ULONG               cDestinations;  // The no. of destinations on device
    LINELIST            listLines;      // The list of all lines on the dev.
    KSTOPOLOGY          Topology;       // The topology
    ULONG               Mapping;        // Mapping algorithm for this device
    PFILE_OBJECT        pfo;            // used for talking to SysAudio
#ifdef DEBUG
    DWORD               dwSig;
#endif
} MIXERDEVICE, *PMIXERDEVICE;

typedef struct tag_AUXDEVICE
{
    COMMONDEVICE;
    DWORD               dwVolumeID;
    DWORD               cChannels;
} AUXDEVICE, *PAUXDEVICE;

typedef struct tag_DEVNODE_LIST_ITEM
{
    LIST_ENTRY Next;
    LONG cReference;                    // Number of device classes init'ed
    LPWSTR DeviceInterface;
    ULONG cDevices[MAX_DEVICE_CLASS];   // Count of devices for each class
    BOOLEAN fAdded[MAX_DEVICE_CLASS];
} DEVNODE_LIST_ITEM, *PDEVNODE_LIST_ITEM;

typedef struct tag_WORK_LIST_ITEM
{
    LIST_ENTRY Next;
    VOID (*Function)(
        PVOID Reference1,
        PVOID Reference2
    );
    PVOID Reference1;
    PVOID Reference2;
} WORK_LIST_ITEM, *PWORK_LIST_ITEM;


extern KMUTEX          wdmaMutex;


typedef struct tag_WDMACONTEXT
{
    LIST_ENTRY      Next;
    BOOL            fInList;

    BOOL            fInitializeSysaudio;
    KEVENT          InitializedSysaudioEvent;
    PFILE_OBJECT    pFileObjectSysaudio;
    KSEVENTDATA     EventData;

    ULONG VirtualWavePinId;
    ULONG VirtualMidiPinId;
    ULONG VirtualCDPinId;

    ULONG PreferredSysaudioWaveDevice;

    ULONG           DevNodeListCount;
    LIST_ENTRY      DevNodeListHead;
    PVOID           NotificationEntry;

    WORK_QUEUE_ITEM WorkListWorkItem;
    LIST_ENTRY      WorkListHead;
    KSPIN_LOCK      WorkListSpinLock;
    LONG            cPendingWorkList;

    WORK_QUEUE_ITEM SysaudioWorkItem;

    PKSWORKER       WorkListWorkerObject;
    PKSWORKER       SysaudioWorkerObject;

    WAVEDEVICE      WaveOutDevs[MAXNUMDEVS];
    WAVEDEVICE      WaveInDevs[MAXNUMDEVS];
    MIDIDEVICE      MidiOutDevs[MAXNUMDEVS];
    MIDIDEVICE      MidiInDevs[MAXNUMDEVS];
    MIXERDEVICE     MixerDevs[MAXNUMDEVS];
    AUXDEVICE       AuxDevs[MAXNUMDEVS];

    PCOMMONDEVICE   apCommonDevice[MAX_DEVICE_CLASS][MAXNUMDEVS];
#ifdef DEBUG
    DWORD           dwSig;
#endif

} WDMACONTEXT, *PWDMACONTEXT;

#ifdef WIN32
#include <pshpack1.h>
#else
#ifndef RC_INVOKED
#pragma pack(1)
#endif
#endif

// This include needs to be here since it needs some of the declarations
// above

#include "kmxluser.h"

typedef WORD        VERSION;    /* major (high byte), minor (low byte) */

typedef struct waveoutcaps16_tag {
    WORD    wMid;                  /* manufacturer ID */
    WORD    wPid;                  /* product ID */
    WORD    vDriverVersion;        /* version of the driver */
    char    szPname[MAXPNAMELEN];  /* product name (NULL terminated string) */
    DWORD   dwFormats;             /* formats supported */
    WORD    wChannels;             /* number of sources supported */
    DWORD   dwSupport;             /* functionality supported by driver */
} WAVEOUTCAPS16, *PWAVEOUTCAPS16;

typedef struct waveincaps16_tag {
    WORD    wMid;                    /* manufacturer ID */
    WORD    wPid;                    /* product ID */
    WORD    vDriverVersion;          /* version of the driver */
    char    szPname[MAXPNAMELEN];    /* product name (NULL terminated string) */
    DWORD   dwFormats;               /* formats supported */
    WORD    wChannels;               /* number of channels supported */
} WAVEINCAPS16, *PWAVEINCAPS16;

typedef struct midioutcaps16_tag {
    WORD    wMid;                  /* manufacturer ID */
    WORD    wPid;                  /* product ID */
    WORD    vDriverVersion;        /* version of the driver */
    char    szPname[MAXPNAMELEN];  /* product name (NULL terminated string) */
    WORD    wTechnology;           /* type of device */
    WORD    wVoices;               /* # of voices (internal synth only) */
    WORD    wNotes;                /* max # of notes (internal synth only) */
    WORD    wChannelMask;          /* channels used (internal synth only) */
    DWORD   dwSupport;             /* functionality supported by driver */
} MIDIOUTCAPS16, *PMIDIOUTCAPS16;

typedef struct midiincaps16_tag {
    WORD    wMid;                  /* manufacturer ID */
    WORD    wPid;                  /* product ID */
    WORD    vDriverVersion;        /* version of the driver */
    char    szPname[MAXPNAMELEN];  /* product name (NULL terminated string) */
#if (WINVER >= 0x0400)
    DWORD   dwSupport;             /* functionality supported by driver */
#endif
} MIDIINCAPS16, *PMIDIINCAPS16;

typedef struct mixercaps16_tag {
    WORD    wMid;                  /* manufacturer id */
    WORD    wPid;                  /* product id */
    WORD    vDriverVersion;        /* version of the driver */
    char    szPname[MAXPNAMELEN];  /* product name */
    DWORD   fdwSupport;            /* misc. support bits */
    DWORD   cDestinations;         /* count of destinations */
} MIXERCAPS16, *PMIXERCAPS16;

typedef struct auxcaps16_tag {
    WORD    wMid;                  /* manufacturer ID */
    WORD    wPid;                  /* product ID */
    WORD    vDriverVersion;        /* version of the driver */
    char    szPname[MAXPNAMELEN];  /* product name (NULL terminated string) */
    WORD    wTechnology;           /* type of device */
    DWORD   dwSupport;             /* functionality supported by driver */
} AUXCAPS16, *PAUXCAPS16;

typedef struct wavehdr_tag32 {
    UINT32      lpData;                 /* pointer to locked data buffer */
    DWORD       dwBufferLength;         /* length of data buffer */
    DWORD       dwBytesRecorded;        /* used for input only */
    UINT32      dwUser;                 /* for client's use */
    DWORD       dwFlags;                /* assorted flags (see defines) */
    DWORD       dwLoops;                /* loop control counter */
    UINT32      lpNext;                 /* reserved for driver */
    UINT32      reserved;               /* reserved for driver */
} WAVEHDR32, *PWAVEHDR32, NEAR *NPWAVEHDR32, FAR *LPWAVEHDR32;

/* MIDI data block header */
typedef struct midihdr_tag32 {
    UINT32      lpData;               /* pointer to locked data block */
    DWORD       dwBufferLength;       /* length of data in data block */
    DWORD       dwBytesRecorded;      /* used for input only */
    UINT32      dwUser;               /* for client's use */
    DWORD       dwFlags;              /* assorted flags (see defines) */
    UINT32      lpNext;               /* reserved for driver */
    UINT32      reserved;             /* reserved for driver */
#if (WINVER >= 0x0400)
    DWORD       dwOffset;             /* Callback offset into buffer */
    UINT32      dwReserved[8];        /* Reserved for MMSYSTEM */
#endif
} MIDIHDR32, *PMIDIHDR32, NEAR *NPMIDIHDR32, FAR *LPMIDIHDR32;

typedef struct tagMIXERLINEA32 {
    DWORD       cbStruct;               /* size of MIXERLINE structure */
    DWORD       dwDestination;          /* zero based destination index */
    DWORD       dwSource;               /* zero based source index (if source) */
    DWORD       dwLineID;               /* unique line id for mixer device */
    DWORD       fdwLine;                /* state/information about line */
    UINT32      dwUser;                 /* driver specific information */
    DWORD       dwComponentType;        /* component type line connects to */
    DWORD       cChannels;              /* number of channels line supports */
    DWORD       cConnections;           /* number of connections [possible] */
    DWORD       cControls;              /* number of controls at this line */
    CHAR        szShortName[MIXER_SHORT_NAME_CHARS];
    CHAR        szName[MIXER_LONG_NAME_CHARS];
    struct {
        DWORD       dwType;                 /* MIXERLINE_TARGETTYPE_xxxx */
        DWORD       dwDeviceID;             /* target device ID of device type */
        WORD        wMid;                   /* of target device */
        WORD        wPid;                   /*      " */
        MMVERSION   vDriverVersion;         /*      " */
        CHAR        szPname[MAXPNAMELEN];   /*      " */
    } Target;
} MIXERLINEA32, *PMIXERLINEA32, *LPMIXERLINEA32;
typedef struct tagMIXERLINEW32 {
    DWORD       cbStruct;               /* size of MIXERLINE structure */
    DWORD       dwDestination;          /* zero based destination index */
    DWORD       dwSource;               /* zero based source index (if source) */
    DWORD       dwLineID;               /* unique line id for mixer device */
    DWORD       fdwLine;                /* state/information about line */
    UINT32      dwUser;                 /* driver specific information */
    DWORD       dwComponentType;        /* component type line connects to */
    DWORD       cChannels;              /* number of channels line supports */
    DWORD       cConnections;           /* number of connections [possible] */
    DWORD       cControls;              /* number of controls at this line */
    WCHAR       szShortName[MIXER_SHORT_NAME_CHARS];
    WCHAR       szName[MIXER_LONG_NAME_CHARS];
    struct {
        DWORD       dwType;                 /* MIXERLINE_TARGETTYPE_xxxx */
        DWORD       dwDeviceID;             /* target device ID of device type */
        WORD        wMid;                   /* of target device */
        WORD        wPid;                   /*      " */
        MMVERSION   vDriverVersion;         /*      " */
        WCHAR       szPname[MAXPNAMELEN];   /*      " */
    } Target;
} MIXERLINEW32, *PMIXERLINEW32, *LPMIXERLINEW32;
#ifdef UNICODE
typedef MIXERLINEW32 MIXERLINE32;
typedef PMIXERLINEW32 PMIXERLINE32;
typedef LPMIXERLINEW32 LPMIXERLINE32;
#else
typedef MIXERLINEA32 MIXERLINE32;
typedef PMIXERLINEA32 PMIXERLINE32;
typedef LPMIXERLINEA32 LPMIXERLINE32;
#endif // UNICODE

typedef struct tagMIXERLINECONTROLSA32 {
    DWORD           cbStruct;       /* size in bytes of MIXERLINECONTROLS */
    DWORD           dwLineID;       /* line id (from MIXERLINE.dwLineID) */
    union {
        DWORD       dwControlID;    /* MIXER_GETLINECONTROLSF_ONEBYID */
        DWORD       dwControlType;  /* MIXER_GETLINECONTROLSF_ONEBYTYPE */
    };
    DWORD           cControls;      /* count of controls pmxctrl points to */
    DWORD           cbmxctrl;       /* size in bytes of _one_ MIXERCONTROL */
    UINT32          pamxctrl;       /* pointer to first MIXERCONTROL array */
} MIXERLINECONTROLSA32, *PMIXERLINECONTROLSA32, *LPMIXERLINECONTROLSA32;
typedef struct tagMIXERLINECONTROLSW32 {
    DWORD           cbStruct;       /* size in bytes of MIXERLINECONTROLS */
    DWORD           dwLineID;       /* line id (from MIXERLINE.dwLineID) */
    union {
        DWORD       dwControlID;    /* MIXER_GETLINECONTROLSF_ONEBYID */
        DWORD       dwControlType;  /* MIXER_GETLINECONTROLSF_ONEBYTYPE */
    };
    DWORD           cControls;      /* count of controls pmxctrl points to */
    DWORD           cbmxctrl;       /* size in bytes of _one_ MIXERCONTROL */
    UINT32          pamxctrl;       /* pointer to first MIXERCONTROL array */
} MIXERLINECONTROLSW32, *PMIXERLINECONTROLSW32, *LPMIXERLINECONTROLSW32;
#ifdef UNICODE
typedef MIXERLINECONTROLSW32 MIXERLINECONTROLS32;
typedef PMIXERLINECONTROLSW32 PMIXERLINECONTROLS32;
typedef LPMIXERLINECONTROLSW32 LPMIXERLINECONTROLS32;
#else
typedef MIXERLINECONTROLSA32 MIXERLINECONTROLS32;
typedef PMIXERLINECONTROLSA32 PMIXERLINECONTROLS32;
typedef LPMIXERLINECONTROLSA32 LPMIXERLINECONTROLS32;
#endif // UNICODE

typedef struct tMIXERCONTROLDETAILS32 {
    DWORD           cbStruct;       /* size in bytes of MIXERCONTROLDETAILS */
    DWORD           dwControlID;    /* control id to get/set details on */
    DWORD           cChannels;      /* number of channels in paDetails array */
    union {
        UINT32      hwndOwner;      /* for MIXER_SETCONTROLDETAILSF_CUSTOM */
        DWORD       cMultipleItems; /* if _MULTIPLE, the number of items per channel */
    };
    DWORD           cbDetails;      /* size of _one_ details_XX struct */
    UINT32          paDetails;      /* pointer to array of details_XX structs */
} MIXERCONTROLDETAILS32, *PMIXERCONTROLDETAILS32, FAR *LPMIXERCONTROLDETAILS32;

#ifdef WIN32
#include <poppack.h>
#else
#ifndef RC_INVOKED
#pragma pack()
#endif
#endif

#ifndef _WIN64
// WARNING WARNING WARNING!!!!
// If the below lines do not compile for 32 bit x86, you MUST sync the
// above wavehdr_tag32 structure up with the wavehdr_tag structure in
// mmsystem.w!  It doesn't compile because someone changed mmsystem.w
// without changing the above structure.
// Make SURE when you sync it up that you use UINT32 for all elements
// that are normally 64bits on win64.
// You MUST also update all places that thunk the above structure!
// Look for all occurances of any of the wavehdr_tag32 typedefs in the
// wdmaud.sys directory.

struct wave_header_structures_are_in_sync {
char x[(sizeof (WAVEHDR32) == sizeof (WAVEHDR)) ? 1 : -1];
};

// WARNING WARNING WARNING!!!
// If above lines do not compile, see comment above and FIX!
// DO NOT COMMENT OUT THE LINES THAT DON'T COMPILE
#endif

#ifndef _WIN64
// WARNING WARNING WARNING!!!!
// If the below lines do not compile for 32 bit x86, you MUST sync the
// above midihdr_tag32 structure up with the midihdr_tag structure in
// mmsystem.w!  It doesn't compile because someone changed mmsystem.w
// without changing the above structure.
// Make SURE when you sync it up that you use UINT32 for all elements
// that are normally 64bits on win64.
// You MUST also update all places that thunk the above structure!
// Look for all occurances of any of the midihdr_tag32 typedefs in the
// wdmaud.sys directory.

struct midi_header_structures_are_in_sync {
char x[(sizeof (MIDIHDR32) == sizeof (MIDIHDR)) ? 1 : -1];
};

// WARNING WARNING WARNING!!!
// If above lines do not compile, see comment above and FIX!
// DO NOT COMMENT OUT THE LINES THAT DON'T COMPILE
#endif

#ifndef _WIN64
// WARNING WARNING WARNING!!!!
// If the below lines do not compile for 32 bit x86, you MUST sync the
// above two tagMIXERLINEX32 structures up with the tagMIXERLINEX structures in
// mmsystem.w!  It doesn't compile because someone changed mmsystem.w
// without changing the above structure.
// Make SURE when you sync it up that you use UINT32 for all elements
// that are normally 64bits on win64.
// You MUST also update all places that thunk the above structure!
// Look for all occurances of any of the MIXERLINE32 typedefs in the
// wdmaud.sys directory.

struct mixer_line_structures_are_in_sync {
char x[(sizeof (MIXERLINE32) == sizeof (MIXERLINE)) ? 1 : -1];
};

// WARNING WARNING WARNING!!!
// If above lines do not compile, see comment above and FIX!
// DO NOT COMMENT OUT THE LINES THAT DON'T COMPILE
#endif

#ifndef _WIN64
// WARNING WARNING WARNING!!!!
// If the below lines do not compile for 32 bit x86, you MUST sync the
// above two tagMIXERLINECONTROLSX32 structures up with the tagMIXERLINECONTROLSX structures in
// mmsystem.w!  It doesn't compile because someone changed mmsystem.w
// without changing the above structure.
// Make SURE when you sync it up that you use UINT32 for all elements
// that are normally 64bits on win64.
// You MUST also update all places that thunk the above structure!
// Look for all occurances of any of the MIXERLINECONTROLS32 typedefs in the
// wdmaud.sys directory.

struct mixer_line_control_structures_are_in_sync {
char x[(sizeof (MIXERLINECONTROLS32) == sizeof (MIXERLINECONTROLS)) ? 1 : -1];
};

// WARNING WARNING WARNING!!!
// If above lines do not compile, see comment above and FIX!
// DO NOT COMMENT OUT THE LINES THAT DON'T COMPILE
#endif

#ifndef _WIN64
// WARNING WARNING WARNING!!!!
// If the below lines do not compile for 32 bit x86, you MUST sync the
// above tMIXERCONTROLDETAILS32 structure up with the tMIXERCONTROLDETAILS32 structure in
// mmsystem.w!  It doesn't compile because someone changed mmsystem.w
// without changing the above structure.
// Make SURE when you sync it up that you use UINT32 for all elements
// that are normally 64bits on win64.
// You MUST also update all places that thunk the above structure!
// Look for all occurances of any of the MIXERCONTROLDETAILS32 typedefs in the
// wdmaud.sys directory.

struct mixer_control_details_structures_are_in_sync {
char x[(sizeof (MIXERCONTROLDETAILS32) == sizeof (MIXERCONTROLDETAILS)) ? 1 : -1];
};

// WARNING WARNING WARNING!!!
// If above lines do not compile, see comment above and FIX!
// DO NOT COMMENT OUT THE LINES THAT DON'T COMPILE
#endif


/***************************************************************************

  Local prototypes

 ***************************************************************************/

//
//  Device.c
//
NTSTATUS 
DriverEntry(
    IN PDRIVER_OBJECT       DriverObject,
    IN PUNICODE_STRING      usRegistryPathName
);

NTSTATUS
DispatchPnp(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP             pIrp
);

NTSTATUS
PnpAddDevice(
    IN PDRIVER_OBJECT   DriverObject,
    IN PDEVICE_OBJECT   PhysicalDeviceObject
);

VOID
PnpDriverUnload(
    IN PDRIVER_OBJECT DriverObject
);

//
// Ioctl.c
//
#ifdef PROFILE
VOID WdmaInitProfile();
VOID WdmaCleanupProfile();

NTSTATUS 
AddMdlToList(
    PMDL            pMdl,
    PWDMACONTEXT    pWdmaContext
);

NTSTATUS 
RemoveMdlFromList(
    PMDL            pMdl
);

#else

#define WdmaInitProfile()
#define AddMdlToList(pMdl,pWdmaContext)
#define RemoveMdlFromList(pMdl)

#endif

extern LIST_ENTRY   WdmaPendingIrpListHead;
extern KSPIN_LOCK   WdmaPendingIrpListSpinLock;

VOID 
WdmaCsqInsertIrp(
    IN struct _IO_CSQ   *pCsq,
    IN PIRP              Irp
);

VOID 
WdmaCsqRemoveIrp(
    IN  PIO_CSQ Csq,
    IN  PIRP    Irp
);

PIRP 
WdmaCsqPeekNextIrp(
    IN  PIO_CSQ Csq,
    IN  PIRP    Irp,
    IN  PVOID   PeekContext
);

VOID 
WdmaCsqAcquireLock(
    IN  PIO_CSQ Csq,
    OUT PKIRQL  Irql
);

VOID 
WdmaCsqReleaseLock(
    IN PIO_CSQ Csq,
    IN KIRQL   Irql
);

VOID 
WdmaCsqCompleteCanceledIrp(
    IN  PIO_CSQ             pCsq,
    IN  PIRP                Irp
);

NTSTATUS 
AddIrpToPendingList(
    PIRP                    pIrp,
    ULONG                   IrpDeviceType,
    PWDMACONTEXT            pWdmaContext,
    PWDMAPENDINGIRP_CONTEXT *ppPendingIrpContext
);

NTSTATUS 
RemoveIrpFromPendingList(
    PWDMAPENDINGIRP_CONTEXT pPendingIrpContext
);

VOID 
wdmaudMapBuffer(
    PIRP            pIrp,
    PVOID           DataBuffer,
    DWORD           DataBufferSize,
    PVOID           *pMappedBuffer,
    PMDL            *ppMdl,
    PWDMACONTEXT    pContext,
    BOOL            bWrite
);

VOID 
wdmaudUnmapBuffer(
    PMDL            pMdl
);

NTSTATUS 
CaptureBufferToLocalPool(
    PVOID           DataBuffer,
    DWORD           DataBufferSize,
    PVOID           *ppMappedBuffer
#ifdef _WIN64
    ,DWORD          ThunkBufferSize
#endif
);

NTSTATUS 
CopyAndFreeCapturedBuffer(
    PVOID           DataBuffer,
    DWORD           DataBufferSize,
    PVOID           *ppMappedBuffer
);

NTSTATUS
SoundDispatchCreate(
   IN  PDEVICE_OBJECT pDO,
   IN  PIRP           pIrp
);

NTSTATUS
SoundDispatchClose(
   IN  PDEVICE_OBJECT pDO,
   IN  PIRP           pIrp
);

NTSTATUS
SoundDispatch(
    IN  PDEVICE_OBJECT pDO,
    IN  PIRP           pIrp
);

NTSTATUS
SoundDispatchCleanup(
    IN  PDEVICE_OBJECT pDO,
    IN  PIRP           pIrp
);

//
// wave.c
//
NTSTATUS 
OpenWavePin(
    PWDMACONTEXT        pWdmaContext,
    ULONG               DeviceNumber,
    LPWAVEFORMATEX      lpFormat,
    HANDLE32            DeviceHandle,
    DWORD               dwFlags,
    ULONG               DataFlow // DataFlow is either in or out.
);
VOID 
CloseTheWavePin(
    PWAVEDEVICE pWaveDev,
    HANDLE32    DeviceHandle
);

VOID 
CloseWavePin(
   PWAVE_PIN_INSTANCE pWavePin
);

NTSTATUS 
wqWriteWaveCallBack(
    PDEVICE_OBJECT  pDeviceObject,
    PIRP            pIrp,
    IN PWAVEHDR     pWriteData
);

NTSTATUS 
ssWriteWaveCallBack(
    PDEVICE_OBJECT       pDeviceObject,
    PIRP                 pIrp,
    IN PSTREAM_HEADER_EX pStreamHeaderEx
);

NTSTATUS 
WriteWaveOutPin(
    PWAVEDEVICE         pWaveOutDevice,
    HANDLE32            DeviceHandle,
    LPWAVEHDR           pWriteData,
    PSTREAM_HEADER_EX   pStreamHeader,
    PIRP                pUserIrp,
    PWDMACONTEXT        pContext,
    BOOL               *pCompletedIrp
);

NTSTATUS 
IoWavePin(
    PWAVE_PIN_INSTANCE  pWavePin,
    ULONG               Operation,
    PWRITE_CONTEXT      pWriteContext,
    ULONG               Size,
    PVOID               RefData,
    PVOID               CallBack
);

NTSTATUS 
PosWavePin(
    PWAVEDEVICE     pWaveDevice,
    HANDLE32        DeviceHandle,
    PWAVEPOSITION   pWavePos
);

NTSTATUS 
BreakLoopWaveOutPin(
    PWAVEDEVICE pWaveOutDevice,
    HANDLE32    DeviceHandle
);

NTSTATUS 
VolumeWaveOutPin(
    ULONG           DeviceNumber,
    HANDLE32        DeviceHandle,
    PDEVICEVOLUME   pWaveVolume
);

NTSTATUS 
VolumeWaveInPin(
    ULONG           DeviceNumber,
    PDEVICEVOLUME   pWaveVolume
);

NTSTATUS 
VolumeWavePin(
    PWAVE_PIN_INSTANCE    pWavePin,
    PDEVICEVOLUME         pWaveVolume
);
NTSTATUS 
ResetWaveOutPin(
    PWAVEDEVICE pWaveOutDevice,
    HANDLE32    DeviceHandle
);

NTSTATUS 
ResetWavePin(
    PWAVE_PIN_INSTANCE pWavePin,
    KSRESET            *pResetValue
);

NTSTATUS 
StateWavePin(
    PWAVEDEVICE pWaveInDevice,
    HANDLE32    DeviceHandle,
    KSSTATE     State
);

NTSTATUS 
ReadWaveCallBack(
    PDEVICE_OBJECT          pDeviceObject,
    PIRP                    pIrp,
    IN PSTREAM_HEADER_EX    pStreamHeader
);

NTSTATUS 
ReadWaveInPin(
    PWAVEDEVICE         pWaveInDevice,
    HANDLE32            DeviceHandle,
    PSTREAM_HEADER_EX   pStreamHeader,
    PIRP                pUserIrp,
    PWDMACONTEXT        pContext,
    BOOL               *pCompletedIrp
);

ULONG
FindMixerForDevNode(
    IN PMIXERDEVICE paMixerDevice,
    IN PCWSTR DeviceInterface
);

NTSTATUS
FindVolumeControl(
    IN PWDMACONTEXT pWdmaContext,
    IN PCWSTR DeviceInterface,
    IN DWORD DeviceType
);

NTSTATUS
IsVolumeControl(
    IN PWDMACONTEXT pWdmaContext,
    IN PCWSTR DeviceInterface,
    IN DWORD dwComponentType,
    IN PDWORD pdwControlID,
    IN PDWORD pcChannels
);

NTSTATUS
SetVolume(
    IN PWDMACONTEXT pWdmaContext,
    IN DWORD DeviceNumber,
    IN DWORD DeviceType,
    IN DWORD LeftChannel,
    IN DWORD RightChannel
);

NTSTATUS
GetVolume(
    IN  PWDMACONTEXT pWdmaContext,
    IN  DWORD  DeviceNumber,
    IN  DWORD  DeviceType,
    OUT PDWORD LeftChannel,
    OUT PDWORD RightChannel
);

VOID 
CleanupWavePins(
    IN PWAVEDEVICE pWaveDevice
);

VOID 
CleanupWaveDevices(
    PWDMACONTEXT pWdmaContext
);

NTSTATUS 
wdmaudPrepareIrp(
    PIRP                    pIrp,
    ULONG                   IrpDeviceType,
    PWDMACONTEXT            pWdmaContext,
    PWDMAPENDINGIRP_CONTEXT *ppPendingIrpContext
);

NTSTATUS 
wdmaudUnprepareIrp(
    PIRP                    pIrp,
    NTSTATUS                IrpStatus,
    ULONG_PTR               Information,
    PWDMAPENDINGIRP_CONTEXT pPendingIrpContext
);

//
// midi.c
//
NTSTATUS 
OpenMidiPin(
    PWDMACONTEXT        pWdmaContext,
    ULONG               DeviceNumber,
    ULONG               DataFlow      //DataFlow is either in or out.
);

VOID 
CloseMidiDevicePin(
    PMIDIDEVICE pMidiDevice
);

VOID 
CloseMidiPin(
    PMIDI_PIN_INSTANCE  pMidiPin
);

NTSTATUS 
WriteMidiEventCallBack(
    PDEVICE_OBJECT          pDeviceObject,
    PIRP                    pIrp,
    IN PSTREAM_HEADER_EX    pStreamHeader
);

NTSTATUS 
WriteMidiEventPin(
    PMIDIDEVICE pMidiOutDevice,
    ULONG       ulEvent
);

NTSTATUS 
WriteMidiCallBack(
    PDEVICE_OBJECT          pDeviceObject,
    PIRP                    pIrp,
    IN PSTREAM_HEADER_EX    pStreamHeader
);

NTSTATUS 
WriteMidiOutPin(
    LPMIDIHDR           pMidiHdr,
    PSTREAM_HEADER_EX   pStreamHeader,
    BOOL               *pCompletedIrp
);

ULONGLONG 
GetCurrentMidiTime(
    VOID
);

NTSTATUS
ResetMidiInPin(
    PMIDI_PIN_INSTANCE pMidiPin
);

NTSTATUS
StateMidiOutPin(
    PMIDI_PIN_INSTANCE pMidiPin,
    KSSTATE     State
);

NTSTATUS 
StateMidiInPin(
    PMIDI_PIN_INSTANCE pMidiPin,
    KSSTATE     State
);

NTSTATUS 
ReadMidiCallBack(
    PDEVICE_OBJECT          pDeviceObject,
    PIRP                    pIrp,
    IN PSTREAM_HEADER_EX    pStreamHeader
);

VOID 
ReadMidiEventWorkItem(
    PSTREAM_HEADER_EX   pStreamHeader,
    PVOID               NotUsed
);

NTSTATUS 
ReadMidiPin(
    PMIDI_PIN_INSTANCE  pMidiPin
);

NTSTATUS 
AddBufferToMidiInQueue(
    PMIDI_PIN_INSTANCE  pMidiPin,
    PMIDIINHDR          pNewMidiInHdr
);

VOID 
CleanupMidiDevices(
    PWDMACONTEXT pWdmaContext
    );

// from NTKERN
NTSYSAPI NTSTATUS NTAPI NtClose
(
    IN HANDLE Handle
);

//
// sysaudio.c
//
/*
NTSTATUS 
AllocMem(
    POOL_TYPE   PoolType,
    PVOID       *pp,
    ULONG       size,
    ULONG       ultag
);

VOID 
FreeMem(
    PVOID       *pp
);
*/

NTSTATUS 
OpenSysAudioPin(
    ULONG           Device,
    ULONG           PinId,
    KSPIN_DATAFLOW  DataFlowRequested,
    PKSPIN_CONNECT  pPinConnect,
    PFILE_OBJECT    *ppFileObjectPin,
    PDEVICE_OBJECT  *ppDeviceObjectPin,
    PCONTROLS_LIST  pControlList
);

VOID 
CloseSysAudio(
    PWDMACONTEXT pWdmaContext,
    PFILE_OBJECT pFileObjectPin
);

NTSTATUS 
OpenSysAudio(
    PHANDLE pHandle,
    PFILE_OBJECT *ppFileObject
);

NTSTATUS 
OpenDevice(
    IN PWSTR    pwstrDevice,
    OUT PHANDLE pHandle
);

NTSTATUS 
GetPinProperty(
    PFILE_OBJECT    pFileObject,
    ULONG           PropertyId,
    ULONG           PinId,
    ULONG           cbProperty,
    PVOID           pProperty
);

NTSTATUS 
GetPinPropertyEx(
    PFILE_OBJECT    pFileObject,
    ULONG           PropertyId,
    ULONG           PinId,
    PVOID           *ppProperty
);

VOID 
GetControlNodes(
   PFILE_OBJECT   pDeviceFileObject,
   PFILE_OBJECT   pPinFileObject,
   ULONG          PinId,
   PCONTROLS_LIST pControlList
);

ULONG 
ControlNodeFromGuid(
   PFILE_OBJECT  pDeviceFileObject,
   PFILE_OBJECT  pPinFileObject,
   ULONG         PinId,
   GUID*         NodeType
);

PVOID 
GetTopologyProperty(
   PFILE_OBJECT  pDeviceFileObject,
   ULONG         PropertyId
);

PKSTOPOLOGY_CONNECTION 
FindConnection(
   PKSTOPOLOGY_CONNECTION pConnections,
   ULONG                  NumConnections,
   ULONG                  FromNode,
   ULONG                  FromPin,
   ULONG                  ToNode,
   ULONG                  ToPin
);

ULONG 
GetFirstConnectionIndex(
   PFILE_OBJECT pPinFileObject
);

VOID 
UpdatePreferredDevice(
    PWDMACONTEXT pWdmaContext
);

NTSTATUS 
SetPreferredDevice(
    PWDMACONTEXT pContext,
    LPDEVICEINFO pDeviceInfo
);

NTSTATUS 
GetSysAudioProperty(
    PFILE_OBJECT pFileObject,
    ULONG        PropertyId,
    ULONG        DeviceIndex,
    ULONG        cbProperty,
    PVOID        pProperty
);

NTSTATUS 
SetSysAudioProperty(
    PFILE_OBJECT pFileObject,
    ULONG        PropertyId,
    ULONG        cbProperty,
    PVOID        pProperty
);

WORD 
GetMidiTechnology(
    PKSDATARANGE_MUSIC   MusicDataRange
);

DWORD 
GetFormats(
    PKSDATARANGE_AUDIO   AudioDataRange
);

NTSTATUS 
wdmaudGetDevCaps(
    PWDMACONTEXT pWdmaContext,
    DWORD        DeviceType,
    DWORD        DeviceNumber,
    LPBYTE       lpCaps,
    DWORD        dwSize
);

NTSTATUS 
wdmaudGetNumDevs(
    PWDMACONTEXT pWdmaContext,
    DWORD        DeviceType,
    LPCTSTR      DeviceInterface,
    LPDWORD      lpNumberOfDevices
);

BOOL 
IsEqualInterface(
    PKSPIN_INTERFACE    pInterface1,
    PKSPIN_INTERFACE    pInterface2
);

DWORD 
wdmaudTranslateDeviceNumber(
    PWDMACONTEXT pWdmaContext,
    DWORD        DeviceType,
    PCWSTR       DeviceInterface,
    DWORD        DeviceNumber
);

NTSTATUS 
AddDevice(
    PWDMACONTEXT    pWdmaContext,
    ULONG           Device,
    DWORD           DeviceType,
    PCWSTR          DeviceInterface,
    ULONG           PinId,
    PWSTR           pwstrName,
    BOOL            fUsePreferred,
    PDATARANGES     pDataRange,
    PKSCOMPONENTID  ComponentId
);

NTSTATUS 
PinProperty(
    PFILE_OBJECT        pFileObject,
    const GUID          *pPropertySet,
    ULONG               ulPropertyId,
    ULONG               ulFlags,
    ULONG               cbProperty,
    PVOID               pProperty
);

NTSTATUS 
PinMethod(
    PFILE_OBJECT        pFileObject,
    const GUID          *pMethodSet,
    ULONG               ulMethodId,
    ULONG               ulFlags,
    ULONG               cbMethod,
    PVOID               pMethod
);

VOID
CopyAnsiStringtoUnicodeString(
    LPWSTR lpwstr,
    LPCSTR lpstr,
    int len
);

VOID
CopyUnicodeStringtoAnsiString(
    LPSTR lpstr,
    LPCWSTR lpwstr,
    int len
);

NTSTATUS
AttachVirtualSource(
    PFILE_OBJECT pFileObject,
    ULONG ulPinId
);

NTSTATUS
SysAudioPnPNotification(
    IN PVOID NotificationStructure,
    IN PVOID Context
);

NTSTATUS
InitializeSysaudio(
    PVOID Reference1,
    PVOID Reference2
);

VOID
UninitializeSysaudio(
);

NTSTATUS
AddDevNode(
    PWDMACONTEXT pWdmaContext,
    PCWSTR       DeviceInterface,
    UINT         DeviceType
);

VOID
RemoveDevNode(
    PWDMACONTEXT pWdmaContext,
    PCWSTR       DeviceInterface,
    UINT         DeviceType
);

NTSTATUS
ProcessDevNodeListItem(
    PWDMACONTEXT pWdmaContext,
    PDEVNODE_LIST_ITEM pDevNodeListItem,
    ULONG DeviceType
);

VOID
SysaudioAddRemove(
    PWDMACONTEXT pWdmaContext
);

NTSTATUS
QueueWorkList(
    PWDMACONTEXT pWdmaContext,
    VOID (*Function)(
        PVOID Reference1,
        PVOID Reference2
    ),
    PVOID Reference1,
    PVOID Reference2
);

VOID
WorkListWorker(
    PVOID pReference
);

NTSTATUS 
AddFsContextToList(
    PWDMACONTEXT pWdmaContext
    );

NTSTATUS 
RemoveFsContextFromList(
    PWDMACONTEXT pWdmaContext
    );

typedef NTSTATUS (FNCONTEXTCALLBACK)(PWDMACONTEXT pContext,PVOID pvoidRefData,PVOID pvoidRefData2);

NTSTATUS
HasMixerBeenInitialized(
    PWDMACONTEXT pContext,
    PVOID pvoidRefData,
    PVOID pvoidRefData2
    );

NTSTATUS
EnumFsContext(
    FNCONTEXTCALLBACK fnCallback,
    PVOID pvoidRefData,
    PVOID pvoidRefData2
    );

VOID 
WdmaContextCleanup(
    PWDMACONTEXT pWdmaContext
    );

VOID
WdmaGrabMutex(
    PWDMACONTEXT pWdmaContext
);

VOID
WdmaReleaseMutex(
    PWDMACONTEXT pWdmaContext
);


int 
MyWcsicmp(
    const wchar_t *, 
    const wchar_t *
    );

void
LockedWaveIoCount(
    PWAVE_PIN_INSTANCE  pCurWavePin,
    BOOL bIncrease
    );

void
LockedMidiIoCount(
    PMIDI_PIN_INSTANCE  pCurMidiPin,
    BOOL bIncrease
    );

void
MidiCompleteIo(
    PMIDI_PIN_INSTANCE pMidiPin,
    BOOL Yield
    );

NTSTATUS 
StatePin(
    IN PFILE_OBJECT pFileObject,
    IN KSSTATE      State,
    OUT PKSSTATE    pResultingState
);


//==========================================================================
//
// In order to better track memory allocations, if you include the following
// all memory allocations will be tagged.  
//
//==========================================================================

//
// For memory allocation routines we need some memory tags.  Well, here they
// are.
//
#define TAG_AudD_DEVICEINFO ((ULONG)'DduA') 
#define TAG_AudC_CONTROL    ((ULONG)'CduA') 
#define TAG_AudE_EVENT      ((ULONG)'EduA')
#define TAG_AuDF_HARDWAREEVENT ((ULONG)'FDuA')
#define TAG_AudL_LINE       ((ULONG)'LduA')

#define TAG_AuDA_CHANNEL    ((ULONG)'ADuA')
#define TAG_AuDB_CHANNEL    ((ULONG)'BDuA')
#define TAG_AuDC_CHANNEL    ((ULONG)'CDuA')
#define TAG_AuDD_CHANNEL    ((ULONG)'DDuA')
#define TAG_AuDE_CHANNEL    ((ULONG)'EDuA')


#define TAG_AudS_SUPERMIX   ((ULONG)'SduA')
#define TAG_Audl_MIXLEVEL   ((ULONG)'lduA')
#define TAG_AudN_NODE       ((ULONG)'NduA')
#define TAG_Audn_PEERNODE   ((ULONG)'nduA')

//#define TAG_AudP_PROPERTY   ((ULONG)'PduA')
#define TAG_AudQ_PROPERTY    ((ULONG)'QduA')
#define TAG_Audq_PROPERTY    ((ULONG)'qduA')
#define TAG_AudV_PROPERTY    ((ULONG)'VduA')
#define TAG_Audv_PROPERTY    ((ULONG)'vduA')
#define TAG_AudU_PROPERTY    ((ULONG)'UduA')
#define TAG_Audu_PROPERTY    ((ULONG)'uduA')
#define TAG_Auda_PROPERTY    ((ULONG)'aduA')
#define TAG_AudA_PROPERTY    ((ULONG)'AduA')

#define TAG_Audp_NAME       ((ULONG)'pduA')
#define TAG_AudG_GETMUXLINE ((ULONG)'GduA')
#define TAG_AudI_INSTANCE   ((ULONG)'IduA')
#define TAG_Audd_DETAILS    ((ULONG)'dduA')
#define TAG_Audi_PIN        ((ULONG)'iduA')
#define TAG_Audt_CONNECT    ((ULONG)'tduA')
#define TAG_Audh_STREAMHEADER ((ULONG)'hduA')
#define TAG_Audm_MUSIC      ((ULONG)'mduA')
#define TAG_Audx_CONTEXT    ((ULONG)'xduA')
#define TAG_AudT_TIMER      ((ULONG)'TduA')
#define TAG_AudF_FORMAT     ((ULONG)'FduA')
#define TAG_AudM_MDL        ((ULONG)'MduA')
#define TAG_AudR_IRP        ((ULONG)'RduA')
#define TAG_AudB_BUFFER     ((ULONG)'BduA')
#define TAG_Aude_MIDIHEADER ((ULONG)'eduA')

#define TAG_AuDN_NOTIFICATION ((ULONG)'NDuA')
#define TAG_AuDL_LINK       ((ULONG)'LDuA')


/***************************************************************************

    DEBUGGING SUPPORT

 ***************************************************************************/

#ifdef DEBUG
//-----------------------------------------------------------------------------
//
// Debug support for wdmaud.sys on NT is found here.
//
// To start with, There will be four different levels or debugging information.
// With each level, there will be functional area.  Thus, you can turn on 
// debug output for just driver calls, api tracing or whatnot.
//
//-----------------------------------------------------------------------------

//
// 8 bits reserved for debug leves.
//                                        
#define DL_ERROR        0x00000000
#define DL_WARNING      0x00000001
#define DL_TRACE        0x00000002
#define DL_MAX          0x00000004
#define DL_PATHTRAP     0x00000080

#define DL_MASK         0x000000FF

//
// 20 bits reserved for functional areas.  If we find that this bit is set
// in the DebugLevel variable, we will display every message of this type.
//                          
#define FA_HARDWAREEVENT 0x80000000
#define FA_MIXER         0x40000000
#define FA_IOCTL         0x20000000
#define FA_SYSAUDIO      0x10000000
#define FA_PERSIST       0x08000000
#define FA_PROPERTY      0x04000000
#define FA_USER          0x02000000
#define FA_WAVE          0x01000000
#define FA_MIDI          0x00800000
#define FA_INSTANCE      0x00400000
#define FA_NOTE          0x00200000
#define FA_KS            0x00100000
#define FA_MASK          0xFFFFF000                             
#define FA_ASSERT        0x00002000
#define FA_ALL           0x00001000

//
// 4 bits reserved for return codes.  The 3 lower bits map directly to status 
// codes shifted right 22 bits.  One bit represents that fact that we have a
// return statement.
//
#define RT_ERROR         0x00000300 // 0xCxxxxxxx >> 22 == 0x0000003xx
#define RT_WARNING       0x00000200 // 0x8xxxxxxx >> 22 == 0x0000002xx
#define RT_INFO          0x00000100 // 0x4xxxxxxx >> 22 == 0x0000001xx
#define RT_MASK          0x00000300

#define RT_RETURN        0x00000800


//-----------------------------------------------------------------------------
// Macro might look like this.  
//
// Take the string that we want to output and add "WDMAUD.SYS" and ("Error" or
// "warning" or whatever) to the front of the string.  Next, follow that with
// the function name and line number in the file that the function is found in.
// Then display the error message and then close the message with a breakpoint 
// statement.
//
// The logic goes like this.  If the user wants to see these messages ok.  Else
// bail.  If so, wdmaudDbgPreCheckLevel will return TRUE and it will have
// formated the start of the string.  It will look like:
//
// WDMAUD.SYS Erorr OurFooFunction(456)
//
// Next, the message string with the variable arguements will be displayed, like:
//
// WDMAUD.SYS Warning OurFooFunction(456) Invalid Data Queue returning C0000109
//
// Then, wdmaudDbgPostCheckLevel will be called to post format the message and
// see if the user wanted to trap on this output.
//           
// WDMAUD.SYS Warning OutFooFunction(456) Invalid Data Queue returning C0000109 &DL=ff680123
//
// The internal version will append "See \\debugtips\wdmaud.sys\wdmaud.htm" to
// the end
//
// if( wdmaudDbgPreCheckLevel(TypeOfMessageInCode) )
// {
//     DbgPrintF( _x_ ); // output the actual string here.
//     if( wdmaudDbgPostCheckLevel(Variable) )
//         DbgBreakPoint();
// }
//
// DPF( DL_WARNING|DL_ALL, ("Invalid queue %X",Queue) );
//
//-----------------------------------------------------------------------------

extern VOID 
wdmaudDbgBreakPoint(
    );

extern UINT 
wdmaudDbgPreCheckLevel(
    UINT uiMsgLevel,
    char *pFunction,
    int iLine
    );

extern UINT 
wdmaudDbgPostCheckLevel(
    UINT uiMsgLevel
    );

extern char * 
wdmaudReturnString(
    ULONG ulMsg
    );


extern char szReturningErrorStr[];
extern UINT uiDebugLevel;


#define DPF(_x_,_y_) {if( wdmaudDbgPreCheckLevel(_x_,__FUNCTION__,__LINE__) ) { DbgPrint _y_; \
    wdmaudDbgPostCheckLevel( _x_ ); }}
    
//
// Writing macros are easy, it's figuring out when they are useful that is more
// difficult!  In this code, The RETURN macro replaces the return keyword in the
// debug builds when returning an NTSTATUS code.  Then, when tracking debug output
// the return debug line will be displayed based on the type of error the status
// value represents.  
//
// Notice that the error code is shifted 22 bits and ORed with RT_RETURN.  Thus 
// a value of "0xCxxxxxxx" will be seen as an error message, "0x8xxxxxxx" will
// be seen as a warning and "0x4xxxxxxx" will be seen as a message.
//
// Key, if uiDebugLevel is DL_ERROR or DL_WARNING all NTSTATUS Error message will be displayed
// if uiDebugLevel is DL_TRACE, all warning return codes and error return codes
// will be displayed and if uiDebugLevel is set to DL_MAX all return messages will
// displayed including success codes.
//
// RETURN(Status);
//
// WARNING: Do not rap functions in this macro! Notice that _status_ is used more 
// then once!  Thus, the function will get called more then once!  Don't do it.

#define RETURN(_status_) {DPF((RT_RETURN|DL_WARNING|((unsigned long)_status_>>22)),("%X:%s",_status_,wdmaudReturnString(_status_))); return (_status_);}
    
//
// _list_ is parameters for wdmaudExclusionList.  Like (_status_,STATUS_INVALID_PARAMETER,STATUS_NOT_FOUND,...).
// wdmaudExclusionList takes a variable number of parameters.  If the status value is
// found in the list of error codes supplied, the function returns TRUE.
//
extern int __cdecl 
wdmaudExclusionList( 
    int count, 
    unsigned long status,
    ... 
);
//
// Thus, this macro reads: We have a return code that we're going to return. Is
// it a special return code that we don't need to display?  NO - show the debug
// spew.  YES - just return it.
//
//  _status_ = The status in question
//  _y_ = Parameters to wdmaudExclusionList "( the status in question, exclution values, .... )"
//
#define DPFRETURN( _status_,_y_ )  {if( !wdmaudExclusionList _y_ ) {  \
    if( wdmaudDbgPreCheckLevel((RT_RETURN|DL_WARNING|(_status_>>22)),__FUNCTION__,__LINE__) ) { \
        DbgPrint ("%X:%s",_status_,wdmaudReturnString(_status_) ); \
        wdmaudDbgPostCheckLevel( (RT_RETURN|DL_WARNING|(_status_>>22)) ); \
    } } return (_status_);}


//
// It's bad form to put more then one expression in an assert macro.  Why? because
// you will not know exactly what expression failed the assert!
//
#define DPFASSERT(_exp_) {if( !(_exp_) ) {DPF(DL_ERROR|FA_ASSERT,("'%s'",#_exp_) );}} 

#ifdef WANT_TRAPS
//
// Branch trap.  This macro is used when testing code to make sure that you've
// hit all branches in the new code.  Every time you hit one validate that the
// code does the correct thing and then remove it from the source.  We should 
// ship with none of these lines left in the code!!!!!!
//
#define DPFBTRAP() DPF(DL_PATHTRAP,("Please report") )
#else
#define DPFBTRAP()
#endif


//
// There are a number of new routines in the checked build that validate structure
// types for us now.  These should be used inside the DPFASSERT() macro.  Thus,
// Under retail they don't have to be defined.
//
BOOL
IsValidDeviceInfo(
    IN LPDEVICEINFO pDeviceInfo
    );

BOOL
IsValidMixerObject(
    IN PMIXEROBJECT pmxobj
    );

BOOL
IsValidMixerDevice(
    IN PMIXERDEVICE pmxd
    );

BOOL
IsValidControl(
    IN PMXLCONTROL pControl
    );

BOOL
IsValidWdmaContext(
    IN PWDMACONTEXT pWdmaContext
    );

BOOL
IsValidLine(
    IN PMXLLINE pLine
    );

VOID 
GetuiDebugLevel(
    );

#else

#define DPF(_x_,_y_)
#define RETURN( _status_ ) return (_status_)
#define DPFRETURN( _status_,_y_ ) return (_status_)
#define DPFASSERT(_exp_)
#define DPFBTRAP() 


#endif

VOID
kmxlFindAddressInNoteList(
    IN PMXLCONTROL pControl 
    );

VOID
kmxlCleanupNoteList(
    );

NTSTATUS
kmxlDisableControlChangeNotifications(
    IN PMXLCONTROL pControl
    );

VOID
kmxlRemoveContextFromNoteList(
    PWDMACONTEXT pContext
    );

VOID
kmxlPersistHWControlWorker(
    PVOID pReference
    );

#endif // _WDMSYS_H_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\sysaudio\clist.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   clist.cpp
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//  To Do:     Date	  Author      Comment
//
//@@END_MSINTERNAL
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"

//---------------------------------------------------------------------------
// CListSingle Class
//---------------------------------------------------------------------------

ENUMFUNC
CListSingle::EnumerateList(
    IN ENUMFUNC (CListSingleItem::*pfn)(
    )
)
{
    NTSTATUS Status = STATUS_CONTINUE;
    PCLIST_SINGLE_ITEM plsi;

    Assert(this);
    FOR_EACH_CLIST_ITEM_DELETE(this, plsi, CLIST_SINGLE_ITEM) {
	Status = (plsi->*pfn)();
	if(Status != STATUS_CONTINUE) {
	    goto exit;
	}
    } END_EACH_CLIST_ITEM
exit:
    return(Status);
}

ENUMFUNC
CListSingle::EnumerateList(
    IN ENUMFUNC (CListSingleItem::*pfn)(
	PVOID pReference
    ),
    PVOID pReference
)
{
    NTSTATUS Status = STATUS_CONTINUE;
    PCLIST_SINGLE_ITEM plsi;

    Assert(this);
    FOR_EACH_CLIST_ITEM_DELETE(this, plsi, CLIST_SINGLE_ITEM) {
	Status = (plsi->*pfn)(pReference);
	if(Status != STATUS_CONTINUE) {
	    goto exit;
	}
    } END_EACH_CLIST_ITEM
exit:
    return(Status);
}

PCLIST_SINGLE_ITEM *
CListSingle::GetListEnd(
)
{
    PCLIST_SINGLE_ITEM *pplsi;

    for(pplsi = &m_plsiHead;
      !IsListEnd(*pplsi);
      pplsi = &(*pplsi)->m_plsiNext) {
        Assert(*pplsi);
    }
    return(pplsi);
}

void 
CListSingle::ReverseList(
)
{
    PCLIST_SINGLE_ITEM plsi = m_plsiHead;
    PCLIST_SINGLE_ITEM plsiNext;
    PCLIST_SINGLE_ITEM plsiTemp;

    if (NULL != plsi) {
        plsiNext = plsi->m_plsiNext;
        plsi->m_plsiNext = NULL;
        
        while (NULL != plsiNext) {
            plsiTemp = plsiNext->m_plsiNext;
            plsiNext->m_plsiNext = plsi;
            plsi = plsiNext;
            plsiNext = plsiTemp;
        }

        m_plsiHead = plsi;
    }
}

//---------------------------------------------------------------------------
// CListSingleItem Class
//---------------------------------------------------------------------------

VOID
CListSingleItem::RemoveList(
    IN PCLIST_SINGLE pls
)
{
    PCLIST_SINGLE_ITEM *pplsi;

    Assert(pls);
    Assert(this);

    for(pplsi = &pls->m_plsiHead;
      !pls->IsListEnd(*pplsi);
      pplsi = &(*pplsi)->m_plsiNext) {
	Assert(*pplsi);
	if(*pplsi == this) {
	    break;
	}
    }
    *pplsi = m_plsiNext;
}

//---------------------------------------------------------------------------
// CListDouble Class
//---------------------------------------------------------------------------

ULONG
CListDouble::CountList(
)
{
    PCLIST_DOUBLE_ITEM pldi;
    ULONG c = 0;

    Assert(this);
    FOR_EACH_CLIST_ITEM(this, pldi) {
	Assert(pldi);
	c++;
    } END_EACH_CLIST_ITEM
    return(c);
}

ENUMFUNC
CListDouble::EnumerateList(
    IN ENUMFUNC (CListDoubleItem::*pfn)(
    )
)
{
    NTSTATUS Status = STATUS_CONTINUE;
    PCLIST_DOUBLE_ITEM plbi;

    Assert(this);
    FOR_EACH_CLIST_ITEM_DELETE(this, plbi, CLIST_DOUBLE_ITEM) {
	Status = (plbi->*pfn)();
	if(Status != STATUS_CONTINUE) {
	    goto exit;
	}
    } END_EACH_CLIST_ITEM
exit:
    return(Status);
}

ENUMFUNC
CListDouble::EnumerateList(
    IN ENUMFUNC (CListDoubleItem::*pfn)(
	PVOID pReference
    ),
    PVOID pReference
)
{
    NTSTATUS Status = STATUS_CONTINUE;
    PCLIST_DOUBLE_ITEM plbi;

    Assert(this);
    FOR_EACH_CLIST_ITEM_DELETE(this, plbi, CLIST_DOUBLE_ITEM) {
	Status = (plbi->*pfn)(pReference);
	if(Status != STATUS_CONTINUE) {
	    goto exit;
	}
    } END_EACH_CLIST_ITEM
exit:
    return(Status);
}

//---------------------------------------------------------------------------
// CListData Class
//---------------------------------------------------------------------------

VOID
CListData::DestroyList()
{
    PCLIST_DATA_DATA pldd;

    Assert(this);
    FOR_EACH_CLIST_ITEM_DELETE(this, pldd, CLIST_DATA_DATA) {
	delete pldd;
    } END_EACH_CLIST_ITEM
    CListSingle::DestroyList();
}

ULONG
CListData::CountList(
)
{
    PCLIST_DATA_DATA pldd;
    ULONG c = 0;

    Assert(this);
    FOR_EACH_CLIST_ITEM(this, pldd) {
	Assert(pldd);
	c++;
    } END_EACH_CLIST_ITEM
    return(c);
}

ENUMFUNC
CListData::EnumerateList(
    IN ENUMFUNC (CListDataItem::*pfn)(
    )
)
{
    NTSTATUS Status = STATUS_CONTINUE;
    PCLIST_DATA_DATA pldd;

    Assert(this);
    FOR_EACH_CLIST_ITEM_DELETE(this, pldd, CLIST_DATA_DATA) {
	Status = (GetListData(pldd)->*pfn)();
	if(Status != STATUS_CONTINUE) {
	    goto exit;
	}
    } END_EACH_CLIST_ITEM
exit:
    return(Status);
}

ENUMFUNC
CListData::EnumerateList(
    IN ENUMFUNC (CListDataItem::*pfn)(
	PVOID pReference
    ),
    PVOID pReference
)
{
    NTSTATUS Status = STATUS_CONTINUE;
    PCLIST_DATA_DATA pldd;

    Assert(this);
    FOR_EACH_CLIST_ITEM_DELETE(this, pldd, CLIST_DATA_DATA) {
	Status = (GetListData(pldd)->*pfn)(pReference);
	if(Status != STATUS_CONTINUE) {
	    goto exit;
	}
    } END_EACH_CLIST_ITEM
exit:
    return(Status);
}

NTSTATUS
CListData::CreateUniqueList(
    OUT PCLIST_DATA pldOut,
    IN PVOID (*GetFunction)(
	IN PVOID pData
    ),
    IN BOOL (*CompareFunction)(
        IN PVOID pIn,
        IN PVOID pOut
    )
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PCLIST_DATA_DATA plddIn, plddOut;
    PVOID pIn, pOut;
    BOOL fFoundMatch;

    FOR_EACH_CLIST_ITEM(this, plddIn) {

	pIn = (*GetFunction)((PVOID)GetListData(plddIn));
	if(pIn == NULL) {
	    continue;
	}
 	AssertAligned(pIn);
	fFoundMatch = FALSE;
	FOR_EACH_CLIST_ITEM(pldOut, plddOut) {

	    pOut = (PVOID)pldOut->GetListData(plddOut);
	    if((*CompareFunction)(pIn, pOut)) {
		fFoundMatch = TRUE;
		break;
	    }

	} END_EACH_CLIST_ITEM

	if(!fFoundMatch) {
	    Status = pldOut->AddListEnd(pIn);
	    if(!NT_SUCCESS(Status)) {
		Trap();
		goto exit;
	    }
	}

    } END_EACH_CLIST_ITEM
exit:
    if(!NT_SUCCESS(Status)) {
	pldOut->DestroyList();
    }
    return(Status);
}

BOOL
CListData::CheckDupList(
    PVOID p
)
{
    PCLIST_DATA_DATA pldd;

    Assert(this);
    FOR_EACH_CLIST_ITEM(this, pldd) {
	if(GetListData(pldd) == p) {
	   return(TRUE);
	}
    } END_EACH_CLIST_ITEM
    return(FALSE);
}

NTSTATUS 
CListData::AddList(
    PVOID p
)
{
    Assert(this);
    if(CheckDupList(p)) {
	return(STATUS_SUCCESS);
    }
    return(AddListDup(p));
}

NTSTATUS 
CListData::AddListDup(
    PVOID p
)
{
    Assert(this);
    PCLIST_DATA_DATA pldd = new CLIST_DATA_DATA(p);
    if(pldd == NULL) {
	return(STATUS_INSUFFICIENT_RESOURCES);
    }
    pldd->AddList(this);
    return(STATUS_SUCCESS);
}

NTSTATUS
CListData::AddListEnd(
    PVOID p
)
{
    ASSERT(!CheckDupList(p));

    PCLIST_DATA_DATA pldd = new CLIST_DATA_DATA(p);
    if(pldd == NULL) {
	return(STATUS_INSUFFICIENT_RESOURCES);
    }
    *(GetListEnd()) = pldd;
    return(STATUS_SUCCESS);
}

NTSTATUS
CListData::AddListOrdered(
    PVOID p,
    LONG lFieldOffset
)
{
    PCLIST_DATA_DATA pldd, *ppldd;
    ULONG ulOrder;

    ASSERT(!CheckDupList(p));
    ulOrder = *((PULONG)(((PCHAR)p) + lFieldOffset));

    pldd = new CLIST_DATA_DATA(p);
    if(pldd == NULL) {
	return(STATUS_INSUFFICIENT_RESOURCES);
    }
    for(ppldd = (PCLIST_DATA_DATA *)&m_plsiHead;
      !IsListEnd(*ppldd);
      ppldd = (PCLIST_DATA_DATA *)&(*ppldd)->m_plsiNext) {
	Assert(*ppldd);
	if(ulOrder < *((PULONG)(((PCHAR)GetListData(*ppldd)) + lFieldOffset))) {
	     break;
	}
    }
    pldd->m_plsiNext = *ppldd;
    *ppldd = pldd;
    return(STATUS_SUCCESS);
}

VOID 
CListData::RemoveList(
    PVOID p
)
{
    PCLIST_DATA_DATA pldd;

    Assert(this);
    FOR_EACH_CLIST_ITEM_DELETE(this, pldd, CLIST_DATA_DATA) {
	if(GetListData(pldd) == p) {
	    pldd->RemoveList(this);
	    delete pldd;
	}
    } END_EACH_CLIST_ITEM
}

VOID
CListData::JoinList(
    PCLIST_DATA pld
)
{
    *GetListEnd() = pld->GetListFirst();
    pld->CListSingle::DestroyList();
}

//---------------------------------------------------------------------------
// CListMulti Class
//---------------------------------------------------------------------------

VOID
CListMulti::DestroyList(
)
{
    PCLIST_MULTI_DATA plmd;

    Assert(this);
    FOR_EACH_CLIST_ITEM_DELETE(this, plmd, CLIST_MULTI_DATA) {
	delete plmd;
    } END_EACH_CLIST_ITEM
    CListDouble::DestroyList();
}

ENUMFUNC
CListMulti::EnumerateList(
    ENUMFUNC (CListMultiItem::*pfn)(
    )
)
{
    NTSTATUS Status = STATUS_CONTINUE;
    PCLIST_MULTI_DATA plmd;

    Assert(this);
    FOR_EACH_CLIST_ITEM_DELETE(this, plmd, CLIST_MULTI_DATA) {
	Status = (GetListData(plmd)->*pfn)();
	if(Status != STATUS_CONTINUE) {
	    goto exit;
	}
    } END_EACH_CLIST_ITEM
exit:
    return(Status);
}

ENUMFUNC
CListMulti::EnumerateList(
    ENUMFUNC (CListMultiItem::*pfn)(
	PVOID pReference
    ),
    PVOID pReference
)
{
    NTSTATUS Status = STATUS_CONTINUE;
    PCLIST_MULTI_DATA plmd;

    Assert(this);
    FOR_EACH_CLIST_ITEM_DELETE(this, plmd, CLIST_MULTI_DATA) {
	Status = (GetListData(plmd)->*pfn)(pReference);
	if(Status != STATUS_CONTINUE) {
	    goto exit;
	}
    } END_EACH_CLIST_ITEM
exit:
    return(Status);
}

BOOL
CListMulti::CheckDupList(
    PVOID p
)
{
    PCLIST_MULTI_DATA plmd;

    FOR_EACH_CLIST_ITEM(this, plmd) {
	if(GetListData(plmd) == p) {
	   return(TRUE);
	}
    } END_EACH_CLIST_ITEM
    return(FALSE);
}

NTSTATUS 
CListMulti::AddList(
    PVOID p,
    CListMultiItem *plmi
)
{
    Assert(this);
    Assert(plmi);
    if(CheckDupList(p)) {
	return(STATUS_SUCCESS);
    }
    PCLIST_MULTI_DATA plmd = new CLIST_MULTI_DATA(p);
    if(plmd == NULL) {
	return(STATUS_INSUFFICIENT_RESOURCES);
    }
    plmd->AddList(this);
    plmd->m_ldiItem.AddList(plmi);
    return(STATUS_SUCCESS);
}

NTSTATUS 
CListMulti::AddListEnd(
    PVOID p,
    CListMultiItem *plmi
)
{
    Assert(this);
    Assert(plmi);
    if(CheckDupList(p)) {
	return(STATUS_SUCCESS);
    }
    PCLIST_MULTI_DATA plmd = new CLIST_MULTI_DATA(p);
    if(plmd == NULL) {
	return(STATUS_INSUFFICIENT_RESOURCES);
    }
    plmd->AddListEnd(this);
    plmd->m_ldiItem.AddListEnd(plmi);
    return(STATUS_SUCCESS);
}

NTSTATUS 
CListMulti::AddListOrdered(
    PVOID p,
    CListMultiItem *plmi,
    LONG lFieldOffset
)
{
    PCLIST_MULTI_DATA plmd, plmdNew;
    ULONG ulOrder;

    ASSERT(!CheckDupList(p));
    ulOrder = *((PULONG)(((PCHAR)p) + lFieldOffset));

    plmdNew = new CLIST_MULTI_DATA(p);
    if(plmdNew == NULL) {
	return(STATUS_INSUFFICIENT_RESOURCES);
    }
    plmdNew->m_ldiItem.AddList(plmi);

    FOR_EACH_CLIST_ITEM(this, plmd) {
	if(ulOrder < *((PULONG)(((PCHAR)GetListData(plmd)) + lFieldOffset))) {
	    break;
	}
    } END_EACH_CLIST_ITEM

    InsertTailList(&plmd->m_le, &plmdNew->m_le);
    return(STATUS_SUCCESS);
}

VOID 
CListMulti::RemoveList(
    PVOID p
)
{
    PCLIST_MULTI_DATA plmd;

    Assert(this);
    FOR_EACH_CLIST_ITEM_DELETE(this, plmd, CLIST_MULTI_DATA) {
	if(GetListData(plmd) == p) {
	    delete plmd;
	}
    } END_EACH_CLIST_ITEM
}

VOID
CListMulti::JoinList(
    PCLIST_MULTI plm
)
{
    Assert(this);
    Assert(plm);
    ASSERT(this->m_leHead.Blink->Flink == &this->m_leHead);
    ASSERT(plm->m_leHead.Blink->Flink == &plm->m_leHead);
    ASSERT(this->m_leHead.Flink->Blink == &this->m_leHead);
    ASSERT(plm->m_leHead.Flink->Blink == &plm->m_leHead);

    if(!plm->IsLstEmpty()) {
	this->m_leHead.Blink->Flink = plm->m_leHead.Flink;
	plm->m_leHead.Flink->Blink = this->m_leHead.Blink;
	plm->m_leHead.Blink->Flink = &this->m_leHead;
	this->m_leHead.Blink = plm->m_leHead.Blink;
	InitializeListHead(&plm->m_leHead);
    }
}

//---------------------------------------------------------------------------
// CListMultiItem Class
//---------------------------------------------------------------------------

CListMultiItem::~CListMultiItem()
{
    PCLIST_MULTI_DATA plmd, plmdNext;

    for(plmd = CONTAINING_RECORD(GetListFirst(), CLIST_MULTI_DATA, m_ldiItem);
       !IsListEnd(&plmd->m_ldiItem);
        plmd = plmdNext) {

	Assert(plmd);
	plmdNext = CONTAINING_RECORD(
	  GetListNext(&plmd->m_ldiItem),
	  CLIST_MULTI_DATA,
	  m_ldiItem);

	delete plmd;
    }
}

//---------------------------------------------------------------------------
// end of clist.cpp
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\sysaudio\cn.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   cn.cpp
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//  To Do:     Date	  Author      Comment
//
//@@END_MSINTERNAL
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------

NTSTATUS
CConnectNode::Create(
    PCONNECT_NODE *ppConnectNode,
    PLOGICAL_FILTER_NODE pLogicalFilterNode,
    PCONNECT_NODE pConnectNodeNext,
    PGRAPH_PIN_INFO pGraphPinInfo,
    PPIN_NODE pPinNode1,
    PPIN_NODE pPinNode2,
    ULONG ulFlagsCurrent,
    PGRAPH_NODE pGraphNode
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PCONNECT_NODE pConnectNode;

    Assert(pPinNode1);
    Assert(pPinNode2);

    pConnectNode = new CConnectNode(pConnectNodeNext);
    if(pConnectNode == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }

    switch(pPinNode1->pPinInfo->Communication) {
        case KSPIN_COMMUNICATION_BOTH:
            switch(pPinNode2->pPinInfo->Communication) {
                case KSPIN_COMMUNICATION_SINK:
                    pConnectNode->pPinNodeSource = pPinNode1;
                    pConnectNode->pPinNodeSink = pPinNode2;
                    break;
                case KSPIN_COMMUNICATION_BOTH:
                case KSPIN_COMMUNICATION_SOURCE:
                    pConnectNode->pPinNodeSource = pPinNode2;
                    pConnectNode->pPinNodeSink = pPinNode1;
                    break;
                default:
                    ASSERT(FALSE);
                    Status = STATUS_INVALID_PARAMETER;
                    goto exit;
            }
            break;
        case KSPIN_COMMUNICATION_SINK:
            pConnectNode->pPinNodeSink = pPinNode1;
            pConnectNode->pPinNodeSource = pPinNode2;
            ASSERT(
              pPinNode2->pPinInfo->Communication == KSPIN_COMMUNICATION_BOTH ||
              pPinNode2->pPinInfo->Communication == KSPIN_COMMUNICATION_SOURCE);
            break;
        case KSPIN_COMMUNICATION_SOURCE:
            pConnectNode->pPinNodeSink = pPinNode2;
            pConnectNode->pPinNodeSource = pPinNode1;
            ASSERT(
              pPinNode2->pPinInfo->Communication == KSPIN_COMMUNICATION_SINK ||
              pPinNode2->pPinInfo->Communication == KSPIN_COMMUNICATION_BOTH);
            break;
        default:
            ASSERT(FALSE);
            Status = STATUS_INVALID_PARAMETER;
            goto exit;
    }
    Status = CConnectInfo::Create(
      pConnectNode, 
      pLogicalFilterNode,
      pConnectNodeNext->GetConnectInfo(),
      pGraphPinInfo,
      ulFlagsCurrent,
      pGraphNode);

    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }
    if(pLogicalFilterNode->GetFlags() & LFN_FLAGS_NO_BYPASS) {
        Status = pGraphNode->lstLogicalFilterNodeNoBypass.AddList(
              pLogicalFilterNode,
          pConnectNode);

        if(!NT_SUCCESS(Status)) {
            Trap();
            goto exit;
        }
    }
    DPF3(80, "CConnectNode::Create %08x PN %08x %08x",
      pConnectNode,
      pConnectNode->pPinNodeSink,
      pConnectNode->pPinNodeSource);
exit:
    if(!NT_SUCCESS(Status)) {
        if (pConnectNode) {
            pConnectNode->Destroy();
        }
        pConnectNode = NULL;
    }
    *ppConnectNode = pConnectNode;
    return(Status);
}

CConnectNode::CConnectNode(
    PCONNECT_NODE pConnectNodeNext
)
{
    this->pConnectNodeNext = pConnectNodeNext;
    pConnectNodeNext->AddRef();
    AddRef();
    DPF1(80, "CConnectNode:%08x PN:%08x %08x", this);
}

CConnectNode::~CConnectNode(
)
{
    Assert(this);
    DPF1(80, "~CConnectNode: %08x", this);
    pConnectInfo->Destroy();
    pConnectNodeNext->Destroy();
}

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\sysaudio\clist.h ===
//---------------------------------------------------------------------------
//
//  Module:   		clist.h
//
//  Description:	list classes
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Macros
//---------------------------------------------------------------------------

#define	FOR_EACH_LIST_ITEM(pl, p) { \
    PCLIST_ITEM pli; \
    for(pli = (pl)->GetListFirst(); \
      !(pl)->IsListEnd(pli);  \
      pli = (pl)->GetListNext(pli)) { \
	p = (pl)->GetListData(pli); \
	(pl)->AssertList(p);

#define	FOR_EACH_LIST_ITEM_DELETE(pl, p) { \
    PCLIST_ITEM pli, pliNext; \
    for(pli = (pl)->GetListFirst(); !(pl)->IsListEnd(pli); pli = pliNext) { \
	pliNext = (pl)->GetListNext(pli); \
	p = (pl)->GetListData(pli); \
	(pl)->AssertList(p);

#define DELETE_LIST_ITEM(pl) \
    pliNext = (pl)->GetListFirst();

#define	FOR_EACH_LIST_ITEM_BACKWARD(pl, p) { \
    PCLIST_ITEM pli; \
    for(pli = (pl)->GetListLast(); \
      !(pl)->IsListEnd(pli);  \
      pli = (pl)->GetListPrevious(pli)) { \
	p = (pl)->GetListData(pli); \
	(pl)->AssertList(p);

#define END_EACH_LIST_ITEM } }

//---------------------------------------------------------------------------

#define	FOR_EACH_CLIST_ITEM(pl, p) { \
    for(p = (pl)->GetListFirst(); \
      !(pl)->IsListEnd(p); \
      p = (pl)->GetListNext(p)) { \
	Assert(p);

#define	FOR_EACH_CLIST_ITEM_DELETE(pl, p, type) { \
    type *pNext; \
    for(p = (pl)->GetListFirst(); !(pl)->IsListEnd(p); p = pNext) { \
	Assert(p); \
	pNext = (pl)->GetListNext(p);

#define END_EACH_CLIST_ITEM } }

//---------------------------------------------------------------------------
// Abstract List Classes
//---------------------------------------------------------------------------

typedef class CList : public CObj
{
public:
} CLIST, *PCLIST;

typedef class CListItem : public CObj
{
public:
} CLIST_ITEM, *PCLIST_ITEM;

//---------------------------------------------------------------------------
// Singlely Linked List
//---------------------------------------------------------------------------

typedef class CListSingle : public CList
{
    friend class CListSingleItem;
public:
    CListSingle()
    {
        m_plsiHead = NULL;
    };
    VOID DestroyList()
    {
        m_plsiHead = NULL;
    };
    BOOL IsLstEmpty()
    {
        Assert(this);
        return(m_plsiHead == NULL);
    };
    CListSingleItem *GetListFirst()
    {
        Assert(this);
        return(m_plsiHead);
    };
    BOOL IsListEnd(CListSingleItem *plsi)
    {
        Assert(this);
        return(plsi == NULL);
    };
    CListSingleItem *GetListData(CListSingleItem *plsi)
    {
        return plsi;
    }
    CListSingleItem *GetListNext(CListSingleItem *plsi);
    CListSingleItem **GetListEnd();
    ENUMFUNC EnumerateList(
        IN ENUMFUNC (CListSingleItem::*pfn)(
        )
    );
    ENUMFUNC EnumerateList(
        IN ENUMFUNC (CListSingleItem::*pfn)(
            PVOID pReference
        ),
        PVOID pReference
    );
    void ReverseList();
protected:
    CListSingleItem *m_plsiHead;
public:
    DefineSignature(0x2048534C);		// LSH

} CLIST_SINGLE, *PCLIST_SINGLE;

//---------------------------------------------------------------------------

typedef class CListSingleItem : public CListItem
{
    friend class CListData;
    friend class CListSingle;
public:
    CListSingleItem()
    {
        m_plsiNext = NULL;
    };
    VOID AddList(CListSingle *pls)
    {
        Assert(pls);
        Assert(this);
        ASSERT(m_plsiNext == NULL);
        m_plsiNext = pls->m_plsiHead;
        pls->m_plsiHead = this;
    };
    VOID AddListEnd(CListSingle *pls)
    {
        Assert(pls);
        Assert(this);
        ASSERT(m_plsiNext == NULL);
        *(pls->GetListEnd()) = this;
    };
    VOID RemoveList(CListSingle *pls);
private:
    CListSingleItem *m_plsiNext;
public:
    DefineSignature(0x2049534C);		// LSI

} CLIST_SINGLE_ITEM, *PCLIST_SINGLE_ITEM;

inline CListSingleItem *
CListSingle::GetListNext(CListSingleItem *plsi)
{
    Assert(this);
    return plsi->m_plsiNext;
}

//---------------------------------------------------------------------------
// Doublely Linked List
//---------------------------------------------------------------------------

typedef class CListDouble : public CList
{
    friend class CListDoubleItem;
public:
    CListDouble()
    {
	InitializeListHead(&m_leHead);
    };
    VOID DestroyList()
    {
    };
    BOOL IsLstEmpty()
    {
	Assert(this);
	return IsListEmpty(&m_leHead);
    };
    ULONG CountList();
    CListDoubleItem *GetListFirst();
    CListDoubleItem *GetListLast();
    BOOL IsListEnd(CListDoubleItem *pldi);
    CListDoubleItem *GetListNext(CListDoubleItem *pldi);
    CListDoubleItem *GetListPrevious(CListDoubleItem *pldi);
    CListDoubleItem *GetListData(CListDoubleItem *pldi)
    {
	return pldi;
    };
    ENUMFUNC EnumerateList(
	IN ENUMFUNC (CListDoubleItem::*pfn)(
	)
    );
    ENUMFUNC EnumerateList(
	IN ENUMFUNC (CListDoubleItem::*pfn)(
	    PVOID pReference
	),
	PVOID pReference
    );
protected:
    LIST_ENTRY m_leHead;
public:
    DefineSignature(0x2048424C);		// LBH

} CLIST_DOUBLE, *PCLIST_DOUBLE;

//---------------------------------------------------------------------------

typedef class CListDoubleItem : public CListItem
{
    friend class CListDouble;
public:
    VOID AddList(CListDouble *plb)
    {
	Assert(plb);
	Assert(this);
	ASSERT(m_le.Flink == NULL);
	ASSERT(m_le.Blink == NULL);
	InsertHeadList(&plb->m_leHead, &m_le);
    };
    VOID AddListEnd(CListDouble *plb)
    {
	Assert(plb);
	Assert(this);
	ASSERT(m_le.Flink == NULL);
	ASSERT(m_le.Blink == NULL);
	InsertTailList(&plb->m_leHead, &m_le);
    };
    VOID RemoveList()
    {
	Assert(this);
	ASSERT(m_le.Flink != NULL);
	ASSERT(m_le.Blink != NULL);
	RemoveEntryList(&m_le);
	m_le.Flink = NULL;
	m_le.Blink = NULL;
    };
    VOID RemoveListCheck()
    {
	Assert(this);
	if(m_le.Flink != NULL) {
	    RemoveList();
	}
    };
protected:
    LIST_ENTRY m_le;
public:
    DefineSignature(0x2049424C);		// LBI

} CLIST_DOUBLE_ITEM, *PCLIST_DOUBLE_ITEM;

inline CListDoubleItem *
CListDouble::GetListFirst()
{
    Assert(this);
    ASSERT(m_leHead.Flink != NULL);
    return CONTAINING_RECORD(m_leHead.Flink, CListDoubleItem, m_le);
}

inline CListDoubleItem *
CListDouble::GetListLast()
{
    Assert(this);
    ASSERT(m_leHead.Blink != NULL);
    return CONTAINING_RECORD(m_leHead.Blink, CListDoubleItem, m_le);
}

inline BOOL 
CListDouble::IsListEnd(CListDoubleItem *pldi)
{
    Assert(this);
    return(&pldi->m_le == &m_leHead);
}

inline CListDoubleItem *
CListDouble::GetListNext(CListDoubleItem *pldi)
{
    Assert(this);
    ASSERT(pldi->m_le.Flink != NULL);
    return CONTAINING_RECORD(pldi->m_le.Flink, CListDoubleItem, m_le);
}

inline CListDoubleItem *
CListDouble::GetListPrevious(CListDoubleItem *pldi)
{
    Assert(this);
    ASSERT(pldi->m_le.Blink != NULL);
    return CONTAINING_RECORD(pldi->m_le.Blink, CListDoubleItem, m_le);
}

//---------------------------------------------------------------------------
// Linked List of Data Pointers
//---------------------------------------------------------------------------

class CListDataItem;

typedef class CListDataData : public CListSingleItem
{
    friend class CListData;
public:
    CListDataData(
       CListDataItem *pldi
    )
    {
	m_pldiData = pldi;
    };
    CListDataData(
       PVOID p
    )
    {
	m_pldiData = (CListDataItem *)p;
    };
private:
    CListDataItem *m_pldiData;
public:
    DefineSignature(0x2044444C);		// LDD

} CLIST_DATA_DATA, *PCLIST_DATA_DATA;

//---------------------------------------------------------------------------

typedef class CListData : public CListSingle
{
public:
    ~CListData()
    {
	CListData::DestroyList();
    };
    VOID DestroyList();
    ULONG CountList();
    CListDataData *GetListFirst()
    {
	Assert(this);
	return (CListDataData *)CListSingle::GetListFirst();
    };
    CListDataData *GetListNext(CListDataData *pldd)
    {
	Assert(this);
	return (CListDataData *)CListSingle::GetListNext(pldd);
    };
    CListDataItem *GetListData(CListDataData *pldd)
    {
	Assert(this);
	return pldd->m_pldiData;
    };
    CListDataItem *GetListFirstData()
    {
	Assert(this);
	return GetListData(GetListFirst());
    };
    ENUMFUNC EnumerateList(
	IN ENUMFUNC (CListDataItem::*pfn)(
	)
    );
    ENUMFUNC EnumerateList(
	IN ENUMFUNC (CListDataItem::*pfn)(
	    PVOID pReference
	),
	PVOID pReference
    );
    NTSTATUS CreateUniqueList(
	OUT CListData *pldOut,
	IN PVOID (*GetFunction)(
	    IN PVOID pData
	),
	IN BOOL (*CompareFunction)(
	    IN PVOID pIn,
	    IN PVOID pOut
	)
    );
    BOOL CheckDupList(
	PVOID p
    );
    NTSTATUS AddList(
	PVOID p
    );
    NTSTATUS AddListDup(
	PVOID p
    );
    NTSTATUS AddListEnd(
	PVOID p
    );
    NTSTATUS AddListOrdered(
	PVOID p,
	LONG lFieldOffset
    );
    VOID RemoveList(
	PVOID p
    );
    VOID JoinList(
	CListData *pld
    );
private:
    CListDataData **GetListEnd()
    {
       return((CListDataData **)CListSingle::GetListEnd());
    };
public:
    DefineSignature(0x2048444C);		// LDH

} CLIST_DATA, *PCLIST_DATA;

//---------------------------------------------------------------------------

typedef class CListDataItem : public CListItem
{
public: 
    ENUMFUNC Destroy()
    {
	delete this;
	return(STATUS_CONTINUE);
    };
    BOOL CheckDupList(
	PCLIST_DATA pld
    )
    {
	Assert(this);
	return(pld->CheckDupList((PVOID)this));
    };
    NTSTATUS AddList(
	PCLIST_DATA pld
    )
    {
	Assert(this);
	return(pld->AddList((PVOID)this));
    };
    NTSTATUS AddListDup(
	PCLIST_DATA pld
    )
    {
	Assert(this);
	return(pld->AddListDup((PVOID)this));
    };
    NTSTATUS AddListEnd(
	PCLIST_DATA pld
    )
    {
	Assert(this);
	return(pld->AddListEnd((PVOID)this));
    };
    VOID RemoveList(
	PCLIST_DATA pld
    )
    {
	Assert(this);
	pld->RemoveList((PVOID)this);
    };
    DefineSignature(0x2049444C);		// LDI

} CLIST_DATA_ITEM, *PCLIST_DATA_ITEM;

typedef PVOID (*UNIQUE_LIST_PFN)(PVOID);
typedef BOOL (*UNIQUE_LIST_PFN2)(PVOID, PVOID);

//---------------------------------------------------------------------------
// Multi-Headed Linked List
//---------------------------------------------------------------------------

typedef class CListMultiData : public CListDoubleItem
{
    friend class CListMulti;
    friend class CListMultiItem;
public:
    CListMultiData(
	PVOID p
    )
    {
	m_plmiData = (CListMultiItem *)p;
    };
    ~CListMultiData()
    {
	CListMultiData::RemoveList();
    };
    VOID RemoveList()
    {
	Assert(this);
	CListDoubleItem::RemoveList();
	m_ldiItem.RemoveList();
    };
private:
    CListDoubleItem m_ldiItem;
    CListMultiItem *m_plmiData;
public:
    DefineSignature(0x20444d4C);		// LMD

} CLIST_MULTI_DATA, *PCLIST_MULTI_DATA;

//---------------------------------------------------------------------------

typedef class CListMulti : public CListDouble
{
    friend class CListMultiItem;
public:
    ~CListMulti()
    {
	CListMulti::DestroyList();
    };
    VOID DestroyList();
    ENUMFUNC EnumerateList(
	ENUMFUNC (CListMultiItem::*pfn)(
	)
    );
    ENUMFUNC EnumerateList(
	ENUMFUNC (CListMultiItem::*pfn)(
	    PVOID pReference
	),
	PVOID pReference
    );
    CListMultiData *GetListFirst()
    {
	Assert(this);
	return (CListMultiData *)CListDouble::GetListFirst();
    };
    CListMultiData *GetListLast()
    {
	Assert(this);
	return (CListMultiData *)CListDouble::GetListLast();
    };
    BOOL IsListEnd(CListMultiData *plmd)
    {
	Assert(this);
	return CListDouble::IsListEnd(plmd);
    };
    CListMultiData *GetListNext(CListMultiData *plmd)
    {
	Assert(this);
	return (CListMultiData *)CListDouble::GetListNext(plmd);
    };
    CListMultiData *GetListPrevious(CListMultiData *plmd)
    {
	Assert(this);
	return (CListMultiData *)CListDouble::GetListPrevious(plmd);
    };
    CListMultiItem *GetListData(CListMultiData *plmd)
    { 
	Assert(this);
	return plmd->m_plmiData;
    };
    CListMultiItem *GetListFirstData()
    {
	Assert(this);
	return GetListData(GetListFirst());
    };
    BOOL CheckDupList(
	PVOID p
    );
    NTSTATUS AddList(
	PVOID p,
	CListMultiItem *plmi
    );
    NTSTATUS AddList(
	CListMultiItem *plmi
    )
    {
	Assert(this);
	return(AddList((PVOID)plmi, plmi));
    };
    NTSTATUS AddListEnd(
	PVOID p,
	CListMultiItem *plmi
    );
    NTSTATUS AddListEnd(
	CListMultiItem *plmi
    )
    {
	Assert(this);
	return(AddListEnd((PVOID)plmi, plmi));
    };
    NTSTATUS AddListOrdered(
	PVOID p,
	CListMultiItem *plmi,
	LONG lFieldOffset
    );
    NTSTATUS AddListOrdered(
	CListMultiItem *plmi,
	LONG lFieldOffset
    )
    {
	Assert(this);
	return(AddListOrdered((PVOID)plmi, plmi, lFieldOffset));
    };
    VOID RemoveList(
	PVOID p
    );
    VOID JoinList(
	CListMulti *plm
    );
    DefineSignature(0x20484D4C);		// LMH

} CLIST_MULTI, *PCLIST_MULTI;

//---------------------------------------------------------------------------

typedef class CListMultiItem : public CListDouble
{
public:
    ~CListMultiItem();
    BOOL CheckDupList(
	PCLIST_MULTI plm
    )
    {
	return(plm->CheckDupList((PVOID)this));
    };
    NTSTATUS AddList(
	PCLIST_MULTI plm
    )
    {
	Assert(plm);
	Assert(this);
	return(plm->AddList(this));
    };
    NTSTATUS AddListEnd(
	PCLIST_MULTI plm
    )
    {
	Assert(plm);
	Assert(this);
	return(plm->AddListEnd(this));
    };
    NTSTATUS AddListOrdered(
	PCLIST_MULTI plm,
	LONG lFieldOffset
    )
    {
	Assert(plm);
	Assert(this);
	return(plm->AddListOrdered(this, lFieldOffset));
    };
    VOID RemoveList(
	PCLIST_MULTI plm
    )
    {
	Assert(this);
	plm->RemoveList((PVOID)this);
    };
    DefineSignature(0x20494d4C);		// LMI

} CLIST_MULTI_ITEM, *PCLIST_MULTI_ITEM;

//---------------------------------------------------------------------------
//  Templates
//---------------------------------------------------------------------------

template<class TYPE>
class ListSingleDestroy : public CListSingle
{
public:
    ~ListSingleDestroy()
    {
	ListSingleDestroy::DestroyList();
    };
    VOID DestroyList()
    {
	ListSingleDestroy::EnumerateList(TYPE::Destroy);
	CListSingle::DestroyList();
    };
    VOID AssertList(TYPE *p)
    {
	Assert(p);
    };
    ENUMFUNC EnumerateList(
	IN ENUMFUNC (TYPE::*pfn)(
	)
    )
    {
	return CListSingle::EnumerateList(
	  (ENUMFUNC (CListSingleItem::*)())pfn);
    };
    ENUMFUNC EnumerateList(
	IN ENUMFUNC (TYPE::*pfn)(
	    PVOID pReference
	),
	PVOID pReference
    )
    {
	return CListSingle::EnumerateList(
	  (ENUMFUNC (CListSingleItem::*)(PVOID))pfn,
	  pReference);
    };
    PCLIST_ITEM GetListFirst()
    {
	return CListSingle::GetListFirst();
    };
    BOOL IsListEnd(PCLIST_ITEM pli)
    {
	return CListSingle::IsListEnd((CListSingleItem *)pli);
    };
    PCLIST_ITEM GetListNext(PCLIST_ITEM pli)
    {
	return CListSingle::GetListNext((CListSingleItem *)pli);
    };
    TYPE *GetListData(PCLIST_ITEM pli)
    {
	return (TYPE *)CListSingle::GetListData((CListSingleItem *)pli);
    };
    TYPE *GetListFirstData()
    {
	return (TYPE *)CListSingle::GetListData(CListSingle::GetListFirst());
    };
};

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

template<class TYPE>
class ListDouble : public CListDouble
{
public:
    VOID AssertList(TYPE *p)
    {
	Assert(p);
    };
    ENUMFUNC EnumerateList(
	IN ENUMFUNC (TYPE::*pfn)()
    )
    {
	return CListDouble::EnumerateList(
	  (ENUMFUNC (CListDoubleItem::*)())pfn);
    };
    ENUMFUNC EnumerateList(
	IN ENUMFUNC (TYPE::*pfn)(
	    PVOID pReference
	),
	PVOID pReference
    )
    {
	return CListDouble::EnumerateList(
	  (ENUMFUNC (CListDoubleItem::*)(PVOID))pfn,
	  pReference);
    };
    PCLIST_ITEM GetListFirst()
    {
	return CListDouble::GetListFirst();
    };
    PCLIST_ITEM GetListLast()
    {
	return CListDouble::GetListLast();
    };
    BOOL IsListEnd(PCLIST_ITEM pli)
    {
	return CListDouble::IsListEnd((CListDoubleItem *)pli);
    };
    PCLIST_ITEM GetListNext(PCLIST_ITEM pli)
    {
	return CListDouble::GetListNext((CListDoubleItem *)pli);
    };
    PCLIST_ITEM GetListPrevious(PCLIST_ITEM pli)
    {
	return CListDouble::GetListPrevious((CListDoubleItem *)pli);
    };
    TYPE *GetListData(PCLIST_ITEM pli)
    {
	return (TYPE *)CListDouble::GetListData((CListDoubleItem *)pli);
    };
};

//---------------------------------------------------------------------------

template<class TYPE>
class ListDoubleDestroy : public ListDouble<TYPE>
{
public:
    ~ListDoubleDestroy()
    {
	ListDoubleDestroy::DestroyList();
    };
    VOID DestroyList()
    {
	ListDoubleDestroy::EnumerateList(TYPE::Destroy);
	CListDouble::DestroyList();
    };
};

//---------------------------------------------------------------------------

template<class TYPE>
class ListDoubleField : public CListDouble
{
public:
    VOID AssertList(TYPE *p)
    {
	Assert(p);
    };
    CListItem *GetListFirst()
    {
	return (CListItem *)CONTAINING_RECORD(
	  CListDouble::GetListFirst(), TYPE, ldiNext);
    };
    BOOL IsListEnd(CListItem *pli)
    {
	return CListDouble::IsListEnd(&((TYPE *)pli)->ldiNext);
    };
    CListItem *GetListNext(CListItem *pli)
    {
	return (CListItem *)CONTAINING_RECORD(
	  CListDouble::GetListNext(&((TYPE *)pli)->ldiNext), TYPE, ldiNext);
    };
    TYPE *GetListData(CListItem *pli)
    {
	return CONTAINING_RECORD(
	  CListDouble::GetListData(&((TYPE *)pli)->ldiNext), TYPE, ldiNext);
    };
};

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

template<class TYPE>
class ListDataAssertLess : public CListData
{
public:
    VOID AssertList(TYPE *p)
    {
    };
    PCLIST_ITEM GetListFirst()
    {
	return CListData::GetListFirst();
    };
    BOOL IsListEnd(PCLIST_ITEM pli)
    {
	return CListData::IsListEnd((CListDataData *)pli);
    };
    PCLIST_ITEM GetListNext(PCLIST_ITEM pli)
    {
	return CListData::GetListNext((CListDataData *)pli);
    };
    TYPE *GetListData(PCLIST_ITEM pli)
    {
	return (TYPE *)CListData::GetListData((CListDataData *)pli);
    };
    TYPE *GetListFirstData()
    {
	return (TYPE *)CListData::GetListFirstData();
    };
    NTSTATUS AddList(
	TYPE *p
    )
    {
	return CListData::AddList((PVOID)p);
    };
    NTSTATUS AddListDup(
	TYPE *p
    )
    {
	return CListData::AddListDup((PVOID)p);
    };
    NTSTATUS AddListEnd(
	TYPE *p
    )
    {
	return CListData::AddListEnd((PVOID)p);
    };
    NTSTATUS AddListOrdered(
	TYPE *p,
	LONG lFieldOffset
    )
    {
	return CListData::AddListOrdered((PVOID)p, lFieldOffset);
    };
    VOID RemoveList(
	TYPE *p
    )
    {
	CListData::RemoveList((PVOID)p);
    };
};

//---------------------------------------------------------------------------

template<class TYPE>
class ListData : public ListDataAssertLess<TYPE>
{
public:
    VOID AssertList(TYPE *p)
    {
	Assert(p);
    };
    ENUMFUNC EnumerateList(
	ENUMFUNC (TYPE::*pfn)()
    ) 
    {
	return CListData::EnumerateList((ENUMFUNC (CListDataItem::*)())pfn);
    };
    ENUMFUNC EnumerateList(
	ENUMFUNC (TYPE::*pfn)(
	    PVOID pReference
	),
	PVOID pReference
    ) 
    {
	return CListData::EnumerateList(
	  (ENUMFUNC (CListDataItem::*)(PVOID))pfn,
	  pReference);
    };
};

//---------------------------------------------------------------------------

template<class TYPE>
class ListDataDestroy : public ListData<TYPE>
{
public:
    ~ListDataDestroy()
    {
	ListDataDestroy::DestroyList();
    };
    VOID DestroyList()
    {
	ListDataDestroy::EnumerateList(TYPE::Destroy);
	CListData::DestroyList();
    };
};

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

template<class TYPE>
class ListMulti : public CListMulti
{
public:
    VOID AssertList(TYPE *p)
    {
	Assert(p);
    };
    PCLIST_ITEM GetListFirst()
    {
	return CListMulti::GetListFirst();
    };
    PCLIST_ITEM GetListLast()
    {
	return CListMulti::GetListLast();
    };
    BOOL IsListEnd(PCLIST_ITEM pli)
    {
	return CListMulti::IsListEnd((CListMultiData *)pli);
    };
    PCLIST_ITEM GetListNext(PCLIST_ITEM pli)
    {
	return CListMulti::GetListNext((CListMultiData *)pli);
    };
    PCLIST_ITEM GetListPrevious(PCLIST_ITEM pli)
    {
	return CListMulti::GetListPrevious((CListMultiData *)pli);
    };
    TYPE *GetListData(PCLIST_ITEM pli)
    {
	return (TYPE *)CListMulti::GetListData((CListMultiData *)pli);
    };
    TYPE *GetListFirstData()
    {
	return (TYPE *)CListMulti::GetListFirstData();
    };
    ENUMFUNC EnumerateList(
	ENUMFUNC (TYPE::*pfn)()
    ) 
    {
	return CListMulti::EnumerateList((ENUMFUNC (CListMultiItem::*)())pfn);
    };
    ENUMFUNC EnumerateList(
	ENUMFUNC (TYPE::*pfn)(
	    PVOID pReference
	),
	PVOID pReference
    ) 
    {
	return CListMulti::EnumerateList(
	  (ENUMFUNC (CListMultiItem::*)(PVOID))pfn,
	  pReference);
    };
};

//---------------------------------------------------------------------------

template<class TYPE>
class ListMultiDestroy : public ListMulti<TYPE>
{
public:
    ~ListMultiDestroy()
    {
	ListMultiDestroy::DestroyList();
    };
    VOID DestroyList()
    {
	ListMultiDestroy::EnumerateList(TYPE::Destroy);
	CListMulti::DestroyList();
    };
};

//---------------------------------------------------------------------------
//  End of File: clist.h
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\sysaudio\cni.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   cni.cpp
//
//  Description:
//
//  Connect Node Instance
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date   Author      Comment
//
//  To Do:     Date   Author      Comment
//
//@@END_MSINTERNAL
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

CConnectNodeInstance::CConnectNodeInstance(
    IN PCONNECT_NODE pConnectNode
)
{
    Assert(this);
    pConnectNode->AddPinInstance();
    pConnectNode->SetConnectNodeInstance(this);
    this->pConnectNode = pConnectNode;
}

CConnectNodeInstance::~CConnectNodeInstance(
)
{
    Assert(this);
    DPF1(95, "~CConnectNodeInstance: %08x", this);
    if(pConnectNode != NULL) {
        Assert(pConnectNode);
        pConnectNode->RemovePinInstance();
        if(pConnectNode->GetConnectNodeInstance() == this) {
            pConnectNode->SetConnectNodeInstance(NULL);
        }
    }
    pPinNodeInstanceSource->Destroy();
    pPinNodeInstanceSink->Destroy();
    pFilterNodeInstanceSource->Destroy();
    pFilterNodeInstanceSink->Destroy();
}

NTSTATUS
CConnectNodeInstance::Create(
    PSTART_NODE_INSTANCE pStartNodeInstance,
    PDEVICE_NODE pDeviceNode
)
{
    PFILTER_NODE_INSTANCE *ppFilterNodeInstancePrevious;
    PCONNECT_NODE_INSTANCE pConnectNodeInstance = NULL;
    PLOGICAL_FILTER_NODE pLogicalFilterNode;
    NTSTATUS Status = STATUS_SUCCESS;
    BOOL fReuseFilterInstance = TRUE;
    PCONNECT_NODE pConnectNode;

    pLogicalFilterNode =
      pStartNodeInstance->pStartNode->pPinNode->pLogicalFilterNode;
    ppFilterNodeInstancePrevious = &pStartNodeInstance->pFilterNodeInstance;

    for(pConnectNode = pStartNodeInstance->pStartNode->GetFirstConnectNode();
      pConnectNode != NULL;
      pConnectNode = pConnectNode->GetNextConnectNode()) {

        Assert(pLogicalFilterNode);
        Assert(pConnectNode);

        // Get existing connect node instance
        fReuseFilterInstance = pConnectNode->IsReuseFilterInstance();
        pConnectNodeInstance = pConnectNode->GetConnectNodeInstance();

        //
        // Check if the connection already exits. For reusable connections 
        // (for example for kmixer-render connection) do not recreate the 
        // connection instance.
        //
        if(fReuseFilterInstance && pConnectNodeInstance != NULL) {
            Assert(pConnectNodeInstance);
            DPF4(100, "Existing CNI: %08x %d FNI Source: %08x FNI Sink %08x",
              pConnectNodeInstance,
              pConnectNodeInstance->cReference,
              pConnectNodeInstance->pFilterNodeInstanceSource,
              pConnectNodeInstance->pFilterNodeInstanceSink);
        }
        else {
            if(!pConnectNode->IsPinInstances()) {
                DPF1(90, "CCNI::Create: no instances CN %08x", pConnectNode);
                Status = STATUS_DEVICE_BUSY;
                goto exit;
            }
            pConnectNodeInstance = new CONNECT_NODE_INSTANCE(pConnectNode);
            if(pConnectNodeInstance == NULL) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto exit;
            }

            pConnectNodeInstance->fRender = pStartNodeInstance->IsRender();
            Status = CFilterNodeInstance::Create(
              &pConnectNodeInstance->pFilterNodeInstanceSource,
              pLogicalFilterNode,
              pDeviceNode,
              fReuseFilterInstance);

            if(!NT_SUCCESS(Status)) {
                delete pConnectNodeInstance;
                goto exit;
            }
            Assert(pConnectNodeInstance->pFilterNodeInstanceSource);

            DPF4(100, "New CNI: %08x %d FNI Source: %08x FNI Sink %08x",
              pConnectNodeInstance,
              pConnectNodeInstance->cReference,
              pConnectNodeInstance->pFilterNodeInstanceSource,
              pConnectNodeInstance->pFilterNodeInstanceSink);
        }
        Status = pConnectNodeInstance->AddListEnd(
          &pStartNodeInstance->lstConnectNodeInstance);

        if(!NT_SUCCESS(Status)) {
            goto exit;
        }
        if(*ppFilterNodeInstancePrevious == NULL) {

            *ppFilterNodeInstancePrevious =
              pConnectNodeInstance->pFilterNodeInstanceSource;

            pConnectNodeInstance->pFilterNodeInstanceSource->AddRef();
        }
        ppFilterNodeInstancePrevious =
          &pConnectNodeInstance->pFilterNodeInstanceSink;

        pLogicalFilterNode = pConnectNode->pPinNodeSink->pLogicalFilterNode;
    }

    //
    // This is to cover a StartNode with no Connections. So this graph
    // consists of a single filter and single pin. No connection are required.
    //
    if(*ppFilterNodeInstancePrevious == NULL) {

        Assert(pLogicalFilterNode);
        Status = CFilterNodeInstance::Create(
          ppFilterNodeInstancePrevious,
          pLogicalFilterNode,
          pDeviceNode,
          fReuseFilterInstance);

        if(!NT_SUCCESS(Status)) {
            goto exit;
        }
        Assert(*ppFilterNodeInstancePrevious);
    }
exit:
    return(Status);
}

NTSTATUS
CConnectNodeInstance::AddListEnd(
    PCLIST_MULTI plm
)
{
    NTSTATUS Status;

    Status = CListMultiItem::AddListEnd(plm);
    if(NT_SUCCESS(Status)) {
        AddRef();
    }
    return(Status);
}

ENUMFUNC
CConnectNodeInstance::Destroy(
)
{
    if(this != NULL) {
        Assert(this);
        DPF1(95, "CConnectNodeInstance::Destroy: %08x", this);
        ASSERT(cReference > 0);

        if(--cReference == 0) {
            delete this;
        }
    }
    return(STATUS_CONTINUE);
}

NTSTATUS
CConnectNodeInstance::Connect(
    IN PWAVEFORMATEX pWaveFormatEx,
    IN PKSPIN_CONNECT pPinConnectDirect
)
{
    PKSPIN_CONNECT pPinConnect = NULL;
    BOOL fDeletePinConnect;
    NTSTATUS Status = STATUS_SUCCESS;

    Assert(this);
    Assert(pConnectNode);
    Assert(pFilterNodeInstanceSource);
    Assert(pFilterNodeInstanceSink);
    ASSERT(pFilterNodeInstanceSource->pFilterNode ==
      pConnectNode->pPinNodeSource->pPinInfo->pFilterNode);
    ASSERT(pFilterNodeInstanceSink->pFilterNode ==
      pConnectNode->pPinNodeSink->pPinInfo->pFilterNode);

    DPF3(90, "CCNI::Connect: CN  %08x #%d Source %s",
      pConnectNode,
      pConnectNode->pPinNodeSource->pPinInfo->PinId,
      pFilterNodeInstanceSource->pFilterNode->DumpName());

    DPF3(90, "CCNI::Connect: CNI %08x #%d Sink   %s",
      this,
      pConnectNode->pPinNodeSink->pPinInfo->PinId,
      pFilterNodeInstanceSink->pFilterNode->DumpName());

    // If the Connect is supplied to this function,
    // we should not delete it.
    //
    pPinConnect = pPinConnectDirect;
    fDeletePinConnect = (NULL == pPinConnect);

    if(pPinNodeInstanceSink != NULL || pPinNodeInstanceSource != NULL) {
        ASSERT(NT_SUCCESS(Status));
        goto exit;
    }
    ASSERT(pPinNodeInstanceSink == NULL && pPinNodeInstanceSource == NULL);

    if (NULL == pPinConnect) {
        Status = CreatePinConnect(
          &pPinConnect,
          pConnectNode,
          pFilterNodeInstanceSink,
          pFilterNodeInstanceSource,
          pWaveFormatEx);
    }
    else {
        pPinConnect->Medium = *(pConnectNode->pPinNodeSink->pMedium);
        pPinConnect->Interface = *(pConnectNode->pPinNodeSink->pInterface);
        pPinConnect->Priority.PriorityClass = KSPRIORITY_NORMAL;
        pPinConnect->Priority.PrioritySubClass = 1;
        pPinConnect->PinToHandle = NULL;
    }

    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
    Status = CPinNodeInstance::Create(
      &pPinNodeInstanceSink,
      pFilterNodeInstanceSink,
      pConnectNode->pPinNodeSink,
      pPinConnect,
      fRender
#ifdef FIX_SOUND_LEAK
     ,FALSE
#endif
      );

    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
    // Get the pin handle for the pin connecting to this pin
    pPinConnect->PinToHandle = pPinNodeInstanceSink->hPin;

    Status = CPinNodeInstance::Create(
      &pPinNodeInstanceSource,
      pFilterNodeInstanceSource,
      pConnectNode->pPinNodeSource,
      pPinConnect,
      fRender
#ifdef FIX_SOUND_LEAK
     ,FALSE
#endif
      );

    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
    DPF2(90, "CCNI::Connect: SUCCESS PNI Source %08x PNI Sink %08x",
      pPinNodeInstanceSource,
      pPinNodeInstanceSink);
exit:
    if(!NT_SUCCESS(Status)) {
        DPF1(90, "CCNI::Connect: FAIL %08x", Status);
        pPinNodeInstanceSink->Destroy();
        pPinNodeInstanceSink = NULL;
        pPinNodeInstanceSource->Destroy();
        pPinNodeInstanceSource = NULL;
    }

    if (fDeletePinConnect) {
        delete pPinConnect;
    }

    return(Status);
}

NTSTATUS
CConnectNodeInstance::SetStateTopDown(
    KSSTATE NewState,
    KSSTATE PreviousState,
    ULONG ulFlags
)
{
    NTSTATUS Status = STATUS_SUCCESS;

    if(this != NULL) {
        Assert(this);

        if(ulFlags & SETSTATE_FLAG_SOURCE) {
            Status = pPinNodeInstanceSource->SetState(
              NewState,
              PreviousState,
              ulFlags);

            if(!NT_SUCCESS(Status)) {
                goto exit;
            }
        }
        if(ulFlags & SETSTATE_FLAG_SINK) {
            Status = pPinNodeInstanceSink->SetState(
              NewState,
              PreviousState,
              ulFlags);

            if(!NT_SUCCESS(Status)) {
                goto exit;
            }
        }
    }
exit:
    return(Status);
}

NTSTATUS
CConnectNodeInstance::SetStateBottomUp(
    KSSTATE NewState,
    KSSTATE PreviousState,
    ULONG ulFlags
)
{
    NTSTATUS Status = STATUS_SUCCESS;

    if(this != NULL) {
        Assert(this);

        if(ulFlags & SETSTATE_FLAG_SINK) {
            Status = pPinNodeInstanceSink->SetState(
              NewState,
              PreviousState,
              ulFlags);

            if(!NT_SUCCESS(Status)) {
                goto exit;
            }
        }
        if(ulFlags & SETSTATE_FLAG_SOURCE) {
            Status = pPinNodeInstanceSource->SetState(
              NewState,
              PreviousState,
              ulFlags);

            if(!NT_SUCCESS(Status)) {
                goto exit;
            }
        }
    }
exit:
    return(Status);
}

//---------------------------------------------------------------------------

NTSTATUS
CreatePinConnect(
    PKSPIN_CONNECT *ppPinConnect,
    PCONNECT_NODE pConnectNode,
    PFILTER_NODE_INSTANCE pFilterNodeInstanceSink,
    PFILTER_NODE_INSTANCE pFilterNodeInstanceSource,
    PWAVEFORMATEX pWaveFormatExLimit
)
{
    NTSTATUS Status = STATUS_SUCCESS;

    Assert(pConnectNode);
    Assert(pFilterNodeInstanceSink);
    Assert(pFilterNodeInstanceSource);

    if(pWaveFormatExLimit == NULL) {
        if(pConnectNode->IsTopDown()) {
            Status = CreatePinIntersection(
              ppPinConnect,
              pConnectNode->pPinNodeSource,
              pConnectNode->pPinNodeSink,
              pFilterNodeInstanceSource,
              pFilterNodeInstanceSink);
        }
        else {
            Status = CreatePinIntersection(
              ppPinConnect,
              pConnectNode->pPinNodeSink,
              pConnectNode->pPinNodeSource,
              pFilterNodeInstanceSink,
              pFilterNodeInstanceSource);
        }
    }
    else {
        Status = CreateWaveFormatEx(
          ppPinConnect,
          pConnectNode,
          pWaveFormatExLimit);
    }

    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
    //
    // For all the normal fields in the PinConnect we could either the
    // source or sink pinnode, they are same.
    //
    ASSERT(pConnectNode->pPinNodeSink->pMedium != NULL);
    ASSERT(pConnectNode->pPinNodeSink->pInterface != NULL);
    ASSERT(pConnectNode->pPinNodeSink->pDataRange != NULL);

    (*ppPinConnect)->Medium = *(pConnectNode->pPinNodeSink->pMedium);
    (*ppPinConnect)->Interface = *(pConnectNode->pPinNodeSink->pInterface);

    (*ppPinConnect)->Priority.PriorityClass = KSPRIORITY_NORMAL;
    (*ppPinConnect)->Priority.PrioritySubClass = 1;
    (*ppPinConnect)->PinToHandle = NULL;

    DPF2(100, "CreatePinConnect: Source #%d %s",
      pConnectNode->pPinNodeSource->pPinInfo->PinId,
      pFilterNodeInstanceSource->pFilterNode->DumpName());
    DPF2(100, "CreatePinConnect: Sink   #%d %s",
      pConnectNode->pPinNodeSink->pPinInfo->PinId,
      pFilterNodeInstanceSink->pFilterNode->DumpName());
exit:
    return(Status);
}

NTSTATUS
CreatePinIntersection(
    PKSPIN_CONNECT *ppPinConnect,
    PPIN_NODE pPinNode1,
    PPIN_NODE pPinNode2,
    PFILTER_NODE_INSTANCE pFilterNodeInstance1,
    PFILTER_NODE_INSTANCE pFilterNodeInstance2
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PDATARANGES pDataRangesIn = NULL;
    PKSDATARANGE pDataFormatOut = NULL;

    Assert(pPinNode1);
    Assert(pPinNode2);
    Assert(pFilterNodeInstance1);
    Assert(pFilterNodeInstance2);

    Status = GetPinPropertyEx(
      pFilterNodeInstance2->pFileObject,
      KSPROPERTY_PIN_CONSTRAINEDDATARANGES,
      pPinNode2->pPinInfo->PinId,
      (PVOID*)&pDataRangesIn);

    if(!NT_SUCCESS(Status)) {
        goto exit;
    }

    if(pDataRangesIn == NULL) {
        Status = GetPinPropertyEx(
          pFilterNodeInstance2->pFileObject,
          KSPROPERTY_PIN_DATARANGES,
          pPinNode2->pPinInfo->PinId,
          (PVOID*)&pDataRangesIn);

        if(!NT_SUCCESS(Status)) {
            goto exit;
        }
    }

    if(pDataRangesIn == NULL ||
       pDataRangesIn->MultipleItem.Count == 0 ||
       pDataRangesIn->MultipleItem.Size < sizeof(KSDATARANGE)) {
        Trap();
        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto exit;
    }

    Status = GetPinProperty2(
      pFilterNodeInstance1->pFileObject,
      KSPROPERTY_PIN_DATAINTERSECTION,
      pPinNode1->pPinInfo->PinId,
      pDataRangesIn->MultipleItem.Size,
      pDataRangesIn,
      (PVOID*)&pDataFormatOut);

    if(!NT_SUCCESS(Status)) {
        goto exit;
    }

    if(pDataFormatOut == NULL) {
        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto exit;
    }

    *ppPinConnect = (PKSPIN_CONNECT)
      new BYTE[sizeof(KSPIN_CONNECT) + pDataFormatOut->FormatSize];

    if(*ppPinConnect == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }
    if(pDataFormatOut->SampleSize == 0) {
        PWAVEFORMATEX pWaveFormatEx = 
            GetWaveFormatExFromKsDataFormat(pDataFormatOut, NULL);

        if (NULL != pWaveFormatEx) {
            pDataFormatOut->SampleSize = pWaveFormatEx->nBlockAlign;
        }
    }
    memcpy((*ppPinConnect) + 1, pDataFormatOut, pDataFormatOut->FormatSize);

    DPF2(90, "CreatePinIntersection SUCCESS: 1 #%d %s",
      pPinNode1->pPinInfo->PinId,
      pFilterNodeInstance1->pFilterNode->DumpName());

    DPF2(90, "CreatePinIntersection: 2 #%d %s",
      pPinNode2->pPinInfo->PinId,
      pFilterNodeInstance2->pFilterNode->DumpName());
exit:
    delete pDataRangesIn;
    delete pDataFormatOut;
    if(!NT_SUCCESS(Status)) {
        DPF3(90, "CreatePinIntersection FAIL %08x: 1 #%d %s",
          Status,
          pPinNode1->pPinInfo->PinId,
          pFilterNodeInstance1->pFilterNode->DumpName());

        DPF2(90, "CreatePinIntersection: 2 #%d %s",
          pPinNode2->pPinInfo->PinId,
          pFilterNodeInstance2->pFilterNode->DumpName());
    }
    return(Status);
}

NTSTATUS
CreateWaveFormatEx(
    PKSPIN_CONNECT *ppPinConnect,
    PCONNECT_NODE pConnectNode,
    PWAVEFORMATEX pWaveFormatExLimit
)
{
    KSDATARANGE_AUDIO DataRangeAudioIntersection;
    PKSDATARANGE_AUDIO pDataRangeAudioSource;
    PKSDATARANGE_AUDIO pDataRangeAudioSink;
    NTSTATUS Status = STATUS_SUCCESS;

    Assert(pConnectNode);
    Assert(pConnectNode->pPinNodeSource);
    Assert(pConnectNode->pPinNodeSink);
    ASSERT(*ppPinConnect == NULL);

    //
    // For the WaveFormatEx specifier both source and sink pinnode's
    // DataRanges need to be used to generated the PinConnect structure
    //
    pDataRangeAudioSource =
      (PKSDATARANGE_AUDIO)pConnectNode->pPinNodeSource->pDataRange;

    pDataRangeAudioSink =
      (PKSDATARANGE_AUDIO)pConnectNode->pPinNodeSink->pDataRange;

    if(!DataIntersectionRange(
      &pDataRangeAudioSink->DataRange,
      &pDataRangeAudioSource->DataRange,
      &DataRangeAudioIntersection.DataRange) ||
       !DataIntersectionAudio(
      pDataRangeAudioSink,
      pDataRangeAudioSource,
      &DataRangeAudioIntersection)) {
        Trap();
        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto exit;
    }

    //
    // Limit the playback/record format
    //
    if(pConnectNode->IsLimitFormat()) {

        if(!LimitAudioRangeToWave(
          pWaveFormatExLimit,
          &DataRangeAudioIntersection)) {
            DPF(20, "CreateWaveFormatEx: LimitAudioRangeToWave FAILED");
            Status = STATUS_INVALID_DEVICE_REQUEST;
            goto exit;
        }
        DPF6(20,"CreateWaveFormatEx: SR %d CH %d BPS %d | SR %d CH %d BPS %d",
          pWaveFormatExLimit->nSamplesPerSec,
          pWaveFormatExLimit->nChannels,
          pWaveFormatExLimit->wBitsPerSample,
          DataRangeAudioIntersection.MaximumSampleFrequency,
          DataRangeAudioIntersection.MaximumChannels,
          DataRangeAudioIntersection.MaximumBitsPerSample);
    }

    if(IsEqualGUID(
      &DataRangeAudioIntersection.DataRange.Specifier,
      &KSDATAFORMAT_SPECIFIER_WAVEFORMATEX)) {
        PKSDATAFORMAT_WAVEFORMATEX pDataFormatWaveFormatEx;
        ULONG RegionAllocSize;

        if (pWaveFormatExLimit->wFormatTag == WAVE_FORMAT_PCM) {
            RegionAllocSize = sizeof(KSDATAFORMAT_WAVEFORMATEX);
        }
        else {
            RegionAllocSize = sizeof(KSDATAFORMAT_WAVEFORMATEX) + pWaveFormatExLimit->cbSize;
        }

        *ppPinConnect = (PKSPIN_CONNECT)
            new BYTE[sizeof(KSPIN_CONNECT) + RegionAllocSize];

        if(*ppPinConnect == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto exit;
        }
        pDataFormatWaveFormatEx =
          (PKSDATAFORMAT_WAVEFORMATEX)((*ppPinConnect) + 1);

        WaveFormatFromAudioRange(
          &DataRangeAudioIntersection,
          &pDataFormatWaveFormatEx->WaveFormatEx);

        if (pWaveFormatExLimit) {
            //
            // If we are trying the Client's data Format
            //
            if (pWaveFormatExLimit->wFormatTag != WAVE_FORMAT_PCM) {
                ULONG CopySize;
                //
                // and if it is extensible format
                //   Set the Extensible related fields in the WaveformatEx
                //   structure we are building as part of PinConnect
                //

                //
                // cast both pointers to Waveformat extensible equivalents
                //
                pDataFormatWaveFormatEx =
                    (PKSDATAFORMAT_WAVEFORMATEX)((*ppPinConnect) + 1);

                pDataFormatWaveFormatEx->WaveFormatEx.wFormatTag = pWaveFormatExLimit->wFormatTag;
                pDataFormatWaveFormatEx->WaveFormatEx.cbSize = pWaveFormatExLimit->cbSize;
                CopySize = pWaveFormatExLimit->cbSize;

                if (CopySize) {
                    PWAVEFORMATEX pWaveFormatExDest;
                    pWaveFormatExDest = &pDataFormatWaveFormatEx->WaveFormatEx;
                    RtlCopyMemory((pWaveFormatExDest+1),
                                  (pWaveFormatExLimit+1),
                                  CopySize);
                }
            }
        }
        pDataFormatWaveFormatEx->DataFormat =
          DataRangeAudioIntersection.DataRange;

        pDataFormatWaveFormatEx->DataFormat.FormatSize =
            sizeof(KSDATAFORMAT_WAVEFORMATEX);

        //
        // If we are dealing extensible format - set the FormatSize to the extensible equivalent
        //
        if (pWaveFormatExLimit) {
            pDataFormatWaveFormatEx->DataFormat.FormatSize = RegionAllocSize;
        }

        pDataFormatWaveFormatEx->DataFormat.SampleSize =
          pDataFormatWaveFormatEx->WaveFormatEx.nBlockAlign;

        DPF3(90, "CreateWaveFormatEx SUCCESS SR %d CH %d BPS %d",
          pDataFormatWaveFormatEx->WaveFormatEx.nSamplesPerSec,
          pDataFormatWaveFormatEx->WaveFormatEx.nChannels,
          pDataFormatWaveFormatEx->WaveFormatEx.wBitsPerSample);
    }
    else {
        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto exit;
    }
exit:
    if(!NT_SUCCESS(Status)) {
        delete *ppPinConnect;
        *ppPinConnect = NULL;

        DPF4(90, "CreateWaveFormatEx FAILED %08x SR %d CH %d BPS %d",
          Status,
          pWaveFormatExLimit->nSamplesPerSec,
          pWaveFormatExLimit->nChannels,
          pWaveFormatExLimit->wBitsPerSample);
    }
    return(Status);
}

VOID
WaveFormatFromAudioRange(
    PKSDATARANGE_AUDIO pDataRangeAudio,
    WAVEFORMATEX *pWaveFormatEx
)
{
    if(IS_VALID_WAVEFORMATEX_GUID(&pDataRangeAudio->DataRange.SubFormat)) {
        pWaveFormatEx->wFormatTag =
          EXTRACT_WAVEFORMATEX_ID(&pDataRangeAudio->DataRange.SubFormat);
    }
    else {
        pWaveFormatEx->wFormatTag = WAVE_FORMAT_UNKNOWN;
    }
    pWaveFormatEx->nChannels = (WORD)pDataRangeAudio->MaximumChannels;
    pWaveFormatEx->nSamplesPerSec = pDataRangeAudio->MaximumSampleFrequency;
    pWaveFormatEx->wBitsPerSample = (WORD)pDataRangeAudio->MaximumBitsPerSample;
    pWaveFormatEx->nBlockAlign =
      (pWaveFormatEx->nChannels * pWaveFormatEx->wBitsPerSample)/8;
    pWaveFormatEx->nAvgBytesPerSec =
      pWaveFormatEx->nSamplesPerSec * pWaveFormatEx->nBlockAlign;
    pWaveFormatEx->cbSize = 0;
}

BOOL
LimitAudioRangeToWave(
    PWAVEFORMATEX pWaveFormatEx,
    PKSDATARANGE_AUDIO pDataRangeAudio
)
{
    PWAVEFORMATEXTENSIBLE pWaveFormatExtensible;

    DPF5(20, "LimitAudioRangeToWave: SR: %d %d CH: %d BPS %d %d",
      pDataRangeAudio->MinimumSampleFrequency,
      pDataRangeAudio->MaximumSampleFrequency,
      pDataRangeAudio->MaximumChannels,
      pDataRangeAudio->MinimumBitsPerSample,
      pDataRangeAudio->MaximumBitsPerSample);

    if(pWaveFormatEx->wFormatTag == WAVE_FORMAT_EXTENSIBLE) {
        pWaveFormatExtensible = (PWAVEFORMATEXTENSIBLE)pWaveFormatEx;
        if (!IsEqualGUID(&pWaveFormatExtensible->SubFormat, &pDataRangeAudio->DataRange.SubFormat)) {
            return(FALSE);
        }
    }
    else { // not WAVE_FORMAT_EXTENSIBLE
        if(IS_VALID_WAVEFORMATEX_GUID(&pDataRangeAudio->DataRange.SubFormat)) {
            if (pWaveFormatEx->wFormatTag !=
                EXTRACT_WAVEFORMATEX_ID(&pDataRangeAudio->DataRange.SubFormat) ) {
                return(FALSE);
            }
        }
    }
    if(pDataRangeAudio->MinimumSampleFrequency <=
       pWaveFormatEx->nSamplesPerSec &&
       pDataRangeAudio->MaximumSampleFrequency >=
       pWaveFormatEx->nSamplesPerSec) {
        pDataRangeAudio->MaximumSampleFrequency = pWaveFormatEx->nSamplesPerSec;
    }
    else {
        return(FALSE);
    }
    if(pDataRangeAudio->MinimumBitsPerSample <=
       pWaveFormatEx->wBitsPerSample &&
       pDataRangeAudio->MaximumBitsPerSample >=
       pWaveFormatEx->wBitsPerSample) {
        pDataRangeAudio->MaximumBitsPerSample = pWaveFormatEx->wBitsPerSample;
    }
    else {
        return(FALSE);
    }
    // Because there is no minimum channel in the data range,
    // take the maximum channel to be what the requestor wants.
    // i.e. don't limit the number of channels.
    if(pDataRangeAudio->MaximumChannels >= pWaveFormatEx->nChannels) {
        pDataRangeAudio->MaximumChannels = pWaveFormatEx->nChannels;
    }
    else {
        return(FALSE);
    }
    return(TRUE);
}

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\sysaudio\cobj.h ===
//---------------------------------------------------------------------------
//
//  Module:   		cobj.h
//
//  Description:	Base class definition
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//

//---------------------------------------------------------------------------
// Constants
//---------------------------------------------------------------------------

#define ENUMFUNC 		NTSTATUS
#define STATUS_CONTINUE 	((NTSTATUS)-2)

//---------------------------------------------------------------------------
// Macros
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Forward Reference Typedefs
//---------------------------------------------------------------------------

typedef class CShingleInstance *PSHINGLE_INSTANCE;
typedef class CFilterNode *PFILTER_NODE;
typedef class CDeviceNode *PDEVICE_NODE;
typedef class CLogicalFilterNode *PLOGICAL_FILTER_NODE;
typedef class CGraphNode *PGRAPH_NODE;
typedef class CGraphPinInfo *PGRAPH_PIN_INFO;
typedef class CStartInfo *PSTART_INFO;
typedef class CStartNode *PSTART_NODE;
typedef class CConnectInfo *PCONNECT_INFO;
typedef class CConnectNode *PCONNECT_NODE;
typedef class CPinInfo *PPIN_INFO;
typedef class CPinNode *PPIN_NODE;
typedef class CTopologyConnection *PTOPOLOGY_CONNECTION;
typedef class CTopologyNode *PTOPOLOGY_NODE;
typedef class CTopologyPin *PTOPOLOGY_PIN;
typedef class CGraphNodeInstance *PGRAPH_NODE_INSTANCE;
typedef class CStartNodeInstance *PSTART_NODE_INSTANCE;
typedef class CConnectNodeInstance *PCONNECT_NODE_INSTANCE;
typedef class CFilterNodeInstance *PFILTER_NODE_INSTANCE;
typedef class CPinNodeInstance *PPIN_NODE_INSTANCE;
typedef class CVirtualNodeData *PVIRTUAL_NODE_DATA;
typedef class CVirtualSourceData *PVIRTUAL_SOURCE_DATA;
typedef class CVirtualSourceLine *PVIRTUAL_SOURCE_LINE;
typedef class CParentInstance *PPARENT_INSTANCE;
typedef class CFilterInstance *PFILTER_INSTANCE;
typedef class CPinInstance *PPIN_INSTANCE;
typedef class CInstance *PINSTANCE;
typedef class CQueueWorkListData *PQUEUE_WORK_LIST_DATA;

//---------------------------------------------------------------------------
// Classes
//---------------------------------------------------------------------------

typedef class CObj
{
public:
private:
} COBJ, *PCOBJ;

//---------------------------------------------------------------------------
//  End of File: cobj.h
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\sysaudio\common.h ===
//---------------------------------------------------------------------------
//
//  Module:   common.h
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     S.Mohanraj
//
//  History:   Date       Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#if DBG

#ifndef DEBUG
#define DEBUG
#endif

#define dprintf DbgPrint

#endif

#ifdef USE_ZONES
#pragma message("USE_ZONES")
#endif

#ifdef DEBUG
#pragma message("DEBUG")
#endif

#if DBG
#pragma message("DBG")
#endif

#include <wchar.h>

extern "C" {

#ifdef USE_ZONES
#include <ntddk.h>
#else
#include <wdm.h>
#endif
#include <windef.h>
#include <winerror.h>

#include <memory.h>
#include <stddef.h>
#include <stdio.h>
#include <limits.h>
#include <stdlib.h>
#include <tchar.h>
#include <conio.h>
#include <string.h>

#define NOBITMAP
#include <mmsystem.h>
#include <mmreg.h>
#undef NOBITMAP
#include <ks.h>
#include <ksmediap.h>
#include <wdmguid.h>
#include <swenum.h>

} // extern "C"

#include "debug.h"
#include "cobj.h"
#include "clist.h"
#include "util.h"
#include "validate.h"
#include "cinstanc.h"

#include "device.h"
#include "pins.h"
#include "filter.h"
#include "property.h"
#include "registry.h"

#include "tc.h"
#include "tp.h"
#include "tn.h"

#include "pn.h"
#include "pi.h"
#include "fni.h"
#include "lfn.h"

#include "gpi.h"
#include "ci.h"
#include "si.h"
#include "cn.h"
#include "sn.h"

#include "pni.h"
#include "cni.h"
#include "sni.h"
#include "gni.h"
#include "gn.h"

#include "shi.h"
#include "fn.h"

#if defined(_M_IA64)
#pragma section("DATA")
#define ALLOC_PAGEABLE_DATA __declspec(allocate("DATA"))
#else
#define ALLOC_PAGEABLE_DATA
#endif

#include "dn.h"

#include "vsl.h"
#include "vnd.h"
#include "vsd.h"

#include "notify.h"
#include "topology.h"
#include "virtual.h"

//---------------------------------------------------------------------------

#define INIT_CODE   	code_seg("INIT", "CODE")
#define INIT_DATA   	data_seg("INITDATA", "DATA")
#define LOCKED_CODE 	code_seg(".text", "CODE")
#define LOCKED_DATA 	data_seg(".data", "DATA")
#define LOCKED_BSS 	bss_seg(".data", "DATA")
#define PAGEABLE_CODE	code_seg("PAGE", "CODE")
#define PAGEABLE_DATA	data_seg("PAGEDATA", "DATA")
#define PAGEABLE_BSS	bss_seg("PAGEDATA", "DATA")

#if !defined(USE_ALLOC_TEXT)
#pragma PAGEABLE_CODE
#pragma PAGEABLE_DATA
#endif

//---------------------------------------------------------------------------
//  End of File: common.h
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\sysaudio\cni.h ===
//---------------------------------------------------------------------------
//
//  Module:   		cni.h
//
//  Description:	Connect Node Instance Class
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Constants and Macros
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Classes
//---------------------------------------------------------------------------

typedef class CConnectNodeInstance : public CListMultiItem
{
    friend class CStartNodeInstance;
private:
    CConnectNodeInstance(
        IN PCONNECT_NODE pConnectNode
    );

    ~CConnectNodeInstance(
    );

public:
    static NTSTATUS 
    Create(
        PSTART_NODE_INSTANCE pStartNodeInstance,
        PDEVICE_NODE pDeviceNode
    );

    VOID
    AddRef(
    )
    {
        Assert(this);
        ++cReference;
    };

    NTSTATUS
    AddListEnd(
        PCLIST_MULTI plm
    );

    ENUMFUNC
    Destroy(
    );

    BOOL
    IsTopDown(
    )
    {
        Assert(this);
        return(pConnectNode->IsTopDown());
    };

    NTSTATUS
    Connect(
        IN PWAVEFORMATEX pWaveFormatEx,
        IN PKSPIN_CONNECT pPinConnectDirect
    );

    NTSTATUS
    SetStateTopDown(
        KSSTATE NewState,
        KSSTATE PreviousState,
        ULONG ulFlags
    );

    NTSTATUS 
    SetStateBottomUp(
        KSSTATE NewState,
        KSSTATE PreviousState,
        ULONG ulFlags
    );

private:
    BOOL fRender;
    LONG cReference;
    PCONNECT_NODE pConnectNode;
    PFILTER_NODE_INSTANCE pFilterNodeInstanceSource;
    PFILTER_NODE_INSTANCE pFilterNodeInstanceSink;
    PPIN_NODE_INSTANCE pPinNodeInstanceSource;
    PPIN_NODE_INSTANCE pPinNodeInstanceSink;
public:
    DefineSignature(0x20494E43);		// CNI

} CONNECT_NODE_INSTANCE, *PCONNECT_NODE_INSTANCE;

//---------------------------------------------------------------------------

typedef ListMultiDestroy<CONNECT_NODE_INSTANCE> LIST_CONNECT_NODE_INSTANCE;
typedef LIST_CONNECT_NODE_INSTANCE *PLIST_CONNECT_NODE_INSTANCE;

//---------------------------------------------------------------------------
// Local prototypes
//---------------------------------------------------------------------------

NTSTATUS
CreatePinConnect(
    PKSPIN_CONNECT *ppPinConnect,
    PCONNECT_NODE pConnectNode,
    PFILTER_NODE_INSTANCE pFilterNodeInstanceSink,
    PFILTER_NODE_INSTANCE pFilterNodeInstanceSource,
    PWAVEFORMATEX pWaveFormatExLimit
);

NTSTATUS
CreatePinIntersection(
    PKSPIN_CONNECT *ppPinConnect,
    PPIN_NODE pPinNode1,
    PPIN_NODE pPinNode2,
    PFILTER_NODE_INSTANCE pFilterNodeInstance1,
    PFILTER_NODE_INSTANCE pFilterNodeInstance2
);

NTSTATUS
CreateWaveFormatEx(
    PKSPIN_CONNECT *ppPinConnect,
    PCONNECT_NODE pConnectNode,
    PWAVEFORMATEX pWaveFormatExLimit
);

VOID 
WaveFormatFromAudioRange(
    PKSDATARANGE_AUDIO pDataRangeAudio,
    WAVEFORMATEX *pWavFormatEx
);

BOOL
LimitAudioRangeToWave(
    PWAVEFORMATEX pWaveFormatEx,
    PKSDATARANGE_AUDIO pDataRangeAudio
);

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\sysaudio\cn.h ===
//---------------------------------------------------------------------------
//
//  Module:   		cn.h
//
//  Description:	connect node classes
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Constants and Macros
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Class
//---------------------------------------------------------------------------

typedef class CConnectNode : public CListMultiItem
{
    friend class CConnectInfo;
private:
    CConnectNode(
	PCONNECT_NODE pConnectNodeNext
    );

    ~CConnectNode(
    );

public:
    static NTSTATUS
    Create(
	PCONNECT_NODE *ppConnectNode,
	PLOGICAL_FILTER_NODE pLogicalFilterNode,
	PCONNECT_NODE pConnectNodeNext,
	PGRAPH_PIN_INFO pGraphPinInfo,
	PPIN_NODE pPinNode1,
	PPIN_NODE pPinNode2,
	ULONG ulFlagsCurrent,
	PGRAPH_NODE pGraphNode
    );

    ENUMFUNC
    Destroy(
    )
    {
	if(this != NULL) {
	    Assert(this);
	    ASSERT(cReference > 0);

	    if(--cReference == 0) {
		delete this;
	    }
	}
	return(STATUS_CONTINUE);
    };

    VOID
    AddRef(
    )
    {
	if(this != NULL) {
	    Assert(this);
	    ++cReference;
	}
    };

    VOID
    AddPinInstance(
    )
    {
	Assert(this);
	pConnectInfo->AddPinInstance();
    };

    VOID
    RemovePinInstance(
    )
    {
	Assert(this);
	pConnectInfo->RemovePinInstance();
    };

    BOOL
    IsPinInstances(
    )
    {
	Assert(this);
	return(pConnectInfo->IsPinInstances());
    };

    BOOL
    IsTopDown(
    )
    {
	Assert(this);
	return(pConnectInfo->IsTopDown());
    };

    BOOL
    IsLimitFormat(
    )
    {
	Assert(this);
	return(pConnectInfo->IsLimitFormat());
    };

    BOOL
    IsReuseFilterInstance(
    )
    {
	Assert(this);
	return(pConnectInfo->IsReuseFilterInstance());
    };

    BOOL
    IsPinInstanceReserved(
    )
    {
	Assert(this);
	return(pConnectInfo->IsPinInstanceReserved());
    };

    PCONNECT_NODE
    GetNextConnectNode(
    )
    {
	Assert(this);
	return(pConnectNodeNext);
    };

    PCONNECT_NODE_INSTANCE
    GetConnectNodeInstance(
    )
    {
	Assert(this);
	return(pConnectInfo->pConnectNodeInstance);
    };

    VOID
    SetConnectNodeInstance(
	PCONNECT_NODE_INSTANCE pConnectNodeInstance
    )
    {
	Assert(this);
	pConnectInfo->pConnectNodeInstance = pConnectNodeInstance;
    };

    PCONNECT_INFO
    GetConnectInfo(
    )
    {
        return(this == NULL ? NULL : this->pConnectInfo);
    };

private:
    LONG cReference;
    PCONNECT_INFO pConnectInfo;
    PCONNECT_NODE pConnectNodeNext;
public:
    PPIN_NODE pPinNodeSource;
    PPIN_NODE pPinNodeSink;
    DefineSignature(0x20204e43);			// CN

} CONNECT_NODE, *PCONNECT_NODE;

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\sysaudio\debug.h ===
//---------------------------------------------------------------------------
//
//  Module:   debug.h
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Constants and Macros
//---------------------------------------------------------------------------

#ifdef DEBUG
#define STR_MODULENAME "sysaudio: "
#endif

#if defined(DEBUG) && defined(_X86_)
#define Trap()	{_asm {_emit 0xcc}}
#else
#define Trap()
#endif

#define AssertAligned(p)    ASSERT((PtrToUlong(p) & 7) == 0)

#define DBG_IOCTL_LOG       105
#define DBG_IOCTL_FAIL      5

#ifdef DEBUG

typedef struct _OBJECT_HEADER {
    union {
        struct {
            LONG PointerCount;
            LONG HandleCount;
        };
        LIST_ENTRY Entry;
    };
    POBJECT_TYPE Type;
    UCHAR NameInfoOffset;
    UCHAR HandleInfoOffset;
    UCHAR QuotaInfoOffset;
    UCHAR Flags;

    union {
        //POBJECT_CREATE_INFORMATION ObjectCreateInfo;
        PVOID QuotaBlockCharged;
    };

    PSECURITY_DESCRIPTOR SecurityDescriptor;

    QUAD Body;
} OBJECT_HEADER, *POBJECT_HEADER;

#define OBJECT_TO_OBJECT_HEADER( o ) \
    CONTAINING_RECORD( (o), OBJECT_HEADER, Body )

extern "C" PEPROCESS KernelProcess;
extern "C" int SYSAUDIOTraceLevel;

#define DPF(n,sz) (n == MAXULONG ? dprintf(sz "\n") : (n <= SYSAUDIOTraceLevel ? DbgPrint(STR_MODULENAME sz "\n") : 0))
#define DPF1(n,sz,a) (n == MAXULONG ? dprintf(sz "\n", a) : (n <= SYSAUDIOTraceLevel ? DbgPrint(STR_MODULENAME sz "\n", a) : 0))
#define DPF2(n,sz,a,b) (n == MAXULONG ? dprintf(sz "\n", a,b) : (n <= SYSAUDIOTraceLevel ? DbgPrint(STR_MODULENAME sz "\n", a,b) : 0))
#define DPF3(n,sz,a,b,c) (n == MAXULONG ? dprintf(sz "\n", a,b,c) : (n <= SYSAUDIOTraceLevel ? DbgPrint(STR_MODULENAME sz "\n", a,b,c) : 0))
#define DPF4(n,sz,a,b,c,d) (n == MAXULONG ? dprintf(sz "\n", a,b,c,d) : (n <= SYSAUDIOTraceLevel ? DbgPrint(STR_MODULENAME sz "\n",a,b,c,d) : 0))
#define DPF5(n,sz,a,b,c,d,e) (n == MAXULONG ? dprintf(sz "\n", a,b,c,d,e) : (n <= SYSAUDIOTraceLevel ? DbgPrint(STR_MODULENAME sz "\n", a,b,c,d,e) : 0))
#define DPF6(n,sz,a,b,c,d,e,f) (n == MAXULONG ? dprintf(sz "\n", a,b,c,d,e,f) : (n <= SYSAUDIOTraceLevel ? DbgPrint(STR_MODULENAME sz "\n", a,b,c,d,e,f) : 0))
#define DPF7(n,sz,a,b,c,d,e,f,g) (n == MAXULONG ? dprintf(sz "\n", a,b,c,d,e,f,g) : (n <= SYSAUDIOTraceLevel ? DbgPrint(STR_MODULENAME sz "\n", a,b,c,d,e,f,g) : 0))
#define DPF8(n,sz,a,b,c,d,e,f,g,h) (n == MAXULONG ? dprintf(sz "\n", a,b,c,d,e,f,g,h) : (n <= SYSAUDIOTraceLevel ? DbgPrint(STR_MODULENAME sz "\n", a,b,c,d,e,f,g,h) : 0))
#define DPF9(n,sz,a,b,c,d,e,f,g,h,i) (n == MAXULONG ? dprintf(sz "\n", a,b,c,d,e,f,g,h,i) : (n <= SYSAUDIOTraceLevel ? DbgPrint(STR_MODULENAME sz "\n",a,b,c,d,e,f,g,h,i) : 0))

#define AssertStatus(f)     ASSERT(f == STATUS_SUCCESS)

#define AssertFileObject(pfo) \
        ASSERT((pfo)->FsContext != NULL); \
        ASSERT(OBJECT_TO_OBJECT_HEADER(pfo)->PointerCount > 0);

// Debug Levels
//
#define DBG_STATE           20

#else 

#define DPF(n,sz)
#define DPF1(n,sz,a)
#define DPF2(n,sz,a,b)
#define DPF3(n,sz,a,b,c)
#define DPF4(n,sz,a,b,c,d)
#define DPF5(n,sz,a,b,c,d,e)
#define DPF6(n,sz,a,b,c,d,e,f)
#define DPF7(n,sz,a,b,c,d,e,f,g)
#define DPF8(n,sz,a,b,c,d,e,f,g,h)
#define DPF9(n,sz,a,b,c,d,e,f,g,h,i)

#define AssertKernelProcess

#define AssertStatus(f)		f

#define AssertFileObject(pfo)

#endif

#ifdef DEBUG
#define Assert(p) \
    (p)->m_Signature.DebugAssert()

#define DefineSignature(s) \
    class CSignature \
    { \
    public: \
    CSignature() \
    { \
       m_dwSignature = s; \
    }; \
    ~CSignature() \
    { \
       m_dwSignature = 0x44414544; \
    }; \
    BOOL IsAssert() \
    { \
        return(m_dwSignature == s); \
    } \
    VOID DebugAssert() \
    { \
        ASSERT(IsAssert()); \
    }; \
    private: \
    ULONG m_dwSignature; \
    } m_Signature;

#define DestroySignature() \
    m_Signature.~CSignature()

#else
#define Assert(p)
#define DefineSignature(s)
#define DestroySignature()
#endif

#ifdef DEBUG

#ifndef _X86_

#define dprintf DbgPrint

#endif // _X86_

#endif // DEBUG

//---------------------------------------------------------------------------
//  End of File: debug.h
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\sysaudio\device.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   device.c
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     S.Mohanraj
//
//  History:   Date	  Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#define IRPMJFUNCDESC
//#define TIME_BOMB

#include "common.h"
#ifdef TIME_BOMB
#include <ksdebug.h>
#include "..\timebomb\timebomb.c"
#endif


//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

PDEVICE_INSTANCE gpDeviceInstance = NULL;

DEFINE_KSCREATE_DISPATCH_TABLE(DeviceCreateItems)
{
    DEFINE_KSCREATE_ITEMNULL(
      CFilterInstance::FilterDispatchCreate,
      NULL),
};

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

#pragma INIT_CODE
#pragma INIT_DATA

NTSTATUS
DriverEntry
(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING usRegistryPathName
)
{
    NTSTATUS Status = STATUS_SUCCESS;

#ifdef TIME_BOMB
    if (HasEvaluationTimeExpired()) {
        return STATUS_EVALUATION_EXPIRATION;
    }
#endif

    KeInitializeMutex(&gMutex, 0);

    // 
    // ISSUE: 02/13/02 ALPERS
    // Why would we acquire the mutex in DriverEntry?
    //
    GrabMutex();

    DriverObject->MajorFunction[IRP_MJ_PNP] = DispatchPnp;
    DriverObject->MajorFunction[IRP_MJ_POWER] = KsDefaultDispatchPower;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = KsDefaultForwardIrp;
    DriverObject->DriverUnload = DriverUnload;
    DriverObject->DriverExtension->AddDevice = AddDevice;

    KsSetMajorFunctionHandler(DriverObject, IRP_MJ_CREATE);
    KsSetMajorFunctionHandler(DriverObject, IRP_MJ_CLOSE);
    KsSetMajorFunctionHandler(DriverObject, IRP_MJ_DEVICE_CONTROL);
    KsSetMajorFunctionHandler(DriverObject, IRP_MJ_WRITE);

    Status = InitializeUtil();
    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }
    Status = InitializeFilterNode();
    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }
    Status = InitializeDeviceNode();
    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }
    Status = InitializeVirtualSourceLine();
    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }
    InitializeListHead(&gEventQueue);
    KeInitializeSpinLock(&gEventLock);
    
exit:
    // 
    // SECURITY NOTE: 
    // The PnP system will not send anymore message if this routine fails. Even
    // DriverUnload will not be called.
    // According to DDK docs DriverEntry should do its own cleanup in case of
    // failures.
    //
    if (!NT_SUCCESS(Status)) {
        UninitializeUtil();
        UninitializeVirtualSourceLine();
        UninitializeDeviceNode();
        UninitializeFilterNode();
        UninitializeMemory();
    }
    
    ReleaseMutex();
    return(Status);
}

#pragma PAGEABLE_CODE
#pragma PAGEABLE_DATA

NTSTATUS
DispatchPnp(
    IN PDEVICE_OBJECT	pDeviceObject,
    IN PIRP		pIrp
)
{
    PIO_STACK_LOCATION pIrpStack;

    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );

    switch(pIrpStack->MinorFunction) {

    case IRP_MN_QUERY_PNP_DEVICE_STATE:
	    //
	    // Mark the device as not disableable.
	    //
	    pIrp->IoStatus.Information |= PNP_DEVICE_NOT_DISABLEABLE;
	    break;

    case IRP_MN_REMOVE_DEVICE:
	    //
	    // We need to unregister the notifications first before killing the
	    // worker threads
	    //
	    UnregisterForPlugPlayNotifications();

	    //
	    // Needs to be outside the mutex because KsUnregisterWorker blocks
	    // until all worker threads are done
	    //
	    UninitializeUtil();

	    GrabMutex();

	    CShingleInstance::UninitializeShingle();
	    UninitializeFilterNode();
	    UninitializeDeviceNode();
	    UninitializeVirtualSourceLine();
	    gpDeviceInstance = NULL;
	    UninitializeMemory();

	    ReleaseMutex();
	    break;
    }

    return(KsDefaultDispatchPnp(pDeviceObject, pIrp));
}

VOID
DriverUnload(
    IN PDRIVER_OBJECT DriverObject
)
{
}

NTSTATUS
AddDevice(
    IN PDRIVER_OBJECT   DriverObject,
    IN PDEVICE_OBJECT   PhysicalDeviceObject
)
/*++

Routine Description:

    When a new device is detected, PnP calls this entry point with the
    new PhysicalDeviceObject (PDO). The driver creates an associated 
    FunctionalDeviceObject (FDO).

Arguments:

    DriverObject -
        Pointer to the driver object.

    PhysicalDeviceObject -
        Pointer to the new physical device object.

Return Values:

    STATUS_SUCCESS or an appropriate error condition.

--*/
{
    PDEVICE_OBJECT      FunctionalDeviceObject = NULL;
    NTSTATUS            Status;
    int i;

    GrabMutex();

    Status = IoCreateDevice(
      DriverObject,
      sizeof(DEVICE_INSTANCE),
      NULL,
      FILE_DEVICE_KS,
      0,
      FALSE,
      &FunctionalDeviceObject);

    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }

    gpDeviceInstance =
      (PDEVICE_INSTANCE)FunctionalDeviceObject->DeviceExtension;
    gpDeviceInstance->pPhysicalDeviceObject = PhysicalDeviceObject;

    Status = KsAllocateDeviceHeader(
      &gpDeviceInstance->pDeviceHeader,
      SIZEOF_ARRAY(DeviceCreateItems),
      (PKSOBJECT_CREATE_ITEM)DeviceCreateItems);
    
    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }

    KsSetDevicePnpAndBaseObject(
      gpDeviceInstance->pDeviceHeader,
      IoAttachDeviceToDeviceStack(FunctionalDeviceObject, PhysicalDeviceObject),
      FunctionalDeviceObject);

    //
    // ISSUE: 05/13/2002 ALPERS
    // StackSize Problem
    // Note that we may still have StackSize problems with deeper objects.
    // The problem will be caught by IO verifier.
    // However in real world, we do not expect any problems because usbaudio
    // driver will never passes-down requests from Sysaudio. In other words,
    // even if DeviceStackSize is deeper than Sysaudio, the IRP will never go
    // down-level from Usbaudio.
    // 

    //
    // Set the StackSize for deeper device stacks.
    // Sysaudio StackSize is normally 2. 
    //      SYSAUDIO - FDO
    //      SWENUM   - PDO
    // 
    // Sysaudio forwards the IRPs to other device stacks which might
    // be deeper than 2. In that case IoVerifier will bugcheck.
    // An example of this is an upper UsbAudio filter driver forwarding
    // IRPs to UsbAudio. 
    // 
    // Setting FDO StackSize to DEFAULT_LARGE_IRP_LOCATIONS 8 (iomgr.h) 
    // guarantees that the IRP comes from large IRP lookaside list in kernel.
    // Thus no memory is wasted. The system has a list of IRPs that it recycles.
    //
    // StackSize 7 will almost guarantee that sysaudio will be deep enough 
    // for any DeviceStack, even with IoVerifier turned on.
    //
    if (FunctionalDeviceObject->StackSize < SYSTEM_LARGE_IRP_LOCATIONS) {
        FunctionalDeviceObject->StackSize = SYSTEM_LARGE_IRP_LOCATIONS;
    }



    Status = RegisterForPlugPlayNotifications();
    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }

    Status = CShingleInstance::InitializeShingle();
    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }
    DeviceCreateItems[0].Context = 
      apShingleInstance[KSPROPERTY_SYSAUDIO_NORMAL_DEFAULT];

    FunctionalDeviceObject->Flags |= DO_DIRECT_IO | DO_POWER_PAGABLE;
    FunctionalDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

exit:
    ReleaseMutex();
    return(Status);
}

//---------------------------------------------------------------------------
//  End of File: device.c
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\sysaudio\dn.h ===
//---------------------------------------------------------------------------
//
//  Module:         dn.h
//
//  Description:    Device Node Class
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date   Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Constants and Macros
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Classes
//---------------------------------------------------------------------------

typedef class CDeviceNode: public CListDoubleItem
{
public:
    CDeviceNode(
    );

    ~CDeviceNode(
    );

    NTSTATUS
    Create(
    PFILTER_NODE pFilterNode
    );

    NTSTATUS
    Update(
    );

    NTSTATUS
    CreateGraphNodes(
    );

    ENUMFUNC
    Destroy()
    {
    Assert(this);
    delete this;
    return(STATUS_CONTINUE);
    };

    NTSTATUS
    GetIndexByDevice(
    OUT PULONG pIndex
    );

    PKSCOMPONENTID
    GetComponentId(
    )
    {
    if (pFilterNode) {
        return(pFilterNode->GetComponentId());
    }
    else {
        return(NULL);
    }
    };

    PWSTR
    GetFriendlyName(
    )
    {
    if (pFilterNode) {
        return(pFilterNode->GetFriendlyName());
    }
    else {
        return(NULL);
    }
    };

    PWSTR
    GetDeviceInterface(
    )
    {
    if (pFilterNode) {
        return(pFilterNode->GetDeviceInterface());
    }
    else {
        return(NULL);
    }
    };

    VOID
    SetPreferredStatus(
        KSPROPERTY_SYSAUDIO_DEFAULT_TYPE DeviceType,
        BOOL Enable
    );

#ifdef DEBUG
    PSZ
    DumpName(
    )
    {
        return(DbgUnicode2Sz(GetFriendlyName()));
    };
#endif

private:
    NTSTATUS
    AddLogicalFilterNode(
    PFILTER_NODE pFilterNode
    );
public:
    PFILTER_NODE pFilterNode;
    LIST_GRAPH_NODE lstGraphNode;
    PSHINGLE_INSTANCE pShingleInstance;
    LIST_FILTER_INSTANCE lstFilterInstance;
    LIST_MULTI_LOGICAL_FILTER_NODE lstLogicalFilterNode;
    PFILTER_NODE pFilterNodeVirtual;

    // Index by virtual source index
    PVIRTUAL_SOURCE_DATA *papVirtualSourceData;
    ULONG cVirtualSourceData;
    DefineSignature(0x20204E4e);        // DN

} DEVICE_NODE, *PDEVICE_NODE;

//---------------------------------------------------------------------------

typedef ListDoubleDestroy<DEVICE_NODE> LIST_DEVICE_NODE, *PLIST_DEVICE_NODE;

//---------------------------------------------------------------------------
// Globals
//---------------------------------------------------------------------------

extern ALLOC_PAGEABLE_DATA PLIST_DEVICE_NODE gplstDeviceNode;

//---------------------------------------------------------------------------
// Local prototypes
//---------------------------------------------------------------------------

#if defined(_M_IA64)
extern "C"
#endif
NTSTATUS
InitializeDeviceNode(
);

VOID
UninitializeDeviceNode(
);

NTSTATUS
GetDeviceByIndex(
    IN  UINT Index,
    OUT PDEVICE_NODE *ppDeviceNode
);

VOID
DestroyAllGraphs(
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\sysaudio\device.h ===
//---------------------------------------------------------------------------
//
//  Module:   		device.h
//
//  Description:	Device Initialization code
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Constants and Macros
//---------------------------------------------------------------------------

//
// (iomgr.h) DEFAULT_LARGE_IRP_LOCATIONS - 1
//
#define SYSTEM_LARGE_IRP_LOCATIONS      7 

//---------------------------------------------------------------------------
// Data Structures
//---------------------------------------------------------------------------

typedef struct device_instance
{
    PVOID pDeviceHeader;
    PDEVICE_OBJECT pPhysicalDeviceObject;
} DEVICE_INSTANCE, *PDEVICE_INSTANCE;

//---------------------------------------------------------------------------
// Globals
//---------------------------------------------------------------------------

extern PDEVICE_INSTANCE gpDeviceInstance;

//---------------------------------------------------------------------------
// Local prototypes
//---------------------------------------------------------------------------

extern "C" {

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT	    DriverObject,
    IN PUNICODE_STRING	    usRegistryPathName
);

NTSTATUS
DispatchPnp(
    IN PDEVICE_OBJECT	pDeviceObject,
    IN PIRP		pIrp
);

VOID
DriverUnload(
    IN PDRIVER_OBJECT DriverObject
);

NTSTATUS
AddDevice(
    IN PDRIVER_OBJECT   DriverObject,
    IN PDEVICE_OBJECT   PhysicalDeviceObject
);

} // extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\sysaudio\filter.h ===
//---------------------------------------------------------------------------
//
//  Module:   		filter.h
//
//  Description:	KS Filter Instance
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Constants and Macros
//---------------------------------------------------------------------------

// These flags are used in various classes (FI, SHI, GN, GNI, etc)

#define FLAGS_MIXER_TOPOLOGY			0x80000000
#define FLAGS_COMBINE_PINS	        	0x40000000

//---------------------------------------------------------------------------
// Globals
//---------------------------------------------------------------------------

extern LONG glPendingAddDelete;
extern LIST_ENTRY gEventQueue;
extern KSPIN_LOCK gEventLock;
extern KSPROPERTY_VALUES PropertyValuesVolume;

//---------------------------------------------------------------------------
// Structures
//---------------------------------------------------------------------------

typedef class CFilterInstance
{
public:
    ~CFilterInstance();

    static NTSTATUS
    FilterDispatchCreate(
	IN PDEVICE_OBJECT pdo,
	IN PIRP pIrp
    );

    static NTSTATUS
    FilterDispatchClose(
	IN PDEVICE_OBJECT pdo,
	IN PIRP	pIrp
    );

    static NTSTATUS
    FilterDispatchIoControl(
	IN PDEVICE_OBJECT pdo,
	IN PIRP	pIrp
    );

    static NTSTATUS 
    FilterPinInstances(
	IN PIRP	pIrp,
	IN PKSP_PIN pPin,
	OUT PKSPIN_CINSTANCES pCInstances
    );

    static NTSTATUS
    FilterPinPropertyHandler(
	IN PIRP pIrp,
	IN PKSPROPERTY pProperty,
	IN OUT PVOID pvData
    );

    static NTSTATUS
    FilterPinNecessaryInstances(
	IN PIRP pIrp,
	IN PKSP_PIN pPin,
	OUT PULONG pulInstances
    );

    static NTSTATUS
    FilterTopologyHandler(
	IN PIRP Irp,
	IN PKSPROPERTY Property,
	IN OUT PVOID Data
    );

    static NTSTATUS
    FilterPinIntersection(
	IN PIRP     Irp,
	IN PKSP_PIN Pin,
	OUT PVOID   Data
    );

    VOID 
    AddList(CListDouble *pld)
    {
	ldiNext.AddList(pld);
    };

    VOID
    RemoveListCheck()
    {
	ldiNext.RemoveListCheck();
    };

    NTSTATUS
    SetShingleInstance(
	PSHINGLE_INSTANCE pShingleInstance
    );

    NTSTATUS
    SetDeviceNode(
	PDEVICE_NODE pDeviceNode
    );

    PDEVICE_NODE
    GetDeviceNode(
    )
    {
	return(pDeviceNode);
    };

    BOOL
    IsChildInstance(
    )
    {
	return(ParentInstance.IsChildInstance());
    };

    NTSTATUS
    CreateGraph(
    );

    NTSTATUS
    GetGraphNodeInstance(
	OUT PGRAPH_NODE_INSTANCE *ppGraphNodeInstance
    );

private:
    //
    // This pointer to the dispatch table is used in the common
    // dispatch routines  to route the IRP to the appropriate
    // handlers.  This structure is referenced by the device driver
    // with IoGetCurrentIrpStackLocation( pIrp ) -> FsContext
    //
    PVOID pObjectHeader;
    PDEVICE_NODE pDeviceNode;
public:
    PGRAPH_NODE_INSTANCE pGraphNodeInstance;
    PARENT_INSTANCE ParentInstance;
    CLIST_DOUBLE_ITEM ldiNext;
    ULONG ulFlags;
    DefineSignature(0x494C4946);			// FILI

} FILTER_INSTANCE, *PFILTER_INSTANCE;

//---------------------------------------------------------------------------

typedef ListDoubleField<FILTER_INSTANCE> LIST_FILTER_INSTANCE;

//---------------------------------------------------------------------------

typedef ListData<FILTER_INSTANCE> LIST_DATA_FILTER_INSTANCE;
typedef LIST_DATA_FILTER_INSTANCE *PLIST_DATA_FILTER_INSTANCE;

//---------------------------------------------------------------------------
// Globals
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Local prototypes
//---------------------------------------------------------------------------

extern "C" {

NTSTATUS
AddRemoveEventHandler(
    IN PIRP Irp,
    IN PKSEVENTDATA pEventData,
    IN PKSEVENT_ENTRY pEventEntry
);

} // extern "C"

NTSTATUS
GetRelatedGraphNodeInstance(
    IN PIRP pIrp,
    OUT PGRAPH_NODE_INSTANCE *ppGraphNodeInstance
);

NTSTATUS
GetGraphNodeInstance(
    IN PIRP pIrp,
    OUT PGRAPH_NODE_INSTANCE *ppGraphNodeInstance
);

//---------------------------------------------------------------------------

extern "C" {

#ifdef DEBUG

VOID
DumpIoctl(
   PIRP pIrp,
   PSZ pszType,
   LONG lLogLevel
);

#endif

} // extern "C"

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\sysaudio\fn.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   fn.cpp
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date   Author      Comment
//
//  To Do:     Date   Author      Comment
//
//@@END_MSINTERNAL
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"

EXTERN_C VOID KeAttachProcess(PVOID);
EXTERN_C VOID KeDetachProcess(VOID);

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

PLIST_FILTER_NODE gplstFilterNode = NULL;
PLIST_MULTI_LOGICAL_FILTER_NODE gplstLogicalFilterNode = NULL;

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

NTSTATUS
InitializeFilterNode()
{
    if(gplstFilterNode == NULL) {
        gplstFilterNode = new LIST_FILTER_NODE;
        if(gplstFilterNode == NULL) {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }
    }
    if(gplstLogicalFilterNode == NULL) {
        gplstLogicalFilterNode = new LIST_MULTI_LOGICAL_FILTER_NODE;
        if(gplstLogicalFilterNode == NULL) {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }
    }
    return(STATUS_SUCCESS);
}

#pragma PAGEABLE_CODE
#pragma PAGEABLE_DATA

VOID
UninitializeFilterNode()
{
    PFILTER_NODE pFilterNode;

    if (NULL != gplstFilterNode) {
        FOR_EACH_LIST_ITEM_DELETE(gplstFilterNode, pFilterNode) {
            if (pFilterNode->pDeviceNode) {
                pFilterNode->pDeviceNode->pFilterNode=NULL;
            }
            delete pFilterNode;
            DELETE_LIST_ITEM(gplstFilterNode);
        } END_EACH_LIST_ITEM
    }

    delete gplstFilterNode;
    gplstFilterNode = NULL;
    delete gplstLogicalFilterNode;
    gplstLogicalFilterNode = NULL;
}

//---------------------------------------------------------------------------

CFilterNode::CFilterNode(
    ULONG fulType
)
{
    ASSERT(gplstFilterNode != NULL);
    SetType(fulType);
    AddListEnd(gplstFilterNode);
    DPF2(60, "CFilterNode: %08x %s", this, DumpName());
}

CFilterNode::~CFilterNode(
)
{
    PFILTER_NODE pFilterNode;

    Assert(this);
    DPF2(60, "~CFilterNode: %08x %s", this, DumpName());
    RemoveListCheck();
    if (pDeviceNode) {
        pDeviceNode->pFilterNode = NULL;
    }
    if (pFileObject) {
        ::ObDereferenceObject(pFileObject);
        pFileObject = NULL;
    }
    delete pDeviceNode;

    FOR_EACH_LIST_ITEM(gplstFilterNode, pFilterNode) {
        pFilterNode->lstConnectedFilterNode.RemoveList(this);
    } END_EACH_LIST_ITEM

    // Free all other memory
    lstFreeMem.EnumerateList(CListDataItem::Destroy);
}

NTSTATUS
CFilterNode::Create(
    PWSTR pwstrDeviceInterface
)
{
    PFILTER_NODE_INSTANCE pFilterNodeInstance = NULL;
    PKEY_VALUE_FULL_INFORMATION pkvfi = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    HANDLE hkeyDeviceClass = NULL;
    UNICODE_STRING ustrFilterName;
    KSPROPERTY PropertyComponentId;
    KSCOMPONENTID ComponentId;
    ULONG BytesReturned;
    PFILE_OBJECT pFileObject;

    //
    // SECURITY NOTE:
    // pwstrDeviceInterface is either given to us by PNP system or is
    // internal.
    //
    this->pwstrDeviceInterface = new WCHAR[wcslen(pwstrDeviceInterface) + 1];
    if(this->pwstrDeviceInterface == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }
    wcscpy(this->pwstrDeviceInterface, pwstrDeviceInterface);

    Status = lstFreeMem.AddList(this->pwstrDeviceInterface);
    if(!NT_SUCCESS(Status)) {
        Trap();
        delete this->pwstrDeviceInterface;
        goto exit;
    }

    Status = CFilterNodeInstance::Create(&pFilterNodeInstance, this);
    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
    pFileObject = pFilterNodeInstance->pFileObject;

    // Get the filter's friendly name
    RtlInitUnicodeString(&ustrFilterName, this->pwstrDeviceInterface);

    Status = IoOpenDeviceInterfaceRegistryKey(
      &ustrFilterName,
      KEY_READ,
      &hkeyDeviceClass);
    if(!NT_SUCCESS(Status)) {
        goto exit;
    }

    //
    // Note that we do not care if the device has a friendlyname or not.
    // We will simply ignore registry-read failure for the rest of this
    // function.
    //
    Status = QueryRegistryValue(hkeyDeviceClass, L"FriendlyName", &pkvfi);
    if(NT_SUCCESS(Status)) {
        if(pkvfi->Type == REG_SZ && pkvfi->DataLength > 0) {
            Status = lstFreeMem.AddList(pkvfi);
            if(!NT_SUCCESS(Status)) {
                Trap();
                delete pkvfi;
                goto exit;
            }
            pwstrFriendlyName = (PWSTR)(((PUCHAR)pkvfi) + pkvfi->DataOffset);
        }
        else {
            delete pkvfi;
        }
    }

#ifdef DEBUG
    HANDLE hkeySysaudio = NULL;

    Status = OpenRegistryKeyForRead(L"Sysaudio", &hkeySysaudio, hkeyDeviceClass);

    // We do not need these registry keys for retail builds
    if(NT_SUCCESS(Status)) {
        Status = QueryRegistryValue(hkeySysaudio, L"Disabled", &pkvfi);
        if(NT_SUCCESS(Status)) {
            if(pkvfi->Type == REG_DWORD) {
                if(*((PULONG)(((PUCHAR)pkvfi) + pkvfi->DataOffset))) {
                    Status = STATUS_SERVER_DISABLED;
                    delete pkvfi;
                    goto exit;
                }
            }
            delete pkvfi;
        }

        Status = QueryRegistryValue(hkeySysaudio, L"Device", &pkvfi);
        if(NT_SUCCESS(Status)) {
            if(pkvfi->Type == REG_SZ && pkvfi->DataLength > 0) {
                Status = lstFreeMem.AddList(pkvfi);
                if(!NT_SUCCESS(Status)) {
                    Trap();
                    delete pkvfi;
                    goto exit;
                }
                Status = AddDeviceInterfaceMatch(
                  (PWSTR)(((PUCHAR)pkvfi) + pkvfi->DataOffset));

                if(!NT_SUCCESS(Status)) {
                    Trap();
                    delete pkvfi;
                    goto exit;
                }
            }
            else {
                delete pkvfi;
            }
        }

        Status = QueryRegistryValue(hkeySysaudio, L"Order", &pkvfi);
        if(NT_SUCCESS(Status)) {
            if(pkvfi->Type == REG_DWORD) {
                ulOrder = *((PULONG)(((PUCHAR)pkvfi) + pkvfi->DataOffset));
            }
            delete pkvfi;
        }

        Status = QueryRegistryValue(hkeySysaudio, L"Capture", &pkvfi);
        if(NT_SUCCESS(Status)) {
            if(pkvfi->Type == REG_DWORD) {
                if(*((PULONG)(((PUCHAR)pkvfi) + pkvfi->DataOffset))) {
                    ulFlags |= FN_FLAGS_CAPTURE;
                }
                else {
                    ulFlags |= FN_FLAGS_NO_CAPTURE;
                }
            }
            delete pkvfi;
        }

        Status = QueryRegistryValue(hkeySysaudio, L"Render", &pkvfi);
        if(NT_SUCCESS(Status)) {
            if(pkvfi->Type == REG_DWORD) {
                if(*((PULONG)(((PUCHAR)pkvfi) + pkvfi->DataOffset))) {
                    ulFlags |= FN_FLAGS_RENDER;
                }
                else {
                    ulFlags |= FN_FLAGS_NO_RENDER;
                }
            }
            delete pkvfi;
        }
    }
#endif // DEBUG


    // Get the component Id of the filter
    PropertyComponentId.Set = KSPROPSETID_General;
    PropertyComponentId.Id = KSPROPERTY_GENERAL_COMPONENTID;
    PropertyComponentId.Flags = KSPROPERTY_TYPE_GET;

    Status = KsSynchronousIoControlDevice(
      pFileObject,
      KernelMode,
      IOCTL_KS_PROPERTY,
      &PropertyComponentId,
      sizeof(PropertyComponentId),
      &ComponentId,
      sizeof(ComponentId),
      &BytesReturned);

    // Store the component Id
    if (NT_SUCCESS(Status)) {

        ASSERT(BytesReturned >= sizeof(ComponentId));

        this->ComponentId = new KSCOMPONENTID;
        if (this->ComponentId) {

            RtlCopyMemory(this->ComponentId,
                          &ComponentId,
                          sizeof(KSCOMPONENTID));

            Status = lstFreeMem.AddList(this->ComponentId);
            if(!NT_SUCCESS(Status)) {
                delete this->ComponentId;
                this->ComponentId = NULL;
            }
        }
    }
    else {
        this->ComponentId = NULL;
    }

    Status = this->ProfileFilter(pFileObject);
exit:
#ifdef DEBUG
    if(hkeySysaudio != NULL) {
        ZwClose(hkeySysaudio);
    }
#endif
    if(hkeyDeviceClass != NULL) {
        ZwClose(hkeyDeviceClass);
    }
    if (pFilterNodeInstance) {
        pFilterNodeInstance->Destroy();
    }
    return(Status);
}

NTSTATUS
CFilterNode::ProfileFilter(
    PFILE_OBJECT pFileObject
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKSMULTIPLE_ITEM pCategories = NULL;
    PKSMULTIPLE_ITEM pConnections = NULL;
    PKSMULTIPLE_ITEM pNodes = NULL;
    ULONG PinId;
    PPIN_INFO pPinInfo;
    ULONG i;
    KSTOPOLOGY Topology;

    RtlZeroMemory(&Topology, sizeof(Topology));

    // Get the number of pins
    Status = GetPinProperty(
      pFileObject,
      KSPROPERTY_PIN_CTYPES,
      0,			// doesn't matter for ctypes
      sizeof(cPins),
      (PVOID)&cPins);

    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }

    // Get the topology of the filter
    Status = GetProperty(
      pFileObject,
      &KSPROPSETID_Topology,
      KSPROPERTY_TOPOLOGY_CATEGORIES,
      (PVOID*)&pCategories);

    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }

    if(pCategories != NULL) {
        Topology.CategoriesCount = pCategories->Count;
        Topology.Categories = (GUID*)(pCategories + 1);

        ULONG fulType = 0;
        for(i = 0; i < pCategories->Count; i++) {
            GetFilterTypeFromGuid((LPGUID)&Topology.Categories[i], &fulType);
        }
        SetType(fulType);
    }

    Status = GetProperty(
      pFileObject,
      &KSPROPSETID_Topology,
      KSPROPERTY_TOPOLOGY_NODES,
      (PVOID*)&pNodes);

    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }

    if(pNodes != NULL) {
        Status = lstFreeMem.AddList(pNodes);
        if(!NT_SUCCESS(Status)) {
            Trap();
            delete pNodes;
            goto exit;
        }
        Topology.TopologyNodesCount = pNodes->Count;
        Topology.TopologyNodes = (GUID*)(pNodes + 1);
    }

    Status = GetProperty(
      pFileObject,
      &KSPROPSETID_Topology,
      KSPROPERTY_TOPOLOGY_CONNECTIONS,
      (PVOID*)&pConnections);

    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }

    if(pConnections != NULL) {
        Topology.TopologyConnectionsCount = pConnections->Count;
        Topology.TopologyConnections = 
          (PKSTOPOLOGY_CONNECTION)(pConnections + 1);
    }

    // Each pin loop
    for(PinId = 0; PinId < cPins; PinId++) {
        pPinInfo = new PIN_INFO(this, PinId);
        if(pPinInfo == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            Trap();
            goto exit;
        }
        Status = pPinInfo->Create(pFileObject);
        if(!NT_SUCCESS(Status)) {
            goto exit;
        }
    }

    Status = CreateTopology(this, &Topology);
    if(!NT_SUCCESS(Status)) {
        goto exit;
    }

    Status = lstPinInfo.EnumerateList(CPinInfo::CreatePhysicalConnection);
    if(Status == STATUS_CONTINUE) {
        Status = STATUS_SUCCESS;
    }
    else if(!NT_SUCCESS(Status)) {
        goto exit;
    }

    Status = CLogicalFilterNode::CreateAll(this);
    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
exit:
    delete pCategories;
    delete pConnections;
    return(Status);
}

NTSTATUS
CFilterNode::DuplicateForCapture(
)
{
    PLOGICAL_FILTER_NODE pLogicalFilterNode;
    NTSTATUS Status = STATUS_SUCCESS;
    PFILTER_NODE pFilterNode = NULL;

    if(GetType() & FILTER_TYPE_DUP_FOR_CAPTURE) {

        FOR_EACH_LIST_ITEM(&lstLogicalFilterNode, pLogicalFilterNode) {

            if(!pLogicalFilterNode->IsRenderAndCapture()) {
                ASSERT(NT_SUCCESS(Status));
                goto exit;
            }

        } END_EACH_LIST_ITEM

        pFilterNode = new FILTER_NODE(GetType());
        if(pFilterNode == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            Trap();
            goto exit;
        }
        Status = pFilterNode->Create(GetDeviceInterface());
        if(!NT_SUCCESS(Status)) {
            goto exit;
        }
        SetRenderOnly();
        pFilterNode->SetCaptureOnly();
    }
exit:
    if(!NT_SUCCESS(Status)) {
        Trap();
        delete pFilterNode;
    }
    return(Status);
}

BOOL
CFilterNode::IsDeviceInterfaceMatch(
    PDEVICE_NODE pDeviceNode
)
{
    PWSTR pwstr, pwstrDeviceInterface;
    UNICODE_STRING String1, String2;

    Assert(this);
    if(lstwstrDeviceInterfaceMatch.IsLstEmpty()) {
        return(TRUE);
    }
    
    //
    // The +4 for both the strings is to eliminate the \\.\ differences in
    // user mode device interface names & kernel mode device interface names
    //
    pwstrDeviceInterface = pDeviceNode->GetDeviceInterface()+4;
    RtlInitUnicodeString(&String2, pwstrDeviceInterface);
    FOR_EACH_LIST_ITEM(&lstwstrDeviceInterfaceMatch, pwstr) {
        RtlInitUnicodeString(&String1, (pwstr+4));
        if (RtlEqualUnicodeString(&String1, &String2, TRUE)) {
            return(TRUE);
        }
    } END_EACH_LIST_ITEM

    return(FALSE);
}

VOID
CFilterNode::SetType(
    ULONG fulType
)
{
    this->fulType |= fulType;
    //
    // This is because of left overs (type bridge) in the registry
    // that look like aliases.
    //
    if(this->fulType & FILTER_TYPE_TOPOLOGY) {
    this->fulType = (FILTER_TYPE_AUDIO | FILTER_TYPE_TOPOLOGY);
    }
    GetDefaultOrder(this->fulType, &ulOrder);
}

NTSTATUS
CFilterNode::CreatePin(
    PKSPIN_CONNECT pPinConnect,
    ACCESS_MASK Access,
    PHANDLE pHandle
)
{
    NTSTATUS Status;

    //
    // SECURITY NOTE:  
    // ACCESS_MASK must include OBJ_KERNEL_HANDLE. This routine does not run
    // in system process, thus the handle must be protected.
    //
    ::KeAttachProcess(this->pProcess);
    Status = KsCreatePin(this->hFileHandle,
                         pPinConnect,
                         Access | OBJ_KERNEL_HANDLE,
                         pHandle);
    ::KeDetachProcess();
    return(Status);
}

BOOL
CFilterNode::DoesGfxMatch(
    HANDLE hGfx,
    PWSTR pwstrDeviceName,
    ULONG GfxOrder
)
{
    ULONG DeviceCount;
    UNICODE_STRING usInDevice, usfnDevice;
    PWSTR pwstr;

    //
    // SECURITY NOTE:
    // This functions assumes that the pwstrDeviceName will be at least 
    // 4 characters long.
    // This function is only called from notify.cpp and the caller makes sure
    // that this assumption holds.
    //
    RtlInitUnicodeString(&usInDevice, (pwstrDeviceName+4));

    //
    // Skip if it is not a GFX
    //
    DPF1(90, "DoesGfxMatch::         fultype=%x", this->fulType);
    if (!(this->fulType & FILTER_TYPE_GFX)) {
        return(FALSE);
    }

    //
    // If it is a valid handle value, check whether the handle matches
    //
    if (hGfx) {
        if (this->hFileHandle != hGfx) {
            return(FALSE);
        }
    }
    //
    // Skip if the order does not match
    //
    DPF1(90, "DoesGfxMatch::         order=%x", this->ulOrder);
    if (GfxOrder != this->ulOrder) {
        return(FALSE);
    }
    //
    // Skip if the match device list is empty :: should not happen with GFX
    //
    if(lstwstrDeviceInterfaceMatch.IsLstEmpty()) {
        ASSERT(!"GFX with no device to attach to!\n");
        return(FALSE);
    }
    //
    // Check if any of the Match device strings matches the device interface
    // passed in. (In case of GFX we should have only one string though)
    //
    DeviceCount = 0;
    FOR_EACH_LIST_ITEM(&lstwstrDeviceInterfaceMatch, pwstr) {
        ASSERT(DeviceCount == 0);
        RtlInitUnicodeString(&usfnDevice, (pwstr+4));
        DPF1(95, "DoesGfxMatch:: new di = %s)", DbgUnicode2Sz(pwstrDeviceName));
        DPF1(95, "DoesGfxMatch:: old di = %s)", DbgUnicode2Sz(pwstr));
        if (RtlEqualUnicodeString(&usInDevice, &usfnDevice, TRUE)) {
            DPF1(90, "Found a duplicate GFX, pFilterNode = %x", this);
            return(TRUE);
        }
        DeviceCount++;
    } END_EACH_LIST_ITEM
    return (FALSE);
}

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\sysaudio\filter.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   filter.c
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     S.Mohanraj
//
//  History:   Date       Author      Comment
//
//  To Do:     Date       Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

#pragma LOCKED_DATA

LIST_ENTRY gEventQueue;
KSPIN_LOCK gEventLock;
LONG glPendingAddDelete = 0;
BOOL gfFirstEvent = TRUE;

#pragma PAGEABLE_DATA

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

static const WCHAR PinTypeName[] = KSSTRING_Pin ;

DEFINE_KSCREATE_DISPATCH_TABLE(FilterCreateItems)
{
    DEFINE_KSCREATE_ITEM(CPinInstance::PinDispatchCreate, PinTypeName, 0),
};

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

DEFINE_KSDISPATCH_TABLE(
    FilterDispatchTable,
    CFilterInstance::FilterDispatchIoControl,   // Ioctl
    DispatchInvalidDeviceRequest,               // Read
    DispatchInvalidDeviceRequest,               // Write
    DispatchInvalidDeviceRequest,               // Flush
    CFilterInstance::FilterDispatchClose,       // Close
    DispatchInvalidDeviceRequest,               // QuerySecurity
    DispatchInvalidDeviceRequest,               // SetSecurity
    DispatchFastIoDeviceControlFailure,         // FastDeviceIoControl
    DispatchFastReadFailure,                    // FastRead
    DispatchFastWriteFailure                    // FastWrite
);

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

DEFINE_KSPROPERTY_TABLE(FilterPropertyHandlers) {
    DEFINE_KSPROPERTY_ITEM_PIN_CINSTANCES(CFilterInstance::FilterPinInstances),
    DEFINE_KSPROPERTY_ITEM_PIN_DATAINTERSECTION(CFilterInstance::FilterPinIntersection),
    DEFINE_KSPROPERTY_ITEM_PIN_NECESSARYINSTANCES(CFilterInstance::FilterPinNecessaryInstances),
    DEFINE_KSPROPERTY_ITEM_PIN_CTYPES(CFilterInstance::FilterPinPropertyHandler),
    DEFINE_KSPROPERTY_ITEM_PIN_DATAFLOW(CFilterInstance::FilterPinPropertyHandler),
    DEFINE_KSPROPERTY_ITEM_PIN_DATARANGES(CFilterInstance::FilterPinPropertyHandler),
    DEFINE_KSPROPERTY_ITEM_PIN_INTERFACES(CFilterInstance::FilterPinPropertyHandler),
    DEFINE_KSPROPERTY_ITEM_PIN_MEDIUMS(CFilterInstance::FilterPinPropertyHandler),
    DEFINE_KSPROPERTY_ITEM_PIN_COMMUNICATION(CFilterInstance::FilterPinPropertyHandler),
    DEFINE_KSPROPERTY_ITEM_PIN_CATEGORY(CFilterInstance::FilterPinPropertyHandler),
    DEFINE_KSPROPERTY_ITEM_PIN_NAME(CFilterInstance::FilterPinPropertyHandler),
};

DEFINE_KSPROPERTY_TOPOLOGYSET(
    TopologyPropertyHandlers,
    CFilterInstance::FilterTopologyHandler
);

DEFINE_KSPROPERTY_TABLE (SysaudioPropertyHandlers)
{
    DEFINE_KSPROPERTY_ITEM(
        KSPROPERTY_SYSAUDIO_DEVICE_COUNT,
        GetDeviceCount,
        sizeof(KSPROPERTY),
        sizeof(ULONG),
        NULL,
        NULL,
        0,
        NULL,
        NULL,
        0
    ),
    DEFINE_KSPROPERTY_ITEM(
        KSPROPERTY_SYSAUDIO_DEVICE_FRIENDLY_NAME,
        GetFriendlyNameProperty,
        sizeof(KSPROPERTY) + sizeof(ULONG),
        0,
        NULL,
        NULL,
        0,
        NULL,
        NULL,
        0
    ),
    DEFINE_KSPROPERTY_ITEM(
        KSPROPERTY_SYSAUDIO_DEVICE_INSTANCE,
        GetInstanceDevice,
        sizeof(KSPROPERTY),
        sizeof(ULONG),
        SetInstanceDevice,
        NULL,
        0,
        NULL,
        NULL,
        0
    ),
    DEFINE_KSPROPERTY_ITEM(
        KSPROPERTY_SYSAUDIO_DEVICE_DEFAULT,
        NULL,
        sizeof(KSPROPERTY),
        sizeof(ULONG),
        SetDeviceDefault,
        NULL,
        0,
        NULL,
        NULL,
        0
    ),
    DEFINE_KSPROPERTY_ITEM(
        KSPROPERTY_SYSAUDIO_DEVICE_INTERFACE_NAME,
        GetDeviceInterfaceName,
        sizeof(KSPROPERTY) + sizeof(ULONG),
        0,
        NULL,
        NULL,
        0,
        NULL,
        NULL,
        0
    ),
    DEFINE_KSPROPERTY_ITEM(
        KSPROPERTY_SYSAUDIO_SELECT_GRAPH,
        NULL,
        sizeof(SYSAUDIO_SELECT_GRAPH),
        0,
        SelectGraph,
        NULL,
        0,
        NULL,
        NULL,
        0
    ),
    DEFINE_KSPROPERTY_ITEM(
        KSPROPERTY_SYSAUDIO_CREATE_VIRTUAL_SOURCE,
        CreateVirtualSource,
        sizeof(SYSAUDIO_CREATE_VIRTUAL_SOURCE),
        sizeof(ULONG),
        NULL,
        NULL,
        0,
        NULL,
        NULL,
        0
    ),
    DEFINE_KSPROPERTY_ITEM(
        KSPROPERTY_SYSAUDIO_CREATE_VIRTUAL_SOURCE_ONLY,
        CreateVirtualSource,
        sizeof(SYSAUDIO_CREATE_VIRTUAL_SOURCE),
        sizeof(ULONG),
        NULL,
        NULL,
        0,
        NULL,
        NULL,
        0
    ),
    DEFINE_KSPROPERTY_ITEM(
        KSPROPERTY_SYSAUDIO_INSTANCE_INFO,
        NULL,
        sizeof(SYSAUDIO_INSTANCE_INFO),
        0,
        SetInstanceInfo,
        NULL,
        0,
        NULL,
        NULL,
        0
    ),
    DEFINE_KSPROPERTY_ITEM(
        KSPROPERTY_SYSAUDIO_PREFERRED_DEVICE,
        NULL,
        sizeof(SYSAUDIO_PREFERRED_DEVICE),
        sizeof(ULONG),
        SetPreferredDevice,
        NULL,
        0,
        NULL,
        NULL,
        0
    ),
    DEFINE_KSPROPERTY_ITEM(
        KSPROPERTY_SYSAUDIO_COMPONENT_ID,
        GetComponentIdProperty,
        sizeof(KSPROPERTY) + sizeof(ULONG),
        sizeof(KSCOMPONENTID),
        NULL,
        NULL,
        0,
        NULL,
        NULL,
        0
    ),
    DEFINE_KSPROPERTY_ITEM(
        KSPROPERTY_SYSAUDIO_ADDREMOVE_GFX,
        NULL,
        sizeof(KSPROPERTY),
        sizeof(SYSAUDIO_GFX),
        AddRemoveGfx,
        NULL,
        0,
        NULL,
        NULL,
        0
    )
};

//
// ISSUE: 02/12/02
// These properties are obsolete now. Must be removed from ksmedia.h
// 
//KSPROPERTY_SYSAUDIO_ADDREMOVE_LOCK 
//KSPROPERTY_SYSAUDIO_ADDREMOVE_UNLOCK 
//KSPROPERTY_SYSAUDIO_RENDER_PIN_INSTANCES 
//KSPROPERTY_SYSAUDIO_RENDER_CONNECTION_INDEX 
//KSPROPERTY_SYSAUDIO_ALWAYS_CREATE_VIRTUAL_SOURCE
//

KSPROPERTY_STEPPING_LONG SteppingLongVolume[] = {
    (65536/2),              // SteppingDelta
    0,                      // Reserved
    {                       // Bounds
        (-96 * 65536),      // SignedMinimum
        0                   // SignedMaximum
    }
};

KSPROPERTY_MEMBERSLIST MemberListVolume = {
    {                                       // MembersHeader
        KSPROPERTY_MEMBER_STEPPEDRANGES,    // MembersFlags
        sizeof(KSPROPERTY_STEPPING_LONG),   // MembersSize
        SIZEOF_ARRAY(SteppingLongVolume),   // MembersCount
        0                                   // Flags
    },
    SteppingLongVolume                      // Members
};

KSPROPERTY_VALUES PropertyValuesVolume = {
    {                                   // PropTypeSet
        STATIC_KSPROPTYPESETID_General,
            VT_I4,
            0
    },
    1,                                  // MembersListCount
    &MemberListVolume                   // MembersList
};

DEFINE_KSPROPERTY_TABLE (AudioPropertyHandlers)
{
    DEFINE_KSPROPERTY_ITEM(
        KSPROPERTY_AUDIO_VOLUMELEVEL,
        FilterVirtualPropertyHandler,
        sizeof(KSNODEPROPERTY_AUDIO_CHANNEL),
        sizeof(LONG),
        FilterVirtualPropertyHandler,
        &PropertyValuesVolume,
        0,
        NULL,
        (PFNKSHANDLER)FilterVirtualPropertySupportHandler,
        0
    ),
    DEFINE_KSPROPERTY_ITEM(
        KSPROPERTY_AUDIO_MUTE,
        FilterVirtualPropertyHandler,
        sizeof(KSNODEPROPERTY_AUDIO_CHANNEL),
        sizeof(LONG),
        FilterVirtualPropertyHandler,
        NULL,
        0,
        NULL,
        (PFNKSHANDLER)FilterVirtualPropertySupportHandler,
        0
    )
};

DEFINE_KSPROPERTY_SET_TABLE(FilterPropertySet)
{
    DEFINE_KSPROPERTY_SET(
       &KSPROPSETID_Pin,                                // Set
       SIZEOF_ARRAY(FilterPropertyHandlers),            // PropertiesCount
       FilterPropertyHandlers,                          // PropertyItem
       0,                                               // FastIoCount
       NULL                                             // FastIoTable
    ),
    DEFINE_KSPROPERTY_SET(
       &KSPROPSETID_Topology,                           // Set
       SIZEOF_ARRAY(TopologyPropertyHandlers),          // PropertiesCount
       TopologyPropertyHandlers,                        // PropertyItem
       0,                                               // FastIoCount
       NULL                                             // FastIoTable
    ),
    DEFINE_KSPROPERTY_SET(
       &KSPROPSETID_Sysaudio,                           // Set
       SIZEOF_ARRAY(SysaudioPropertyHandlers),          // PropertiesCount
       SysaudioPropertyHandlers,                        // PropertyItem
       0,                                               // FastIoCount
       NULL                                             // FastIoTable
    ),
    DEFINE_KSPROPERTY_SET(
       &KSPROPSETID_Audio,                              // Set
       SIZEOF_ARRAY(AudioPropertyHandlers),             // PropertiesCount
       AudioPropertyHandlers,                           // PropertyItem
       0,                                               // FastIoCount
       NULL                                             // FastIoTable
    )
};

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

DEFINE_KSEVENT_TABLE(SysaudioEventHandlers)
{
    DEFINE_KSEVENT_ITEM(
    KSEVENT_SYSAUDIO_ADDREMOVE_DEVICE,
    sizeof(KSEVENTDATA),
    sizeof(ULONG),
    AddRemoveEventHandler,
    NULL,
    NULL )
};

DEFINE_KSEVENT_SET_TABLE(FilterEvents)
{
    DEFINE_KSEVENT_SET(
    &KSEVENTSETID_Sysaudio,
    SIZEOF_ARRAY(SysaudioEventHandlers),
    SysaudioEventHandlers)
};

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

NTSTATUS
CFilterInstance::FilterDispatchCreate(
    IN PDEVICE_OBJECT pdo,
    IN PIRP pIrp
)
{
    PFILTER_INSTANCE pFilterInstance = NULL;
    PSHINGLE_INSTANCE pShingleInstance;
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION pIrpStack;

    pShingleInstance = (PSHINGLE_INSTANCE)
      KSCREATE_ITEM_IRP_STORAGE(pIrp)->Context;
    Assert(pShingleInstance);
    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);

    Status = KsReferenceSoftwareBusObject(gpDeviceInstance->pDeviceHeader);
    if(!NT_SUCCESS(Status)) {
        pIrp->IoStatus.Status = Status;
        IoCompleteRequest(pIrp, IO_NO_INCREMENT);
        return(Status);
    }

    //
    // ISSUE: 02/13/02 ALPERS
    // It does not make sense to grab the mutex for all these operations.
    // We can probably improve this section of code.
    //
    GrabMutex();

    pFilterInstance = new FILTER_INSTANCE;
    if(pFilterInstance == NULL) {
        KsDereferenceSoftwareBusObject(gpDeviceInstance->pDeviceHeader);
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }

    //
    // Once the FILTER_INSTANCE is created the cleanup will be done in
    // ~CFilterInstance.
    //

    DPF2(100, "FilterDispatchCreate: pFilterInstance: %08x PS %08x",
      pFilterInstance,
      PsGetCurrentProcess());

    Status = KsAllocateObjectHeader(
      &pFilterInstance->pObjectHeader,
      SIZEOF_ARRAY(FilterCreateItems),
      FilterCreateItems,
      pIrp,
      (PKSDISPATCH_TABLE)&FilterDispatchTable);

    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
    pIrpStack->FileObject->FsContext = pFilterInstance; // pointer to instance

    Status = pFilterInstance->SetShingleInstance(pShingleInstance);
    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
exit:
    if(!NT_SUCCESS(Status)) {
        delete pFilterInstance;
    }
    ReleaseMutex();

    pIrp->IoStatus.Status = Status;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);
    return(Status);
}

NTSTATUS
CFilterInstance::FilterDispatchClose(
   IN PDEVICE_OBJECT pdo,
   IN PIRP pIrp
)
{
    PFILTER_INSTANCE pFilterInstance;
    PIO_STACK_LOCATION pIrpStack;

    //
    // ISSUE: 02/13/02 ALPERS
    // It does not make sense to grab the mutex for all these operations.
    // We can probably improve this section of code.
    // What is IoGetCurrentIrpStackLocation doing inside the MUTEX?
    //

    GrabMutex();

    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );
    pFilterInstance = (PFILTER_INSTANCE)pIrpStack->FileObject->FsContext;
    Assert(pFilterInstance);

    pIrpStack->FileObject->FsContext = NULL;
    delete pFilterInstance;

    ReleaseMutex();

    pIrp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}

CFilterInstance::~CFilterInstance(
)
{
    Assert(this);
    RemoveListCheck();
    delete pGraphNodeInstance;
    if(pObjectHeader != NULL) {
        KsFreeObjectHeader(pObjectHeader);
    }
    KsDereferenceSoftwareBusObject(gpDeviceInstance->pDeviceHeader);

    ASSERT(IsChildInstance());
    DPF2(100, "~CFilterInstance: pFilterInstance: %08x PS %08x",
      this,
      PsGetCurrentProcess());
}

NTSTATUS
CFilterInstance::SetShingleInstance(
    PSHINGLE_INSTANCE pShingleInstance
)
{
    PDEVICE_NODE pDeviceNode;
    NTSTATUS Status;

    Assert(this);
    Assert(pShingleInstance);

    ulFlags &= ~(FLAGS_MIXER_TOPOLOGY | FLAGS_COMBINE_PINS);
    ulFlags |=
      pShingleInstance->ulFlags & (FLAGS_MIXER_TOPOLOGY | FLAGS_COMBINE_PINS);

    pDeviceNode = pShingleInstance->GetDeviceNode();

    //
    // Note that all the following routines are ready to handle
    // pDeviceNode == NULL case.
    //

    Status = SetDeviceNode(pDeviceNode);
    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
exit:
    return(Status);
}

NTSTATUS
CFilterInstance::SetDeviceNode(
    PDEVICE_NODE pDeviceNode
)
{
    RemoveListCheck();
    this->pDeviceNode = pDeviceNode;
    if(pDeviceNode != NULL) {
        AddList(&pDeviceNode->lstFilterInstance);
    }
    delete pGraphNodeInstance;
    ASSERT(pGraphNodeInstance == NULL);
    return(CreateGraph());
}

NTSTATUS
CFilterInstance::CreateGraph(
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PGRAPH_NODE pGraphNode;

    ASSERT(pGraphNodeInstance == NULL);
    if(pDeviceNode == NULL) {
        DPF(100, "CFilterInstance::CreateGraph: pDeviceNode == NULL");
        ASSERT(NT_SUCCESS(Status));
        goto exit;
    }

    Status = pDeviceNode->CreateGraphNodes();
    if(!NT_SUCCESS(Status)) {
        DPF(10, "CFilterInstance::CreateGraph: CreateGraphNodes FAILED");
        goto exit;
    }

    //
    // lstGraphNode only has two items. One of the items has 
    // FLAGS_MIXER_TOPOLOGY flag and the other one does not.
    // So the below code will only create on pGraphNodeInstance.
    //
    FOR_EACH_LIST_ITEM(&pDeviceNode->lstGraphNode, pGraphNode) {
        if(((pGraphNode->ulFlags ^ ulFlags) & FLAGS_MIXER_TOPOLOGY) == 0) {

            pGraphNodeInstance = new GRAPH_NODE_INSTANCE(pGraphNode, this);
            if(pGraphNodeInstance == NULL) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto exit;
            }

            Status = pGraphNodeInstance->Create();
            if(!NT_SUCCESS(Status)) {
                goto exit;
            }
            break;
        }

    } END_EACH_LIST_ITEM
exit:
    if(!NT_SUCCESS(Status)) {
       delete pGraphNodeInstance;
       pGraphNodeInstance = NULL;
    }
    return(Status);
}

NTSTATUS
CFilterInstance::FilterDispatchIoControl(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
)
{
    NTSTATUS Status;
    PFILTER_INSTANCE pFilterInstance;
    PIO_STACK_LOCATION pIrpStack;
    PKSIDENTIFIER pKsIdentifier;
    BOOL fIsAllocated;

#ifdef DEBUG
    DumpIoctl(pIrp, "Filter", DBG_IOCTL_LOG);
#endif

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
    fIsAllocated = FALSE;
    pKsIdentifier = NULL;
    
    //
    // If sysaudio is not interested with this IOCTL code then complete the 
    // request.
    //
    if (!IsSysaudioIoctlCode(pIrpStack->Parameters.DeviceIoControl.IoControlCode))
    {
        return KsDefaultDeviceIoCompletion(pDeviceObject, pIrp);
    }

    //
    // Validate input/output buffers. From this point on we can assume 
    // that all parameters are validated and copied to kernel mode.
    // Irp->AssociatedIrp->SystemBuffer should now contain both 
    // input and output buffers.
    //
    Status = ValidateDeviceIoControl(pIrp);
    if (!NT_SUCCESS(Status)) 
    {
        goto exit1;
    }

    GrabMutex();    
    pFilterInstance = (PFILTER_INSTANCE)pIrpStack->FileObject->FsContext;
    if(pFilterInstance == NULL) 
    {
        DPF(5, "FilterDispatchIoControl: FAILED pFilterInstance == NULL");
        Trap();
        Status = STATUS_NO_SUCH_DEVICE;
        goto exit;
    }
    Assert(pFilterInstance);

    //
    // Extract the Identifier from the Irp. Only known error codes will cause a
    // real failure and termination of the function.
    // 
    Status = GetKsIdentifierFromIrp(pIrp, &pKsIdentifier, &fIsAllocated);
    if (!NT_SUCCESS(Status))
    {
        goto exit;
    }

    if (pKsIdentifier && 
        pIrpStack->Parameters.DeviceIoControl.IoControlCode != IOCTL_KS_DISABLE_EVENT)
    {
        //
        // This check allows the actual node or filter return the set's
        // supported, etc. instead of always return only the sets sysaudio
        // supports.
        //
        if (IsIoctlForTopologyNode(
            pIrpStack->Parameters.DeviceIoControl.IoControlCode,
            pKsIdentifier->Flags)) 
        {
            Status = ForwardIrpNode(
                pIrp,
                pKsIdentifier,
                pFilterInstance,
                NULL);
            goto exit2;
        }
    }

    //
    // Handle the request.
    //
    switch (pIrpStack->Parameters.DeviceIoControl.IoControlCode) 
    {
        case IOCTL_KS_PROPERTY:
            Status = KsPropertyHandler(
              pIrp,
              SIZEOF_ARRAY(FilterPropertySet),
              (PKSPROPERTY_SET)FilterPropertySet);

            if(Status != STATUS_NOT_FOUND &&
               Status != STATUS_PROPSET_NOT_FOUND) {
                break;
            }

            // NOTE: ForwardIrpNode releases gMutex
            Status = ForwardIrpNode(
              pIrp,
              pKsIdentifier,
              pFilterInstance,
              NULL);
            goto exit2;

        case IOCTL_KS_ENABLE_EVENT:
            Status = KsEnableEvent(
              pIrp,
              SIZEOF_ARRAY(FilterEvents),
              (PKSEVENT_SET)FilterEvents,
              &gEventQueue,
              KSEVENTS_SPINLOCK,
              &gEventLock);

            if(Status != STATUS_NOT_FOUND &&
               Status != STATUS_PROPSET_NOT_FOUND) {
                break;
            }

            // NOTE: ForwardIrpNode releases gMutex
            Status = ForwardIrpNode(
              pIrp,
              pKsIdentifier,
              pFilterInstance,
              NULL);
            goto exit2;

        case IOCTL_KS_DISABLE_EVENT:
            Status = KsDisableEvent(
              pIrp,
              &gEventQueue,
              KSEVENTS_SPINLOCK,
              &gEventLock);

            if(NT_SUCCESS(Status)) {
                break;
            }
            // Fall through to ForwardIrpNode

        case IOCTL_KS_METHOD:
            // NOTE: ForwardIrpNode releases gMutex
            Status = ForwardIrpNode(
              pIrp,
              pKsIdentifier,
              pFilterInstance,
              NULL);
            goto exit2;
            
        default:
            Status = STATUS_UNSUCCESSFUL;
            ASSERT(FALSE);  // no way to get here
    }
    
exit:
    ReleaseMutex();

exit1:
    pIrp->IoStatus.Status = Status;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

exit2:
    if (fIsAllocated) 
    {
        delete [] pKsIdentifier;
    }

    if (!NT_SUCCESS(Status)) 
    {
        DPF1(10, "FilterDispatchIoControl: Status %08x", Status);
    }
    
    return(Status);
}

NTSTATUS
EnableEventWorker(
    PVOID pReference1,
    PVOID pReference2
)
{
    DecrementAddRemoveCount();
    return(STATUS_SUCCESS);
}

NTSTATUS
AddRemoveEventHandler(
    IN PIRP Irp,
    IN PKSEVENTDATA pEventData,
    IN PKSEVENT_ENTRY pEventEntry
)
{
    NTSTATUS Status = STATUS_SUCCESS;

    ExInterlockedInsertTailList(
      &gEventQueue,
      &pEventEntry->ListEntry,
      &gEventLock);

    if(InterlockedExchange((PLONG)&gfFirstEvent, FALSE)) {
        InterlockedIncrement(&glPendingAddDelete);
        Status = QueueWorkList(EnableEventWorker, NULL, NULL);
    }

    return(Status);
}

NTSTATUS
CFilterInstance::FilterPinPropertyHandler(
    IN PIRP pIrp,
    IN PKSPROPERTY pProperty,
    IN OUT PVOID pData
)
{
    PGRAPH_NODE_INSTANCE pGraphNodeInstance;
    NTSTATUS Status;

    Status = ::GetGraphNodeInstance(pIrp, &pGraphNodeInstance);
    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
    Assert(pGraphNodeInstance);

    if(pProperty->Id == KSPROPERTY_PIN_NAME) {
        PKSP_PIN pPinProperty = (PKSP_PIN)pProperty;

        if(pPinProperty->PinId >= pGraphNodeInstance->cPins) {
            DPF(5, "FilterPinPropertyHandler: PinId >= cPins");
            Status = STATUS_INVALID_PARAMETER;
            goto exit;
        }

        // The only time this isn't going to be NULL is for a virtual source pin
        if(pGraphNodeInstance->paPinDescriptors[pPinProperty->PinId].Name ==
          NULL) {
            PSTART_NODE pStartNode;

            FOR_EACH_LIST_ITEM(
              pGraphNodeInstance->aplstStartNode[pPinProperty->PinId],
              pStartNode) {
                PWSTR pwstrName;

                Assert(pStartNode);
                Assert(pStartNode->pPinNode);
                Assert(pStartNode->pPinNode->pPinInfo);
                pwstrName = pStartNode->pPinNode->pPinInfo->pwstrName;
                if(pwstrName == NULL) {
                    continue;
                }
                Status = PropertyReturnString(
                  pIrp,
                  pwstrName,
                  (wcslen(pwstrName) * sizeof(WCHAR)) + sizeof(UNICODE_NULL),
                  pData);
                goto exit;

            } END_EACH_LIST_ITEM
        }
    }
    Status = KsPinPropertyHandler(
      pIrp,
      pProperty,
      pData,
      pGraphNodeInstance->cPins,
      pGraphNodeInstance->paPinDescriptors);

exit:
    return(Status);
}

NTSTATUS
CFilterInstance::FilterPinInstances(
    IN PIRP pIrp,
    IN PKSP_PIN pPin,
    OUT PKSPIN_CINSTANCES pcInstances
)
{
    PGRAPH_NODE_INSTANCE pGraphNodeInstance;
    NTSTATUS Status;

    Status = ::GetGraphNodeInstance(pIrp, &pGraphNodeInstance);
    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
    
    Assert(pGraphNodeInstance);
    ASSERT(pGraphNodeInstance->pacPinInstances != NULL);

    if(pPin->PinId >= pGraphNodeInstance->cPins) {
        DPF(5, "FilterPinInstances: FAILED PinId invalid");
        Status = STATUS_INVALID_PARAMETER;
        goto exit;
    }
    
    Status = pGraphNodeInstance->GetPinInstances(
        pIrp,
        pPin, 
        pcInstances);

exit:
    return(Status);
}

NTSTATUS
CFilterInstance::FilterPinNecessaryInstances(
    IN PIRP pIrp,
    IN PKSP_PIN pPin,
    OUT PULONG pulInstances
)
{
    PGRAPH_NODE_INSTANCE pGraphNodeInstance;
    NTSTATUS Status;

    Status = ::GetGraphNodeInstance(pIrp, &pGraphNodeInstance);
    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
    Assert(pGraphNodeInstance);

    if(pPin->PinId >= pGraphNodeInstance->cPins) {
        DPF(5, "FilterPinNecessaryInstances: FAILED PinId invalid");
        Status = STATUS_INVALID_PARAMETER;
        goto exit;
    }
    *pulInstances = 0;
    pIrp->IoStatus.Information = sizeof( ULONG );
exit:
    return(Status);
}

NTSTATUS
CFilterInstance::FilterTopologyHandler(
    IN PIRP pIrp,
    IN PKSPROPERTY pProperty,
    IN OUT PVOID pData
)
{
    PGRAPH_NODE_INSTANCE pGraphNodeInstance;
    NTSTATUS Status;

    Status = ::GetGraphNodeInstance(pIrp, &pGraphNodeInstance);
    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
    Assert(pGraphNodeInstance);

    if(pProperty->Id == KSPROPERTY_TOPOLOGY_NAME) {
        PKSP_NODE pNode = (PKSP_NODE)pProperty;

        if(pNode->NodeId >= pGraphNodeInstance->Topology.TopologyNodesCount) {
            Status = STATUS_INVALID_DEVICE_REQUEST;
            goto exit;
        }
        if(pGraphNodeInstance->papTopologyNode[pNode->NodeId]->
          ulRealNodeNumber != MAXULONG) {

            pProperty->Flags |= KSPROPERTY_TYPE_TOPOLOGY;
            Status = STATUS_NOT_FOUND;
            goto exit;
        }
    }

    Status = KsTopologyPropertyHandler(
      pIrp,
      pProperty,
      pData,
      &pGraphNodeInstance->Topology);

    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
exit:
    return(Status);
}

NTSTATUS
CFilterInstance::FilterPinIntersection(
    IN PIRP     pIrp,
    IN PKSP_PIN pPin,
    OUT PVOID   pData
    )
/*++

Routine Description:

    Handles the KSPROPERTY_PIN_DATAINTERSECTION property in the Pin property
    set.  Returns the first acceptable data format given a list of data ranges
    for a specified Pin factory. Actually just calls the Intersection
    Enumeration helper, which then calls the IntersectHandler callback with
    each data range.

Arguments:

    pIrp -
        Device control Irp.

    Pin -
        Specific property request followed by Pin factory identifier, followed
    by a KSMULTIPLE_ITEM structure. This is followed by zero or more data
    range structures.

    Data -
        The place in which to return the data format selected as the first
    intersection between the list of data ranges passed, and the acceptable
    formats.

Return Values:

    returns STATUS_SUCCESS or STATUS_NO_MATCH, else STATUS_INVALID_PARAMETER,
            STATUS_BUFFER_TOO_SMALL, or STATUS_INVALID_BUFFER_SIZE.

--*/
{
    PFILTER_NODE_INSTANCE pFilterNodeInstance = NULL;
    PGRAPH_NODE_INSTANCE pGraphNodeInstance;
    LIST_DATA_FILTER_NODE lstFilterNode;
    PIO_STACK_LOCATION pIrpStack;
    ULONG BytesReturned, PinId;
    PSTART_NODE pStartNode;
    PVOID pBuffer = NULL;
    NTSTATUS Status;

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
    Status = ::GetGraphNodeInstance(pIrp, &pGraphNodeInstance);
    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
    Assert(pGraphNodeInstance);

    //
    // Validate that PinId is valid.
    //
    if(pPin->PinId >= pGraphNodeInstance->cPins) {
        DPF(5, "FilterPinIntersection: FAILED PinId invalid");
        Status = STATUS_INVALID_PARAMETER;
        goto exit;
    }
    PinId = pPin->PinId;

    //
    // Validate KSMULTIPLE_ITEM following the pPin parameter.
    // We make sure that the KSDATARANGE has the correct size.
    //
    Status = SadValidateDataIntersection(pIrp, pPin);
    if (!NT_SUCCESS(Status)) {
        goto exit;
    }

    FOR_EACH_LIST_ITEM(pGraphNodeInstance->aplstStartNode[PinId], pStartNode) {
        PFILTER_NODE pFilterNode;
        PPIN_INFO pPinInfo;

        Assert(pStartNode);
        Assert(pStartNode->pPinNode);

        pPinInfo = pStartNode->pPinNode->pPinInfo;
        Assert(pPinInfo);
        Assert(pPinInfo->pFilterNode);

        if(pPinInfo->pFilterNode->GetType() & FILTER_TYPE_VIRTUAL) {
            continue;
        }

        FOR_EACH_LIST_ITEM(&lstFilterNode, pFilterNode) {
            Assert(pFilterNode);
            if(pFilterNode == pPinInfo->pFilterNode) {
                goto next;
            }
        } END_EACH_LIST_ITEM

        DPF2(100, "FilterPinIntersection: FN %08x %s",
          pPinInfo->pFilterNode,
          pPinInfo->pFilterNode->DumpName());

        Status = lstFilterNode.AddList(pPinInfo->pFilterNode);
        if(!NT_SUCCESS(Status)) {
            Trap();
            goto exit;
        }

        Status = CFilterNodeInstance::Create(
          &pFilterNodeInstance,
          pPinInfo->pFilterNode);

        if(!NT_SUCCESS(Status)) {
            DPF2(10, "FilterPinIntersection CFNI:Create FAILS %08x %s",
              Status,
              pPinInfo->pFilterNode->DumpName());
            goto next;
        }
        pPin->PinId = pPinInfo->PinId;

        AssertFileObject(pFilterNodeInstance->pFileObject);
        Status = KsSynchronousIoControlDevice(
          pFilterNodeInstance->pFileObject,
          KernelMode,
          IOCTL_KS_PROPERTY,
          pPin,
          pIrpStack->Parameters.DeviceIoControl.InputBufferLength,
          pData,
          pIrpStack->Parameters.DeviceIoControl.OutputBufferLength,
          &BytesReturned);

        if(NT_SUCCESS(Status)) {
            #ifdef DEBUG
            ULONG i;
            DPF(95, "FilterPinIntersection enter with:");
            for(i = 0; i < ((PKSMULTIPLE_ITEM)(pPin + 1))->Count; i++) {
                DumpDataRange(
                  95,
                  &(((PKSDATARANGE_AUDIO)
                   (((PKSMULTIPLE_ITEM)(pPin + 1)) + 1))[i]));
            }
            DPF(95, "FilterPinIntersection SUCCESS returns:");
            DumpDataFormat(95, (PKSDATAFORMAT)pData);
            #endif
            pIrp->IoStatus.Information = BytesReturned;
            goto exit;
        }

        if(Status == STATUS_BUFFER_OVERFLOW) {
            pBuffer = new BYTE[BytesReturned];
            if(pBuffer == NULL) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto exit;
            }
            AssertFileObject(pFilterNodeInstance->pFileObject);
            Status = KsSynchronousIoControlDevice(
              pFilterNodeInstance->pFileObject,
              KernelMode,
              IOCTL_KS_PROPERTY,
              pPin,
              pIrpStack->Parameters.DeviceIoControl.InputBufferLength,
              pBuffer,
              BytesReturned,
              &BytesReturned);

            if(NT_SUCCESS(Status)) {
                Status = STATUS_BUFFER_OVERFLOW;
                pIrp->IoStatus.Information = BytesReturned;
                DPF1(100, "FilterPinIntersection: STATUS_BUFFER_OVERFLOW %d",
                  BytesReturned);
                goto exit;
            }
            ASSERT(Status != STATUS_BUFFER_OVERFLOW);
            DPF2(100, "FilterPinIntersection: %08x %d", Status, BytesReturned);
            delete [] pBuffer;
            pBuffer = NULL;
        }

next:
        pFilterNodeInstance->Destroy();
        pFilterNodeInstance = NULL;

    } END_EACH_LIST_ITEM

    DPF(100, "FilterPinIntersection: NOT FOUND");
    Status = STATUS_NOT_FOUND;
exit:
    delete [] pBuffer;
    if (pFilterNodeInstance) {
        pFilterNodeInstance->Destroy();
    }
    return(Status);
}

NTSTATUS
GetRelatedGraphNodeInstance(
    IN PIRP pIrp,
    OUT PGRAPH_NODE_INSTANCE *ppGraphNodeInstance
)
{
    PFILTER_INSTANCE pFilterInstance = 
        (PFILTER_INSTANCE) IoGetCurrentIrpStackLocation(pIrp)->FileObject->
            RelatedFileObject->FsContext;
    if (pFilterInstance)
    {
        return pFilterInstance->GetGraphNodeInstance(ppGraphNodeInstance);
    }

    //
    // SECURITY NOTE:
    // This is in critical code path. Nearly all dispatch functions call this
    // routine.
    // So be a little defensive for cases where FsContext is not valid.
    //
    DPF(5, "GetRelatedGraphNodeInstance : FsContext is NULL");
    return STATUS_UNSUCCESSFUL;
}

NTSTATUS
GetGraphNodeInstance(
    IN PIRP pIrp,
    OUT PGRAPH_NODE_INSTANCE *ppGraphNodeInstance
)
{
    PFILTER_INSTANCE pFilterInstance = 
        (PFILTER_INSTANCE) IoGetCurrentIrpStackLocation(pIrp)->FileObject->
            FsContext;
    if (pFilterInstance)
    {
        return pFilterInstance->GetGraphNodeInstance(ppGraphNodeInstance);
    }

    //
    // SECURITY NOTE:
    // This is in critical code path. Nearly all dispatch functions call this
    // routine.
    // So be a little defensive for cases where FsContext is not valid.
    //
    DPF(5, "GetGraphNodeInstance : FsContext is NULL");
    return STATUS_UNSUCCESSFUL;
}

NTSTATUS
CFilterInstance::GetGraphNodeInstance(
    OUT PGRAPH_NODE_INSTANCE *ppGraphNodeInstance
)
{
    NTSTATUS Status = STATUS_SUCCESS;

    Assert(this);
    if(pGraphNodeInstance == NULL) {
        Status = CreateGraph();
        if(!NT_SUCCESS(Status)) {
            goto exit;
        }
        if(pGraphNodeInstance == NULL) {
            DPF(10, "GetGraphNodeInstance: FAILED pGraphNodeInstance == NULL");
            Status = STATUS_NO_SUCH_DEVICE;
            goto exit;
        }
    }
    
    Assert(pGraphNodeInstance);
    *ppGraphNodeInstance = pGraphNodeInstance;
exit:
    return(Status);
}

//---------------------------------------------------------------------------

#ifdef DEBUG

VOID
DumpIoctl(
   PIRP pIrp,
   PSZ pszType,
   LONG lLogLevel   
)
{
    PIO_STACK_LOCATION pIrpStack;
    PKSPROPERTY pProperty;
    PSZ pszIoctl;

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
    switch(pIrpStack->Parameters.DeviceIoControl.IoControlCode) {
        case IOCTL_KS_PROPERTY:
        pszIoctl = "PROPERTY";
        break;
        case IOCTL_KS_ENABLE_EVENT:
        pszIoctl = "ENABLE_EVENT";
        break;
        case IOCTL_KS_DISABLE_EVENT:
        pszIoctl = "DISABLE_EVENT";
        DPF2(lLogLevel, "%s %s", pszIoctl, pszType);
        return;
        case IOCTL_KS_METHOD:
        pszIoctl = "METHOD";
        break;
    case IOCTL_KS_WRITE_STREAM:
        pszIoctl = "WRITE_STREAM";
        DPF2(lLogLevel, "%s %s", pszIoctl, pszType);
        return;
    case IOCTL_KS_READ_STREAM:
        pszIoctl = "READ_STREAM";
        DPF2(lLogLevel, "%s %s", pszIoctl, pszType);
        return;
    case IOCTL_KS_RESET_STATE:
        pszIoctl = "RESET_STATE";
        DPF2(lLogLevel, "%s %s", pszIoctl, pszType);
        return;
    default:
        DPF2(lLogLevel, "Unknown Ioctl: %s %08x",
          pszType,
          pIrpStack->Parameters.DeviceIoControl.IoControlCode);
        return;
    }
    if(pIrpStack->Parameters.DeviceIoControl.InputBufferLength <
      sizeof(KSPROPERTY)) {
    DPF3(lLogLevel, "InputBufferLength too small: %s %s %08x",
      pszType,
      pszIoctl,
      pIrpStack->Parameters.DeviceIoControl.InputBufferLength);
    return;
    }
    __try {
    if(pIrp->AssociatedIrp.SystemBuffer == NULL) {
        pProperty = (PKSPROPERTY)
          pIrpStack->Parameters.DeviceIoControl.Type3InputBuffer;

        // Validate the pointers if the client is not trusted.
        if(pIrp->RequestorMode != KernelMode) {
        ProbeForRead(
          pProperty,
          pIrpStack->Parameters.DeviceIoControl.InputBufferLength,
          sizeof(BYTE));
        }
    }
    else {
        pProperty =
          (PKSPROPERTY)((PUCHAR)pIrp->AssociatedIrp.SystemBuffer +
          ((pIrpStack->Parameters.DeviceIoControl.OutputBufferLength +
          FILE_QUAD_ALIGNMENT) & ~FILE_QUAD_ALIGNMENT));
    }
    if(pProperty->Flags & KSPROPERTY_TYPE_TOPOLOGY) {
        if(pIrpStack->Parameters.DeviceIoControl.InputBufferLength >=
          sizeof(KSNODEPROPERTY)) {
        DPF5(lLogLevel, "%s %s %s Flags %08x N: %d",
          pszType,
          pszIoctl,
          DbgIdentifier2Sz((PKSIDENTIFIER)pProperty),
          pProperty->Flags,
          ((PKSNODEPROPERTY)pProperty)->NodeId);
        }
    }
    else {
        DPF4(lLogLevel, "%s %s %s Flags %08x",
          pszType,
          pszIoctl,
          DbgIdentifier2Sz((PKSIDENTIFIER)pProperty),
          pProperty->Flags);
    }

    } __except (EXCEPTION_EXECUTE_HANDLER) {
    }
}

#endif

//---------------------------------------------------------------------------
//  End of File: filter.c
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\sysaudio\dn.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   dn.cpp
//
//  Description:
//
//	DeviceNode Class
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//  To Do:     Date	  Author      Comment
//
//@@END_MSINTERNAL
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#if defined(_M_IA64)
#define USE_ALLOC_TEXT
#endif
#include "common.h"

#if defined(ALLOC_PRAGMA) && defined(_M_IA64)
#pragma alloc_text(INIT, InitializeDeviceNode)
#endif

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

ALLOC_PAGEABLE_DATA PLIST_DEVICE_NODE gplstDeviceNode = NULL;

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

#if !defined(_M_IA64)
#pragma INIT_CODE
#endif
#pragma INIT_DATA

NTSTATUS
InitializeDeviceNode(
)
{
    if(gplstDeviceNode == NULL) {
        gplstDeviceNode = new LIST_DEVICE_NODE;
        if(gplstDeviceNode == NULL) {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }
    }
    
    return(STATUS_SUCCESS);
}

#pragma PAGEABLE_CODE
#pragma PAGEABLE_DATA

VOID
UninitializeDeviceNode(
)
{
    delete gplstDeviceNode;
    gplstDeviceNode = NULL;
}

//---------------------------------------------------------------------------

CDeviceNode::CDeviceNode(
)
{
    ASSERT(gplstDeviceNode != NULL);
    AddListEnd(gplstDeviceNode);
    DPF1(50, "CDeviceNode: %08x", this);
}

CDeviceNode::~CDeviceNode(
)
{
    PFILTER_INSTANCE pFilterInstance;
    ULONG i;

    Assert(this);
    RemoveList();
    if (pFilterNode) {
        pFilterNode->pDeviceNode = NULL;
    }

    delete pShingleInstance;

    FOR_EACH_LIST_ITEM_DELETE(&lstFilterInstance, pFilterInstance) {
        ASSERT(pFilterInstance->GetDeviceNode() == this);
        pFilterInstance->SetDeviceNode(NULL);
    } END_EACH_LIST_ITEM

    if(papVirtualSourceData != NULL) {
        for(i = 0; i < cVirtualSourceData; i++) {
            delete papVirtualSourceData[i];
        }
        delete papVirtualSourceData;
    }
    for(i = 0; i < MAX_SYSAUDIO_DEFAULT_TYPE; i++) {
        if(apShingleInstance[i] != NULL) {
            if(apShingleInstance[i]->GetDeviceNode() == this) {
                apShingleInstance[i]->SetDeviceNode(NULL);
            }
        }
    }
    delete pFilterNodeVirtual;
    DPF1(50, "~CFilterNode: %08x", this);
}

NTSTATUS
CDeviceNode::Create(
    PFILTER_NODE pFilterNode
)
{
    NTSTATUS Status = STATUS_SUCCESS;

    Assert(this);
    Assert(pFilterNode);
    this->pFilterNode = pFilterNode;

    Status = Update();
    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
    pShingleInstance = new SHINGLE_INSTANCE(FLAGS_COMBINE_PINS);
    if(pShingleInstance == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }
    Status = pShingleInstance->Create(this, (LPGUID)&KSCATEGORY_AUDIO_DEVICE);
    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
exit:
    return(Status);
}

NTSTATUS
CDeviceNode::Update(
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PFILTER_NODE pFilterNodeNext;
    ULONG i;

    Assert(this);
    Assert(pFilterNode);
    DPF2(50, "CDeviceNode::Update DN %08x %s", this, DumpName());

    //
    // Cleanup all graph structures.
    //
    lstGraphNode.DestroyList();
    lstLogicalFilterNode.DestroyList();
    delete pFilterNodeVirtual;
    pFilterNodeVirtual = NULL;

    //
    // Delete old virtual source lines.
    //
    if(papVirtualSourceData != NULL) {
        for(i = 0; i < cVirtualSourceData; i++) {
            delete papVirtualSourceData[i];
        }
        delete papVirtualSourceData;
        papVirtualSourceData = NULL;
    }

    //
    // Create new virtual source lines.
    //
    if(gcVirtualSources != 0) {
        papVirtualSourceData = new PVIRTUAL_SOURCE_DATA[gcVirtualSources];
        if(papVirtualSourceData == NULL) {
            Trap();
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto exit;
        }
        for(i = 0; i < gcVirtualSources; i++) {
            papVirtualSourceData[i] = new VIRTUAL_SOURCE_DATA(this);
            if(papVirtualSourceData[i] == NULL) {
                Trap();
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto exit;
            }
        }
    }
    cVirtualSourceData = gcVirtualSources;

    Status = AddLogicalFilterNode(pFilterNode);
    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }

    FOR_EACH_LIST_ITEM(&pFilterNode->lstConnectedFilterNode, pFilterNodeNext) {

        Status = AddLogicalFilterNode(pFilterNodeNext);
        if(!NT_SUCCESS(Status)) {
            Trap();
            goto exit;
        }

    } END_EACH_LIST_ITEM

    Status = CreateVirtualMixer(this);
    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }

    if(pShingleInstance != NULL) {
        Status = pShingleInstance->SetDeviceNode(this);
        if(!NT_SUCCESS(Status)) {
            Trap();
            goto exit;
        }
    }
exit:
    return(Status);
}

NTSTATUS
CDeviceNode::AddLogicalFilterNode(
    PFILTER_NODE pFilterNode
)
{
    PLOGICAL_FILTER_NODE pLogicalFilterNode;
    NTSTATUS Status = STATUS_SUCCESS;

    Status = VirtualizeTopology(this, pFilterNode);
    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }
    FOR_EACH_LIST_ITEM(
      &pFilterNode->lstLogicalFilterNode,
      pLogicalFilterNode) {

        DPF2(60, "AddLogicalFilterNode: %08x, DN: %08x",
          pLogicalFilterNode,
          this);

        Status = pLogicalFilterNode->AddList(&lstLogicalFilterNode);
        if(!NT_SUCCESS(Status)) {
            Trap();
            goto exit;
        }
        pLogicalFilterNode->RemoveList(gplstLogicalFilterNode);

    } END_EACH_LIST_ITEM
exit:
    return(Status);
}

NTSTATUS
CDeviceNode::CreateGraphNodes(
)
{
    PGRAPH_NODE pGraphNode, pGraphNodeMixer;
    NTSTATUS Status = STATUS_SUCCESS;

    Assert(this);
    if(lstGraphNode.IsLstEmpty()) {

        pGraphNode = new GRAPH_NODE(this, 0);
        if(pGraphNode == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            Trap();
            goto exit;
        }
        Status = pGraphNode->Create();
        if(!NT_SUCCESS(Status)) {
            Trap();
            goto exit;
        }
        //
        // Create a special GraphNode that points to the same renderer or 
        // capturer, but is marked with the "mixer topology" flag so the
        // pins and topology created for this GraphNode is the virtual mixer
        // topology for the mixer driver.
        //
        pGraphNodeMixer = new GRAPH_NODE(this, FLAGS_MIXER_TOPOLOGY);
        if(pGraphNodeMixer == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            Trap();
            goto exit;
        }
        Status = pGraphNodeMixer->Create();
        if(!NT_SUCCESS(Status)) {
            Trap();
            goto exit;
        }
    }
exit:
    if(!NT_SUCCESS(Status)) {
        Trap();
        lstGraphNode.DestroyList();
    }
    return(Status);
}

NTSTATUS
CDeviceNode::GetIndexByDevice(
    OUT PULONG pIndex
)
{
    NTSTATUS Status = STATUS_INVALID_DEVICE_REQUEST;
    PDEVICE_NODE pDeviceNode;
    UINT iDevice = 0;

    if(this == NULL) {
	ASSERT(Status == STATUS_INVALID_DEVICE_REQUEST);
	goto exit;
    }

    ASSERT(pIndex);

    FOR_EACH_LIST_ITEM(gplstDeviceNode, pDeviceNode) {

        if(pDeviceNode == this) {  // This is the one!
            *pIndex = iDevice;
            Status = STATUS_SUCCESS;
            goto exit;
        }
        iDevice++;

    } END_EACH_LIST_ITEM

    ASSERT(Status == STATUS_INVALID_DEVICE_REQUEST);
exit:
    return(Status);
}

//=============================================================================
// SetPreferredStatus.
// 
// This function is designed to let the drivers know about the preferred
// device changes.
// A usbaudio device can reserve bandwidth based on this property. If it is 
// the preferred device, it will reserve a larger bandwidth.
// 
// As of 02/20/02 (WinXP) there are no drivers implementing this property. 
//
// This code is to support any future changes in external bus class drivers
// related to bus reservation.
//
VOID
CDeviceNode::SetPreferredStatus(
    KSPROPERTY_SYSAUDIO_DEFAULT_TYPE DeviceType,
    BOOL Enable
)
{
    PFILTER_NODE_INSTANCE    pFilterNodeInstance=NULL;
    KSAUDIO_PREFERRED_STATUS PreferredStatus;
    PFILE_OBJECT             pFileObject;
    KSPROPERTY               PreferredStatusProperty;
    NTSTATUS                 Status;
    ULONG                    BytesReturned;

    Status = CFilterNodeInstance::Create(&pFilterNodeInstance, this->pFilterNode);
    if (!NT_SUCCESS(Status)) {
        DPF1(5, "SetPreferredStatus : Create filterinstance failed with status = 0x%08x", Status);
        goto exit;
    }
    pFileObject = pFilterNodeInstance->pFileObject;

    ASSERT(pFileObject);

    //
    // Form the IOCTL packet & send it down
    //
    PreferredStatusProperty.Set = KSPROPSETID_Audio;
    PreferredStatusProperty.Id = KSPROPERTY_AUDIO_PREFERRED_STATUS;
    PreferredStatusProperty.Flags = KSPROPERTY_TYPE_SET;

    PreferredStatus.Enable = Enable;
    PreferredStatus.DeviceType = DeviceType;
    PreferredStatus.Flags = 0;
    PreferredStatus.Reserved = 0;

    DPF(60,"Sending preferred Status to:");
    DPF1(60," FriendlyName = %s", DbgUnicode2Sz(this->pFilterNode->GetFriendlyName()));
    DPF1(60," DI = %s", DbgUnicode2Sz(this->pFilterNode->GetDeviceInterface()));
    DPF1(60," Enable = 0x%08x", Enable);
    DPF1(60," DeviceType = 0x%08x", DeviceType);

    //
    // We actually throw away the status we got back from the device.
    // Even if this failed we will still continue setting the device to be the
    // preferred device
    //
    Status = KsSynchronousIoControlDevice(pFileObject,
                                          KernelMode,
                                          IOCTL_KS_PROPERTY,
                                          &PreferredStatusProperty,
                                          sizeof(PreferredStatusProperty),
                                          &PreferredStatus,
                                          sizeof(PreferredStatus),
                                          &BytesReturned);


exit:
    if (pFilterNodeInstance) {
        pFilterNodeInstance->Destroy();
    }
}


NTSTATUS
GetDeviceByIndex(
    IN  UINT Index,
    OUT PDEVICE_NODE *ppDeviceNode
)
{
    PDEVICE_NODE pDeviceNode;
    NTSTATUS Status;
    UINT iDevice = 0;

    ASSERT(ppDeviceNode);

    FOR_EACH_LIST_ITEM(gplstDeviceNode, pDeviceNode) {

        if(iDevice++ == Index) {	// This is the one!
            *ppDeviceNode = pDeviceNode;
            Status = STATUS_SUCCESS;
            goto exit;
        }

    } END_EACH_LIST_ITEM

    Status = STATUS_INVALID_DEVICE_REQUEST;
exit:
    return(Status);
}

//---------------------------------------------------------------------------

VOID
DestroyAllGraphs(
)
{
    PDEVICE_NODE pDeviceNode;

    DPF(50, "DestroyAllGraphs");

    FOR_EACH_LIST_ITEM(gplstDeviceNode, pDeviceNode) {
        pDeviceNode->lstGraphNode.DestroyList();
    } END_EACH_LIST_ITEM
}

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\sysaudio\fni.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   fni.cpp
//
//  Description:
//
//	Filter Node Instance
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//  To Do:     Date	  Author      Comment
//
//@@END_MSINTERNAL
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

CFilterNodeInstance::~CFilterNodeInstance(
)
{
    Assert(this);
    DPF1(95, "~CFilterNodeInstance: %08x", this);
    RemoveListCheck();
    UnregisterTargetDeviceChangeNotification();
    //
    // if hFilter == NULL && pFileObject != NULL
    //   it means that this filter instance is for a GFX
    //   do not try to dereference the file object in that case
    //
    if( (hFilter != NULL) && (pFileObject != NULL) ) {
        AssertFileObject(pFileObject);
        ObDereferenceObject(pFileObject);
    }
    if(hFilter != NULL) {
        AssertStatus(ZwClose(hFilter));
    }
}

NTSTATUS
CFilterNodeInstance::Create(
    PFILTER_NODE_INSTANCE *ppFilterNodeInstance,
    PLOGICAL_FILTER_NODE pLogicalFilterNode,
    PDEVICE_NODE pDeviceNode,
    BOOL fReuseInstance
)
{
    PFILTER_NODE_INSTANCE pFilterNodeInstance = NULL;
    PLOGICAL_FILTER_NODE pLogicalFilterNode2;
    NTSTATUS Status = STATUS_SUCCESS;

    Assert(pLogicalFilterNode);
    Assert(pLogicalFilterNode->pFilterNode);

    //
    // AEC is a special filter we need both of the logical filters.
    // So AddRef for all FilterNodeInstances of all aec logical filters.
    //
    if(pLogicalFilterNode->GetType() & FILTER_TYPE_AEC) {
        FOR_EACH_LIST_ITEM(
          &pLogicalFilterNode->pFilterNode->lstLogicalFilterNode,
          pLogicalFilterNode2) {

            FOR_EACH_LIST_ITEM(
              &pLogicalFilterNode2->lstFilterNodeInstance,
              pFilterNodeInstance) {

        	pFilterNodeInstance->AddRef();
        	ASSERT(NT_SUCCESS(Status));
        	goto exit;

            } END_EACH_LIST_ITEM

        } END_EACH_LIST_ITEM
    }
    else {
        //
        // For reusable filters find the appropriate FilterNodeInstances and
        // AddRef.
        //
        if(fReuseInstance) {
            FOR_EACH_LIST_ITEM(
              &pLogicalFilterNode->lstFilterNodeInstance,
              pFilterNodeInstance) {

        	if(pDeviceNode == NULL || 
        	   pDeviceNode == pFilterNodeInstance->pDeviceNode) {
        	    pFilterNodeInstance->AddRef();
        	    ASSERT(NT_SUCCESS(Status));
        	    goto exit;
        	}

            } END_EACH_LIST_ITEM
        }
    }

    //
    // Otherwise create a FilterNodeInstance.
    //
    Status = Create(&pFilterNodeInstance, pLogicalFilterNode->pFilterNode);
    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
    pFilterNodeInstance->pDeviceNode = pDeviceNode;
    pFilterNodeInstance->AddList(&pLogicalFilterNode->lstFilterNodeInstance);
exit:
    *ppFilterNodeInstance = pFilterNodeInstance;
    return(Status);
}

NTSTATUS
CFilterNodeInstance::Create(
    PFILTER_NODE_INSTANCE *ppFilterNodeInstance,
    PFILTER_NODE pFilterNode
)
{
    PFILTER_NODE_INSTANCE pFilterNodeInstance = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    Assert(pFilterNode);
    pFilterNodeInstance = new FILTER_NODE_INSTANCE;
    if(pFilterNodeInstance == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }
    pFilterNodeInstance->pFilterNode = pFilterNode;
    pFilterNodeInstance->AddRef();


    if(pFilterNode->GetType() & FILTER_TYPE_GFX) {
        //
        // if it is a GFX do not try to open the device, just re-use
        // the file object which we cached during AddGfx
        //
        pFilterNodeInstance->pFileObject = pFilterNode->GetFileObject();
        pFilterNodeInstance->hFilter = NULL;
        Status = STATUS_SUCCESS;
    }
    else {
        //
        // if it is not a GFX go ahead and open the device.
        //
        Status = pFilterNode->OpenDevice(&pFilterNodeInstance->hFilter);
    }
    if(!NT_SUCCESS(Status)) {
        DPF2(10, "CFilterNodeInstance::Create OpenDevice Failed: %08x FN: %08x",
          Status,
          pFilterNode);
        pFilterNodeInstance->hFilter = NULL;
        goto exit;
    }

    if (pFilterNodeInstance->hFilter) {
        Status = ObReferenceObjectByHandle(
          pFilterNodeInstance->hFilter,
          GENERIC_READ | GENERIC_WRITE,
          NULL,
          KernelMode,
          (PVOID*)&pFilterNodeInstance->pFileObject,
          NULL);
    }

    if(!NT_SUCCESS(Status)) {
        Trap();
        pFilterNodeInstance->pFileObject = NULL;
        goto exit;
    }

    AssertFileObject(pFilterNodeInstance->pFileObject);
    Status = pFilterNodeInstance->RegisterTargetDeviceChangeNotification();
    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
    DPF2(95, "CFilterNodeInstance::Create %08x FN: %08x",
      pFilterNodeInstance,
      pFilterNode);
exit:
    if(!NT_SUCCESS(Status)) {
        if (pFilterNodeInstance) {
            pFilterNodeInstance->Destroy();
        }
        pFilterNodeInstance = NULL;
    }
    *ppFilterNodeInstance = pFilterNodeInstance;
    return(Status);
}

//---------------------------------------------------------------------------

NTSTATUS
CFilterNodeInstance::RegisterTargetDeviceChangeNotification(
)
{
    NTSTATUS Status;

    ASSERT(gpDeviceInstance != NULL);
    ASSERT(gpDeviceInstance->pPhysicalDeviceObject != NULL);
    ASSERT(pNotificationHandle == NULL);

    Status = IoRegisterPlugPlayNotification(
      EventCategoryTargetDeviceChange,
      0,
      pFileObject,
      gpDeviceInstance->pPhysicalDeviceObject->DriverObject,
      (NTSTATUS (*)(PVOID, PVOID))
        CFilterNodeInstance::TargetDeviceChangeNotification,
      this,
      &pNotificationHandle);

    //
    // ISSUE: 02/20/02 ALPERS
    // Can this IoRegisterPlugPlayNotification ever return
    // STATUS_NOT_IMPLEMENTED on XP?
    // This code does not make sense to me...
    //
    if(!NT_SUCCESS(Status)) {
        if(Status != STATUS_NOT_IMPLEMENTED) {
            goto exit;
        }

        // ISSUE: 02/20/02 ALPERS
        // According to Adrian Oney...
        // On Win2K/XP, when a driver passes in a handle 
        // (EventCategoryTargetDeviceChange), PnP tries to find the hardware 
        // backing that handle. It does this by sending a "homing beacon" IRP, 
        // IRP_MN_QUERY_DEVICE_RELATIONS(TargetDeviceRelation). Filesystems 
        // and legacy side-stacks typically forward this to the underlying 
        // WDM stack. The PDO responds by identifying itself as the underlying 
        // hardware. If a filesystem or legacy-stack fails this request 
        // (or a broken WDM stack fails the request), then 
        // STATUS_NOT_IMPLEMENTED would be returned.
        // 
        // Therefore this ASSERT is inserted to see if we ever get 
        // STATUS_NOT_IMPLEMENTED.
        //
         ASSERT(0);
        Status = STATUS_SUCCESS;
    }
    DPF2(100, "RegisterTargetDeviceChangeNotification: FNI: %08x PFO: %08x", 
      this,
      this->pFileObject);
exit:
    return(Status);
}

VOID
CFilterNodeInstance::UnregisterTargetDeviceChangeNotification(
)
{
    HANDLE hNotification;

    DPF1(100, "UnregisterTargetDeviceChangeNotification: FNI: %08x", this);
    hNotification = pNotificationHandle;
    if(hNotification != NULL) {
        pNotificationHandle = NULL;
        IoUnregisterPlugPlayNotification(hNotification);
    }
}   

NTSTATUS
CFilterNodeInstance::DeviceQueryRemove(
)
{
    PGRAPH_NODE_INSTANCE pGraphNodeInstance;
    PDEVICE_NODE pDeviceNode;
    PGRAPH_NODE pGraphNode;

    FOR_EACH_LIST_ITEM(gplstDeviceNode, pDeviceNode) {

        FOR_EACH_LIST_ITEM(&pDeviceNode->lstGraphNode, pGraphNode) {

            FOR_EACH_LIST_ITEM(
              &pGraphNode->lstGraphNodeInstance,
              pGraphNodeInstance) {

               for(ULONG n = 0;
                 n < pGraphNodeInstance->Topology.TopologyNodesCount;
                 n++) {
                    pGraphNodeInstance->
                      papFilterNodeInstanceTopologyTable[n]->Destroy();

                    pGraphNodeInstance->
                      papFilterNodeInstanceTopologyTable[n] = NULL;
               }

            } END_EACH_LIST_ITEM

        } END_EACH_LIST_ITEM

    } END_EACH_LIST_ITEM

    return(STATUS_SUCCESS);
}

NTSTATUS
CFilterNodeInstance::TargetDeviceChangeNotification(
    IN PTARGET_DEVICE_REMOVAL_NOTIFICATION pNotification,
    IN PFILTER_NODE_INSTANCE pFilterNodeInstance
)
{
    DPF3(5, "TargetDeviceChangeNotification: FNI: %08x PFO: %08x %s", 
      pFilterNodeInstance,
      pNotification->FileObject,
      DbgGuid2Sz(&pNotification->Event));

    if(IsEqualGUID(
      &pNotification->Event,
      &GUID_TARGET_DEVICE_REMOVE_COMPLETE) ||
      IsEqualGUID(
      &pNotification->Event,
      &GUID_TARGET_DEVICE_QUERY_REMOVE)) {
        NTSTATUS Status = STATUS_SUCCESS;
        LARGE_INTEGER li = {0, 10000};  // wait for 1 ms

        //
        // ISSUE: 02/20/02 ALPERS
        // It is not clear to me yet what happens if the mutex times out.
        // We will return STATUS_TIMEOUT, then what.
        // Should we veto the removal if we cannot acquire the mutex?s
        //

        Status = KeWaitForMutexObject(
          &gMutex,
          Executive,
          KernelMode,
          FALSE,
          &li);

        if(Status != STATUS_TIMEOUT) {

            DeviceQueryRemove();
            ReleaseMutex();
        }
        else {
            DPF1(5, "TargetDeviceChangeNotification: FAILED %08x", Status);
        }
    }
    return(STATUS_SUCCESS);
}

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\sysaudio\gn.h ===
//---------------------------------------------------------------------------
//
//  Module:   		gn.h
//
//  Description:	graph node classes
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Constants and Macros
//---------------------------------------------------------------------------

#define GN_FLAGS_PLAYBACK   0x00000001
#define GN_FLAGS_RECORD     0x00000002
#define GN_FLAGS_MIDI       0x00000004

//---------------------------------------------------------------------------
// Classes
//---------------------------------------------------------------------------

typedef class CGraphNode : public CListDoubleItem
{
public:
    CGraphNode(
        PDEVICE_NODE pDeviceNode,
        ULONG ulFlags
    );

    ~CGraphNode(
    );

    NTSTATUS
    Create(
    );

    ENUMFUNC
    Destroy(
    )
    {
	Assert(this);
	delete this;
	return(STATUS_CONTINUE);
    };

private:
    NTSTATUS
    Create(
	PLOGICAL_FILTER_NODE pLogicalFilterNode
    );

    NTSTATUS 
    CreateGraph(
	PPIN_NODE pPinNode,
	PCONNECT_NODE pConnectNodePrevious,
	PLOGICAL_FILTER_NODE pLogicalFilterNodePrevious,
	PGRAPH_PIN_INFO pGraphPinInfoPrevious,
	ULONG ulFlagsCurrent,
	ULONG ulOverhead
    );

    NTSTATUS
    CreateGraphToPin(
	PPIN_NODE pPinNode,
	PCONNECT_NODE pConnectNodePrevious,
	PLOGICAL_FILTER_NODE pLogicalFilterNode,
	PGRAPH_PIN_INFO pGraphPinInfo,
	ULONG ulFlagsCurrent,
	ULONG ulOverhead
    );

    NTSTATUS
    CreateGraphFromPin(
	PPIN_NODE pPinNode,
	PPIN_NODE pPinNodeTo,
	PCONNECT_NODE pConnectNode,
	PLOGICAL_FILTER_NODE pLogicalFilterNode,
	PGRAPH_PIN_INFO pGraphPinInfo,
	ULONG ulFlagsCurrent,
	ULONG ulOverhead
    );
public:
    PDEVICE_NODE pDeviceNode;
    LIST_PIN_NODE lstPinNode;
    LIST_START_NODE lstStartNode;
    LIST_START_INFO lstStartInfo;
    LIST_CONNECT_INFO lstConnectInfo;
    LIST_GRAPH_PIN_INFO lstGraphPinInfo;
    LIST_GRAPH_NODE_INSTANCE lstGraphNodeInstance;
    LIST_DESTROY_TOPOLOGY_CONNECTION lstTopologyConnection;
    LIST_MULTI_LOGICAL_FILTER_NODE lstLogicalFilterNode;
    LIST_MULTI_LOGICAL_FILTER_NODE lstLogicalFilterNodeNoBypass;
    ULONG ulFlags;
    DefineSignature(0x20204E47);				// GN

} GRAPH_NODE, *PGRAPH_NODE;

//---------------------------------------------------------------------------

typedef ListDoubleDestroy<GRAPH_NODE> LIST_GRAPH_NODE;

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\sysaudio\fn.h ===
//---------------------------------------------------------------------------
//
//  Module:         fn.h
//
//  Description:    filter node classes
//
//      Filter nodes represent the physical ks filter and along with PinInfo,
//  PinNodes, TopologyNodes, TopologyPins, TopologyConnections objects
//  represent the whole filter.  These objects are built when sysaudio
//  is notified via audio class device interfaces arrivals.
//
//  There is some info read from the registry for each filter.  Various
//  defaults can be overriden:
//
//  Device Parameters/Sysaudio/Disabled     DWORD
//
//      If !0, the filter isn't profiled or used in any graph.
//
//  Device Parameters/Sysaudio/Capture  DWORD
//
//      If !0, puts the filters in the capture side of the graph.  See
//      the FILTER_TYPE_CAPTURE define for the particular default of
//      a filter type.
//
//  Device Parameters/Sysaudio/Render   DWORD
//
//      If !0, puts the filters in the render side of the graph.  See
//      the FILTER_TYPE_RENDER define for the particular default of
//      a filter type.
//
//  Device Parameters/Sysaudio/Order    DWORD
//
//      Overrides the default order in the graph.  See the ORDER_XXXX
//      defines below for the default.
//
//  Device Parameters/Sysaudio/Device   STRING
//
//      The device interface (in the KSCATEGORY_AUDIO class) of the
//      renderer and/or capturer device graph to put this filter.  The
//      default is to put the filter in all device graphs.
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date   Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Constants and Macros
//---------------------------------------------------------------------------

#define OVERHEAD_NONE               0
#define OVERHEAD_LOWEST             1
#define OVERHEAD_LOW                0x00001000
#define OVERHEAD_HARDWARE           0x00010000
#define OVERHEAD_MEDIUM             0x00100000
#define OVERHEAD_SOFTWARE           0x01000000
#define OVERHEAD_HIGH               0x10000000
#define OVERHEAD_HIGHEST            MAXULONG

//---------------------------------------------------------------------------

//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// MAKE SURE THAT NO FILTER ORDER IS ADDED BETWEEN GFX_FIRST & GFX_LAST
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

#define ORDER_NONE                  0
#define ORDER_LOWEST                1
#define ORDER_ENDPOINT              1
#define ORDER_VIRTUAL               0x10000000
#define ORDER_MIC_ARRAY_PROCESSOR   0x15000000
#define ORDER_AEC                   0x40000000
#define ORDER_GFX                   0x50000000
#define ORDER_SPLITTER              0x20000000
#define ORDER_MIXER                 0xA0000000
#define ORDER_SYNTHESIZER           0xB0000000
#define ORDER_DATA_TRANSFORM        0xB0000000
#define ORDER_DRM_DESCRAMBLE        0xB0000000
#define ORDER_INTERFACE_TRANSFORM   0xC0000000
#define ORDER_HIGHEST               MAXULONG

#define ORDER_CAPTURE_GFX_LAST      (ORDER_SPLITTER-1)
#define ORDER_CAPTURE_GFX_FIRST     0x10000001

#define ORDER_RENDER_GFX_LAST       ORDER_GFX
#define ORDER_RENDER_GFX_FIRST      (ORDER_AEC+1)

//---------------------------------------------------------------------------

#define FILTER_TYPE_AUDIO           0x00000001
#define FILTER_TYPE_TOPOLOGY            0x00000002
#define FILTER_TYPE_BRIDGE          0x00000004
#define FILTER_TYPE_RENDERER            0x00000008
#define FILTER_TYPE_CAPTURER            0x00000010
#define FILTER_TYPE_MIXER           0x00000020
#define FILTER_TYPE_GFX             0x00000040
#define FILTER_TYPE_AEC             0x00000080
#define FILTER_TYPE_DATA_TRANSFORM      0x00000100
#define FILTER_TYPE_COMMUNICATION_TRANSFORM 0x00000200
#define FILTER_TYPE_INTERFACE_TRANSFORM     0x00000400
#define FILTER_TYPE_MEDIUM_TRANSFORM        0x00000800
#define FILTER_TYPE_SPLITTER            0x00001000
#define FILTER_TYPE_SYNTHESIZER         0x00002000
#define FILTER_TYPE_DRM_DESCRAMBLE      0x00004000
#define FILTER_TYPE_MIC_ARRAY_PROCESSOR     0x00008000
#define FILTER_TYPE_VIRTUAL         0x00010000

#define FILTER_TYPE_ENDPOINT        (FILTER_TYPE_BRIDGE | \
                     FILTER_TYPE_RENDERER | \
                     FILTER_TYPE_CAPTURER)

#define FILTER_TYPE_LOGICAL_FILTER  (FILTER_TYPE_MIXER | \
                     FILTER_TYPE_GFX | \
                     FILTER_TYPE_AEC | \
                     FILTER_TYPE_DATA_TRANSFORM | \
                     FILTER_TYPE_INTERFACE_TRANSFORM | \
                     FILTER_TYPE_SPLITTER | \
                     FILTER_TYPE_SYNTHESIZER | \
                     FILTER_TYPE_DRM_DESCRAMBLE | \
                     FILTER_TYPE_MIC_ARRAY_PROCESSOR | \
                     FILTER_TYPE_VIRTUAL)

#define FILTER_TYPE_RENDER      (FILTER_TYPE_INTERFACE_TRANSFORM | \
                     FILTER_TYPE_GFX | \
                     FILTER_TYPE_AEC |  \
                     FILTER_TYPE_MIXER | \
                     FILTER_TYPE_SYNTHESIZER | \
                     FILTER_TYPE_DRM_DESCRAMBLE | \
                     FILTER_TYPE_VIRTUAL)

#define FILTER_TYPE_CAPTURE     (FILTER_TYPE_AEC | \
                     FILTER_TYPE_MIC_ARRAY_PROCESSOR | \
                     FILTER_TYPE_MIXER | \
                     FILTER_TYPE_SPLITTER)

#define FILTER_TYPE_PRE_MIXER       (FILTER_TYPE_SYNTHESIZER | \
                     FILTER_TYPE_DRM_DESCRAMBLE | \
                     FILTER_TYPE_INTERFACE_TRANSFORM )

#define FILTER_TYPE_NORMAL_TOPOLOGY (FILTER_TYPE_INTERFACE_TRANSFORM | \
                     FILTER_TYPE_GFX | \
                     FILTER_TYPE_ENDPOINT | \
                     FILTER_TYPE_AEC | \
                     FILTER_TYPE_MIC_ARRAY_PROCESSOR | \
                     FILTER_TYPE_SYNTHESIZER | \
                     FILTER_TYPE_DRM_DESCRAMBLE | \
                     FILTER_TYPE_MIXER | \
                     FILTER_TYPE_SPLITTER)

#define FILTER_TYPE_MIXER_TOPOLOGY  (FILTER_TYPE_VIRTUAL)

#define FILTER_TYPE_NO_BYPASS       (FILTER_TYPE_GFX)

#define FILTER_TYPE_NOT_SELECT      (FILTER_TYPE_AEC | \
                     FILTER_TYPE_MIC_ARRAY_PROCESSOR)

#define FILTER_TYPE_GLOBAL_SELECT   (FILTER_TYPE_AEC)

#define FILTER_TYPE_DUP_FOR_CAPTURE (FILTER_TYPE_MIXER)

//---------------------------------------------------------------------------

#define FN_FLAGS_RENDER         0x00000001
#define FN_FLAGS_NO_RENDER      0x00000002
#define FN_FLAGS_CAPTURE        0x00000004
#define FN_FLAGS_NO_CAPTURE     0x00000008

//---------------------------------------------------------------------------
// Class List Definitions
//---------------------------------------------------------------------------

typedef ListDoubleDestroy<CFilterNode> LIST_FILTER_NODE, *PLIST_FILTER_NODE;

//---------------------------------------------------------------------------

typedef ListData<CFilterNode> LIST_DATA_FILTER_NODE, *PLIST_DATA_FILTER_NODE;

//---------------------------------------------------------------------------

typedef ListDataAssertLess<WCHAR> LIST_WSTR;

//---------------------------------------------------------------------------
// Classes
//---------------------------------------------------------------------------

typedef class CFilterNode : public CListDoubleItem
{
public:
    CFilterNode(
        ULONG fulType
    );

    ~CFilterNode(
    );

    NTSTATUS
    Create(
    PWSTR pwstrDeviceInterface
    );

    NTSTATUS
    ProfileFilter(
	PFILE_OBJECT pFileObject
    );

    NTSTATUS
    DuplicateForCapture(
    );

    ENUMFUNC
    Destroy(
    )
    {
    Assert(this);
    delete this;
    return(STATUS_CONTINUE);
    };

    NTSTATUS
    OpenDevice(
    OUT PHANDLE pHandle
    )
    {
    ASSERT(pwstrDeviceInterface != NULL);
    return(::OpenDevice(pwstrDeviceInterface, pHandle));
    };

    BOOL
    IsDeviceInterfaceMatch(
    PDEVICE_NODE pDeviceNode
    );

    NTSTATUS
    AddDeviceInterfaceMatch(
    PWSTR pwstr
    )
    {
    return(lstwstrDeviceInterfaceMatch.AddList(pwstr));
    };

    ULONG
    GetFlags(
    )
    {
    return(ulFlags);
    };

    VOID
    SetRenderOnly(
    )
    {
    PLOGICAL_FILTER_NODE pLogicalFilterNode;
    FOR_EACH_LIST_ITEM(&lstLogicalFilterNode, pLogicalFilterNode) {
        pLogicalFilterNode->SetRenderOnly();
    } END_EACH_LIST_ITEM
    };

    VOID
    SetCaptureOnly(
    )
    {
    PLOGICAL_FILTER_NODE pLogicalFilterNode;
    FOR_EACH_LIST_ITEM(&lstLogicalFilterNode, pLogicalFilterNode) {
        pLogicalFilterNode->SetCaptureOnly();
    } END_EACH_LIST_ITEM
    };

    ULONG
    GetOrder(
    )
    {
    return(ulOrder);
    };

    VOID
    SetOrder(
    ULONG ulOrder
    )
    {
    PLOGICAL_FILTER_NODE pLogicalFilterNode;
    FOR_EACH_LIST_ITEM(&lstLogicalFilterNode, pLogicalFilterNode) {
        pLogicalFilterNode->SetOrder(ulOrder);
    } END_EACH_LIST_ITEM
    this->ulOrder = ulOrder;
    };

    ULONG
    GetType(
    )
    {
    return(fulType);
    };

    VOID
    SetType(
    ULONG fulType
    );

    VOID
    SetRenderCaptureFlags(
    ULONG fulFlags
    )
    {
        if (fulFlags == GFX_DEVICETYPE_RENDER) {
            ulFlags |= FN_FLAGS_RENDER | FN_FLAGS_NO_CAPTURE;
        } else if (fulFlags == GFX_DEVICETYPE_CAPTURE) {
            ulFlags |= FN_FLAGS_CAPTURE | FN_FLAGS_NO_RENDER;
        }
        else {
            Trap();
        }
    }

    PFILE_OBJECT
    GetFileObject(
    )
    {
        return(pFileObject);
    }

    VOID
    SetFileDetails(
    HANDLE Handle,
    PFILE_OBJECT pFileObject,
    PEPROCESS pProcess
    )
    {
        this->hFileHandle = Handle;
        this->pFileObject = pFileObject;
        this->pProcess = pProcess;
    }

    void
    ClearFileDetails(
    )
    {
        ::ObDereferenceObject(this->pFileObject);
        this->pFileObject = NULL;
        this->hFileHandle = 0;
        this->pProcess = NULL;
    }

    BOOL
    CFilterNode::DoesGfxMatch(
    HANDLE hGfx,
    PWSTR pwstrDeviceName,
    ULONG GfxOrder
    );

    NTSTATUS
    CreatePin(
    PKSPIN_CONNECT pPinConnect,
    ACCESS_MASK Access,
    PHANDLE pHandle
    );

    PKSCOMPONENTID
    GetComponentId(
    )
    {
        return(ComponentId);
    };

    PWSTR
    GetFriendlyName(
    )
    {
    return(pwstrFriendlyName);
    };

    VOID
    SetFriendlyName(
    PWSTR pwstr
    )
    {
    pwstrFriendlyName = pwstr;
    };

    PWSTR
    GetDeviceInterface(
    )
    {
    return(pwstrDeviceInterface);
    };

#ifdef DEBUG
    PSZ DumpName()
    {
    return(DbgUnicode2Sz(pwstrFriendlyName));
    };
#endif
    PDEVICE_NODE pDeviceNode;
    LIST_PIN_INFO lstPinInfo;
    LIST_TOPOLOGY_NODE lstTopologyNode;
    LIST_DESTROY_TOPOLOGY_CONNECTION lstTopologyConnection;
    LIST_DESTROY_LOGICAL_FILTER_NODE lstLogicalFilterNode;
    LIST_DATA_FILTER_NODE lstConnectedFilterNode;
    CLIST_DATA lstFreeMem;          // list of blocks to free
private:
    LIST_WSTR lstwstrDeviceInterfaceMatch;
    PWSTR pwstrDeviceInterface;
    PWSTR pwstrFriendlyName;
    ULONG ulFlags;
    ULONG fulType;
    ULONG ulOrder;
    PKSCOMPONENTID ComponentId;
    PFILE_OBJECT pFileObject;
    HANDLE hFileHandle;
    PEPROCESS pProcess;
public:
    ULONG cPins;
    DefineSignature(0x20204E46);        // FN

} FILTER_NODE, *PFILTER_NODE;

//---------------------------------------------------------------------------
// Inline functions
//---------------------------------------------------------------------------

inline ULONG
CLogicalFilterNode::GetType(
)
{
    return(pFilterNode->GetType());
}

//---------------------------------------------------------------------------
// Globals
//---------------------------------------------------------------------------

extern PLIST_FILTER_NODE gplstFilterNode;

//---------------------------------------------------------------------------
// Local prototypes
//---------------------------------------------------------------------------

NTSTATUS
InitializeFilterNode(
);

VOID
UninitializeFilterNode(
);

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\sysaudio\fni.h ===
//---------------------------------------------------------------------------
//
//  Module:   		fni.h
//
//  Description:	Filter Node Instance Class
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Constants and Macros
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Classes
//---------------------------------------------------------------------------

typedef class CFilterNodeInstance : public CListDoubleItem
{
public:
    ~CFilterNodeInstance(
    );

    static NTSTATUS
    Create(
	PFILTER_NODE_INSTANCE *ppFilterNodeInstance,
	PLOGICAL_FILTER_NODE pLogicalFilterNode,
	PDEVICE_NODE pDeviceNode,
	BOOL fReuseInstance
    );

    static NTSTATUS
    Create(
	PFILTER_NODE_INSTANCE *ppFilterNodeInstance,
	PFILTER_NODE pFilterNode
    );

    VOID 
    AddRef(
    )
    {
	Assert(this);
	++cReference;
    };

    ENUMFUNC 
    Destroy()
    {
	if(this != NULL) {
	    Assert(this);
	    DPF1(95, "CFilterNodeInstance::Destroy: %08x", this);
	    ASSERT(cReference > 0);

	    if(--cReference == 0) {
		delete this;
	    }
	}
	return(STATUS_CONTINUE);
    };

    NTSTATUS
    RegisterTargetDeviceChangeNotification(
    );

    VOID
    UnregisterTargetDeviceChangeNotification(
    );

    static NTSTATUS
    CFilterNodeInstance::DeviceQueryRemove(
    );

    static NTSTATUS
    TargetDeviceChangeNotification(
	IN PTARGET_DEVICE_REMOVAL_NOTIFICATION pNotification,
	IN PFILTER_NODE_INSTANCE pFilterNodeInstance
    );

private:
    LONG cReference;
public:
    PFILTER_NODE pFilterNode;
    PDEVICE_NODE pDeviceNode;
    PFILE_OBJECT pFileObject;
    HANDLE hFilter;
    HANDLE pNotificationHandle;
    DefineSignature(0x20494E46);			// FNI

} FILTER_NODE_INSTANCE, *PFILTER_NODE_INSTANCE;

//---------------------------------------------------------------------------

typedef ListDoubleDestroy<FILTER_NODE_INSTANCE> LIST_FILTER_NODE_INSTANCE;

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\sysaudio\gni.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   gni.cpp
//
//  Description:
//
//	Graph Node Instance
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//  To Do:     Date	  Author      Comment
//
//@@END_MSINTERNAL
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"

//---------------------------------------------------------------------------

GUID aguidSysAudioCategories[] = {
    STATICGUIDOF(KSCATEGORY_SYSAUDIO)
};

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

CGraphNodeInstance::CGraphNodeInstance(
    PGRAPH_NODE pGraphNode,
    PFILTER_INSTANCE pFilterInstance
)
{
    Assert(pGraphNode);
    Assert(pFilterInstance);
    this->pFilterInstance = pFilterInstance;
    this->ulFlags = pFilterInstance->ulFlags;
    this->pGraphNode = pGraphNode;
    AddList(&pGraphNode->lstGraphNodeInstance);
}

CGraphNodeInstance::CGraphNodeInstance(
    PGRAPH_NODE pGraphNode
)
{
    Assert(pGraphNode);
    this->ulFlags = pGraphNode->ulFlags;
    this->pGraphNode = pGraphNode;
    AddList(&pGraphNode->lstGraphNodeInstance);
}

CGraphNodeInstance::~CGraphNodeInstance(
)
{
    Assert(this);
    RemoveList();
    if(pFilterInstance != NULL) {
        Assert(pFilterInstance);
        pFilterInstance->pGraphNodeInstance = NULL;
        pFilterInstance->ParentInstance.Invalidate();
    }
    DestroyPinDescriptors();
    DestroySysAudioTopology();
    delete[] paulNodeNumber;
}

NTSTATUS 
CGraphNodeInstance::Create(
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG i, n;

    if(this == NULL) {
        Status = STATUS_NO_SUCH_DEVICE;
        goto exit;
    }
    Assert(this);
    Assert(pGraphNode);

    Status = CreatePinDescriptors();
    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
    Status = CreateSysAudioTopology();
    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
    if(gcVirtualSources != 0) {
        paulNodeNumber = new ULONG[gcVirtualSources];
        if(paulNodeNumber == NULL) {
            Trap();
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto exit;
        }
        for(i = 0; i < gcVirtualSources; i++) {
            for(n = 0; n < cTopologyNodes; n++) {
                if(pGraphNode->pDeviceNode->papVirtualSourceData[i]->
                   pTopologyNode == papTopologyNode[n]) {
                    paulNodeNumber[i] = n;
                    break;
                }
            }
        }
    }
exit:
    return(Status);
}

//---------------------------------------------------------------------------

NTSTATUS
CGraphNodeInstance::GetTopologyNodeFileObject(
    OUT PFILE_OBJECT *ppFileObject,
    IN ULONG NodeId
)
{
    NTSTATUS Status = STATUS_SUCCESS;

    if(this == NULL) {
        Status = STATUS_NO_SUCH_DEVICE;
        goto exit;
    }
    Assert(this);

    if(NodeId >= cTopologyNodes) {
        DPF2(100, 
          "GetTopologyNodeFileObject: NodeId(%d) >= cTopologyNodes(%d)",
          NodeId,
          cTopologyNodes);
        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto exit;
    }

    // If virtual topology node, return error
    if(papTopologyNode[NodeId]->ulRealNodeNumber == MAXULONG) {
        DPF(100, "GetTopologyNodeFileObject: ulRealNodeNumber == MAXULONG");
        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto exit;
    }

    if(papFilterNodeInstanceTopologyTable == NULL) {
        Trap();
        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto exit;
    }

    if(papFilterNodeInstanceTopologyTable[NodeId] == NULL) {
        Status = CFilterNodeInstance::Create(
          &papFilterNodeInstanceTopologyTable[NodeId],
          papTopologyNode[NodeId]->lstLogicalFilterNode.GetListFirstData(),
          pGraphNode->pDeviceNode,
          TRUE);				// Reuse an instance

        if(!NT_SUCCESS(Status)) {
            goto exit;
        }
    }
    Assert(papFilterNodeInstanceTopologyTable[NodeId]);
    *ppFileObject = papFilterNodeInstanceTopologyTable[NodeId]->pFileObject;

    DPF1(110,
      "GetToplogyNodeFileObject: using filter for node: %d\n",
      NodeId);
exit:
    return(Status);
}

//---------------------------------------------------------------------------

NTSTATUS
CGraphNodeInstance::CreateSysAudioTopology(
)
{
    NTSTATUS Status = STATUS_SUCCESS;

    Assert(this);
    ASSERT(Topology.TopologyNodes == NULL);
    ASSERT(Topology.TopologyConnections == NULL);
    ASSERT(papFilterNodeInstanceTopologyTable == NULL);

    Topology.CategoriesCount = SIZEOF_ARRAY(aguidSysAudioCategories);
    Topology.Categories = aguidSysAudioCategories;

    CreateTopologyTables();

    if(cTopologyNodes != 0) {

        Topology.TopologyNodes = new GUID[cTopologyNodes];
        if(Topology.TopologyNodes == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto exit;
        }

        papFilterNodeInstanceTopologyTable = 
          new PFILTER_NODE_INSTANCE[cTopologyNodes];

        if(papFilterNodeInstanceTopologyTable == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto exit;
        }

        papTopologyNode = new PTOPOLOGY_NODE[cTopologyNodes];
        if(papTopologyNode == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto exit;
        }
    }
    if(cTopologyConnections != 0) {

        Topology.TopologyConnections = 
          new KSTOPOLOGY_CONNECTION[cTopologyConnections];

        if(Topology.TopologyConnections == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto exit;
        }
    }
    CreateTopologyTables();
exit:
    if(!NT_SUCCESS(Status)) {
        DestroySysAudioTopology();
    }
    return(Status);
}

VOID
CGraphNodeInstance::DestroySysAudioTopology(
)
{
    ULONG n;

    delete[] (PVOID)Topology.TopologyNodes;
    Topology.TopologyNodes = NULL;
    delete[] (PVOID)Topology.TopologyConnections;
    Topology.TopologyConnections = NULL;
    delete[] papTopologyNode;
    papTopologyNode = NULL;

    if(papFilterNodeInstanceTopologyTable != NULL) {
        for(n = 0; n < cTopologyNodes; n++) {
            papFilterNodeInstanceTopologyTable[n]->Destroy();
        }
        delete[] papFilterNodeInstanceTopologyTable;
        papFilterNodeInstanceTopologyTable = NULL;
    }
}

typedef ENUMFUNC (CTopologyNode::*CLIST_TN_PFN2)(PVOID, PVOID);

VOID
CGraphNodeInstance::CreateTopologyTables(
)
{
    Assert(this);
    Assert(pGraphNode);

    cTopologyNodes = 0;
    cTopologyConnections = 0;

    // Initialize the "ulSysaudioNodeNumber" field in the TopologyNodes first
    ProcessLogicalFilterNodeTopologyNode(
      &pGraphNode->pDeviceNode->lstLogicalFilterNode,
      CTopologyNode::InitializeTopologyNode);

    ProcessLogicalFilterNodeTopologyNode(
      &pGraphNode->lstLogicalFilterNode,
      CTopologyNode::InitializeTopologyNode);

    // All the nodes need to be processed first so the ulSysaudioNodeNumber in
    // the TopologyNode is correct before any connections are processed.
    ProcessLogicalFilterNodeTopologyNode(
      &pGraphNode->pDeviceNode->lstLogicalFilterNode,
      CTopologyNode::AddTopologyNode);

    ProcessLogicalFilterNodeTopologyNode(
      &pGraphNode->lstLogicalFilterNode,
      CTopologyNode::AddTopologyNode);

    // Now process all the topology connection lists
    ProcessLogicalFilterNodeTopologyConnection(
      &pGraphNode->pDeviceNode->lstLogicalFilterNode,
      CTopologyConnection::ProcessTopologyConnection);

    ProcessLogicalFilterNodeTopologyConnection(
      &pGraphNode->lstLogicalFilterNode,
      CTopologyConnection::ProcessTopologyConnection);

    pGraphNode->lstTopologyConnection.EnumerateList(
      CTopologyConnection::ProcessTopologyConnection,
      (PVOID)this);
}

VOID
CGraphNodeInstance::ProcessLogicalFilterNodeTopologyNode(
    PLIST_MULTI_LOGICAL_FILTER_NODE plstLogicalFilterNode,
    NTSTATUS (CTopologyNode::*Function)(
        PVOID pGraphNodeInstance
    )
)
{
    PLOGICAL_FILTER_NODE pLogicalFilterNode;

    FOR_EACH_LIST_ITEM(
      plstLogicalFilterNode,
      pLogicalFilterNode) {
        Assert(pLogicalFilterNode);
        pLogicalFilterNode->lstTopologyNode.EnumerateList(Function, this);
    } END_EACH_LIST_ITEM
}

VOID
CGraphNodeInstance::ProcessLogicalFilterNodeTopologyConnection(
    PLIST_MULTI_LOGICAL_FILTER_NODE plstLogicalFilterNode,
    NTSTATUS (CTopologyConnection::*Function)(
        PVOID pGraphNodeInstance
    )
)
{
    PLOGICAL_FILTER_NODE pLogicalFilterNode;

    FOR_EACH_LIST_ITEM(
      plstLogicalFilterNode,
      pLogicalFilterNode) {
        Assert(pLogicalFilterNode);
        pLogicalFilterNode->lstTopologyConnection.EnumerateList(Function, this);
    } END_EACH_LIST_ITEM
}

ENUMFUNC
CTopologyConnection::ProcessTopologyConnection(
    PVOID pReference
)
{
    PGRAPH_NODE_INSTANCE pGraphNodeInstance = (PGRAPH_NODE_INSTANCE)pReference;
    PSTART_NODE pStartNode;
    ULONG ulFromPin;
    ULONG ulFromNode;
    ULONG ulToPin;
    ULONG ulToNode;
    ULONG PinId;

    Assert(this);
    Assert(pGraphNodeInstance);

    ulFromPin = MAXULONG;
    ulToPin = MAXULONG;
#ifdef DEBUG
    ulFromNode = MAXULONG;
    ulToNode = MAXULONG;
#endif

    // If the connection doesn't connect LFNs on this GraphNode, skip connection
    if(!IsTopologyConnectionOnGraphNode(pGraphNodeInstance->pGraphNode)) {
        DPF3(100, "ProcessTC: %s TC %08x GN %08x - skip TC",
          pGraphNodeInstance->pGraphNode->pDeviceNode->DumpName(),
          this,
          pGraphNodeInstance->pGraphNode);
        goto exit;
    }

    if(pTopologyPinFrom != NULL) {
        ulFromNode = pTopologyPinFrom->pTopologyNode->ulSysaudioNodeNumber;
        ulFromPin = pTopologyPinFrom->ulPinNumber;

        ASSERT(pPinInfoFrom == NULL);
        ASSERT(ulFromNode != MAXULONG);
        ASSERT(ulFromPin != MAXULONG);
    }

    if(pTopologyPinTo != NULL) {
        ulToNode = pTopologyPinTo->pTopologyNode->ulSysaudioNodeNumber;
        ulToPin = pTopologyPinTo->ulPinNumber;

        ASSERT(pPinInfoTo == NULL);
        ASSERT(ulToNode != MAXULONG);
        ASSERT(ulToPin != MAXULONG);
    }

    if(pGraphNodeInstance->aplstStartNode != NULL) {

        for(PinId = 0; PinId < pGraphNodeInstance->cPins; PinId++) {

            FOR_EACH_LIST_ITEM(
              pGraphNodeInstance->aplstStartNode[PinId],
              pStartNode) {

                Assert(pStartNode);
                if(pPinInfoFrom != NULL) {
                    ASSERT(pTopologyPinFrom == NULL);

                    if(pStartNode->pPinNode->pPinInfo == pPinInfoFrom) {
                        // This code assumes that a filter's pininfo will show
                        // up in one SAD pin. If a filter exposes more than one
                        // major format on the same pin, that pininfo show on 
                        // two different SAD pins.
                        ASSERT(ulFromNode == KSFILTER_NODE);
                        ASSERT(ulFromPin == MAXULONG || ulFromPin == PinId);

                        pStartNode->GetStartInfo()->
                          ulTopologyConnectionTableIndex =
                            pGraphNodeInstance->cTopologyConnections;

                        ulFromNode = KSFILTER_NODE;
                        ulFromPin = PinId;
                    }
                }

                if(pPinInfoTo != NULL) {
                    ASSERT(pTopologyPinTo == NULL);

                    if(pStartNode->pPinNode->pPinInfo == pPinInfoTo) {
                        // See above.
                        ASSERT(ulToNode == KSFILTER_NODE);
                        ASSERT(ulToPin == MAXULONG || ulToPin == PinId);

                        pStartNode->GetStartInfo()->
                          ulTopologyConnectionTableIndex =
                            pGraphNodeInstance->cTopologyConnections;

                        ulToNode = KSFILTER_NODE;
                        ulToPin = PinId;
                    }
                }

            } END_EACH_LIST_ITEM
        }
    }
    if(ulFromPin != MAXULONG && ulToPin != MAXULONG) {
        pGraphNodeInstance->AddTopologyConnection(
          ulFromNode,
          ulFromPin,
          ulToNode,
          ulToPin);
    }
exit:
    return(STATUS_CONTINUE);
}

ENUMFUNC
CTopologyNode::InitializeTopologyNode(
    PVOID pReference
)
{
    PGRAPH_NODE_INSTANCE pGraphNodeInstance = (PGRAPH_NODE_INSTANCE)pReference;

    Assert(this);
    Assert(pGraphNodeInstance);
    ulSysaudioNodeNumber = MAXULONG;
    return(STATUS_CONTINUE);
}

ENUMFUNC
CTopologyNode::AddTopologyNode(
    PVOID pReference
)
{
    PGRAPH_NODE_INSTANCE pGraphNodeInstance = (PGRAPH_NODE_INSTANCE)pReference;

    Assert(this);
    Assert(pGraphNodeInstance);

    // Skip duplicate TopologyNodes
    if(ulSysaudioNodeNumber != MAXULONG) {
        DPF1(100, "AddTopologyNode: dup TN: %08x", this);
        goto exit;
    }
    ulSysaudioNodeNumber = pGraphNodeInstance->cTopologyNodes;

    if(pGraphNodeInstance->papTopologyNode != NULL) {
        pGraphNodeInstance->papTopologyNode[
          pGraphNodeInstance->cTopologyNodes] = this;
    }
    if(pGraphNodeInstance->Topology.TopologyNodes != NULL) {
        ((GUID *)(pGraphNodeInstance->Topology.TopologyNodes))[
          pGraphNodeInstance->cTopologyNodes] = *pguidType;
    }
    DPF3(115, "AddTopologyNode: %02x GNI: %08x TN: %08x",
      pGraphNodeInstance->cTopologyNodes,
      pGraphNodeInstance,
      this);

    ++pGraphNodeInstance->cTopologyNodes;
exit:
    return(STATUS_CONTINUE);
}

VOID
CGraphNodeInstance::AddTopologyConnection(
    ULONG ulFromNode,
    ULONG ulFromPin,
    ULONG ulToNode,
    ULONG ulToPin
)
{
    Assert(this);
    if(Topology.TopologyConnections != NULL) {
        PKSTOPOLOGY_CONNECTION pKSTopologyConnection =
          (PKSTOPOLOGY_CONNECTION)&Topology.TopologyConnections[
             cTopologyConnections];

        pKSTopologyConnection->FromNode = ulFromNode;
        pKSTopologyConnection->FromNodePin = ulFromPin;
        pKSTopologyConnection->ToNode = ulToNode;
        pKSTopologyConnection->ToNodePin = ulToPin;
    }
    ++cTopologyConnections;

    DPF4(115, "AddTopologyConnection: FN:%02x FNP:%02x TN:%02x TNP:%02x",
      ulFromNode,
      ulFromPin,
      ulToNode,
      ulToPin);
}

//---------------------------------------------------------------------------

NTSTATUS
CGraphNodeInstance::CreatePinDescriptors(
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    ListDataAssertLess<LIST_DATA_START_NODE> lstStartNodeLists;
    ListDataAssertLess<KSDATARANGE> lstDataRange;
    PLIST_DATA_START_NODE plstStartNodeOrdered;
    PSTART_NODE pStartNodeSorted;
    PSTART_NODE pStartNode;
    BOOL fSorted;
    ULONG PinId;

    Assert(this);
    Assert(pGraphNode);
    ASSERT(paPinDescriptors == NULL);
    ASSERT(aplstStartNode == NULL);
    ASSERT(palstTopologyNodeSelect == NULL);
    ASSERT(palstTopologyNodeNotSelect == NULL);
    ASSERT(pacPinInstances == NULL);
    ASSERT(pulPinFlags == NULL);
    ASSERT(cPins == 0);

    // Sort StartNodes by Communication, DataFlow and Major Format GUID
    FOR_EACH_LIST_ITEM(&pGraphNode->lstStartNode, pStartNode) {
        Assert(pStartNode->pPinNode);
        Assert(pStartNode->pPinNode->pPinInfo);

        // Skip any start nodes with no data range
        if(pStartNode->pPinNode->pDataRange == NULL) {
            Trap();
            continue;
        }
        // Skip any start nodes with no instances left on the pin
        if(ulFlags & FLAGS_COMBINE_PINS) {
            if(pStartNode->pPinNode->pPinInfo->Communication == 
               KSPIN_COMMUNICATION_SINK ||
               pStartNode->pPinNode->pPinInfo->Communication == 
               KSPIN_COMMUNICATION_SOURCE ||
               pStartNode->pPinNode->pPinInfo->Communication == 
               KSPIN_COMMUNICATION_BOTH) {

                if(!pStartNode->IsPossibleInstances()) {
                    continue;
                }
            }
        }
        fSorted = FALSE;
        FOR_EACH_LIST_ITEM(&lstStartNodeLists, plstStartNodeOrdered) {

            FOR_EACH_LIST_ITEM(plstStartNodeOrdered, pStartNodeSorted) {
                Assert(pStartNodeSorted);
                Assert(pStartNodeSorted->pPinNode);
                Assert(pStartNodeSorted->pPinNode->pPinInfo);

                // If the same actual pin, combine the pin nodes
                if((pStartNode->pPinNode->pPinInfo ==
                    pStartNodeSorted->pPinNode->pPinInfo) ||

                   // Combine only if client wants it that way
                   (ulFlags & FLAGS_COMBINE_PINS) &&

                   // Combine only AUDIO major formats
                   IsEqualGUID(
                     &pStartNode->pPinNode->pDataRange->MajorFormat,
                     &KSDATAFORMAT_TYPE_AUDIO) &&

                   // Only combine SINK, SOURCE, BOTH StartNodes; keep
                   // NONE and BRIDGE as separate SAD pins
                   ((pStartNode->pPinNode->pPinInfo->Communication ==
                     KSPIN_COMMUNICATION_SINK) ||
                   (pStartNode->pPinNode->pPinInfo->Communication ==
                     KSPIN_COMMUNICATION_SOURCE) ||
                   (pStartNode->pPinNode->pPinInfo->Communication ==
                     KSPIN_COMMUNICATION_BOTH)) &&

                   // Combine if same data flow
                   (pStartNode->pPinNode->pPinInfo->DataFlow ==
                    pStartNodeSorted->pPinNode->pPinInfo->DataFlow) &&

                   // Combine if same communication type OR
                   ((pStartNode->pPinNode->pPinInfo->Communication ==
                     pStartNodeSorted->pPinNode->pPinInfo->Communication) ||

                    // Combine a SINK and a BOTH
                    ((pStartNode->pPinNode->pPinInfo->Communication ==
                       KSPIN_COMMUNICATION_SINK) &&
                     (pStartNodeSorted->pPinNode->pPinInfo->Communication ==
                       KSPIN_COMMUNICATION_BOTH)) ||

                    // Combine a BOTH and a SINK
                    ((pStartNode->pPinNode->pPinInfo->Communication ==
                       KSPIN_COMMUNICATION_BOTH) &&
                     (pStartNodeSorted->pPinNode->pPinInfo->Communication ==
                       KSPIN_COMMUNICATION_SINK)) ||

                    // Combine a SOURCE and a BOTH
                    ((pStartNode->pPinNode->pPinInfo->Communication ==
                       KSPIN_COMMUNICATION_SOURCE) &&
                     (pStartNodeSorted->pPinNode->pPinInfo->Communication ==
                       KSPIN_COMMUNICATION_BOTH)) ||

                    // Combine a BOTH and a SOURCE
                    ((pStartNode->pPinNode->pPinInfo->Communication ==
                       KSPIN_COMMUNICATION_BOTH) &&
                     (pStartNodeSorted->pPinNode->pPinInfo->Communication ==
                       KSPIN_COMMUNICATION_SOURCE))) &&

                   // Combine if major format is the same
                   IsEqualGUID(
                     &pStartNode->pPinNode->pDataRange->MajorFormat,
                     &pStartNodeSorted->pPinNode->pDataRange->MajorFormat)) {

                    Status = plstStartNodeOrdered->AddListOrdered(
                      pStartNode,
                      FIELD_OFFSET(START_NODE, ulOverhead));

                    if(!NT_SUCCESS(Status)) {
                        goto exit;
                    }
                    fSorted = TRUE;
                    break;
                    }

            } END_EACH_LIST_ITEM

            if(fSorted) {
               break;
            }

        } END_EACH_LIST_ITEM

        if(!fSorted) {
            plstStartNodeOrdered = new LIST_DATA_START_NODE;
            if(plstStartNodeOrdered == NULL) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto exit;
            }
            Status = plstStartNodeOrdered->AddListOrdered(
              pStartNode,
              FIELD_OFFSET(START_NODE, ulOverhead));

            if(!NT_SUCCESS(Status)) {
                goto exit;
            }
            Status = lstStartNodeLists.AddList(plstStartNodeOrdered);
            if(!NT_SUCCESS(Status)) {
                goto exit;
            }
        }

    } END_EACH_LIST_ITEM

    // Allocate the pin descriptors, pin instance and start node arrays
    cPins = lstStartNodeLists.CountList();

    // if there are no pins, exit
    if(cPins == 0) {
        goto exit;
    }

    paPinDescriptors = new KSPIN_DESCRIPTOR[cPins];
    if(paPinDescriptors == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }

    aplstStartNode = new PLIST_DATA_START_NODE[cPins];
    if(aplstStartNode == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }
    DPF1(100, "CreatePinDescriptors: cPins %d", cPins);

    // For each pin, create a list of interfaces, mediums and dataranges
    PinId = 0;
    FOR_EACH_LIST_ITEM(&lstStartNodeLists, plstStartNodeOrdered) {
        PKSDATARANGE pDataRange, *apDataRanges;
        BOOL fBoth = TRUE;

        ASSERT(PinId < cPins);
        ASSERT(!plstStartNodeOrdered->IsLstEmpty());
        aplstStartNode[PinId] = plstStartNodeOrdered;

        FOR_EACH_LIST_ITEM(plstStartNodeOrdered, pStartNode) {
            Assert(pStartNode);
            Assert(pStartNode->pPinNode);
            Assert(pStartNode->pPinNode->pPinInfo);

            paPinDescriptors[PinId].DataFlow = 
              pStartNode->pPinNode->pPinInfo->DataFlow;

            if(pStartNode->pPinNode->pPinInfo->Communication !=
              KSPIN_COMMUNICATION_BOTH) {
                fBoth = FALSE;
                paPinDescriptors[PinId].Communication =
                  pStartNode->pPinNode->pPinInfo->Communication;
            }

            if(paPinDescriptors[PinId].Category == NULL ||
              IsEqualGUID(
               paPinDescriptors[PinId].Category, 
               &GUID_NULL)) {

                paPinDescriptors[PinId].Category =
                  pStartNode->pPinNode->pPinInfo->pguidCategory;

                paPinDescriptors[PinId].Name =
                  pStartNode->pPinNode->pPinInfo->pguidName;
            }

        } END_EACH_LIST_ITEM

        if(fBoth) {
            paPinDescriptors[PinId].Communication = KSPIN_COMMUNICATION_SINK;
        }

        // Make a list of all the DataRanges this pin will support
        Status = plstStartNodeOrdered->CreateUniqueList(
          &lstDataRange,
          (UNIQUE_LIST_PFN)GetStartNodeDataRange,
          (UNIQUE_LIST_PFN2)CompareDataRangeExact);

        if(!NT_SUCCESS(Status)) {
            goto exit;
        }

        // Put the number of data ranges into the pin descriptor
        paPinDescriptors[PinId].DataRangesCount = lstDataRange.CountList();
        if(paPinDescriptors[PinId].DataRangesCount != 0) {

            // Allocate the array of ptrs to DataRanges; put it into the desc
            paPinDescriptors[PinId].DataRanges = new PKSDATARANGE[
              paPinDescriptors[PinId].DataRangesCount];

            if(paPinDescriptors[PinId].DataRanges == NULL) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto exit;
            }

            // Put each data range pointer into the array
            apDataRanges = (PKSDATARANGE *)paPinDescriptors[PinId].DataRanges;

            FOR_EACH_LIST_ITEM(&lstDataRange, pDataRange) {

                *apDataRanges = pDataRange;
                apDataRanges++;
            } END_EACH_LIST_ITEM
        }

        // Destroy the data range list
        lstDataRange.DestroyList();

        // Create the interface array for the pin descriptor
        Status = CreateIdentifierArray(
          plstStartNodeOrdered,
          &paPinDescriptors[PinId].InterfacesCount,
          (PKSIDENTIFIER *)&paPinDescriptors[PinId].Interfaces,
          GetStartNodeInterface);

        if(!NT_SUCCESS(Status)) {
            goto exit;
        }

        // Create the medium array for the pin descriptor
        Status = CreateIdentifierArray(
          plstStartNodeOrdered,
          &paPinDescriptors[PinId].MediumsCount,
          (PKSIDENTIFIER *)&paPinDescriptors[PinId].Mediums,
          GetStartNodeMedium);

        if(!NT_SUCCESS(Status)) {
            goto exit;
        }
        DPF6(100, "PinId %d DataFlow %d cD %d cI %d cM %d cSN %d",
          PinId,
              paPinDescriptors[PinId].DataFlow,
          paPinDescriptors[PinId].DataRangesCount,
          paPinDescriptors[PinId].InterfacesCount,
          paPinDescriptors[PinId].MediumsCount,
          aplstStartNode[PinId]->CountList());

        // Next pin number
        PinId++;

    } END_EACH_LIST_ITEM

    if((ulFlags & FLAGS_MIXER_TOPOLOGY) == 0) {
        palstTopologyNodeSelect = new LIST_DATA_TOPOLOGY_NODE[cPins];
        if(palstTopologyNodeSelect == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto exit;
        }

        palstTopologyNodeNotSelect = new LIST_DATA_TOPOLOGY_NODE[cPins];
        if(palstTopologyNodeNotSelect == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto exit;
        }
        PLOGICAL_FILTER_NODE pLogicalFilterNode;
        PTOPOLOGY_NODE pTopologyNode;

        FOR_EACH_LIST_ITEM(
          &pGraphNode->lstLogicalFilterNode,
          pLogicalFilterNode) {

           if(pLogicalFilterNode->GetFlags() & LFN_FLAGS_NOT_SELECT) {
                
               FOR_EACH_LIST_ITEM(
                 &pLogicalFilterNode->lstTopologyNode,
                 pTopologyNode) {

                    for(PinId = 0; PinId < cPins; PinId++) {
                        Status = palstTopologyNodeNotSelect[PinId].AddList(
                          pTopologyNode);

                        if(!NT_SUCCESS(Status)) {
                            goto exit;
                        }
                    }

               } END_EACH_LIST_ITEM
           }

        } END_EACH_LIST_ITEM
    }

    pacPinInstances = new KSPIN_CINSTANCES[cPins];
    if(pacPinInstances == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }

    pulPinFlags = new ULONG[cPins];
    if (NULL == pulPinFlags) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }

    for(PinId = 0; PinId < cPins; PinId++) {
        LIST_DATA_GRAPH_PIN_INFO lstGraphPinInfo;
        PSTART_NODE pStartNode2;
        PPIN_INFO pPinInfo;
        BOOL fHWRender = TRUE;

        FOR_EACH_LIST_ITEM(aplstStartNode[PinId], pStartNode2) {
            PGRAPH_PIN_INFO pGraphPinInfo;

            pGraphPinInfo = pStartNode2->GetGraphPinInfo();
            Assert(pGraphPinInfo);

            // 
            // Set pin type. 
            // If all startnodes are connected directly to renderer.
            //
            pPinInfo = pGraphPinInfo->GetPinInfo();

            ASSERT(pPinInfo);
            if ((!(pPinInfo->pFilterNode->GetType() & FILTER_TYPE_RENDERER)) ||
                (KSPIN_DATAFLOW_IN != pPinInfo->DataFlow) ||
                (KSPIN_COMMUNICATION_SINK != pPinInfo->Communication)) {
                fHWRender = FALSE;
            }

            if(lstGraphPinInfo.CheckDupList(pGraphPinInfo)) {
                continue;
            }

            Status = lstGraphPinInfo.AddList(pGraphPinInfo);
            if(!NT_SUCCESS(Status)) {
                goto exit;
            }

            //
            // Set cinstances.
            //
            if(pGraphPinInfo->IsPinReserved()) {
                pacPinInstances[PinId].CurrentCount = 1;
            }
            if(pGraphPinInfo->GetPinInstances()->PossibleCount == MAXULONG) {
                pacPinInstances[PinId].PossibleCount = MAXULONG;
                break;
            }
            pacPinInstances[PinId].PossibleCount +=
              pGraphPinInfo->GetPinInstances()->PossibleCount;

            if (fHWRender) {
                fHWRender = (1 < pGraphPinInfo->GetPinInstances()->PossibleCount);
            }

        } END_EACH_LIST_ITEM

        pulPinFlags[PinId] = fHWRender;

        lstGraphPinInfo.DestroyList();
    }
    
exit:
    if(!NT_SUCCESS(Status)) {
        DestroyPinDescriptors();
    }
    return(Status);
}

VOID
CGraphNodeInstance::DestroyPinDescriptors(
)
{
    ULONG PinId;

    Assert(this);
    for(PinId = 0; PinId < cPins; PinId++) {
        if(paPinDescriptors != NULL) {
            delete (PVOID)paPinDescriptors[PinId].DataRanges;
            if(paPinDescriptors[PinId].InterfacesCount > 1) {
                delete (PVOID)paPinDescriptors[PinId].Interfaces;
            }
            if(paPinDescriptors[PinId].MediumsCount > 1) {
                delete (PVOID)paPinDescriptors[PinId].Mediums;
            }
        }
        if(aplstStartNode != NULL) {
            delete aplstStartNode[PinId];
        }
    }
    delete[cPins] aplstStartNode;
    aplstStartNode = NULL;
    delete[cPins] paPinDescriptors;
    paPinDescriptors = NULL;
    delete[cPins] palstTopologyNodeSelect;
    palstTopologyNodeSelect = NULL;
    delete[cPins] palstTopologyNodeNotSelect;
    palstTopologyNodeNotSelect = NULL;
    delete[cPins] pacPinInstances;
    pacPinInstances = NULL;
    delete[cPins] pulPinFlags;
    pulPinFlags = NULL;
}

NTSTATUS
CreateIdentifierArray(
    PLIST_DATA_START_NODE plstStartNode,
    PULONG pulCount,
    PKSIDENTIFIER *ppIdentifier,
    PKSIDENTIFIER (*GetFunction)(
        PSTART_NODE pStartNode
    )
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    KSIDENTIFIER *pIdentifier1, *pIdentifier2;
    ListDataAssertLess<KSIDENTIFIER> lstIdentifier;

    Status = plstStartNode->CreateUniqueList(
      &lstIdentifier,
      (UNIQUE_LIST_PFN)GetFunction,
      (UNIQUE_LIST_PFN2)CompareIdentifier);

    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
    if((*pulCount = lstIdentifier.CountList()) == 0) {
        *ppIdentifier = NULL;
    }
    else {
        if(*pulCount == 1) {
            *ppIdentifier = lstIdentifier.GetListFirstData();
        }
        else {
            *ppIdentifier = new KSIDENTIFIER[*pulCount];
            if(*ppIdentifier == NULL) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto exit;
            }
            pIdentifier1 = *ppIdentifier;
            AssertAligned(pIdentifier1);
            FOR_EACH_LIST_ITEM(&lstIdentifier, pIdentifier2) {
                AssertAligned(pIdentifier1);
                AssertAligned(pIdentifier2);
                RtlCopyMemory(pIdentifier1, pIdentifier2, sizeof(KSIDENTIFIER));
                pIdentifier1++;
            } END_EACH_LIST_ITEM
        }
    }
exit:
    return(Status);
}

PKSDATARANGE
GetStartNodeDataRange(
    PSTART_NODE pStartNode
)
{
    return(pStartNode->pPinNode->pDataRange);
}

PKSIDENTIFIER
GetStartNodeInterface(
    PSTART_NODE pStartNode
)
{
    return(pStartNode->pPinNode->pInterface);
}

PKSIDENTIFIER
GetStartNodeMedium(
    PSTART_NODE pStartNode
)
{
    return(pStartNode->pPinNode->pMedium);
}

//---------------------------------------------------------------------------

//
// This functions checks whether a given TopologyNode is in the Topology
// Connection list.
//
ENUMFUNC
FindTopologyNode(
    IN PTOPOLOGY_CONNECTION pTopologyConnection,
    IN BOOL fToDirection,
    IN PTOPOLOGY_NODE pTopologyNode
)
{
    Assert(pTopologyConnection);

    if(IS_CONNECTION_TYPE(pTopologyConnection, GRAPH)) {
        return(STATUS_DEAD_END);
    }
    if(fToDirection) {
        if(pTopologyConnection->pTopologyPinTo != NULL) {
            if(pTopologyNode == 
               pTopologyConnection->pTopologyPinTo->pTopologyNode) {
                return(STATUS_SUCCESS);
            }
        }
    }
    else {
        if(pTopologyConnection->pTopologyPinFrom != NULL) {
            if(pTopologyNode == 
               pTopologyConnection->pTopologyPinFrom->pTopologyNode) {
                return(STATUS_SUCCESS);
            }
        }
    }
    return(STATUS_CONTINUE);
}

BOOL
CGraphNodeInstance::IsGraphValid(
    PSTART_NODE pStartNode,
    ULONG PinId
)
{
    PFILTER_INSTANCE pFilterInstance;
    PTOPOLOGY_NODE pTopologyNode;
    BOOL fCheck;

    Assert(this);
    Assert(pGraphNode);
    Assert(pStartNode);
    Assert(pStartNode->pPinNode);
    Assert(pStartNode->pPinNode->pPinInfo);
    Assert(pGraphNode->pDeviceNode);
    ASSERT(PinId < cPins);

    //
    // First make sure that all GlobalSelect nodes are in StartNode graph.
    //
    if(pStartNode->pPinNode->pPinInfo->DataFlow == KSPIN_DATAFLOW_IN) {

        FOR_EACH_LIST_ITEM(
          &pGraphNode->pDeviceNode->lstFilterInstance,
          pFilterInstance) {

            if(pFilterInstance->pGraphNodeInstance == NULL) {
                continue;
            }
            Assert(pFilterInstance->pGraphNodeInstance);

            FOR_EACH_LIST_ITEM(
              &pFilterInstance->pGraphNodeInstance->lstTopologyNodeGlobalSelect,
              pTopologyNode) {

                if(EnumerateGraphTopology(
                  pStartNode->GetStartInfo(),
                  (TOP_PFN)FindTopologyNode,
                  pTopologyNode) == STATUS_CONTINUE) {

                    DPF2(80,
                      "IsGraphValid: TN %08x SN %08x not found Global",
                      pTopologyNode,
                      pStartNode);

                    return(FALSE);
                }

            } END_EACH_LIST_ITEM

        } END_EACH_LIST_ITEM
    }

    //
    // Make sure that all Selected nodes are in StartNode graph.
    //
    if (palstTopologyNodeSelect) {
        FOR_EACH_LIST_ITEM(&palstTopologyNodeSelect[PinId], pTopologyNode) {

            if(EnumerateGraphTopology(
              pStartNode->GetStartInfo(),
              (TOP_PFN)FindTopologyNode,
              pTopologyNode) == STATUS_CONTINUE) {

                DPF2(80, "IsGraphValid: TN %08x SN %08x not found Select",
                  pTopologyNode,
                  pStartNode);

                return(FALSE);
            }

        } END_EACH_LIST_ITEM
    }
    
    // If a NotSelectNode is in the GlobalSelectList of another FilterInstance,
    // don't consider this as an invalid Graph.
    // This behaves like an implicit SelectGraph.
    //
    if (palstTopologyNodeNotSelect) {
        PTOPOLOGY_NODE pDestroyTopologyNode = NULL;   
        
        FOR_EACH_LIST_ITEM(&palstTopologyNodeNotSelect[PinId], pTopologyNode) {

            if (pDestroyTopologyNode)
            {
                DPF2(50, "Removing (1) TN %X %s", 
                    pDestroyTopologyNode, 
                    pDestroyTopologyNode->pFilterNode->DumpName());

                // Remove the topologynode from NotSelect list.
                palstTopologyNodeNotSelect[PinId].
                    RemoveList(pDestroyTopologyNode);

                pDestroyTopologyNode = NULL;
            }
            
            fCheck = TRUE;
            if(pStartNode->pPinNode->pPinInfo->DataFlow == KSPIN_DATAFLOW_IN) {

                FOR_EACH_LIST_ITEM(
                  &pGraphNode->pDeviceNode->lstFilterInstance,
                  pFilterInstance) {

                    if(pFilterInstance->pGraphNodeInstance == NULL) {
                        continue;
                    }
                    Assert(pFilterInstance->pGraphNodeInstance);

                    // Is this NotSelectNode in the GlobalSelectList of 
                    // another FilterInstance.
                    // Remove it from NotSelectList and add it to 
                    // GlobalSelectList for this filter as well.
                    //
                    if(pFilterInstance->pGraphNodeInstance->
                      lstTopologyNodeGlobalSelect.EnumerateList(
                        CTopologyNode::MatchTopologyNode,
                        pTopologyNode) == STATUS_SUCCESS) {

                        if (NT_SUCCESS(lstTopologyNodeGlobalSelect.
                          AddListDup(pTopologyNode))) {

                            // Mark the topologyNode for deletion.
                            pDestroyTopologyNode = pTopologyNode;
                        }
                        else {
                            DPF2(4, "Failed to add TN %X to GNI %X GlobalSelectList", 
                                pTopologyNode,
                                this);
                            Trap();
                        }

                        fCheck = FALSE;
                        break;
                    }

                } END_EACH_LIST_ITEM
            }

            if(fCheck) {
                if(EnumerateGraphTopology(
                  pStartNode->GetStartInfo(),
                  (TOP_PFN)FindTopologyNode,
                  pTopologyNode) == STATUS_SUCCESS) {

                    DPF2(80, "IsGraphValid: TN %08x SN %08x found NotSelect",
                      pTopologyNode,
                      pStartNode);

                    return(FALSE);
                }
            }

        } END_EACH_LIST_ITEM

        if (pDestroyTopologyNode)
        {
            DPF2(50, "Removing (2) TN %X %s", 
                pDestroyTopologyNode, 
                pDestroyTopologyNode->pFilterNode->DumpName());

            // Remove the topologynode from NotSelect list.
            palstTopologyNodeNotSelect[PinId].
                RemoveList(pDestroyTopologyNode);
        }
    }
    
    return(TRUE);
}

NTSTATUS 
CGraphNodeInstance::GetPinInstances(
    PIRP pIrp,
    PKSP_PIN pPin,
    PKSPIN_CINSTANCES pcInstances    
)
{
    NTSTATUS Status;
    ULONG ulPinId = pPin->PinId;

    // 
    // For HW Accelerated pins, send the request to HW filter.
    //
    if (pulPinFlags[ulPinId]) {
        PSTART_NODE pStartNode;
        PPIN_INFO pPinInfo;
        ULONG BytesReturned;
        PIO_STACK_LOCATION pIrpStack;        
        PFILTER_NODE_INSTANCE pFilterNodeInstance = NULL;

        pIrpStack = IoGetCurrentIrpStackLocation(pIrp);

        pStartNode = aplstStartNode[ulPinId]->GetListFirstData();

        pPinInfo = pStartNode->pPinNode->pPinInfo;

        Status = CFilterNodeInstance::Create(
          &pFilterNodeInstance,
          pStartNode->pPinNode->pLogicalFilterNode,
          pGraphNode->pDeviceNode,
          TRUE);        

        if(NT_SUCCESS(Status)) {
            pPin->PinId = pPinInfo->PinId;
            pPin->Property.Id = KSPROPERTY_PIN_CINSTANCES;

            AssertFileObject(pFilterNodeInstance->pFileObject);
            Status = KsSynchronousIoControlDevice(
              pFilterNodeInstance->pFileObject,
              KernelMode,
              IOCTL_KS_PROPERTY,
              pPin,
              pIrpStack->Parameters.DeviceIoControl.InputBufferLength,
              pcInstances,
              pIrpStack->Parameters.DeviceIoControl.OutputBufferLength,
              &BytesReturned);

            if(NT_SUCCESS(Status)) {
                pIrp->IoStatus.Information = BytesReturned;
            }

            if (pFilterNodeInstance) {
                pFilterNodeInstance->Destroy();
            }        
        }
        else {
            DPF2(10, "GetPinInstances FAILS %08x %s",
              Status,
              pPinInfo->pFilterNode->DumpName());
        }
    }
    //
    // For other pins use the cached instances
    //
    else {
        Status = STATUS_SUCCESS;
        *pcInstances = pacPinInstances[ulPinId];
    }

    return Status;
} // GetPinInstances


BOOL
CGraphNodeInstance::IsPinInstances(
    ULONG ulPinId)
{
    //
    // For HW Accelerated pins, always allow further operations.
    //
    if (pulPinFlags[ulPinId]) {
        return TRUE;
    }
    //
    // For other pins check cached instances.
    //
    else
    {
        if(pacPinInstances[ulPinId].CurrentCount >=
           pacPinInstances[ulPinId].PossibleCount) {
           return FALSE;
        }
    }

    return TRUE;
} // IsPinInstances

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\sysaudio\gn.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   gn.cpp
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//  To Do:     Date	  Author      Comment
//
//@@END_MSINTERNAL
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

ULONG gcGraphRecursion = 0;

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

CGraphNode::CGraphNode(
    PDEVICE_NODE pDeviceNode,
    ULONG ulFlags
)
{
    Assert(pDeviceNode);
    this->pDeviceNode = pDeviceNode;
    this->ulFlags = ulFlags;
    AddList(&pDeviceNode->lstGraphNode);
    DPF2(80, "CGraphNode %08x, DN: %08x", this, pDeviceNode);
}

CGraphNode::~CGraphNode(
)
{
    DPF1(80, "~CGraphNode: %08x", this);
    Assert(this);
    RemoveList();
}

NTSTATUS
CGraphNode::Create(
)
{
    PGRAPH_NODE_INSTANCE pGraphNodeInstance;
    PLOGICAL_FILTER_NODE pLogicalFilterNode;		
    NTSTATUS Status = STATUS_SUCCESS;

    DPF3(80, "CGraphNode::Create: GN %08x F %08x %s",
      this,
      this->ulFlags,
      pDeviceNode->DumpName());

    FOR_EACH_LIST_ITEM(&pDeviceNode->lstLogicalFilterNode, pLogicalFilterNode) {

	Status = Create(pLogicalFilterNode);
	if(!NT_SUCCESS(Status)) {
	    Trap();
	    goto exit;
	}

    } END_EACH_LIST_ITEM

    if(!lstLogicalFilterNodeNoBypass.IsLstEmpty()) {
	lstStartNode.EnumerateList(CStartNode::RemoveBypassPaths, this);
    }
    if(this->ulFlags & FLAGS_MIXER_TOPOLOGY) {
	lstStartNode.EnumerateList(CStartNode::RemoveConnectedStartNode, this);
    }
    lstStartInfo.EnumerateList(CStartInfo::CreatePinInfoConnection, this);

    pGraphNodeInstance = new GRAPH_NODE_INSTANCE(this);
    if(pGraphNodeInstance == NULL) {
	Status = STATUS_INSUFFICIENT_RESOURCES;
	Trap();
	goto exit;
    }
    Status = pGraphNodeInstance->Create();
    if(!NT_SUCCESS(Status)) {
	Trap();
	goto exit;
    }
    //
    // The "ulSysaudioNodeNumber" field in the topology node isn't
    // valid until CGraphNodeInstance::Create and they are only valid
    // for this pGraphNode.
    //
    lstStartInfo.EnumerateList(CStartInfo::EnumStartInfo);
    delete pGraphNodeInstance;
exit:
    return(Status);
}

NTSTATUS
CGraphNode::Create(
    PLOGICAL_FILTER_NODE pLogicalFilterNode
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG ulFlagsCurrent;
    PPIN_NODE pPinNode;

    DPF2(80, "CGraphNode::Create: LFN %08x %s",
      pLogicalFilterNode,
      pLogicalFilterNode->pFilterNode->DumpName());

    Assert(pLogicalFilterNode);
    FOR_EACH_LIST_ITEM(&pLogicalFilterNode->lstPinNode, pPinNode) {

	Assert(pPinNode);
	Assert(pPinNode->pPinInfo);
	ASSERT(
	  (pLogicalFilterNode->GetFlags() & LFN_FLAGS_REFLECT_DATARANGE) == 0);
	gcGraphRecursion = 0;
	ulFlagsCurrent = 0;

	// Determine whether it is an input stream or output stream
	if(pPinNode->pPinInfo->DataFlow == KSPIN_DATAFLOW_IN) {
	    ulFlagsCurrent |= LFN_FLAGS_CONNECT_RENDER;
	}
	if(pPinNode->pPinInfo->DataFlow == KSPIN_DATAFLOW_OUT) {
	    ulFlagsCurrent |= LFN_FLAGS_CONNECT_CAPTURE;
	}

	// Determine the kind of graph to build
	if(this->ulFlags & FLAGS_MIXER_TOPOLOGY) {
	    ulFlagsCurrent |= LFN_FLAGS_CONNECT_MIXER_TOPOLOGY;
	}
	else {
	    ulFlagsCurrent |= LFN_FLAGS_CONNECT_NORMAL_TOPOLOGY;
	}

	Status = CreateGraph(
	  pPinNode,
	  NULL,
	  pLogicalFilterNode,
	  NULL,
	  ulFlagsCurrent,
	  pPinNode->GetOverhead() + pLogicalFilterNode->GetOverhead());

	if(!NT_SUCCESS(Status)) {
	    Trap();
	    goto exit;
	}

    } END_EACH_LIST_ITEM
exit:
    return(Status);
}

NTSTATUS
CGraphNode::CreateGraph(
    PPIN_NODE pPinNode,
    PCONNECT_NODE pConnectNodePrevious,
    PLOGICAL_FILTER_NODE pLogicalFilterNodePrevious,
    PGRAPH_PIN_INFO pGraphPinInfoPrevious,
    ULONG ulFlagsCurrent,
    ULONG ulOverhead
)
{
    PLOGICAL_FILTER_NODE pLogicalFilterNode;
    PGRAPH_PIN_INFO pGraphPinInfo = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    Assert(this);
    Assert(pPinNode);
    Assert(pPinNode->pPinInfo);
    Assert(pLogicalFilterNodePrevious);
    if(pConnectNodePrevious != NULL) {
	Assert(pConnectNodePrevious);
    }
    ASSERT(pPinNode->pLogicalFilterNode == pLogicalFilterNodePrevious);

    //
    // Don't allow unlimited nesting, allow graphs number of LFNs deep
    //
    if(gcGraphRecursion++ > (gcLogicalFilterNodes + 8)) {
	DPF(10, "CreateGraph: recursion too deep");
	Status = STATUS_STACK_OVERFLOW;
	goto exit;
    }

    if(pGraphPinInfoPrevious == NULL) {
	Status = CGraphPinInfo::Create(
	  &pGraphPinInfo,
	  pPinNode->pPinInfo,
	  0,
	  this);

	if(!NT_SUCCESS(Status)) {
	    Trap();
	    goto exit;
	}
	pGraphPinInfoPrevious = pGraphPinInfo;
    }

    FOR_EACH_LIST_ITEM(gplstLogicalFilterNode, pLogicalFilterNode) {
	ULONG ulFlagsDiff;

	ASSERT(pLogicalFilterNode->GetOverhead() != OVERHEAD_NONE);
	//ASSERT(pLogicalFilterNode->GetOrder() != ORDER_NONE);

	DPF5(100, "CreateGraph: %s F %x LFN %08x F %x T %x",
	  pLogicalFilterNode->pFilterNode->DumpName(),
	  ulFlagsCurrent,
	  pLogicalFilterNode,
	  pLogicalFilterNode->GetFlags(),
	  pLogicalFilterNode->GetType());

	//
	// Rule: don't allow the same filter be connected twice
	//
	if(pLogicalFilterNode == pLogicalFilterNodePrevious) {
	    DPF1(100, "CreateGraph: same LFN: %08x", pLogicalFilterNode);
	    continue;
	}
	ulFlagsDiff = ~(ulFlagsCurrent ^ pLogicalFilterNode->GetFlags());

	if((ulFlagsDiff &
	  (LFN_FLAGS_CONNECT_CAPTURE | 
	   LFN_FLAGS_CONNECT_RENDER)) == 0) {
	    DPF1(100, "CreateGraph: i/o no match: LFN %08x", 
	      pLogicalFilterNode);
	    continue;
	}
	if((ulFlagsDiff & LFN_FLAGS_CONNECT_NORMAL_TOPOLOGY) == 0) {
	    DPF1(100, "CreateGraph: norm no match: LFN %08x",
	      pLogicalFilterNode);
	    continue;
	}
	if((ulFlagsDiff & LFN_FLAGS_CONNECT_MIXER_TOPOLOGY) == 0) {
	    DPF1(100, "CreateGraph: mixer no match: LFN %08x",
	      pLogicalFilterNode);
	    continue;
	}
	if(pLogicalFilterNode->GetOrder() < 
	   pLogicalFilterNodePrevious->GetOrder()) {
	    DPF2(100, "CreateGraph: ulOrder(%x) < Previous Order (%x)",
	      pLogicalFilterNode->GetOrder(),
	      pLogicalFilterNodePrevious->GetOrder());
	    continue;
	}
    #ifndef CONNECT_DIRECT_TO_HW
	if(pLogicalFilterNode->GetType() & FILTER_TYPE_PRE_MIXER) {
	    if(pLogicalFilterNodePrevious->GetOrder() < ORDER_MIXER) {
		if(gcMixers > 0) {
		    // 100
		    DPF2(50, 
		      "CreateGraph: previous order (%x) < ORDER_MIXER LFN %08x",
		      pLogicalFilterNodePrevious->GetOrder(),
		      pLogicalFilterNode);
		    continue;
		}
	    }
	}
    #endif
	if(!pLogicalFilterNode->pFilterNode->IsDeviceInterfaceMatch(
	  pDeviceNode)) {
	    DPF1(100, "CreateGraph: no dev interface match DN %08x",
	      pDeviceNode);
	    continue;
	}
	//
	// Enumerate each "To" pin on the LFN to see if it matchs the input pin
	//
	Status = CreateGraphToPin(
	  pPinNode,
	  pConnectNodePrevious,
	  pLogicalFilterNode,
	  pGraphPinInfoPrevious,
	  ulFlagsCurrent,
	  ulOverhead);

	if(!NT_SUCCESS(Status)) {
	    Trap();
	    goto exit;
	}

    } END_EACH_LIST_ITEM	// end each LFN

    Status = CStartNode::Create(
      pPinNode,
      pConnectNodePrevious,
      pGraphPinInfoPrevious,
      ulFlagsCurrent,
      ulOverhead,
      this);

    if(!NT_SUCCESS(Status)) {
	Trap();
	goto exit;
    }
exit:
    //
    // Remove the GPI if it doesn't have any other references from SIs or CIs
    //
    if (pGraphPinInfo) {
        pGraphPinInfo->Destroy();
    }
    gcGraphRecursion--;
    return(Status);
}

NTSTATUS
CGraphNode::CreateGraphToPin(
    PPIN_NODE pPinNode,
    PCONNECT_NODE pConnectNodePrevious,
    PLOGICAL_FILTER_NODE pLogicalFilterNode,
    PGRAPH_PIN_INFO pGraphPinInfo,
    ULONG ulFlagsCurrent,
    ULONG ulOverhead
)
{
    PCONNECT_NODE pConnectNode = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    PPIN_NODE pPinNodeTo;

    Assert(this);
    Assert(pPinNode);
    Assert(pPinNode->pPinInfo);
    Assert(pLogicalFilterNode);

    FOR_EACH_LIST_ITEM(&pLogicalFilterNode->lstPinNode, pPinNodeTo) {
	Assert(pPinNodeTo);
	Assert(pPinNodeTo->pPinInfo);
	ASSERT(pPinNodeTo->pLogicalFilterNode == pLogicalFilterNode);
	//
	// The dataflow, communication, interface, medium and data 
	// formats must be compatible.
	//
	if(!pPinNode->ComparePins(pPinNodeTo)) {
	    DPF2(100, "CreateGraph: pins mis: PN %08x PNTo %08x",
	      pPinNode,
	      pPinNodeTo);
	    continue;
	}
	Status = CConnectNode::Create(
	  &pConnectNode,
	  pLogicalFilterNode,
	  pConnectNodePrevious,
	  pGraphPinInfo,
	  pPinNode,
	  pPinNodeTo,
	  ulFlagsCurrent,
	  this);

	if(!NT_SUCCESS(Status)) {
	    Trap();
	    goto exit;
	}
	//
	// Enumerate each "from" pin on the LFN and recurse building the graph
	//
	Status = CreateGraphFromPin(
	  pPinNode,
	  pPinNodeTo,
	  pConnectNode,
	  pLogicalFilterNode,
	  pConnectNode->IsPinInstanceReserved() ? NULL : pGraphPinInfo,
	  ulFlagsCurrent,
	  ulOverhead);

	if(!NT_SUCCESS(Status)) {
	    Trap();
	    goto exit;
	}
	//
	// Remove CN if it doesn't have any other refs from other CNs or SNs.
	//
	pConnectNode->Destroy();
	pConnectNode = NULL;

    } END_EACH_LIST_ITEM	// end each LFN node "to" pin node
exit:
    if(!NT_SUCCESS(Status)) {
	//
	// Clean up the last CN created if error
	//
	Trap();
	pConnectNode->Destroy();
    }
    return(Status);
}

NTSTATUS
CGraphNode::CreateGraphFromPin(
    PPIN_NODE pPinNode,
    PPIN_NODE pPinNodeTo,
    PCONNECT_NODE pConnectNode,
    PLOGICAL_FILTER_NODE pLogicalFilterNode,
    PGRAPH_PIN_INFO pGraphPinInfo,
    ULONG ulFlagsCurrent,
    ULONG ulOverhead
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PPIN_NODE pPinNodeFrom;

    Assert(this);
    Assert(pPinNode);
    Assert(pPinNodeTo);
    Assert(pPinNodeTo->pPinInfo);
    Assert(pLogicalFilterNode);

    FOR_EACH_LIST_ITEM(&pLogicalFilterNode->lstPinNode, pPinNodeFrom) {
	ASSERT(pPinNodeFrom->pLogicalFilterNode == pLogicalFilterNode);

	if(pPinNodeTo->pPinInfo == pPinNodeFrom->pPinInfo) {
	    continue;
	}
	if(pLogicalFilterNode->GetFlags() & LFN_FLAGS_REFLECT_DATARANGE) {

	    pPinNodeFrom = new PIN_NODE(this, pPinNodeFrom);
	    if(pPinNodeFrom == NULL) {
		Status = STATUS_INSUFFICIENT_RESOURCES;
		Trap();
		goto exit;
	    }
	    pPinNodeFrom->pDataRange = pPinNode->pDataRange;
	}
	//
	// Recurse building the graph
	//
	Status = CreateGraph(
	  pPinNodeFrom,
	  pConnectNode,
	  pLogicalFilterNode,
	  pGraphPinInfo,
	  ulFlagsCurrent,
	  ulOverhead +
	    pPinNodeFrom->GetOverhead() +
	    pLogicalFilterNode->GetOverhead());

	if(!NT_SUCCESS(Status)) {
	    Trap();
	    goto exit;
	}

    } END_EACH_LIST_ITEM	// end each LFN "from" pin node
exit:
    return(Status);
}

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\sysaudio\gni.h ===
//---------------------------------------------------------------------------
//
//  Module:   		gni.h
//
//  Description:	Graph Node Instance Class
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Constants and Macros
//---------------------------------------------------------------------------

#define	cTopologyNodes		Topology.TopologyNodesCount
#define	cTopologyConnections	Topology.TopologyConnectionsCount

//---------------------------------------------------------------------------
// Classes
//---------------------------------------------------------------------------

typedef class CGraphNodeInstance : public CListDoubleItem
{
public:
    CGraphNodeInstance(
        PGRAPH_NODE pGraphNode,
        PFILTER_INSTANCE pFilterInstance
    );
    CGraphNodeInstance(
        PGRAPH_NODE pGraphNode
    );
    ~CGraphNodeInstance();
    NTSTATUS Create();
    ENUMFUNC Destroy()
    {
        Assert(this);
        delete this;
        return(STATUS_CONTINUE);
    };
    NTSTATUS GetTopologyNodeFileObject(
        OUT PFILE_OBJECT *ppFileObject,
        IN ULONG NodeId
    );
    BOOL IsGraphValid(
        PSTART_NODE pStartNode,
        ULONG PinId
    );
    VOID AddTopologyConnection(
        ULONG ulFromNode,
        ULONG ulFromPin,
        ULONG ulToNode,
        ULONG ulToPin
    );
    NTSTATUS GetPinInstances(
        PIRP pIrp,
        PKSP_PIN pPin,
        PKSPIN_CINSTANCES pcInstances    
    );
    BOOL IsPinInstances(
        ULONG ulPinId
    );
private:
    NTSTATUS CreatePinDescriptors();
    VOID DestroyPinDescriptors();
    NTSTATUS CreateSysAudioTopology();
    VOID DestroySysAudioTopology();
    VOID CreateTopologyTables();
    VOID ProcessLogicalFilterNodeTopologyNode(
        PLIST_MULTI_LOGICAL_FILTER_NODE plstLogicalFilterNode,
        NTSTATUS (CTopologyNode::*Function)(
            PVOID pGraphNodeInstance
        )
    );
    VOID ProcessLogicalFilterNodeTopologyConnection(
        PLIST_MULTI_LOGICAL_FILTER_NODE plstLogicalFilterNode,
        NTSTATUS (CTopologyConnection::*Function)(
            PVOID pGraphNodeInstance
        )
    );

public:
    LIST_DATA_TOPOLOGY_NODE lstTopologyNodeGlobalSelect;
    LIST_START_NODE_INSTANCE lstStartNodeInstance;
    PFILTER_INSTANCE pFilterInstance;
    PGRAPH_NODE pGraphNode;
    KSTOPOLOGY Topology;
    ULONG cPins;

    // Index by pin number
    PKSPIN_CINSTANCES pacPinInstances;
    PULONG            pulPinFlags;
    PKSPIN_DESCRIPTOR paPinDescriptors;
    PLIST_DATA_START_NODE *aplstStartNode;
    PLIST_DATA_TOPOLOGY_NODE palstTopologyNodeSelect;
    PLIST_DATA_TOPOLOGY_NODE palstTopologyNodeNotSelect;

    // Index by node number
    PTOPOLOGY_NODE *papTopologyNode;
    PFILTER_NODE_INSTANCE *papFilterNodeInstanceTopologyTable;

    // Index by virtual source index
    ULONG *paulNodeNumber;
private:
    ULONG ulFlags;
public:
    DefineSignature(0x20494E47);		// GNI

} GRAPH_NODE_INSTANCE, *PGRAPH_NODE_INSTANCE;

//---------------------------------------------------------------------------

typedef ListDoubleDestroy<GRAPH_NODE_INSTANCE> LIST_GRAPH_NODE_INSTANCE;

//---------------------------------------------------------------------------
// Local prototypes
//---------------------------------------------------------------------------

extern "C" {

NTSTATUS
CreateIdentifierArray(
    PLIST_DATA_START_NODE pldhStartNode,
    PULONG pulCount,
    PKSIDENTIFIER *ppIdentifier,
    PKSIDENTIFIER (*GetFunction)(
        PSTART_NODE pStartNode
    )
);

PKSDATARANGE
GetStartNodeDataRange(
    PSTART_NODE pStartNode
);

PKSIDENTIFIER
GetStartNodeInterface(
    PSTART_NODE pStartNode
);

PKSIDENTIFIER
GetStartNodeMedium(
    PSTART_NODE pStartNode
);

ENUMFUNC
FindTopologyNode(
    IN PTOPOLOGY_CONNECTION pTopologyConnection,
    IN BOOL fToDirection,
    IN PTOPOLOGY_NODE pTopologyNode
);

} // extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\sysaudio\gpi.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   gpi.cpp
//
//  Description:
//
//	Graph Pin Info Class
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//  To Do:     Date	  Author      Comment
//
//@@END_MSINTERNAL
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

NTSTATUS
CGraphPinInfo::Create(
    PGRAPH_PIN_INFO *ppGraphPinInfo,
    PPIN_INFO pPinInfo,
    ULONG ulFlags,
    PGRAPH_NODE pGraphNode
)
{
    PGRAPH_PIN_INFO pGraphPinInfo = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    Assert(pPinInfo);
    Assert(pGraphNode);

    FOR_EACH_LIST_ITEM(&pGraphNode->lstGraphPinInfo, pGraphPinInfo) {

	if(pGraphPinInfo->pPinInfo == pPinInfo &&
         ((pGraphPinInfo->ulFlags ^ ulFlags) & 
	    GPI_FLAGS_RESERVE_PIN_INSTANCE) == 0) {

	    pGraphPinInfo->AddRef();
	    goto exit;
	}

    } END_EACH_LIST_ITEM

    pGraphPinInfo = new GRAPH_PIN_INFO(pPinInfo, ulFlags, pGraphNode);
    if(pGraphPinInfo == NULL) {
	Status = STATUS_INSUFFICIENT_RESOURCES;
	goto exit;
    }
    DPF2(80, "CGraphPinInfo::Create %08x GN %08x", pGraphPinInfo, pGraphNode);
exit:
    *ppGraphPinInfo = pGraphPinInfo;
    return(Status);
}

CGraphPinInfo::CGraphPinInfo(
    PPIN_INFO pPinInfo,
    ULONG ulFlags,
    PGRAPH_NODE pGraphNode
)
{
    Assert(pPinInfo);
    Assert(pGraphNode);

    this->pPinInfo = pPinInfo;
    this->ulFlags = ulFlags;
    if(ulFlags & GPI_FLAGS_RESERVE_PIN_INSTANCE) {
	this->cPinInstances.PossibleCount = 1;
	this->cPinInstances.CurrentCount = 0;
    }
    else {
	this->cPinInstances = pPinInfo->cPinInstances;
    }
    AddRef();
    AddList(&pGraphNode->lstGraphPinInfo);
    DPF2(80, "CGraphPinInfo: %08x GN %08x", this, pGraphNode);
}

CGraphPinInfo::~CGraphPinInfo(
)
{
    DPF1(80, "~CGraphPinInfo: %08x", this);
    Assert(this);
    RemoveList();
}

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\sysaudio\lfn.h ===
//---------------------------------------------------------------------------
//
//  Module:   		lfn.h
//
//  Description:	logical filter node classes
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Constants and Macros
//---------------------------------------------------------------------------

#define	LFN_FLAGS_CONNECT_CAPTURE		0x00000001
#define	LFN_FLAGS_CONNECT_RENDER		0x00000002
#define	LFN_FLAGS_CONNECT_NORMAL_TOPOLOGY	0x00000004
#define	LFN_FLAGS_CONNECT_MIXER_TOPOLOGY	0x00000008
#define	LFN_FLAGS_TOP_DOWN			0x00000010
#define	LFN_FLAGS_NO_BYPASS			0x00000020
#define	LFN_FLAGS_NOT_SELECT			0x00000040
#define	LFN_FLAGS_REFLECT_DATARANGE		0x00000080

//---------------------------------------------------------------------------
// Classes
//---------------------------------------------------------------------------

typedef class CLogicalFilterNode : public CListMultiItem
{
private:
    CLogicalFilterNode(
        PFILTER_NODE pFilterNode
    );

public:
    ~CLogicalFilterNode(
    );

    static NTSTATUS
    Create(
	PLOGICAL_FILTER_NODE *ppLogicalFilterNode,
        PFILTER_NODE pFilterNode
    );

    ENUMFUNC
    Destroy(
    )
    {
	Assert(this);
	delete this;
	return(STATUS_CONTINUE);
    };

    static NTSTATUS
    CreateAll(
	PFILTER_NODE pFilterNode
    );

    static NTSTATUS
    EnumerateFilterTopology(
	IN PTOPOLOGY_CONNECTION pTopologyConnection,
	IN BOOL fToDirection,
	IN OUT PLOGICAL_FILTER_NODE *ppLogicalFilterNode
    );

    ULONG 
    GetFlags(
    )
    {
	return(ulFlags);
    };

    BOOL
    IsRenderAndCapture(
    )
    {
	return(
	  (GetFlags() & LFN_FLAGS_CONNECT_CAPTURE) && 
	  (GetFlags() & LFN_FLAGS_CONNECT_RENDER));
    };

    VOID
    SetRenderOnly(
    )
    {
	ulFlags |= LFN_FLAGS_CONNECT_RENDER;
	ulFlags &= ~LFN_FLAGS_CONNECT_CAPTURE;
    };

    VOID
    SetCaptureOnly(
    )
    {
	ulFlags |= LFN_FLAGS_CONNECT_CAPTURE;
	ulFlags &= ~LFN_FLAGS_CONNECT_RENDER;
    };

    ULONG
    GetOverhead(
    )
    {
	return(ulOverhead);
    };

    ULONG
    GetOrder(
    )
    {
	return(ulOrder);
    };

    VOID
    SetOrder(
	ULONG ulOrder
    )
    {
	this->ulOrder = ulOrder;
    };

    ULONG 
    GetType(				// see fn.h
    );

    VOID
    SetType(
	ULONG fulType
    );

    PFILTER_NODE pFilterNode;
    LIST_DATA_PIN_NODE lstPinNode;
    LIST_DATA_TOPOLOGY_NODE lstTopologyNode;
    LIST_MULTI_TOPOLOGY_CONNECTION lstTopologyConnection;
    LIST_FILTER_NODE_INSTANCE lstFilterNodeInstance;
private:
    ULONG ulOverhead;
    ULONG ulFlags;
    ULONG ulOrder;
public:
    DefineSignature(0x204e464c);				// LFN

} LOGICAL_FILTER_NODE, *PLOGICAL_FILTER_NODE;

//---------------------------------------------------------------------------

typedef ListMultiDestroy<LOGICAL_FILTER_NODE> LIST_DESTROY_LOGICAL_FILTER_NODE;

//---------------------------------------------------------------------------

typedef ListMulti<CLogicalFilterNode> LIST_MULTI_LOGICAL_FILTER_NODE;
typedef LIST_MULTI_LOGICAL_FILTER_NODE *PLIST_MULTI_LOGICAL_FILTER_NODE;

//---------------------------------------------------------------------------
// Inline functions
//---------------------------------------------------------------------------

inline ULONG 
CPinNode::GetType(
)
{
    return(pLogicalFilterNode->GetType());
}

//---------------------------------------------------------------------------
// Globals
//---------------------------------------------------------------------------

extern ULONG gcMixers;
extern ULONG gcSplitters;
extern ULONG gcLogicalFilterNodes;
extern PLIST_MULTI_LOGICAL_FILTER_NODE gplstLogicalFilterNode;

//---------------------------------------------------------------------------
// Local prototypes
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\sysaudio\gpi.h ===
//---------------------------------------------------------------------------
//
//  Module:   		gni.h
//
//  Description:	Graph Pin Info Class
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Constants and Macros
//---------------------------------------------------------------------------

#define GPI_FLAGS_RESERVE_PIN_INSTANCE		0x00000001
#define GPI_FLAGS_PIN_INSTANCE_RESERVED		0x00000002

//---------------------------------------------------------------------------
// Class
//---------------------------------------------------------------------------

typedef class CGraphPinInfo : public CListDoubleItem
{
    friend class CConnectInfo;
private:
    CGraphPinInfo(
	PPIN_INFO pPinInfo,
	ULONG ulFlags,
	PGRAPH_NODE pGraphNode
    );

    ~CGraphPinInfo(
    );

public:
    static NTSTATUS
    Create(
	PGRAPH_PIN_INFO *ppGraphPinInfo,
	PPIN_INFO pPinInfo,
	ULONG ulFlags,
	PGRAPH_NODE pGraphNode
    );

    ENUMFUNC
    Destroy(
    )
    {
	if(this != NULL) {
	    Assert(this);
	    ASSERT(cReference > 0);

	    if(--cReference == 0) {
		delete this;
	    }
	}
	return(STATUS_CONTINUE);
    };

    VOID 
    AddRef(
    )
    {
	if(this != NULL) {
	    Assert(this);
	    ++cReference;
	}
    };

    PPIN_INFO
    GetPinInfo(
    )
    {
	Assert(this);
	return(pPinInfo);
    };

    PKSPIN_CINSTANCES
    GetPinInstances(
    )
    {
	Assert(this);
	return(&cPinInstances);
    };

    VOID
    AddPinInstance(
    )
    {
	Assert(this);
	cPinInstances.CurrentCount++;
    };

    VOID
    RemovePinInstance(
    )
    {
	Assert(this);
	cPinInstances.CurrentCount--;
    };

    BOOL
    IsPinInstances(
    )
    {
	Assert(this);
	return(cPinInstances.CurrentCount < cPinInstances.PossibleCount);
    };

    BOOL
    IsPinReserved(
    )
    {
	return(ulFlags & GPI_FLAGS_PIN_INSTANCE_RESERVED);
    };

    BOOL
    IsPossibleInstances(
    )
    {
	if(IsPinReserved()) {
	    return(cPinInstances.PossibleCount > 1);
	}
	return(cPinInstances.PossibleCount > 0);
    };

    VOID
    ReservePinInstance(
    )
    {
	Assert(this);
	ulFlags |= GPI_FLAGS_PIN_INSTANCE_RESERVED;
	cPinInstances.CurrentCount = 1;
    };

private:
    LONG cReference;
    ULONG ulFlags;
    PPIN_INFO pPinInfo;
    KSPIN_CINSTANCES cPinInstances;
public:
    DefineSignature(0x20495047);				// GPI

} GRAPH_PIN_INFO, *PGRAPH_PIN_INFO;

//---------------------------------------------------------------------------

typedef ListDouble<GRAPH_PIN_INFO> LIST_GRAPH_PIN_INFO;

//---------------------------------------------------------------------------

typedef ListData<GRAPH_PIN_INFO> LIST_DATA_GRAPH_PIN_INFO;

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\sysaudio\notify.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   notify.cpp
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//  To Do:     Date	  Author      Comment
//
//@@END_MSINTERNAL
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"

//
// Include safe string library for safe string manipulation. 
//
#define STRSAFE_NO_DEPRECATE // Use safe and unsafe functions interchangeably.
#include "strsafe.h"

#define DEVICE_NAME_TAG         L"\\\\?\\"

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

CONST GUID *apguidCategories[] = {
    &KSCATEGORY_AUDIO,
    &KSCATEGORY_AUDIO_GFX,
    &KSCATEGORY_TOPOLOGY,
    &KSCATEGORY_BRIDGE,
    &KSCATEGORY_RENDER,
    &KSCATEGORY_CAPTURE,
    &KSCATEGORY_MIXER,
    &KSCATEGORY_DATATRANSFORM,
    &KSCATEGORY_ACOUSTIC_ECHO_CANCEL,
    &KSCATEGORY_INTERFACETRANSFORM,
    &KSCATEGORY_MEDIUMTRANSFORM,
    &KSCATEGORY_DATACOMPRESSOR,
    &KSCATEGORY_DATADECOMPRESSOR,
    &KSCATEGORY_COMMUNICATIONSTRANSFORM,
    &KSCATEGORY_SPLITTER,
    &KSCATEGORY_AUDIO_SPLITTER,
    &KSCATEGORY_SYNTHESIZER,
    &KSCATEGORY_DRM_DESCRAMBLE,
    &KSCATEGORY_MICROPHONE_ARRAY_PROCESSOR,
};

ULONG aulFilterType[] = {
    FILTER_TYPE_AUDIO,
    FILTER_TYPE_GFX,
    FILTER_TYPE_TOPOLOGY,
    FILTER_TYPE_BRIDGE,
    FILTER_TYPE_RENDERER,
    FILTER_TYPE_CAPTURER,
    FILTER_TYPE_MIXER,
    FILTER_TYPE_DATA_TRANSFORM,
    FILTER_TYPE_AEC,
    FILTER_TYPE_INTERFACE_TRANSFORM,
    FILTER_TYPE_MEDIUM_TRANSFORM,
    FILTER_TYPE_DATA_TRANSFORM,
    FILTER_TYPE_DATA_TRANSFORM,
    FILTER_TYPE_COMMUNICATION_TRANSFORM,
    FILTER_TYPE_SPLITTER,
    FILTER_TYPE_SPLITTER,
    FILTER_TYPE_SYNTHESIZER,
    FILTER_TYPE_DRM_DESCRAMBLE,
    FILTER_TYPE_MIC_ARRAY_PROCESSOR,
};

PVOID pNotificationHandle = NULL;

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

NTSTATUS
RegisterForPlugPlayNotifications(
)
{
    NTSTATUS Status;

    DPF(50, "RegisterForPlugPlayNotifications");
    ASSERT(gpDeviceInstance != NULL);
    ASSERT(gpDeviceInstance->pPhysicalDeviceObject != NULL);

    Status = IoRegisterPlugPlayNotification(
      EventCategoryDeviceInterfaceChange,
      PNPNOTIFY_DEVICE_INTERFACE_INCLUDE_EXISTING_INTERFACES,
      (LPGUID)&KSCATEGORY_AUDIO,
      gpDeviceInstance->pPhysicalDeviceObject->DriverObject,
      (NTSTATUS (*)(PVOID, PVOID)) AudioDeviceInterfaceNotification,
      NULL,
      &pNotificationHandle);

    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }

exit:
    return(Status);
}

VOID
UnregisterForPlugPlayNotifications(
)
{
    if(pNotificationHandle != NULL) {
        IoUnregisterPlugPlayNotification(pNotificationHandle);
    }
}

VOID
DecrementAddRemoveCount(
)
{
    if(InterlockedDecrement(&glPendingAddDelete) == 0) {
        DPF(50, "DecrementAddRemoveCount: sending event");
        KsGenerateEventList(
          NULL,
          KSEVENT_SYSAUDIO_ADDREMOVE_DEVICE,
          &gEventQueue,
          KSEVENTS_SPINLOCK,
          &gEventLock);
    }
}

NTSTATUS
AddFilterWorker(
    PWSTR pwstrDeviceInterface,
    PVOID pReference
)
{
    AddFilter(pwstrDeviceInterface, NULL);
    ExFreePool(pwstrDeviceInterface);
    DecrementAddRemoveCount();

    // Dereference sysaudio PDO.
    KsDereferenceSoftwareBusObject(gpDeviceInstance->pDeviceHeader);

    return(STATUS_SUCCESS);
}

NTSTATUS
DeleteFilterWorker(
    PWSTR pwstrDeviceInterface,
    PVOID pReference
)
{
    DeleteFilter(pwstrDeviceInterface);
    ExFreePool(pwstrDeviceInterface);
    DecrementAddRemoveCount();

    // Dereference sysaudio PDO.
    KsDereferenceSoftwareBusObject(gpDeviceInstance->pDeviceHeader);
    
    return(STATUS_SUCCESS);
}

NTSTATUS
AudioDeviceInterfaceNotification(
    IN PDEVICE_INTERFACE_CHANGE_NOTIFICATION pNotification,
    IN PVOID Context
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PWSTR pwstrDeviceInterface;

    DPF1(50, "AudioDeviceInterfaceNotification: (%s)",
      DbgUnicode2Sz(pNotification->SymbolicLinkName->Buffer));

    //
    // SECURITY NOTE:
    // We trust the Buffer, because it is passed to us as part of notification
    // from PnP subsystem.
    //
    pwstrDeviceInterface = (PWSTR)
        ExAllocatePoolWithTag(
            PagedPool,
            (wcslen(pNotification->SymbolicLinkName->Buffer) + 1) * sizeof(WCHAR),
            POOLTAG_SYSA);
    if(pwstrDeviceInterface == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }

    // The notification sends null terminated unicode strings
    wcscpy(pwstrDeviceInterface, pNotification->SymbolicLinkName->Buffer);

    if(IsEqualGUID(&pNotification->Event, &GUID_DEVICE_INTERFACE_ARRIVAL)) {
        //
        // Keep a reference so that SWENUM does not REMOVE the device
        // when the Worker thread is running.
        // If the thread is scheduled successfully, it will remove the reference
        // when exiting.
        //
        Status = KsReferenceSoftwareBusObject(gpDeviceInstance->pDeviceHeader);
        if(!NT_SUCCESS(Status)) {
            goto exit;
        }

        InterlockedIncrement(&glPendingAddDelete);
        Status = QueueWorkList(
          (UTIL_PFN)AddFilterWorker,
          pwstrDeviceInterface,
          NULL);
        if (!NT_SUCCESS(Status)) {
            KsDereferenceSoftwareBusObject(gpDeviceInstance->pDeviceHeader);

        }
    }
    else if(IsEqualGUID(&pNotification->Event, &GUID_DEVICE_INTERFACE_REMOVAL)) {
        //
        // Keep a reference so that SWENUM does not REMOVE the device
        // when the Worker thread is running.
        // If the thread is scheduled successfully, it will remove the reference
        // when exiting.
        //
        Status = KsReferenceSoftwareBusObject(gpDeviceInstance->pDeviceHeader);
        if(!NT_SUCCESS(Status)) {
            goto exit;
        }

        InterlockedIncrement(&glPendingAddDelete);
        Status = QueueWorkList(
          (UTIL_PFN)DeleteFilterWorker,
          pwstrDeviceInterface,
          NULL);
        if (!NT_SUCCESS(Status)) {
            KsDereferenceSoftwareBusObject(gpDeviceInstance->pDeviceHeader);
        }
    }
    else {
        //
        // SECURITY NOTE:
        // Sysaudio is registering only for EventCategoryDeviceInterfaceChange.
        // This should send ARRIVAL and REMOVAL.
        // If anything else comes up, we will return SUCCESS.
        // However we are making sure that pwstrDeviceInterface is not leaked.
        //
        if (pwstrDeviceInterface) {
            ExFreePool(pwstrDeviceInterface);
            pwstrDeviceInterface = NULL;
        }
    }

exit:
    if (!NT_SUCCESS(Status))
    {
        if (pwstrDeviceInterface) {
            ExFreePool(pwstrDeviceInterface);
            pwstrDeviceInterface = NULL;
        }
    }
    
    return(Status);
}


NTSTATUS
AddFilter(
    PWSTR pwstrDeviceInterface,
    PFILTER_NODE *ppFilterNode	// if !NULL, physical connection addfilter
)
{
    PFILTER_NODE pFilterNodeDuplicate = NULL;
    PFILTER_NODE pFilterNode = NULL;
    UNICODE_STRING ustrFilterName;
    UNICODE_STRING ustrAliasName;
    UNICODE_STRING ustrName;
    NTSTATUS Status;
    ULONG fulType;
    int i;

    DPF1(50, "AddFilter: (%s)", DbgUnicode2Sz(pwstrDeviceInterface));

    fulType = 0;
    RtlInitUnicodeString(&ustrFilterName, pwstrDeviceInterface);
    
    //
    // For each Interface in apguidCategories, get interface alias of 
    // the new device. Check for duplicate interfaces.
    //
    for(i = 0; i < SIZEOF_ARRAY(apguidCategories); i++) {
        Status = IoGetDeviceInterfaceAlias(
          &ustrFilterName,
          apguidCategories[i],
          &ustrAliasName);

        if(NT_SUCCESS(Status)) {
            HANDLE hAlias;

            Status = OpenDevice(ustrAliasName.Buffer, &hAlias); 

            if(NT_SUCCESS(Status)) {
                DPF2(100, "AddFilter: alias (%s) aulFilterType %08x",
                  DbgUnicode2Sz(ustrAliasName.Buffer),
                  aulFilterType[i]);

                fulType |= aulFilterType[i];
                ZwClose(hAlias);

                if(pFilterNodeDuplicate == NULL) {
                    FOR_EACH_LIST_ITEM(gplstFilterNode, pFilterNode) {
                        if(pFilterNode->GetDeviceInterface() == NULL) {
                            continue;
                        }
                        RtlInitUnicodeString(
                          &ustrName,
                          pFilterNode->GetDeviceInterface());

                        if(RtlEqualUnicodeString(
                          &ustrAliasName,
                          &ustrName,
                          TRUE)) {
                            DPF(50, "AddFilter: dup");
                            pFilterNodeDuplicate = pFilterNode;
                            break;
                        }
                    } END_EACH_LIST_ITEM
                }
            }
            else {
                DPF1(10, "AddFilter: OpenDevice FAILED on alias (%s)",
                  DbgUnicode2Sz(ustrAliasName.Buffer));
            }
            RtlFreeUnicodeString(&ustrAliasName);
        }
    }
    
    pFilterNode = pFilterNodeDuplicate;
    Status = STATUS_SUCCESS;

    //
    // Create a new Filter_Node if this is not a duplicate.
    //
    if(pFilterNodeDuplicate == NULL) {
        pFilterNode = new FILTER_NODE(fulType);
        if(pFilterNode == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            Trap();
            goto exit;
        }
        Status = pFilterNode->Create(pwstrDeviceInterface);
        if(!NT_SUCCESS(Status)) {
            goto exit;
        }
        Status = pFilterNode->DuplicateForCapture();
        if(!NT_SUCCESS(Status)) {
            goto exit;
        }
        DPF1(50, "AddFilter: new CFilterNode fulType %08x", fulType);
    }

    //
    // If this is called from Interface Notification Callback,
    // create a new DeviceNode for the new FilterNode.
    //
    if(ppFilterNode == NULL) {
        if(pFilterNode->GetType() & FILTER_TYPE_ENDPOINT) {

            //
            // Check if a  DeviceNode has already been created for 
            // this FilterNode. 
            //
            if (NULL != pFilterNodeDuplicate && 
                NULL != pFilterNodeDuplicate->pDeviceNode) {
                DPF1(5, "Duplicate FilterNode %X. Skip DeviceNode Create", 
                    pFilterNode);
            }
            else {
                pFilterNode->pDeviceNode = new DEVICE_NODE;
                if(pFilterNode->pDeviceNode == NULL) {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    Trap();
                    goto exit;
                }
                
                Status = pFilterNode->pDeviceNode->Create(pFilterNode);
                if(!NT_SUCCESS(Status)) {
                    goto exit;
                }
            }
        }
        else {
            DPF(50, "AddFilter: DestroyAllGraphs");
            DestroyAllGraphs();
        }
    }
    
exit:
    if(!NT_SUCCESS(Status)) {
        DPF2(5, "AddFilter: FAILED (%s) %08x",
          DbgUnicode2Sz(pwstrDeviceInterface),
          Status);

        if(pFilterNode != NULL && pFilterNodeDuplicate == NULL) {
            delete pFilterNode;
            pFilterNode = NULL;
        }
    }
    if(ppFilterNode != NULL) {
        *ppFilterNode = pFilterNode;
    }
    return(Status);
}

NTSTATUS
DeleteFilter(
    PWSTR pwstrDeviceInterface
)
{
    UNICODE_STRING ustrFilterName;
    UNICODE_STRING ustrAliasName;
    UNICODE_STRING ustrName;
    PFILTER_NODE pFilterNode;
    NTSTATUS Status;
    int i;

    DPF1(50, "DeleteFilter: (%s)", DbgUnicode2Sz(pwstrDeviceInterface));

    RtlInitUnicodeString(&ustrFilterName, pwstrDeviceInterface);

    //
    // First delete all filter nodes which have the device interface which is
    // going away
    //
    FOR_EACH_LIST_ITEM_DELETE(gplstFilterNode, pFilterNode) {
        if(pFilterNode->GetDeviceInterface() == NULL) {
            continue;
        }
        RtlInitUnicodeString(
          &ustrName,
          pFilterNode->GetDeviceInterface());

        if(RtlEqualUnicodeString(
          &ustrFilterName,
          &ustrName,
          TRUE)) {
            delete pFilterNode;
            DELETE_LIST_ITEM(gplstFilterNode);
        }
    } END_EACH_LIST_ITEM

    for(i = 0; i < SIZEOF_ARRAY(apguidCategories); i++) {

        //
        // According to PnP group, it is perfectly safe to ask for aliases 
        // during removal. The interface itself will be enabled or disabled. But
        // we will still get the correct aliases.
        //
        Status = IoGetDeviceInterfaceAlias(
          &ustrFilterName,
          apguidCategories[i],
          &ustrAliasName);

        if(NT_SUCCESS(Status)) {
            FOR_EACH_LIST_ITEM_DELETE(gplstFilterNode, pFilterNode) {

                if(pFilterNode->GetDeviceInterface() == NULL) {
                    continue;
                }
                RtlInitUnicodeString(
                  &ustrName,
                  pFilterNode->GetDeviceInterface());

                if(RtlEqualUnicodeString(
                  &ustrAliasName,
                  &ustrName,
                  TRUE)) {
                    delete pFilterNode;
                    DELETE_LIST_ITEM(gplstFilterNode);
                }

            } END_EACH_LIST_ITEM

            RtlFreeUnicodeString(&ustrAliasName);
        }
    }
    
    return(STATUS_SUCCESS);
}

#define GFX_VERBOSE_LEVEL 50

//=============================================================================
// Assumptions:
//    - SysaudioGfx.ulType has been already validated.
//
NTSTATUS  AddGfx(
    PSYSAUDIO_GFX pSysaudioGfx,
    ULONG cbMaxLength
)
{
    NTSTATUS Status;
    PFILE_OBJECT pFileObject;
    PFILTER_NODE pFilterNode;
    ULONG Flags;
    PWSTR pwstrDeviceName;
    ULONG GfxOrderBase, GfxOrderCeiling;

    ASSERT(pSysaudioGfx);

    pFileObject = NULL;
    pwstrDeviceName = NULL;
    pFilterNode = NULL;
    GfxOrderBase = GfxOrderCeiling = 0;

    DPF1(GFX_VERBOSE_LEVEL, "AddGfx :: Request to add Gfx %x", pSysaudioGfx);
    DPF1(GFX_VERBOSE_LEVEL, "          hGfx    = %x", pSysaudioGfx->hGfx);
    DPF1(GFX_VERBOSE_LEVEL, "          ulOrder = %x", pSysaudioGfx->ulOrder);
    DPF1(GFX_VERBOSE_LEVEL, "          ulType  = %x", pSysaudioGfx->ulType);
    DPF1(GFX_VERBOSE_LEVEL, "          Flags   = %x", pSysaudioGfx->ulFlags);

    //
    // Setup GFX Order's base & ceiling for future usage
    //
    if (pSysaudioGfx->ulType == GFX_DEVICETYPE_RENDER) {
        GfxOrderBase = ORDER_RENDER_GFX_FIRST;
        GfxOrderCeiling = ORDER_RENDER_GFX_LAST;
    }

    if (pSysaudioGfx->ulType == GFX_DEVICETYPE_CAPTURE) {
        GfxOrderBase = ORDER_CAPTURE_GFX_FIRST;
        GfxOrderCeiling = ORDER_CAPTURE_GFX_LAST;
    }

    ASSERT(GfxOrderBase);
    ASSERT(GfxOrderCeiling);

    //
    // validate that order is within range
    //
    if (pSysaudioGfx->ulOrder >= (GfxOrderCeiling - GfxOrderBase)) {
        Status = STATUS_INVALID_PARAMETER;
        Trap();
        goto exit;
    }

    //
    // Allocate a Filter Node for the new GFX
    //
    pFilterNode = new FILTER_NODE(FILTER_TYPE_GFX);
    if(pFilterNode == NULL) {
        Trap();
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }
    
    pFilterNode->SetRenderCaptureFlags(pSysaudioGfx->ulType);
    
    //
    // Copy the Device Name (on which the gfx needs to be attached) into a local 
    // copy for our own use
    //
    Status = SafeCopyDeviceName(
        (PWSTR) ((CHAR *) pSysaudioGfx + pSysaudioGfx->ulDeviceNameOffset), 
        cbMaxLength,
        &pwstrDeviceName);
    if (!NT_SUCCESS(Status)) {
        goto exit;
    }

    DPF1(GFX_VERBOSE_LEVEL, "          On DI   = %s", DbgUnicode2Sz(pwstrDeviceName));

    //
    // Make sure that there are no other GFXes with the same order on this device
    //
    if ((FindGfx(pFilterNode,
                 0, // wild card for handle
                 pwstrDeviceName,
                 pSysaudioGfx->ulOrder+GfxOrderBase))) {
        delete [] pwstrDeviceName;
        Status = STATUS_INVALID_PARAMETER;
        goto exit;
    }

    //
    // Get the FileObject of the GFX for future use
    // SECURITY NOTE:
    // The handle is coming from UserMode. So we have to specify UserMode.
    // Also we are explicitly interested in FileObjects. The rest should be 
    // rejected.
    //
    Status = ObReferenceObjectByHandle(
      pSysaudioGfx->hGfx,
      FILE_GENERIC_READ | FILE_GENERIC_WRITE,
      *IoFileObjectType,
      UserMode,
      (PVOID*)&pFileObject,
      NULL);

    if (!NT_SUCCESS(Status) || NULL == pFileObject) {
        DPF1(GFX_VERBOSE_LEVEL, "AddGfx :: ObReference failed %x", Status);
        delete [] pwstrDeviceName;
        goto exit;
    }

    //
    // Add the device name string to global memory to be freed
    //
    Status = pFilterNode->lstFreeMem.AddList(pwstrDeviceName);
    if(!NT_SUCCESS(Status)) {
        Trap();
        delete [] pwstrDeviceName;
        goto exit;
    }

    //
    // Indicate that this Gfx needs be loaded only on the device pointed to be 
    // pwstrDeviceName
    //
    Status = pFilterNode->AddDeviceInterfaceMatch(pwstrDeviceName);
    if(!NT_SUCCESS(Status)) {
        Trap();
        delete [] pwstrDeviceName;        
        goto exit;
    }

    //
    // Set the Gfx order in the filter node
    //
    pFilterNode->SetOrder(pSysaudioGfx->ulOrder+GfxOrderBase);

    //
    // Profile the GFX and create pin infos, logical filter nodes etc
    //
    Status = pFilterNode->ProfileFilter(pFileObject);
    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }

    //
    // Fix the GFX glitching problem. Send the property blindly to GFX
    // filter. KS will handle the property.
    // Failures are not important, ignore them.
    //
    SetKsFrameHolding(pFileObject);    

exit:
    if(!NT_SUCCESS(Status)) {
        DPF1(GFX_VERBOSE_LEVEL, "AddGfx :: Failed, Status = %x", Status);
        if(pFilterNode != NULL) {
            delete pFilterNode;
            pFilterNode = NULL;
        }
        if(pFileObject != NULL) {
            ObDereferenceObject(pFileObject);
        }
    }
    else {

        DPF1(GFX_VERBOSE_LEVEL, "AddGfx :: Added GFX FilterNode %x", pFilterNode);
        DPF1(GFX_VERBOSE_LEVEL, "            order = %x", pFilterNode->GetOrder());
        DPF1(GFX_VERBOSE_LEVEL, "            type  = %x", pFilterNode->GetType());
        DPF1(GFX_VERBOSE_LEVEL, "            flags = %x", pFilterNode->GetFlags());

        //
        // Setup file handle details for later use of
        // the user mode handle passed in
        //
        pFilterNode->SetFileDetails(pSysaudioGfx->hGfx,
                                    pFileObject,
                                    PsGetCurrentProcess());
        //
        // Force a rebuild of graph nodes
        //
        DestroyAllGraphs();
    }
    return(Status);
}

//=============================================================================
// Assumptions:
//    - SysaudioGfx.ulType has been already validated.
//
NTSTATUS RemoveGfx(
    PSYSAUDIO_GFX pSysaudioGfx,
    ULONG cbMaxLength
)
{
    NTSTATUS Status;
    PFILTER_NODE pFilterNode;
    PWSTR pwstrDeviceName;
    ULONG GfxOrderBase, GfxOrderCeiling;

    pFilterNode = NULL;
    GfxOrderBase = GfxOrderCeiling = 0;
    pwstrDeviceName = NULL;

    DPF1(GFX_VERBOSE_LEVEL, "RemoveGfx :: Request to remove Gfx %x", pSysaudioGfx);
    DPF1(GFX_VERBOSE_LEVEL, "          hGfx    = %x", pSysaudioGfx->hGfx);
    DPF1(GFX_VERBOSE_LEVEL, "          ulOrder = %x", pSysaudioGfx->ulOrder);
    DPF1(GFX_VERBOSE_LEVEL, "          ulType  = %x", pSysaudioGfx->ulType);
    DPF1(GFX_VERBOSE_LEVEL, "          Flags   = %x", pSysaudioGfx->ulFlags);

    //
    // Setup GFX Order's base & ceiling for future usage
    //
    if (pSysaudioGfx->ulType == GFX_DEVICETYPE_RENDER) {
        GfxOrderBase = ORDER_RENDER_GFX_FIRST;
        GfxOrderCeiling = ORDER_RENDER_GFX_LAST;
    }

    if (pSysaudioGfx->ulType == GFX_DEVICETYPE_CAPTURE ) {
        GfxOrderBase = ORDER_CAPTURE_GFX_FIRST;
        GfxOrderCeiling = ORDER_CAPTURE_GFX_LAST;
    }

    ASSERT(GfxOrderBase);
    ASSERT(GfxOrderCeiling);

    //
    // Copy the Device Name (on which the gfx needs to be attached) into a local copy for our own use
    //
    Status = SafeCopyDeviceName(
        (PWSTR) ((CHAR *) pSysaudioGfx + pSysaudioGfx->ulDeviceNameOffset), 
        cbMaxLength,
        &pwstrDeviceName);
    if (!NT_SUCCESS(Status)) {
        goto exit;
    }

    DPF1(GFX_VERBOSE_LEVEL, "          On DI   = %s", DbgUnicode2Sz(pwstrDeviceName));

    //
    // Find the FilterNode for the Gfx
    //
    if ((pFilterNode = FindGfx(NULL,
                               pSysaudioGfx->hGfx,
                               pwstrDeviceName,
                               pSysaudioGfx->ulOrder+GfxOrderBase)) == NULL) {
        Status = STATUS_INVALID_PARAMETER;
        goto exit;
    }

    //
    // Should we validate the FileHandle Value?
    //

    //
    // Dereference the file object
    //
    pFilterNode->ClearFileDetails();
exit:
    if(!NT_SUCCESS(Status)) {
        DPF1(GFX_VERBOSE_LEVEL, "RemoveGfx :: Failed, Status = %x", Status);
        Trap();
    }
    else {
        delete pFilterNode;
    }
    delete pwstrDeviceName;
    return(Status);
}

PFILTER_NODE
FindGfx(
    PFILTER_NODE pnewFilterNode,
    HANDLE hGfx,
    PWSTR pwstrDeviceName,
    ULONG GfxOrder
)
{
    PFILTER_NODE pFilterNode;
    ULONG DeviceCount;
    UNICODE_STRING usInDevice, usfnDevice;
    PWSTR pwstr;

    DPF2(90, "FindGfx::   Looking for GFX with order = %x attached to %s)", GfxOrder, DbgUnicode2Sz(pwstrDeviceName));

    FOR_EACH_LIST_ITEM(gplstFilterNode, pFilterNode) {

        //
        // Skip the one we just added
        //
        if (pFilterNode == pnewFilterNode) {
            continue;
        }

        //
        // Check whether this pFilterNode matches the Gfx we are looking for
        //
        if (pFilterNode->DoesGfxMatch(hGfx, pwstrDeviceName, GfxOrder)) {
            return (pFilterNode);
        }

    } END_EACH_LIST_ITEM

    return(NULL);
}


//=============================================================================
//  
// Copies a UNICODE DeviceName to a new location. The source string is coming 
// from user mode.
// There are assumptions in the code that the size should be greater than 4  
// characters. (see DEVICE_NAME_TAG)
// Caller must make sure that this is BUFFERRED IO.
// 
NTSTATUS
SafeCopyDeviceName(
    PWSTR pwstrDeviceName,
    ULONG cbMaxLength,
    PWSTR *String
)
{
    NTSTATUS ntStatus;
    ULONG cchLength;
    PWSTR pwstrString = NULL;

    *String = NULL;

    //
    // SECURITY_NOTE:
    // pwstrDeviceName points to a NULL-terminated UNICODE string.
    // The string is coming from user mode, through BUFFERRED IO. So try/
    // except is not necessary. Also Probe would not catch any errors.
    // The IRP OutputBufferLength limits, the size of the string.
    //
    if (S_OK != 
        StringCchLength(pwstrDeviceName, (size_t) cbMaxLength / sizeof(WCHAR), (size_t *) &cchLength))
    {
        DPF(5, "SafeCopyDeviceName: DeviceName is not zero-terminated.");
        ntStatus = STATUS_INVALID_PARAMETER;
        goto exit;
    }

    //
    // SECURITY NOTE:
    // There are assumptions further in the code about DeviceName string.
    // Make sure those assumptions hold.
    // One assumption is that DeviceName should be greater than 4  
    // characters.
    //
    if (cchLength <= wcslen(DEVICE_NAME_TAG)) {
        DPF(5, "SafeCopyDeviceName: DeviceName is not well-formed");
        ntStatus = STATUS_INVALID_PARAMETER;
        goto exit;
    }

    pwstrString = new(WCHAR[cchLength + 1]) ;
    if(pwstrString == NULL) {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }

    //
    // SECURITY NOTE:
    // Note that Length does not include the terminating NULL.
    // Use n version of string copy in case the buffer changes.
    // Also make sure that the string is NULL terminated.
    //
    wcsncpy(pwstrString, pwstrDeviceName, cchLength);
    pwstrString[cchLength] = UNICODE_NULL;
    ntStatus = STATUS_SUCCESS;

exit:    
    *String = pwstrString;
    return ntStatus;
}

NTSTATUS
GetFilterTypeFromGuid(
    IN LPGUID pguid,
    OUT PULONG pfulType
)
{
    int i;
    for(i = 0; i < SIZEOF_ARRAY(apguidCategories); i++) {
        if (memcmp (apguidCategories[i], pguid, sizeof(GUID)) == 0) {
            *pfulType |= aulFilterType[i];
            return(STATUS_SUCCESS);
        }
    }
    return(STATUS_INVALID_DEVICE_REQUEST);
}

//---------------------------------------------------------------------------
//  End of File: notify.cpp
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\sysaudio\pi.h ===
//---------------------------------------------------------------------------
//
//  Module:   		pi.h
//
//  Description:	pin info classes
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Constants and Macros
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Classes
//---------------------------------------------------------------------------

typedef class CPinInfo : public CListSingleItem
{
public:
    CPinInfo(
	PFILTER_NODE pFilterNode,
	ULONG PinId = MAXULONG
    );
    ~CPinInfo();
    NTSTATUS Create(
	PFILE_OBJECT pFileObject
    );
    ENUMFUNC Destroy()
    {
	Assert(this);
	delete this;
	return(STATUS_CONTINUE);
    };
    ENUMFUNC CreatePhysicalConnection();

    PFILTER_NODE pFilterNode;
    KSPIN_DATAFLOW DataFlow;
    KSPIN_COMMUNICATION Communication;
    KSPIN_CINSTANCES cPinInstances;
    GUID *pguidCategory;
    GUID *pguidName;
    PWSTR pwstrName;
    LIST_DESTROY_TOPOLOGY_CONNECTION lstTopologyConnection;
    LIST_PIN_NODE lstPinNode;
    ULONG PinId;

    NTSTATUS GetPinInstances(
        PFILE_OBJECT pFileObject,
        PKSPIN_CINSTANCES pcInstances);
       
private:
    PKSPIN_PHYSICALCONNECTION pPhysicalConnection;
public:
    DefineSignature(0x20204950);		// PI

} PIN_INFO, *PPIN_INFO;

//---------------------------------------------------------------------------

typedef ListSingleDestroy<PIN_INFO> LIST_PIN_INFO;

//---------------------------------------------------------------------------
// Globals
//---------------------------------------------------------------------------

extern DATARANGES DataRangesNull;
extern IDENTIFIERS IdentifiersNull;

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\sysaudio\pi.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   pi.cpp
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//  To Do:     Date	  Author      Comment
//
//@@END_MSINTERNAL
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

DATARANGES DataRangesNull = {
    {
        sizeof(KSMULTIPLE_ITEM) + sizeof(KSDATARANGE),
        1
    },
    {
        sizeof(KSDATARANGE),
        0,
        STATICGUIDOF(GUID_NULL),
        STATICGUIDOF(GUID_NULL),
        STATICGUIDOF(GUID_NULL),
    }
};

IDENTIFIERS IdentifiersNull = {
    {
        sizeof(KSMULTIPLE_ITEM) + sizeof(KSIDENTIFIER),
        1
    },
    {
        STATICGUIDOF(GUID_NULL),
        0,
        0
    }
};

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

CPinInfo::CPinInfo(
    PFILTER_NODE pFilterNode,
    ULONG PinId
)
{
    Assert(pFilterNode);
    this->pFilterNode = pFilterNode;
    this->PinId = PinId;
    AddList(&pFilterNode->lstPinInfo);
}

CPinInfo::~CPinInfo()
{
    Assert(this);

    // Free physical connection data
    delete pPhysicalConnection;
    delete pwstrName;

}

ENUMFUNC
CPinInfo::CreatePhysicalConnection(
)
{
    NTSTATUS Status;

    Assert(this);
    if(pPhysicalConnection != NULL) {
        PFILTER_NODE pFilterNodeConnect;
        PPIN_INFO pPinInfoConnect;

        ASSERT(pPhysicalConnection->Size != 0);
        Status = AddFilter(
          pPhysicalConnection->SymbolicLinkName,
          &pFilterNodeConnect);

        if(!NT_SUCCESS(Status)) {
            DPF1(10,
              "CreatePhysicalConnection: AddFilter FAILED: %08x", Status);
            goto exit;
        }
        Assert(pFilterNodeConnect);

        FOR_EACH_LIST_ITEM(&pFilterNodeConnect->lstPinInfo, pPinInfoConnect) {

            if(pPhysicalConnection->Pin == pPinInfoConnect->PinId) {

                DPF2(50, "CreatePhysicalConnection: From %d %s",
                  PinId,
                  pFilterNode->DumpName());

                DPF2(50, "CreatePhysicalConnection: To %d %s",
                  pPinInfoConnect->PinId,
                  pPinInfoConnect->pFilterNode->DumpName());

                if(DataFlow == KSPIN_DATAFLOW_OUT &&
                   pPinInfoConnect->DataFlow == KSPIN_DATAFLOW_IN) {
                    PTOPOLOGY_CONNECTION pTopologyConnection;

                    Status = CreatePinInfoConnection(
                       &pTopologyConnection,
                       pFilterNode,
                       NULL,
                       this,
                       pPinInfoConnect);

                    if(!NT_SUCCESS(Status)) {
                       Trap();
                       goto exit;
                    }
                }
                else {
                    DPF(50, "CreatePhysicalConnection: rejected");
                }
                break;
            }

        } END_EACH_LIST_ITEM

        delete pPhysicalConnection;
        pPhysicalConnection = NULL;
    }
    Status = STATUS_CONTINUE;
exit:
    return(Status);
}

NTSTATUS CPinInfo::GetPinInstances(
    PFILE_OBJECT pFileObject,
    PKSPIN_CINSTANCES pcInstances
)
{
    NTSTATUS Status;

    Status = GetPinProperty(
      pFileObject,
      KSPROPERTY_PIN_CINSTANCES,
      PinId,
      sizeof(KSPIN_CINSTANCES),
      (PVOID) pcInstances);

    return Status;
} // GetPinInstances

NTSTATUS
CPinInfo::Create(
    PFILE_OBJECT pFileObject
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PDATARANGES pDataRanges;
    PIDENTIFIERS pInterfaces;
    PIDENTIFIERS pMediums;

    Assert(this);
    Assert(pFilterNode);

    Status = GetPinInstances(pFileObject, &cPinInstances);
    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }

    Status = GetPinProperty(
      pFileObject,
      KSPROPERTY_PIN_DATAFLOW,
      PinId,
      sizeof(KSPIN_DATAFLOW),
      (PVOID)&DataFlow);

    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }

    Status = GetPinProperty(
      pFileObject,
      KSPROPERTY_PIN_COMMUNICATION,
      PinId,
      sizeof(KSPIN_COMMUNICATION),
      (PVOID)&Communication);

    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }
    pguidCategory = new GUID;
    if(pguidCategory == NULL) {
        Trap();
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }
    Status = GetPinProperty(
      pFileObject,
      KSPROPERTY_PIN_CATEGORY,
      PinId,
      sizeof(GUID),
      (PVOID)pguidCategory);

    if(NT_SUCCESS(Status)) {
        Status = pFilterNode->lstFreeMem.AddList(pguidCategory);
        if(!NT_SUCCESS(Status)) {
            Trap();
            delete pguidCategory;
            pguidCategory = NULL;
            goto exit;
        }
    }
    else {
        delete pguidCategory;
        pguidCategory = NULL;
        if(Status != STATUS_NOT_FOUND) {
            Trap();
            goto exit;
        }
    }

    Status = GetPinPropertyEx(
      pFileObject,
      KSPROPERTY_PIN_NAME,
      PinId,
      (PVOID*)&pwstrName);

    if(!NT_SUCCESS(Status) && Status != STATUS_OBJECT_NAME_NOT_FOUND) {
        Trap();
        goto exit;
    }

    Status = GetPinPropertyEx(
      pFileObject,
      KSPROPERTY_PIN_PHYSICALCONNECTION,
      PinId,
      (PVOID*)&pPhysicalConnection);

    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }

    Status = GetPinPropertyEx(
      pFileObject,
      KSPROPERTY_PIN_INTERFACES,
      PinId,
      (PVOID*)&pInterfaces);

    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }

    if(pInterfaces == NULL || pInterfaces->MultipleItem.Count == 0) {
        delete pInterfaces;
        pInterfaces = &IdentifiersNull;
    }
    else {
        Status = pFilterNode->lstFreeMem.AddList(pInterfaces);
        if(!NT_SUCCESS(Status)) {
            Trap();
            delete pInterfaces;
            goto exit;
        }
    }

    Status = GetPinPropertyEx(
      pFileObject,
      KSPROPERTY_PIN_MEDIUMS,
      PinId,
      (PVOID*)&pMediums);

    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }

    if(pMediums == NULL || pMediums->MultipleItem.Count == 0) {
        delete pMediums;
        pMediums = &IdentifiersNull;
    }
    else {
        Status = pFilterNode->lstFreeMem.AddList(pMediums);
        if(!NT_SUCCESS(Status)) {
            Trap();
            delete pMediums;
            goto exit;
        }
    }

    Status = GetPinPropertyEx(
      pFileObject,
      KSPROPERTY_PIN_DATARANGES,
      PinId,
      (PVOID*)&pDataRanges);

    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }

    if(pDataRanges == NULL || pDataRanges->MultipleItem.Count == 0) {
        Trap();
        delete pDataRanges;
        pDataRanges = &DataRangesNull;
    }
    else {
        Status = pFilterNode->lstFreeMem.AddList(pDataRanges);
        if(!NT_SUCCESS(Status)) {
            Trap();
            delete pDataRanges;
            goto exit;
        }
    }

    Status = CPinNode::CreateAll(
      this,
      pDataRanges,
      pInterfaces,
      pMediums);

    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }

    // ISSUE-2001/05/15-alpers    
    // This is a temporary low risk solution to reverse DataRange problem.
    // This needs to be implemented properly in the future.
    //

    if (pFilterNode->GetType() & FILTER_TYPE_AEC) {
        DPF(10, "AEC Filter Pin : Reversing Data Ranges");
        lstPinNode.ReverseList();
    }

    if (pFilterNode->GetType() & FILTER_TYPE_GFX) {
        DPF(10, "GFX Filter Pin : Reversing Data Ranges");
        lstPinNode.ReverseList();
    }

exit:
    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\sysaudio\lfn.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   lfn.cpp
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//  To Do:     Date	  Author      Comment
//
//@@END_MSINTERNAL
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

ULONG gcMixers = 0;
ULONG gcSplitters = 0;
ULONG gcLogicalFilterNodes = 0;

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

NTSTATUS
CLogicalFilterNode::Create(
    OUT PLOGICAL_FILTER_NODE *ppLogicalFilterNode,
    IN PFILTER_NODE pFilterNode
)
{
    PLOGICAL_FILTER_NODE pLogicalFilterNode;
    NTSTATUS Status;

    pLogicalFilterNode = new LOGICAL_FILTER_NODE(pFilterNode);
    if(pLogicalFilterNode == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        Trap();
        goto exit;
    }
    Status = pLogicalFilterNode->AddList(&pFilterNode->lstLogicalFilterNode);
    if(!NT_SUCCESS(Status)) {
        Trap();
        delete pLogicalFilterNode;
        pLogicalFilterNode = NULL;
        goto exit;
    }
    if(pLogicalFilterNode->GetType() & FILTER_TYPE_LOGICAL_FILTER) {
        Status = pLogicalFilterNode->AddListOrdered(
          gplstLogicalFilterNode,
          FIELD_OFFSET(LOGICAL_FILTER_NODE, ulOrder));

        if(!NT_SUCCESS(Status)) {
            Trap();
            goto exit;
        }
    }
exit:
    *ppLogicalFilterNode = pLogicalFilterNode;
    return(Status);
}

CLogicalFilterNode::CLogicalFilterNode(
    PFILTER_NODE pFilterNode
)
{
    Assert(pFilterNode);
    this->pFilterNode = pFilterNode;

    // The type/order is the same as filter node
    SetType(pFilterNode->GetType());

    // Determine the overhead here, default to software (higher)
    ulOverhead = OVERHEAD_SOFTWARE;
    if(GetType() & FILTER_TYPE_ENDPOINT) {
        ulOverhead = OVERHEAD_HARDWARE;
    }

    // Count the mixers, splitters and lfns
    if(GetType() & FILTER_TYPE_MIXER) {
        ++gcMixers;
    }
    if(GetType() & FILTER_TYPE_SPLITTER) {
        ++gcSplitters;
    }
    ++gcLogicalFilterNodes;

    DPF3(60, "CLogicalFilterNode: %08x FN: %08x %s",
      this,
      pFilterNode,
      pFilterNode->DumpName());
}

CLogicalFilterNode::~CLogicalFilterNode(
)
{
    PLOGICAL_FILTER_NODE pLogicalFilterNode;
    PDEVICE_NODE pDeviceNode;
    PGRAPH_NODE pGraphNode;
    PPIN_NODE pPinNode;
    BOOL fDestroy;

    Assert(this);
    DPF2(60, "~CLogicalFilterNode: %08x %s", this, pFilterNode->DumpName());
    //
    // Need to NULL the pPinNode's LFN field because it is used in AddPinNodes
    // to indicate that this PN hasn't been assigned a LFN yet.
    //
    FOR_EACH_LIST_ITEM(&lstPinNode, pPinNode) {

        Assert(pPinNode);
        if(pPinNode->pLogicalFilterNode == this) {
            pPinNode->pLogicalFilterNode = NULL;
        }

    } END_EACH_LIST_ITEM

    FOR_EACH_LIST_ITEM(gplstDeviceNode, pDeviceNode) {

        fDestroy = FALSE;

        FOR_EACH_LIST_ITEM(
          &pDeviceNode->lstLogicalFilterNode,
          pLogicalFilterNode) {

            if(pLogicalFilterNode == this) {
                DPF2(50, "~CLogicalFilterNode: %08x GN %08x Destroy",
                  pLogicalFilterNode,
                  pGraphNode);
                fDestroy = TRUE;
                break;
            }

        } END_EACH_LIST_ITEM

        if(!fDestroy) {
            FOR_EACH_LIST_ITEM(&pDeviceNode->lstGraphNode, pGraphNode) {

                FOR_EACH_LIST_ITEM(
                  &pGraphNode->lstLogicalFilterNode,
                  pLogicalFilterNode) {

                    if(pLogicalFilterNode == this) {
                        DPF2(50, "~CLogicalFilterNode: %08x GN %08x Destroy",
                          pLogicalFilterNode,
                          pGraphNode);
                        fDestroy = TRUE;
                        break;
                    }

                } END_EACH_LIST_ITEM

            } END_EACH_LIST_ITEM
        }

        if(fDestroy) {
            pDeviceNode->lstGraphNode.DestroyList();
        }

    } END_EACH_LIST_ITEM

    if(GetType() & FILTER_TYPE_MIXER) {
        --gcMixers;
    }
    if(GetType() & FILTER_TYPE_SPLITTER) {
        --gcSplitters;
    }
    --gcLogicalFilterNodes;
}

VOID 
CLogicalFilterNode::SetType(
    ULONG fulType
)
{
    pFilterNode->SetType(fulType);
    SetOrder(pFilterNode->GetOrder());

    ulFlags = 0;
    if(GetType() & FILTER_TYPE_RENDER) {
        ulFlags |= LFN_FLAGS_CONNECT_RENDER;
    }
    if(GetType() & FILTER_TYPE_CAPTURE) {
        ulFlags |= LFN_FLAGS_CONNECT_CAPTURE;
    }
    if(GetType() & FILTER_TYPE_NORMAL_TOPOLOGY) {
        ulFlags |= LFN_FLAGS_CONNECT_NORMAL_TOPOLOGY;
    }
    if(GetType() & FILTER_TYPE_MIXER_TOPOLOGY) {
        ulFlags |= LFN_FLAGS_CONNECT_MIXER_TOPOLOGY;
    }
    if(GetType() & FILTER_TYPE_NO_BYPASS) {
        ulFlags |= LFN_FLAGS_NO_BYPASS;
    }
    if(GetType() & FILTER_TYPE_NOT_SELECT) {
        ulFlags |= LFN_FLAGS_NOT_SELECT;
    }
    if(pFilterNode->GetFlags() & FN_FLAGS_RENDER) {
        ulFlags |= LFN_FLAGS_CONNECT_RENDER;
    }
    if(pFilterNode->GetFlags() & FN_FLAGS_NO_RENDER) {
        ulFlags &= ~LFN_FLAGS_CONNECT_RENDER;
    }
    if(pFilterNode->GetFlags() & FN_FLAGS_CAPTURE) {
        ulFlags |= LFN_FLAGS_CONNECT_CAPTURE;
    }
    if(pFilterNode->GetFlags() & FN_FLAGS_NO_CAPTURE) {
        ulFlags &= ~LFN_FLAGS_CONNECT_CAPTURE;
    }
}

NTSTATUS
SwitchLogicalFilterNodes(
    IN PLOGICAL_FILTER_NODE pLogicalFilterNode,
    IN OUT PLOGICAL_FILTER_NODE *ppLogicalFilterNode
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PTOPOLOGY_NODE pTopologyNode;
    PPIN_NODE pPinNode;

    Assert(pLogicalFilterNode);
    Assert(*ppLogicalFilterNode);
    if(pLogicalFilterNode != *ppLogicalFilterNode) {

        FOR_EACH_LIST_ITEM(&(*ppLogicalFilterNode)->lstPinNode, pPinNode) {
            Assert(pPinNode);
            pPinNode->pLogicalFilterNode = pLogicalFilterNode;
        } END_EACH_LIST_ITEM

        pLogicalFilterNode->lstPinNode.JoinList(
          &(*ppLogicalFilterNode)->lstPinNode);

        FOR_EACH_LIST_ITEM(
          &(*ppLogicalFilterNode)->lstTopologyNode,
          pTopologyNode) {
            Assert(pTopologyNode);

            (*ppLogicalFilterNode)->RemoveList(
              &pTopologyNode->lstLogicalFilterNode);

            Status = pLogicalFilterNode->AddList(
              &pTopologyNode->lstLogicalFilterNode);

            if(!NT_SUCCESS(Status)) {
                Trap();
                goto exit;
            }
            Status = pLogicalFilterNode->lstTopologyNode.AddList(pTopologyNode);
            if(!NT_SUCCESS(Status)) {
                Trap();
                goto exit;
            }

        } END_EACH_LIST_ITEM

        pLogicalFilterNode->lstTopologyConnection.JoinList(
          &(*ppLogicalFilterNode)->lstTopologyConnection);

        delete *ppLogicalFilterNode;
        *ppLogicalFilterNode = pLogicalFilterNode;
    }
exit:
    return(Status);
}

NTSTATUS
AddPinNodes(
    IN PPIN_INFO pPinInfo,
    IN OUT PLOGICAL_FILTER_NODE *ppLogicalFilterNode
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PPIN_NODE pPinNode;

    Assert(pPinInfo);
    Assert(*ppLogicalFilterNode);

    FOR_EACH_LIST_ITEM(&pPinInfo->lstPinNode, pPinNode) {

        if(pPinNode->pLogicalFilterNode == NULL) {
            pPinNode->pLogicalFilterNode = *ppLogicalFilterNode;
        }
        else {
            Status = SwitchLogicalFilterNodes(
              pPinNode->pLogicalFilterNode,
              ppLogicalFilterNode);

            if(!NT_SUCCESS(Status)) {
                Trap();
                goto exit;
            }
        }
        Status = (*ppLogicalFilterNode)->lstPinNode.AddList(pPinNode);
        if(!NT_SUCCESS(Status)) {
            Trap();
            goto exit;
        }
        DPF2(100, "AddPinNodes: add PN %08x LFN %08x",
          pPinNode,
          *ppLogicalFilterNode);

    } END_EACH_LIST_ITEM
exit:
    return(Status);
}

NTSTATUS
CLogicalFilterNode::EnumerateFilterTopology(
    IN PTOPOLOGY_CONNECTION pTopologyConnection,
    IN BOOL fToDirection,
    IN OUT PLOGICAL_FILTER_NODE *ppLogicalFilterNode
)
{
    PTOPOLOGY_NODE pTopologyNode;
    NTSTATUS Status;

    Assert(pTopologyConnection);
    DPF5(100, "EFT: PIF %08x PIT %08x TPF %08x TPT %08x f %x",
      pTopologyConnection->pPinInfoFrom,
      pTopologyConnection->pPinInfoTo,
      pTopologyConnection->pTopologyPinFrom,
      pTopologyConnection->pTopologyPinTo,
      fToDirection);

    if(!fToDirection) {
        Status = STATUS_DEAD_END;
        goto exit;
    }
    if(IS_CONNECTION_TYPE(pTopologyConnection, FILTER)) {

        if(pTopologyConnection->pPinInfoFrom != NULL) {
            Assert(pTopologyConnection->pPinInfoFrom);

            if(*ppLogicalFilterNode == NULL) {

                Status = CLogicalFilterNode::Create(
                  ppLogicalFilterNode,
                  pTopologyConnection->pPinInfoFrom->pFilterNode);

                if(!NT_SUCCESS(Status)) {
                    Trap();
                    goto exit;
                }
            }

            Status = AddPinNodes(
              pTopologyConnection->pPinInfoFrom,
              ppLogicalFilterNode);

            if(!NT_SUCCESS(Status)) {
                Trap();
                goto exit;
            }
            DPF2(100, "EFT: add from PI %08x LFN %08x",
              pTopologyConnection->pPinInfoFrom,
              *ppLogicalFilterNode);
        }
        ASSERT(*ppLogicalFilterNode != NULL);
        Assert(*ppLogicalFilterNode);

        if(pTopologyConnection->pPinInfoTo != NULL) {

            Status = AddPinNodes(
              pTopologyConnection->pPinInfoTo,
              ppLogicalFilterNode);

            if(!NT_SUCCESS(Status)) {
                Trap();
                goto exit;
            }
            DPF2(100, "EFT: add to PI %08x LFN %08x",
              pTopologyConnection->pPinInfoTo,
              *ppLogicalFilterNode);
        }

        if(pTopologyConnection->pTopologyPinTo != NULL) {
            Assert(pTopologyConnection->pTopologyPinTo);
            pTopologyNode = pTopologyConnection->pTopologyPinTo->pTopologyNode;
            Assert(pTopologyNode);

            Status = (*ppLogicalFilterNode)->lstTopologyNode.AddList(
              pTopologyNode);

            if(!NT_SUCCESS(Status)) {
                Trap();
                goto exit;
            }

            if(IsEqualGUID(
              &KSNODETYPE_ACOUSTIC_ECHO_CANCEL,
              pTopologyNode->pguidType)) {

                Assert(*ppLogicalFilterNode);
                (*ppLogicalFilterNode)->SetType(FILTER_TYPE_AEC);
                if(pTopologyConnection->pTopologyPinTo->ulPinNumber ==
                   KSNODEPIN_AEC_RENDER_IN) {
                    (*ppLogicalFilterNode)->SetRenderOnly();
                }
                else {
                    ASSERT(
                     pTopologyConnection->pTopologyPinTo->ulPinNumber ==
                     KSNODEPIN_AEC_CAPTURE_IN);
                    (*ppLogicalFilterNode)->SetCaptureOnly();
                }
                Status = (*ppLogicalFilterNode)->AddList(
                  &pTopologyNode->lstLogicalFilterNode);

                if(!NT_SUCCESS(Status)) {
                    Trap();
                    goto exit;
                }
            }
            else {
                if(pTopologyNode->lstLogicalFilterNode.IsLstEmpty()) {
                    Assert(*ppLogicalFilterNode);

                    Status = (*ppLogicalFilterNode)->AddList(
                      &pTopologyNode->lstLogicalFilterNode);

                    if(!NT_SUCCESS(Status)) {
                        Trap();
                        goto exit;
                    }
                }
                else {
                    Status = SwitchLogicalFilterNodes(
                      (PLOGICAL_FILTER_NODE)
                        pTopologyNode->lstLogicalFilterNode.GetListFirstData(),
                      ppLogicalFilterNode);

                    if(!NT_SUCCESS(Status)) {
                        Trap();
                        goto exit;
                    }
                }
            }
            DPF2(100, "EFT: add to PI %08x LFN %08x",
              pTopologyConnection->pPinInfoTo,
              *ppLogicalFilterNode);
        }
    }
    Status = pTopologyConnection->AddList(
      &(*ppLogicalFilterNode)->lstTopologyConnection);

    if(!NT_SUCCESS(Status)) {
	Trap();
	goto exit;
    }

    if(IS_CONNECTION_TYPE(pTopologyConnection, FILTER)) {
	Status = STATUS_CONTINUE;
    }
    else {
	Status = STATUS_DEAD_END;
    }
exit:
    return(Status);
}

NTSTATUS
CLogicalFilterNode::CreateAll(
    PFILTER_NODE pFilterNode
)
{
    PLOGICAL_FILTER_NODE pLogicalFilterNode;
    NTSTATUS Status = STATUS_SUCCESS;
    PPIN_INFO pPinInfo;
    PPIN_NODE pPinNode;

    DPF2(100, "CLFN::CreateAll: FN %08x %s",
      pFilterNode,
      pFilterNode->DumpName());

    //
    // Split up the filter into logical filter nodes. 
    //
    FOR_EACH_LIST_ITEM(&pFilterNode->lstPinInfo, pPinInfo) {

        pLogicalFilterNode = NULL;
        Status = EnumerateTopology(
          pPinInfo,
          (TOP_PFN)EnumerateFilterTopology,
          &pLogicalFilterNode);

        if(Status == STATUS_CONTINUE) {
            Status = STATUS_SUCCESS;
        }
        else {
            if(!NT_SUCCESS(Status)) {
                goto exit;
            }
        }

    } END_EACH_LIST_ITEM

    //
    // Look at the pins of each LFN and determine if it could possibly
    // be a capture or render filter (or both).
    //
    FOR_EACH_LIST_ITEM(
      &pFilterNode->lstLogicalFilterNode,
      pLogicalFilterNode) {
        ULONG ulPossibleFlags;

        ulPossibleFlags = 0;
        pLogicalFilterNode->ulFlags |= LFN_FLAGS_REFLECT_DATARANGE;
        FOR_EACH_LIST_ITEM(&pLogicalFilterNode->lstPinNode, pPinNode) {

            // Don't care about the major format
            if(!IsEqualGUID(
              &pPinNode->pDataRange->SubFormat,
              &KSDATAFORMAT_SUBTYPE_WILDCARD) ||

               !IsEqualGUID(
              &pPinNode->pDataRange->Specifier,
              &KSDATAFORMAT_SPECIFIER_WILDCARD)) {
                pLogicalFilterNode->ulFlags &= ~LFN_FLAGS_REFLECT_DATARANGE;
            }

            switch(pPinNode->pPinInfo->Communication) {
                case KSPIN_COMMUNICATION_BOTH:
                    ulPossibleFlags |=
                      LFN_FLAGS_CONNECT_CAPTURE | LFN_FLAGS_CONNECT_RENDER;
                    break;
                case KSPIN_COMMUNICATION_SOURCE:
                    switch(pPinNode->pPinInfo->DataFlow) {
                        case KSPIN_DATAFLOW_IN:
                            ulPossibleFlags |= LFN_FLAGS_CONNECT_CAPTURE;
                            break;
                        case KSPIN_DATAFLOW_OUT:
                            ulPossibleFlags |= LFN_FLAGS_CONNECT_RENDER;
                            break;
                    }
                    break;
                case KSPIN_COMMUNICATION_SINK:
                    switch(pPinNode->pPinInfo->DataFlow) {
                        case KSPIN_DATAFLOW_IN:
                            ulPossibleFlags |= LFN_FLAGS_CONNECT_RENDER;
                            break;
                        case KSPIN_DATAFLOW_OUT:
                            ulPossibleFlags |= LFN_FLAGS_CONNECT_CAPTURE;
                            break;
                    }
                    break;
            }
            if(ulPossibleFlags ==
              (LFN_FLAGS_CONNECT_CAPTURE | LFN_FLAGS_CONNECT_RENDER)) {
                break;
            }

        } END_EACH_LIST_ITEM

        pLogicalFilterNode->ulFlags =
          (ulPossibleFlags & pLogicalFilterNode->GetFlags()) |
          (pLogicalFilterNode->GetFlags() & 
            ~(LFN_FLAGS_CONNECT_CAPTURE | LFN_FLAGS_CONNECT_RENDER));

    } END_EACH_LIST_ITEM
exit:
    return(Status);
}

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\sysaudio\pins.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   pins.c
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     S.Mohanraj
//
//  History:   Date	  Author      Comment
//
//  To Do:     Date	  Author      Comment
//
//@@END_MSINTERNAL
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------


#include "common.h"


//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

DEFINE_KSDISPATCH_TABLE(
    PinDispatchTable,
    CPinInstance::PinDispatchIoControl,		// Ioctl
    CInstance::DispatchForwardIrp,		// Read
    CInstance::DispatchForwardIrp,		// Write
    DispatchInvalidDeviceRequest,		// Flush
    CPinInstance::PinDispatchClose,		// Close
    DispatchInvalidDeviceRequest,		// QuerySecurity
    DispatchInvalidDeviceRequest,		// SetSeturity
    DispatchFastIoDeviceControlFailure,		// FastDeviceIoControl
    DispatchFastReadFailure,			// FastRead
    DispatchFastWriteFailure			// FastWrite
);

DEFINE_KSPROPERTY_TABLE(SysaudioPinPropertyHandlers) {
    DEFINE_KSPROPERTY_ITEM(
        KSPROPERTY_SYSAUDIO_TOPOLOGY_CONNECTION_INDEX,	// idProperty
        GetTopologyConnectionIndex,			// pfnGetHandler
        sizeof(KSPROPERTY),				// cbMinGetPropertyInput
        sizeof(ULONG),					// cbMinGetDataInput
        NULL,						// pfnSetHandler
        NULL,						// Values
        0,						// RelationsCount
        NULL,						// Relations
        NULL,						// SupportHandler
        0						// SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM(
        KSPROPERTY_SYSAUDIO_ATTACH_VIRTUAL_SOURCE,	// idProperty
        NULL,				    // pfnGetHandler
        sizeof(SYSAUDIO_ATTACH_VIRTUAL_SOURCE),		// cbMinGetPropertyInput
        0,						// cbMinGetDataInput
        AttachVirtualSource,				// pfnSetHandler
        NULL,						// Values
        0,						// RelationsCount
        NULL,						// Relations
        NULL,						// SupportHandler
        0						// SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM(
        KSPROPERTY_SYSAUDIO_PIN_VOLUME_NODE,		// idProperty
        GetPinVolumeNode,				// pfnGetHandler
        sizeof(KSPROPERTY),				// cbMinGetPropertyInput
        sizeof(ULONG),					// cbMinGetDataInput
        NULL,						// pfnSetHandler
        NULL,						// Values
        0,						// RelationsCount
        NULL,						// Relations
        NULL,						// SupportHandler
        0						// SerializedSize
    ),
};

DEFINE_KSPROPERTY_TABLE(PinConnectionHandlers) {
    DEFINE_KSPROPERTY_ITEM(
	KSPROPERTY_CONNECTION_STATE,			// idProperty
        CPinInstance::PinStateHandler,			// pfnGetHandler
        sizeof(KSPROPERTY),				// cbMinGetPropertyInput
        sizeof(ULONG),					// cbMinGetDataInput
        CPinInstance::PinStateHandler,			// pfnSetHandler
        NULL,						// Values
        0,						// RelationsCount
        NULL,						// Relations
        NULL,						// SupportHandler
        0						// SerializedSize
    )
};

DEFINE_KSPROPERTY_TABLE (AudioPinPropertyHandlers)
{
    DEFINE_KSPROPERTY_ITEM(
    	KSPROPERTY_AUDIO_VOLUMELEVEL,
    	PinVirtualPropertyHandler,
    	sizeof(KSNODEPROPERTY_AUDIO_CHANNEL),
    	sizeof(LONG),
    	PinVirtualPropertyHandler,
    	&PropertyValuesVolume,
        0,
        NULL,
        (PFNKSHANDLER)PinVirtualPropertySupportHandler,
        0
    )
};

DEFINE_KSPROPERTY_SET_TABLE(PinPropertySet)
{
    DEFINE_KSPROPERTY_SET(
       &KSPROPSETID_Connection,				// Set
       SIZEOF_ARRAY(PinConnectionHandlers),		// PropertiesCount
       PinConnectionHandlers,				// PropertyItem
       0,						// FastIoCount
       NULL						// FastIoTable
    ),
    DEFINE_KSPROPERTY_SET(
       &KSPROPSETID_Sysaudio_Pin,			// Set
       SIZEOF_ARRAY(SysaudioPinPropertyHandlers),	// PropertiesCount
       SysaudioPinPropertyHandlers,			// PropertyItem
       0,						// FastIoCount
       NULL						// FastIoTable
    ),
    DEFINE_KSPROPERTY_SET(
       &KSPROPSETID_Audio,                              // Set
       SIZEOF_ARRAY(AudioPinPropertyHandlers),          // PropertiesCount
       AudioPinPropertyHandlers,                        // PropertyItem
       0,                                               // FastIoCount
       NULL                                             // FastIoTable
    )
};

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

CPinInstance::CPinInstance(
    IN PPARENT_INSTANCE pParentInstance
) : CInstance(pParentInstance)
{
}

CPinInstance::~CPinInstance(
)
{
    PGRAPH_NODE_INSTANCE pGraphNodeInstance;

    Assert(this);
    Assert(pFilterInstance);
    DPF1(100, "~CPinInstance: %08x", this);
    if(pStartNodeInstance != NULL) {
        pGraphNodeInstance = pFilterInstance->pGraphNodeInstance;
        if(pGraphNodeInstance != NULL) {
            Assert(pGraphNodeInstance);
            ASSERT(PinId < pGraphNodeInstance->cPins);
            ASSERT(pGraphNodeInstance->pacPinInstances != NULL);
            ASSERT(pGraphNodeInstance->pacPinInstances[PinId].CurrentCount > 0);

            pGraphNodeInstance->pacPinInstances[PinId].CurrentCount--;
        }
        else {
            DPF2(10, "~CPinInstance PI %08x FI %08x no GNI",
              this,
              pFilterInstance);
        }
        pStartNodeInstance->Destroy();
    }
    else {
        DPF2(10, "~CPinInstance PI %08x FI %08x no SNI",
          this,
          pFilterInstance);
    }
}

NTSTATUS
CPinInstance::PinDispatchCreate(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
)
{
    PGRAPH_NODE_INSTANCE pGraphNodeInstance;
    PPIN_INSTANCE pPinInstance = NULL;
    PKSPIN_CONNECT pPinConnect = NULL;
    NTSTATUS Status;

    ::GrabMutex();

    Status = GetRelatedGraphNodeInstance(pIrp, &pGraphNodeInstance);
    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
    Assert(pGraphNodeInstance);
    ASSERT(pGraphNodeInstance->pacPinInstances != NULL);
    ASSERT(pGraphNodeInstance->paPinDescriptors != NULL);

    //
    // Get the PinConnect structure from KS.
    // This function will copy creation parameters to pPinConnect.
    // Also do a basic connectibility testing by comparing KSDATAFORMAT of 
    // pin descriptors and the request.
    //
    Status = KsValidateConnectRequest(
      pIrp,
      pGraphNodeInstance->cPins,
      pGraphNodeInstance->paPinDescriptors,
      &pPinConnect);

    if(!NT_SUCCESS(Status)) {
#ifdef DEBUG
        DPF1(60, "PinDispatchCreate: KsValidateConnectReq FAILED %08x", Status);

        if(pPinConnect != NULL) {
            DumpPinConnect(60, pPinConnect);
        }
#endif
        goto exit;
    }

    ASSERT(pPinConnect->PinId < pGraphNodeInstance->cPins);

    //
    // Validate the integrity of AudioDataFormat.
    // Note that IO subsystem and KS will make sure that pPinConnect is 
    // at least sizeof(KSPIN_CONNECT) + sizeof(KSDATAFORMAT). Also they make
    // sure that it is probed and buffered properly.
    //
    // Note that Midi formats are OK because they do not have a specifier.
    //
    Status = ValidateDataFormat((PKSDATAFORMAT) pPinConnect + 1);
    if (!NT_SUCCESS(Status))
    {
        goto exit;
    }

#ifdef DEBUG
    DPF(60, "PinDispatchCreate:");
    DumpPinConnect(60, pPinConnect);
#endif

    // Check the pin instance count
    if(!pGraphNodeInstance->IsPinInstances(pPinConnect->PinId)) {
        DPF4(60, "PinDispatchCreate: not enough ins GNI %08x #%d C %d P %d",
         pGraphNodeInstance,
         pPinConnect->PinId,
         pGraphNodeInstance->pacPinInstances[pPinConnect->PinId].CurrentCount,
         pGraphNodeInstance->pacPinInstances[pPinConnect->PinId].PossibleCount);
        Status = STATUS_DEVICE_BUSY;
        goto exit;
    }

    // Allocate per pin instance data
    pPinInstance = new PIN_INSTANCE(
      &pGraphNodeInstance->pFilterInstance->ParentInstance);
    if(pPinInstance == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }
    // Setup the pin's instance data
    pPinInstance->ulVolumeNodeNumber = MAXULONG;
    pPinInstance->pFilterInstance = pGraphNodeInstance->pFilterInstance;
    pPinInstance->PinId = pPinConnect->PinId;

    Status = pPinInstance->DispatchCreate(
      pIrp,
      (UTIL_PFN)PinDispatchCreateKP,
      pPinConnect,
      0,
      NULL,
      &PinDispatchTable);

    pPinConnect->PinId = pPinInstance->PinId;
    if(!NT_SUCCESS(Status)) {
#ifdef DEBUG
        DPF1(60, "PinDispatchCreate: FAILED: %08x ", Status);
        DumpPinConnect(60, pPinConnect);
#endif
        goto exit;
    }
    // Increment the reference count on this pin
    ASSERT(pPinInstance->pStartNodeInstance != NULL);
    ASSERT(pGraphNodeInstance->pacPinInstances != NULL);
    pGraphNodeInstance->pacPinInstances[pPinInstance->PinId].CurrentCount++;
exit:
    if(!NT_SUCCESS(Status)) {
        delete pPinInstance;
    }
    ::ReleaseMutex();

    pIrp->IoStatus.Status = Status;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);
    return Status;
}

NTSTATUS
CPinInstance::PinDispatchCreateKP(
    PPIN_INSTANCE pPinInstance,
    PKSPIN_CONNECT pPinConnect
)
{
    PWAVEFORMATEX pWaveFormatExRequested = NULL;
    PFILTER_INSTANCE pFilterInstance;
    PSTART_NODE pStartNode;
    NTSTATUS Status;

    Assert(pPinInstance);
    pFilterInstance = pPinInstance->pFilterInstance;
    Assert(pFilterInstance);
    ASSERT(pPinInstance->PinId < pFilterInstance->pGraphNodeInstance->cPins);
    ASSERT(pPinConnect->PinId < pFilterInstance->pGraphNodeInstance->cPins);

    //
    // SECURITY NOTE: 
    // pPinConnect and following buffer is fully validated at this point. 
    // So it is totally safe to call GetWaveFormatExFromKsDataFormat.
    // 
    pWaveFormatExRequested = 
        GetWaveFormatExFromKsDataFormat(PKSDATAFORMAT(pPinConnect + 1), NULL);

    if(pWaveFormatExRequested != NULL) {
        // Fix SampleSize if zero
        if(PKSDATAFORMAT(pPinConnect + 1)->SampleSize == 0) {
            PKSDATAFORMAT(pPinConnect + 1)->SampleSize = 
              pWaveFormatExRequested->nBlockAlign;
        }
    }

    //
    // Try each start node until success
    //
    Status = STATUS_INVALID_DEVICE_REQUEST;

    //
    // First loop through all the start nodes which are not marked SECONDPASS
    // and try to create a StartNodeInstance
    //
    FOR_EACH_LIST_ITEM(
      pFilterInstance->pGraphNodeInstance->aplstStartNode[pPinInstance->PinId],
      pStartNode) {

        Assert(pStartNode);
        Assert(pFilterInstance);

        if(pStartNode->ulFlags & STARTNODE_FLAGS_SECONDPASS) {
            continue;
        }

        if(pFilterInstance->pGraphNodeInstance->IsGraphValid(
          pStartNode,
          pPinInstance->PinId)) {

            Status = CStartNodeInstance::Create(
              pPinInstance,
              pStartNode,
              pPinConnect,
              pWaveFormatExRequested);
            if(NT_SUCCESS(Status)) {
                break;
            }
        }

    } END_EACH_LIST_ITEM

    //
    // If first pass failed to create an instance try all the second pass
    // StartNodes in the list. This is being done for creating paths with no GFX
    // because we created a path with AEC and no GFX earlier.
    //
    if(!NT_SUCCESS(Status)) {
        FOR_EACH_LIST_ITEM(
          pFilterInstance->pGraphNodeInstance->aplstStartNode[pPinInstance->PinId],
          pStartNode) {

            Assert(pStartNode);
            Assert(pFilterInstance);

            if((pStartNode->ulFlags & STARTNODE_FLAGS_SECONDPASS) == 0) {
                continue;
            }

            if(pFilterInstance->pGraphNodeInstance->IsGraphValid(
              pStartNode,
              pPinInstance->PinId)) {

                Status = CStartNodeInstance::Create(
                  pPinInstance,
                  pStartNode,
                  pPinConnect,
                  pWaveFormatExRequested);
                if(NT_SUCCESS(Status)) {
                    break;
                }
            }
        } END_EACH_LIST_ITEM

        if(!NT_SUCCESS(Status)) {
            goto exit;
        }
    }
    Status = pPinInstance->SetNextFileObject(
      pPinInstance->pStartNodeInstance->pPinNodeInstance->hPin);

    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }

exit:
    return(Status);
}

NTSTATUS
CPinInstance::PinDispatchClose(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
)
{
    PIO_STACK_LOCATION pIrpStack;
    PPIN_INSTANCE pPinInstance;

    ::GrabMutex();

    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );
    pPinInstance = (PPIN_INSTANCE)pIrpStack->FileObject->FsContext;
    Assert(pPinInstance);
    pIrpStack->FileObject->FsContext = NULL;
    delete pPinInstance;

    ::ReleaseMutex();

    pIrp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}

NTSTATUS
CPinInstance::PinDispatchIoControl(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
)
{
    NTSTATUS Status;
    PSTART_NODE_INSTANCE pStartNodeInstance;
    PIO_STACK_LOCATION pIrpStack;
    PKSIDENTIFIER pKsIdentifier;
    PPIN_INSTANCE pPinInstance;
    BOOL fIsAllocated;

#ifdef DEBUG
    DumpIoctl(pIrp, "Pin", DBG_IOCTL_LOG);
#endif

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
    fIsAllocated = FALSE;
    pKsIdentifier = NULL;

    //
    // If sysaudio is not interested with this IOCTL code then forward
    // the request.
    //
    if (!IsSysaudioIoctlCode(pIrpStack->Parameters.DeviceIoControl.IoControlCode))
    {
        return DispatchForwardIrp(pDeviceObject, pIrp);
    }

    //
    // Validate input/output buffers. From this point on we can assume 
    // that all parameters are validated and copied to kernel mode.
    // Irp->AssociatedIrp->SystemBuffer should now contain both 
    // input and output buffers.
    //
    Status = ValidateDeviceIoControl(pIrp);
    if (!NT_SUCCESS(Status)) 
    {
        goto exit1;
    }

    ::GrabMutex();

    pPinInstance = (PPIN_INSTANCE)pIrpStack->FileObject->FsContext;
    Status = pPinInstance->GetStartNodeInstance(&pStartNodeInstance);
    if (!NT_SUCCESS(Status)) 
    {
        goto exit;
    }
    Assert(pPinInstance->pFilterInstance);
    Assert(pPinInstance->pFilterInstance->pGraphNodeInstance);

    //
    // Extract the Identifier from the Irp. Only known error codes will cause a
    // real failure.
    // 
    Status = GetKsIdentifierFromIrp(pIrp, &pKsIdentifier, &fIsAllocated);
    if (!NT_SUCCESS(Status))
    {
        goto exit;
    }
    
    //
    // This check allows the actual node or filter return the set's
    // supported, etc. instead of always return only the sets sysaudio
    // supports.
    //
    if (pKsIdentifier) 
    {
        if (IsIoctlForTopologyNode(
            pIrpStack->Parameters.DeviceIoControl.IoControlCode,
            pKsIdentifier->Flags))
        {
            Status = ForwardIrpNode(
                pIrp,
                pKsIdentifier,
                pPinInstance->pFilterInstance,
                pPinInstance);
            goto exit2;
        }
    }

    //
    // Handle the request.
    //
    switch(pIrpStack->Parameters.DeviceIoControl.IoControlCode) 
    {
        case IOCTL_KS_PROPERTY:
            Status = KsPropertyHandler(
              pIrp,
              SIZEOF_ARRAY(PinPropertySet),
              (PKSPROPERTY_SET)PinPropertySet);

            if(Status != STATUS_NOT_FOUND &&
               Status != STATUS_PROPSET_NOT_FOUND) 
            {
                break;
            }
            // Fall through if property not found

        case IOCTL_KS_ENABLE_EVENT:
        case IOCTL_KS_DISABLE_EVENT:
        case IOCTL_KS_METHOD:

            // NOTE: ForwardIrpNode releases gMutex
            Status = ForwardIrpNode(
              pIrp,
              pKsIdentifier,
              pPinInstance->pFilterInstance,
              pPinInstance);
            goto exit2;

        default:
            Status = STATUS_UNSUCCESSFUL;
            ASSERT(FALSE);	// Can't happen because of IsSysaudioIoctlCode
    }
exit:
    ::ReleaseMutex();

exit1:    

    pIrp->IoStatus.Status = Status;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

exit2:
    if (fIsAllocated) 
    {
        delete [] pKsIdentifier;
    }
    return(Status);
}

NTSTATUS 
CPinInstance::PinStateHandler
(
    IN PIRP pIrp,
    IN PKSPROPERTY pProperty,
    IN OUT PKSSTATE pState
)
{
    PSTART_NODE_INSTANCE pStartNodeInstance;
    NTSTATUS Status = STATUS_SUCCESS;
#ifdef DEBUG
    extern PSZ apszStates[];
#endif
    Status = ::GetStartNodeInstance(pIrp, &pStartNodeInstance);
    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }
    if(pProperty->Flags & KSPROPERTY_TYPE_GET) {
        *pState = pStartNodeInstance->CurrentState;
        pIrp->IoStatus.Information = sizeof(KSSTATE);
        if(*pState == KSSTATE_PAUSE) {
            if(pStartNodeInstance->pPinNodeInstance->
              pPinNode->pPinInfo->DataFlow == KSPIN_DATAFLOW_OUT) {
                Status = STATUS_NO_DATA_DETECTED;
            }
        }
    }
    else {
        ASSERT(pProperty->Flags & KSPROPERTY_TYPE_SET);

        DPF3(90, "PinStateHandler from %s to %s - SNI: %08x",
          apszStates[pStartNodeInstance->CurrentState],
          apszStates[*pState],
          pStartNodeInstance);

        Status = pStartNodeInstance->SetState(*pState, 0);
        if(!NT_SUCCESS(Status)) {
            DPF1(90, "PinStateHandler FAILED: %08x", Status);
            goto exit;
        }
    }
exit:
    return(Status);
}

NTSTATUS
GetRelatedStartNodeInstance(
    IN PIRP pIrp,
    OUT PSTART_NODE_INSTANCE *ppStartNodeInstance
)
{
    ASSERT(ppStartNodeInstance);

    PPIN_INSTANCE pPinInstance = 
        (PPIN_INSTANCE) IoGetCurrentIrpStackLocation(pIrp)->FileObject->
            RelatedFileObject->FsContext;
    if (NULL != pPinInstance) {
        return pPinInstance->GetStartNodeInstance(ppStartNodeInstance);
    }

    //
    // SECURITY NOTE:
    // This is in critical code path. Nearly all dispatch functions call this
    // routine.
    // So be a little defensive for cases where FsContext is not valid.
    //
    DPF(5, "GetRelatedStartNodeInstance : FsContext is NULL");
    return STATUS_UNSUCCESSFUL;
}

NTSTATUS
GetStartNodeInstance(
    IN PIRP pIrp,
    OUT PSTART_NODE_INSTANCE *ppStartNodeInstance
)
{
    ASSERT(ppStartNodeInstance);

    PPIN_INSTANCE pPinInstance = 
        (PPIN_INSTANCE) IoGetCurrentIrpStackLocation(pIrp)->
            FileObject->FsContext;
    if (NULL != pPinInstance) {
        return pPinInstance->GetStartNodeInstance(ppStartNodeInstance);
    }

    //
    // SECURITY NOTE:
    // This is in critical code path. Nearly all dispatch functions call this
    // routine.
    // So be a little defensive for cases where FsContext is not valid.
    //
    DPF(5, "GetStartNodeInstance : FsContext is NULL");
    return STATUS_UNSUCCESSFUL;
}

NTSTATUS
CPinInstance::GetStartNodeInstance(
    OUT PSTART_NODE_INSTANCE *ppStartNodeInstance
)
{
    NTSTATUS Status = STATUS_SUCCESS;

    ASSERT(ppStartNodeInstance);

    if(this == NULL || pStartNodeInstance == NULL) {
        DPF(60, "GetStartNodeInstance: pStartNodeInstance == NULL");
        Status = STATUS_NO_SUCH_DEVICE;
        goto exit;
    }
    Assert(this);
    *ppStartNodeInstance = pStartNodeInstance;
exit:
    return(Status);
}

//---------------------------------------------------------------------------
//
// Extracts the KsIdentifier from the Irp.
// This should be called with only DEVICE_CONTROL requests.
//
NTSTATUS 
GetKsIdentifierFromIrp(
    PIRP pIrp,
    PKSIDENTIFIER *ppKsIdentifier,
    PBOOL pfIsAllocated
)
{
    NTSTATUS Status;
    PIO_STACK_LOCATION pIrpStack;
    PKSIDENTIFIER pKsIdentifier;
    BOOL fIsAllocated;
    ULONG cbInput;

    ASSERT(ppKsIdentifier);
    ASSERT(pfIsAllocated);

    Status = STATUS_SUCCESS;
    pKsIdentifier = NULL;
    fIsAllocated = FALSE;
    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
    cbInput = pIrpStack->Parameters.DeviceIoControl.InputBufferLength;
    *ppKsIdentifier = NULL;
    *pfIsAllocated = FALSE;

    //
    // Reject if the buffer is too small.
    //
    if (cbInput < sizeof(KSIDENTIFIER))
    {
        return STATUS_SUCCESS;
    }

    //
    // Reject DISABLE_EVENT requests. These buffers are handled seperately.
    //
    if (IOCTL_KS_DISABLE_EVENT == pIrpStack->Parameters.DeviceIoControl.IoControlCode)
    {
        return STATUS_SUCCESS;
    }

    //
    // SystemBuffer is not Set. We are still depending on Type3InputBuffer.
    //
    if (NULL == pIrp->AssociatedIrp.SystemBuffer)
    {
        //
        // If the request is coming from KernelMode, we can use it directly.
        // Note that there might be some synchronization issues here.
        //
        if (KernelMode == pIrp->RequestorMode)
        {
            pKsIdentifier = (PKSIDENTIFIER) 
                pIrpStack->Parameters.DeviceIoControl.Type3InputBuffer;
        }
        //
        // If the request is coming from UserMode, we need to buffer it.
        //
        else
        {
            pKsIdentifier = (PKSIDENTIFIER) new BYTE[cbInput];
            if (NULL == pKsIdentifier)
            {
                DPF(5, "GetKsIdentifierFromIrp: Memory allocation failed");
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
            else
            {
                __try
                {
                    ProbeForWrite(
                        pIrpStack->Parameters.DeviceIoControl.Type3InputBuffer,
                        cbInput, 
                        sizeof(BYTE));

                    RtlCopyMemory(
                        pKsIdentifier, 
                        pIrpStack->Parameters.DeviceIoControl.Type3InputBuffer,
                        cbInput);

                    fIsAllocated = TRUE;
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    Status = STATUS_UNSUCCESSFUL;
                    DPF1(5, "GetKsIdentifierFromIrp: Exception %08x", GetExceptionCode());
                    delete [] pKsIdentifier;
                    pKsIdentifier = NULL;
                }
            }
        }
    }
    //
    // If SystemBuffer is already set, ValidateDeviceIoControl must 
    // have converted the request to BUFFERRED.
    //
    else
    {
        pKsIdentifier = (PKSIDENTIFIER)
            ((PUCHAR)pIrp->AssociatedIrp.SystemBuffer +
            ((pIrpStack->Parameters.DeviceIoControl.OutputBufferLength +
                FILE_QUAD_ALIGNMENT) & ~FILE_QUAD_ALIGNMENT));
    }

    *ppKsIdentifier = pKsIdentifier;
    *pfIsAllocated = fIsAllocated;

    return Status;
} // GetKsIdentifierFromIrp

#pragma LOCKED_CODE
#pragma LOCKED_DATA

BOOL
IsIoctlForTopologyNode(
    ULONG IoControlCode,
    ULONG Flags
)
{
    if (Flags & KSPROPERTY_TYPE_TOPOLOGY) 
    {
        if (IOCTL_KS_PROPERTY == IoControlCode) 
        {
            if ((Flags & (KSPROPERTY_TYPE_GET |
                          KSPROPERTY_TYPE_SET |
                          KSPROPERTY_TYPE_BASICSUPPORT)) == 0) 
            {
                return TRUE;
            }
        }
        else 
        {
            return TRUE;
        }
    }

    return FALSE;    
} // IsIoctlForTopologyNode

//---------------------------------------------------------------------------
//
// Get the FileObject for the filter that owns this node.
// 
NTSTATUS
GetFileObjectFromNodeId(
    IN PPIN_INSTANCE pPinInstance,
    IN PGRAPH_NODE_INSTANCE pGraphNodeInstance,
    IN ULONG NodeId,
    OUT PFILE_OBJECT *ppFileObject
)
{
    NTSTATUS Status;

    ASSERT(ppFileObject);

    if (pPinInstance == NULL) 
    {
        Status = pGraphNodeInstance->GetTopologyNodeFileObject(
            ppFileObject,
            NodeId);
    }
    else 
    {
        Status = pPinInstance->pStartNodeInstance->GetTopologyNodeFileObject(
            ppFileObject,
            NodeId);
    }
    
    return Status;
}// GetFileObjectFromNodeId

//---------------------------------------------------------------------------
//
// Extracts the event data from Irp. Caller must free the EventData
// depending on fIsAllocated.
// 
NTSTATUS
GetEventDataFromIrp(
    IN PIRP pIrp,
    OUT PKSEVENTDATA *ppEventData,
    OUT BOOL *pfIsAllocated
)
{
    NTSTATUS Status;
    PIO_STACK_LOCATION pIrpStack;
    PKSEVENTDATA pEventData;
    BOOL fIsAllocated;
    ULONG cbInput;

    ASSERT(pIrp);
    ASSERT(ppEventData);
    ASSERT(pfIsAllocated);

    Status = STATUS_SUCCESS;
    pEventData = NULL;
    fIsAllocated = FALSE;
    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
    cbInput = pIrpStack->Parameters.DeviceIoControl.InputBufferLength;
    *ppEventData = NULL;
    *pfIsAllocated = FALSE;

    if (cbInput < sizeof(KSEVENTDATA)) 
    {
        DPF1(5, "GetEventDataFromIrp: InputBuffer too small %d", cbInput);
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    // SystemBuffer is not Set. We are still depending on Type3InputBuffer.
    //
    if (NULL == pIrp->AssociatedIrp.SystemBuffer)
    {
        //
        // If the request is coming from KernelMode, we can use it directly.
        // Note that there might be some synchronization issues here.
        //
        if (KernelMode == pIrp->RequestorMode)
        {
            pEventData = (PKSEVENTDATA) 
                pIrpStack->Parameters.DeviceIoControl.Type3InputBuffer;
        }
        //
        // If the request is coming from UserMode, we need to buffer it.
        //
        else
        {
            pEventData = (PKSEVENTDATA) ExAllocatePoolWithTag(
                NonPagedPool, 
                cbInput, 
                POOLTAG_SYSA);
            if (NULL == pEventData)
            {
                DPF(5, "GetEventDataFromIrp: Memory allocation failed");
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
            else
            {
                __try
                {
                    ProbeForWrite(
                        pIrpStack->Parameters.DeviceIoControl.Type3InputBuffer,
                        cbInput, 
                        sizeof(BYTE));

                    RtlCopyMemory(
                        pEventData, 
                        pIrpStack->Parameters.DeviceIoControl.Type3InputBuffer,
                        cbInput);

                    fIsAllocated = TRUE;
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    Status = STATUS_UNSUCCESSFUL;
                    DPF1(5, "GetEventDataFromIrp: Exception %08x", GetExceptionCode());
                    ExFreePool(pEventData);
                    pEventData = NULL;
                }
            }
        }
    }
    //
    // If SystemBuffer is already set, ValidateDeviceIoControl must 
    // have converted the request to BUFFERRED.
    //
    else
    {
        pEventData = (PKSEVENTDATA)
            ((PUCHAR)pIrp->AssociatedIrp.SystemBuffer +
            ((pIrpStack->Parameters.DeviceIoControl.OutputBufferLength +
                FILE_QUAD_ALIGNMENT) & ~FILE_QUAD_ALIGNMENT));
    }

    *ppEventData = pEventData;
    *pfIsAllocated = fIsAllocated;
   
    return Status;
} // GetEventDataFromIrp

//---------------------------------------------------------------------------
//
// Get the FileObject from DISABLE_EVENT request.
// This function should not touch ppFileObject incase of a failure.
// 
NTSTATUS
GetFileObjectFromEvent(
    IN PIRP pIrp,
    IN PPIN_INSTANCE pPinInstance,
    IN PGRAPH_NODE_INSTANCE pGraphNodeInstance,
    OUT PFILE_OBJECT *ppFileObject
)
{
    NTSTATUS Status;
    PIO_STACK_LOCATION pIrpStack;
    PKSEVENTDATA pEventData;
    BOOL fIsAllocated;
    ULONG cbInput;
    ULONG OriginalNodeId;

    ASSERT(pIrp);
    ASSERT(pGraphNodeInstance);
    ASSERT(ppFileObject);

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
    cbInput = pIrpStack->Parameters.DeviceIoControl.InputBufferLength;

    //
    // Get KSEVENTDATA from the Irp safely.
    //
    Status = GetEventDataFromIrp(
        pIrp,
        &pEventData,
        &fIsAllocated);
    if (NT_SUCCESS(Status)) 
    {
        //
        // Extract the NodeId and FileObject.
        //
        OriginalNodeId = ULONG(pEventData->Dpc.Reserved);

        if ((pEventData->NotificationType == KSEVENTF_DPC) &&
            (OriginalNodeId & 0x80000000)) 
        {
            OriginalNodeId = OriginalNodeId & 0x7fffffff;

            Status = GetFileObjectFromNodeId(
                pPinInstance,
                pGraphNodeInstance,
                OriginalNodeId,
                ppFileObject);
            if(!NT_SUCCESS(Status)) 
            {
                DPF1(5, "GetFileObjectFromEvent: GetTopologyNodeFileObject FAILED %08x", Status);
                goto exit;
            }
        }
    }
    //
    // No else here. We are succeeding in all other cases.
    //

exit:
    if (fIsAllocated)
    {
        ExFreePool(pEventData);
    }
    return Status;
} // GetFileObjectFromEvent

//=============================================================================
//
// ForwardIrpNode
//
// NOTE: ForwardIrpNode releases gMutex
//
NTSTATUS
ForwardIrpNode(
    IN PIRP pIrp,
    IN PKSIDENTIFIER pKsIdentifier,
    IN PFILTER_INSTANCE pFilterInstance,
    IN OPTIONAL PPIN_INSTANCE pPinInstance
)
{
    PGRAPH_NODE_INSTANCE pGraphNodeInstance;
    PFILE_OBJECT pFileObject = NULL;
    PIO_STACK_LOCATION pIrpStack;
    ULONG OriginalNodeId;
    NTSTATUS Status;

    Assert(pFilterInstance);
    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
    Status = pFilterInstance->GetGraphNodeInstance(&pGraphNodeInstance);
    if (!NT_SUCCESS(Status)) 
    {
        goto exit;
    }
    Assert(pGraphNodeInstance);

    if (pPinInstance != NULL) 
    {
        pFileObject = pPinInstance->GetNextFileObject();
    }
    
    //
    // if InputBufferLength is more than KSNODEPROPERTY the callers
    // must have already set the identifier.
    //
    if (pIrpStack->Parameters.DeviceIoControl.InputBufferLength >= sizeof(KSNODEPROPERTY) &&
        pIrpStack->Parameters.DeviceIoControl.IoControlCode != IOCTL_KS_DISABLE_EVENT) 
    {
        ASSERT(pKsIdentifier);
        if (pKsIdentifier->Flags & KSPROPERTY_TYPE_TOPOLOGY) 
        {
            PKSNODEPROPERTY pNodeProperty;
            
            pNodeProperty = (PKSNODEPROPERTY) pKsIdentifier;
            OriginalNodeId = pNodeProperty->NodeId;

            Status = GetFileObjectFromNodeId(
                pPinInstance,
                pGraphNodeInstance,
                OriginalNodeId,
                &pFileObject);
            if (!NT_SUCCESS(Status)) 
            {
                DPF1(100, 
                  "ForwardIrpNode: GetTopologyNodeFileObject FAILED %08x",
                  Status);
                goto exit;
            }
            
            // Put real node number in input buffer
            pNodeProperty->NodeId = pGraphNodeInstance->
                papTopologyNode[OriginalNodeId]->ulRealNodeNumber;
        }
    }
    //
    // If it is DisableEvent && if it is of type DPC. We look into the
    // Reserved field of KSEVENTDATA to extract the original node on
    // which the event was enabled (The high bit is set if we ever
    // stashed a NodeId in there).
    //
    else 
    {
        if (pIrpStack->Parameters.DeviceIoControl.IoControlCode ==
            IOCTL_KS_DISABLE_EVENT) 
        {
            ASSERT(NULL == pKsIdentifier); 
            Status = GetFileObjectFromEvent(
                pIrp, 
                pPinInstance, 
                pGraphNodeInstance,
                &pFileObject);
            if (!NT_SUCCESS(Status)) 
            {
                goto exit;
            }
        }
    }

    if (pFileObject == NULL) 
    {
        Status = STATUS_NOT_FOUND;
        DPF1(6, "ForwardIrpNode: Property not forwarded: %08x", pKsIdentifier);
        goto exit;
    }
    pIrpStack->FileObject = pFileObject;

    //
    // If it was EnableEvent we stash away pointer to KSEVENTDATA, so that we
    // can stash the NodeID into it after we call the next driver on the stack
    //
    PKSEVENTDATA pEventData;
    KPROCESSOR_MODE  RequestorMode;
    
    if ((pKsIdentifier != NULL) &&
        (pIrpStack->Parameters.DeviceIoControl.IoControlCode == IOCTL_KS_ENABLE_EVENT) &&
       !(pKsIdentifier->Flags & KSEVENT_TYPE_BASICSUPPORT) &&
        (pKsIdentifier->Flags & KSPROPERTY_TYPE_TOPOLOGY) &&
        (pKsIdentifier->Flags & KSEVENT_TYPE_ENABLE)) 
    {
        pEventData = (PKSEVENTDATA) pIrp->UserBuffer;
        RequestorMode = pIrp->RequestorMode;
    }
    else 
    {
        pEventData = NULL;
    }

    //
    // Forward request to the top of audio graph.
    // There is no problem as long as the target device stack size is
    // less than SYSTEM_LARGE_IRP_LOCATIONS
    //
    IoSkipCurrentIrpStackLocation(pIrp);
    AssertFileObject(pIrpStack->FileObject);
    Status = IoCallDriver(IoGetRelatedDeviceObject(pFileObject), pIrp);

    //
    // ISSUE: ALPERS 05/29/2002
    // This logic is completely broken. Now the IRP is completed, how
    // can we make sure that UserData is still available.
    //

    //
    // Stash away the Node id in EventData
    //
    __try 
    {
        if (pEventData != NULL)
        {
            if (UserMode == RequestorMode)
            {
                ProbeForWrite(pEventData, sizeof(KSEVENTDATA), 1);
            }

            if (KSEVENTF_DPC == pEventData->NotificationType)
            {
                pEventData->Dpc.Reserved = OriginalNodeId | 0x80000000;
            }
        }
    } 
    __except (EXCEPTION_EXECUTE_HANDLER) 
    {
        Trap();
        Status = GetExceptionCode();
        DPF1(5, "ForwardIrpNode: Exception %08x", Status);
    }

    if(!NT_SUCCESS(Status)) 
    {
        DPF1(100, "ForwardIrpNode: Status %08x", Status);
    }

    ::ReleaseMutex();
    return(Status);

exit:
    ::ReleaseMutex();

    pIrp->IoStatus.Status = Status;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);
    return(Status);
}

//---------------------------------------------------------------------------
//  End of File: pins.c
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\sysaudio\notify.h ===
//---------------------------------------------------------------------------
//
//  Module:   notify.h
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Local prototypes
//---------------------------------------------------------------------------

extern "C" {

NTSTATUS
RegisterForPlugPlayNotifications(
);

VOID
UnregisterForPlugPlayNotifications(
);

VOID
DecrementAddRemoveCount(
);

NTSTATUS
AudioDeviceInterfaceNotification(
    IN PDEVICE_INTERFACE_CHANGE_NOTIFICATION pNotification,
    IN PVOID Context
);

NTSTATUS
AddFilter(
    PWSTR pwstrDeviceInterface,
    PFILTER_NODE *ppFilterNode
);

NTSTATUS
DeleteFilter(
    PWSTR pwstrDeviceInterface
);

NTSTATUS AddGfx(
    PSYSAUDIO_GFX pSysaudioGfx,
    ULONG cbMaxLength
);

NTSTATUS RemoveGfx(
    PSYSAUDIO_GFX pSysaudioGfx,
    ULONG cbMaxLength    
);

PFILTER_NODE
FindGfx(
    PFILTER_NODE pnewFilterNode,
    HANDLE hGfx,
    PWSTR pwstrDeviceName,
    ULONG GfxOrder
);

NTSTATUS
SafeCopyDeviceName(
    PWSTR pwstrDeviceName,
    ULONG cbMaxLength,
    PWSTR *String
);

NTSTATUS
GetFilterTypeFromGuid(
    IN LPGUID Guid,
    OUT PULONG pFilterType
);

} // extern "C"

//---------------------------------------------------------------------------
//  End of File: nodes.h
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\sysaudio\pni.h ===
//---------------------------------------------------------------------------
//
//  Module:         pni.h
//
//  Description:    Pin Node Instance Class
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date   Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Constants and Macros
//---------------------------------------------------------------------------

#define SETSTATE_FLAG_IGNORE_ERROR  0x00000001
#define SETSTATE_FLAG_SINK          0x00000002
#define SETSTATE_FLAG_SOURCE        0x00000004

#define MAX_STATES                  (KSSTATE_RUN+1)

// Enable temp fix for LEAKING the last portion of previous sound.
#define FIX_SOUND_LEAK 1


//---------------------------------------------------------------------------
// Classes
//---------------------------------------------------------------------------

#ifdef DEBUG
typedef class CPinNodeInstance : public CListMultiItem
#else
typedef class CPinNodeInstance : public CObj
#endif
{
private:
    ~CPinNodeInstance(
    );

public:
    static NTSTATUS
    Create(
        PPIN_NODE_INSTANCE *ppPinNodeInstance,
        PFILTER_NODE_INSTANCE pFilterNodeInstance,
        PPIN_NODE pPinNode,
        PKSPIN_CONNECT pPinConnect,
        BOOL fRender
#ifdef FIX_SOUND_LEAK
       ,BOOL fDirectConnection
#endif
    );

    VOID
    Destroy(
    )
    {
        if(this != NULL) {
            Assert(this);
            delete this;
        }
    };

    NTSTATUS
    SetState(
        KSSTATE NewState,
        KSSTATE PreviousState,
        ULONG ulFlags
    );

    PPIN_NODE pPinNode;
    PFILE_OBJECT pFileObject;
    HANDLE hPin;
private:
    KSSTATE CurrentState;
    int     cState[MAX_STATES];
    PFILTER_NODE_INSTANCE pFilterNodeInstance;
    BOOL    fRender;

#ifdef FIX_SOUND_LEAK
    BOOL    fDirectConnection;
    BOOL    ForceRun;
#endif

public:
    DefineSignature(0x20494E50);        // PNI

} PIN_NODE_INSTANCE, *PPIN_NODE_INSTANCE;

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\sysaudio\pni.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   pni.cpp
//
//  Description:
//
//  Pin Node Instance
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date   Author      Comment
//
//  To Do:     Date   Author      Comment
//
//@@END_MSINTERNAL
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

CPinNodeInstance::~CPinNodeInstance(
)
{
    DPF1(90, "~CPinNodeInstance: %08x", this);
    Assert(this);

    if(pFileObject != NULL) {
        AssertFileObject(pFileObject);
        ObDereferenceObject(pFileObject);
    }
    if(hPin != NULL) {
        AssertStatus(ZwClose(hPin));
    }
    pFilterNodeInstance->Destroy();
}

NTSTATUS
CPinNodeInstance::Create(
    PPIN_NODE_INSTANCE *ppPinNodeInstance,
    PFILTER_NODE_INSTANCE pFilterNodeInstance,
    PPIN_NODE pPinNode,
    PKSPIN_CONNECT pPinConnect,
    BOOL fRender
#ifdef FIX_SOUND_LEAK
   ,BOOL fDirectConnection
#endif
)
{
    PPIN_NODE_INSTANCE pPinNodeInstance = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    Assert(pPinNode);
    Assert(pPinNode->pPinInfo);
    Assert(pFilterNodeInstance);

    pPinConnect->PinId = pPinNode->pPinInfo->PinId;
    pPinNodeInstance = new PIN_NODE_INSTANCE();
    if(pPinNodeInstance == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }
    pPinNodeInstance->pPinNode = pPinNode;
    pPinNodeInstance->pFilterNodeInstance = pFilterNodeInstance;
    ASSERT(pPinNodeInstance->CurrentState == KSSTATE_STOP);
    pFilterNodeInstance->AddRef();
    pPinNodeInstance->fRender  = fRender;
#ifdef FIX_SOUND_LEAK
    pPinNodeInstance->fDirectConnection = fDirectConnection;
    pPinNodeInstance->ForceRun = FALSE;
#endif
#ifdef DEBUG
    DPF3(90, "CPNI::Create PN %08x #%d %s",
      pPinNode,
      pPinNode->pPinInfo->PinId,
      pPinNode->pPinInfo->pFilterNode->DumpName());
    DumpPinConnect(90, pPinConnect);
#endif
    if (pFilterNodeInstance->hFilter == NULL) {
        //
        // If it is a GFX we have to attach to the AddGfx() context 
        // to create the pin
        //
        Status = pFilterNodeInstance->pFilterNode->CreatePin(pPinConnect,
                                                    GENERIC_WRITE,
                                                    &pPinNodeInstance->hPin);
    }
    else {
        Status = KsCreatePin(
          pFilterNodeInstance->hFilter,
          pPinConnect,
          GENERIC_WRITE | OBJ_KERNEL_HANDLE,
          &pPinNodeInstance->hPin);
    }

    if(!NT_SUCCESS(Status)) {
#ifdef DEBUG
        DPF4(90, "CPNI::Create PN %08x #%d %s KsCreatePin FAILED: %08x",
          pPinNode,
          pPinNode->pPinInfo->PinId,
          pPinNode->pPinInfo->pFilterNode->DumpName(),
          Status);
#endif
        pPinNodeInstance->hPin = NULL;
        goto exit;
    }
    Status = ObReferenceObjectByHandle(
      pPinNodeInstance->hPin,
      GENERIC_READ | GENERIC_WRITE,
      NULL,
      KernelMode,
      (PVOID*)&pPinNodeInstance->pFileObject,
      NULL);

    if(!NT_SUCCESS(Status)) {
        pPinNodeInstance->pFileObject = NULL;
        goto exit;
    }
    AssertFileObject(pPinNodeInstance->pFileObject);

    DPF2(90, "CPNI::Create SUCCESS %08x PN %08x", pPinNodeInstance, pPinNode);
exit:
    if(!NT_SUCCESS(Status)) {
        if (pPinNodeInstance) {
            pPinNodeInstance->Destroy();
        }
        pPinNodeInstance = NULL;
    }

    *ppPinNodeInstance = pPinNodeInstance;
    return(Status);
}

#ifdef DEBUG
PSZ apszStates[] = { "STOP", "ACQUIRE", "PAUSE", "RUN" };
#endif

NTSTATUS
CPinNodeInstance::SetState(
    KSSTATE NewState,
    KSSTATE PreviousState,
    ULONG ulFlags
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    LONG State;

    if(this == NULL) {
        goto exit;
    }
    Assert(this);

    DPF9(DBG_STATE, "SetState %s to %s cR %d cP %d cA %d cS %d P# %d %s %s",
      apszStates[PreviousState],
      apszStates[NewState],
      cState[KSSTATE_RUN],
      cState[KSSTATE_PAUSE],
      cState[KSSTATE_ACQUIRE],
      cState[KSSTATE_STOP],
      pPinNode->pPinInfo->PinId,
      apszStates[CurrentState],
      pPinNode->pPinInfo->pFilterNode->DumpName());

    cState[PreviousState]--;
    cState[NewState]++;

    for(State = KSSTATE_RUN; State > KSSTATE_STOP; State--) {
        if(cState[State] > 0) {
            break;
        }
    }

    // ISSUE-2001/04/09-alpers
    // The proper fix would be to propagate the reset to the entire audio stack.
    // But it is considered as being to risky for now (after Beta2 of Windows XP).
    // This should be one of the first things we should address in Blackcomb.
    //

#ifdef FIX_SOUND_LEAK
    // FIX_SOUND_LEAK is to prevent the audio stack from play/recording the last
    // portion of data when a new stream is started.
    // This temporary fix keeps the pins below splitter/kmixer sink pin in
    // RUNNING state.
    //
    if (fRender)
    {
        // For render pins
        //  The criteria for keeping the pin in RUN state:
        //  If the pin is going to PAUSE from RUN.
        //  If the filter is below kmixer.
        //  If the pin is not kmixer sink pin.
        //
        if ( (!fDirectConnection) &&
             (State == KSSTATE_PAUSE) &&
             (PreviousState == KSSTATE_RUN) &&
             (pFilterNodeInstance->pFilterNode->GetOrder() <= ORDER_MIXER) &&
             !(pFilterNodeInstance->pFilterNode->GetOrder() == ORDER_MIXER &&
              pPinNode->pPinInfo->Communication == KSPIN_COMMUNICATION_SINK) )
        {
                ForceRun = TRUE;
        }
    }
    else
    {
        // For capture pins
        //  The criteria for keeping the pin in RUN state:
        //  If the pin is going to PAUSE from RUN.
        //  There are more than one pins in PAUSE.
        //
        if ( (State == KSSTATE_PAUSE) &&
             (PreviousState == KSSTATE_RUN) &&
             (cState[KSSTATE_PAUSE] > 1) )
        {
            DPF(DBG_STATE, "SetState: CAPTURE forcing KSSTATE_RUN");
            State = KSSTATE_RUN;
        }
    }

    if (ForceRun)
    {
        DPF(DBG_STATE, "SetState: RENDER IN FORCE KSSTATE_RUN state");
        State = KSSTATE_RUN;
    }

#else
    for(State = KSSTATE_RUN; cState[State] <= 0; State--) {
        if(State == KSSTATE_STOP) {
            break;
        }
    }
#endif

#ifdef FIX_SOUND_LEAK
    // If the pin is forced to be in RUN state, we should go back to
    // regular state scheme, if and only if there are no pins in RUN state.
    // To prevent RUN-ACQUIRE first go to PAUSE.
    //
    if (ForceRun &&
        (0 == cState[KSSTATE_PAUSE]) &&
        (0 == cState[KSSTATE_RUN]))
    {
        KSSTATE TempState = KSSTATE_PAUSE;

        DPF(DBG_STATE, "SetState: Exiting FORCE KSSTATE_RUN state");
        DPF1(DBG_STATE, "SetState: PinConnectionProperty(%s)", apszStates[TempState]);

        Status = PinConnectionProperty(
          pFileObject,
          KSPROPERTY_CONNECTION_STATE,
          KSPROPERTY_TYPE_SET,
          sizeof(TempState),
          &TempState);
        if (!NT_SUCCESS(Status))
        {
            if(ulFlags & SETSTATE_FLAG_IGNORE_ERROR) {
                Status = STATUS_SUCCESS;
            }
            else {
                //
                // Go back to previous state if failure
                //
                cState[PreviousState]++;
                cState[NewState]--;
                goto exit;
            }
        }

        // Exiting the FORCE_RUN state.
        //
        CurrentState = KSSTATE_PAUSE;
        State = KSSTATE_ACQUIRE;
        ForceRun = FALSE;
    }
#endif

    if(CurrentState != State) {
        DPF1(DBG_STATE, "SetState: PinConnectionProperty(%s)", apszStates[State]);
        ASSERT(State == CurrentState + 1 || State == CurrentState - 1);

        Status = PinConnectionProperty(
          pFileObject,
          KSPROPERTY_CONNECTION_STATE,
          KSPROPERTY_TYPE_SET,
          sizeof(State),
          &State);

        if(!NT_SUCCESS(Status)) {
            DPF1(5, "SetState: PinConnectionProperty FAILED %08x", Status);

            if(ulFlags & SETSTATE_FLAG_IGNORE_ERROR) {
                Status = STATUS_SUCCESS;
            }
            else {
                //
                // Go back to previous state if failure
                //
                cState[PreviousState]++;
                cState[NewState]--;
                goto exit;
            }
        }

        CurrentState = (KSSTATE)State;
    }
exit:
    return(Status);
}

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\sysaudio\pn.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   pn.cpp
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//  To Do:     Date	  Author      Comment
//
//@@END_MSINTERNAL
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

CPinNode::CPinNode(
    PPIN_INFO pPinInfo
)
{
    Assert(pPinInfo);
    this->pPinInfo = pPinInfo;
    AddList(&pPinInfo->lstPinNode);
}

CPinNode::CPinNode(
    PGRAPH_NODE pGraphNode,
    PPIN_NODE pPinNode
)
{
    this->pPinInfo = pPinNode->pPinInfo;
    this->ulOverhead = pPinNode->GetOverhead();
    this->pDataRange = pPinNode->pDataRange;
    this->pInterface = pPinNode->pInterface;
    this->pMedium = pPinNode->pMedium;
    this->pLogicalFilterNode = pPinNode->pLogicalFilterNode;
    AddList(&pGraphNode->lstPinNode);
}

NTSTATUS
CPinNode::CreateAll(
    PPIN_INFO pPinInfo,
    PDATARANGES pDataRanges,
    PIDENTIFIERS pInterfaces,
    PIDENTIFIERS pMediums
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKSDATARANGE pDataRange;
    PPIN_NODE pPinNode;
    ULONG d, i, m;

    Assert(pPinInfo);

    // Data Ranges loop
    pDataRange = &pDataRanges->aDataRanges[0];

    for(d = 0; d < pDataRanges->MultipleItem.Count; d++) {

        if(IsEqualGUID(
          &KSDATAFORMAT_SPECIFIER_WAVEFORMATEX,
          &pDataRange->Specifier) ||
           IsEqualGUID(
          &KSDATAFORMAT_SPECIFIER_DSOUND,
          &pDataRange->Specifier)) {
            //
            // Reject KSDATARANGE_AUDIO's that have the wrong size
            //
            if(pDataRange->FormatSize < sizeof(KSDATARANGE_AUDIO)) {
                DPF(5, "CPinNode::Create: KSDATARANGE_AUDIO wrong size");
                continue;
            }
        }

        // Interfaces loop
        for(i = 0; i < pInterfaces->MultipleItem.Count; i++) {

            // Mediums loop
            for(m = 0; m < pMediums->MultipleItem.Count; m++) {

                pPinNode = new PIN_NODE(pPinInfo);
                if(pPinNode == NULL) {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    Trap();
                    goto exit;
                }
                if(pDataRanges != &DataRangesNull) {
                    pPinNode->pDataRange = pDataRange;
                    AssertAligned(pPinNode->pDataRange);
                } else Trap();
                if(pInterfaces != &IdentifiersNull) {
                    pPinNode->pInterface = &pInterfaces->aIdentifiers[i];
                    AssertAligned(pPinNode->pInterface);
                }
                if(pMediums != &IdentifiersNull) {
                    pPinNode->pMedium = &pMediums->aIdentifiers[m];
                    AssertAligned(pPinNode->pMedium);
                } else Trap();

                if(IsEqualGUID(
                  &KSDATAFORMAT_SPECIFIER_WAVEFORMATEX,
                  &pDataRange->Specifier) ||
                   IsEqualGUID(
                  &KSDATAFORMAT_SPECIFIER_DSOUND,
                  &pDataRange->Specifier)) {
                    //
                    // Puts in order based on SR, BPS and CHs, 
                    // scaled down to 0 - 256
                    //
                    pPinNode->ulOverhead = 256 -
                      (( (((PKSDATARANGE_AUDIO)pDataRange)->
                    MaximumChannels > 6 ? 6 :
                      ((PKSDATARANGE_AUDIO)pDataRange)->
                    MaximumChannels) *
                      ((PKSDATARANGE_AUDIO)pDataRange)->
                    MaximumSampleFrequency *
                      ((PKSDATARANGE_AUDIO)pDataRange)->
                    MaximumBitsPerSample) / ((96000 * 32 * 6)/256));
                    //
                    // Try the WaveFormatEx format first, then DSOUND
                    //
                    if(IsEqualGUID(
                      &KSDATAFORMAT_SPECIFIER_DSOUND,
                      &pDataRange->Specifier)) {
                        pPinNode->ulOverhead += 1;
                    }
                }
                else {
                    // Put in order that the filter had the data ranges
                    pPinNode->ulOverhead = d;
                }
                // Put in order that the filter had the interface/mediums
                pPinNode->ulOverhead += (m << 16) + (i << 8);
            }
        }
        // Get the pointer to the next data range
        *((PUCHAR*)&pDataRange) += ((pDataRange->FormatSize + 
          FILE_QUAD_ALIGNMENT) & ~FILE_QUAD_ALIGNMENT);
    }
exit:
    return(Status);
}

BOOL
CPinNode::ComparePins(
    PPIN_NODE pPinNode2
)
{
    PPIN_NODE pPinNode1 = this;

    // Check if dataflow is compatible
    switch(pPinNode1->pPinInfo->DataFlow) {

        case KSPIN_DATAFLOW_IN:
            switch(pPinNode2->pPinInfo->DataFlow) {
                case KSPIN_DATAFLOW_OUT:
                   break;

                default:
                    DPF(100, "ComparePins: dataflow mismatch");
                    return(FALSE);
            }
            break;

        case KSPIN_DATAFLOW_OUT:
            switch(pPinNode2->pPinInfo->DataFlow) {
                case KSPIN_DATAFLOW_IN:
                   break;

                default:
                    DPF(100, "ComparePins: dataflow mismatch");
                    return(FALSE);
            }
            break;

        default:
            Trap();
            DPF(100, "ComparePins: dataflow mismatch");
            return(FALSE);
    }

    // Check if communication type is compatible
    switch(pPinNode1->pPinInfo->Communication) {
        case KSPIN_COMMUNICATION_BOTH:
            switch(pPinNode2->pPinInfo->Communication) {
                case KSPIN_COMMUNICATION_BOTH:
                case KSPIN_COMMUNICATION_SINK:
                case KSPIN_COMMUNICATION_SOURCE:
                   break;

                default:
                    DPF(100, "ComparePins: comm mismatch");
                    return(FALSE);
            }
            break;

        case KSPIN_COMMUNICATION_SOURCE:
            switch(pPinNode2->pPinInfo->Communication) {
                case KSPIN_COMMUNICATION_BOTH:
                case KSPIN_COMMUNICATION_SINK:
                   break;

                default:
                    DPF(100, "ComparePins: comm mismatch");
                    return(FALSE);
            }
            break;

        case KSPIN_COMMUNICATION_SINK:
            switch(pPinNode2->pPinInfo->Communication) {
                case KSPIN_COMMUNICATION_BOTH:
                case KSPIN_COMMUNICATION_SOURCE:
                   break;

                default:
                    DPF(100, "ComparePins: comm mismatch");
                    return(FALSE);
            }
            break;

        default:
            DPF(100, "ComparePins: comm mismatch");
            return(FALSE);
    }

    // Check if interface is the same
    if(!CompareIdentifier(pPinNode1->pInterface, pPinNode2->pInterface)) {
        DPF(100, "ComparePins: interface mismatch");
        return(FALSE);
    }

    // Check if medium is the same
    if(!CompareIdentifier(pPinNode1->pMedium, pPinNode2->pMedium)) {
        Trap();
        DPF(100, "ComparePins: medium mismatch");
        return(FALSE);
    }

    // Check if data range is the same
    if(!CompareDataRange(pPinNode1->pDataRange, pPinNode2->pDataRange)) {
        DPF(100, "ComparePins: datarange mismatch");
        return(FALSE);
    }
    return(TRUE);
}

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\sysaudio\pins.h ===
//---------------------------------------------------------------------------
//
//  Module:   		pins.h
//
//  Description:	KS Pin Instance
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Constants and Macros
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Classes
//---------------------------------------------------------------------------

typedef class CPinInstance : public CInstance
{
public:
    CPinInstance(
        IN PPARENT_INSTANCE pParentInstance
    );
    ~CPinInstance(
    );

    static NTSTATUS
    PinDispatchCreate(
        IN PDEVICE_OBJECT pdo,
        IN PIRP	pIrp
    );

    static NTSTATUS
    PinDispatchCreateKP(
        IN OUT PPIN_INSTANCE pPinInstance,
        IN PKSPIN_CONNECT pPinConnect
    );

    static NTSTATUS
    PinDispatchClose(
        IN PDEVICE_OBJECT pdo,
        IN PIRP	pIrp
    );

    static NTSTATUS
    PinDispatchIoControl(
        IN PDEVICE_OBJECT pdo,
        IN PIRP	pIrp
    );

    static NTSTATUS 
    PinStateHandler(
        IN PIRP pIrp,
        IN PKSPROPERTY pProperty,
        IN OUT PKSSTATE pState
    );

    NTSTATUS 
    GetStartNodeInstance(
        OUT PSTART_NODE_INSTANCE *ppStartNodeInstance
    );

    PARENT_INSTANCE ParentInstance;
    PFILTER_INSTANCE pFilterInstance;
    PSTART_NODE_INSTANCE pStartNodeInstance;
    ULONG ulVolumeNodeNumber;
    ULONG PinId;
    DefineSignature(0x494E4950);            // PINI

} PIN_INSTANCE, *PPIN_INSTANCE;

//---------------------------------------------------------------------------
// Inlines
//---------------------------------------------------------------------------

inline PPIN_INSTANCE
CInstance::GetParentInstance(
)
{
    return(CONTAINING_RECORD(
      pParentInstance,
      PIN_INSTANCE,
      ParentInstance));
}

//---------------------------------------------------------------------------
// Local prototypes
//---------------------------------------------------------------------------

NTSTATUS
ForwardIrpNode(
    IN PIRP pIrp,
    IN PKSIDENTIFIER pKsIdentifier,
    IN PFILTER_INSTANCE pFilterInstance,
    IN OPTIONAL PPIN_INSTANCE pPinInstance
);

NTSTATUS
GetRelatedStartNodeInstance(
    IN PIRP pIrp,
    OUT PSTART_NODE_INSTANCE *ppStartNodeInstance
);

NTSTATUS
GetStartNodeInstance(
    IN PIRP pIrp,
    OUT PSTART_NODE_INSTANCE *ppStartNodeInstance
);

NTSTATUS 
GetKsIdentifierFromIrp(
    PIRP pIrp,
    PKSIDENTIFIER *ppKsIdentifier,
    PBOOL pfIsAllocated
);

BOOL
IsIoctlForTopologyNode(
    ULONG IoControlCode,
    ULONG Flags
);

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\sysaudio\property.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   property.c
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Andy Nicholson
//
//  History:   Date       Author      Comment
//
//  To Do:     Date       Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

#define IsTopologyProperty(x) (x & KSPROPERTY_TYPE_TOPOLOGY)

//---------------------------------------------------------------------------
// 
// Copy pwstrString to pData.
// Assumptions
//     - pIrp has already been verified. input buffer is probed and double
// buffered.
//
NTSTATUS
PropertyReturnString(
    IN PIRP pIrp,
    IN PWSTR pwstrString,
    IN ULONG cbString,
    OUT PVOID pData
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION pIrpStack;
    ULONG cbNameBuffer;
    ULONG cbToCopy;

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
    cbNameBuffer = pIrpStack->Parameters.DeviceIoControl.OutputBufferLength;

    //
    // If the size of the passed buffer is 0, then the
    // requestor wants to know the length of the string.
    //
    if (cbNameBuffer == 0) 
    {
        pIrp->IoStatus.Information = cbString;
        Status = STATUS_BUFFER_OVERFLOW;
    }
    //
    // If the size of the passed buffer is a ULONG, then infer the
    // requestor wants to know the length of the string.
    //
    else if (cbNameBuffer == sizeof(ULONG)) 
    {
        pIrp->IoStatus.Information = sizeof(ULONG);
        *((PULONG)pData) = cbString;
    }
    //
    // The buffer is too small, return error-code.
    //
    else if (cbNameBuffer < sizeof(ULONG)) 
    {
        pIrp->IoStatus.Information = 0;
        Status = STATUS_BUFFER_TOO_SMALL;
    }
    else 
    {
        //
        // Note that we don't check for zero-length buffer because ks handler
        // function should have done that already.
        // Even though we are getting back the length of the string (as though
        // it were a unicode string) it is being handed up as a double-byte
        // string, so this code assumes there is a null at the end.  There
        // will be a bug here if there is no null.
        //

        // round down to whole wchar's
        cbNameBuffer &= ~(sizeof(WCHAR) - 1);  
        cbToCopy = min(cbString, cbNameBuffer);
        RtlCopyMemory(pData, pwstrString, cbToCopy);

        // Ensure there is a null at the end
        ((PWCHAR)pData)[cbToCopy/sizeof(WCHAR) - 1] = (WCHAR)0;
        pIrp->IoStatus.Information =  cbToCopy;
    }
    return(Status);
}

//---------------------------------------------------------------------------
NTSTATUS
GetDeviceNodeFromDeviceIndex(
    IN PFILTER_INSTANCE pFilterInstance,
    IN ULONG ulDeviceIndex,
    OUT PDEVICE_NODE *ppDeviceNode
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PDEVICE_NODE pDeviceNode;

    ASSERT(ppDeviceNode);
    ASSERT(pFilterInstance);

    *ppDeviceNode = NULL;    

    if(ulDeviceIndex == MAXULONG) {
        pDeviceNode = pFilterInstance->GetDeviceNode();
        if(pDeviceNode == NULL) {
            Status = STATUS_INVALID_PARAMETER;
            goto exit;
        }
    }
    else {
        Status = GetDeviceByIndex(ulDeviceIndex, &pDeviceNode);
        if(!NT_SUCCESS(Status)) {
            goto exit;
        }
    }

    if (NT_SUCCESS(Status)) {
        Assert(pDeviceNode);
    }

    *ppDeviceNode = pDeviceNode;

exit:
    return Status;
} // GetDeviceNodeFromDeviceIndex

//---------------------------------------------------------------------------

NTSTATUS
SetPreferredDevice(
    IN PIRP pIrp,
    IN PSYSAUDIO_PREFERRED_DEVICE pPreferred,
    IN PULONG pulDevice
)
{
    PFILTER_INSTANCE pFilterInstance;
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION pIrpStack;
    PDEVICE_NODE pDeviceNode,OldDeviceNode;

    if (IsTopologyProperty(pPreferred->Property.Flags)) {
        Status = STATUS_INVALID_PARAMETER;
        goto exit;
    }

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
    pFilterInstance = (PFILTER_INSTANCE)pIrpStack->FileObject->FsContext;
    Assert(pFilterInstance);

    //
    // Validate input buffer.
    //
    if(pPreferred->Flags & ~SYSAUDIO_FLAGS_CLEAR_PREFERRED) {
        Status = STATUS_INVALID_PARAMETER;
        goto exit;
    }
    if(pPreferred->Index >= MAX_SYSAUDIO_DEFAULT_TYPE) {
        Trap();
        Status = STATUS_INVALID_PARAMETER;
        goto exit;
    }

    if(pPreferred->Flags & SYSAUDIO_FLAGS_CLEAR_PREFERRED) {
        OldDeviceNode = apShingleInstance[pPreferred->Index]->GetDeviceNode();
        if (OldDeviceNode) {
            OldDeviceNode->SetPreferredStatus(
                (KSPROPERTY_SYSAUDIO_DEFAULT_TYPE)pPreferred->Index, 
                FALSE);
        }
        apShingleInstance[pPreferred->Index]->SetDeviceNode(NULL);
        DPF1(60, "SetPreferredDevice: CLEAR %d", pPreferred->Index);
    }
    else {
        Status = GetDeviceNodeFromDeviceIndex(
            pFilterInstance, 
            *pulDevice,
            &pDeviceNode);
        if (!NT_SUCCESS(Status)) {
            goto exit;
        }

        OldDeviceNode = apShingleInstance[pPreferred->Index]->GetDeviceNode();
        if (OldDeviceNode) {
            OldDeviceNode->SetPreferredStatus(
                (KSPROPERTY_SYSAUDIO_DEFAULT_TYPE)pPreferred->Index, 
                FALSE);
        }
        
        apShingleInstance[pPreferred->Index]->SetDeviceNode(pDeviceNode);
        pDeviceNode->SetPreferredStatus(
            (KSPROPERTY_SYSAUDIO_DEFAULT_TYPE)pPreferred->Index, 
            TRUE);

        DPF3(60, "SetPreferredDevice: %d SAD %d %s",
          pPreferred->Index,
          *pulDevice,
          pDeviceNode->DumpName());
    }
exit:
    return(Status);
}

NTSTATUS
GetComponentIdProperty(
    IN PIRP pIrp,
    IN PKSPROPERTY pRequest,
    IN OUT PVOID pData
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PFILTER_INSTANCE pFilterInstance;
    PIO_STACK_LOCATION pIrpStack;
    PDEVICE_NODE pDeviceNode;
    ULONG DeviceIndex = *(PULONG)(pRequest + 1);

    if (IsTopologyProperty(pRequest->Flags)) {
        Status = STATUS_INVALID_PARAMETER;
        goto exit;
    }

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
    pFilterInstance = (PFILTER_INSTANCE)pIrpStack->FileObject->FsContext;
    Assert(pFilterInstance);
   
    Status = GetDeviceNodeFromDeviceIndex(
        pFilterInstance, 
        DeviceIndex,
        &pDeviceNode);
    if (!NT_SUCCESS(Status)) {
        goto exit;
    }

    if(pDeviceNode->GetComponentId() == NULL) {
        // This should be STATUS_NOT_FOUND but returning this causes 
        // FilterDispatchIoControl call ForwardIrpNode which asserts that this 
        // is not a KSPROPSETID_Sysaudio property.
        Status = STATUS_INVALID_DEVICE_REQUEST; 
        goto exit;                              
    }

    RtlCopyMemory(
        pData,
        pDeviceNode->GetComponentId(),
        sizeof(KSCOMPONENTID));
    pIrp->IoStatus.Information = sizeof(KSCOMPONENTID);

 exit:
    return(Status);
}

NTSTATUS
GetFriendlyNameProperty(
    IN PIRP pIrp,
    IN PKSPROPERTY pRequest,
    IN OUT PVOID pData
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PFILTER_INSTANCE pFilterInstance;
    PIO_STACK_LOCATION pIrpStack;
    PDEVICE_NODE pDeviceNode;
    ULONG DeviceIndex = *(PULONG)(pRequest + 1);

    if (IsTopologyProperty(pRequest->Flags)) {
        Status = STATUS_INVALID_PARAMETER;
        goto exit;
    }

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
    pFilterInstance = (PFILTER_INSTANCE)pIrpStack->FileObject->FsContext;
    Assert(pFilterInstance);

    Status = GetDeviceNodeFromDeviceIndex(
        pFilterInstance, 
        DeviceIndex,
        &pDeviceNode);
    if (!NT_SUCCESS(Status)) {
        goto exit;
    }

    if(pDeviceNode->GetFriendlyName() == NULL) {
        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto exit;
    }

    Status = PropertyReturnString(
      pIrp,
      pDeviceNode->GetFriendlyName(),
      (wcslen(pDeviceNode->GetFriendlyName()) *
        sizeof(WCHAR)) + sizeof(UNICODE_NULL),
      pData);

    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
exit:
    return(Status);
}

NTSTATUS
GetDeviceCount(
    IN PIRP     pIrp,
    IN PKSPROPERTY  pRequest,
    IN OUT PVOID    pData
)
{
    if (IsTopologyProperty(pRequest->Flags)) {
        return STATUS_INVALID_PARAMETER;
    }

    if(gplstDeviceNode == NULL) {
        *(PULONG)pData = 0;
    }
    else {
        *(PULONG)pData = gplstDeviceNode->CountList();
    }

    pIrp->IoStatus.Information = sizeof(ULONG);
    return(STATUS_SUCCESS);
}

NTSTATUS
GetInstanceDevice(
    IN PIRP     pIrp,
    IN PKSPROPERTY  pRequest,
    IN OUT PVOID    pData
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION pIrpStack;
    PFILTER_INSTANCE pFilterInstance;
    PDEVICE_NODE pDeviceNode;
    ULONG Index;

    if (IsTopologyProperty(pRequest->Flags)) {
        Status = STATUS_INVALID_PARAMETER;
        goto exit;
    }

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
    pFilterInstance = (PFILTER_INSTANCE)pIrpStack->FileObject->FsContext;
    Assert(pFilterInstance);

    pDeviceNode = pFilterInstance->GetDeviceNode();
    if(pDeviceNode == NULL) {
        Status = STATUS_INVALID_PARAMETER;
        goto exit;
    }

    Status = pDeviceNode->GetIndexByDevice(&Index);
    if(NT_SUCCESS(Status)) {
        *(PULONG)pData = Index;
        pIrp->IoStatus.Information = sizeof(ULONG);
    }

exit:
    return(Status);
}

NTSTATUS
SetInstanceDevice(
    IN PIRP     Irp,
    IN PKSPROPERTY  Request,
    IN OUT PVOID    Data
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PFILTER_INSTANCE pFilterInstance;
    PIO_STACK_LOCATION pIrpStack;
    PDEVICE_NODE pDeviceNode;

    if (IsTopologyProperty(Request->Flags)) {
        Status = STATUS_INVALID_PARAMETER;
        goto exit;
    }

    pIrpStack = IoGetCurrentIrpStackLocation(Irp);
    pFilterInstance = (PFILTER_INSTANCE)pIrpStack->FileObject->FsContext;
    Assert(pFilterInstance);

    if(!pFilterInstance->IsChildInstance()) {
        DPF(5, "SetInstanceDevice: FAILED - open pin instances");
        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto exit;
    }

    Status = GetDeviceByIndex(*(PULONG)Data, &pDeviceNode);
    if(NT_SUCCESS(Status)) {
        Status = pFilterInstance->SetDeviceNode(pDeviceNode);
        if(!NT_SUCCESS(Status)) {
            goto exit;
        }
    }
exit:
    return(Status);
}

NTSTATUS
SetInstanceInfo(
    IN PIRP     Irp,
    IN PSYSAUDIO_INSTANCE_INFO pInstanceInfo,
    IN OUT PVOID    Data
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PFILTER_INSTANCE pFilterInstance;
    PIO_STACK_LOCATION pIrpStack;
    PDEVICE_NODE pDeviceNode;

    if (IsTopologyProperty(pInstanceInfo->Property.Flags)) {
        Status = STATUS_INVALID_PARAMETER;
        goto exit;
    }

    pIrpStack = IoGetCurrentIrpStackLocation(Irp);
    pFilterInstance = (PFILTER_INSTANCE)pIrpStack->FileObject->FsContext;
    Assert(pFilterInstance);

    if(pInstanceInfo->Flags & ~SYSAUDIO_FLAGS_DONT_COMBINE_PINS) {
        Status = STATUS_INVALID_PARAMETER;
        goto exit;
    }

    if(!pFilterInstance->IsChildInstance()) {
        Trap();
        DPF(5, "SetInstanceInfo: FAILED - open pin instances");
        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto exit;
    }

    Status = GetDeviceByIndex(pInstanceInfo->DeviceNumber, &pDeviceNode);
    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
    Assert(pDeviceNode);

    pFilterInstance->ulFlags |= FLAGS_COMBINE_PINS;
    if(pInstanceInfo->Flags & SYSAUDIO_FLAGS_DONT_COMBINE_PINS) {
        pFilterInstance->ulFlags &= ~FLAGS_COMBINE_PINS;
    }
    Status = pFilterInstance->SetDeviceNode(pDeviceNode);
    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
exit:
    return(Status);
}

NTSTATUS
SetDeviceDefault(
    IN PIRP     pIrp,
    IN PKSPROPERTY  pRequest,
    IN OUT PULONG   pData
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PFILTER_INSTANCE pFilterInstance;
    PIO_STACK_LOCATION pIrpStack;

    if (IsTopologyProperty(pRequest->Flags)) {
        Status = STATUS_INVALID_PARAMETER;
        goto exit;
    }

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
    pFilterInstance = (PFILTER_INSTANCE)pIrpStack->FileObject->FsContext;
    Assert(pFilterInstance);

    if(*pData >= MAX_SYSAUDIO_DEFAULT_TYPE) {
        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto exit;
    }
    if(!pFilterInstance->IsChildInstance()) {
        Trap();
        DPF(5, "SetDeviceDefault: FAILED - open pin instances");
        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto exit;
    }
    Status = pFilterInstance->SetShingleInstance(apShingleInstance[*pData]);
    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
exit:
    return(Status);
}

NTSTATUS
GetDeviceInterfaceName(
    IN PIRP pIrp,
    IN PKSPROPERTY pRequest,
    IN OUT PVOID pData
)
{
    PIO_STACK_LOCATION pIrpStack;
    PFILTER_INSTANCE pFilterInstance;
    NTSTATUS Status = STATUS_SUCCESS;
    PDEVICE_NODE pDeviceNode;
    ULONG DeviceIndex = *(PULONG)(pRequest + 1);

    if (IsTopologyProperty(pRequest->Flags)) {
        Status = STATUS_INVALID_PARAMETER;
        goto exit;
    }

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
    pFilterInstance = (PFILTER_INSTANCE)pIrpStack->FileObject->FsContext;
    Assert(pFilterInstance);

    Status = GetDeviceNodeFromDeviceIndex(
        pFilterInstance, 
        DeviceIndex,
        &pDeviceNode);
    if (!NT_SUCCESS(Status)) {
        goto exit;
    }

    if(pDeviceNode->GetDeviceInterface() == NULL) {
        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto exit;
    }

    Status = PropertyReturnString(
      pIrp,
      pDeviceNode->GetDeviceInterface(),
      (wcslen(pDeviceNode->GetDeviceInterface()) *
        sizeof(WCHAR)) + sizeof(UNICODE_NULL),
      pData);

    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
exit:
    return(Status);
}

NTSTATUS
SelectGraph(
    IN PIRP pIrp,
    PSYSAUDIO_SELECT_GRAPH pSelectGraph,
    IN OUT PVOID pData
)
{
    PGRAPH_NODE_INSTANCE pGraphNodeInstance;
    PTOPOLOGY_NODE pTopologyNode2;
    PTOPOLOGY_NODE pTopologyNode;
    PSTART_NODE pStartNode;
    NTSTATUS Status;

    if (IsTopologyProperty(pSelectGraph->Property.Flags)) {
        Status = STATUS_INVALID_PARAMETER;
        goto exit2;
    }

    Status = ::GetGraphNodeInstance(pIrp, &pGraphNodeInstance);
    if(!NT_SUCCESS(Status)) {
        goto exit2;
    }
    Assert(pGraphNodeInstance);

    //
    // Parameter and state validation.
    //
    if(pGraphNodeInstance->palstTopologyNodeSelect == NULL ||
      pGraphNodeInstance->palstTopologyNodeNotSelect == NULL) {
        DPF(5, "SelectGraph: palstTopologyNodeSelect == NULL");
        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto exit2;
    }
    
    if(pSelectGraph->Flags != 0 || pSelectGraph->Reserved != 0) {
        DPF(5, "SelectGraph: invalid flags or reserved field");
        Status = STATUS_INVALID_PARAMETER;
        goto exit2;
    }
    
    if(pSelectGraph->PinId >= pGraphNodeInstance->cPins) {
        DPF(5, "SelectGraph: invalid pin id");
        Status = STATUS_INVALID_PARAMETER;
        goto exit2;
    }
    
    if(pSelectGraph->NodeId >=
      pGraphNodeInstance->Topology.TopologyNodesCount) {
        DPF(5, "SelectGraph: invalid node id");
        Status = STATUS_INVALID_PARAMETER;
        goto exit2;
    }

    pTopologyNode = pGraphNodeInstance->papTopologyNode[pSelectGraph->NodeId];
    Assert(pTopologyNode);
    Assert(pGraphNodeInstance->pGraphNode);
    Assert(pGraphNodeInstance->pGraphNode->pDeviceNode);

    //
    // SECURITY NOTE:
    // SelectGraph is a very flexible property call that can change global
    // behavior. 
    // Therefore we are limiting the usage explicitly for AecNodes. 
    //
    if (!IsEqualGUID(pTopologyNode->pguidType, &KSNODETYPE_ACOUSTIC_ECHO_CANCEL) &&
        !IsEqualGUID(pTopologyNode->pguidType, &KSNODETYPE_NOISE_SUPPRESS) &&
        !IsEqualGUID(pTopologyNode->pguidType, &KSNODETYPE_AGC) &&
        !IsEqualGUID(pTopologyNode->pguidType, &KSNODETYPE_MICROPHONE_ARRAY) &&
        !IsEqualGUID(pTopologyNode->pguidType, &KSNODETYPE_MICROPHONE_ARRAY_PROCESSOR)) {
        DPF(5, "SelectGraph: None Aec node is selected");
        Status = STATUS_INVALID_PARAMETER;
        goto exit2;
    }

    DPF2(90, "SelectGraph GNI %08X TN %08X", pGraphNodeInstance, pTopologyNode);

    //
    // A global select type of filter needs to be inserted to all 
    // instances.
    // So if the client is trying to insert a global_select node and if
    // there are graph instances that do not have the node, the request will
    // fail.
    //
    if(pTopologyNode->pFilterNode->GetType() & FILTER_TYPE_GLOBAL_SELECT &&
       pGraphNodeInstance->paPinDescriptors[pSelectGraph->PinId].DataFlow ==
       KSPIN_DATAFLOW_IN) {

        PSTART_NODE_INSTANCE pStartNodeInstance;
        PFILTER_INSTANCE pFilterInstance;

        FOR_EACH_LIST_ITEM(
          &pGraphNodeInstance->pGraphNode->pDeviceNode->lstFilterInstance,
          pFilterInstance) {

            if(pFilterInstance->pGraphNodeInstance == NULL) {
                continue;
            }
            Assert(pFilterInstance->pGraphNodeInstance);

            FOR_EACH_LIST_ITEM(
              &pFilterInstance->pGraphNodeInstance->lstStartNodeInstance,
              pStartNodeInstance) {

                if(EnumerateGraphTopology(
                  pStartNodeInstance->pStartNode->GetStartInfo(),
                  (TOP_PFN)FindTopologyNode,
                  pTopologyNode) == STATUS_CONTINUE) {

                    DPF2(5, "SelectGraph: TN %08x not found on SNI %08x",
                        pTopologyNode,
                        pStartNodeInstance);

                    Status = STATUS_INVALID_DEVICE_REQUEST;
                    goto exit;
                }
            } END_EACH_LIST_ITEM
        } END_EACH_LIST_ITEM

        Status = pGraphNodeInstance->
            lstTopologyNodeGlobalSelect.AddListDup(pTopologyNode);

        if(!NT_SUCCESS(Status)) {
            Trap();
            goto exit;
        }
    }
    else {
        Status = pGraphNodeInstance->
            palstTopologyNodeSelect[pSelectGraph->PinId].AddList(pTopologyNode);

        if(!NT_SUCCESS(Status)) {
            Trap();
            goto exit;
        }
    }

    //
    // If this is a "not select" type filter like AEC or Mic Array, then all
    // the nodes in the filter have to be remove from the not select list,
    // otherwise IsGraphValid will never find a valid graph.
    //
    if(pTopologyNode->pFilterNode->GetType() & FILTER_TYPE_NOT_SELECT) {

        FOR_EACH_LIST_ITEM(
          &pTopologyNode->pFilterNode->lstTopologyNode,
          pTopologyNode2) {

            pGraphNodeInstance->palstTopologyNodeNotSelect[
                pSelectGraph->PinId].RemoveList(pTopologyNode2);

            DPF2(50, "   Removing %s NodeId %d",\
                pTopologyNode2->pFilterNode->DumpName(),
                pTopologyNode2->ulSysaudioNodeNumber);

        } END_EACH_LIST_ITEM
    }

    //
    // Validate that there is a valid path though the graph after updating
    // the various global, select and not select lists.
    //
    DPF(90, "SelectGraph: Validating Graph");
    FOR_EACH_LIST_ITEM(
      pGraphNodeInstance->aplstStartNode[pSelectGraph->PinId],
      pStartNode) {

        DPF2(90, "   SN: %X %s", 
            pStartNode,
            pStartNode->GetStartInfo()->GetPinInfo()->pFilterNode->DumpName());

        Assert(pStartNode);
        if(pGraphNodeInstance->IsGraphValid(
          pStartNode,
          pSelectGraph->PinId)) {
            Status = STATUS_SUCCESS;
            goto exit;
        }
        else {
            DPF(90, "      IsGraphValid failed");
        }

    } END_EACH_LIST_ITEM
    
    //
    // The select graph failed so restore the not select list back to normal
    //
    if(pTopologyNode->pFilterNode->GetType() & FILTER_TYPE_NOT_SELECT) {

        FOR_EACH_LIST_ITEM(
          &pTopologyNode->pFilterNode->lstTopologyNode,
          pTopologyNode2) {

            pGraphNodeInstance->palstTopologyNodeNotSelect[
                pSelectGraph->PinId].AddList(pTopologyNode2);

        } END_EACH_LIST_ITEM
    }
    
    Status = STATUS_INVALID_DEVICE_REQUEST;
    
exit:
    if(!NT_SUCCESS(Status)) {
        pGraphNodeInstance->
            palstTopologyNodeSelect[pSelectGraph->PinId].RemoveList(pTopologyNode);

        pGraphNodeInstance->
            lstTopologyNodeGlobalSelect.RemoveList(pTopologyNode);
    }
    
exit2:
    return(Status);
}

//---------------------------------------------------------------------------

NTSTATUS
GetTopologyConnectionIndex(
    IN PIRP pIrp,
    IN PKSPROPERTY pProperty,
    OUT PULONG pulIndex
)
{
    PSTART_NODE_INSTANCE pStartNodeInstance;
    NTSTATUS Status = STATUS_SUCCESS;

    if (IsTopologyProperty(pProperty->Flags)) {
        Status = STATUS_INVALID_PARAMETER;
        goto exit;
    }

    Status = ::GetStartNodeInstance(pIrp, &pStartNodeInstance);
    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }
    Assert(pStartNodeInstance);
    Assert(pStartNodeInstance->pStartNode);
    Assert(pStartNodeInstance->pStartNode->GetStartInfo());
    *pulIndex = pStartNodeInstance->pStartNode->GetStartInfo()->
      ulTopologyConnectionTableIndex;
    pIrp->IoStatus.Information = sizeof(ULONG);

exit:
    return(Status);
}

NTSTATUS
GetPinVolumeNode(
    IN PIRP pIrp,
    IN PKSPROPERTY pProperty,
    OUT PULONG pulNode
)
{
    PIO_STACK_LOCATION pIrpStack;
    PPIN_INSTANCE pPinInstance;
    NTSTATUS Status;

    if (IsTopologyProperty(pProperty->Flags)) {
        Status = STATUS_INVALID_PARAMETER;
        goto exit;
    }

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
    pPinInstance = (PPIN_INSTANCE)pIrpStack->FileObject->FsContext;
    Assert(pPinInstance);
    
    Status = GetVolumeNodeNumber(pPinInstance, NULL);
    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }

    if(pPinInstance->ulVolumeNodeNumber == MAXULONG) {
        DPF(5, "GetPinVolumeNode: no volume node found");
        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto exit;
    }

    *pulNode = pPinInstance->ulVolumeNodeNumber;
    pIrp->IoStatus.Information = sizeof(ULONG);
exit:
    return(Status);
}

NTSTATUS
AddRemoveGfx(
    IN PIRP pIrp,
    IN PKSPROPERTY pProperty,
    IN PSYSAUDIO_GFX pSysaudioGfx
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION pIrpStack;   
    ULONG cbMaxLength;

    if (IsTopologyProperty(pProperty->Flags)) 
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Make sure that this is bufferred IO.
    // The rest of this function assumes bufferred IO.
    //
    if (NULL == pIrp->AssociatedIrp.SystemBuffer)
    {
        DPF(5, "AddRemoveGFX: Only Bufferred IO");
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Parameter validation for SYSAUDIO_GFX.
    //
    if (pSysaudioGfx->ulType != GFX_DEVICETYPE_RENDER &&
        pSysaudioGfx->ulType != GFX_DEVICETYPE_CAPTURE)
    {
        DPF(5, "AddRemoveGFX: Invalid GFX type");
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Make sure that the offsets are within the range.
    //
    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
    cbMaxLength = 
        pIrpStack->Parameters.DeviceIoControl.OutputBufferLength - sizeof(SYSAUDIO_GFX);

    if (pIrpStack->Parameters.DeviceIoControl.OutputBufferLength < pSysaudioGfx->ulDeviceNameOffset ||
        pIrpStack->Parameters.DeviceIoControl.OutputBufferLength < pSysaudioGfx->ulDeviceNameOffset)
    {
        DPF2(5, "AddRemoveGFX: Invalid NameOffset %d %d", pSysaudioGfx->ulDeviceNameOffset, pSysaudioGfx->ulDeviceNameOffset);
        return STATUS_INVALID_PARAMETER;
    }

    if(pSysaudioGfx->Enable) 
    {
        Status = AddGfx(pSysaudioGfx, cbMaxLength);
    }
    else 
    {
        Status = RemoveGfx(pSysaudioGfx, cbMaxLength);
    }
    
    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\sysaudio\property.h ===
//---------------------------------------------------------------------------
//
//  Module:         property.h
//
//  Description:    Sysaudio Property Definations
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date   Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Constants and Macros
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Classes
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Globals
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Local prototypes
//---------------------------------------------------------------------------

extern "C" {

NTSTATUS
SetPreferredDevice(
    IN PIRP pIrp,
    IN PSYSAUDIO_PREFERRED_DEVICE pPreferred,
    IN PULONG pulDevice
);

NTSTATUS
PropertyReturnString(
    IN PIRP pIrp,
    IN PWSTR pwstrString,
    IN ULONG cbString,
    OUT PVOID pData
);

NTSTATUS
GetDeviceCount(
    IN PIRP     Irp,
    IN PKSPROPERTY  Request,
    IN OUT PVOID    Data
);

NTSTATUS
GetComponentIdProperty(
    IN PIRP     Irp,
    IN PKSPROPERTY  Request,
    IN OUT PVOID    Data
);

NTSTATUS
GetFriendlyNameProperty(
    IN PIRP     Irp,
    IN PKSPROPERTY  Request,
    IN OUT PVOID    Data
);

NTSTATUS
GetInstanceDevice(
    IN PIRP     Irp,
    IN PKSPROPERTY  Request,
    IN OUT PVOID    Data
);

NTSTATUS
SetInstanceDevice(
    IN PIRP     Irp,
    IN PKSPROPERTY  Request,
    IN OUT PVOID    Data
);

NTSTATUS
SetDeviceDefault(
    IN PIRP     Irp,
    IN PKSPROPERTY  Request,
    IN OUT PULONG   pData
);

NTSTATUS
SetInstanceInfo(
    IN PIRP     Irp,
    IN PSYSAUDIO_INSTANCE_INFO pInstanceInfo,
    IN OUT PVOID    Data
);

NTSTATUS
GetDeviceInterfaceName(
    IN PIRP     Irp,
    IN PKSPROPERTY  Request,
    IN OUT PVOID    Data
);

NTSTATUS
SelectGraph(
    IN PIRP pIrp,
    IN PSYSAUDIO_SELECT_GRAPH pSelectGraph,
    IN OUT PVOID pData
);

NTSTATUS
GetTopologyConnectionIndex(
    IN PIRP pIrp,
    IN PKSPROPERTY pProperty,
    OUT PULONG pulIndex
);

NTSTATUS
GetPinVolumeNode(
    IN PIRP pIrp,
    IN PKSPROPERTY pProperty,
    OUT PULONG pulNode
);

NTSTATUS
AddRemoveGfx(
    IN PIRP,
    IN PKSPROPERTY pProperty,
    IN PSYSAUDIO_GFX pSysaudioGfx
);

} // extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\sysaudio\pn.h ===
//---------------------------------------------------------------------------
//
//  Module:   		pn.h
//
//  Description:	pin node classes
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Classes
//---------------------------------------------------------------------------

typedef class CPinNode : public CListSingleItem
{
public:
    CPinNode(
        PPIN_INFO pPinInfo
    );

    CPinNode(
        PGRAPH_NODE pGraphNode,
        PPIN_NODE pPinNode
    );

    static NTSTATUS
    CreateAll(
	PPIN_INFO pPinInfo,
	PDATARANGES pDataRanges,
	PIDENTIFIERS pInterfaces,
	PIDENTIFIERS pMediums
    );

    ENUMFUNC
    Destroy()
    {
	Assert(this);
	delete this;
	return(STATUS_CONTINUE);
    };

    BOOL
    ComparePins(
	PPIN_NODE pPinNode
    );

    ULONG
    GetOverhead(
    )
    {
	return(ulOverhead);
    };

    ULONG
    GetType(				// see lfn.h
    );

private:
    ULONG ulOverhead;
public:
    PPIN_INFO pPinInfo;
    PLOGICAL_FILTER_NODE pLogicalFilterNode;
    PKSDATARANGE pDataRange;
    PKSPIN_MEDIUM pMedium;
    PKSPIN_INTERFACE pInterface;
    DefineSignature(0x20204e50);		// PN

} PIN_NODE, *PPIN_NODE;

//---------------------------------------------------------------------------

typedef ListSingleDestroy<PIN_NODE> LIST_PIN_NODE;

//---------------------------------------------------------------------------

typedef ListData<PIN_NODE> LIST_DATA_PIN_NODE;

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\sysaudio\registry.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   registry.c
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date       Author      Comment
//
//  To Do:     Date       Author      Comment
//
//@@END_MSINTERNAL
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"

//===========================================================================
//===========================================================================


// 
// OpenRegistryKeyForRead
//
NTSTATUS
OpenRegistryKeyForRead(
    PCWSTR pcwstr,
    PHANDLE pHandle,
    HANDLE hRootDir
)
{
    UNICODE_STRING UnicodeDeviceString;
    OBJECT_ATTRIBUTES ObjectAttributes;

    RtlInitUnicodeString(&UnicodeDeviceString, pcwstr);

    //
    // SECURITY NOTE:
    // This function is called from AddFilter notification function
    // which runs under system process. 
    // Therefore OBJ_KERNEL_HANDLE is not necessary.
    //
    InitializeObjectAttributes(
      &ObjectAttributes, 
      &UnicodeDeviceString,
      OBJ_CASE_INSENSITIVE,
      hRootDir,
      NULL);

    return(ZwOpenKey(
      pHandle,
      KEY_READ,
      &ObjectAttributes));
} // OpenRegistryKeyForRead

NTSTATUS
QueryRegistryValue(
    HANDLE hkey,
    PCWSTR pcwstrValueName,
    PKEY_VALUE_FULL_INFORMATION *ppkvfi
)
{
    UNICODE_STRING ustrValueName;
    NTSTATUS Status;
    ULONG cbValue;

    ASSERT(pcwstrValueName);
    ASSERT(ppkvfi);

    *ppkvfi = NULL;
    RtlInitUnicodeString(&ustrValueName, pcwstrValueName);

    //
    // Get the size of buffer required to read the registry key.
    // 
    Status = ZwQueryValueKey(
      hkey,
      &ustrValueName,
      KeyValueFullInformation,
      NULL,
      0,
      &cbValue);

    // 
    // SECURITY NOTE:
    // If the above ZwQueryValueKey function returns STATUS_SUCCESS, the callers
    // will get pkvfi = NULL. And eventually crash.
    // The good news is that ZwQueryValueKey will never return STATUS_SUCCESS
    // with KeyValueFullInformation.
    //
    ASSERT(!(NT_SUCCESS(Status)));

    if(Status != STATUS_BUFFER_OVERFLOW &&
       Status != STATUS_BUFFER_TOO_SMALL) {
        goto exit;
    }

    //
    // Allocate the data buffer.
    //
    *ppkvfi = (PKEY_VALUE_FULL_INFORMATION) new BYTE[cbValue];
    if(*ppkvfi == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }

    //
    // Read the actual data and associated type information.
    //
    Status = ZwQueryValueKey(
      hkey,
      &ustrValueName,
      KeyValueFullInformation,
      *ppkvfi,
      cbValue,
      &cbValue);
    if(!NT_SUCCESS(Status)) {
        delete *ppkvfi;
        *ppkvfi = NULL;
        goto exit;
    }

exit:
    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\sysaudio\shi.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   shi.cpp
//
//  Description:
//
//	Shingle Instance Class
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//  To Do:     Date	  Author      Comment
//
//@@END_MSINTERNAL
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

const WCHAR cwstrFilterTypeName[] = KSSTRING_Filter;
const WCHAR cwstrPlaybackShingleName[] = L"PLAYBACK";
const WCHAR cwstrRecordShingleName[] = L"RECORD";
const WCHAR cwstrMidiShingleName[] = L"MIDI";
const WCHAR cwstrMixerShingleName[] = L"MIXER";
#ifdef DEBUG
const WCHAR cwstrPinsShingleName[] = L"PINS";
#endif

PSHINGLE_INSTANCE apShingleInstance[] = {
    NULL,		// KSPROPERTY_SYSAUDIO_NORMAL_DEFAULT
    NULL,		// KSPROPERTY_SYSAUDIO_PLAYBACK_DEFAULT
    NULL,		// KSPROPERTY_SYSAUDIO_RECORD_DEFAULT
    NULL,		// KSPROPERTY_SYSAUDIO_MIDI_DEFAULT
    NULL,		// KSPROPERTY_SYSAUDIO_MIXER_DEFAULT
#ifdef DEBUG
    NULL,
#endif
};

ULONG aulFlags[] = {
    FLAGS_COMBINE_PINS | GN_FLAGS_PLAYBACK | GN_FLAGS_RECORD | GN_FLAGS_MIDI,
    FLAGS_COMBINE_PINS | GN_FLAGS_PLAYBACK,
    FLAGS_COMBINE_PINS | GN_FLAGS_RECORD,
    FLAGS_COMBINE_PINS | GN_FLAGS_MIDI,
    FLAGS_MIXER_TOPOLOGY | GN_FLAGS_PLAYBACK | GN_FLAGS_RECORD | GN_FLAGS_MIDI,
#ifdef DEBUG
    GN_FLAGS_PLAYBACK,
#endif
};

PCWSTR apcwstrReference[] = {
    cwstrFilterTypeName,
    cwstrPlaybackShingleName,
    cwstrRecordShingleName,
    cwstrMidiShingleName,
    cwstrMixerShingleName,
#ifdef DEBUG
    cwstrPinsShingleName,
#endif
};

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

NTSTATUS
CShingleInstance::InitializeShingle(
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    int i;

    for(i = 0; i < SIZEOF_ARRAY(apShingleInstance); i++) {
	apShingleInstance[i] = new SHINGLE_INSTANCE(aulFlags[i]);

	if(apShingleInstance[i] == NULL) {
	    Status = STATUS_INSUFFICIENT_RESOURCES;
	    goto exit;
	}

	Status = apShingleInstance[i]->CreateCreateItem(apcwstrReference[i]);
	if(!NT_SUCCESS(Status)) {
	    goto exit;
	}
    }
    Status = QueueWorkList(
      CShingleInstance::InitializeShingleWorker,
      NULL,
      NULL);

    if(!NT_SUCCESS(Status)) {
	goto exit;
    }
exit:
    if(!NT_SUCCESS(Status)) {
	UninitializeShingle();
    }
    return(Status);
}

VOID
CShingleInstance::UninitializeShingle(
)
{
    int i;

    for(i = 0; i < SIZEOF_ARRAY(apShingleInstance); i++) {
	delete apShingleInstance[i];
	apShingleInstance[i] = NULL;
    }
}

NTSTATUS
CShingleInstance::InitializeShingleWorker(
    PVOID pReference1,
    PVOID pReference2
)
{
    NTSTATUS Status;

    Status = apShingleInstance[KSPROPERTY_SYSAUDIO_PLAYBACK_DEFAULT]->Create(
      NULL,
      (LPGUID)&KSCATEGORY_PREFERRED_WAVEOUT_DEVICE);

    if(!NT_SUCCESS(Status)) {
        goto exit;
    }

    Status = apShingleInstance[KSPROPERTY_SYSAUDIO_RECORD_DEFAULT]->Create(
      NULL,
      (LPGUID)&KSCATEGORY_PREFERRED_WAVEIN_DEVICE);

    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
    Status = apShingleInstance[KSPROPERTY_SYSAUDIO_MIDI_DEFAULT]->Create(
      NULL,
      (LPGUID)&KSCATEGORY_PREFERRED_MIDIOUT_DEVICE);

    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
exit:
    return(Status);
}

//---------------------------------------------------------------------------

CShingleInstance::CShingleInstance(
    ULONG ulFlags
)
{
    this->ulFlags = ulFlags;
}

CShingleInstance::~CShingleInstance(
)
{
    PKSOBJECT_CREATE_ITEM pCreateItem;

    DPF1(60, "~CShingleInstance: %08x", this);
    ASSERT(this != NULL);
    Assert(this);

    DestroyDeviceInterface();
    FOR_EACH_LIST_ITEM(&lstCreateItem, pCreateItem) {
	DestroyCreateItem(pCreateItem);
    } END_EACH_LIST_ITEM
}

NTSTATUS
CShingleInstance::Create(
    IN PDEVICE_NODE pDeviceNode,
    IN LPGUID pguidClass
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    static ULONG cShingles = 0;

    this->pDeviceNode = pDeviceNode;
    
    //
    // SECURITY NOTE: ALPERS
    // I am not going to switch to strsafe.h just for this.
    // This almost has no risk. cShingles represent the number of 
    // ShingleInstances that have been created. In order for this to overflow
    // cShingles has to be larger than 999999.
    //
    swprintf(wstrReference, L"SAD%d", cShingles++);

    Status = CreateCreateItem(wstrReference);
    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
    Status = CreateDeviceInterface(pguidClass, wstrReference);
    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
    DPF2(60, "CShingleInstance::Create: %08x DN: %08x", this, pDeviceNode);
exit:
    return(Status);
}

NTSTATUS
CShingleInstance::SetDeviceNode(
    IN PDEVICE_NODE pDeviceNode
)
{
    NTSTATUS Status = STATUS_SUCCESS;

    DisableDeviceInterface();
    this->pDeviceNode = pDeviceNode;
    Status = EnableDeviceInterface();
    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
    DPF2(60, "CShingleInstance::SetDeviceNode: %08x DN: %08x",
      this,
      pDeviceNode);
exit:
    return(Status);
}

NTSTATUS
CShingleInstance::CreateCreateItem(
    IN PCWSTR pcwstrReference
)
{
    PKSOBJECT_CREATE_ITEM pCreateItem = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // SECURITY NOTE:
    // The new operator allocates memory and fills it with zeros.
    // Therefore the SECURITY_DESCRIPTOR of KSOBJECT_CREATE_ITEM will
    // be NULL. 
    // That's OK, because we want to apply default security to this object.
    //
    pCreateItem = new KSOBJECT_CREATE_ITEM;
    if(pCreateItem == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }
    pCreateItem->Create = CFilterInstance::FilterDispatchCreate;
    pCreateItem->Context = this;

    RtlInitUnicodeString(&pCreateItem->ObjectClass, pcwstrReference);

    Status = KsAllocateObjectCreateItem(
      gpDeviceInstance->pDeviceHeader,
      pCreateItem,
      FALSE,
      NULL);

    if(!NT_SUCCESS(Status)) {
        //
        // This is used in DestroyCreateItem to determine if it is necessary
        // to call KsFreeObjectCreateItem.
        //
        pCreateItem->ObjectClass.Buffer = NULL;
        goto exit;
    }
    Status = lstCreateItem.AddList(pCreateItem);
    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
    DPF3(60, "CSHI::CreateItem SHI %08x CI %08x %s", 
      this,
      pCreateItem,
      DbgUnicode2Sz((PWSTR)pcwstrReference));
exit:
    if(!NT_SUCCESS(Status)) {
	DestroyCreateItem(pCreateItem);
    }
    return(Status);
}

ENUMFUNC
CShingleInstance::DestroyCreateItem(
    IN PKSOBJECT_CREATE_ITEM pCreateItem
)
{
    if(pCreateItem != NULL) {
	if(pCreateItem->ObjectClass.Buffer != NULL) {

	    KsFreeObjectCreateItem(
	      gpDeviceInstance->pDeviceHeader,
	      &pCreateItem->ObjectClass);
	}
	delete pCreateItem;
    }
    return(STATUS_CONTINUE);
}

NTSTATUS
CShingleInstance::CreateDeviceInterface(
    IN LPGUID pguidClass,
    IN PCWSTR pcwstrReference
)
{
    UNICODE_STRING ustrReference;
    NTSTATUS Status = STATUS_SUCCESS;

    ASSERT(gpDeviceInstance != NULL);
    ASSERT(gpDeviceInstance->pPhysicalDeviceObject != NULL);
    ASSERT(gpDeviceInstance->pDeviceHeader != NULL);
    ASSERT(this->ustrSymbolicLinkName.Buffer == NULL);

    RtlInitUnicodeString(&ustrReference, pcwstrReference);

    Status = IoRegisterDeviceInterface(
       gpDeviceInstance->pPhysicalDeviceObject,
       pguidClass,
       &ustrReference,
       &this->ustrSymbolicLinkName);

    if(!NT_SUCCESS(Status)) {
        goto exit;
    }

    Status = EnableDeviceInterface();
    if(!NT_SUCCESS(Status)) {
	goto exit;
    }

    DPF3(60, "CSHI::CreateDeviceInterface: %08x %s %s",
      this,
      DbgGuid2Sz(pguidClass),
      DbgUnicode2Sz(this->ustrSymbolicLinkName.Buffer));
exit:
    return(Status);
}

NTSTATUS
CShingleInstance::EnableDeviceInterface(
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PWSTR pwstrFriendlyName = L"";
    UNICODE_STRING ustrValueName;
    UNICODE_STRING ustrValue;
    HANDLE hkey = NULL;

    if(this->ustrSymbolicLinkName.Buffer == NULL) {
	ASSERT(NT_SUCCESS(Status));
        goto exit;
    }

    //
    // Put the proxy's CLSID in the new device interface
    //

    Status = IoOpenDeviceInterfaceRegistryKey(
       &this->ustrSymbolicLinkName,
       STANDARD_RIGHTS_ALL,
       &hkey);

    if(!NT_SUCCESS(Status)) {
	goto exit;
    }

    RtlInitUnicodeString(&ustrValueName, L"CLSID");
    RtlInitUnicodeString(&ustrValue, L"{17CCA71B-ECD7-11D0-B908-00A0C9223196}");

    Status = ZwSetValueKey(
      hkey,
      &ustrValueName,
      0, 
      REG_SZ,
      ustrValue.Buffer,
      ustrValue.Length);

    if(!NT_SUCCESS(Status)) {
	goto exit;
    }

    //
    // Set the friendly name into the new device interface
    //

    if(pDeviceNode != NULL) {
        Assert(pDeviceNode);
        if(pDeviceNode->GetFriendlyName() != NULL) {
            pwstrFriendlyName = pDeviceNode->GetFriendlyName();
        }
        else {
            DPF(5, "CSHI::EnableDeviceInterface no friendly name");
        }
    }

    RtlInitUnicodeString(&ustrValueName, L"FriendlyName");

    Status = ZwSetValueKey(
      hkey,
      &ustrValueName,
      0, 
      REG_SZ,
      pwstrFriendlyName,
      (wcslen(pwstrFriendlyName) * sizeof(WCHAR)) + sizeof(UNICODE_NULL));

    if(!NT_SUCCESS(Status)) {
	goto exit;
    }

    Status = IoSetDeviceInterfaceState(&this->ustrSymbolicLinkName, TRUE);
    if(!NT_SUCCESS(Status)) {
        goto exit;
    }

    DPF2(60, "CSHI::EnableDeviceInterface: %08x %s",
      this,
      DbgUnicode2Sz(this->ustrSymbolicLinkName.Buffer));
exit:
    if(hkey != NULL) {
        ZwClose(hkey);
    }
    return(Status);
}

VOID
CShingleInstance::DisableDeviceInterface(
)
{
    Assert(this);
    DPF1(60, "CSHI::DisableDeviceInterface %08x", this);
    if(this->ustrSymbolicLinkName.Buffer != NULL) {
        DPF1(60, "CSHI::DisableDeviceInterface %s", 
          DbgUnicode2Sz(this->ustrSymbolicLinkName.Buffer));
        IoSetDeviceInterfaceState(&this->ustrSymbolicLinkName, FALSE);
    }
}

VOID
CShingleInstance::DestroyDeviceInterface(
)
{
    DisableDeviceInterface();
    RtlFreeUnicodeString(&this->ustrSymbolicLinkName);
    this->ustrSymbolicLinkName.Buffer = NULL;
}

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\sysaudio\si.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   si.cpp
//
//  Description:
//
//	Start Info Class
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//  To Do:     Date	  Author      Comment
//
//@@END_MSINTERNAL
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

NTSTATUS
CStartInfo::Create(
    PSTART_NODE pStartNode,
    PCONNECT_INFO pConnectInfo,
    PGRAPH_PIN_INFO pGraphPinInfo,
    PGRAPH_NODE pGraphNode
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PSTART_INFO pStartInfo;

    Assert(pGraphNode);
    Assert(pStartNode);

    //
    // Check for duplicate StartInfo in this GraphNode. If duplicate
    // AddRef.
    // 
    FOR_EACH_LIST_ITEM(&pGraphNode->lstStartInfo, pStartInfo) {

        if(pStartInfo->GetPinInfo() == pStartNode->pPinNode->pPinInfo &&
           pStartInfo->pConnectInfoHead == pConnectInfo) {

            ASSERT(pStartInfo->pConnectInfoHead->IsSameGraph(pConnectInfo));
            pStartInfo->AddRef();
            goto exit;
        }

    } END_EACH_LIST_ITEM

    pStartInfo = new START_INFO(
      pStartNode->pPinNode->pPinInfo,
      pConnectInfo,
      pGraphPinInfo,
      pGraphNode);

    if(pStartInfo == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }
    DPF2(80, "CStartInfo::Create %08x GN %08x", pStartInfo, pGraphNode);
exit:
    pStartNode->pStartInfo = pStartInfo;
    return(Status);
}

CStartInfo::CStartInfo(
    PPIN_INFO pPinInfo,
    PCONNECT_INFO pConnectInfo,
    PGRAPH_PIN_INFO pGraphPinInfo,
    PGRAPH_NODE pGraphNode
)
{
    Assert(pGraphPinInfo);
    Assert(pGraphNode);

    this->pPinInfo = pPinInfo;
    this->ulTopologyConnectionTableIndex = MAXULONG;
    this->ulVolumeNodeNumberPre = MAXULONG;
    this->ulVolumeNodeNumberSuperMix = MAXULONG;
    this->ulVolumeNodeNumberPost = MAXULONG;
    this->pGraphPinInfo = pGraphPinInfo;
    pGraphPinInfo->AddRef();
    this->pConnectInfoHead = pConnectInfo;
    pConnectInfo->AddRef();
    AddList(&pGraphNode->lstStartInfo);
    AddRef();
    DPF2(80, "CStartInfo: %08x GN %08x", this, pGraphNode);
}

CStartInfo::~CStartInfo(
)
{
    DPF1(80, "~CStartInfo: %08x", this);
    Assert(this);
    RemoveList();
    pGraphPinInfo->Destroy();
    pConnectInfoHead->Destroy();
}

ENUMFUNC
CStartInfo::CreatePinInfoConnection(
    PVOID pReference
)
{
    PGRAPH_NODE pGraphNode = PGRAPH_NODE(pReference);
    PTOPOLOGY_CONNECTION pTopologyConnection = NULL;
    PCONNECT_INFO pConnectInfo;
    NTSTATUS Status;

    Assert(this);
    Assert(pGraphNode);

    for(pConnectInfo = GetFirstConnectInfo();
        pConnectInfo != NULL;
        pConnectInfo = pConnectInfo->GetNextConnectInfo()) {

        Assert(pConnectInfo);
        Status = ::CreatePinInfoConnection(
          &pTopologyConnection,
          NULL,
          pGraphNode,
          pConnectInfo->pPinInfoSource,
          pConnectInfo->pPinInfoSink);

        if(!NT_SUCCESS(Status)) {
            Trap();
            goto exit;
        }
    }
    Status = STATUS_CONTINUE;
exit:
    return(Status);
}

ENUMFUNC
FindVolumeNode(
    IN PTOPOLOGY_CONNECTION pTopologyConnection,
    IN BOOL fToDirection,
    IN PSTART_INFO pStartInfo
)
{
    PTOPOLOGY_PIN pTopologyPin;

    Assert(pTopologyConnection);

    // Need this check when called from EnumerateGraphTopology
    if(IS_CONNECTION_TYPE(pTopologyConnection, GRAPH)) {
        return(STATUS_DEAD_END);
    }

    if(fToDirection) {
       pTopologyPin = pTopologyConnection->pTopologyPinTo;
    }
    else {
       pTopologyPin = pTopologyConnection->pTopologyPinFrom;
    }

    if(pTopologyPin == NULL) {
        return(STATUS_CONTINUE);
    }

    if(IsEqualGUID(pTopologyPin->pTopologyNode->pguidType, &KSNODETYPE_SUM)) {
        return(STATUS_DEAD_END);
    }

    if(IsEqualGUID(pTopologyPin->pTopologyNode->pguidType, &KSNODETYPE_MUX)) {
        return(STATUS_DEAD_END);
    }

    if(IsEqualGUID(
      pTopologyPin->pTopologyNode->pguidType, 
      &KSNODETYPE_SUPERMIX)) {

        Assert(pStartInfo);
        pStartInfo->ulVolumeNodeNumberSuperMix =
          pTopologyPin->pTopologyNode->ulSysaudioNodeNumber;

        DPF1(100, "FindVolumeNode: found supermix node: %02x",
          pStartInfo->ulVolumeNodeNumberSuperMix);

        return(STATUS_CONTINUE);
    }

    if(IsEqualGUID(
      pTopologyPin->pTopologyNode->pguidType,
      &KSNODETYPE_VOLUME)) {

        Assert(pStartInfo);
        if(pStartInfo->ulVolumeNodeNumberSuperMix != MAXULONG) {

            // Found a volume node after a super mix
            pStartInfo->ulVolumeNodeNumberPost =
              pTopologyPin->pTopologyNode->ulSysaudioNodeNumber;

            DPF1(100, "FindVolumeNode: found post node: %02x",
              pStartInfo->ulVolumeNodeNumberPost);

            return(STATUS_SUCCESS);
        }

        if(pStartInfo->ulVolumeNodeNumberPre == MAXULONG) {

            // Found first volume node
            pStartInfo->ulVolumeNodeNumberPre =
              pTopologyPin->pTopologyNode->ulSysaudioNodeNumber;

            DPF1(100, "FindVolumeNode: found pre node: %02x",
              pStartInfo->ulVolumeNodeNumberPre);
        }
    }
    return(STATUS_CONTINUE);
}

ENUMFUNC
CStartInfo::EnumStartInfo(
)
{
    Assert(this);

    DPF3(100, "EnumStartInfo: %08x %d %s", 
      this,
      GetPinInfo()->PinId,
      GetPinInfo()->pFilterNode->DumpName());

    EnumerateGraphTopology(
      this,
      (TOP_PFN)FindVolumeNode,
      this);

    return(STATUS_CONTINUE);
}

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\sysaudio\sn.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   sn.cpp
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//  To Do:     Date	  Author      Comment
//
//@@END_MSINTERNAL
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

NTSTATUS
CStartNode::Create(
    PPIN_NODE pPinNode,
    PCONNECT_NODE pConnectNode,
    PGRAPH_PIN_INFO pGraphPinInfo,
    ULONG ulFlagsCurrent,
    ULONG ulOverhead,
    PGRAPH_NODE pGraphNode
)
{
    PTOPOLOGY_CONNECTION pTopologyConnection;
    NTSTATUS Status = STATUS_SUCCESS;
    PSTART_NODE pStartNode = NULL;

    Assert(pPinNode);
    Assert(pGraphNode);

    if((pPinNode->pPinInfo->Communication == KSPIN_COMMUNICATION_SOURCE)) {
        ASSERT(NT_SUCCESS(Status));
        ASSERT(pStartNode == NULL);
        goto exit;
    }

    if(pPinNode->pPinInfo->Communication == KSPIN_COMMUNICATION_SINK ||
       pPinNode->pPinInfo->Communication == KSPIN_COMMUNICATION_BOTH) {

        // Don't create a sysaudio pin if OUT/RENDER or IN/CAPTURER
        if(pPinNode->pPinInfo->DataFlow == KSPIN_DATAFLOW_OUT &&
          ulFlagsCurrent & LFN_FLAGS_CONNECT_RENDER) {
            DPF1(50, "CStartNode::Create PN %08x - out/render", pPinNode);
            ASSERT(NT_SUCCESS(Status));
            ASSERT(pStartNode == NULL);
            goto exit;
        }
        
        if(pPinNode->pPinInfo->DataFlow == KSPIN_DATAFLOW_IN &&
          ulFlagsCurrent & LFN_FLAGS_CONNECT_CAPTURE) {
            DPF1(50, "CStartNode::Create PN %08x - in/capturer", pPinNode);
            ASSERT(NT_SUCCESS(Status));
            ASSERT(pStartNode == NULL);
            goto exit;
        }
    }

    FOR_EACH_LIST_ITEM(
      &pPinNode->pPinInfo->lstTopologyConnection,
      pTopologyConnection) {

        // Only check physical connections
        if(!IS_CONNECTION_TYPE(pTopologyConnection, PHYSICAL)) {
            continue;
        }

        // If there is one connection that is valid for this GraphNode
        if(pTopologyConnection->IsTopologyConnectionOnGraphNode(pGraphNode)) {

            // Don't create a sysaudio pin
            DPF4(80, "CStartNode::Create %s PN %08x TC %08x GN %08x connected",
              pPinNode->pPinInfo->pFilterNode->DumpName(),
              pPinNode,
              pTopologyConnection,
              pGraphNode);

            ASSERT(NT_SUCCESS(Status));
            ASSERT(pStartNode == NULL);
            goto exit;
        }
    } END_EACH_LIST_ITEM

    pStartNode = new START_NODE(
      pPinNode,
      pConnectNode,
      ulOverhead,
      pGraphNode);

    if(pStartNode == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }
    Status = CStartInfo::Create(
      pStartNode,
      pConnectNode->GetConnectInfo(),
      pGraphPinInfo,
      pGraphNode);

    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }
    DPF3(80, "CStartNode::Create %08x PN %08x O %08x",
      pStartNode,
      pPinNode,
      pStartNode->ulOverhead);

    //
    // For capture graphs only.
    //
    if (pStartNode->pPinNode->pPinInfo->DataFlow == KSPIN_DATAFLOW_OUT) {
        pStartNode->SetSpecialFlags();
    }
exit:
    if(!NT_SUCCESS(Status)) {
        if (pStartNode) {
            pStartNode->Destroy();
        }
    }
    return(Status);
}

CStartNode::CStartNode(
    PPIN_NODE pPinNode,
    PCONNECT_NODE pConnectNode,
    ULONG ulOverhead,
    PGRAPH_NODE pGraphNode
)
{
    Assert(pPinNode);
    Assert(pGraphNode);
    this->pPinNode = pPinNode;
    this->ulOverhead = ulOverhead + pPinNode->GetOverhead();
    this->pConnectNodeHead = pConnectNode;
    this->ulFlags = 0;
    this->fRender = (pPinNode->pPinInfo->DataFlow == KSPIN_DATAFLOW_IN);
    this->ulSpecialFlags = STARTNODE_SPECIALFLAG_NONE;
    pConnectNode->AddRef();
    if(pPinNode->GetType() & FILTER_TYPE_VIRTUAL) {
        AddListEnd(&pGraphNode->lstStartNode);
    }
    else {
        AddList(&pGraphNode->lstStartNode);
    }
    DPF3(80, "CStartNode: %08x PN %08x O %08x", this, pPinNode, ulOverhead);
}

CStartNode::~CStartNode(
)
{
    DPF1(80, "~CStartNode: %08x", this);
    Assert(this);
    RemoveList();
    pStartInfo->Destroy();
    pConnectNodeHead->Destroy();
}

void
CStartNode::SetSpecialFlags()
{
    //
    // STARTNODE_SPECIALFLAG_STRICT
    // Get the last ConnectNode in connection list and check if the
    // source pin is splitter.
    // Also the first pin should be splitter pin.
    //

    //
    // STARTNODE_SPECIALFLAG_AEC
    // If the StartNode contains Aec mark the StartNode with this flag.
    //
    
    // 
    // ISSUE-2001/03/09-alpers
    // In the future two splitters in the graph will not work
    // with this logic.
    // We need a way of knowing if a filter does SRC upfront.
    //

    if (pConnectNodeHead)
    {
        PCONNECT_NODE pConnectNode;

        for(pConnectNode = pConnectNodeHead;
            pConnectNode->GetNextConnectNode() != NULL;
            pConnectNode = pConnectNode->GetNextConnectNode()) {

            if (pConnectNode->pPinNodeSource->pLogicalFilterNode->
                pFilterNode->GetType() & FILTER_TYPE_AEC) {

                ulSpecialFlags |= STARTNODE_SPECIALFLAG_AEC;
            }
        }

        ulSpecialFlags |= 
            (pConnectNode->pPinNodeSource->pPinInfo->
             pFilterNode->GetType() & FILTER_TYPE_SPLITTER) &&
            (pPinNode->pPinInfo->pFilterNode->GetType() & FILTER_TYPE_SPLITTER) ?
            STARTNODE_SPECIALFLAG_STRICT :
            STARTNODE_SPECIALFLAG_NONE;
    }

    DPF3(50, "CStartNode: %08x %s SpecialFlags %X", this, 
        DbgUnicode2Sz(pPinNode->pPinInfo->pFilterNode->GetFriendlyName()),
        ulSpecialFlags);
    
}

ENUMFUNC
CStartNode::RemoveBypassPaths(
    PVOID pReference
)
{
    PGRAPH_NODE pGraphNode = PGRAPH_NODE(pReference);
    PLOGICAL_FILTER_NODE pLogicalFilterNode;
    PCONNECT_NODE pConnectNode;
    ULONG cLfnNoBypassTotal = 0;
    ULONG cLfnNoBypass = 0;
    ULONG ulFlags;
    ULONG cAecFilterCount = 0;
    BOOL  fDestroy;

    Assert(this);
    Assert(pGraphNode);

    if(pPinNode->pPinInfo->Communication == KSPIN_COMMUNICATION_NONE ||
       pPinNode->pPinInfo->Communication == KSPIN_COMMUNICATION_BRIDGE ||
       pPinNode->pPinInfo->Communication == KSPIN_COMMUNICATION_SOURCE) {
	return(STATUS_CONTINUE);
    }

    if(pPinNode->pPinInfo->DataFlow == KSPIN_DATAFLOW_IN) {
	ulFlags = LFN_FLAGS_CONNECT_RENDER;
        DPF(60,"RBP - for Render");
    }
    else {
	ASSERT(pPinNode->pPinInfo->DataFlow == KSPIN_DATAFLOW_OUT);
	ulFlags = LFN_FLAGS_CONNECT_CAPTURE;
        DPF(60,"RBP - for Capture");
    }

    FOR_EACH_LIST_ITEM(
      &pGraphNode->lstLogicalFilterNodeNoBypass,
      pLogicalFilterNode) {

	if(pLogicalFilterNode->GetFlags() & ulFlags) {
	    ++cLfnNoBypassTotal;
	}

    } END_EACH_LIST_ITEM

    DPF1(60,"RBP:NoBypassTotal = %08x", cLfnNoBypassTotal);

    for(pConnectNode = GetFirstConnectNode();
	pConnectNode != NULL;
	pConnectNode = pConnectNode->GetNextConnectNode()) {

	Assert(pConnectNode);
	FOR_EACH_LIST_ITEM(
	  &pGraphNode->lstLogicalFilterNodeNoBypass,
	  pLogicalFilterNode) {

	    if(pLogicalFilterNode->GetFlags() & ulFlags) {
		Assert(pConnectNode->pPinNodeSource);
		Assert(pConnectNode->pPinNodeSource->pLogicalFilterNode);
		if(pConnectNode->pPinNodeSource->pLogicalFilterNode == 
		   pLogicalFilterNode) {
		     cLfnNoBypass++;
		}
	    }

	} END_EACH_LIST_ITEM

        DPF1(60,"RBP:FilterInPath = %s",
              DbgUnicode2Sz(pConnectNode->pPinNodeSource->pLogicalFilterNode->pFilterNode->GetFriendlyName()));

        //
        // In capture paths count AEC filters to avoid conflict with GFXes
        //
        if((ulFlags & LFN_FLAGS_CONNECT_CAPTURE) &&
           (pConnectNode->pPinNodeSource->pLogicalFilterNode->pFilterNode->GetType() & FILTER_TYPE_AEC)) {
                ++cAecFilterCount;
        }
    }

    ASSERT(cAecFilterCount < 2);

    DPF2(60,"RBP:NBPCount=%08x, AECCount=%08x", cLfnNoBypass, cAecFilterCount);

    //
    // Mark all the paths with NO Gfx as second pass candidates
    // We do this to support the following sequence of capture pin creations
    //   1. Client installs GFX(es) on a capture device
    //   2. Client creates a pin with AEC
    //      This would result in creating a Capture->Splitter->AEC path
    //   3. Client tries to create a regular capture pin (with GFX)
    //      In this case we want to create a regular path (but since no GFX
    //      hooked up between capture and splitter. We create a capture->splitter->[kmixer] path
    //      These special paths are marked as secondpass. And we try these paths
    //      only if all the primary start nodes failed to instantiate a pin.
    //      (look in pins.cpp - PinDispatchCreateKP()
    //
    if(cLfnNoBypassTotal != 0) {
        if(cLfnNoBypass == 0) {
            this->ulFlags |= STARTNODE_FLAGS_SECONDPASS;
        }
    }

    //
    // Assume that this path is going to be OK
    //
    fDestroy = FALSE;


    if (cAecFilterCount == 0) {
        //
        // There is no AEC in this path
        // We have to make sure that we have all the necessary
        // GFXs loaded in this path. (Else destroy the path)
        //
        if(cLfnNoBypass != cLfnNoBypassTotal) {
            fDestroy = TRUE;
        }
    }
    else {
        //
        // There is an AEC in this path
        // No GFXs should be there in this path. If there is even one GFX
        // destroy the path
        //
        if ((cLfnNoBypass != 0) || (cAecFilterCount > 1)) {
            fDestroy = TRUE;
        }
    }

    if ((fDestroy) && ((this->ulFlags & STARTNODE_FLAGS_SECONDPASS) == 0)) {
        Destroy();
        DPF(60,"RBP:PathDestroyed");
    }

    DPF(60,"RBP:Done");
    return(STATUS_CONTINUE);
}

ENUMFUNC
CStartNode::RemoveConnectedStartNode(
    PVOID pReference
)
{
    PGRAPH_NODE pGraphNode = PGRAPH_NODE(pReference);
    PCONNECT_NODE pConnectNode;
    PSTART_NODE pStartNode;

    Assert(this);
    Assert(pGraphNode);

    FOR_EACH_LIST_ITEM(&pGraphNode->lstStartNode, pStartNode) {

	if(this == pStartNode) {
	    continue;
	}
	for(pConnectNode = pStartNode->GetFirstConnectNode();
	    pConnectNode != NULL;
	    pConnectNode = pConnectNode->GetNextConnectNode()) {

	    if(this->pPinNode == pConnectNode->pPinNodeSink) {
		DPF3(50, "CStartNode::RemoveConnectedSN %08x GN %08x %s",
		  this,
		  pGraphNode,
		  pPinNode->pPinInfo->pFilterNode->DumpName());

		Destroy();
		return(STATUS_CONTINUE);
	    }
	}

    } END_EACH_LIST_ITEM

    return(STATUS_CONTINUE);
}

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\sysaudio\registry.h ===
//---------------------------------------------------------------------------
//
//  Module:   registry.h
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date       Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Constants and Macros
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Global Data
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Data structures
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Local prototypes
//---------------------------------------------------------------------------

NTSTATUS
OpenRegistryKeyForRead(
    PCWSTR pcwstr,
    PHANDLE pHandle,
    HANDLE hRootDir = NULL
);


NTSTATUS
QueryRegistryValue(
    HANDLE hkey,
    PCWSTR pcwstrValueName,
    PKEY_VALUE_FULL_INFORMATION *ppkvfi
);

//---------------------------------------------------------------------------
//  End of File: registry.h
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\sysaudio\sn.h ===
//---------------------------------------------------------------------------
//
//  Module:   		sn.h
//
//  Description:	start node classes
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Constants and Macros
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Classes
//---------------------------------------------------------------------------

#define STARTNODE_FLAGS_SECONDPASS    0x01

#define STARTNODE_SPECIALFLAG_NONE    0

// StartNode must connect with the same format bottom up.
// Use this information to optimize graph building.
#define STARTNODE_SPECIALFLAG_STRICT  0x00000001 

// StartNode contains Aec filter.
#define STARTNODE_SPECIALFLAG_AEC     0x00000002

typedef class CStartNode : public CListDoubleItem
{
    friend class CStartInfo;
private:
    CStartNode(
        PPIN_NODE pPinNode,
        PCONNECT_NODE pConnectNode,
        ULONG ulOverhead,
        PGRAPH_NODE pGraphNode
    );

    ~CStartNode(
    );

public:
    static NTSTATUS
    Create(
        PPIN_NODE pPinNode,
        PCONNECT_NODE pConnectNode,
        PGRAPH_PIN_INFO pGraphPinInfo,
        ULONG ulFlagsCurrent,
        ULONG ulOverhead,
        PGRAPH_NODE pGraphNode
    );

    ENUMFUNC
    Destroy()
    {
        Assert(this);
        delete this;
        return(STATUS_CONTINUE);
    };

    PGRAPH_PIN_INFO
    GetGraphPinInfo(
    )
    {
        Assert(this);
        return(pStartInfo->GetGraphPinInfo());
    };

    ENUMFUNC
    RemoveBypassPaths(
        PVOID pGraphNode
    );

    ENUMFUNC
    RemoveConnectedStartNode(
        PVOID pReference
    );

    PKSPIN_CINSTANCES
    GetPinInstances(
    )
    {
        Assert(this);
        return(pStartInfo->GetPinInstances());
    };

    VOID
    AddPinInstance(
    )
    {
        Assert(this);
        pStartInfo->AddPinInstance();
    };

    VOID
    RemovePinInstance(
    )
    {
        Assert(this);
        pStartInfo->RemovePinInstance();
    };

    BOOL
    IsPinInstances(
    )
    {
        Assert(this);
        return(pStartInfo->IsPinInstances());
    };

    BOOL
    IsPossibleInstances(
    )
    {
        Assert(this);
        return(pStartInfo->IsPossibleInstances());
    };

    PCONNECT_NODE
    GetFirstConnectNode(
    )
    {
        return(pConnectNodeHead);
    };

    PSTART_INFO
    GetStartInfo(
    )
    {
        Assert(this);
        return(pStartInfo);
    };

    BOOL
    IsCaptureFormatStrict(
    )
    {
        return ulSpecialFlags & STARTNODE_SPECIALFLAG_STRICT;
    };

    BOOL
    IsAecIncluded(
    )
    {
        return ulSpecialFlags & STARTNODE_SPECIALFLAG_AEC;
    };

private:
    void 
    SetSpecialFlags();

private:
    PSTART_INFO pStartInfo;
    PCONNECT_NODE pConnectNodeHead;
    ULONG ulSpecialFlags;    
public:
    BOOL fRender;
    ULONG ulOverhead;
    ULONG ulFlags;
    PPIN_NODE pPinNode;
    DefineSignature(0x20204e53);			// SN

} START_NODE, *PSTART_NODE;

//---------------------------------------------------------------------------

typedef ListDoubleDestroy<START_NODE> LIST_START_NODE;

//---------------------------------------------------------------------------

typedef ListData<START_NODE> LIST_DATA_START_NODE, *PLIST_DATA_START_NODE;

//---------------------------------------------------------------------------
// Globals
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Local prototypes
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\sysaudio\shi.h ===
//---------------------------------------------------------------------------
//
//  Module:   		shi.h
//
//  Description:	Shingle Instance Class
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Constants and Macros
//---------------------------------------------------------------------------

#define MAX_SYSAUDIO_DEFAULT_TYPE	(KSPROPERTY_SYSAUDIO_MIXER_DEFAULT+1)

//---------------------------------------------------------------------------
// Class
//---------------------------------------------------------------------------

typedef class CShingleInstance : public CObj
{
public:
    CShingleInstance(
        ULONG ulFlags = 0
    );

    ~CShingleInstance();

    static NTSTATUS 
    InitializeShingle(
    );

    static VOID 
    UninitializeShingle(
    );

    static NTSTATUS
    InitializeShingleWorker(
	PVOID pReference1,
	PVOID pReference2
    );

    NTSTATUS 
    Create(
	IN PDEVICE_NODE pDeviceNode,
	IN LPGUID pguidClass
    );

    NTSTATUS
    SetDeviceNode(
	IN PDEVICE_NODE pDeviceNode
    );

    PDEVICE_NODE
    GetDeviceNode(
    )
    {
	return(pDeviceNode);
    };

private:
    NTSTATUS
    CreateCreateItem(
	IN PCWSTR pcwstrReference
    );

    ENUMFUNC
    DestroyCreateItem(
	IN PKSOBJECT_CREATE_ITEM pCreateItem
    );

    NTSTATUS
    CreateDeviceInterface(
	IN LPGUID pguidClass,
	IN PCWSTR pcwstrReference
    );

    NTSTATUS
    EnableDeviceInterface(
    );

    VOID
    DisableDeviceInterface(
    );

    VOID
    DestroyDeviceInterface(
    );

    ListDataAssertLess<KSOBJECT_CREATE_ITEM> lstCreateItem;
    UNICODE_STRING ustrSymbolicLinkName;
    WCHAR wstrReference[10];
    PDEVICE_NODE pDeviceNode;

public:
    ULONG ulFlags;

    DefineSignature(0x20494853);		// SHI

} SHINGLE_INSTANCE, *PSHINGLE_INSTANCE;

//---------------------------------------------------------------------------
// Globals
//---------------------------------------------------------------------------

extern PSHINGLE_INSTANCE apShingleInstance[];

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\sysaudio\sni.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   sni.cpp
//
//  Description:
//
//	Start Node Instance
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//  To Do:     Date	  Author      Comment
//
//@@END_MSINTERNAL
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"

//---------------------------------------------------------------------------

WAVEFORMATEX aWaveFormatEx[] = {
   {
       WAVE_FORMAT_PCM,					// wFormatTag
       2,						// nChannels
       44100,						// nSamplesPerSec
       0,						// nAvgBytesPerSec
       0,						// nBlockAlign
       16,						// wBitsPerSample
       0,						// cbSize
   },
   {
       WAVE_FORMAT_PCM,					// wFormatTag
       1,						// nChannels
       44100,						// nSamplesPerSec
       0,						// nAvgBytesPerSec
       0,						// nBlockAlign
       16,						// wBitsPerSample
       0,						// cbSize
   },
   {
       WAVE_FORMAT_PCM,					// wFormatTag
       2,						// nChannels
       44100,						// nSamplesPerSec
       0,						// nAvgBytesPerSec
       0,						// nBlockAlign
       8,						// wBitsPerSample
       0,						// cbSize
   },
   {
       WAVE_FORMAT_PCM,					// wFormatTag
       1,						// nChannels
       44100,						// nSamplesPerSec
       0,						// nAvgBytesPerSec
       0,						// nBlockAlign
       8,						// wBitsPerSample
       0,						// cbSize
   },
   {
       WAVE_FORMAT_PCM,					// wFormatTag
       2,						// nChannels
       48000,						// nSamplesPerSec
       0,						// nAvgBytesPerSec
       0,						// nBlockAlign
       16,						// wBitsPerSample
       0,						// cbSize
   },
   {
       WAVE_FORMAT_PCM,					// wFormatTag
       1,						// nChannels
       48000,						// nSamplesPerSec
       0,						// nAvgBytesPerSec
       0,						// nBlockAlign
       16,						// wBitsPerSample
       0,						// cbSize
   },
   {
       WAVE_FORMAT_PCM,					// wFormatTag
       2,						// nChannels
       48000,						// nSamplesPerSec
       0,						// nAvgBytesPerSec
       0,						// nBlockAlign
       8,						// wBitsPerSample
       0,						// cbSize
   },
   {
       WAVE_FORMAT_PCM,					// wFormatTag
       1,						// nChannels
       48000,						// nSamplesPerSec
       0,						// nAvgBytesPerSec
       0,						// nBlockAlign
       8,						// wBitsPerSample
       0,						// cbSize
   },
   {
       WAVE_FORMAT_PCM,					// wFormatTag
       2,						// nChannels
       32000,						// nSamplesPerSec
       0,						// nAvgBytesPerSec
       0,						// nBlockAlign
       16,						// wBitsPerSample
       0,						// cbSize
   },
   {
       WAVE_FORMAT_PCM,					// wFormatTag
       1,						// nChannels
       32000,						// nSamplesPerSec
       0,						// nAvgBytesPerSec
       0,						// nBlockAlign
       16,						// wBitsPerSample
       0,						// cbSize
   },
   {
       WAVE_FORMAT_PCM,					// wFormatTag
       2,						// nChannels
       32000,						// nSamplesPerSec
       0,						// nAvgBytesPerSec
       0,						// nBlockAlign
       8,						// wBitsPerSample
       0,						// cbSize
   },
   {
       WAVE_FORMAT_PCM,					// wFormatTag
       1,						// nChannels
       32000,						// nSamplesPerSec
       0,						// nAvgBytesPerSec
       0,						// nBlockAlign
       8,						// wBitsPerSample
       0,						// cbSize
   },
   {
       WAVE_FORMAT_PCM,					// wFormatTag
       2,						// nChannels
       22050,						// nSamplesPerSec
       0,						// nAvgBytesPerSec
       0,						// nBlockAlign
       16,						// wBitsPerSample
       0,						// cbSize
   },
   {
       WAVE_FORMAT_PCM,					// wFormatTag
       1,						// nChannels
       22050,						// nSamplesPerSec
       0,						// nAvgBytesPerSec
       0,						// nBlockAlign
       16,						// wBitsPerSample
       0,						// cbSize
   },
   {
       WAVE_FORMAT_PCM,					// wFormatTag
       2,						// nChannels
       22050,						// nSamplesPerSec
       0,						// nAvgBytesPerSec
       0,						// nBlockAlign
       8,						// wBitsPerSample
       0,						// cbSize
   },
   {
       WAVE_FORMAT_PCM,					// wFormatTag
       1,						// nChannels
       22050,						// nSamplesPerSec
       0,						// nAvgBytesPerSec
       0,						// nBlockAlign
       8,						// wBitsPerSample
       0,						// cbSize
   },
   {
       WAVE_FORMAT_PCM,					// wFormatTag
       2,						// nChannels
       16000,						// nSamplesPerSec
       0,						// nAvgBytesPerSec
       0,						// nBlockAlign
       16,						// wBitsPerSample
       0,						// cbSize
   },
   {
       WAVE_FORMAT_PCM,					// wFormatTag
       1,						// nChannels
       16000,						// nSamplesPerSec
       0,						// nAvgBytesPerSec
       0,						// nBlockAlign
       16,						// wBitsPerSample
       0,						// cbSize
   },
   {
       WAVE_FORMAT_PCM,					// wFormatTag
       2,						// nChannels
       16000,						// nSamplesPerSec
       0,						// nAvgBytesPerSec
       0,						// nBlockAlign
       8,						// wBitsPerSample
       0,						// cbSize
   },
   {
       WAVE_FORMAT_PCM,					// wFormatTag
       1,						// nChannels
       16000,						// nSamplesPerSec
       0,						// nAvgBytesPerSec
       0,						// nBlockAlign
       8,						// wBitsPerSample
       0,						// cbSize
   },
   {
       WAVE_FORMAT_PCM,					// wFormatTag
       2,						// nChannels
       11025,						// nSamplesPerSec
       0,						// nAvgBytesPerSec
       0,						// nBlockAlign
       16,						// wBitsPerSample
       0,						// cbSize
   },
   {
       WAVE_FORMAT_PCM,					// wFormatTag
       1,						// nChannels
       11025,						// nSamplesPerSec
       0,						// nAvgBytesPerSec
       0,						// nBlockAlign
       16,						// wBitsPerSample
       0,						// cbSize
   },
   {
       WAVE_FORMAT_PCM,					// wFormatTag
       2,						// nChannels
       11025,						// nSamplesPerSec
       0,						// nAvgBytesPerSec
       0,						// nBlockAlign
       8,						// wBitsPerSample
       0,						// cbSize
   },
   {
       WAVE_FORMAT_PCM,					// wFormatTag
       1,						// nChannels
       11025,						// nSamplesPerSec
       0,						// nAvgBytesPerSec
       0,						// nBlockAlign
       8,						// wBitsPerSample
       0,						// cbSize
   },
   {
       WAVE_FORMAT_PCM,					// wFormatTag
       2,						// nChannels
       8000,						// nSamplesPerSec
       0,						// nAvgBytesPerSec
       0,						// nBlockAlign
       16,						// wBitsPerSample
       0,						// cbSize
   },
   {
       WAVE_FORMAT_PCM,					// wFormatTag
       1,						// nChannels
       8000,						// nSamplesPerSec
       0,						// nAvgBytesPerSec
       0,						// nBlockAlign
       16,						// wBitsPerSample
       0,						// cbSize
   },
   {
       WAVE_FORMAT_PCM,					// wFormatTag
       2,						// nChannels
       8000,						// nSamplesPerSec
       0,						// nAvgBytesPerSec
       0,						// nBlockAlign
       8,						// wBitsPerSample
       0,						// cbSize
   },
   {
       WAVE_FORMAT_PCM,					// wFormatTag
       1,						// nChannels
       8000,						// nSamplesPerSec
       0,						// nAvgBytesPerSec
       0,						// nBlockAlign
       8,						// wBitsPerSample
       0,						// cbSize
   },
};

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

NTSTATUS
CStartNodeInstance::Create(
    PPIN_INSTANCE pPinInstance,
    PSTART_NODE pStartNode,
    PKSPIN_CONNECT pPinConnect,
    PWAVEFORMATEX pWaveFormatExRequested
)
{
    PSTART_NODE_INSTANCE pStartNodeInstance = NULL;
    NTSTATUS Status = STATUS_INVALID_DEVICE_REQUEST;

    Assert(pPinInstance);
    Assert(pStartNode);
    Assert(pStartNode->pPinNode);

    DPF3(90, "CSNI::Create SN %08x #%d %s", 
      pStartNode,
      pStartNode->pPinNode->pPinInfo->PinId,
      pStartNode->pPinNode->pPinInfo->pFilterNode->DumpName());

#ifdef DEBUG
    DumpDataRange(95, (PKSDATARANGE_AUDIO)pStartNode->pPinNode->pDataRange);
#endif

    //
    // First few checks compare the StartNode datarange to pPinConnect
    // datarange.
    //
    if(!CompareIdentifier(
      pStartNode->pPinNode->pMedium,
      &pPinConnect->Medium)) {
        Trap();
        DPF1(90, "CSNI::Create: Medium %08X", pStartNode);
        ASSERT(Status == STATUS_INVALID_DEVICE_REQUEST);
        goto exit;
    }

    if(!CompareIdentifier(
      pStartNode->pPinNode->pInterface,
      &pPinConnect->Interface)) {
        DPF1(90, "CSNI::Create: Interface %08X", pStartNode);
        ASSERT(Status == STATUS_INVALID_DEVICE_REQUEST);
        goto exit;
    }

    if(!CompareDataRangeGuids(
      pStartNode->pPinNode->pDataRange,
      (PKSDATARANGE)(pPinConnect + 1))) {
        DPF1(90, "CSNI::Create: DataRange GUID %08X", pStartNode);
        ASSERT(Status == STATUS_INVALID_DEVICE_REQUEST);
        goto exit;
    }

    //
    // VOICE MANAGEMENT and HW ACCELARATION
    // For HW accelarated pins we are not relying on local sysaudio 
    // instance counts. PinCreate request will be sent down to the driver.
    // It is upto the driver to reject the request based on its capabilities.
    //
    if ((pStartNode->pPinNode->pPinInfo->pFilterNode->GetType() & FILTER_TYPE_RENDERER) &&
        (KSPIN_DATAFLOW_IN == pStartNode->pPinNode->pPinInfo->DataFlow) &&
        (KSPIN_COMMUNICATION_SINK == pStartNode->pPinNode->pPinInfo->Communication)) {

        DPF(20,"StartInfo::IsPinInstances return TRUE for HW");
    } 
    else {
        if(!pStartNode->IsPinInstances()) {
            DPF1(90, "CSNI::Create: no instances SN %08X", pStartNode);
            Status = STATUS_DEVICE_BUSY;
            goto exit;
        }
    }
 
    pStartNodeInstance = new START_NODE_INSTANCE(pPinInstance, pStartNode);
    if(pStartNodeInstance == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }

    //
    // If capture pin, try some intelligent variations of requested format
    //
    if(!NT_SUCCESS(Status) &&
        pWaveFormatExRequested != NULL &&
        pStartNode->pPinNode->pPinInfo->DataFlow == KSPIN_DATAFLOW_OUT) {

        DPF(90, "CSNI::Create: IntelligentConnect");

        Status = pStartNodeInstance->IntelligentConnect(
                    pPinInstance->pFilterInstance->GetDeviceNode(),
                    pPinConnect,
                    pWaveFormatExRequested);

        //
        // If the graph contains only splitter and capturer, only the 
        // requested format can succeed.
        // So exit here.
        //
        if (pStartNodeInstance->pStartNode->IsCaptureFormatStrict()) {
            DPF1(50, "CSNI::Create: CaptureFormatStrict Bailing Out: Status %X", Status);
            goto exit;           
        }
    }

    //
    // If capture pin and if aec is included, negotiate format between
    // aec and capture device.
    //
    if(!NT_SUCCESS(Status) &&
        pStartNode->IsAecIncluded() &&
        pStartNode->pPinNode->pPinInfo->DataFlow == KSPIN_DATAFLOW_OUT) {

        PKSPIN_CONNECT pPinConnectDirect = NULL;

        DPF(90, "CSNI::Create: AecConnection");

        Status = pStartNodeInstance->AecConnectionFormat(
                    pPinInstance->pFilterInstance->GetDeviceNode(),
                    &pPinConnectDirect);

        //
        // Try mono/stereo formats first.
        //
        if (NT_SUCCESS(Status)) {
            for (WORD i = 1; i <= 2; i++) {
                ModifyPinConnect(pPinConnectDirect, i);

                Status = pStartNodeInstance->Connect(
                  pPinInstance->pFilterInstance->GetDeviceNode(),
                  pPinConnect,
                  NULL,
                  pPinConnectDirect);
                if (NT_SUCCESS(Status)) {
                    break;
                }
            }
        }
        
        if (pPinConnectDirect) {
            delete pPinConnectDirect;
        }
    }

    
    //
    // Try pin data intersection
    //
    if(!NT_SUCCESS(Status)) {
        DPF(90, "CSNI::Create: Data Intersection");

        Status = pStartNodeInstance->Connect(
          pPinInstance->pFilterInstance->GetDeviceNode(),
          pPinConnect,
          NULL,
          NULL);
    }

    if(!NT_SUCCESS(Status)) {
        int i;

        //
        // Try each waveformatex limit until success
        //
        for(i = 0; i < SIZEOF_ARRAY(aWaveFormatEx); i++) {

            DPF3(90, "CSNI::Create: Array SR %d CH %d BPS %d",
              aWaveFormatEx[i].nSamplesPerSec,
              aWaveFormatEx[i].nChannels,
              aWaveFormatEx[i].wBitsPerSample);

            Status = pStartNodeInstance->Connect(
              pPinInstance->pFilterInstance->GetDeviceNode(),
              pPinConnect,
              &aWaveFormatEx[i],
              NULL);

            if(NT_SUCCESS(Status)) {
                break;
            }
        }
    }

    if(!NT_SUCCESS(Status)) {
        goto exit;
    }

    //
    // Now all the pins in the graph are connected successfully. 
    // Create the topology table.
    //
    Status = pStartNodeInstance->CreateTopologyTable(
      pPinInstance->pFilterInstance->pGraphNodeInstance);

    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }
    ASSERT(pStartNodeInstance->CurrentState == KSSTATE_STOP);

    DPF1(90, "CSNI::Create: SUCCESS %08x", pStartNodeInstance);
exit:
    if(!NT_SUCCESS(Status)) {
        DPF1(90, "CSNI::Create: FAIL %08x", Status);
        delete pStartNodeInstance;
    }
    return(Status);
}

CStartNodeInstance::CStartNodeInstance(
    PPIN_INSTANCE pPinInstance,
    PSTART_NODE pStartNode
)
{
    this->pStartNode = pStartNode;
    pStartNode->AddPinInstance();
    this->pPinInstance = pPinInstance;
    pPinInstance->pStartNodeInstance = this;
    AddList(
      &pPinInstance->pFilterInstance->pGraphNodeInstance->lstStartNodeInstance);
}

CStartNodeInstance::~CStartNodeInstance(
)
{
    PINSTANCE pInstance;

    ASSERT(this != NULL);
    Assert(this);
    Assert(pPinInstance);
    DPF1(95, "~CSNI: %08x", this);
    RemoveList();

    SetState(KSSTATE_STOP, SETSTATE_FLAG_IGNORE_ERROR);
    pStartNode->RemovePinInstance();

    if (pPinNodeInstance)
    {
        pPinNodeInstance->Destroy();        // also see CSNI::CleanUp
    }

    if (pFilterNodeInstance)
    {
        pFilterNodeInstance->Destroy();
    }

    delete [] papFileObjectTopologyTable;
    delete pVirtualNodeData;
    pPinInstance->pStartNodeInstance = NULL;
    pPinInstance->ParentInstance.Invalidate();
}

VOID
CStartNodeInstance::CleanUp(
)
{
    Assert(this);
    ASSERT(papFileObjectTopologyTable == NULL);
    ASSERT(pVirtualNodeData == NULL);
    ASSERT(CurrentState == KSSTATE_STOP);

    if (pPinNodeInstance)
    {
        pPinNodeInstance->Destroy();
        pPinNodeInstance = NULL;
    }
    if (pFilterNodeInstance)
    {
        pFilterNodeInstance->Destroy();
        pFilterNodeInstance = NULL;
    }
    
    lstConnectNodeInstance.DestroyList();
}

NTSTATUS
CStartNodeInstance::IntelligentConnect(
    PDEVICE_NODE pDeviceNode,
    PKSPIN_CONNECT pPinConnect,
    PWAVEFORMATEX pWaveFormatEx
)
{
    PWAVEFORMATEXTENSIBLE pWaveFormatExtensible;
    NTSTATUS        Status;
    BOOL            Continue;
    WORD            NumChannels, BitWidth;
    PBYTE           pWaveFormat = NULL;
    ULONG           RegionAllocSize, RegionCopySize;
    BOOL            IsFloat = FALSE;
    WORD            MaxBitWidth, MinBitWidth, MaxChannels, MinChannels;

    //
    // First copy the user requested format into a local structure
    //  (because we will tamper it later for different params)
    //
    if (pWaveFormatEx->wFormatTag == WAVE_FORMAT_PCM) {
        RegionAllocSize = sizeof(WAVEFORMATEX);
        RegionCopySize = sizeof(PCMWAVEFORMAT);
    }
    else {
        RegionAllocSize = sizeof(WAVEFORMATEX) + pWaveFormatEx->cbSize;
        RegionCopySize = RegionAllocSize;
    }

    pWaveFormat = new(BYTE[RegionAllocSize]);
    if (!pWaveFormat) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }

    RtlCopyMemory(pWaveFormat, pWaveFormatEx, RegionCopySize);

    //
    // cast for convenient access
    //
    pWaveFormatExtensible = (PWAVEFORMATEXTENSIBLE) pWaveFormat;
    if (pWaveFormatExtensible->Format.wFormatTag == WAVE_FORMAT_PCM) {
        pWaveFormatExtensible->Format.cbSize = 0;
    }

    DPF3(90, "CSNI::Create: Client SR %d CH %d BPS %d",
             pWaveFormatExtensible->Format.nSamplesPerSec,
             pWaveFormatExtensible->Format.nChannels,
             pWaveFormatExtensible->Format.wBitsPerSample);

    //
    // and try the requested format first
    //
    Status = this->Connect(
        pDeviceNode, 
        pPinConnect, 
        (PWAVEFORMATEX)pWaveFormatEx, 
        NULL);

    //
    // If the graph contains only splitter and capturer, only the 
    // requested format can succeed.
    // So exit here.
    //
    if (pStartNode->IsCaptureFormatStrict()) {
        goto exit;           
    }
    

    if (pWaveFormatExtensible->Format.wFormatTag == WAVE_FORMAT_IEEE_FLOAT) {
        IsFloat = TRUE;
    }

    if (pWaveFormatExtensible->Format.wFormatTag == WAVE_FORMAT_EXTENSIBLE) {
        if (IsEqualGUID(&pWaveFormatExtensible->SubFormat,&KSDATAFORMAT_SUBTYPE_IEEE_FLOAT)) {
            IsFloat = TRUE;
        }
    }

    if (IsFloat == FALSE) {
        if (pWaveFormatExtensible->Format.wFormatTag != WAVE_FORMAT_PCM) {
            if (pWaveFormatExtensible->Format.wFormatTag != WAVE_FORMAT_EXTENSIBLE) {
                goto exit;
            }
            else {
                if (!IsEqualGUID(&pWaveFormatExtensible->SubFormat,&KSDATAFORMAT_SUBTYPE_PCM)) {
                    goto exit;
                }
            }
        }
        MaxBitWidth = 
            (pWaveFormatExtensible->Format.wBitsPerSample>16) ?
                pWaveFormatExtensible->Format.wBitsPerSample:16;
        MinBitWidth = 8;
    }
    else {
        MaxBitWidth = MinBitWidth = pWaveFormatEx->wBitsPerSample;
    }

    //
    // ISSUE: 02/20/02 ALPERS
    // The channel logic might not work with micarrays which have more than
    // two channels.
    //

    //
    // MaxChannels = (pWaveFormatExtensible->nChannels > 2) ? pWaveFormatExtensible->nChannels:2;
    // We can do this, what would be the channel mask for WaveFormatExtensible?
    //
    MaxChannels = 2;
    MinChannels = 1;

    //
    // If that failed with the same sample rate try different
    // combinations of numchannels & bitwidth
    //
    // Tries 4 combinations of STEREO/MONO & 8/16 bits
    // More intelligence can be built based upon device capability
    // (also does not check whether we tried a combination earlier)
    //
    if (!NT_SUCCESS(Status)) {
        Continue = TRUE;
        for (NumChannels = MaxChannels; (NumChannels >= MinChannels) && Continue; NumChannels--) {
            for (BitWidth = MaxBitWidth;
                 (BitWidth >= MinBitWidth) && Continue;
                 BitWidth=(BitWidth%8)?((BitWidth/8)*8):(BitWidth-8)) {

                pWaveFormatExtensible->Format.nChannels = NumChannels;
                pWaveFormatExtensible->Format.wBitsPerSample = BitWidth;
                pWaveFormatExtensible->Format.nBlockAlign = (NumChannels * BitWidth)/8;

                pWaveFormatExtensible->Format.nAvgBytesPerSec = 
                    pWaveFormatExtensible->Format.nSamplesPerSec *
                    pWaveFormatExtensible->Format.nBlockAlign;
                
                if (pWaveFormatExtensible->Format.wFormatTag == WAVE_FORMAT_EXTENSIBLE) {
                    pWaveFormatExtensible->Samples.wValidBitsPerSample = BitWidth;
                    if (NumChannels == 1) {
                        pWaveFormatExtensible->dwChannelMask = SPEAKER_FRONT_CENTER;
                    }
                    else {
                        pWaveFormatExtensible->dwChannelMask = SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT;
                    }
                }

                DPF3(90, "CSNI::Create: Client SR %d CH %d BPS %d",
                         pWaveFormatExtensible->Format.nSamplesPerSec,
                         pWaveFormatExtensible->Format.nChannels,
                         pWaveFormatExtensible->Format.wBitsPerSample);

                Status = this->Connect(pDeviceNode,
                                       pPinConnect,
                                       (PWAVEFORMATEX)pWaveFormatExtensible,
                                       NULL);
                if (NT_SUCCESS(Status)) {
                    Continue = FALSE;
                }
            }
        }
    }
exit:
    delete [] pWaveFormat;
    return(Status);
}

NTSTATUS
CStartNodeInstance::AecConnectionFormat(
    PDEVICE_NODE pDeviceNode,
    PKSPIN_CONNECT *ppPinConnect)
{
    PCLIST_ITEM            pListItem;
    PCONNECT_NODE_INSTANCE pConnectNodeInstance;
    PCONNECT_NODE_INSTANCE pBottomConnection;
    PCONNECT_NODE_INSTANCE pAecConnection = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    ASSERT(ppPinConnect);

    *ppPinConnect = NULL;
    
    Status = CConnectNodeInstance::Create(this, pDeviceNode);
    if(!NT_SUCCESS(Status)) {
        goto exit;
    }

    //
    // Get Aec Source and Capture Sink pins.
    //
    pListItem = lstConnectNodeInstance.GetListLast();
    pBottomConnection = lstConnectNodeInstance.GetListData(pListItem);
    
    FOR_EACH_LIST_ITEM_BACKWARD(&lstConnectNodeInstance, pConnectNodeInstance) {
        if (pConnectNodeInstance->pConnectNode->pPinNodeSource->
            pPinInfo->pFilterNode->GetType() & FILTER_TYPE_AEC) {
                
            pAecConnection = pConnectNodeInstance;
            break;
        }
    } END_EACH_LIST_ITEM

    if (NULL == pAecConnection || NULL == pBottomConnection) {
        DPF(5, "CSNI::AecConnectionFormat: Cannot find Aec or Capture");
        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto exit;
    }

    DPF3(20, "Aec : %X %d %s",
        pAecConnection,
        pAecConnection->pConnectNode->pPinNodeSource->pPinInfo->PinId,
        pAecConnection->pConnectNode->pPinNodeSource->pPinInfo->pFilterNode->DumpName());

    DPF3(20, "Capture : %X %d %s",
        pBottomConnection,
        pBottomConnection->pConnectNode->pPinNodeSink->pPinInfo->PinId,
        pBottomConnection->pConnectNode->pPinNodeSink->pPinInfo->pFilterNode->DumpName());

    //
    // Find the intersection between kmixer source and capture sink.
    //
    Status = CreatePinIntersection(
        ppPinConnect,
        pBottomConnection->pConnectNode->pPinNodeSink,
        pAecConnection->pConnectNode->pPinNodeSource,
        pBottomConnection->pFilterNodeInstanceSink,
        pAecConnection->pFilterNodeInstanceSource);

    if(!NT_SUCCESS(Status)) {
        DPF(5, "CSNI::AecConnectionFormat: No intersection found");
        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto exit;
    }

#ifdef DEBUG
    DumpDataFormat(20, (PKSDATAFORMAT) (*ppPinConnect + 1));
#endif

exit:
    if(!NT_SUCCESS(Status)) {
        DPF2(90, "CSNI::AecConnectionFormat: %08x FAIL %08x", this, Status);

        delete [] *ppPinConnect;
        *ppPinConnect = NULL;
    }

    CleanUp();
    return(Status);    
} // AecConnectionFormat


NTSTATUS
CStartNodeInstance::Connect(
    PDEVICE_NODE pDeviceNode,
    PKSPIN_CONNECT pPinConnect,
    PWAVEFORMATEX pWaveFormatEx,
    PKSPIN_CONNECT pPinConnectDirect
)
{
    PCONNECT_NODE_INSTANCE pConnectNodeInstance;
    NTSTATUS Status = STATUS_SUCCESS;

    Status = CConnectNodeInstance::Create(this, pDeviceNode);
    if(!NT_SUCCESS(Status)) {
        goto exit;
    }

    //
    // Do all the bottom up connecting
    //

    FOR_EACH_LIST_ITEM_BACKWARD(&lstConnectNodeInstance, pConnectNodeInstance) {

        if(!pConnectNodeInstance->IsTopDown()) {

            //
            // For Aec sink pin do intersection, no matter what the format is.
            //
            if (pConnectNodeInstance->pFilterNodeInstanceSink->
                pFilterNode->GetType() & FILTER_TYPE_AEC) {
                
                Status = pConnectNodeInstance->Connect(NULL, NULL);
            }
            else {
                Status = pConnectNodeInstance->Connect(
                    pWaveFormatEx,
                    pPinConnectDirect);
            }

            if(!NT_SUCCESS(Status)) {
                goto exit;
            }
        }
    } END_EACH_LIST_ITEM

    pPinConnect->PinToHandle = NULL;

    Status = CPinNodeInstance::Create(
      &pPinNodeInstance,
      pFilterNodeInstance,
      pStartNode->pPinNode,
      pPinConnect,
      (pStartNode->fRender)
#ifdef FIX_SOUND_LEAK
     ,lstConnectNodeInstance.IsLstEmpty()
#endif
      );

    if(!NT_SUCCESS(Status)) {
        goto exit;
    }

    //
    // Do all the top down connecting
    //

    FOR_EACH_LIST_ITEM(&lstConnectNodeInstance, pConnectNodeInstance) {

        if(pConnectNodeInstance->IsTopDown()) {
            //
            // Rely on DataIntersection for all Topdown connections
            //
            Status = pConnectNodeInstance->Connect(NULL, NULL);
            if(!NT_SUCCESS(Status)) {
                goto exit;
            }
        }

    } END_EACH_LIST_ITEM

    DPF1(90, "CSNI::Connect: %08x SUCCESS", this);
exit:
    if(!NT_SUCCESS(Status)) {
        DPF2(90, "CSNI::Connect: %08x FAIL %08x", this, Status);
        CleanUp();
    }
    return(Status);
}

//=============================================================================
// Create an array which holds FileObject of the pin for each topology node
// in this graph.
// This array is later used as a lookup table for node communication.
// 
NTSTATUS
CStartNodeInstance::CreateTopologyTable(
    PGRAPH_NODE_INSTANCE pGraphNodeInstance
)
{
    PCONNECT_NODE_INSTANCE pConnectNodeInstance;
    NTSTATUS Status = STATUS_SUCCESS;
    PFILTER_NODE pFilterNode = NULL;
    ULONG n;

    Assert(this);
    Assert(pGraphNodeInstance);

    if(pGraphNodeInstance->Topology.TopologyNodesCount != 0) {

        ASSERT(papFileObjectTopologyTable == NULL);

        papFileObjectTopologyTable =
           new PFILE_OBJECT[pGraphNodeInstance->Topology.TopologyNodesCount];

        if(papFileObjectTopologyTable == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto exit;
        }
    }
    for(n = 0; n < pGraphNodeInstance->Topology.TopologyNodesCount; n++) {

        // if filter node is the same as last time, no need to search
        if(pFilterNode == pGraphNodeInstance->papTopologyNode[n]->pFilterNode) {
            ASSERT(n != 0);
            ASSERT(pFilterNode != NULL);
            papFileObjectTopologyTable[n] = papFileObjectTopologyTable[n - 1];
            continue;
        }
        pFilterNode = pGraphNodeInstance->papTopologyNode[n]->pFilterNode;
        Assert(pFilterNode);
        //
        // Now find a filter instance and a pin instance in this graph
        // instance for this filter node.
        //
        Assert(pPinNodeInstance);

        if(pPinNodeInstance->pPinNode->pPinInfo->pFilterNode == pFilterNode) {
            papFileObjectTopologyTable[n] = pPinNodeInstance->pFileObject;
            continue;
        }

        FOR_EACH_LIST_ITEM_BACKWARD(		// Top Down
          &lstConnectNodeInstance,
          pConnectNodeInstance) {

            Assert(pConnectNodeInstance);
            Assert(pConnectNodeInstance->pPinNodeInstanceSink);
            Assert(pConnectNodeInstance->pPinNodeInstanceSink->pPinNode);
            Assert(
              pConnectNodeInstance->pPinNodeInstanceSink->pPinNode->pPinInfo);

            //
            // Use the sink pin handle for now. This should be fine until 
            // Sysaudio supports a spliter.
            //

            if(pConnectNodeInstance->pPinNodeInstanceSink->
              pPinNode->pPinInfo->pFilterNode == pFilterNode) {
                papFileObjectTopologyTable[n] = 
                    pConnectNodeInstance->pPinNodeInstanceSink->pFileObject;
                break;
            }

        } END_EACH_LIST_ITEM
    }
    DPF1(90, "CreatePinInstanceTopologyTable PI: %08x",
      papFileObjectTopologyTable);
exit:
    return(Status);
}

NTSTATUS
CStartNodeInstance::GetTopologyNodeFileObject(
    OUT PFILE_OBJECT *ppFileObject,
    IN ULONG NodeId
)
{
    PGRAPH_NODE_INSTANCE pGraphNodeInstance;
    NTSTATUS Status = STATUS_SUCCESS;

    if(this == NULL) {
        Status = STATUS_NO_SUCH_DEVICE;
        goto exit;
    }
    Assert(this);
    ASSERT(pPinInstance != NULL);

    Status = pPinInstance->pFilterInstance->GetGraphNodeInstance(
      &pGraphNodeInstance);

    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
    Assert(pGraphNodeInstance);

    if(NodeId >= pGraphNodeInstance->cTopologyNodes) {
        Trap();
        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto exit;
    }

    if(papFileObjectTopologyTable == NULL ||
       papFileObjectTopologyTable[NodeId] == NULL) {

        Status = pGraphNodeInstance->GetTopologyNodeFileObject(
          ppFileObject,
          NodeId);

        if(!NT_SUCCESS(Status)) {
            goto exit;
        }
    }
    else {
        *ppFileObject = papFileObjectTopologyTable[NodeId];
    }
exit:
    return(Status);
}

//---------------------------------------------------------------------------

NTSTATUS
CStartNodeInstance::SetState(
    KSSTATE NewState,
    ULONG ulFlags
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    LONG State;

    //
    // ISSUE: 04/23/2002 ALPERS 
    // Until we have the parameter validation layer, this function 
    // is unprotected.
    // 

    Assert(this);
    if(CurrentState == NewState) {
        ASSERT(NT_SUCCESS(Status));
        goto exit;
    }
    if(CurrentState < NewState) {
        for(State = CurrentState + 1; State <= NewState; State++) {

            Status = SetStateTopDown(
              (KSSTATE)State,
              CurrentState,
              ulFlags | SETSTATE_FLAG_SINK | SETSTATE_FLAG_SOURCE);

            if(!NT_SUCCESS(Status)) {
                goto exit;
            }
            CurrentState = (KSSTATE)State;
        }
    }
    else {
        for(State = CurrentState - 1; State >= NewState; State--) {

            Status = SetStateBottomUp(
              (KSSTATE)State,
              CurrentState,
              ulFlags | SETSTATE_FLAG_SINK | SETSTATE_FLAG_SOURCE);

            if(!NT_SUCCESS(Status)) {
                goto exit;
            }
            CurrentState = (KSSTATE)State;
        }
    }
    ASSERT(CurrentState == NewState);
exit:
    return(Status);
}

NTSTATUS
CStartNodeInstance::SetStateTopDown(
    KSSTATE NewState,
    KSSTATE PreviousState,
    ULONG ulFlags
)
{
    PCONNECT_NODE_INSTANCE pConnectNodeInstance;
    NTSTATUS Status = STATUS_SUCCESS;

    if(this != NULL) {
        Assert(this);

        if(ulFlags & SETSTATE_FLAG_SINK) {
            Status = pPinNodeInstance->SetState(
              NewState,
              PreviousState,
              ulFlags);

            if(!NT_SUCCESS(Status)) {
                goto exit;
            }
        }
        FOR_EACH_LIST_ITEM(
          &lstConnectNodeInstance,
          pConnectNodeInstance) {

            Status = pConnectNodeInstance->SetStateTopDown(
              NewState,
              PreviousState,
              ulFlags);

            if(!NT_SUCCESS(Status)) {
                goto exit;
            }

        } END_EACH_LIST_ITEM
    }
exit:
    return(Status);
}

NTSTATUS
CStartNodeInstance::SetStateBottomUp(
    KSSTATE NewState,
    KSSTATE PreviousState,
    ULONG ulFlags
)
{
    PCONNECT_NODE_INSTANCE pConnectNodeInstance;
    NTSTATUS Status = STATUS_SUCCESS;

    if(this != NULL) {
        Assert(this);

        FOR_EACH_LIST_ITEM_BACKWARD(
          &lstConnectNodeInstance,
          pConnectNodeInstance) {

            Status = pConnectNodeInstance->SetStateBottomUp(
              NewState,
              PreviousState,
              ulFlags);

            if(!NT_SUCCESS(Status)) {
                goto exit;
            }

        } END_EACH_LIST_ITEM

        if(ulFlags & SETSTATE_FLAG_SINK) {
            Status = pPinNodeInstance->SetState(
              NewState,
              PreviousState,
              ulFlags);

            if(!NT_SUCCESS(Status)) {
                goto exit;
            }
        }
    }
exit:
    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\sysaudio\si.h ===
//---------------------------------------------------------------------------
//
//  Module:   		si.h
//
//  Description:	Start Info Class
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Constants and Macros
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Class
//---------------------------------------------------------------------------

typedef class CStartInfo : public CListDoubleItem
{
private:
    CStartInfo(
	PPIN_INFO pPinInfo,
	PCONNECT_INFO pConnectInfo,
	PGRAPH_PIN_INFO pGraphPinInfo,
	PGRAPH_NODE pGraphNode
    );

    ~CStartInfo(
    );

public:
    static NTSTATUS
    Create(
	PSTART_NODE pStartNode,
	PCONNECT_INFO pConnectInfo,
	PGRAPH_PIN_INFO pGraphPinInfo,
	PGRAPH_NODE pGraphNode
    );

    ENUMFUNC
    Destroy(
    )
    {
	if(this != NULL) {
	    Assert(this);
	    ASSERT(cReference > 0);

	    if(--cReference == 0) {
		delete this;
	    }
	}
	return(STATUS_CONTINUE);
    };

    VOID 
    AddRef(
    )
    {
	if(this != NULL) {
	    Assert(this);
	    ++cReference;
	}
    };

    PPIN_INFO
    GetPinInfo(
    )
    {
	Assert(this);
	return(pPinInfo);
    };

    PGRAPH_PIN_INFO
    GetGraphPinInfo(
    )
    {
	Assert(this);
	return(pGraphPinInfo);
    };

    PKSPIN_CINSTANCES
    GetPinInstances(
    )
    {
	Assert(this);
	return(pGraphPinInfo->GetPinInstances());
    };

    VOID
    AddPinInstance(
    )
    {
	Assert(this);
	if(pPinInfo == pGraphPinInfo->GetPinInfo()) {
	    pGraphPinInfo->AddPinInstance();
	}
    };

    VOID
    RemovePinInstance(
    )
    {
	Assert(this);
	if(pPinInfo == pGraphPinInfo->GetPinInfo()) {
	    pGraphPinInfo->RemovePinInstance();
	}
    };

    BOOL
    IsPinInstances(
    )
    {
	Assert(this);
	return(pGraphPinInfo->IsPinInstances());
    };

    BOOL
    IsPossibleInstances(
    )
    {
	Assert(this);
	return(pGraphPinInfo->IsPossibleInstances());
    };

    PCONNECT_INFO
    GetFirstConnectInfo(
    )
    {
	return(pConnectInfoHead);
    };

    ENUMFUNC
    CreatePinInfoConnection(
	PVOID pGraphNode
    );

    ENUMFUNC
    EnumStartInfo(
    );

private:
    LONG cReference;
    PPIN_INFO pPinInfo;
    PCONNECT_INFO pConnectInfoHead;
    PGRAPH_PIN_INFO pGraphPinInfo;
public:
    ULONG ulTopologyConnectionTableIndex;
    ULONG ulVolumeNodeNumberPre;
    ULONG ulVolumeNodeNumberSuperMix;
    ULONG ulVolumeNodeNumberPost;
    DefineSignature(0x20204953);				// SI

} START_INFO, *PSTART_INFO;

//---------------------------------------------------------------------------

typedef ListDouble<START_INFO> LIST_START_INFO;

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\sysaudio\tc.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   tc.cpp
//
//  Description:
//
//	Topology Connection Class
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//  To Do:     Date	  Author      Comment
//
//@@END_MSINTERNAL
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"

//---------------------------------------------------------------------------

ULONG gcTopologyConnections = 0;

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

CTopologyConnection::CTopologyConnection(
    PTOPOLOGY_PIN pTopologyPinFrom,
    PTOPOLOGY_PIN pTopologyPinTo,
    PPIN_INFO pPinInfoFrom,
    PPIN_INFO pPinInfoTo
)
{
    DPF4(110,
      "CTopologyConnection: PIF: %08x PIT: %08x TPF: %08x TPT: %08x",
      pPinInfoFrom,
      pPinInfoTo,
      pTopologyPinFrom,
      pTopologyPinTo);

    this->pTopologyPinFrom = pTopologyPinFrom;
    this->pTopologyPinTo = pTopologyPinTo;
    this->pPinInfoFrom = pPinInfoFrom;
    this->pPinInfoTo = pPinInfoTo;
    ASSERT(TOPC_FLAGS_FILTER_CONNECTION_TYPE == 0);
    ++gcTopologyConnections;
    DPF1(70, "CTopologyConnection: %08x", this);
}

CTopologyConnection::~CTopologyConnection(
)
{
    Assert(this);
    DPF1(70, "~CTopologyConnection: %08x", this);
    --gcTopologyConnections;
}

NTSTATUS
CTopologyConnection::Create(
    PTOPOLOGY_CONNECTION *ppTopologyConnection,
    PFILTER_NODE pFilterNode,
    PGRAPH_NODE pGraphNode,
    PTOPOLOGY_PIN pTopologyPinFrom,
    PTOPOLOGY_PIN pTopologyPinTo,
    PPIN_INFO pPinInfoFrom,
    PPIN_INFO pPinInfoTo
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PTOPOLOGY_CONNECTION pTopologyConnection;
    PLIST_DESTROY_TOPOLOGY_CONNECTION plstTopologyConnection;

    PFILTER_NODE pFilterNodeNext;

    DPF4(110,
      "CTopologyConnection::Create: PIF: %08x PIT: %08x TPF: %08x TPT: %08x",
      pPinInfoFrom,
      pPinInfoTo,
      pTopologyPinFrom,
      pTopologyPinTo);

    ASSERT(pFilterNode != NULL || pGraphNode != NULL);

    pTopologyConnection = new TOPOLOGY_CONNECTION(
        pTopologyPinFrom,
        pTopologyPinTo,
        pPinInfoFrom,
        pPinInfoTo
    );
    if(pTopologyConnection == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        Trap();
        goto exit;
    }
    *ppTopologyConnection = pTopologyConnection;

    if(pFilterNode != NULL) {
        Assert(pFilterNode);
        ASSERT(pGraphNode == NULL);

        // Adding connection to filter connection list
        plstTopologyConnection = &pFilterNode->lstTopologyConnection;

        // Check if duplicate connection on filter list
        FOR_EACH_LIST_ITEM(
              &pFilterNode->lstConnectedFilterNode,
          pFilterNodeNext) {

            if(pFilterNodeNext->lstTopologyConnection.EnumerateList(
              CTopologyConnection::CheckDuplicate,
              ppTopologyConnection) == STATUS_SUCCESS) {

                ASSERT(NT_SUCCESS(Status));
                DPF(70, "CTopologyConnection::Create: Duplicate 1");
                delete pTopologyConnection;
                goto exit;
            }

        } END_EACH_LIST_ITEM

    }

    if(pGraphNode != NULL) {
        PLOGICAL_FILTER_NODE pLogicalFilterNode;
        Assert(pGraphNode);
        ASSERT(pFilterNode == NULL);

        // Adding connection to GraphNode connection list
        plstTopologyConnection = &pGraphNode->lstTopologyConnection;

        // Check if duplicate on GraphNode's logical filter list
        FOR_EACH_LIST_ITEM(
          &pGraphNode->pDeviceNode->lstLogicalFilterNode,
          pLogicalFilterNode) {

            if(pLogicalFilterNode->lstTopologyConnection.EnumerateList(
              CTopologyConnection::CheckDuplicate,
              ppTopologyConnection) == STATUS_SUCCESS) {

                ASSERT(NT_SUCCESS(Status));
                DPF(70, "CTopologyConnection::Create: Duplicate 2");
                delete pTopologyConnection;
                goto exit;
            }

        } END_EACH_LIST_ITEM

        // Check if duplicate on GraphNode's connected filter list
        FOR_EACH_LIST_ITEM(
          &pGraphNode->lstLogicalFilterNode,
          pLogicalFilterNode) {

            if(pLogicalFilterNode->lstTopologyConnection.EnumerateList(
              CTopologyConnection::CheckDuplicate,
              ppTopologyConnection) == STATUS_SUCCESS) {

                ASSERT(NT_SUCCESS(Status));
                DPF(70, "CTopologyConnection::Create: Duplicate 3");
                delete pTopologyConnection;
                goto exit;
            }

        } END_EACH_LIST_ITEM

        pTopologyConnection->ulFlags = TOPC_FLAGS_GRAPH_CONNECTION_TYPE;
    }

    // Check for duplicate topology connections
    if(plstTopologyConnection->EnumerateList(
      CTopologyConnection::CheckDuplicate,
      ppTopologyConnection) == STATUS_SUCCESS) {

        DPF(70, "CTopologyConnection::Create: Duplicate 4");
        ASSERT(NT_SUCCESS(Status));
        delete pTopologyConnection;
        goto exit;
    }

    if(pTopologyPinFrom != NULL) {
        Assert(pTopologyConnection);

        Status = pTopologyConnection->AddListEnd(
          &pTopologyPinFrom->lstTopologyConnection);

        if(!NT_SUCCESS(Status)) {
            Trap();
            goto exit;
        }
        }
        if(pTopologyPinTo != NULL) {
        Assert(pTopologyConnection);

        Status = pTopologyConnection->AddListEnd(
          &pTopologyPinTo->lstTopologyConnection);

        if(!NT_SUCCESS(Status)) {
            Trap();
            goto exit;
        }
    }
    if(pPinInfoFrom != NULL) {
        Assert(pTopologyConnection);

        Status = pTopologyConnection->AddListEnd(
          &pPinInfoFrom->lstTopologyConnection);

        if(!NT_SUCCESS(Status)) {
            Trap();
            goto exit;
        }
        }
        if(pPinInfoTo != NULL) {
        Assert(pTopologyConnection);

        Status = pTopologyConnection->AddListEnd(
          &pPinInfoTo->lstTopologyConnection);

        if(!NT_SUCCESS(Status)) {
            Trap();
            goto exit;
        }
    }
    Status = pTopologyConnection->AddListEnd(plstTopologyConnection);
    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }
exit:
    DPF3(70, "CTopologyConnection::Create: %08x, FN: %08x GN: %08x", 
      *ppTopologyConnection,
      pFilterNode,
      pGraphNode);
    return(Status);
}

ENUMFUNC
CTopologyConnection::CheckDuplicate(
    PVOID pReference
)
{
    PTOPOLOGY_CONNECTION *ppTopologyConnection = 
      (PTOPOLOGY_CONNECTION*)pReference;

    if((this->pTopologyPinFrom == (*ppTopologyConnection)->pTopologyPinFrom) &&
       (this->pTopologyPinTo == (*ppTopologyConnection)->pTopologyPinTo) &&
       (this->pPinInfoFrom == (*ppTopologyConnection)->pPinInfoFrom) &&
       (this->pPinInfoTo == (*ppTopologyConnection)->pPinInfoTo)) {
        *ppTopologyConnection = this;
        return(STATUS_SUCCESS);
    }
    return(STATUS_CONTINUE);
}

BOOL
CTopologyConnection::IsTopologyConnectionOnGraphNode(
    PGRAPH_NODE pGraphNode
)
{
    PLOGICAL_FILTER_NODE pLogicalFilterNodeFrom;
    PLOGICAL_FILTER_NODE pLogicalFilterNodeTo;
    PLOGICAL_FILTER_NODE pLogicalFilterNode;
    BOOL fStatusFrom = FALSE;
    BOOL fStatusTo = FALSE;

    Assert(pGraphNode);
    if(pPinInfoFrom != NULL || pPinInfoTo != NULL) {
        return(TRUE);
    }
    if(pTopologyPinFrom == NULL || pTopologyPinTo == NULL) {
        return(FALSE);
    }
    Assert(pTopologyPinFrom);
    Assert(pTopologyPinTo);

    FOR_EACH_LIST_ITEM(
      &pTopologyPinFrom->pTopologyNode->lstLogicalFilterNode,
      pLogicalFilterNodeFrom) {

        Assert(pLogicalFilterNodeFrom);
        FOR_EACH_LIST_ITEM(
          &pTopologyPinTo->pTopologyNode->lstLogicalFilterNode,
          pLogicalFilterNodeTo) {

            FOR_EACH_LIST_ITEM(
              &pGraphNode->pDeviceNode->lstLogicalFilterNode,
              pLogicalFilterNode) {

                Assert(pLogicalFilterNode);
                if(pLogicalFilterNode == pLogicalFilterNodeFrom) {
                    fStatusFrom = TRUE;
                }
                if(pLogicalFilterNode == pLogicalFilterNodeTo) {
                    fStatusTo = TRUE;
                }

            } END_EACH_LIST_ITEM

            if(fStatusFrom && fStatusTo) {
                goto exit;
            }

            FOR_EACH_LIST_ITEM(
              &pGraphNode->lstLogicalFilterNode,
              pLogicalFilterNode) {

                Assert(pLogicalFilterNode);
                if(pLogicalFilterNode == pLogicalFilterNodeFrom) {
                    fStatusFrom = TRUE;
                }
                if(pLogicalFilterNode == pLogicalFilterNodeTo) {
                    fStatusTo = TRUE;
                }

            } END_EACH_LIST_ITEM

            if(fStatusFrom && fStatusTo) {
                goto exit;
            }

        } END_EACH_LIST_ITEM

    } END_EACH_LIST_ITEM
exit:
    return(fStatusFrom && fStatusTo);
}

NTSTATUS
AddPinToFilterNode(
    PTOPOLOGY_PIN pTopologyPin,
    PFILTER_NODE pFilterNode
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PFILTER_NODE pFilterNodeNext;

    Assert(pFilterNode);
    Assert(pTopologyPin);
    Assert(pTopologyPin->pTopologyNode->pFilterNode);
    //
    // Add the filter node to connected filter node list
    //
    if(pFilterNode != pTopologyPin->pTopologyNode->pFilterNode) {

        Status = pFilterNode->lstConnectedFilterNode.AddList(
          pTopologyPin->pTopologyNode->pFilterNode);

        if(!NT_SUCCESS(Status)) {
            Trap();
            goto exit;
        }
        // Hack for ds1wdm dmus synth topology (adds dmus to wave FN lst)
        if((pFilterNode->GetType() & FILTER_TYPE_ENDPOINT) == 0) {

            DPF2(50, "AddPinToFilterNode: (from) FN: %08x %s",
              pFilterNode,
              pFilterNode->DumpName());

            FOR_EACH_LIST_ITEM(
              &pTopologyPin->pTopologyNode->pFilterNode->lstConnectedFilterNode,
              pFilterNodeNext) {

                if(pFilterNodeNext == pFilterNode ||
                  pFilterNodeNext == pTopologyPin->pTopologyNode->pFilterNode) {
                    continue;
                }
                DPF2(50, "AddPinToFilterNode: (to) FN: %08x %s",
                  pFilterNodeNext,
                  pFilterNodeNext->DumpName());

                Status = pFilterNodeNext->lstConnectedFilterNode.AddList(
                  pFilterNode);

                if(!NT_SUCCESS(Status)) {
                    Trap();
                    goto exit;
                }

            } END_EACH_LIST_ITEM
        }

        //
        // This fixes the bug with capture only devices. The topology for 
        // capture only devices was not built properly, due to the missing 
        // link between wave filter and topology filter.
        // Add the topology filter to wave filter ConnectedFilterNode list.
        // The AddList function does not allow duplicate entries.
        //
        if ((pFilterNode->GetType() & FILTER_TYPE_TOPOLOGY) &&
            (pTopologyPin->pTopologyNode->pFilterNode->GetType() & (FILTER_TYPE_CAPTURER))) {
            
            Status = pTopologyPin->pTopologyNode->pFilterNode->lstConnectedFilterNode.AddList(
              pFilterNode);

            DPF3(20, "AddPinToFilterNode: (CAPTURE ONLY) FN: %08x FN: %08x %s",
              pTopologyPin->pTopologyNode->pFilterNode,
              pFilterNode,
              pFilterNode->DumpName());
        }
    }
exit:
    return(Status);
}

NTSTATUS
AddPinToGraphNode(
    PTOPOLOGY_PIN pTopologyPin,
    PGRAPH_NODE pGraphNode,
    PTOPOLOGY_CONNECTION pTopologyConnection
)
{
    PLOGICAL_FILTER_NODE pLogicalFilterNode2;
    PLOGICAL_FILTER_NODE pLogicalFilterNode;
    PTOPOLOGY_CONNECTION pTopologyConnection2;
    NTSTATUS Status = STATUS_SUCCESS;
    BOOL fAddLogicalFilterNode;

    Assert(pTopologyPin);
    Assert(pTopologyPin->pTopologyNode);
    Assert(pGraphNode);

    FOR_EACH_LIST_ITEM(
      &pTopologyPin->pTopologyNode->lstLogicalFilterNode,
      pLogicalFilterNode) {
        fAddLogicalFilterNode = FALSE;

        FOR_EACH_LIST_ITEM(
          &pLogicalFilterNode->lstTopologyConnection,
          pTopologyConnection2) {

            Assert(pTopologyConnection2);
            if(pTopologyPin == pTopologyConnection2->pTopologyPinFrom ||
               pTopologyPin == pTopologyConnection2->pTopologyPinTo) {
                fAddLogicalFilterNode = TRUE;
                break;
            }

        } END_EACH_LIST_ITEM

        if(fAddLogicalFilterNode) {
            FOR_EACH_LIST_ITEM(
              &pGraphNode->pDeviceNode->lstLogicalFilterNode,
              pLogicalFilterNode2) {

                Assert(pLogicalFilterNode2);
                if(pLogicalFilterNode == pLogicalFilterNode2) {
                    fAddLogicalFilterNode = FALSE;
                    break;
                }

            } END_EACH_LIST_ITEM
        }

        if(fAddLogicalFilterNode) {

            Status = pGraphNode->lstLogicalFilterNode.AddList(
              pLogicalFilterNode,
              pTopologyConnection);

            if(!NT_SUCCESS(Status)) {
                Trap();
                goto exit;
            }
        }

    } END_EACH_LIST_ITEM
exit:
    return(Status);
}

NTSTATUS
CreatePinInfoConnection(
    PTOPOLOGY_CONNECTION *ppTopologyConnection,
    PFILTER_NODE pFilterNode,
    PGRAPH_NODE pGraphNode,
    PPIN_INFO pPinInfoSource,
    PPIN_INFO pPinInfoSink
)
{
    PTOPOLOGY_CONNECTION pTopologyConnectionSource;
    PTOPOLOGY_CONNECTION pTopologyConnectionSink;
    PTOPOLOGY_PIN pTopologyPinFrom;
    PTOPOLOGY_PIN pTopologyPinTo;
    NTSTATUS Status = STATUS_SUCCESS;

    Assert(pPinInfoSource);
    Assert(pPinInfoSink);
    ASSERT(pPinInfoSource != pPinInfoSink);

    FOR_EACH_LIST_ITEM(
      &pPinInfoSource->lstTopologyConnection,
      pTopologyConnectionSource) {

        Assert(pTopologyConnectionSource);
        if(!IS_CONNECTION_TYPE(pTopologyConnectionSource, FILTER)) {
            continue;
        }
        pTopologyPinFrom = NULL;
        pTopologyPinTo = NULL;

        if(pTopologyConnectionSource->pTopologyPinFrom != NULL) {
            ASSERT(pTopologyConnectionSource->pPinInfoTo == pPinInfoSource);
            ASSERT(pTopologyConnectionSource->pPinInfoFrom == NULL);
            ASSERT(pTopologyConnectionSource->pTopologyPinTo == NULL);
            pTopologyPinFrom = pTopologyConnectionSource->pTopologyPinFrom;
        }

        if(pTopologyConnectionSource->pTopologyPinTo != NULL) {
            ASSERT(pTopologyConnectionSource->pPinInfoFrom == pPinInfoSource);
            ASSERT(pTopologyConnectionSource->pPinInfoTo == NULL);
            ASSERT(pTopologyConnectionSource->pTopologyPinFrom == NULL);
            pTopologyPinTo = pTopologyConnectionSource->pTopologyPinTo;
        }

        FOR_EACH_LIST_ITEM(
          &pPinInfoSink->lstTopologyConnection,
          pTopologyConnectionSink) {

            Assert(pTopologyConnectionSink);
            if(!IS_CONNECTION_TYPE(pTopologyConnectionSink, FILTER)) {
                continue;
            }
            if(pTopologyConnectionSink->pTopologyPinFrom != NULL) {
                ASSERT(pTopologyConnectionSink->pPinInfoTo == pPinInfoSink);
                ASSERT(pTopologyConnectionSink->pPinInfoFrom == NULL);
                ASSERT(pTopologyConnectionSink->pTopologyPinTo == NULL);
                pTopologyPinFrom = pTopologyConnectionSink->pTopologyPinFrom;
            }

            if(pTopologyConnectionSink->pTopologyPinTo != NULL) {
                ASSERT(pTopologyConnectionSink->pPinInfoFrom == pPinInfoSink);
                ASSERT(pTopologyConnectionSink->pPinInfoTo == NULL);
                ASSERT(pTopologyConnectionSink->pTopologyPinFrom == NULL);
                pTopologyPinTo = pTopologyConnectionSink->pTopologyPinTo;
            }

            ASSERT(pTopologyPinFrom != NULL);
            ASSERT(pTopologyPinTo != NULL);

            Status = CTopologyConnection::Create(
              ppTopologyConnection,
              pFilterNode,
              pGraphNode,
              pTopologyPinFrom,			// DataFlow == OUT, Pin #0
              pTopologyPinTo,			// DataFlow == IN, Pin #1 - n
              NULL,
              NULL);

            if(!NT_SUCCESS(Status)) {
                Trap();
                goto exit;
            }

            // Add the connections to the PinInfos
            Assert(*ppTopologyConnection);

            Status = (*ppTopologyConnection)->AddListEnd(
              &pPinInfoSource->lstTopologyConnection);

            if(!NT_SUCCESS(Status)) {
                Trap();
                goto exit;
            }

            Status = (*ppTopologyConnection)->AddListEnd(
              &pPinInfoSink->lstTopologyConnection);

            if(!NT_SUCCESS(Status)) {
                Trap();
                goto exit;
            }

            if(pFilterNode != NULL) {
                Assert(pFilterNode);
                Status = AddPinToFilterNode(pTopologyPinFrom, pFilterNode);
                if(!NT_SUCCESS(Status)) {
                    Trap();
                    goto exit;
                }
                Status = AddPinToFilterNode(pTopologyPinTo, pFilterNode);
                if(!NT_SUCCESS(Status)) {
                    Trap();
                    goto exit;
                }
                // Change the connection type to physical
                (*ppTopologyConnection)->ulFlags =
                  TOPC_FLAGS_PHYSICAL_CONNECTION_TYPE;
            }

            if(pGraphNode != NULL) {
                Assert(pGraphNode);
                Status = AddPinToGraphNode(
                  pTopologyPinFrom,
                  pGraphNode,
                  *ppTopologyConnection);

                if(!NT_SUCCESS(Status)) {
                    Trap();
                    goto exit;
                }
                Status = AddPinToGraphNode(
                  pTopologyPinTo,
                  pGraphNode,
                  *ppTopologyConnection);

                if(!NT_SUCCESS(Status)) {
                    Trap();
                    goto exit;
                }
                ASSERT(IS_CONNECTION_TYPE(*ppTopologyConnection, GRAPH));
            }

        } END_EACH_LIST_ITEM

    } END_EACH_LIST_ITEM
exit:
    return(Status);
}

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\sysaudio\tn.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   tn.cpp
//
//  Description:
//
//	Topology Node Class
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//  To Do:     Date	  Author      Comment
//
//@@END_MSINTERNAL
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

NTSTATUS
CTopologyNode::Create(
    PTOPOLOGY_NODE *ppTopologyNode,
    PFILTER_NODE pFilterNode,
    ULONG ulNodeNumber,
    GUID *pguidType
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PTOPOLOGY_NODE pTopologyNode;

    pTopologyNode = new TOPOLOGY_NODE(pFilterNode, ulNodeNumber, pguidType);
    if(pTopologyNode == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        Trap();
        goto exit;
    }
    DPF2(70, "CTopologyNode::Create: %08x, FN: %08x",
      pTopologyNode,
      pFilterNode);
exit:
    *ppTopologyNode = pTopologyNode;
    return(Status);
}

CTopologyNode::CTopologyNode(
    PFILTER_NODE pFilterNode,
    ULONG ulNodeNumber,
    GUID *pguidType
)
{
    Assert(pFilterNode);
    this->pFilterNode = pFilterNode;
    this->ulRealNodeNumber = ulNodeNumber;
    this->ulSysaudioNodeNumber = MAXULONG;
    this->iVirtualSource = MAXULONG;
    this->pguidType = pguidType;
    AddList(&pFilterNode->lstTopologyNode);
    DPF2(70, "CTopologyNode: %08x, FN: %08x", this, pFilterNode);
}

CTopologyNode::~CTopologyNode(
)
{
    DPF1(70, "~CTopologyNode: %08x", this);
    Assert(this);
}

NTSTATUS
CreateTopology(
    PFILTER_NODE pFilterNode,
    PKSTOPOLOGY pTopology
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PTOPOLOGY_CONNECTION pTopologyConnection;
    PTOPOLOGY_NODE *papTopologyNode = NULL;
    PTOPOLOGY_NODE pTopologyNodeFrom;
    PTOPOLOGY_NODE pTopologyNodeTo;
    PTOPOLOGY_PIN pTopologyPinFrom;
    PTOPOLOGY_PIN pTopologyPinTo;
    PPIN_INFO pPinInfoFrom;
    PPIN_INFO pPinInfoTo;
    PPIN_INFO pPinInfo;
    ULONG ulTopologyPinNumberFrom;
    ULONG ulTopologyPinNumberTo;
    ULONG n, c;

    // If no topology, return error
    if(pTopology->TopologyNodesCount == 0) {
        if(pTopology->TopologyConnectionsCount == 0) {
            DPF2(5,
              "CreateTopology: FAILED, %s has no topology FN: %08x",
              pFilterNode->DumpName(),
              pFilterNode);
            Status = STATUS_INVALID_PARAMETER;
            goto exit;
        }
    }
    else {
        papTopologyNode = new PTOPOLOGY_NODE[pTopology->TopologyNodesCount];
        if(papTopologyNode == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto exit;
        }
        for(n = 0; n < pTopology->TopologyNodesCount; n++) {

            Status = CTopologyNode::Create(
              &papTopologyNode[n],
              pFilterNode,
              n,
              (GUID *)&pTopology->TopologyNodes[n]);

            if(!NT_SUCCESS(Status)) {
                Trap();
                goto exit;
            }
        }
    }

    for(c = 0; c < pTopology->TopologyConnectionsCount; c++) {

        pTopologyNodeFrom = pTopologyNodeTo = NULL;
        pTopologyPinFrom = pTopologyPinTo = NULL;
        pPinInfoFrom = pPinInfoTo = NULL;

        if(pTopology->TopologyConnections[c].FromNode != KSFILTER_NODE) {
            if(pTopology->TopologyConnections[c].FromNode >=
               pTopology->TopologyNodesCount) {
                DPF2(5,
                  "CreateTopology: FAILED, %s invalid 'from' node # %08x",
                  pFilterNode->DumpName(),
                  pTopology->TopologyConnections[c].FromNode);
                Trap();
                Status = STATUS_INVALID_PARAMETER;
                goto exit;
            }
            pTopologyNodeFrom =
              papTopologyNode[pTopology->TopologyConnections[c].FromNode];

            ulTopologyPinNumberFrom =
              pTopology->TopologyConnections[c].FromNodePin;
        }

        if(pTopology->TopologyConnections[c].ToNode != KSFILTER_NODE) {
            if(pTopology->TopologyConnections[c].ToNode >=
               pTopology->TopologyNodesCount) {
                DPF2(5,
                  "CreateTopology: FAILED, %s invalid 'to' node # %08x",
                  pFilterNode->DumpName(),
                      pTopology->TopologyConnections[c].ToNode);
                Trap();
                Status = STATUS_INVALID_PARAMETER;
                goto exit;
            }
            pTopologyNodeTo = 
              papTopologyNode[pTopology->TopologyConnections[c].ToNode];

            ulTopologyPinNumberTo =
              pTopology->TopologyConnections[c].ToNodePin;
        }

        if(pTopologyNodeFrom == NULL) {

            FOR_EACH_LIST_ITEM(&pFilterNode->lstPinInfo, pPinInfo) {

                if(pPinInfo->PinId == 
                  pTopology->TopologyConnections[c].FromNodePin) {
                    pPinInfoFrom = pPinInfo;
                    break;
                }

            } END_EACH_LIST_ITEM

            if(pPinInfoFrom == NULL) {
                DPF2(5,
                  "CreateTopology: FAILED, %s invalid 'from' node pin # %08x",
                      pFilterNode->DumpName(),
                  pTopology->TopologyConnections[c].FromNodePin);
                Trap();
                Status = STATUS_INVALID_PARAMETER;
                goto exit;
            }
        }
        else {
            Status = CTopologyPin::Create(
              &pTopologyPinFrom,
              ulTopologyPinNumberFrom,
              pTopologyNodeFrom);

            if(!NT_SUCCESS(Status)) {
                Trap();
                goto exit;
            }
        }

        if(pTopologyNodeTo == NULL) {

            FOR_EACH_LIST_ITEM(&pFilterNode->lstPinInfo, pPinInfo) {

                if(pPinInfo->PinId == 
                  pTopology->TopologyConnections[c].ToNodePin) {
                    pPinInfoTo = pPinInfo;
                    break;
                }

            } END_EACH_LIST_ITEM

            if(pPinInfoTo == NULL) {
                DPF2(5,
                  "CreateTopology: FAILED, %s invalid 'to' node pin # %08x",
                      pFilterNode->DumpName(),
                  pTopology->TopologyConnections[c].ToNodePin);
                Trap();
                Status = STATUS_INVALID_PARAMETER;
                goto exit;
            }
        }
        else {
            Status = CTopologyPin::Create(
              &pTopologyPinTo,
              ulTopologyPinNumberTo,
              pTopologyNodeTo);

            if(!NT_SUCCESS(Status)) {
                Trap();
                goto exit;
            }
        }
        Status = CTopologyConnection::Create(
          &pTopologyConnection,
          pFilterNode,
          NULL,
          pTopologyPinFrom,
          pTopologyPinTo,
          pPinInfoFrom,
          pPinInfoTo);

        if(!NT_SUCCESS(Status)) {
            Trap();
            goto exit;
        }
        ASSERT(IS_CONNECTION_TYPE(pTopologyConnection, FILTER));
    }
exit:
    delete [] papTopologyNode;
    return(Status);
}
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\sysaudio\topology.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   topology.c
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//  To Do:     Date	  Author      Comment
//
//@@END_MSINTERNAL
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"

//---------------------------------------------------------------------------

ENUMFUNC
EnumerateTopology(
    IN PPIN_INFO pPinInfo,
    IN NTSTATUS (*Function)(
        IN PTOPOLOGY_CONNECTION pTopologyConnection,
        IN BOOL fToDirection,
        IN OUT PVOID pReference
    ),
    IN OUT PVOID pReference
)
{
    ENUM_TOPOLOGY EnumTopology;
    NTSTATUS Status;

    Assert(pPinInfo);
    EnumTopology.cTopologyRecursion = 0;
    EnumTopology.Function = Function;
    EnumTopology.fToDirection = (pPinInfo->DataFlow == KSPIN_DATAFLOW_IN);
    EnumTopology.pReference = pReference;
    Status = EnumeratePinInfoTopology(pPinInfo, &EnumTopology);
    return(Status);
}

ENUMFUNC
EnumerateGraphTopology(
    IN PSTART_INFO pStartInfo,
    IN NTSTATUS (*Function)(
        IN PTOPOLOGY_CONNECTION pTopologyConnection,
        IN BOOL fToDirection,
        IN OUT PVOID pReference
    ),
    IN OUT PVOID pReference
)
{
    PCONNECT_INFO pConnectInfo;
    NTSTATUS Status;

    Assert(pStartInfo);
    Assert(pStartInfo->GetPinInfo());

    Status = EnumerateTopology(
      pStartInfo->GetPinInfo(),
      Function,
      pReference);

    if(Status != STATUS_CONTINUE) {
        goto exit;
    }
    for(pConnectInfo = pStartInfo->GetFirstConnectInfo();
        pConnectInfo != NULL;
        pConnectInfo = pConnectInfo->GetNextConnectInfo()) {

        Assert(pConnectInfo);
        Status = EnumerateTopology(
          pConnectInfo->pPinInfoSink,
          Function,
          pReference);

        if(Status != STATUS_CONTINUE) {
            goto exit;
        }
    }
exit:
    return(Status);
}

ENUMFUNC
EnumeratePinInfoTopology(
    IN PPIN_INFO pPinInfo,
    IN PENUM_TOPOLOGY pEnumTopology
)
{
    PTOPOLOGY_CONNECTION pTopologyConnection;
    NTSTATUS Status = STATUS_CONTINUE;

    Assert(pPinInfo);
    Assert(pEnumTopology);
    DPF2(110, "EnumerateTopologyPinInfo %08x #%x", pPinInfo, pPinInfo->PinId);

    FOR_EACH_LIST_ITEM(
      &pPinInfo->lstTopologyConnection,
      pTopologyConnection) {

        Assert(pTopologyConnection);
        if(pEnumTopology->fToDirection) {
            if(pTopologyConnection->pPinInfoFrom != pPinInfo) {
                continue;
            }
            ASSERT(pTopologyConnection->pPinInfoTo != pPinInfo);
        }
        else {
            if(pTopologyConnection->pPinInfoTo != pPinInfo) {
                continue;
            }
            ASSERT(pTopologyConnection->pPinInfoFrom != pPinInfo);
        }
        Status = EnumerateTopologyConnection(
          pTopologyConnection,
          pEnumTopology);

        if(Status != STATUS_CONTINUE) {
            goto exit;
        }

    } END_EACH_LIST_ITEM
exit:
    return(Status);
}

ENUMFUNC
EnumerateTopologyPin(
    IN PTOPOLOGY_PIN pTopologyPin,
    IN PENUM_TOPOLOGY pEnumTopology
)
{
    PTOPOLOGY_CONNECTION pTopologyConnection;
    PTOPOLOGY_PIN pTopologyPin2;
    NTSTATUS Status = STATUS_CONTINUE;
    BOOL fFromPinEqual = TRUE;
    ULONG ulFromPinNumber = MAXULONG;
    BOOL fToPinEqual = TRUE;
    ULONG ulToPinNumber = MAXULONG;
    BOOL fPinEqual;
    ULONG ulPinNumber;

    Assert(pTopologyPin);
    Assert(pEnumTopology);
    DPF3(110, "EnumerateTopologyPin %08x TP #%x TN #%x",
      pTopologyPin, 
      pTopologyPin->ulPinNumber,
      pTopologyPin->pTopologyNode->ulRealNodeNumber);

    if(IsEqualGUID(
      &KSNODETYPE_ACOUSTIC_ECHO_CANCEL,
      pTopologyPin->pTopologyNode->pguidType)) {
        switch(pTopologyPin->ulPinNumber) {
            case KSNODEPIN_AEC_RENDER_OUT:
                ASSERT(!pEnumTopology->fToDirection);
            case KSNODEPIN_AEC_RENDER_IN:
            ulFromPinNumber = KSNODEPIN_AEC_RENDER_IN;
            ulToPinNumber = KSNODEPIN_AEC_RENDER_OUT;
            break;

            case KSNODEPIN_AEC_CAPTURE_OUT:
            ASSERT(!pEnumTopology->fToDirection);
            case KSNODEPIN_AEC_CAPTURE_IN:
            ulFromPinNumber = KSNODEPIN_AEC_CAPTURE_IN;
            ulToPinNumber = KSNODEPIN_AEC_CAPTURE_OUT;
            break;
        }
    }
    else if(IsEqualGUID(
      &KSNODETYPE_SUM,
      pTopologyPin->pTopologyNode->pguidType) ||

      IsEqualGUID(
      &KSNODETYPE_MUX,
      pTopologyPin->pTopologyNode->pguidType)) {

        ulFromPinNumber = KSNODEPIN_SUM_MUX_IN;
        fFromPinEqual = FALSE;
        ulToPinNumber = KSNODEPIN_SUM_MUX_OUT;
    }
    else if(IsEqualGUID(
      &KSNODETYPE_DEMUX,
      pTopologyPin->pTopologyNode->pguidType)) {

        ulFromPinNumber = KSNODEPIN_DEMUX_IN;
        ulToPinNumber = KSNODEPIN_DEMUX_OUT;
        fToPinEqual = FALSE;
    }
    else {
        ulFromPinNumber = KSNODEPIN_STANDARD_IN;
        ulToPinNumber = KSNODEPIN_STANDARD_OUT;
    }

    // Swap pin numbers and flags
    if(!pEnumTopology->fToDirection) {
       ulPinNumber = ulToPinNumber;
       ulToPinNumber = ulFromPinNumber;
       ulFromPinNumber = ulPinNumber;
       fPinEqual = fToPinEqual;
       fToPinEqual = fFromPinEqual;
       fFromPinEqual = fPinEqual;
    }
    ASSERT(ulToPinNumber != MAXULONG);
    ASSERT(ulFromPinNumber != MAXULONG);

    // Validate input/from pin(s)
    if(fFromPinEqual) {
        if(pTopologyPin->ulPinNumber != ulFromPinNumber) {
            DPF2(5, "EnumerateTopologyPin: %s bad 'from' pin number %08x",
              pTopologyPin->pTopologyNode->pFilterNode->DumpName(),
              pTopologyPin->ulPinNumber);
            Status = STATUS_INVALID_DEVICE_REQUEST;
            goto exit;
        }
    }
    else {
        if(pTopologyPin->ulPinNumber < ulFromPinNumber) {
            DPF2(5, "EnumerateTopologyPin: %s bad 'from' pin number %08x",
              pTopologyPin->pTopologyNode->pFilterNode->DumpName(),
              pTopologyPin->ulPinNumber);
            Status = STATUS_INVALID_DEVICE_REQUEST;
            goto exit;
        }
    }

    FOR_EACH_LIST_ITEM(
      &pTopologyPin->pTopologyNode->lstTopologyPin,
      pTopologyPin2) {

        if(pTopologyPin == pTopologyPin2) {
            continue;
        }

        // Pick the right output/to pin(s)
        if(fToPinEqual) {
            if(pTopologyPin2->ulPinNumber != ulToPinNumber) {
                continue;
            }
        }
        else {
            if(pTopologyPin2->ulPinNumber < ulToPinNumber) {
                continue;
            }
        }

        FOR_EACH_LIST_ITEM(
          &pTopologyPin2->lstTopologyConnection,
          pTopologyConnection) {

            Assert(pTopologyConnection);
            if(pEnumTopology->fToDirection) {
                if(pTopologyConnection->pTopologyPinFrom != pTopologyPin2) {
                    continue;
                }
                ASSERT(pTopologyConnection->pTopologyPinTo != pTopologyPin2);
            }
            else {
                if(pTopologyConnection->pTopologyPinTo != pTopologyPin2) {
                    continue;
                }
                ASSERT(pTopologyConnection->pTopologyPinFrom != pTopologyPin2);
            }
            Status = EnumerateTopologyConnection(
              pTopologyConnection,
              pEnumTopology);

            if(Status != STATUS_CONTINUE) {
                goto exit;
            }

        } END_EACH_LIST_ITEM

    } END_EACH_LIST_ITEM
exit:
    return(Status);
}

ENUMFUNC
EnumerateTopologyConnection(
    IN PTOPOLOGY_CONNECTION pTopologyConnection,
    IN PENUM_TOPOLOGY pEnumTopology
)
{
    PTOPOLOGY_PIN pTopologyPin;
    PPIN_INFO pPinInfo;
    NTSTATUS Status;

    Assert(pEnumTopology);
    Assert(pTopologyConnection);
    DPF1(110, "EnumerateTopologyConnection %08x", pTopologyConnection);

    if(pEnumTopology->cTopologyRecursion++ > (gcTopologyConnections + 16)) {
        Trap();
        DPF(5, "EnumerateTopologyConnection: recursion too deep");
        Status = STATUS_STACK_OVERFLOW;
        goto exit;
    }
    // Have we visited this topology connection already?
    Status = VisitedTopologyConnection(pTopologyConnection, pEnumTopology);
    if(Status != STATUS_CONTINUE) {
        if(Status == STATUS_DEAD_END) {
            Status = STATUS_CONTINUE;
        }
        goto exit;
    }
    Status = (*pEnumTopology->Function)(
      pTopologyConnection,
      pEnumTopology->fToDirection,
      pEnumTopology->pReference);

    if(Status != STATUS_CONTINUE) {
        if(Status == STATUS_DEAD_END) {
            Status = STATUS_CONTINUE;
        }
        goto exit;
    }
    if(pEnumTopology->fToDirection) {
       pTopologyPin = pTopologyConnection->pTopologyPinTo;
       pPinInfo = pTopologyConnection->pPinInfoTo;
    }
    else {
       pTopologyPin = pTopologyConnection->pTopologyPinFrom;
       pPinInfo = pTopologyConnection->pPinInfoFrom;
    }
    if(pTopologyPin != NULL) {

        Status = EnumerateTopologyPin(pTopologyPin, pEnumTopology);
        if(Status != STATUS_CONTINUE) {
            goto exit;
        }
    }
    if(pPinInfo != NULL) {

        Status = EnumeratePinInfoTopology(pPinInfo, pEnumTopology);
        if(Status != STATUS_CONTINUE) {
            goto exit;
        }
    }
exit:
    pEnumTopology->cTopologyRecursion--;
    return(Status);
}

ENUMFUNC
VisitedTopologyConnection(
    IN PTOPOLOGY_CONNECTION pTopologyConnection,
    IN PENUM_TOPOLOGY pEnumTopology
)
{
    NTSTATUS Status;

    Assert(pEnumTopology);
    Assert(pTopologyConnection);

    // Have we visited this topology connection already?
    if(pTopologyConnection->CheckDupList(
      &pEnumTopology->lstTopologyConnection)) {
        DPF1(100, "VisitedTopologyConnection: %08x already visited",
          pTopologyConnection);
        Status = STATUS_DEAD_END;
        goto exit;		// yes, break cycle in topology
    }
    // Add topology pin to list of pin's visited
    Status = pTopologyConnection->AddList(
      &pEnumTopology->lstTopologyConnection);
    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
    Status = STATUS_CONTINUE;
exit:
    return(Status);
}

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\sysaudio\sni.h ===
//---------------------------------------------------------------------------
//
//  Module:   		sni.h
//
//  Description:	Start Node Instance Class
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Constants and Macros
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Classes
//---------------------------------------------------------------------------

typedef class CStartNodeInstance : public CListDoubleItem
{
private:
    CStartNodeInstance(
        PPIN_INSTANCE pPinInstance,
        PSTART_NODE pStartNode
    );

    ~CStartNodeInstance();

    VOID
    CleanUp(
    );

public:
    static NTSTATUS
    Create(
        PPIN_INSTANCE pPinInstance,
        PSTART_NODE pStartNode,
        PKSPIN_CONNECT pPinConnect,
        PWAVEFORMATEX pWaveFormatExRequested
    );

    ENUMFUNC
    Destroy(
    )
    {
        if(this != NULL) {
            Assert(this);
            delete this;
        }
        return(STATUS_CONTINUE);
    };

    NTSTATUS
    IntelligentConnect(
        PDEVICE_NODE pDeviceNode,
        PKSPIN_CONNECT pPinConnect,
        PWAVEFORMATEX pWaveFormatEx
    );

    NTSTATUS
    Connect(
        PDEVICE_NODE pDeviceNode,
        PKSPIN_CONNECT pPinConnect,
        PWAVEFORMATEX pWaveFormatEx,
        PKSPIN_CONNECT pPinConnectDirect
    );

    NTSTATUS
    AecConnectionFormat(
        PDEVICE_NODE pDeviceNode,
        PKSPIN_CONNECT *ppPinConnect);

    NTSTATUS
    CreateTopologyTable(
        PGRAPH_NODE_INSTANCE pGraphNodeInstance 
    );

    NTSTATUS
    GetTopologyNodeFileObject(
        OUT PFILE_OBJECT *ppFileObject,
        IN ULONG NodeId
    );

    BOOL
    IsRender()
    {
        return pStartNode->fRender;
    };

    NTSTATUS
    SetState(
        KSSTATE NewState,
        ULONG ulFlags
    );

    NTSTATUS
    SetStateTopDown(
        KSSTATE NewState,
        KSSTATE PreviousState,
        ULONG ulFlags
    );

    NTSTATUS
    SetStateBottomUp(
        KSSTATE NewState,
        KSSTATE PreviousState,
        ULONG ulFlags
    );

    KSSTATE CurrentState;
    PSTART_NODE pStartNode;
    PPIN_INSTANCE pPinInstance;
    PVIRTUAL_NODE_DATA pVirtualNodeData;
    PFILE_OBJECT *papFileObjectTopologyTable;
    LIST_CONNECT_NODE_INSTANCE lstConnectNodeInstance;
    PFILTER_NODE_INSTANCE pFilterNodeInstance;
    PPIN_NODE_INSTANCE pPinNodeInstance;
public:
    DefineSignature(0x20494E53);		// SNI

} START_NODE_INSTANCE, *PSTART_NODE_INSTANCE;

//---------------------------------------------------------------------------

typedef ListDoubleDestroy<START_NODE_INSTANCE> LIST_START_NODE_INSTANCE;

//---------------------------------------------------------------------------
// Globals
//---------------------------------------------------------------------------

extern WAVEFORMATEX aWaveFormatEx[];

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\sysaudio\tc.h ===
//---------------------------------------------------------------------------
//
//  Module:   		tc.h
//
//  Description:	Topology Connection Class
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Constants and Macros
//---------------------------------------------------------------------------

#define TOPC_FLAGS_FILTER_CONNECTION_TYPE	0x00000000
#define TOPC_FLAGS_PHYSICAL_CONNECTION_TYPE	0x00000001
#define TOPC_FLAGS_GRAPH_CONNECTION_TYPE	0x00000002
#define TOPC_FLAGS_CONNECTION_TYPE		0x00000003

#define	IS_CONNECTION_TYPE(pTopologyConnection, Type) \
	(((pTopologyConnection)->ulFlags & TOPC_FLAGS_CONNECTION_TYPE) ==\
	TOPC_FLAGS_##Type##_CONNECTION_TYPE)

//---------------------------------------------------------------------------
// Classes
//---------------------------------------------------------------------------

typedef class CTopologyConnection : public CListMultiItem
{
private:
    CTopologyConnection(
	PTOPOLOGY_PIN pTopologyPinFrom,
	PTOPOLOGY_PIN pTopologyPinTo,
	PPIN_INFO pPinInfoFrom,
	PPIN_INFO pPinInfoTo
    );

    ~CTopologyConnection(
    );

public:
    static NTSTATUS
    Create(
	PTOPOLOGY_CONNECTION *ppTopologyConnection,
	PFILTER_NODE pFilterNode,
	PGRAPH_NODE pGraphNode,
	PTOPOLOGY_PIN pTopologyPinFrom,
	PTOPOLOGY_PIN pTopologyPinTo,
	PPIN_INFO pPinInfoFrom,
	PPIN_INFO pPinInfoTo
    );

    ENUMFUNC
    Destroy()
    {
	Assert(this);
	delete this;
	return(STATUS_CONTINUE);
    };

    ENUMFUNC
    CheckDuplicate(
	PVOID ppTopologyConnection
    );

    ENUMFUNC
    ProcessTopologyConnection(
	PVOID pGraphNodeInstance
    );

    BOOL
    IsTopologyConnectionOnGraphNode(
	PGRAPH_NODE pGraphNode
    );

    ULONG ulFlags;
    PTOPOLOGY_PIN pTopologyPinFrom;
    PTOPOLOGY_PIN pTopologyPinTo;
    PPIN_INFO pPinInfoFrom;
    PPIN_INFO pPinInfoTo;
    DefineSignature(0x20204354);		// TC

} TOPOLOGY_CONNECTION, *PTOPOLOGY_CONNECTION;

//---------------------------------------------------------------------------

typedef ListMultiDestroy<TOPOLOGY_CONNECTION> LIST_DESTROY_TOPOLOGY_CONNECTION;
typedef LIST_DESTROY_TOPOLOGY_CONNECTION *PLIST_DESTROY_TOPOLOGY_CONNECTION;

//---------------------------------------------------------------------------

typedef ListMulti<TOPOLOGY_CONNECTION> LIST_MULTI_TOPOLOGY_CONNECTION;

//---------------------------------------------------------------------------
// Globals
//---------------------------------------------------------------------------

extern ULONG gcTopologyConnections;

//---------------------------------------------------------------------------
// Local prototypes
//---------------------------------------------------------------------------

NTSTATUS
CreatePinInfoConnection(
    IN PTOPOLOGY_CONNECTION *ppTopologyConnection,
    IN PFILTER_NODE pFilterNode,
    IN PGRAPH_NODE pGraphNode,
    IN PPIN_INFO pPinInfoSource,
    IN PPIN_INFO pPinInfoSink
);

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\sysaudio\tp.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   tp.cpp
//
//  Description:
//
//	Topology Pin Class
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//  To Do:     Date	  Author      Comment
//
//@@END_MSINTERNAL
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

NTSTATUS
CTopologyPin::Create(
    PTOPOLOGY_PIN *ppTopologyPin,
    ULONG ulPinNumber,
    PTOPOLOGY_NODE pTopologyNode
)
{
    PTOPOLOGY_PIN pTopologyPin = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    Assert(pTopologyNode);
    FOR_EACH_LIST_ITEM(&pTopologyNode->lstTopologyPin, pTopologyPin) {

        if(pTopologyPin->ulPinNumber == ulPinNumber) {
            goto exit;
        }

    } END_EACH_LIST_ITEM

    pTopologyPin = new TOPOLOGY_PIN(ulPinNumber, pTopologyNode);
    if(pTopologyPin == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        Trap();
        goto exit;
    }
    DPF2(70, "CTopologyPin::Create: %08x, TN: %08x",
      pTopologyPin,
      pTopologyNode);
exit:
    *ppTopologyPin = pTopologyPin;
    return(Status);
}

CTopologyPin::CTopologyPin(
    ULONG ulPinNumber,
    PTOPOLOGY_NODE pTopologyNode
)
{
    Assert(this);
    this->ulPinNumber = ulPinNumber;
    this->pTopologyNode = pTopologyNode;
    AddList(&pTopologyNode->lstTopologyPin);
    DPF2(70, "CTopologyPin: %08x, TN: %08x", this, pTopologyNode);
}

CTopologyPin::~CTopologyPin(
)
{
    DPF1(70, "~CTopologyPin: %08x", this);
    Assert(this);
}

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\sysaudio\tn.h ===
//---------------------------------------------------------------------------
//
//  Module:   		tn.h
//
//  Description:	Topology Node Class
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Constants and Macros
//---------------------------------------------------------------------------

#define TN_FLAGS_DONT_FORWARD			0x00000001

//---------------------------------------------------------------------------
// Classes
//---------------------------------------------------------------------------

typedef ListMulti<CLogicalFilterNode> LIST_MULTI_LOGICAL_FILTER_NODE;

//---------------------------------------------------------------------------

typedef class CTopologyNode : public CListSingleItem
{
public:
    CTopologyNode(
	PFILTER_NODE pFilterNode,
	ULONG ulNodeNumber,
	GUID *pguidType
    );

    ~CTopologyNode(
    );

    static NTSTATUS
    Create(
	PTOPOLOGY_NODE *ppTopologyNode,
	PFILTER_NODE pFilterNode,
	ULONG ulNodeNumber,
	GUID *pguidType
    );

    ENUMFUNC
    Destroy()
    {
	Assert(this);
	delete this;
	return(STATUS_CONTINUE);
    };

    ENUMFUNC
    InitializeTopologyNode(
	PVOID pGraphNodeInstance
    );

    ENUMFUNC 
    AddTopologyNode(
	PVOID pGraphNodeInstance
    );

    ENUMFUNC
    MatchTopologyNode(
	PVOID pReference
    )
    {
	if(this == PTOPOLOGY_NODE(pReference)) {
	    return(STATUS_SUCCESS);
	}
	return(STATUS_CONTINUE);
    };

    PFILTER_NODE pFilterNode;
    GUID *pguidType;
    ULONG ulFlags;
    ULONG ulRealNodeNumber;
    ULONG ulSysaudioNodeNumber;
    ULONG iVirtualSource;
    LIST_TOPOLOGY_PIN lstTopologyPin;
    LIST_MULTI_LOGICAL_FILTER_NODE lstLogicalFilterNode;
    DefineSignature(0x20204E54);		// TN

} TOPOLOGY_NODE, *PTOPOLOGY_NODE;

//---------------------------------------------------------------------------

typedef ListSingleDestroy<TOPOLOGY_NODE> LIST_TOPOLOGY_NODE;

//---------------------------------------------------------------------------

typedef ListData<TOPOLOGY_NODE> LIST_DATA_TOPOLOGY_NODE, *PLIST_DATA_TOPOLOGY_NODE;

//---------------------------------------------------------------------------
// Globals
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Local prototypes
//---------------------------------------------------------------------------

NTSTATUS
CreateTopology(
    PFILTER_NODE pFilterNode,
    PKSTOPOLOGY pTopology
);

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\sysaudio\topology.h ===
//---------------------------------------------------------------------------
//
//  Module:   topology.h
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Constants and Macros
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Data structures
//---------------------------------------------------------------------------

typedef struct enum_topology {

    ULONG cTopologyRecursion;
    LIST_MULTI_TOPOLOGY_CONNECTION lstTopologyConnection;
    NTSTATUS (*Function)(
	IN PTOPOLOGY_CONNECTION pTopologyConnection,
	IN BOOL fToDirection,
	IN OUT PVOID pReference
    );
    BOOL fToDirection;
    PVOID pReference;
    DefineSignature(0x504F5445);		// ETOP

} ENUM_TOPOLOGY, *PENUM_TOPOLOGY;

//---------------------------------------------------------------------------

typedef ENUMFUNC (*TOP_PFN)(PTOPOLOGY_CONNECTION, BOOL, PVOID);

//---------------------------------------------------------------------------
// Global variables
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Local prototypes
//---------------------------------------------------------------------------

ENUMFUNC
EnumerateTopology(
    IN PPIN_INFO pPinInfo,
    IN NTSTATUS (*Function)(
	IN PTOPOLOGY_CONNECTION pTopologyConnection,
	IN BOOL fToDirection,
	IN OUT PVOID pReference
    ),
    IN OUT PVOID pReference
);

ENUMFUNC
EnumerateGraphTopology(
    IN PSTART_INFO pStartInfo,
    IN NTSTATUS (*Function)(
	IN PTOPOLOGY_CONNECTION pTopologyConnection,
	IN BOOL fToDirection,
	IN OUT PVOID pReference
    ),
    IN OUT PVOID pReference
);

ENUMFUNC
EnumeratePinInfoTopology(
    IN PPIN_INFO pPinInfo,
    IN PENUM_TOPOLOGY pEnumTopology
);

ENUMFUNC
EnumerateTopologyPin(
    IN PTOPOLOGY_PIN pTopologyPin,
    IN PENUM_TOPOLOGY pEnumTopology
);

ENUMFUNC
EnumerateTopologyConnection(
    IN PTOPOLOGY_CONNECTION pTopologyConnection,
    IN PENUM_TOPOLOGY pEnumTopology
);

ENUMFUNC
VisitedTopologyConnection(
    IN PTOPOLOGY_CONNECTION pTopologyConnection,
    IN PENUM_TOPOLOGY pEnumTopology
);

//---------------------------------------------------------------------------
//  End of File: topology.h
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\sysaudio\util.h ===
//---------------------------------------------------------------------------
//
//  Module:   util.h
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date       Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Constants and Macros
//---------------------------------------------------------------------------

#define INTERNAL_WILDCARD       ((PKSIDENTIFIER)-1)

#define STATUS_DEAD_END         ((NTSTATUS)-1)

#define POOLTAG_SYSA            0x41535953  // 'SYSA'

//---------------------------------------------------------------------------
// Global Data
//---------------------------------------------------------------------------

extern "C" KMUTEX gMutex;

#ifdef DEBUG
extern ULONG ulDebugFlags;
extern ULONG ulDebugNumber;
#endif

//---------------------------------------------------------------------------
// Data structures
//---------------------------------------------------------------------------

typedef struct dataranges {
    KSMULTIPLE_ITEM MultipleItem;
    KSDATARANGE aDataRanges[1];
} DATARANGES, *PDATARANGES;

typedef struct identifiers {
    KSMULTIPLE_ITEM MultipleItem;
    KSIDENTIFIER aIdentifiers[1];	// Array of identifiers
} IDENTIFIERS, *PIDENTIFIERS;

typedef class CQueueWorkListData : public CObj
{
public:
    void * __cdecl operator new(size_t size)
    {
	return(ExAllocatePoolWithTag(NonPagedPool, size, POOLTAG_SYSA));
    };
    void __cdecl operator delete(void *p)
    {
	ExFreePool(p);
    };

    CQueueWorkListData(
	NTSTATUS (*Function)(PVOID Reference1, PVOID Reference2),
	PVOID Reference1,
	PVOID Reference2
    );

    NTSTATUS
    QueueAsyncList(
    );

    static VOID
    AsyncWorker(
	IN OUT PVOID pReference
    );

private:
    LIST_ENTRY leNext;
    NTSTATUS (*Function)(PVOID, PVOID);
    PVOID Reference1;
    PVOID Reference2;
    DefineSignature(0x444c5751);      			// QWLD

} QUEUE_WORK_LIST_DATA, *PQUEUE_WORK_LIST_DATA;

//---------------------------------------------------------------------------

typedef NTSTATUS (*UTIL_PFN)(PVOID, PVOID);

//---------------------------------------------------------------------------
// Inline helper functions
//---------------------------------------------------------------------------

__inline int IsEqualGUID(const GUID *lpguid1, const GUID *lpguid2)
{
    return !memcmp(lpguid1, lpguid2, sizeof(GUID));
}

__inline VOID GrabMutex()
{
    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);
#ifdef DEBUG
    LARGE_INTEGER li = {0, 600000000};
    NTSTATUS Status;
    while(Status = KeWaitForMutexObject(
      &gMutex,
      Executive,
      KernelMode,
      FALSE,
      &li) == STATUS_TIMEOUT) {
	dprintf("SYSAUDIO: possible deadlock - thread %08x\n",
	  KeGetCurrentThread());
    }
#else
    KeWaitForMutexObject(&gMutex, Executive, KernelMode, FALSE, NULL);
#endif
}

__inline VOID ReleaseMutex()
{
    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);
    KeReleaseMutex(&gMutex, FALSE);
}

//---------------------------------------------------------------------------
// Local prototypes
//---------------------------------------------------------------------------

extern "C" {

NTSTATUS
InitializeUtil(
);

VOID
UninitializeUtil(
);

VOID
UninitializeMemory(
);

NTSTATUS
DispatchInvalidDeviceRequest(
   IN PDEVICE_OBJECT pdo,
   IN PIRP           pIrp
);

BOOLEAN
DispatchFastIoDeviceControlFailure(
   IN PFILE_OBJECT FileObject,
   IN BOOLEAN Wait,
   IN PVOID InputBuffer OPTIONAL,
   IN ULONG InputBufferLength,
   OUT PVOID OutputBuffer OPTIONAL,
   IN ULONG OutputBufferLength,
   IN ULONG IoControlCode,
   OUT PIO_STATUS_BLOCK IoStatus,
   IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN
DispatchFastReadFailure(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
);

#define DispatchFastWriteFailure DispatchFastReadFailure

CompareDataRange(
    PKSDATARANGE pDataRange1,
    PKSDATARANGE pDataRange2
);

BOOL
DataIntersectionRange(
    PKSDATARANGE pDataRange1,
    PKSDATARANGE pDataRange2,
    PKSDATARANGE pDataRangeIntersection
);

BOOL
DataIntersectionAudio(
    PKSDATARANGE_AUDIO pDataRangeAudio1,
    PKSDATARANGE_AUDIO pDataRangeAudio2,
    PKSDATARANGE_AUDIO pDataRangeAudioIntersection
);

BOOL
CompareDataRangeExact(
    PKSDATARANGE pDataRange1,
    PKSDATARANGE pDataRange2
);

BOOL
CompareDataRangeGuids(
    PKSDATARANGE pDataRange1,
    PKSDATARANGE pDataRange2
);

BOOL
CompareIdentifier(
    PKSIDENTIFIER pIdentifier1,
    PKSIDENTIFIER pIdentifier2
);

void
ModifyPinConnect(
    PKSPIN_CONNECT pPinConnect,
    WORD nChannels
);

NTSTATUS 
OpenDevice(
    IN PWSTR pwstrDevice,
    OUT PHANDLE pHandle
);

NTSTATUS
GetPinProperty(
    PFILE_OBJECT pFileObject,
    ULONG PropertyId,
    ULONG PinId,
    ULONG cbProperty,
    PVOID pProperty
);

NTSTATUS
PinConnectionProperty(
    PFILE_OBJECT pFileObject,
    ULONG ulPropertyId,
    ULONG ulFlags,
    ULONG cbProperty,
    PVOID pProperty

);

NTSTATUS
GetPinPropertyEx(
    PFILE_OBJECT pFileObject,
    ULONG PropertyId,
    ULONG PinId,
    PVOID *ppProperty
);

NTSTATUS
GetPinProperty2(
    PFILE_OBJECT pFileObject,
    ULONG ulPropertyId,
    ULONG ulPinId,
    ULONG cbInput,
    PVOID pInputData,
    PVOID *ppPropertyOutput
);

NTSTATUS
GetProperty(
    PFILE_OBJECT pFileObject,
    CONST GUID *pguidPropertySet,
    ULONG ulPropertyId,
    PVOID *ppPropertyOutput
);

NTSTATUS 
QueueWorkList(
    IN NTSTATUS (*Function)(PVOID Reference1, PVOID Reference2),
    IN PVOID Reference1,
    IN PVOID Reference2
);

VOID 
GetDefaultOrder(
    ULONG fulType,
    PULONG pulOrder
);

NTSTATUS
SetKsFrameHolding(
    PFILE_OBJECT pFileObject
);

//---------------------------------------------------------------------------
// Validation Routines

PWAVEFORMATEX 
GetWaveFormatExFromKsDataFormat(
    PKSDATAFORMAT pDataFormat,
    PULONG pcbFormat    
);

//---------------------------------------------------------------------------

#ifdef DEBUG

VOID
DumpPinConnect(
    LONG Level,
    PKSPIN_CONNECT pPinConnect
);

VOID
DumpDataFormat(
    LONG Level,
    PKSDATAFORMAT pDataFormat
);

VOID
DumpWaveFormatEx(
    LONG Level,
    PSZ pszSpecifier,
    WAVEFORMATEX *pWaveFormatEx
);

VOID
DumpDataRange(
    LONG Level,
    PKSDATARANGE_AUDIO pDataRangeAudio
);

PSZ DbgUnicode2Sz(
    PWSTR pwstr
);

PSZ
DbgIdentifier2Sz(
    PKSIDENTIFIER pIdentifier
);

PSZ
DbgGuid2Sz(
    GUID *pGuid
);

//---------------------------------------------------------------------------

#endif  // DEBUG

} // extern "C"

//---------------------------------------------------------------------------
//  End of File: util.h
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\sysaudio\tp.h ===
//---------------------------------------------------------------------------
//
//  Module:   		tp.h
//
//  Description:	Topology Pin Class
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Constants and Macros
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Classes
//---------------------------------------------------------------------------

typedef class CTopologyPin : public CListSingleItem
{
public:
    CTopologyPin(
	ULONG ulPinNumber,
	PTOPOLOGY_NODE pTopologyNode
    );
    ~CTopologyPin();

    static NTSTATUS
    Create(
	PTOPOLOGY_PIN *ppTopologyPin,
	ULONG ulPinNumber,
	PTOPOLOGY_NODE pTopologyNode
    );

    ENUMFUNC
    Destroy()
    {
	Assert(this);
	delete this;
	return(STATUS_CONTINUE);
    };

    PTOPOLOGY_NODE pTopologyNode;
    ULONG ulPinNumber;
    LIST_DESTROY_TOPOLOGY_CONNECTION lstTopologyConnection;
    DefineSignature(0x20205054);		// TP

} TOPOLOGY_PIN, *PTOPOLOGY_PIN;

//---------------------------------------------------------------------------

typedef ListSingleDestroy<TOPOLOGY_PIN> LIST_TOPOLOGY_PIN;

//---------------------------------------------------------------------------

typedef ListData<TOPOLOGY_PIN> LIST_DATA_TOPOLOGY_PIN;

//---------------------------------------------------------------------------
// Globals
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Local prototypes
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\sysaudio\util.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   util.c
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date       Author      Comment
//
//  To Do:     Date       Author      Comment
//
//@@END_MSINTERNAL
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"

#define SMALL_BLOCK_SIZE        32

extern KSDATARANGE DataRangeWildCard;
extern KSDATARANGE VirtualPinDataRange;

//===========================================================================
//===========================================================================

#pragma LOCKED_DATA

#ifdef DEBUG
//#define MEMORY_LIST       // Enable this to use ExAlloc instead of Zones.
ULONG ulDebugFlags = 0;
ULONG ulDebugNumber = MAXULONG;
int SYSAUDIOTraceLevel = 5;
ULONG cAllocMem = 0;
ULONG cAllocMemSmall = 0;
ULONG cAllocMem64 = 0;
ULONG cAllocMem128 = 0;
ULONG cbMemoryUsage = 0;
#endif

//===========================================================================
//===========================================================================

LIST_ENTRY glehQueueWorkList;
KSPIN_LOCK gSpinLockQueueWorkList;
WORK_QUEUE_ITEM gWorkItem;
LONG gcQueueWorkList = 0;
KMUTEX gMutex;
PKSWORKER gWorkerObject = NULL;

#ifdef USE_ZONES
ZONE_HEADER gZone;
#endif

#ifdef MEMORY_LIST
LIST_ENTRY gleMemoryHead;
KSPIN_LOCK gSpinLockMemoryHead;
#endif

#pragma PAGEABLE_DATA

//===========================================================================
//===========================================================================

#pragma INIT_CODE
#pragma INIT_DATA

NTSTATUS
InitializeUtil()
{
    NTSTATUS Status = STATUS_SUCCESS;
    
#ifdef USE_ZONES
    PVOID pInitial = NULL;

    pInitial = ExAllocatePoolWithTag(PagedPool, 4096, POOLTAG_SYSA);
    if(pInitial == NULL) {
        Trap();
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }
    Status = ExInitializeZone(&gZone, SMALL_BLOCK_SIZE, pInitial, 4096);
    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }
#endif

#ifdef MEMORY_LIST
    InitializeListHead(&gleMemoryHead);
    KeInitializeSpinLock(&gSpinLockMemoryHead);
#endif

    KeInitializeSpinLock(&gSpinLockQueueWorkList);
    InitializeListHead(&glehQueueWorkList);
    ExInitializeWorkItem(
      &gWorkItem,
      CQueueWorkListData::AsyncWorker,
      NULL);

    //
    // Note... if we fail during preparation, the DriverUnload() routine
    // calls the UninitializeUtil() function which handles the clean up.
    //
    Status = KsRegisterWorker(DelayedWorkQueue, &gWorkerObject);
    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }

exit:

#ifdef USE_ZONES
    if(!NT_SUCCESS(Status)) {
	if(pInitial != NULL) {
	    //
	    // Make sure UninitializeMemory doesn't also try to free this.
	    //
	    gZone.SegmentList.Next = NULL;
	    //
	    // Free initial zone page if failure
	    //
	    ExFreePool(pInitial);
	}
    }
#endif

    return(Status);
}

#pragma PAGEABLE_CODE
#pragma PAGEABLE_DATA

VOID
UninitializeUtil()
{
    if(gWorkerObject != NULL) {
        KsUnregisterWorker(gWorkerObject);
        gWorkerObject = NULL;
    }
}

VOID
UninitializeMemory()
{
#ifdef USE_ZONES
    PSINGLE_LIST_ENTRY psle, psleNext;

    psle = gZone.SegmentList.Next;
    while(psle != NULL) {
        psleNext = psle->Next;
        ExFreePool(psle);
        psle = psleNext;
    }
#endif
    ASSERT(cbMemoryUsage == 0);
}

//
// NOTE:
// These functions are necessary to avoid the linker error LNK4210.
// If you fill the dispatch tables with KsXXX functions instead of XXX
// functions, the linker will error out. It will think that global-variables
// are initialized with a non-compile-time constant.
// 
NTSTATUS
DispatchInvalidDeviceRequest(
   IN PDEVICE_OBJECT pdo,
   IN PIRP           pIrp
)
{
    return KsDispatchInvalidDeviceRequest(pdo,pIrp);
}

BOOLEAN
DispatchFastIoDeviceControlFailure(
   IN PFILE_OBJECT FileObject,
   IN BOOLEAN Wait,
   IN PVOID InputBuffer OPTIONAL,
   IN ULONG InputBufferLength,
   OUT PVOID OutputBuffer OPTIONAL,
   IN ULONG OutputBufferLength,
   IN ULONG IoControlCode,
   OUT PIO_STATUS_BLOCK IoStatus,
   IN PDEVICE_OBJECT DeviceObject
)
{
    return KsDispatchFastIoDeviceControlFailure(
      FileObject,
      Wait,
      InputBuffer,
      InputBufferLength,
      OutputBuffer,
      OutputBufferLength,
      IoControlCode,
      IoStatus,
      DeviceObject);
}

BOOLEAN
DispatchFastReadFailure(
   IN PFILE_OBJECT FileObject,
   IN PLARGE_INTEGER FileOffset,
   IN ULONG Length,
   IN BOOLEAN Wait,
   IN ULONG LockKey,
   OUT PVOID Buffer,
   OUT PIO_STATUS_BLOCK IoStatus,
   IN PDEVICE_OBJECT DeviceObject
)
{
    return KsDispatchFastReadFailure(
      FileObject,
      FileOffset,
      Length,
      Wait,
      LockKey,
      Buffer,
      IoStatus,
      DeviceObject);
}
// END_NOTE


BOOL
CompareDataRange(
    PKSDATARANGE pDataRange1,
    PKSDATARANGE pDataRange2
)
{
    KSDATARANGE_AUDIO DataRangeAudioIntersection;

    if(CompareDataRangeGuids(pDataRange1, pDataRange2)) {

        //
        // See if there is a valid intersection
        //
        if(DataIntersectionAudio(
          (PKSDATARANGE_AUDIO)pDataRange1,
          (PKSDATARANGE_AUDIO)pDataRange2,
          &DataRangeAudioIntersection)) {
            return(TRUE);
        }
        if(pDataRange1 == &DataRangeWildCard ||
           pDataRange2 == &DataRangeWildCard ||
           pDataRange1 == &VirtualPinDataRange ||
           pDataRange2 == &VirtualPinDataRange) {
            return(TRUE);
        }
        return(FALSE);
    }
    return(FALSE);
}

BOOL DataIntersectionRange(
    PKSDATARANGE pDataRange1,
    PKSDATARANGE pDataRange2,
    PKSDATARANGE pDataRangeIntersection
)
{
    // Pick up pDataRange1 values by default.
    *pDataRangeIntersection = *pDataRange1;

    if(IsEqualGUID(&pDataRange1->MajorFormat, &pDataRange2->MajorFormat) ||
       IsEqualGUID(&pDataRange1->MajorFormat, &KSDATAFORMAT_TYPE_WILDCARD)) {
        pDataRangeIntersection->MajorFormat = pDataRange2->MajorFormat;
    }
    else if(!IsEqualGUID(
      &pDataRange2->MajorFormat,
      &KSDATAFORMAT_TYPE_WILDCARD)) {
        return FALSE;
    }
    if(IsEqualGUID(&pDataRange1->SubFormat, &pDataRange2->SubFormat) ||
       IsEqualGUID(&pDataRange1->SubFormat, &KSDATAFORMAT_SUBTYPE_WILDCARD)) {
        pDataRangeIntersection->SubFormat = pDataRange2->SubFormat;
    }
    else if(!IsEqualGUID(
      &pDataRange2->SubFormat,
      &KSDATAFORMAT_SUBTYPE_WILDCARD)) {
        return FALSE;
    }
    if(IsEqualGUID(&pDataRange1->Specifier, &pDataRange2->Specifier) ||
       IsEqualGUID(&pDataRange1->Specifier, &KSDATAFORMAT_SPECIFIER_WILDCARD)) {
        pDataRangeIntersection->Specifier = pDataRange2->Specifier;
    }
    else if(!IsEqualGUID(
      &pDataRange2->Specifier,
      &KSDATAFORMAT_SPECIFIER_WILDCARD)) {
        return FALSE;
    }
    pDataRangeIntersection->Reserved = 0; // Must be zero
    return(TRUE);
}

BOOL
DataIntersectionAudio(
    PKSDATARANGE_AUDIO pDataRangeAudio1,
    PKSDATARANGE_AUDIO pDataRangeAudio2,
    PKSDATARANGE_AUDIO pDataRangeAudioIntersection
)
{
    if((IsEqualGUID(
      &pDataRangeAudio1->DataRange.Specifier,
      &KSDATAFORMAT_SPECIFIER_WAVEFORMATEX) ||
       IsEqualGUID(
      &pDataRangeAudio1->DataRange.Specifier,
      &KSDATAFORMAT_SPECIFIER_DSOUND)) &&
       IsEqualGUID(
      &pDataRangeAudio2->DataRange.Specifier,
      &KSDATAFORMAT_SPECIFIER_WILDCARD)) {

        pDataRangeAudioIntersection->MaximumChannels =
          pDataRangeAudio1->MaximumChannels;
        pDataRangeAudioIntersection->MaximumSampleFrequency =
          pDataRangeAudio1->MaximumSampleFrequency;
        pDataRangeAudioIntersection->MinimumSampleFrequency =
          pDataRangeAudio1->MinimumSampleFrequency;
        pDataRangeAudioIntersection->MaximumBitsPerSample =
          pDataRangeAudio1->MaximumBitsPerSample;
        pDataRangeAudioIntersection->MinimumBitsPerSample =
          pDataRangeAudio1->MinimumBitsPerSample;
        return(TRUE);
    }
    if(IsEqualGUID(
      &pDataRangeAudio1->DataRange.Specifier,
      &KSDATAFORMAT_SPECIFIER_WILDCARD) &&
      (IsEqualGUID(
      &pDataRangeAudio2->DataRange.Specifier,
      &KSDATAFORMAT_SPECIFIER_WAVEFORMATEX) ||
       IsEqualGUID(
      &pDataRangeAudio2->DataRange.Specifier,
      &KSDATAFORMAT_SPECIFIER_DSOUND))) {

        pDataRangeAudioIntersection->MaximumChannels =
          pDataRangeAudio2->MaximumChannels;
        pDataRangeAudioIntersection->MaximumSampleFrequency =
          pDataRangeAudio2->MaximumSampleFrequency;
        pDataRangeAudioIntersection->MinimumSampleFrequency =
          pDataRangeAudio2->MinimumSampleFrequency;
        pDataRangeAudioIntersection->MaximumBitsPerSample =
          pDataRangeAudio2->MaximumBitsPerSample;
        pDataRangeAudioIntersection->MinimumBitsPerSample =
          pDataRangeAudio2->MinimumBitsPerSample;
        return(TRUE);
    }
    if((IsEqualGUID(
      &pDataRangeAudio1->DataRange.Specifier,
      &KSDATAFORMAT_SPECIFIER_WAVEFORMATEX) ||
       IsEqualGUID(
      &pDataRangeAudio1->DataRange.Specifier,
      &KSDATAFORMAT_SPECIFIER_DSOUND)) &&
      (IsEqualGUID(
      &pDataRangeAudio2->DataRange.Specifier,
      &KSDATAFORMAT_SPECIFIER_WAVEFORMATEX) ||
       IsEqualGUID(
      &pDataRangeAudio2->DataRange.Specifier,
      &KSDATAFORMAT_SPECIFIER_DSOUND))) {

	if(pDataRangeAudio1->MaximumChannels <
	   pDataRangeAudio2->MaximumChannels) {
	    pDataRangeAudioIntersection->MaximumChannels =
	      pDataRangeAudio1->MaximumChannels;
	}
	else {
	    pDataRangeAudioIntersection->MaximumChannels =
	      pDataRangeAudio2->MaximumChannels;
	}

	if(pDataRangeAudio1->MaximumSampleFrequency <
	   pDataRangeAudio2->MaximumSampleFrequency) {
	    pDataRangeAudioIntersection->MaximumSampleFrequency =
	      pDataRangeAudio1->MaximumSampleFrequency;
	}
	else {
	    pDataRangeAudioIntersection->MaximumSampleFrequency =
	      pDataRangeAudio2->MaximumSampleFrequency;
	}
	if(pDataRangeAudio1->MinimumSampleFrequency >
	   pDataRangeAudio2->MinimumSampleFrequency) {
	    pDataRangeAudioIntersection->MinimumSampleFrequency =
	      pDataRangeAudio1->MinimumSampleFrequency;
	}
	else {
	    pDataRangeAudioIntersection->MinimumSampleFrequency =
	      pDataRangeAudio2->MinimumSampleFrequency;
	}
	if(pDataRangeAudioIntersection->MaximumSampleFrequency <
	   pDataRangeAudioIntersection->MinimumSampleFrequency ) {
	    DPF2(110, "DataIntersectionAudio: SR %08x %08x",
	      pDataRangeAudio1,
	      pDataRangeAudio2);
	    return(FALSE);
	}

	if(pDataRangeAudio1->MaximumBitsPerSample <
	   pDataRangeAudio2->MaximumBitsPerSample) {
	    pDataRangeAudioIntersection->MaximumBitsPerSample =
	      pDataRangeAudio1->MaximumBitsPerSample;
	}
	else {
	    pDataRangeAudioIntersection->MaximumBitsPerSample =
	      pDataRangeAudio2->MaximumBitsPerSample;
	}
	if(pDataRangeAudio1->MinimumBitsPerSample >
	   pDataRangeAudio2->MinimumBitsPerSample) {
	    pDataRangeAudioIntersection->MinimumBitsPerSample =
	      pDataRangeAudio1->MinimumBitsPerSample;
	}
	else {
	    pDataRangeAudioIntersection->MinimumBitsPerSample =
	      pDataRangeAudio2->MinimumBitsPerSample;
	}
	if(pDataRangeAudioIntersection->MaximumBitsPerSample <
	   pDataRangeAudioIntersection->MinimumBitsPerSample ) {
	    DPF2(110, "DataIntersectionAudio: BPS %08x %08x",
	      pDataRangeAudio1,
	      pDataRangeAudio2);
	    return(FALSE);
	}
	return(TRUE);
    }
    return(FALSE);
}

BOOL
CompareDataRangeExact(
    PKSDATARANGE pDataRange1,
    PKSDATARANGE pDataRange2
)
{
    if(pDataRange1 == NULL || pDataRange2 == NULL) {
        Trap();
        return(FALSE);
    }
    ASSERT(pDataRange1->Reserved == pDataRange2->Reserved);
    if(pDataRange1->FormatSize == pDataRange2->FormatSize) {
        return(!memcmp(pDataRange1, pDataRange2, pDataRange1->FormatSize));
    }
    return(FALSE);
}

BOOL
CompareDataRangeGuids(
    PKSDATARANGE pDataRange1,
    PKSDATARANGE pDataRange2
)
{
    if(pDataRange1 == NULL || pDataRange2 == NULL) {
        Trap();
        return(FALSE);
    }
    if((IsEqualGUID(&pDataRange1->MajorFormat, &pDataRange2->MajorFormat) ||
      IsEqualGUID(&pDataRange1->MajorFormat, &KSDATAFORMAT_TYPE_WILDCARD) ||
      IsEqualGUID(&pDataRange2->MajorFormat, &KSDATAFORMAT_TYPE_WILDCARD)) &&

     (IsEqualGUID(&pDataRange1->SubFormat, &pDataRange2->SubFormat) ||
      IsEqualGUID(&pDataRange1->SubFormat, &KSDATAFORMAT_SUBTYPE_WILDCARD) ||
      IsEqualGUID(&pDataRange2->SubFormat, &KSDATAFORMAT_SUBTYPE_WILDCARD)) &&

     (IsEqualGUID(&pDataRange1->Specifier, &pDataRange2->Specifier) ||
      IsEqualGUID(&pDataRange1->Specifier, &KSDATAFORMAT_SPECIFIER_WILDCARD) ||
      IsEqualGUID(&pDataRange2->Specifier, &KSDATAFORMAT_SPECIFIER_WILDCARD))) {
        return(TRUE);
    }
    return(FALSE);
}

BOOL
CompareIdentifier(
    PKSIDENTIFIER pIdentifier1,
    PKSIDENTIFIER pIdentifier2
)
{
    if(pIdentifier1 == NULL || pIdentifier2 == NULL) {
        Trap();
        return(FALSE);
    }
    if(pIdentifier1 == INTERNAL_WILDCARD ||
       pIdentifier2 == INTERNAL_WILDCARD) {
        return(TRUE);
    }
    if(IsEqualGUID(&pIdentifier1->Set, &pIdentifier2->Set) &&
      (pIdentifier1->Id == pIdentifier2->Id)) {
        return(TRUE);
    }
    return(FALSE);
}

//===========================================================================
//
// Returns the WAVEFORMATEX structure appended to KSDATAFORMAT.
// Assumptions:
//     - pDataFormat is totally trusted. It has been probed and buffered
//     properly.
//     - This function should only be called if MajorFormat is AUDIO.
//

PWAVEFORMATEX 
GetWaveFormatExFromKsDataFormat(
    PKSDATAFORMAT pDataFormat,
    PULONG pcbFormat
)
{
    ASSERT(pDataFormat);

    PWAVEFORMATEX pWaveFormat = NULL;

    if(IsEqualGUID(&pDataFormat->Specifier, &KSDATAFORMAT_SPECIFIER_WAVEFORMATEX)) {
        pWaveFormat = 
          &PKSDATAFORMAT_WAVEFORMATEX(pDataFormat)->WaveFormatEx;

        if (pcbFormat) {
            *pcbFormat = sizeof(KSDATAFORMAT_WAVEFORMATEX);
        }
    }
    else if(IsEqualGUID(&pDataFormat->Specifier, &KSDATAFORMAT_SPECIFIER_DSOUND)) {
        pWaveFormat = 
          &PKSDATAFORMAT_DSOUND(pDataFormat)->BufferDesc.WaveFormatEx;

        if (pcbFormat) {
            *pcbFormat = sizeof(KSDATAFORMAT_DSOUND);
        }
    }
    else {
        DPF(20, "GetWaveFormatExFromKsDataFormat : Unknown format specifier");
    }

    return pWaveFormat;
} // GetWaveFormatExFromKsDataFormat

//===========================================================================
//
// Edits the WAVEFORMATEX structure embedded in pPinConnect.
// Assumptions:
//     - pPinConnect and following KSDATAFORMAT is totally trusted. 
//     It has been probed and buffered properly.
//     - This function should only be called if MajorFormat is AUDIO.
//

void
ModifyPinConnect(
    PKSPIN_CONNECT pPinConnect,
    WORD  nChannels
)
{
    ASSERT(pPinConnect);

    PKSDATAFORMAT pDataFormat = (PKSDATAFORMAT) (pPinConnect + 1);
    PWAVEFORMATEX pWaveFormat = NULL;

    pWaveFormat = GetWaveFormatExFromKsDataFormat(pDataFormat, NULL);
    if (NULL != pWaveFormat) {
        if (IsEqualGUID(&pDataFormat->SubFormat, &KSDATAFORMAT_SUBTYPE_PCM)) {
            
            pWaveFormat->nChannels = nChannels;
            pWaveFormat->nBlockAlign = 
                (pWaveFormat->wBitsPerSample / 8) * pWaveFormat->nChannels;
            pWaveFormat->nAvgBytesPerSec =
                pWaveFormat->nSamplesPerSec * pWaveFormat->nBlockAlign;

            //
            // Modify speaker configuration for WAVEFORMATEXTENSIBLE.
            //
            if (WAVE_FORMAT_EXTENSIBLE == pWaveFormat->wFormatTag) {
                PWAVEFORMATEXTENSIBLE pWaveFormatExt = 
                    (PWAVEFORMATEXTENSIBLE) pWaveFormat;
                
                if (1 == nChannels) {
                    pWaveFormatExt->dwChannelMask = SPEAKER_FRONT_CENTER;
                }
                else if (2 == nChannels) {
                    pWaveFormatExt->dwChannelMask = 
                        SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT;
                }
            }
        }
        else {
            DPF(5, "ModifyPinConnect : Not touching NON-PCM formats.");            
        }
    }
} // ModifyPinConnect

NTSTATUS
OpenDevice(
    PWSTR pwstrDevice,
    PHANDLE pHandle
)
{
    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING UnicodeDeviceString;
    OBJECT_ATTRIBUTES ObjectAttributes;

    RtlInitUnicodeString(&UnicodeDeviceString, pwstrDevice);

    //
    // SECURITY NOTE:
    // OBJ_KERNEL_HANDLE is required here since this code might also be 
    // running in a USER process.
    //
    InitializeObjectAttributes(
      &ObjectAttributes,
      &UnicodeDeviceString,
      OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
      NULL,
      NULL);

    return(ZwCreateFile(pHandle,
      GENERIC_READ | GENERIC_WRITE,
      &ObjectAttributes,
      &IoStatusBlock,
      NULL,
      FILE_ATTRIBUTE_NORMAL,
      0,
      FILE_OPEN,
      0,
      NULL,
      0));
}

NTSTATUS
GetPinProperty(
    PFILE_OBJECT pFileObject,
    ULONG PropertyId,
    ULONG PinId,
    ULONG cbProperty,
    PVOID pProperty
)
{
    ULONG BytesReturned;
    KSP_PIN Pin;
    NTSTATUS Status;

    Pin.Property.Set = KSPROPSETID_Pin;
    Pin.Property.Id = PropertyId;
    Pin.Property.Flags = KSPROPERTY_TYPE_GET;
    Pin.PinId = PinId;
    Pin.Reserved = 0;

    AssertFileObject(pFileObject);
    Status = KsSynchronousIoControlDevice(
      pFileObject,
      KernelMode,
      IOCTL_KS_PROPERTY,
      &Pin,
      sizeof(Pin),
      pProperty,
      cbProperty,
      &BytesReturned);

    if(!NT_SUCCESS(Status)) {
        DPF2(10,
	  "GetPinProperty: id %d p %d KsSynchronousIoControlDevice FAILED",
	  PropertyId,
	  PinId);
        goto exit;
    }
    ASSERT(BytesReturned == cbProperty);
exit:
    return(Status);
}

NTSTATUS
PinConnectionProperty(
    PFILE_OBJECT pFileObject,
    ULONG ulPropertyId,
    ULONG ulFlags,
    ULONG cbProperty,
    PVOID pProperty
)
{
    KSIDENTIFIER Property;
    ULONG BytesReturned;
    NTSTATUS Status;

    Property.Set = KSPROPSETID_Connection;
    Property.Id = ulPropertyId;
    Property.Flags = ulFlags;

    AssertFileObject(pFileObject);
    Status = KsSynchronousIoControlDevice(
      pFileObject,
      KernelMode,
      IOCTL_KS_PROPERTY,
      &Property,
      sizeof(Property),
      pProperty,
      cbProperty,
      &BytesReturned);

    if(!NT_SUCCESS(Status)) {
        DPF(10, "SetPinConnectionProperty: KsSynchronousIoControlDevice Failed");
        goto exit;
    }
exit:
    return(Status);
}

NTSTATUS
GetPinPropertyEx(
    PFILE_OBJECT pFileObject,
    ULONG PropertyId,
    ULONG PinId,
    PVOID *ppProperty
)
{
    ULONG BytesReturned;
    NTSTATUS Status;
    KSP_PIN Pin;

    ASSERT(pFileObject);

    //
    // Setup the Property.
    // 
    Pin.Property.Set = KSPROPSETID_Pin;
    Pin.Property.Id = PropertyId;
    Pin.Property.Flags = KSPROPERTY_TYPE_GET;
    Pin.PinId = PinId;
    Pin.Reserved = 0;

    //
    // Send IOCTL to FILE_OBJECT to get the size of output buffer.
    // This should always fail.
    //
    AssertFileObject(pFileObject);
    Status = KsSynchronousIoControlDevice(
      pFileObject,
      KernelMode,
      IOCTL_KS_PROPERTY,
      &Pin,
      sizeof(KSP_PIN),
      NULL,
      0,
      &BytesReturned);

    //
    // SECURITY NOTE:
    // KsSynchronousIoControlDevice should never return STATUS_SUCCESS.
    //
    ASSERT(!NT_SUCCESS(Status));
    if(Status != STATUS_BUFFER_OVERFLOW) {
        goto exit;
    }
    if(BytesReturned == 0) {
        *ppProperty = NULL;
        Status = STATUS_SUCCESS;
        goto exit;
    }

    //
    // Now allocate the output buffer.
    //
    *ppProperty = new BYTE[BytesReturned];
    if(*ppProperty == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }

    //
    // Send IOCTL to FILE_OBJECT with actual output buffer.
    //
    AssertFileObject(pFileObject);
    Status = KsSynchronousIoControlDevice(
      pFileObject,
      KernelMode,
      IOCTL_KS_PROPERTY,
      &Pin,
      sizeof(KSP_PIN),
      *ppProperty,
      BytesReturned,
      &BytesReturned);

    if(!NT_SUCCESS(Status)) {
        Trap();
        delete *ppProperty;
        *ppProperty = NULL;
        goto exit;
    }
exit:
    if(Status == STATUS_PROPSET_NOT_FOUND ||
       Status == STATUS_NOT_FOUND) {
        Status = STATUS_SUCCESS;
        *ppProperty = NULL;
    }
    return(Status);
}

NTSTATUS
GetPinProperty2(
    PFILE_OBJECT pFileObject,
    ULONG ulPropertyId,
    ULONG ulPinId,
    ULONG cbInput,
    PVOID pInputData,
    PVOID *ppPropertyOutput
)
{
    ULONG cbPropertyInput = sizeof(KSP_PIN);
    ULONG BytesReturned;
    NTSTATUS Status;
    PKSP_PIN pPin;

    //
    // Allocate input buffer (sizeof(KSP_PIN) + cbInput) and set its 
    // fields
    //
    cbPropertyInput += cbInput;
    pPin = (PKSP_PIN)new BYTE[cbPropertyInput];
    if(pPin == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }
    pPin->Property.Set = KSPROPSETID_Pin;
    pPin->Property.Id = ulPropertyId;
    pPin->Property.Flags = KSPROPERTY_TYPE_GET;
    pPin->PinId = ulPinId;
    pPin->Reserved = 0;

    if(pInputData != NULL) {
        memcpy(pPin + 1, pInputData, cbInput);
    }

    //
    // Send IOCTL to FILE_OBJECT with NULL output buffer to get real
    // output size.
    // This call should always fail.
    //
    AssertFileObject(pFileObject);
    Status = KsSynchronousIoControlDevice(
      pFileObject,
      KernelMode,
      IOCTL_KS_PROPERTY,
      pPin,
      cbPropertyInput,
      NULL,
      0,
      &BytesReturned);

    //
    // SECURITY NOTE:
    // KsSynchronousIoControlDevice should never return STATUS_SUCCESS.
    //
    ASSERT(!NT_SUCCESS(Status));
    if(Status != STATUS_BUFFER_OVERFLOW) {
        DPF(10, "GetPinProperty2: KsSynchronousIoControlDevice 1 Failed");
        goto exit;
    }

    if(BytesReturned == 0) {
        *ppPropertyOutput = NULL;
        Status = STATUS_SUCCESS;
        goto exit;
    }

    //
    // Allocate the real output buffer.
    //
    *ppPropertyOutput = new BYTE[BytesReturned];
    if(*ppPropertyOutput == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }

    //
    // Send the IOCTL to FILE_OBJECT with real output buffer.
    //
    AssertFileObject(pFileObject);
    Status = KsSynchronousIoControlDevice(
      pFileObject,
      KernelMode,
      IOCTL_KS_PROPERTY,
      pPin,
      cbPropertyInput,
      *ppPropertyOutput,
      BytesReturned,
      &BytesReturned);

    if(!NT_SUCCESS(Status)) {
        DPF(10, "GetPinProperty2: KsSynchronousIoControlDevice 2 Failed");
        delete *ppPropertyOutput;
        goto exit;
    }
exit:
    delete [] pPin;
    if(!NT_SUCCESS(Status)) {
        *ppPropertyOutput = NULL;
        if(Status == STATUS_PROPSET_NOT_FOUND ||
           Status == STATUS_NOT_FOUND) {
            Status = STATUS_SUCCESS;
        }
    }
    return(Status);
}

NTSTATUS
GetProperty(
    PFILE_OBJECT pFileObject,
    CONST GUID *pguidPropertySet,
    ULONG ulPropertyId,
    PVOID *ppPropertyOutput
)
{
    ULONG BytesReturned;
    ULONG cbPropertyInput = sizeof(KSPROPERTY);
    PKSPROPERTY pPropertyInput;
    NTSTATUS Status;

    ASSERT(pguidPropertySet);
    ASSERT(pFileObject);
    ASSERT(ppPropertyOutput);

    //
    // Allocate KS Property structure and set its fields.
    //
    pPropertyInput = (PKSPROPERTY)new BYTE[cbPropertyInput];
    if(pPropertyInput == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }
    pPropertyInput->Set = *pguidPropertySet;
    pPropertyInput->Id = ulPropertyId;
    pPropertyInput->Flags = KSPROPERTY_TYPE_GET;

    //
    // Send property to FILE_OBJECT and get the actual return buffer size.
    // This should always return failure code.
    //
    AssertFileObject(pFileObject);
    Status = KsSynchronousIoControlDevice(
      pFileObject,
      KernelMode,
      IOCTL_KS_PROPERTY,
      pPropertyInput,
      cbPropertyInput,
      NULL,
      0,
      &BytesReturned);

    //
    // SECURITY NOTE:
    // KsSynchronousIoControlDevice should never return STATUS_SUCCESS.
    //
    ASSERT(!NT_SUCCESS(Status));
    if(Status != STATUS_BUFFER_OVERFLOW) {
        DPF(10, "GetProperty: KsSynchronousIoControlDevice 1 Failed");
        goto exit;
    }

    if(BytesReturned == 0) {
        *ppPropertyOutput = NULL;
        Status = STATUS_SUCCESS;
        goto exit;
    }

    //
    // Allocate memory for output buffer.
    //
    *ppPropertyOutput = new BYTE[BytesReturned];
    if(*ppPropertyOutput == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }

    //
    // Send property to FILE_OBJECT again (this time with output buffer).
    //
    AssertFileObject(pFileObject);
    Status = KsSynchronousIoControlDevice(
      pFileObject,
      KernelMode,
      IOCTL_KS_PROPERTY,
      pPropertyInput,
      cbPropertyInput,
      *ppPropertyOutput,
      BytesReturned,
      &BytesReturned);

    if(!NT_SUCCESS(Status)) {
        DPF(10, "GetProperty: KsSynchronousIoControlDevice 2 Failed");
        delete *ppPropertyOutput;
        goto exit;
    }
exit:
    delete [] pPropertyInput;
    if(!NT_SUCCESS(Status)) {
        *ppPropertyOutput = NULL;
        if(Status == STATUS_PROPSET_NOT_FOUND ||
           Status == STATUS_NOT_FOUND) {
            Status = STATUS_SUCCESS;
        }
    }
    return(Status);
}

CQueueWorkListData::CQueueWorkListData(
    NTSTATUS (*Function)(PVOID Reference1, PVOID Reference2),
    PVOID Reference1,
    PVOID Reference2
)
{
    this->Function = Function;
    this->Reference1 = Reference1;
    this->Reference2 = Reference2;
}

NTSTATUS
CQueueWorkListData::QueueAsyncList(
)
{
    NTSTATUS ntStatus = STATUS_SUCCESS;

    ExInterlockedInsertTailList(
      &glehQueueWorkList,
      &leNext,
      &gSpinLockQueueWorkList);

    // Schedule the workitem, if it is not already running.
    // 
    if(InterlockedIncrement(&gcQueueWorkList) == 1) {
        ntStatus = KsQueueWorkItem(gWorkerObject, &gWorkItem);
    }

    return ntStatus;
}

VOID
CQueueWorkListData::AsyncWorker(
    IN OUT PVOID pReference
)
{
    PQUEUE_WORK_LIST_DATA pQueueWorkListData;
    PLIST_ENTRY ple;

    ::GrabMutex();

    while(
      (ple = ExInterlockedRemoveHeadList(
      &glehQueueWorkList,
      &gSpinLockQueueWorkList)) != NULL) {
        pQueueWorkListData =
          CONTAINING_RECORD(ple, QUEUE_WORK_LIST_DATA, leNext);

        Assert(pQueueWorkListData);
        (*pQueueWorkListData->Function)
          (pQueueWorkListData->Reference1,
           pQueueWorkListData->Reference2);

        delete pQueueWorkListData;

        if(InterlockedDecrement(&gcQueueWorkList) == 0) {
            break;
        }
    }
    ::ReleaseMutex();
}

NTSTATUS
QueueWorkList(
    NTSTATUS (*Function)(PVOID Reference1, PVOID Reference2),
    PVOID Reference1,
    PVOID Reference2
)
{
    NTSTATUS Status = STATUS_SUCCESS;

    PQUEUE_WORK_LIST_DATA pQueueWorkListData = new QUEUE_WORK_LIST_DATA(
       Function,
       Reference1,
       Reference2);

    if(pQueueWorkListData == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }

    Status = pQueueWorkListData->QueueAsyncList();
    
exit:
    return(Status);
}

VOID 
GetDefaultOrder(
    ULONG fulType,
    PULONG pulOrder
)
{
    if(fulType != 0) {
	if(*pulOrder == ORDER_NONE) {
	    if(fulType & FILTER_TYPE_ENDPOINT) {
		*pulOrder = ORDER_ENDPOINT;
		return;
	    }
	    if(fulType & FILTER_TYPE_VIRTUAL) {
		*pulOrder = ORDER_VIRTUAL;
		return;
	    }
	    if(fulType & FILTER_TYPE_GFX) {
		*pulOrder = ORDER_GFX;
		return;
	    }
	    if(fulType & FILTER_TYPE_INTERFACE_TRANSFORM) {
		*pulOrder = ORDER_INTERFACE_TRANSFORM;
		return;
	    }
	    if(fulType & FILTER_TYPE_AEC) {
		*pulOrder = ORDER_AEC;
		return;
	    }
	    if(fulType & FILTER_TYPE_MIC_ARRAY_PROCESSOR) {
		*pulOrder = ORDER_MIC_ARRAY_PROCESSOR;
		return;
	    }
	    if(fulType & FILTER_TYPE_SPLITTER) {
		*pulOrder = ORDER_SPLITTER;
		return;
	    }
	    if(fulType & FILTER_TYPE_MIXER) {
		*pulOrder = ORDER_MIXER;
		return;
	    }
	    if(fulType & FILTER_TYPE_SYNTHESIZER) {
		*pulOrder = ORDER_SYNTHESIZER;
		return;
	    }
	    if(fulType & FILTER_TYPE_DRM_DESCRAMBLE) {
		*pulOrder = ORDER_DRM_DESCRAMBLE;
		return;
	    }
	    if(fulType & FILTER_TYPE_DATA_TRANSFORM) {
		*pulOrder = ORDER_DATA_TRANSFORM;
		return;
	    }
	}
    }
}

//===========================================================================
// ISSUE-2001/03/06-alpers
// This is a temporary solution for GFX glitching problem.
// In BlackComb time-frame after the right fix is implemented, we should delete
// this definition and references to it.
// 
#define STATIC_KSPROPSETID_Frame\
    0xA60D8368L, 0x5324, 0x4893, 0xB0, 0x20, 0xC4, 0x31, 0xA5, 0x0B, 0xCB, 0xE3
DEFINE_GUIDSTRUCT("A60D8368-5324-4893-B020-C431A50BCBE3", KSPROPSETID_Frame);
#define KSPROPSETID_Frame DEFINE_GUIDNAMED(KSPROPSETID_Frame)

typedef enum {
    KSPROPERTY_FRAME_HOLDING
} KSPROPERTY_FRAME;
//===========================================================================

NTSTATUS
SetKsFrameHolding(
    PFILE_OBJECT pFileObject
)
{
    KSPROPERTY      Property;
    NTSTATUS        ntStatus;
    ULONG           ulBytesReturned;
    BOOL            fFrameEnable = TRUE;

    ASSERT(pFileObject);

    //
    // Form the IOCTL packet & send it down
    //
    Property.Set    = KSPROPSETID_Frame;
    Property.Id     = KSPROPERTY_FRAME_HOLDING;
    Property.Flags  = KSPROPERTY_TYPE_SET;

    DPF(60,"Sending KSPROPERTY_FRAME_HOLDING");

    //
    // We actually throw away the status we got back from the device.
    //
    ntStatus = KsSynchronousIoControlDevice(pFileObject,
                                            KernelMode,
                                            IOCTL_KS_PROPERTY,
                                            &Property,
                                            sizeof(Property),
                                            &fFrameEnable,
                                            sizeof(fFrameEnable),
                                            &ulBytesReturned);
    DPF1(60,"KSPROPERTY_FRAME_HOLDING %s", 
        (NT_SUCCESS(ntStatus)) ? "Succeeded" : "Failed");

    return ntStatus;
} // SetKsFrameHolding

//---------------------------------------------------------------------------

#pragma LOCKED_CODE

//
//  Zero initializes the block.
//

void * __cdecl operator new( size_t size )
{
    PVOID p;
    ASSERT(size != 0);
    ASSERT(size < 0x10000);

#if defined(USE_ZONES) || defined(DEBUG)
    size += sizeof(ULONGLONG);
#endif

#ifdef MEMORY_LIST
    size += sizeof(LIST_ENTRY);
#endif

#ifdef USE_ZONES
    if(size <= SMALL_BLOCK_SIZE) {
        if(ExIsFullZone(&gZone)) {
            p = ExAllocatePoolWithTag(PagedPool, 4096, POOLTAG_SYSA);     // SYSA
            if(p != NULL) {
                if(!NT_SUCCESS(ExExtendZone(&gZone, p, 4096))) {
                    Trap();
                    ExFreePool(p);
                    DPF(5, "ExExtendZone FAILED");
                    return(NULL);
                }
            }
        }
        p = ExAllocateFromZone(&gZone);
    }
    else {
        p = ExAllocatePoolWithTag(PagedPool, size, POOLTAG_SYSA);		// SYSA
    }
#else
    p = ExAllocatePoolWithTag(PagedPool, size, POOLTAG_SYSA);		// SYSA
#endif
    if(p != NULL) {
	RtlZeroMemory(p, size);

    #if defined(USE_ZONES) || defined(DEBUG)
	*((PULONG)p) = size;
	p = ((PULONGLONG)p) + 1;
    #endif

    #ifdef MEMORY_LIST
	ExInterlockedInsertTailList(
	  &gleMemoryHead,
	  ((PLIST_ENTRY)p),
	  &gSpinLockMemoryHead);
	p = ((PLIST_ENTRY)p) + 1;
    #endif

    #ifdef DEBUG
	cbMemoryUsage += size;
	++cAllocMem;
	if(size <= SMALL_BLOCK_SIZE) {
	    ++cAllocMemSmall;
	}
	else if(size <= 64) {
	    ++cAllocMem64;
	}
	else if(size <= 128) {
	    ++cAllocMem128;
	}
    #endif
    }
    AssertAligned(p);
    return(p);
}

//
// Frees memory
//

void __cdecl operator delete( void *p )
{
    if(p != NULL) {

    #ifdef MEMORY_LIST
	KIRQL OldIrql;
	p = ((PLIST_ENTRY)p) - 1;
	KeAcquireSpinLock(&gSpinLockMemoryHead, &OldIrql);
	RemoveEntryList((PLIST_ENTRY)p);
	KeReleaseSpinLock(&gSpinLockMemoryHead, OldIrql);
    #endif

    #if defined(USE_ZONES) || defined(DEBUG)
	ULONG size;
 	AssertAligned(p);
	p = ((PULONGLONG)p) - 1;
	size = *((PULONG)p);
    #endif

    #ifdef DEBUG
	cbMemoryUsage -= size;
	--cAllocMem;
	if(size <= SMALL_BLOCK_SIZE) {
	    --cAllocMemSmall;
	}
	else if(size <= 64) {
	    --cAllocMem64;
	}
	else if(size <= 128) {
	    --cAllocMem128;
	}
    #endif

    #ifdef USE_ZONES
	if(size <= SMALL_BLOCK_SIZE) {
	    ExFreeToZone(&gZone, p);
	}
	else {
	    ExFreePool(p);
	}
    #else
	ExFreePool(p);
    #endif
    }
}

#pragma PAGEABLE_CODE

//---------------------------------------------------------------------------

#ifdef DEBUG

VOID
DumpPinConnect(
    LONG Level,
    PKSPIN_CONNECT pPinConnect
)
{
    DPF1(Level, "    PinId: %d", pPinConnect->PinId);
    DPF1(Level, "Interface: %s", DbgIdentifier2Sz(&pPinConnect->Interface));
    DPF1(Level, "   Medium: %s", DbgIdentifier2Sz(&pPinConnect->Medium));
    DumpDataFormat(Level, ((PKSDATAFORMAT)(pPinConnect + 1)));
}

VOID
DumpDataFormat(
    LONG Level,
    PKSDATAFORMAT pDataFormat
)
{
    DPF2(Level, 
      " FormatSize: %02x Flags: %08x", 
      pDataFormat->FormatSize,
      pDataFormat->Flags);
    DPF2(Level, 
      " SampleSize: %02x Reserved: %08x", 
      pDataFormat->SampleSize,
      pDataFormat->Reserved);
    DPF1(Level, "MajorFormat: %s", DbgGuid2Sz(&pDataFormat->MajorFormat));
    DPF1(Level, "  SubFormat: %s", DbgGuid2Sz(&pDataFormat->SubFormat));
    DPF1(Level, "  Specifier: %s", DbgGuid2Sz(&pDataFormat->Specifier));

    if(IsEqualGUID(
      &KSDATAFORMAT_SPECIFIER_WAVEFORMATEX,
      &pDataFormat->Specifier)) {

        DumpWaveFormatEx(
	  Level,
	  "WaveFmtEx",
          &((PKSDATAFORMAT_WAVEFORMATEX)pDataFormat)->WaveFormatEx);
    }
    if(IsEqualGUID(
      &KSDATAFORMAT_SPECIFIER_DSOUND,
      &pDataFormat->Specifier)) {

        DumpWaveFormatEx(
	  Level,
	  "DSOUND",
	  &((PKSDATAFORMAT_DSOUND)pDataFormat)->BufferDesc.WaveFormatEx);
    }
}

VOID
DumpWaveFormatEx(
    LONG Level,
    PSZ pszSpecifier,
    WAVEFORMATEX *pWaveFormatEx
)
{
    DPF8(Level, "%s T %u SR %u CH %u BPS %u ABPS %u BA %u cb %u",
      pszSpecifier,
      pWaveFormatEx->wFormatTag,
      pWaveFormatEx->nSamplesPerSec,
      pWaveFormatEx->nChannels,
      pWaveFormatEx->wBitsPerSample,
      pWaveFormatEx->nAvgBytesPerSec,
      pWaveFormatEx->nBlockAlign,
      pWaveFormatEx->cbSize);

    if(pWaveFormatEx->wFormatTag == WAVE_FORMAT_EXTENSIBLE) {
	DPF3(Level, "VBPS %u CHMASK %08x %s",
	  ((PWAVEFORMATEXTENSIBLE)pWaveFormatEx)->Samples.wValidBitsPerSample,
	  ((PWAVEFORMATEXTENSIBLE)pWaveFormatEx)->dwChannelMask,
	  DbgGuid2Sz(&((PWAVEFORMATEXTENSIBLE)pWaveFormatEx)->SubFormat));
    }
}

VOID
DumpDataRange(
    LONG Level,
    PKSDATARANGE_AUDIO pDataRangeAudio
)
{
    DPF2(Level,
      " FormatSize: %02x Flags: %08x", 
      pDataRangeAudio->DataRange.FormatSize,
      pDataRangeAudio->DataRange.Flags);
    DPF2(Level,
      " SampleSize: %02x Reserved: %08x", 
      pDataRangeAudio->DataRange.SampleSize,
      pDataRangeAudio->DataRange.Reserved);
    DPF1(Level, "MajorFormat: %s",
      DbgGuid2Sz(&pDataRangeAudio->DataRange.MajorFormat));
    DPF1(Level, "  SubFormat: %s",
      DbgGuid2Sz(&pDataRangeAudio->DataRange.SubFormat));
    DPF1(Level, "  Specifier: %s",
      DbgGuid2Sz(&pDataRangeAudio->DataRange.Specifier));

    if(IsEqualGUID(
      &KSDATAFORMAT_SPECIFIER_WAVEFORMATEX,
      &pDataRangeAudio->DataRange.Specifier)) {

	DPF5(Level, "WaveFmtEx: MaxCH %d MaxSR %u MinSR %u MaxBPS %u MinBPS %u",
          pDataRangeAudio->MaximumChannels,
          pDataRangeAudio->MinimumSampleFrequency,
          pDataRangeAudio->MaximumSampleFrequency,
          pDataRangeAudio->MinimumBitsPerSample,
          pDataRangeAudio->MaximumBitsPerSample);
    }

    if(IsEqualGUID(
      &KSDATAFORMAT_SPECIFIER_DSOUND,
      &pDataRangeAudio->DataRange.Specifier)) {

	DPF5(Level, "DSOUND:    MaxCH %d MaxSR %u MinSR %u MaxBPS %u MinBPS %u",
          pDataRangeAudio->MaximumChannels,
          pDataRangeAudio->MinimumSampleFrequency,
          pDataRangeAudio->MaximumSampleFrequency,
          pDataRangeAudio->MinimumBitsPerSample,
          pDataRangeAudio->MaximumBitsPerSample);

    }
}

PSZ
DbgUnicode2Sz(
    PWSTR pwstr
)
{
    static char sz[256];
    UNICODE_STRING UnicodeString;
    ANSI_STRING AnsiString;

    sz[0] = '\0';
    if(pwstr != NULL) {
        RtlInitUnicodeString(&UnicodeString, pwstr);
        RtlInitAnsiString(&AnsiString, sz);
        AnsiString.MaximumLength = sizeof(sz);
        RtlUnicodeStringToAnsiString(&AnsiString, &UnicodeString, FALSE);
    }
    return(sz);
}

PSZ
DbgIdentifier2Sz(
    PKSIDENTIFIER pIdentifier
)
{
    static char sz[256];

    sz[0] = '\0';
    if(pIdentifier != NULL && pIdentifier != INTERNAL_WILDCARD) {
        if(IsEqualGUID(
          &KSMEDIUMSETID_Standard,
          &pIdentifier->Set) &&
          (pIdentifier->Id == KSMEDIUM_STANDARD_DEVIO)) {
            return("KSMEDIUM_STANDARD_DEVIO");
        }
        if(IsEqualGUID(
          &KSINTERFACESETID_Standard,
          &pIdentifier->Set)) {
            switch(pIdentifier->Id) {
                case KSINTERFACE_STANDARD_STREAMING:
                    return("KSINTERFACE_STANDARD_STREAMING");
                case KSINTERFACE_STANDARD_LOOPED_STREAMING:
                    return("KSINTERFACE_STANDARD_LOOPED_STREAMING");
                case KSINTERFACE_STANDARD_CONTROL:
                    return("KSINTERFACE_STANDARD_CONTROL");
            }
        }
        if(IsEqualGUID(
          &KSINTERFACESETID_Media,
          &pIdentifier->Set)) {
            switch(pIdentifier->Id) {
                case KSINTERFACE_MEDIA_MUSIC:
                    return("KSINTERFACE_MEDIA_MUSIC");
                case KSINTERFACE_MEDIA_WAVE_BUFFERED:
                    return("KSINTERFACE_MEDIA_WAVE_BUFFERED");
                case KSINTERFACE_MEDIA_WAVE_QUEUED:
                    return("KSINTERFACE_MEDIA_WAVE_QUEUED");
            }
        }
        if(IsEqualGUID(
          &KSPROPSETID_Pin,
          &pIdentifier->Set)) {
            switch(pIdentifier->Id) {
                case KSPROPERTY_PIN_CINSTANCES:
                    return("KSPROPERTY_PIN_CINSTANCES");
                case KSPROPERTY_PIN_CTYPES:
                    return("KSPROPERTY_PIN_CTYPES");
                case KSPROPERTY_PIN_DATAFLOW:
                    return("KSPROPERTY_PIN_DATAFLOW");
                case KSPROPERTY_PIN_DATARANGES:
                    return("KSPROPERTY_PIN_DATARANGES");
                case KSPROPERTY_PIN_DATAINTERSECTION:
                    return("KSPROPERTY_PIN_DATAINTERSECTION");
                case KSPROPERTY_PIN_INTERFACES:
                    return("KSPROPERTY_PIN_INTERFACES");
                case KSPROPERTY_PIN_MEDIUMS:
                    return("KSPROPERTY_PIN_MEDIUMS");
                case KSPROPERTY_PIN_COMMUNICATION:
                    return("KSPROPERTY_PIN_COMMUNICATION");
                case KSPROPERTY_PIN_GLOBALCINSTANCES:
                    return("KSPROPERTY_PIN_GLOBALCINSTANCES");
                case KSPROPERTY_PIN_NECESSARYINSTANCES:
                    return("KSPROPERTY_PIN_NECESSARYINSTANCES");
                case KSPROPERTY_PIN_PHYSICALCONNECTION:
                    return("KSPROPERTY_PIN_PHYSICALCONNECTION");
                case KSPROPERTY_PIN_CATEGORY:
                    return("KSPROPERTY_PIN_CATEGORY");
                case KSPROPERTY_PIN_NAME:
                    return("KSPROPERTY_PIN_NAME");
                case KSPROPERTY_PIN_CONSTRAINEDDATARANGES:
                    return("KSPROPERTY_PIN_CONSTRAINEDDATARANGES");
            }
        }
        if(IsEqualGUID(
          &KSPROPSETID_Connection,
          &pIdentifier->Set)) {
            switch(pIdentifier->Id) {
                case KSPROPERTY_CONNECTION_STATE:
                    return("KSPROPERTY_CONNECTION_STATE");
                case KSPROPERTY_CONNECTION_PRIORITY:
                    return("KSPROPERTY_CONNECTION_PRIORITY");
                case KSPROPERTY_CONNECTION_DATAFORMAT:
                    return("KSPROPERTY_CONNECTION_DATAFORMAT");
                case KSPROPERTY_CONNECTION_ALLOCATORFRAMING:
                    return("KSPROPERTY_CONNECTION_ALLOCATORFRAMING");
                case KSPROPERTY_CONNECTION_PROPOSEDATAFORMAT:
                    return("KSPROPERTY_CONNECTION_PROPOSEDATAFORMAT");
                case KSPROPERTY_CONNECTION_ACQUIREORDERING:
                    return("KSPROPERTY_CONNECTION_ACQUIREORDERING");
                case KSPROPERTY_CONNECTION_ALLOCATORFRAMING_EX:
                    return("KSPROPERTY_CONNECTION_ALLOCATORFRAMING_EX");
            }
        }
        if(IsEqualGUID(
          &KSPROPSETID_Stream,
          &pIdentifier->Set)) {
            switch(pIdentifier->Id) {
                case KSPROPERTY_STREAM_ALLOCATOR:
                    return("KSPROPERTY_STREAM_ALLOCATOR");
                case KSPROPERTY_STREAM_MASTERCLOCK:
                    return("KSPROPERTY_STREAM_MASTERCLOCK");
            }
            sprintf(sz, "KSPROPSETID_Stream Id: %02x", pIdentifier->Id);
            return(sz);
        }
        if(IsEqualGUID(
          &KSPROPSETID_Clock,
          &pIdentifier->Set)) {
            sprintf(sz, "KSPROPSETID_Clock Id: %02x", pIdentifier->Id);
            return(sz);
        }
        if(IsEqualGUID(
          &KSPROPSETID_StreamAllocator,
          &pIdentifier->Set)) {
            sprintf(sz, "KSPROPSETID_StreamAllocator Id: %02x",
              pIdentifier->Id);
            return(sz);
        }
        if(IsEqualGUID(
          &KSPROPSETID_StreamInterface,
          &pIdentifier->Set)) {
            sprintf(sz, "KSPROPSETID_StreamInterface Id: %02x",
              pIdentifier->Id);
            return(sz);
        }
        if(IsEqualGUID(
          &KSPROPSETID_Topology,
          &pIdentifier->Set)) {
            switch(pIdentifier->Id) {
                case KSPROPERTY_TOPOLOGY_CATEGORIES:
                    return("KSPROPERTY_TOPOLOGY_CATEGORIES");
                case KSPROPERTY_TOPOLOGY_NODES:
                    return("KSPROPERTY_TOPOLOGY_NODES");
                case KSPROPERTY_TOPOLOGY_CONNECTIONS:
                    return("KSPROPERTY_TOPOLOGY_CONNECTIONS");
                case KSPROPERTY_TOPOLOGY_NAME:
                    return("KSPROPERTY_TOPOLOGY_NAME");
                default:
                    sprintf(sz, "KSPROPSETID_Topology Id: %02x",
                      pIdentifier->Id);
                    return(sz);
            }
        }
        if(IsEqualGUID(
          &KSPROPSETID_Audio,
          &pIdentifier->Set)) {
            switch(pIdentifier->Id) {
                case KSPROPERTY_AUDIO_VOLUMELEVEL:
                    return("KSPROPERTY_AUDIO_VOLUMELEVEL");
                case KSPROPERTY_AUDIO_MUTE:
                    return("KSPROPERTY_AUDIO_MUTE");
                case KSPROPERTY_AUDIO_MIX_LEVEL_TABLE:
                    return("KSPROPERTY_AUDIO_MIX_LEVEL_TABLE");
                case KSPROPERTY_AUDIO_MIX_LEVEL_CAPS:
                    return("KSPROPERTY_AUDIO_MIX_LEVEL_CAPS");
                case KSPROPERTY_AUDIO_MUX_SOURCE:
                    return("KSPROPERTY_AUDIO_MUX_SOURCE");
                case KSPROPERTY_AUDIO_BASS:
                    return("KSPROPERTY_AUDIO_BASS");
                case KSPROPERTY_AUDIO_MID:
                    return("KSPROPERTY_AUDIO_MID");
                case KSPROPERTY_AUDIO_TREBLE:
                    return("KSPROPERTY_AUDIO_TREBLE");
                case KSPROPERTY_AUDIO_BASS_BOOST:
                    return("KSPROPERTY_AUDIO_BASS_BOOST");
                case KSPROPERTY_AUDIO_AGC:
                    return("KSPROPERTY_AUDIO_AGC");
                default:
                    sprintf(sz, "KSPROPSETID_Audio Id: %02x", pIdentifier->Id);
                    return(sz);
            }
        }
        if(IsEqualGUID(
          &KSPROPSETID_Sysaudio,
          &pIdentifier->Set)) {
            switch(pIdentifier->Id) {
                case KSPROPERTY_SYSAUDIO_DEVICE_COUNT:
                    return("KSPROPERTY_SYSAUDIO_DEVICE_COUNT");
                case KSPROPERTY_SYSAUDIO_DEVICE_FRIENDLY_NAME:
                    return("KSPROPERTY_SYSAUDIO_DEVICE_FRIENDLY_NAME");
                case KSPROPERTY_SYSAUDIO_DEVICE_INSTANCE:
                    return("KSPROPERTY_SYSAUDIO_DEVICE_INSTANCE");
                case KSPROPERTY_SYSAUDIO_DEVICE_INTERFACE_NAME:
                    return("KSPROPERTY_SYSAUDIO_DEVICE_INTERFACE_NAME");
                case KSPROPERTY_SYSAUDIO_SELECT_GRAPH:
                    return("KSPROPERTY_SYSAUDIO_SELECT_GRAPH");
                case KSPROPERTY_SYSAUDIO_CREATE_VIRTUAL_SOURCE:
                    return("KSPROPERTY_SYSAUDIO_CREATE_VIRTUAL_SOURCE");
                case KSPROPERTY_SYSAUDIO_DEVICE_DEFAULT:
                    return("KSPROPERTY_SYSAUDIO_DEVICE_DEFAULT");
                case KSPROPERTY_SYSAUDIO_ALWAYS_CREATE_VIRTUAL_SOURCE:
                    return("KSPROPERTY_SYSAUDIO_ALWAYS_CREATE_VIRTUAL_SOURCE");
                case KSPROPERTY_SYSAUDIO_ADDREMOVE_LOCK:
                    return("KSPROPERTY_SYSAUDIO_ADDREMOVE_LOCK");
                case KSPROPERTY_SYSAUDIO_ADDREMOVE_UNLOCK:
                    return("KSPROPERTY_SYSAUDIO_ADDREMOVE_UNLOCK");
                case KSPROPERTY_SYSAUDIO_RENDER_PIN_INSTANCES:
                    return("KSPROPERTY_SYSAUDIO_RENDER_PIN_INSTANCES");
                case KSPROPERTY_SYSAUDIO_RENDER_CONNECTION_INDEX:
                    return("KSPROPERTY_SYSAUDIO_RENDER_CONNECTION_INDEX");
                default:
                    sprintf(sz, "KSPROPSETID_Sysaudio Id: %02x",
                      pIdentifier->Id);
                    return(sz);
            }
        }
        if(IsEqualGUID(
          &KSEVENTSETID_Connection,
          &pIdentifier->Set)) {
            switch(pIdentifier->Id) {
                case KSEVENT_CONNECTION_POSITIONUPDATE:
                    return("KSEVENT_CONNECTION_POSITIONUPDATE");
                case KSEVENT_CONNECTION_DATADISCONTINUITY:
                    return("KSEVENT_CONNECTION_DATADISCONTINUITY");
                case KSEVENT_CONNECTION_TIMEDISCONTINUITY:
                    return("KSEVENT_CONNECTION_TIMEDISCONTINUITY");
                case KSEVENT_CONNECTION_PRIORITY:
                    return("KSEVENT_CONNECTION_PRIORITY");
                case KSEVENT_CONNECTION_ENDOFSTREAM:
                    return("KSEVENT_CONNECTION_ENDOFSTREAM");
            }
        }
        if(IsEqualGUID(
          &KSEVENTSETID_Clock,
          &pIdentifier->Set)) {
            switch(pIdentifier->Id) {
                case KSEVENT_CLOCK_INTERVAL_MARK:
                    return("KSEVENT_CLOCK_INTERVAL_MARK");
                case KSEVENT_CLOCK_POSITION_MARK:
                    return("KSEVENT_CLOCK_POSITION_MARK");
            }
        }
        if(IsEqualGUID(
          &GUID_NULL,
          &pIdentifier->Set)) {
            sprintf(sz, "GUID_NULL Id: %02x", pIdentifier->Id);
            return(sz);
        }
        sprintf(sz, "Set: %s Id: %02x",
          DbgGuid2Sz(&pIdentifier->Set),
          pIdentifier->Id);
    }
    else {
        sprintf(sz, "%08x", (ULONG_PTR)pIdentifier);
    }
    return(sz);
}

PSZ
DbgGuid2Sz(
    GUID *pGuid
)
{
    static char sz[256];
    if(pGuid == NULL) {
        return("NO GUID");
    }
    if(IsEqualGUID(
      &GUID_NULL,
      pGuid)) {
        return("GUID_NULL");
    }
    if(IsEqualGUID(
      &KSDATAFORMAT_TYPE_AUDIO,
      pGuid)) {
        return("KSDATAFORMAT_TYPE_AUDIO");
    }
    if(IsEqualGUID(
      &KSDATAFORMAT_SUBTYPE_ANALOG,
      pGuid)) {
        return("KSDATAFORMAT_SUBTYPE_ANALOG");
    }
    if(IsEqualGUID(
      &KSDATAFORMAT_SUBTYPE_PCM,
      pGuid)) {
        return("KSDATAFORMAT_SUBTYPE_PCM");
    }
    if(IsEqualGUID(
      &KSDATAFORMAT_SUBTYPE_IEEE_FLOAT,
      pGuid)) {
        return("KSDATAFORMAT_SUBTYPE_IEEE_FLOAT");
    }
    if(IsEqualGUID(
      &KSDATAFORMAT_TYPE_MUSIC,
      pGuid)) {
        return("KSDATAFORMAT_TYPE_MUSIC");
    }
    if(IsEqualGUID(
      &KSDATAFORMAT_SUBTYPE_MIDI,
      pGuid)) {
        return("KSDATAFORMAT_SUBTYPE_MIDI");
    }
    if(IsEqualGUID(
      &KSDATAFORMAT_SUBTYPE_MIDI_BUS,
      pGuid)) {
        return("KSDATAFORMAT_SUBTYPE_MIDI_BUS");
    }
    if(IsEqualGUID(
      &KSDATAFORMAT_SPECIFIER_DSOUND,
      pGuid)) {
        return("KSDATAFORMAT_SPECIFIER_DSOUND");
    }
    if(IsEqualGUID(
      &KSDATAFORMAT_SPECIFIER_WAVEFORMATEX,
      pGuid)) {
        return("KSDATAFORMAT_SPECIFIER_WAVEFORMATEX");
    }
    if(IsEqualGUID(
      &KSDATAFORMAT_SPECIFIER_NONE,
      pGuid)) {
        return("KSDATAFORMAT_SPECIFIER_NONE");
    }
    if(IsEqualGUID(
      &KSCATEGORY_AUDIO,
      pGuid)) {
        return("KSCATEGORY_AUDIO");
    }
    if(IsEqualGUID(
      &KSNODETYPE_SPEAKER,
      pGuid)) {
        return("KSNODETYPE_SPEAKER");
    }
    if(IsEqualGUID(
      &KSNODETYPE_MICROPHONE,
      pGuid)) {
        return("KSNODETYPE_MICROPHONE");
    }
    if(IsEqualGUID(
      &KSNODETYPE_CD_PLAYER,
      pGuid)) {
        return("KSNODETYPE_CD_PLAYER");
    }
    if(IsEqualGUID(
      &KSNODETYPE_LEGACY_AUDIO_CONNECTOR,
      pGuid)) {
        return("KSNODETYPE_LEGACY_AUDIO_CONNECTOR");
    }
    if(IsEqualGUID(
      &KSNODETYPE_ANALOG_CONNECTOR,
      pGuid)) {
        return("KSNODETYPE_ANALOG_CONNECTOR");
    }
    if(IsEqualGUID(
      &KSCATEGORY_WDMAUD_USE_PIN_NAME,
      pGuid)) {
        return("KSCATEGORY_WDMAUD_USE_PIN_NAME");
    }
    if(IsEqualGUID(
      &KSNODETYPE_LINE_CONNECTOR,
      pGuid)) {
        return("KSNODETYPE_LINE_CONNECTOR");
    }
    if(IsEqualGUID(
      &GUID_TARGET_DEVICE_QUERY_REMOVE,
      pGuid)) {
        return("GUID_TARGET_DEVICE_QUERY_REMOVE");
    }
    if(IsEqualGUID(
      &GUID_TARGET_DEVICE_REMOVE_CANCELLED,
      pGuid)) {
        return("GUID_TARGET_DEVICE_REMOVE_CANCELLED");
    }
    if(IsEqualGUID(
      &GUID_TARGET_DEVICE_REMOVE_COMPLETE,
      pGuid)) {
        return("GUID_TARGET_DEVICE_REMOVE_COMPLETE");
    }
    if(IsEqualGUID(
      &PINNAME_CAPTURE,
      pGuid)) {
        return("PINNAME_CAPTURE");
    }
    if(IsEqualGUID(&KSNODETYPE_DAC, pGuid)) {
	return("KSNODETYPE_DAC");
    }
    if(IsEqualGUID(&KSNODETYPE_ADC, pGuid)) {
	return("KSNODETYPE_ADC");
    }
    if(IsEqualGUID(&KSNODETYPE_SRC, pGuid)) {
	return("KSNODETYPE_SRC");
    }
    if(IsEqualGUID(&KSNODETYPE_SUPERMIX, pGuid)) {
	return("KSNODETYPE_SUPERMIX");
    }
    if(IsEqualGUID( &KSNODETYPE_MUX, pGuid)) {
	return("KSNODETYPE_MUX");
    }
    if(IsEqualGUID( &KSNODETYPE_DEMUX, pGuid)) {
	return("KSNODETYPE_DEMUX");
    }
    if(IsEqualGUID(&KSNODETYPE_SUM, pGuid)) {
	return("KSNODETYPE_SUM");
    }
    if(IsEqualGUID(&KSNODETYPE_MUTE, pGuid)) {
	return("KSNODETYPE_MUTE");
    }
    if(IsEqualGUID(&KSNODETYPE_VOLUME, pGuid)) {
	return("KSNODETYPE_VOLUME");
    }
    if(IsEqualGUID(&KSNODETYPE_TONE, pGuid)) {
	return("KSNODETYPE_TONE");
    }
    if(IsEqualGUID(&KSNODETYPE_AGC, pGuid)) {
	return("KSNODETYPE_AGC");
    }
    if(IsEqualGUID(&KSNODETYPE_SYNTHESIZER, pGuid)) {
	return("KSNODETYPE_SYNTHESIZER");
    }
    if(IsEqualGUID(&KSNODETYPE_SWSYNTH, pGuid)) {
	return("KSNODETYPE_SWSYNTH");
    }
    if(IsEqualGUID(&KSNODETYPE_3D_EFFECTS, pGuid)) {
	return("KSNODETYPE_3D_EFFECTS");
    }
    sprintf(sz, "%08x %04x %04x %02x%02x%02x%02x%02x%02x%02x%02x",
      pGuid->Data1,
      pGuid->Data2,
      pGuid->Data3,
      pGuid->Data4[0],
      pGuid->Data4[1],
      pGuid->Data4[2],
      pGuid->Data4[3],
      pGuid->Data4[4],
      pGuid->Data4[5],
      pGuid->Data4[6],
      pGuid->Data4[7]);

    return(sz);
}

#endif  // DEBUG

//---------------------------------------------------------------------------
//  End of File: util.c
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\sysaudio\validate.h ===
//---------------------------------------------------------------------------
//
//  Module:   validate.h
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Alper Selcuk
//
//  History:   Date       Author      Comment
//             02/28/02   AlperS      Created
//
//  To Do:     Date       Author      Comment
//
//@@END_MSINTERNAL
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 2002-2002 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#ifndef _VALIDATE_H_
#define _VALIDATE_H_

//---------------------------------------------------------------------------
// Local prototypes
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Validation Routines

NTSTATUS
ValidateAudioDataFormats(
    PKSDATAFORMAT pDataFormat
);

NTSTATUS
ValidateDataFormat(
    PKSDATAFORMAT pDataFormat
);

NTSTATUS 
ValidateDeviceIoControl(
    PIRP pIrp
);

BOOL
IsSysaudioIoctlCode(
    ULONG IoControlCode
);

NTSTATUS 
SadValidateConnectionState(
    IN PIRP pIrp,
    IN PKSPROPERTY pProperty,
    IN OUT PKSSTATE pState
);

NTSTATUS
SadValidateAudioQuality(
    IN PIRP pIrp,
    IN PKSPROPERTY pProperty,
    IN PLONG pQuality
);

NTSTATUS
SadValidateAudioMixLevelCaps(
    IN PIRP pIrp,
    IN PKSPROPERTY pProperty,
    IN OUT PVOID pVoid
);

NTSTATUS
SadValidateAudioStereoEnhance(
    IN PIRP pIrp,
    IN PKSPROPERTY pProperty,
    IN PKSAUDIO_STEREO_ENHANCE pStereoEnhance
);

NTSTATUS
SadValidateAudioPreferredStatus(
    IN PIRP pIrp,
    IN PKSPROPERTY pProperty,
    IN PKSAUDIO_PREFERRED_STATUS pPreferredStatus
);

NTSTATUS
SadValidateDataFormat(
    IN PIRP pIrp,
    IN PKSPROPERTY pProperty,
    PKSDATAFORMAT pDataFormat
);

NTSTATUS 
SadValidateDataIntersection(
    IN PIRP pIrp,
    IN PKSP_PIN pPin
);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\sysaudio\virtual.h ===
//---------------------------------------------------------------------------
//
//  Module:   virtual.h
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Local prototypes
//---------------------------------------------------------------------------

NTSTATUS
CreateVirtualMixer(
    PDEVICE_NODE pDeviceNode
);

NTSTATUS
CreateVirtualLine(
    PDEVICE_NODE pDeviceNode,
    PFILTER_NODE pFilterNode,
    PTOPOLOGY_NODE pTopologyNodeSum,
    PLOGICAL_FILTER_NODE pLogicalFilterNode,
    PVIRTUAL_SOURCE_LINE pVirtualSourceLine
);

//---------------------------------------------------------------------------

NTSTATUS VirtualizeTopology(
    PDEVICE_NODE pDeviceNode,
    PFILTER_NODE pFilterNode
);

//---------------------------------------------------------------------------

NTSTATUS
CreateVirtualSource(
    IN PIRP pIrp,
    PSYSAUDIO_CREATE_VIRTUAL_SOURCE pCreateVirtualSource,
    OUT PULONG	pulMixerPinId
);

NTSTATUS
AttachVirtualSource(
    IN PIRP pIrp,
    IN PSYSAUDIO_ATTACH_VIRTUAL_SOURCE pAttachVirtualSource,
    IN OUT PVOID pData
);

NTSTATUS
FilterVirtualPropertySupportHandler(
    IN PIRP pIrp,
    IN PKSNODEPROPERTY pNodeProperty,
    IN OUT PVOID pData
);

NTSTATUS
FilterVirtualPropertyHandler(
    IN PIRP pIrp,
    IN PKSNODEPROPERTY pNodeProperty,
    IN OUT PLONG plLevel
);

NTSTATUS
PinVirtualPropertySupportHandler(
    IN PIRP pIrp,
    IN PKSNODEPROPERTY pNodeProperty,
    IN OUT PVOID pData
);

NTSTATUS
PinVirtualPropertyHandler(
    IN PIRP pIrp,
    IN PKSNODEPROPERTY_AUDIO_CHANNEL pNodePropertyAudioChannel,
    IN OUT PLONG plLevel
);

NTSTATUS
GetControlRange(
    PVIRTUAL_NODE_DATA pVirtualNodeData
);

NTSTATUS
QueryPropertyRange(
    PFILE_OBJECT pFileObject,
    CONST GUID *pguidPropertySet,
    ULONG ulPropertyId,
    ULONG ulNodeId,
    PKSPROPERTY_DESCRIPTION *ppPropertyDescription
);

NTSTATUS
SetVirtualVolume(
    PVIRTUAL_NODE_DATA pVirtualNodeData,
    LONG Channel
);

NTSTATUS
SetPhysicalVolume(
    PGRAPH_NODE_INSTANCE pGraphNodeInstance,
    PVIRTUAL_SOURCE_DATA pVirtualSourceData,
    LONG Channel
);

LONG
MapVirtualLevel(
    PVIRTUAL_NODE_DATA pVirtualNodeData,
    LONG lLevel
);

NTSTATUS
GetVolumeNodeNumber(
    PPIN_INSTANCE pPinInstance,
    PVIRTUAL_SOURCE_DATA pVirtualSourceData OPTIONAL
);

NTSTATUS
GetSuperMixCaps(
    OUT PKSAUDIO_MIXCAP_TABLE pAudioMixCapTable,
    IN PSTART_NODE_INSTANCE pStartNodeInstance,
    IN ULONG NodeId
);

//---------------------------------------------------------------------------
//  End of File: virtual.h
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\sysaudio\validate.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   validate.cpp
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Alper Selcuk
//
//  History:   Date       Author      Comment
//             02/28/02   AlperS      Created
//
//  To Do:     Date       Author      Comment
//
//@@END_MSINTERNAL
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 2002-2002 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"

DEFINE_KSPROPERTY_TABLE(AudioPropertyValidationHandlers) 
{
    DEFINE_KSPROPERTY_ITEM(
        KSPROPERTY_AUDIO_QUALITY,                       // idProperty
        NULL,                                           // pfnGetHandler
        sizeof(KSPROPERTY),                             // cbMinGetPropertyInput
        sizeof(ULONG),                                  // cbMinGetDataInput
        SadValidateAudioQuality,                        // pfnSetHandler
        NULL,                                           // Values
        0,                                              // RelationsCount
        NULL,                                           // Relations
        NULL,                                           // SupportHandler
        0                                               // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM(
        KSPROPERTY_AUDIO_MIX_LEVEL_CAPS,                // idProperty
        NULL,                                           // pfnGetHandler
        sizeof(KSPROPERTY),                             // cbMinGetPropertyInput
        sizeof(ULONG) + sizeof(ULONG),                  // cbMinGetDataInput
        SadValidateAudioMixLevelCaps,                   // pfnSetHandler
        NULL,                                           // Values
        0,                                              // RelationsCount
        NULL,                                           // Relations
        NULL,                                           // SupportHandler
        0                                               // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM(
        KSPROPERTY_AUDIO_STEREO_ENHANCE,                // idProperty
        NULL,                                           // pfnGetHandler
        sizeof(KSPROPERTY),                             // cbMinGetPropertyInput
        sizeof(KSAUDIO_STEREO_ENHANCE),                 // cbMinGetDataInput
        SadValidateAudioStereoEnhance,                  // pfnSetHandler
        NULL,                                           // Values
        0,                                              // RelationsCount
        NULL,                                           // Relations
        NULL,                                           // SupportHandler
        0                                               // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM(
        KSPROPERTY_AUDIO_PREFERRED_STATUS,              // idProperty
        NULL,                                           // pfnGetHandler
        sizeof(KSPROPERTY),                             // cbMinGetPropertyInput
        sizeof(KSAUDIO_PREFERRED_STATUS),               // cbMinGetDataInput
        SadValidateAudioPreferredStatus,                // pfnSetHandler
        NULL,                                           // Values
        0,                                              // RelationsCount
        NULL,                                           // Relations
        NULL,                                           // SupportHandler
        0                                               // SerializedSize
    )
};

DEFINE_KSPROPERTY_TABLE(PinConnectionValidationHandlers) 
{
    DEFINE_KSPROPERTY_ITEM(
        KSPROPERTY_CONNECTION_STATE,                    // idProperty
        NULL,                                           // pfnGetHandler
        sizeof(KSPROPERTY),                             // cbMinGetPropertyInput
        sizeof(ULONG),                                  // cbMinGetDataInput
        SadValidateConnectionState,                     // pfnSetHandler
        NULL,                                           // Values
        0,                                              // RelationsCount
        NULL,                                           // Relations
        NULL,                                           // SupportHandler
        0                                               // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM(
        KSPROPERTY_CONNECTION_DATAFORMAT,               // idProperty
        SadValidateDataFormat,                          // pfnGetHandler
        sizeof(KSPROPERTY),                             // cbMinGetPropertyInput
        sizeof(KSDATAFORMAT_WAVEFORMATEX),              // cbMinGetDataInput
        SadValidateDataFormat,                          // pfnSetHandler
        NULL,                                           // Values
        0,                                              // RelationsCount
        NULL,                                           // Relations
        NULL,                                           // SupportHandler
        0                                               // SerializedSize
    )
};


DEFINE_KSPROPERTY_SET_TABLE(ValidationPropertySet)
{
     DEFINE_KSPROPERTY_SET(
       &KSPROPSETID_Audio,                              // Set
       SIZEOF_ARRAY(AudioPropertyValidationHandlers),   // PropertiesCount
       AudioPropertyValidationHandlers,                 // PropertyItem
       0,                                               // FastIoCount
       NULL                                             // FastIoTable
    ),
    DEFINE_KSPROPERTY_SET(
       &KSPROPSETID_Connection,                         // Set
       SIZEOF_ARRAY(PinConnectionValidationHandlers),   // PropertiesCount
       PinConnectionValidationHandlers,                 // PropertyItem
       0,                                               // FastIoCount
       NULL                                             // FastIoTable
    )
};


//===========================================================================
//
// Validates the integrity of KSDATAFORMAT structure for AUDIO.
// Assumptions:
//     - pDataFormat is totally trusted. It has been probed and buffered
//     properly.
//     - This function should only be called if MajorFormat is AUDIO.
//
NTSTATUS
ValidateAudioDataFormats(
    PKSDATAFORMAT pDataFormat
)
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    ULONG cbAudioFormat;
    PWAVEFORMATEX pWaveFormatEx;

    ASSERT(pDataFormat);
    ASSERT(IsEqualGUID(&pDataFormat->MajorFormat, &KSDATAFORMAT_TYPE_AUDIO));

    //
    // We only support two specifiers in audio land. All the rest will be 
    // accepted without further checks, because we don't know how to validate
    // them.
    //
    pWaveFormatEx = GetWaveFormatExFromKsDataFormat(pDataFormat, &cbAudioFormat);
    if (NULL == pWaveFormatEx) {
        DPF(5, "ValidataAudioDataFormats : invalid format specifier");
        ntStatus = STATUS_SUCCESS;
        goto exit;
    }

    //
    // Make sure that we have enough space for the actual format packet.
    // Note that this will make sure we can at least touch the WAVEFORMATEX 
    // part.
    //
    if (pDataFormat->FormatSize < cbAudioFormat)
    {
        DPF(10, "ValidataAudioDataFormats : format size does not match specifier");
        ntStatus = STATUS_INVALID_PARAMETER;
        goto exit;
    }

    //
    // Check to see if WAVEFORMATEXTENSIBLE size is specified correctly.
    //
    if ((WAVE_FORMAT_EXTENSIBLE == pWaveFormatEx->wFormatTag) &&
        (pWaveFormatEx->cbSize < sizeof(WAVEFORMATEXTENSIBLE) - sizeof(WAVEFORMATEX))) 
    {
        DPF1(4, "ValidataAudioDataFormats : WAVEFORMATEXTENSIBLE size does not match %d", pWaveFormatEx->cbSize);
        ntStatus = STATUS_INVALID_PARAMETER;
        goto exit;
    }

    //
    // Now that WaveFormatEx is guaranteed to be safe, check if we have extended
    // information in WAVEFORMATEX.
    // cbSize specifies the size of the extension structure. 
    // Validate that FormatSize accomodates cbSize
    // Validate that cbSize does not cause an overflow.
    //
    if (pDataFormat->FormatSize < cbAudioFormat + pWaveFormatEx->cbSize ||
        cbAudioFormat + pWaveFormatEx->cbSize < cbAudioFormat)
    {
        DPF1(10, "ValidataAudioDataFormats : format size does not match waveformatex.cbSize %d", pWaveFormatEx->cbSize);
        ntStatus = STATUS_INVALID_PARAMETER;
        goto exit;
    }

    //
    // Now we validated that the data buffer passed to us actually matches
    // with its specifier.
    //
    
exit:        
    return ntStatus;
} // ValidateAudioDataFormats

//===========================================================================
//
// Validates the integrity of KSDATAFORMAT structure. 
// Calls ValidateAudioDataFormat if MajorFormat is audio.
// Or checks the buffers size if Specifier is NONE.
// Assumptions:
//     - pDataFormat is totally trusted. It has been probed and buffered
//     properly.
//
NTSTATUS
ValidateDataFormat(
    PKSDATAFORMAT pDataFormat
)
{
    NTSTATUS ntStatus = STATUS_SUCCESS;

    ASSERT(pDataFormat);

    if (IsEqualGUID(&pDataFormat->MajorFormat, &KSDATAFORMAT_TYPE_AUDIO))
    {
        ntStatus = ValidateAudioDataFormats(pDataFormat);
    }

    return ntStatus;
} // ValidateDataFormat

//===========================================================================
// 
// ValidateDeviceIoControl
//
// Probe Ioctl parameters by calling KS functions.
// All the KS functions called here first probe the input and output buffers
// and then copy them to Irp->SystemBuffer for further safe usage.
// Calling these functions with NULL parameter basically means probe and copy
// the buffers and return.
//
NTSTATUS 
ValidateDeviceIoControl(
    PIRP pIrp
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION pIrpStack;

    ASSERT(pIrp);

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);

    switch (pIrpStack->Parameters.DeviceIoControl.IoControlCode) 
    {
        case IOCTL_KS_PROPERTY:
            Status = KsPropertyHandler(
                pIrp, 
                SIZEOF_ARRAY(ValidationPropertySet), 
                ValidationPropertySet);
            break;

        case IOCTL_KS_ENABLE_EVENT:
            Status = KsEnableEvent(pIrp, 0, NULL, NULL, KSEVENTS_NONE, NULL);
            break;

        case IOCTL_KS_METHOD:
            Status = KsMethodHandler(pIrp, 0, NULL);
            break;

        //
        // IOCTL_KS_DISABLE_EVENT
        // KsDisableEvent does not use and touch input parameters.
        // So input buffer validation is not necessary.
        //

        //
        // IOCTL_KS_RESET_STATE
        // The reset request only takes a ULONG. KsAcquireResetValue safely
        // extracts the RESET value from the IRP. 
        // Sysaudio cannot do any validation here, because KsAcquireResetValue
        // works on Input buffer directly.
        //
        
        //
        // IOCTL_KS_WRITE_STREAM
        // IOCTL_KS_READ_STREAM
        // We are not doing any validation on these.
        //
        default:
            Status = STATUS_NOT_FOUND;
    }

    //
    // If there is no validation function ValidationPropertySet, Ks
    // will return one of these. Even in this case buffers must have
    // been probed and copied to kernel.
    // 
    if (Status == STATUS_NOT_FOUND || Status == STATUS_PROPSET_NOT_FOUND) 
    {
        Status = STATUS_SUCCESS;
    }

    if (!NT_SUCCESS(Status))
    {
        DPF1(5, "Rejected DeviceIOCTL - %X", pIrpStack->Parameters.DeviceIoControl.IoControlCode);
    }

    return Status;
} // ValidateDeviceIoControl

//===========================================================================
// 
// Return TRUE if sysaudio is interested in handling this IoControlCode
// Otherwise return FALSE.
// 
BOOL
IsSysaudioIoctlCode(
    ULONG IoControlCode
)
{
    if (IOCTL_KS_PROPERTY == IoControlCode ||
        IOCTL_KS_ENABLE_EVENT == IoControlCode ||
        IOCTL_KS_DISABLE_EVENT == IoControlCode ||
        IOCTL_KS_METHOD == IoControlCode)
    {
        return TRUE;
    }

    return FALSE;
} // IsSysaudioIoctlCode

//===========================================================================
//
// SadValidateConnectionState
// Check that the KSSTATE is valid.
//
NTSTATUS 
SadValidateConnectionState(
    IN PIRP pIrp,
    IN PKSPROPERTY pProperty,
    IN PKSSTATE pState
)
{
    ASSERT(pState);
    
    if (KSSTATE_STOP <= *pState &&
        KSSTATE_RUN >= *pState)
    {
        return STATUS_SUCCESS;
    }

    DPF1(5, "SadValidateConnectionState: Invalid State %d", *pState);
    return STATUS_INVALID_PARAMETER;
} // SadValidateConnectionState

//===========================================================================
//
// SadValidateDataFormat
// Checks whether the given format is valid.
//
NTSTATUS
SadValidateDataFormat(
    IN PIRP pIrp,
    IN PKSPROPERTY pProperty,
    PKSDATAFORMAT pDataFormat
)
{
    ASSERT(pDataFormat);

    return ValidateDataFormat(pDataFormat);
} // SadValidateDataFormat

//===========================================================================
//
// SadValidateAudioQuality
// Checks if the quality is valid.
//
NTSTATUS
SadValidateAudioQuality(
    IN PIRP pIrp,
    IN PKSPROPERTY pProperty,
    IN PLONG pQuality
)
{
    ASSERT(pQuality);

    if (KSAUDIO_QUALITY_WORST <= *pQuality &&
        KSAUDIO_QUALITY_ADVANCED >= *pQuality)
    {
        return STATUS_SUCCESS;
    }

    DPF1(5, "SadValidateAudioQuality: Invalid Quality %d", *pQuality);
    return STATUS_INVALID_PARAMETER;
} // SadValidateAudioQuality

//===========================================================================
//
// SadValidateAudioQuality
// Checks if the structure is valid.
//
NTSTATUS
SadValidateAudioMixLevelCaps(
    IN PIRP pIrp,
    IN PKSPROPERTY pProperty,
    IN OUT PVOID pVoid
)
{
    ASSERT(pVoid);
    ASSERT(pIrp->AssociatedIrp.SystemBuffer);

    PKSAUDIO_MIXCAP_TABLE pMixTable;
    PIO_STACK_LOCATION pIrpStack;
    ULONG ulTotalChannels;
    ULONG cbRequiredSize;
    
    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
    pMixTable = (PKSAUDIO_MIXCAP_TABLE) pVoid;

    if (pMixTable->InputChannels > 10000 ||
        pMixTable->OutputChannels > 10000)
    {
        DPF2(5, "SadValidateAudioMixLevelCaps: Huge Channel numbers %d %d", pMixTable->InputChannels, pMixTable->OutputChannels);
        return STATUS_INVALID_PARAMETER;
    }

    ulTotalChannels = pMixTable->InputChannels + pMixTable->OutputChannels;
    if (ulTotalChannels)
    {
        cbRequiredSize = 
            sizeof(KSAUDIO_MIXCAP_TABLE) + ulTotalChannels * sizeof(KSAUDIO_MIX_CAPS);
        if (cbRequiredSize < 
            pIrpStack->Parameters.DeviceIoControl.InputBufferLength)
        {
            DPF1(5, "SadValidateAudioMixLevelCaps: Buffer too small %d", 
                pIrpStack->Parameters.DeviceIoControl.InputBufferLength);
            return STATUS_BUFFER_TOO_SMALL;
        }
    }
    
    return STATUS_SUCCESS;
} // SadValidateAudioMixLevelCaps

//===========================================================================
//
// SadValidateAudioQuality
// Checks if the Technique is valid.
//
NTSTATUS
SadValidateAudioStereoEnhance(
    IN PIRP pIrp,
    IN PKSPROPERTY pProperty,
    IN PKSAUDIO_STEREO_ENHANCE pStereoEnhance
)
{
    ASSERT(pStereoEnhance);

    if (SE_TECH_NONE <= pStereoEnhance->Technique &&
        SE_TECH_VLSI_TECH >= pStereoEnhance->Technique)
    {
        return STATUS_SUCCESS;
    }

    DPF1(5, "SadValidateAudioStereoEnhance: Invalid Technique %d", pStereoEnhance->Technique);
    return STATUS_INVALID_PARAMETER;
} // SadValidateAudioStereoEnhance

//===========================================================================
//
// SadValidateAudioQuality
// Checks if the quality is valid.
//
NTSTATUS
SadValidateAudioPreferredStatus(
    IN PIRP pIrp,
    IN PKSPROPERTY pProperty,
    IN PKSAUDIO_PREFERRED_STATUS pPreferredStatus
)
{
    ASSERT(pPreferredStatus);

    if (KSPROPERTY_SYSAUDIO_NORMAL_DEFAULT <= pPreferredStatus->DeviceType &&
        KSPROPERTY_SYSAUDIO_MIXER_DEFAULT >= pPreferredStatus->DeviceType)
    {
        return STATUS_SUCCESS;
    }

    DPF1(5, "SadValidateAudioPreferredStatus: Invalid DeviceType %d", pPreferredStatus->DeviceType);
    return STATUS_INVALID_PARAMETER;
} // SadValidateAudioPreferredStatus

//===========================================================================
//
// SadValidateDataIntersection
// Checks the integrity of dataranges following pPin.
//
NTSTATUS 
SadValidateDataIntersection(
    IN PIRP pIrp,
    IN PKSP_PIN pPin
)
{
    PIO_STACK_LOCATION pIrpStack;
    PKSMULTIPLE_ITEM pKsMultipleItem;
    PKSDATARANGE pKsDataRange;
    ULONG cbTotal;

    ASSERT(pIrp);
    ASSERT(pPin);

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
    pKsMultipleItem = (PKSMULTIPLE_ITEM) (pPin + 1);
    pKsDataRange = (PKSDATARANGE) (pKsMultipleItem + 1);
    cbTotal = pKsMultipleItem->Size - sizeof(KSMULTIPLE_ITEM);

    //
    // Make sure that the Irp Input Size is valid. Basically 
    // InputBufferLength must be greater or equal to 
    // KSP_PIN + MULTIPLE_ITEM.Size
    //
    if (pIrpStack->Parameters.DeviceIoControl.InputBufferLength - sizeof(KSP_PIN) <
        pKsMultipleItem->Size)
    {
        DPF(5, "SadValidateDataIntersection: InputBuffer too small");
        return STATUS_INVALID_BUFFER_SIZE;
    }

    //
    // Make sure that the MULTIPLE_ITEM contains at least one DATARANGE.
    //
    if (cbTotal < sizeof(KSDATARANGE))
    {
        DPF(5, "SadValidateDataIntersection: Not enough data for datarange");
        return STATUS_INVALID_BUFFER_SIZE;
    }

    for (ULONG ii = 0; ii < pKsMultipleItem->Count; ii++)
    {
        //
        // Check if we can touch the FormatSize field.
        // Check if we the next data-range is fully available.
        //
        if (cbTotal < sizeof(ULONG) ||
            cbTotal < pKsDataRange->FormatSize || 
            pKsDataRange->FormatSize < sizeof(KSDATARANGE))
        {
            DPF3(5, "SadValidateDataIntersection: Not enough data for datarange %d %d %d", ii, pKsDataRange->FormatSize, cbTotal);
            return STATUS_INVALID_BUFFER_SIZE;
        }

        //
        // Check if the MajorFormat and size are consistent.
        // 
        if (IsEqualGUID(&pKsDataRange->MajorFormat, &KSDATAFORMAT_TYPE_AUDIO))
        {
            if (pKsDataRange->FormatSize < sizeof(KSDATARANGE_AUDIO)) 
            {
                DPF(5, "SadValidateDataIntersection: InputBuffer too small for AUDIO");
                return STATUS_INVALID_BUFFER_SIZE;
            }
        }

        //
        // Set next data range.
        //
        cbTotal -= pKsDataRange->FormatSize;
        pKsDataRange = (PKSDATARANGE) ( ((PBYTE) pKsDataRange) + pKsDataRange->FormatSize );
    }

    //
    // SECURITY NOTE:
    // We are not checking the output buffer integrity. The underlying drivers
    // are responsible for checking the size of the output buffer, based on
    // the result of the intersection.
    //

    return STATUS_SUCCESS;
} // SadValidateDataIntersection
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\sysaudio\vnd.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   vnd.cpp
//
//  Description:
//
//	Virtual Node Data Class
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//  To Do:     Date	  Author      Comment
//
//@@END_MSINTERNAL
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

CVirtualNodeData::CVirtualNodeData(
    PSTART_NODE_INSTANCE pStartNodeInstance,
    PVIRTUAL_SOURCE_DATA pVirtualSourceData
)
{
    pStartNodeInstance->pVirtualNodeData = this;
    this->pVirtualSourceData = pVirtualSourceData;
    this->pStartNodeInstance = pStartNodeInstance;
    AddList(&pVirtualSourceData->lstVirtualNodeData);
}
    
CVirtualNodeData::~CVirtualNodeData(
)
{
    Assert(this); 
    RemoveList();
    ASSERT(pStartNodeInstance->pVirtualNodeData == this);
    pStartNodeInstance->pVirtualNodeData = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\sysaudio\virtual.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   virtual.c
//
//  Description:
//     Virtual Source Stuff
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Andy Nicholson
//
//  History:   Date       Author      Comment
//
//  To Do:     Date       Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"

//---------------------------------------------------------------------------

// Virtual Source Data

KSDATARANGE DataRangeWildCard =
{
    sizeof(KSDATARANGE),
    0,
    0,
    0,
    STATICGUIDOF(KSDATAFORMAT_TYPE_AUDIO),
    STATICGUIDOF(KSDATAFORMAT_SUBTYPE_PCM),
    STATICGUIDOF(KSDATAFORMAT_SPECIFIER_WILDCARD),
};

KSPIN_MEDIUM VirtualPinMedium =
{
    STATICGUIDOF(KSMEDIUMSETID_Standard),
    KSMEDIUM_STANDARD_DEVIO
};

KSDATARANGE VirtualPinDataRange =
{
    sizeof(KSDATARANGE),
    0,
    0,
    0,
    STATICGUIDOF(KSDATAFORMAT_TYPE_AUDIO),
    STATICGUIDOF(KSDATAFORMAT_SUBTYPE_ANALOG),
    STATICGUIDOF(KSDATAFORMAT_SPECIFIER_NONE),
};

//---------------------------------------------------------------------------

NTSTATUS
CreateVirtualMixer(
    PDEVICE_NODE pDeviceNode
)
{
    PTOPOLOGY_CONNECTION pTopologyConnection;
    PVIRTUAL_SOURCE_LINE pVirtualSourceLine;
    PLOGICAL_FILTER_NODE pLogicalFilterNode;
    PTOPOLOGY_PIN pTopologyPinSumOutput;
    PTOPOLOGY_NODE pTopologyNodeSum;
    NTSTATUS Status = STATUS_SUCCESS;
    PFILTER_NODE pFilterNode;
    PPIN_INFO pPinInfo;
    PPIN_NODE pPinNode;

    //
    // Create a special "virtual source" filter node and related structures
    //

    pFilterNode = new FILTER_NODE(FILTER_TYPE_AUDIO | FILTER_TYPE_VIRTUAL);
    if(pFilterNode == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        Trap();
        goto exit;
    }
    pFilterNode->SetFriendlyName(L"Virtual Mixer");

    Status = pFilterNode->AddDeviceInterfaceMatch(
      pDeviceNode->GetDeviceInterface());

    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }

    //
    // Create the logical filter node for this "virtual" filter
    //

    Status = CLogicalFilterNode::Create(&pLogicalFilterNode, pFilterNode);
    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }
    Status = CTopologyNode::Create(
      &pTopologyNodeSum,
      pFilterNode,
      MAXULONG,
      (GUID *)&KSNODETYPE_SUM);

    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }
    pTopologyNodeSum->iVirtualSource = 0;

    Status = pLogicalFilterNode->lstTopologyNode.AddList(pTopologyNodeSum);
    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }
    Status = pLogicalFilterNode->AddList(
      &pTopologyNodeSum->lstLogicalFilterNode);

    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }

    Status = CTopologyPin::Create(
      &pTopologyPinSumOutput,
      0,				// 0 output
      pTopologyNodeSum);

    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }

    //
    // Create a virtual sysaudio source pin
    //

    pPinInfo = new PIN_INFO(pFilterNode, 0);
    if(pPinInfo == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        Trap();
        goto exit;
    }

    pPinInfo->DataFlow = KSPIN_DATAFLOW_OUT;
    pPinInfo->Communication = KSPIN_COMMUNICATION_SOURCE;
    pPinInfo->cPinInstances.PossibleCount = MAXULONG;
    pFilterNode->cPins++;

    pPinNode = new PIN_NODE(pPinInfo);
    if(pPinNode == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        Trap();
        goto exit;
    }
    pPinNode->pMedium = INTERNAL_WILDCARD;
    pPinNode->pInterface = INTERNAL_WILDCARD;
    pPinNode->pDataRange = &DataRangeWildCard;

    Status = pLogicalFilterNode->lstPinNode.AddList(pPinNode);
    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }
    pPinNode->pLogicalFilterNode = pLogicalFilterNode;

    //
    // Connect the out of sum node to the source pin
    //

    Status = CTopologyConnection::Create(
      &pTopologyConnection,
      pFilterNode,			// pFilterNode
      NULL,				// pGraphNode
      pTopologyPinSumOutput,		// pTopologyPin From
      NULL,				// pTopologyPin To
      NULL,				// pPinInfo From
      pPinInfo);			// pPinInfo To

    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }

    Status = pTopologyConnection->AddList(
      &pLogicalFilterNode->lstTopologyConnection);

    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }

    FOR_EACH_LIST_ITEM(gplstVirtualSourceLine, pVirtualSourceLine) {

        ASSERT(pVirtualSourceLine->iVirtualSource < 
          pDeviceNode->cVirtualSourceData);

        if(pDeviceNode->papVirtualSourceData[
          pVirtualSourceLine->iVirtualSource]->pTopologyNode != NULL) {
            continue;
        }

        Status = CreateVirtualLine(
          pDeviceNode,
          pFilterNode,
          pTopologyNodeSum,
          pLogicalFilterNode,
          pVirtualSourceLine);

        if(!NT_SUCCESS(Status)) {
            Trap();
            goto exit;
        }

    } END_EACH_LIST_ITEM

    // if new virtual source lines were created
    if(pFilterNode->cPins > 1) {
        pDeviceNode->pFilterNodeVirtual = pFilterNode;
    }
    else {
        delete pFilterNode;
    }
exit:
    if(!NT_SUCCESS(Status)) {
        Trap();
        delete pFilterNode;
    }
    return(Status);
}

NTSTATUS
CreateVirtualLine(
    PDEVICE_NODE pDeviceNode,
    PFILTER_NODE pFilterNode,
    PTOPOLOGY_NODE pTopologyNodeSum,
    PLOGICAL_FILTER_NODE pLogicalFilterNode,
    PVIRTUAL_SOURCE_LINE pVirtualSourceLine
)
{
    PTOPOLOGY_CONNECTION pTopologyConnection;
    NTSTATUS Status = STATUS_SUCCESS;
    PTOPOLOGY_NODE pTopologyNode;
    PTOPOLOGY_PIN pTopologyPinSumInput;
    PTOPOLOGY_PIN pTopologyPinVolume;
    PTOPOLOGY_PIN pTopologyPinMute;
    PPIN_INFO pPinInfo;
    PPIN_NODE pPinNode;

    //
    // Create a virtual sysaudio pin
    //

    pPinInfo = new PIN_INFO(pFilterNode, pVirtualSourceLine->iVirtualSource+1);
    if(pPinInfo == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        Trap();
        goto exit;
    }
    pPinInfo->DataFlow = KSPIN_DATAFLOW_IN;
    pPinInfo->Communication = KSPIN_COMMUNICATION_NONE;
    pPinInfo->pguidCategory = &pVirtualSourceLine->guidCategory;
    pPinInfo->pguidName = &pVirtualSourceLine->guidName;
    pFilterNode->cPins++;

    pPinNode = new PIN_NODE(pPinInfo);
    if(pPinNode == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        Trap();
        goto exit;
    }
    pPinNode->pMedium = &VirtualPinMedium;
    pPinNode->pDataRange = &VirtualPinDataRange;

    Status = pLogicalFilterNode->lstPinNode.AddList(pPinNode);
    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }
    pPinNode->pLogicalFilterNode = pLogicalFilterNode;

    //
    // Create a virtual volume topology node and input topology pin
    //

    Status = CTopologyNode::Create(
      &pTopologyNode,
      pFilterNode,
      MAXULONG,
      (GUID *)&KSNODETYPE_VOLUME);

    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }
    pTopologyNode->iVirtualSource = pVirtualSourceLine->iVirtualSource;

    ASSERT(pVirtualSourceLine->iVirtualSource < 
      pDeviceNode->cVirtualSourceData);

    pDeviceNode->papVirtualSourceData[
      pVirtualSourceLine->iVirtualSource]->pTopologyNode = pTopologyNode;

    Status = pLogicalFilterNode->lstTopologyNode.AddList(pTopologyNode);
    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }
    Status = pLogicalFilterNode->AddList(&pTopologyNode->lstLogicalFilterNode);
    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }

    Status = CTopologyPin::Create(
      &pTopologyPinVolume,
      KSNODEPIN_STANDARD_IN,		// 1 = input
      pTopologyNode);

    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }

    //
    // Create a connection from virtual pin to volume node
    //

    Status = CTopologyConnection::Create(
      &pTopologyConnection,
      pFilterNode,			// pFilterNode
      NULL,				// pGraphNode
      NULL,				// pTopologyPin From
      pTopologyPinVolume,		// pTopologyPin To
      pPinInfo,				// pPinInfo From
      NULL);				// pPinInfo To

    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }

    Status = pTopologyConnection->AddList(
      &pLogicalFilterNode->lstTopologyConnection);

    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }

    Status = CTopologyPin::Create(
      &pTopologyPinVolume,
      KSNODEPIN_STANDARD_OUT,			// 0 = output
      pTopologyNode);

    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }

    //
    // Create a virtual mute topology node and input topology pin
    //

    Status = CTopologyNode::Create(
      &pTopologyNode,
      pFilterNode,
      MAXULONG,
      (GUID *)&KSNODETYPE_MUTE);

    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }
    pTopologyNode->iVirtualSource = pVirtualSourceLine->iVirtualSource;

    Status = pLogicalFilterNode->lstTopologyNode.AddList(pTopologyNode);
    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }
    Status = pLogicalFilterNode->AddList(&pTopologyNode->lstLogicalFilterNode);
    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }

    Status = CTopologyPin::Create(
      &pTopologyPinMute,
      KSNODEPIN_STANDARD_IN,		// 1 = input
      pTopologyNode);

    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }

    //
    // Create a connection from volume node to mute node pin
    //

    Status = CTopologyConnection::Create(
      &pTopologyConnection,
      pFilterNode,			// pFilterNode
      NULL,				// pGraphNode
      pTopologyPinVolume,		// pTopologyPin From
      pTopologyPinMute,			// pTopologyPin To
      NULL,				// pPinInfo From
      NULL);				// pPinInfo To

    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }
    Status = pTopologyConnection->AddList(
      &pLogicalFilterNode->lstTopologyConnection);

    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }

    Status = CTopologyPin::Create(
      &pTopologyPinMute,
      KSNODEPIN_STANDARD_OUT,			// 1 = output
      pTopologyNode);

    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }

    Status = CTopologyPin::Create(
      &pTopologyPinSumInput,
      pVirtualSourceLine->iVirtualSource + 1,	// >= 1 input
      pTopologyNodeSum);

    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }

    //
    // Create a connection from mute node to sum node pin
    //

    Status = CTopologyConnection::Create(
      &pTopologyConnection,
      pFilterNode,			// pFilterNode
      NULL,				// pGraphNode
      pTopologyPinMute,			// pTopologyPin From
      pTopologyPinSumInput,		// pTopologyPin To
      NULL,				// pPinInfo From
      NULL);				// pPinInfo To

    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }
    Status = pTopologyConnection->AddList(
      &pLogicalFilterNode->lstTopologyConnection);

    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }
exit:
    return(Status);
}

//---------------------------------------------------------------------------

ENUMFUNC
VirtualizeFindPin(
    IN PTOPOLOGY_CONNECTION pTopologyConnection,
    IN BOOL fToDirection,
    IN PVOID pReference
)
{
    NTSTATUS Status = STATUS_CONTINUE; 
    IN PPIN_INFO pPinInfo;

    Assert(pTopologyConnection);
    if(!IS_CONNECTION_TYPE(pTopologyConnection, FILTER)) {
        Status = STATUS_DEAD_END;
        goto exit;
    }

    if(fToDirection) {
       pPinInfo = pTopologyConnection->pPinInfoTo;
    }
    else {
       pPinInfo = pTopologyConnection->pPinInfoFrom;
    }

    if(pPinInfo == NULL) {
        ASSERT(Status == STATUS_CONTINUE);
        goto exit;
    }

    if(pPinInfo->pguidCategory == NULL) {
        ASSERT(Status == STATUS_CONTINUE);
        goto exit;
    }

    if(IsEqualGUID(pPinInfo->pguidCategory, &KSNODETYPE_SPEAKER)) {
        Status = STATUS_SUCCESS;
    }
exit:
    return(Status);
}

ENUMFUNC
EnumerateVirtualizeFindPin(
    IN PTOPOLOGY_CONNECTION pTopologyConnection,
    IN BOOL fToDirection
)
{
    ENUM_TOPOLOGY EnumTopology;
    NTSTATUS Status;

    Assert(pTopologyConnection);
    EnumTopology.cTopologyRecursion = 0;
    EnumTopology.Function = VirtualizeFindPin;
    EnumTopology.fToDirection = fToDirection;
    EnumTopology.pReference = NULL;
    Status = EnumerateTopologyConnection(pTopologyConnection, &EnumTopology);
    return(Status);
}

ENUMFUNC
VirtualizeFindNode(
    IN PTOPOLOGY_CONNECTION pTopologyConnection,
    IN BOOL fToDirection,
    OUT PTOPOLOGY_NODE *ppTopologyNode,
    IN GUID const *pguidType
)
{
    NTSTATUS Status = STATUS_CONTINUE; 
    PTOPOLOGY_PIN pTopologyPin;

    Assert(pTopologyConnection);
    if(!IS_CONNECTION_TYPE(pTopologyConnection, FILTER)) {
        Status = STATUS_DEAD_END;
        goto exit;
    }

    if(fToDirection) {
       pTopologyPin = pTopologyConnection->pTopologyPinTo;
    }
    else {
       pTopologyPin = pTopologyConnection->pTopologyPinFrom;
    }

    if(pTopologyPin == NULL) {
        ASSERT(Status == STATUS_CONTINUE);
        goto exit;
    }

    if(IsEqualGUID(pTopologyPin->pTopologyNode->pguidType, &KSNODETYPE_SUM)) {
        Status = STATUS_DEAD_END;
        goto exit;
    }

    if(IsEqualGUID(pTopologyPin->pTopologyNode->pguidType, &KSNODETYPE_MUX)) {
        Status = STATUS_DEAD_END;
        goto exit;
    }

    if(IsEqualGUID(pTopologyPin->pTopologyNode->pguidType, pguidType)) {

        Status = EnumerateVirtualizeFindPin(pTopologyConnection, fToDirection);
        if(NT_SUCCESS(Status)) {
            *ppTopologyNode = pTopologyPin->pTopologyNode;
        }
        ASSERT(Status != STATUS_DEAD_END);
    }
exit:
    return(Status);
}

ENUMFUNC
VirtualizeFindMute(
    IN PTOPOLOGY_CONNECTION pTopologyConnection,
    IN BOOL fToDirection,
    OUT PTOPOLOGY_NODE *ppTopologyNode
)
{
    return(VirtualizeFindNode(
      pTopologyConnection,
      fToDirection,
      ppTopologyNode, 
      &KSNODETYPE_MUTE));
}

ENUMFUNC
VirtualizeFindVolume(
    IN PTOPOLOGY_CONNECTION pTopologyConnection,
    IN BOOL fToDirection,
    OUT PTOPOLOGY_NODE *ppTopologyNode
)
{
    return(VirtualizeFindNode(
      pTopologyConnection,
      fToDirection,
      ppTopologyNode, 
      &KSNODETYPE_VOLUME));
}

VOID
VirtualizeTopologyNode(
    IN PDEVICE_NODE pDeviceNode,
    IN PTOPOLOGY_NODE pTopologyNode,
    IN PVIRTUAL_SOURCE_LINE pVirtualSourceLine
)
{
    DPF3(100, "VirtualizeTopologyNode: real node #%d index %d %s", 
      pTopologyNode->ulRealNodeNumber, 
      pVirtualSourceLine->iVirtualSource,
      DbgGuid2Sz(&pVirtualSourceLine->guidCategory));

    ASSERT(
      (pTopologyNode->iVirtualSource == MAXULONG) ||
      (pTopologyNode->iVirtualSource == pVirtualSourceLine->iVirtualSource));

    // The PinId of a virtual pininfo has VirtualSourceData index
    pTopologyNode->iVirtualSource = pVirtualSourceLine->iVirtualSource;

    if(pVirtualSourceLine->ulFlags & VSL_FLAGS_CREATE_ONLY) {
        pTopologyNode->ulFlags |= TN_FLAGS_DONT_FORWARD;
    }
    ASSERT(pTopologyNode->iVirtualSource < pDeviceNode->cVirtualSourceData);

    //
    // Store the topologyNode in virtualsource structures for further usage.
    //
    if(IsEqualGUID(pTopologyNode->pguidType, &KSNODETYPE_VOLUME)) {
        pDeviceNode->papVirtualSourceData[
          pTopologyNode->iVirtualSource]->pTopologyNode = pTopologyNode;
    }
}

NTSTATUS
AddVirtualMute(
    IN PDEVICE_NODE pDeviceNode,
    IN PTOPOLOGY_NODE pTopologyNodeVolume,
    IN PVIRTUAL_SOURCE_LINE pVirtualSourceLine
)
{
    PTOPOLOGY_CONNECTION pTopologyConnectionNew = NULL;
    PTOPOLOGY_CONNECTION pTopologyConnection = NULL;
    PTOPOLOGY_NODE pTopologyNodeMute = NULL;
    PTOPOLOGY_PIN pTopologyPinMuteInput = NULL;
    PTOPOLOGY_PIN pTopologyPinMuteOutput = NULL;
    PTOPOLOGY_PIN pTopologyPinVolumeOutput = NULL;
    PLOGICAL_FILTER_NODE pLogicalFilterNode;
    NTSTATUS Status;

    ASSERT(pTopologyNodeVolume->iVirtualSource != MAXULONG);

    FOR_EACH_LIST_ITEM(
      &pTopologyNodeVolume->lstTopologyPin,
      pTopologyPinVolumeOutput) {

        if(pTopologyPinVolumeOutput->ulPinNumber == KSNODEPIN_STANDARD_OUT) {
            break;
        }

    } END_EACH_LIST_ITEM

    if(pTopologyPinVolumeOutput == NULL) {
        Trap();
        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto exit;
    }
    ASSERT(pTopologyPinVolumeOutput->ulPinNumber == KSNODEPIN_STANDARD_OUT);

    FOR_EACH_LIST_ITEM(
      &pTopologyPinVolumeOutput->lstTopologyConnection,
      pTopologyConnection) {

        Assert(pTopologyConnection);
        if(EnumerateVirtualizeFindPin(
          pTopologyConnection,
          TRUE) == STATUS_SUCCESS) {	// Assumes KSPIN_DATAFLOW_IN
            break;
        }

    } END_EACH_LIST_ITEM

    if(pTopologyConnection == NULL) {
        Trap();
        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto exit;
    }
    ASSERT(pTopologyConnection->pTopologyPinFrom == pTopologyPinVolumeOutput);

    Status = CTopologyNode::Create(
      &pTopologyNodeMute,
      pTopologyNodeVolume->pFilterNode,
      MAXULONG,
      (GUID *)&KSNODETYPE_MUTE);

    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }
    VirtualizeTopologyNode(pDeviceNode, pTopologyNodeMute, pVirtualSourceLine);

    Status = CTopologyPin::Create(
      &pTopologyPinMuteInput,
      KSNODEPIN_STANDARD_IN,		// 1 = input
      pTopologyNodeMute);

    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }

    Status = CTopologyPin::Create(
      &pTopologyPinMuteOutput,
      KSNODEPIN_STANDARD_OUT,		// 0 = output
      pTopologyNodeMute);

    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }

    Status = CTopologyConnection::Create(
      &pTopologyConnectionNew,
      pTopologyNodeVolume->pFilterNode,	// pFilterNode
      NULL,				// pGraphNode
      pTopologyPinVolumeOutput,		// pTopologyPin From
      pTopologyPinMuteInput,		// pTopologyPin To
      NULL,				// pPinInfo From
      NULL);				// pPinInfo To

    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }

    Status = pTopologyConnection->AddList(
      &pTopologyPinMuteOutput->lstTopologyConnection);

    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }

    FOR_EACH_LIST_ITEM(
      &pTopologyNodeVolume->lstLogicalFilterNode,
      pLogicalFilterNode) {

        Status = pLogicalFilterNode->AddList(
          &pTopologyNodeMute->lstLogicalFilterNode);

        if(!NT_SUCCESS(Status)) {
            Trap();
            goto exit;
        }
        Status = pLogicalFilterNode->lstTopologyNode.AddList(pTopologyNodeMute);
        if(!NT_SUCCESS(Status)) {
            Trap();
            goto exit;
        }
        Status = pTopologyConnectionNew->AddList(
          &pLogicalFilterNode->lstTopologyConnection);

        if(!NT_SUCCESS(Status)) {
            Trap();
            goto exit;
        }

    } END_EACH_LIST_ITEM

    pTopologyConnection->pTopologyPinFrom = pTopologyPinMuteOutput;

    pTopologyConnection->RemoveList(
      &pTopologyPinVolumeOutput->lstTopologyConnection);
exit:
    if(!NT_SUCCESS(Status)) {
        Trap();
        if(pTopologyConnectionNew != NULL) {
            Trap();
            pTopologyConnectionNew->Destroy();
        }
        if(pTopologyNodeMute != NULL) {
            if(pTopologyNodeVolume != NULL) {
                Trap();
                pTopologyNodeMute->RemoveList(
                  &pTopologyNodeVolume->pFilterNode->lstTopologyNode);

                FOR_EACH_LIST_ITEM(
                  &pTopologyNodeVolume->lstLogicalFilterNode,
                  pLogicalFilterNode) {

                    pLogicalFilterNode->lstTopologyNode.RemoveList(
                      pTopologyNodeMute);

                } END_EACH_LIST_ITEM
            }
            pTopologyNodeMute->Destroy();
        }
    }
    return(Status);
}

NTSTATUS
VirtualizeTopology(
    PDEVICE_NODE pDeviceNode,
    PFILTER_NODE pFilterNode

)
{
    PVIRTUAL_SOURCE_LINE pVirtualSourceLine;
    PTOPOLOGY_NODE pTopologyNodeVolume;
    PTOPOLOGY_NODE pTopologyNodeMute;
    NTSTATUS Status = STATUS_SUCCESS;
    PPIN_INFO pPinInfo;

    FOR_EACH_LIST_ITEM(&pFilterNode->lstPinInfo, pPinInfo) {

        if(pPinInfo->pguidCategory == NULL) {
            continue;
        }
        FOR_EACH_LIST_ITEM(gplstVirtualSourceLine, pVirtualSourceLine) {

            if(pPinInfo->DataFlow != KSPIN_DATAFLOW_IN) {
                continue;
            }
            if(!IsEqualGUID(
              pPinInfo->pguidCategory,
              &pVirtualSourceLine->guidCategory)) {
                continue;
            }
            if(EnumerateTopology(
              pPinInfo,
              (TOP_PFN)VirtualizeFindVolume,
              &pTopologyNodeVolume) == STATUS_SUCCESS) {

                VirtualizeTopologyNode(
                  pDeviceNode,
                  pTopologyNodeVolume,
                  pVirtualSourceLine);

                if(EnumerateTopology(
                  pPinInfo,
                  (TOP_PFN)VirtualizeFindMute,
                  &pTopologyNodeMute) == STATUS_SUCCESS) {

                    VirtualizeTopologyNode(
                      pDeviceNode,
                      pTopologyNodeMute,
                      pVirtualSourceLine);
                }
                else {
                    Status = AddVirtualMute(
                      pDeviceNode,
                      pTopologyNodeVolume,
                      pVirtualSourceLine);

                    if(!NT_SUCCESS(Status)) {
                        Trap();
                        goto exit;
                    }
                }
            }

        } END_EACH_LIST_ITEM

    } END_EACH_LIST_ITEM
exit:
    return(Status);
}

//---------------------------------------------------------------------------

NTSTATUS
CreateVirtualSource(
    IN PIRP pIrp,
    PSYSAUDIO_CREATE_VIRTUAL_SOURCE pCreateVirtualSource,
    OUT PULONG  pulMixerPinId
)
{
    PVIRTUAL_SOURCE_LINE pVirtualSourceLine = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    PFILTER_INSTANCE pFilterInstance;
    PIO_STACK_LOCATION pIrpStack;
    PDEVICE_NODE pDeviceNode;

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
    pFilterInstance = (PFILTER_INSTANCE)pIrpStack->FileObject->FsContext;
    Assert(pFilterInstance);

    //
    // VirtualSources are not created if there is already an active pin 
    // instance on this filter.
    //
    if(!pFilterInstance->IsChildInstance()) {
        DPF(5, "CreateVirtualSource: FAILED - open pin instances");
        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto exit;
    }

    //
    // Make sure that this is not a duplicate.
    //
    FOR_EACH_LIST_ITEM(gplstVirtualSourceLine, pVirtualSourceLine) {

        if(!IsEqualGUID(
          &pVirtualSourceLine->guidCategory,
          &pCreateVirtualSource->PinCategory)) {
            continue;
        }
        if(!IsEqualGUID(
          &pVirtualSourceLine->guidName,
          &pCreateVirtualSource->PinName)) {
            continue;
        }
        ASSERT(NT_SUCCESS(Status));
        goto dup;

    } END_EACH_LIST_ITEM

    pVirtualSourceLine = new VIRTUAL_SOURCE_LINE(pCreateVirtualSource);
    if(pVirtualSourceLine == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        Trap();
        goto exit;
    }

    FOR_EACH_LIST_ITEM(gplstDeviceNode, pDeviceNode) {

        DPF2(60, "CreateVirtualSource: DN %08x %s",
          pDeviceNode,
          pDeviceNode->DumpName());

        Status = pDeviceNode->Update();
        if(!NT_SUCCESS(Status)) {
            Trap();
            goto exit;
        }

    } END_EACH_LIST_ITEM
dup:
    *pulMixerPinId = pVirtualSourceLine->iVirtualSource;
    pIrp->IoStatus.Information = sizeof(ULONG);
exit:
    if(!NT_SUCCESS(Status)) {
        delete pVirtualSourceLine;
    }
    return(Status);
}

NTSTATUS
AttachVirtualSource(
    IN PIRP pIrp,
    IN PSYSAUDIO_ATTACH_VIRTUAL_SOURCE pAttachVirtualSource,
    IN OUT PVOID pData
)
{
    PVIRTUAL_NODE_DATA pVirtualNodeData = NULL;
    PSTART_NODE_INSTANCE pStartNodeInstance;
    PVIRTUAL_SOURCE_DATA pVirtualSourceData;
    NTSTATUS Status = STATUS_SUCCESS;
    PPIN_INSTANCE pPinInstance;
    PDEVICE_NODE pDeviceNode;
    LONG Channel;

    Status = ::GetStartNodeInstance(pIrp, &pStartNodeInstance);
    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
    pPinInstance = pStartNodeInstance->pPinInstance;
    Assert(pPinInstance);
    Assert(pPinInstance->pFilterInstance);
    Assert(pPinInstance->pFilterInstance->pGraphNodeInstance);

    pDeviceNode = pPinInstance->pFilterInstance->GetDeviceNode();
    Assert(pDeviceNode);

    if(pAttachVirtualSource->MixerPinId >= pDeviceNode->cVirtualSourceData) {
        DPF(5, "AttachVirtualSource: invalid MixerPinId");
        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto exit;
    }
    ASSERT(pDeviceNode->papVirtualSourceData != NULL);
    pVirtualSourceData = 
      pDeviceNode->papVirtualSourceData[pAttachVirtualSource->MixerPinId];
    Assert(pVirtualSourceData);

    Status = GetVolumeNodeNumber(pPinInstance, pVirtualSourceData);
    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }
    if(pPinInstance->ulVolumeNodeNumber == MAXULONG) {
        ASSERT(NT_SUCCESS(Status));
        goto exit;
    }

    pVirtualNodeData = new VIRTUAL_NODE_DATA(
      pStartNodeInstance,
      pVirtualSourceData);

    if(pVirtualNodeData == NULL) {
        Trap();
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }

    if(pVirtualSourceData->pTopologyNode->ulRealNodeNumber != MAXULONG) {
        ULONG ulNodeNumber;

        //
        // Get the volume control range for the physical node
        //

        ulNodeNumber = pPinInstance->pFilterInstance->pGraphNodeInstance->
          paulNodeNumber[pAttachVirtualSource->MixerPinId];

        if(ulNodeNumber == pPinInstance->ulVolumeNodeNumber) {
            ASSERT(NT_SUCCESS(Status));
            delete pVirtualNodeData;
            goto exit;
        }

        Status = pStartNodeInstance->GetTopologyNodeFileObject(
            &pVirtualNodeData->pFileObject,
            ulNodeNumber);

        if(!NT_SUCCESS(Status)) {
            Trap();
            goto exit;
        }
        pVirtualNodeData->NodeId = 
          pVirtualSourceData->pTopologyNode->ulRealNodeNumber;

        Status = GetControlRange(pVirtualNodeData);
        if(!NT_SUCCESS(Status)) {
            goto exit;
        }
        pVirtualSourceData->MinimumValue = pVirtualNodeData->MinimumValue;
        pVirtualSourceData->MaximumValue = pVirtualNodeData->MaximumValue;
        pVirtualSourceData->Steps = pVirtualNodeData->Steps;
    }

    Status = pStartNodeInstance->GetTopologyNodeFileObject(
        &pVirtualNodeData->pFileObject,
        pPinInstance->ulVolumeNodeNumber);

    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }
    pVirtualNodeData->NodeId = pPinInstance->pFilterInstance->
      pGraphNodeInstance->papTopologyNode[pPinInstance->ulVolumeNodeNumber]->
      ulRealNodeNumber;

    Status = GetControlRange(pVirtualNodeData);
    if(!NT_SUCCESS(Status)) {
        goto exit;
    }

    for(Channel = 0; Channel < pVirtualSourceData->cChannels; Channel++) {
        Status = SetVirtualVolume(pVirtualNodeData, Channel);
        if(!NT_SUCCESS(Status)) {
            Trap();
            goto exit;
        }
    }
exit:
    if(!NT_SUCCESS(Status)) {
        delete pVirtualNodeData;
    }
    return(Status);
}

NTSTATUS
FilterVirtualPropertySupportHandler(
    IN PIRP pIrp,
    IN PKSNODEPROPERTY pNodeProperty,
    IN OUT PVOID pData
)
{
    PGRAPH_NODE_INSTANCE pGraphNodeInstance;
    PTOPOLOGY_NODE pTopologyNode;
    NTSTATUS Status;

    Status = GetGraphNodeInstance(pIrp, &pGraphNodeInstance);
    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
    Assert(pGraphNodeInstance);

    Status = STATUS_NOT_FOUND;
    if((pNodeProperty->Property.Flags & KSPROPERTY_TYPE_TOPOLOGY) == 0) {
        DPF(5, "FilterVirtualPropertySupportHandler: no TOPOLOGY bit");
        ASSERT(Status == STATUS_NOT_FOUND);
        goto exit;
    }
    if(pNodeProperty->NodeId >= 
      pGraphNodeInstance->Topology.TopologyNodesCount) {
        DPF(5, "FilterVirtualPropertySupportHandler: invalid node #");
        ASSERT(Status == STATUS_NOT_FOUND);
        goto exit;
    }
    pTopologyNode = pGraphNodeInstance->papTopologyNode[pNodeProperty->NodeId];
    Assert(pTopologyNode);

    if(pTopologyNode->ulRealNodeNumber == MAXULONG) {
        ASSERT(pTopologyNode->iVirtualSource != MAXULONG);
        Status = STATUS_SOME_NOT_MAPPED;
        goto exit;
    }
    ASSERT(Status == STATUS_NOT_FOUND);
exit:
    return(Status);
}

NTSTATUS
FilterVirtualPropertyHandler(
    IN PIRP pIrp,
    IN PKSNODEPROPERTY pNodeProperty,
    IN OUT PLONG plLevel
)
{
    PGRAPH_NODE_INSTANCE pGraphNodeInstance;
    PVIRTUAL_SOURCE_DATA pVirtualSourceData;
    PVIRTUAL_NODE_DATA pVirtualNodeData;
    PIO_STACK_LOCATION pIrpStack;
    PTOPOLOGY_NODE pTopologyNode;
    LONG StopChannel, Channel;
    NTSTATUS Status;

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
    Status = GetGraphNodeInstance(pIrp, &pGraphNodeInstance);
    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
    Assert(pGraphNodeInstance);

    if(((pNodeProperty->Property.Flags & KSPROPERTY_TYPE_TOPOLOGY) == 0) ||
      (pNodeProperty->NodeId >= 
       pGraphNodeInstance->Topology.TopologyNodesCount)) {
        DPF(5, "FilterVirtualPropertyHandler: invalid property");
        Status = STATUS_NOT_FOUND;
        goto exit;
    }
    pTopologyNode = pGraphNodeInstance->papTopologyNode[pNodeProperty->NodeId];

    Assert(pTopologyNode);
    if(pTopologyNode->iVirtualSource == MAXULONG) {
        Status = STATUS_NOT_FOUND;
        goto exit;
    }

    ASSERT(pTopologyNode->iVirtualSource < gcVirtualSources);
    ASSERT(pGraphNodeInstance->pGraphNode->pDeviceNode->
      papVirtualSourceData != NULL);

    pVirtualSourceData = pGraphNodeInstance->pGraphNode->pDeviceNode->
      papVirtualSourceData[pTopologyNode->iVirtualSource];

    Assert(pVirtualSourceData);

    //
    // ISSUE: 03/07/2002 These checks are totally irrelevant. 
    // KS would have never called this functions if these conditions
    // have not been met before.
    //
    if(pIrpStack->Parameters.DeviceIoControl.InputBufferLength < 
       sizeof(KSNODEPROPERTY_AUDIO_CHANNEL) ||
      (pNodeProperty->Property.Id != KSPROPERTY_AUDIO_VOLUMELEVEL &&
       pNodeProperty->Property.Id != KSPROPERTY_AUDIO_MUTE)) {
        Trap();
        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto exit;
    }

    Channel = ((PKSNODEPROPERTY_AUDIO_CHANNEL)pNodeProperty)->Channel;
    StopChannel = Channel;

    if(Channel == MAXULONG) {
        Channel = 0;
        StopChannel = pVirtualSourceData->cChannels - 1;
    }

    if(Channel >= MAX_NUM_CHANNELS || Channel < 0) {
        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto exit;
    }

    for(; Channel <= StopChannel; Channel++) {

        if(IsEqualGUID(pTopologyNode->pguidType, &KSNODETYPE_MUTE)) {

            if(pNodeProperty->Property.Flags & KSPROPERTY_TYPE_GET) {
              *plLevel = pVirtualSourceData->fMuted[Channel];
                pIrp->IoStatus.Information = sizeof(LONG);
            }
            else {
                ASSERT(pNodeProperty->Property.Flags & KSPROPERTY_TYPE_SET);
                pVirtualSourceData->fMuted[Channel] = *plLevel;

                if(pTopologyNode->ulRealNodeNumber == MAXULONG) {

                    Status = SetPhysicalVolume(
                      pGraphNodeInstance,
                      pVirtualSourceData,
                      Channel);

                    if(!NT_SUCCESS(Status)) {
                        Trap();
                        goto exit;
                    }
                }
            }
        }
        else if(IsEqualGUID(pTopologyNode->pguidType, &KSNODETYPE_VOLUME)) {

            if(pNodeProperty->Property.Flags & KSPROPERTY_TYPE_GET) {
                *plLevel = pVirtualSourceData->lLevel[Channel];
                pIrp->IoStatus.Information = sizeof(LONG);
            }
            else {
                ASSERT(pNodeProperty->Property.Flags & KSPROPERTY_TYPE_SET);
                pVirtualSourceData->lLevel[Channel] = *plLevel;
            }
        }
        else {
            DPF2(5, "Invalid TopologyNode Prop.Id %d Node.Id %d",
                pNodeProperty->Property.Id,
                pTopologyNode->ulRealNodeNumber);
            Status = STATUS_INVALID_DEVICE_REQUEST;
            goto exit;
        }
        ASSERT(NT_SUCCESS(Status));

        if(pNodeProperty->Property.Flags & KSPROPERTY_TYPE_SET) {

            FOR_EACH_LIST_ITEM(
              &pVirtualSourceData->lstVirtualNodeData,
              pVirtualNodeData) {

                ASSERT(pVirtualSourceData == 
                  pVirtualNodeData->pVirtualSourceData);

                Status = SetVirtualVolume(pVirtualNodeData, Channel);
                if(!NT_SUCCESS(Status)) {
                    Trap();
                    goto exit;
                }

            } END_EACH_LIST_ITEM
        }
    }

    if(pTopologyNode->ulRealNodeNumber == MAXULONG ||
       pTopologyNode->ulFlags & TN_FLAGS_DONT_FORWARD ||
       pNodeProperty->Property.Flags & KSPROPERTY_TYPE_GET) {
        Status = STATUS_SUCCESS;
    }
    else {
        // If topology node has a real node number, forward the irp to it
        Status = STATUS_NOT_FOUND;
    }
    
exit:
    return(Status);
}

NTSTATUS
PinVirtualPropertySupportHandler(
    IN PIRP pIrp,
    IN PKSNODEPROPERTY pNodeProperty,
    IN OUT PVOID pData
)
{
    return(STATUS_NOT_FOUND);
}

NTSTATUS
PinVirtualPropertyHandler(
    IN PIRP pIrp,
    IN PKSNODEPROPERTY_AUDIO_CHANNEL pNodePropertyAudioChannel,
    IN OUT PLONG plLevel
)
{
    PSTART_NODE_INSTANCE pStartNodeInstance;
    PFILTER_INSTANCE pFilterInstance;
    NTSTATUS Status = STATUS_SUCCESS;
    PKSNODEPROPERTY pNodeProperty;
    PPIN_INSTANCE pPinInstance;
    LONG StopChannel, Channel;

    Status = ::GetStartNodeInstance(pIrp, &pStartNodeInstance);
    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
    pPinInstance = pStartNodeInstance->pPinInstance;
    Assert(pPinInstance);

    pFilterInstance = pPinInstance->pFilterInstance;
    Assert(pFilterInstance);
    Assert(pFilterInstance->pGraphNodeInstance);

    pNodeProperty = &pNodePropertyAudioChannel->NodeProperty;
    if(((pNodeProperty->Property.Flags & KSPROPERTY_TYPE_TOPOLOGY) == 0) ||
      (pNodeProperty->NodeId >= 
        pFilterInstance->pGraphNodeInstance->Topology.TopologyNodesCount)) {
        DPF(5, "PinVirtualPropertyHandler: invalid property");
        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto exit;
    }

    if(pStartNodeInstance->pVirtualNodeData == NULL ||
       pPinInstance->ulVolumeNodeNumber == MAXULONG ||
       pPinInstance->ulVolumeNodeNumber != pNodeProperty->NodeId) {
        Status = STATUS_NOT_FOUND;
        goto exit;
    }
    Assert(pStartNodeInstance->pVirtualNodeData);
    Assert(pStartNodeInstance->pVirtualNodeData->pVirtualSourceData);

    StopChannel = Channel = pNodePropertyAudioChannel->Channel;
    if(Channel == MAXULONG) {
        Channel = 0;
        StopChannel = pStartNodeInstance->pVirtualNodeData->
          pVirtualSourceData->cChannels - 1;
    }

    if(Channel >= MAX_NUM_CHANNELS || Channel < 0) {
        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto exit;
    }

    for(; Channel <= StopChannel; Channel++) {

        if(pNodeProperty->Property.Flags & KSPROPERTY_TYPE_GET) {
            *plLevel = pStartNodeInstance->pVirtualNodeData->lLevel[Channel];
            pIrp->IoStatus.Information = sizeof(LONG);
            ASSERT(NT_SUCCESS(Status));
        }
        else {
            ASSERT(pNodeProperty->Property.Flags & KSPROPERTY_TYPE_SET);
            pStartNodeInstance->pVirtualNodeData->lLevel[Channel] = *plLevel;

            Status = SetVirtualVolume(
              pStartNodeInstance->pVirtualNodeData,
              Channel);

            if(!NT_SUCCESS(Status)) {
                Trap();
                goto exit;
            }
        }
    }
    
exit:
    return(Status);
}

NTSTATUS
GetControlRange(
    PVIRTUAL_NODE_DATA pVirtualNodeData
)
{
    PKSPROPERTY_DESCRIPTION pPropertyDescription = NULL;
    PKSPROPERTY_MEMBERSHEADER pMemberHeader;
    PKSPROPERTY_STEPPING_LONG pSteppingLong;
    NTSTATUS Status = STATUS_SUCCESS;

    // Setup the defaults
    pVirtualNodeData->MinimumValue = (-96 * 65536);
    pVirtualNodeData->MaximumValue = 0;
    pVirtualNodeData->Steps = (65536/2);	// 1/2 db steps

    Status = QueryPropertyRange(
      pVirtualNodeData->pFileObject,
      &KSPROPSETID_Audio,
      KSPROPERTY_AUDIO_VOLUMELEVEL,
      pVirtualNodeData->NodeId,
      &pPropertyDescription);

    if(!NT_SUCCESS(Status)) {
        goto exit;
    }

    if((pPropertyDescription->MembersListCount == 0) ||
       (!IsEqualGUID(
         &pPropertyDescription->PropTypeSet.Set,
         &KSPROPTYPESETID_General)) ||
       (pPropertyDescription->PropTypeSet.Id != VT_I4)) {
        Status = STATUS_NOT_SUPPORTED;
        goto exit;
    }

    pMemberHeader = (PKSPROPERTY_MEMBERSHEADER)(pPropertyDescription + 1);
    if(pMemberHeader->MembersFlags & KSPROPERTY_MEMBER_STEPPEDRANGES) {

        pSteppingLong = (PKSPROPERTY_STEPPING_LONG)(pMemberHeader + 1);
        pVirtualNodeData->MinimumValue = pSteppingLong->Bounds.SignedMinimum;
        pVirtualNodeData->MaximumValue = pSteppingLong->Bounds.SignedMaximum;
        pVirtualNodeData->Steps = pSteppingLong->SteppingDelta;
    }
    else {
        Trap();
        Status = STATUS_NOT_SUPPORTED;
        goto exit;
    }
exit:
    delete pPropertyDescription;
    return(STATUS_SUCCESS);
}

NTSTATUS
QueryPropertyRange(
    PFILE_OBJECT pFileObject,
    CONST GUID *pguidPropertySet,
    ULONG ulPropertyId,
    ULONG ulNodeId,
    PKSPROPERTY_DESCRIPTION *ppPropertyDescription
)
{
    KSPROPERTY_DESCRIPTION PropertyDescription;
    KSNODEPROPERTY NodeProperty;
    ULONG BytesReturned;
    NTSTATUS Status;

    NodeProperty.Property.Set = *pguidPropertySet;
    NodeProperty.Property.Id = ulPropertyId;
    NodeProperty.Property.Flags =
      KSPROPERTY_TYPE_BASICSUPPORT | KSPROPERTY_TYPE_TOPOLOGY;
    NodeProperty.NodeId = ulNodeId;
    NodeProperty.Reserved = 0;

    AssertFileObject(pFileObject);
    Status = KsSynchronousIoControlDevice(
      pFileObject,
      KernelMode,
      IOCTL_KS_PROPERTY,
      &NodeProperty,
      sizeof(NodeProperty),
      &PropertyDescription,
      sizeof(PropertyDescription),
      &BytesReturned);

    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
    ASSERT(BytesReturned == sizeof(PropertyDescription));

    *ppPropertyDescription =
      (PKSPROPERTY_DESCRIPTION)new BYTE[PropertyDescription.DescriptionSize];

    if(*ppPropertyDescription == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }

    AssertFileObject(pFileObject);
    Status = KsSynchronousIoControlDevice(
      pFileObject,
      KernelMode,
      IOCTL_KS_PROPERTY,
      &NodeProperty,
      sizeof( NodeProperty ),
      *ppPropertyDescription,
      PropertyDescription.DescriptionSize,
      &BytesReturned);

    if(!NT_SUCCESS(Status)) {
        delete *ppPropertyDescription;
        *ppPropertyDescription = NULL;
        goto exit;
    }
exit:				    
    return(Status);
}

NTSTATUS
SetVirtualVolume(
    PVIRTUAL_NODE_DATA pVirtualNodeData,
    LONG Channel
)
{
    KSNODEPROPERTY_AUDIO_CHANNEL NodePropertyAudioChannel;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG BytesReturned;
    LONG lLevel;

    ASSERT(pVirtualNodeData->NodeId != MAXULONG);
    Assert(pVirtualNodeData->pVirtualSourceData);

    NodePropertyAudioChannel.NodeProperty.Property.Set =
      KSPROPSETID_Audio;
    NodePropertyAudioChannel.NodeProperty.Property.Id =
      KSPROPERTY_AUDIO_VOLUMELEVEL;
    NodePropertyAudioChannel.NodeProperty.Property.Flags =
      KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_TOPOLOGY;
    NodePropertyAudioChannel.NodeProperty.NodeId = pVirtualNodeData->NodeId;
    NodePropertyAudioChannel.Channel = Channel;
    NodePropertyAudioChannel.Reserved = 0;

    if(pVirtualNodeData->pVirtualSourceData->fMuted[Channel]) {
        lLevel = LONG_MIN;
    }
    else {
        if(pVirtualNodeData->pVirtualSourceData->lLevel[Channel] == LONG_MIN) {
            lLevel = LONG_MIN;
        }
        else {
            lLevel = pVirtualNodeData->lLevel[Channel];
            if(lLevel != LONG_MIN) {
            	lLevel += pVirtualNodeData->pVirtualSourceData->lLevel[Channel];
            	lLevel = MapVirtualLevel(pVirtualNodeData, lLevel);
            }
        }
    }
    AssertFileObject(pVirtualNodeData->pFileObject);
    Status = KsSynchronousIoControlDevice(
      pVirtualNodeData->pFileObject,
      KernelMode,
      IOCTL_KS_PROPERTY,
      &NodePropertyAudioChannel,
      sizeof(KSNODEPROPERTY_AUDIO_CHANNEL),
      &lLevel,
      sizeof(LONG),
      &BytesReturned);

    if(!NT_SUCCESS(Status)) {
        DPF4(10, "SetVirtualVolume: [%d] SNI %08x N# %u FAILED %08x",
          Channel,
          pVirtualNodeData->pStartNodeInstance,
          pVirtualNodeData->NodeId,
          Status);
    }
    return(STATUS_SUCCESS);
}

NTSTATUS
SetPhysicalVolume(
    PGRAPH_NODE_INSTANCE pGraphNodeInstance,
    PVIRTUAL_SOURCE_DATA pVirtualSourceData,
    LONG Channel
)
{
    KSNODEPROPERTY_AUDIO_CHANNEL NodePropertyAudioChannel;
    NTSTATUS Status = STATUS_SUCCESS;
    PFILE_OBJECT pFileObject;
    ULONG BytesReturned;
    LONG lLevel;

    Assert(pGraphNodeInstance);
    Assert(pVirtualSourceData);
    ASSERT(IsEqualGUID(
      pVirtualSourceData->pTopologyNode->pguidType,
      &KSNODETYPE_VOLUME));

    if(pVirtualSourceData->pTopologyNode->ulRealNodeNumber == MAXULONG) {
        ASSERT(NT_SUCCESS(Status));
        goto exit;
    }
    ASSERT(pVirtualSourceData->pTopologyNode->iVirtualSource < 
      gcVirtualSources);

    Status = pGraphNodeInstance->GetTopologyNodeFileObject(
      &pFileObject,
      pGraphNodeInstance->paulNodeNumber[
	pVirtualSourceData->pTopologyNode->iVirtualSource]);

    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }

    NodePropertyAudioChannel.NodeProperty.Property.Set =
      KSPROPSETID_Audio;

    NodePropertyAudioChannel.NodeProperty.Property.Id =
      KSPROPERTY_AUDIO_VOLUMELEVEL;

    NodePropertyAudioChannel.NodeProperty.Property.Flags =
      KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_TOPOLOGY;

    NodePropertyAudioChannel.NodeProperty.NodeId =
      pVirtualSourceData->pTopologyNode->ulRealNodeNumber;

    NodePropertyAudioChannel.Channel = Channel;
    NodePropertyAudioChannel.Reserved = 0;

    if(pVirtualSourceData->fMuted[Channel]) {
        lLevel = LONG_MIN;
    }
    else {
        lLevel = pVirtualSourceData->lLevel[Channel];
    }

    AssertFileObject(pFileObject);
    Status = KsSynchronousIoControlDevice(
      pFileObject,
      KernelMode,
      IOCTL_KS_PROPERTY,
      &NodePropertyAudioChannel,
      sizeof(KSNODEPROPERTY_AUDIO_CHANNEL),
      &lLevel,
      sizeof(LONG),
      &BytesReturned);

    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }
exit:
    if(!NT_SUCCESS(Status)) {
        DPF2(10, "SetPhysicalVolume: [%d] FAILED %08x", Channel, Status);
    }
    return(Status);
}

LONG
MapVirtualLevel(
    PVIRTUAL_NODE_DATA pVirtualNodeData,
    LONG lLevel
)
{
    DPF4(100, "MapVirtualLevel: from %d max %d min %d step %d", 
      lLevel / 65536,
      pVirtualNodeData->pVirtualSourceData->MaximumValue / 65536,
      pVirtualNodeData->pVirtualSourceData->MinimumValue / 65536,
      pVirtualNodeData->pVirtualSourceData->Steps / 65536);

    if(lLevel != LONG_MIN) {
        lLevel += pVirtualNodeData->MaximumValue -
          pVirtualNodeData->pVirtualSourceData->MaximumValue;
    }

    DPF4(100, "MapVirtualLevel: to %d max %d min %d step %d",
      lLevel / 65536,
      pVirtualNodeData->MaximumValue / 65536,
      pVirtualNodeData->MinimumValue / 65536,
      pVirtualNodeData->Steps / 65536);

    return(lLevel);
}

NTSTATUS
GetVolumeNodeNumber(
    PPIN_INSTANCE pPinInstance,
    PVIRTUAL_SOURCE_DATA pVirtualSourceData OPTIONAL
)
{
    PSTART_NODE pStartNode;
    NTSTATUS Status = STATUS_SUCCESS;
    KSAUDIO_MIXCAP_TABLE AudioMixCapTable;

    Assert(pPinInstance);
    Assert(pPinInstance->pFilterInstance);
    Assert(pPinInstance->pFilterInstance->pGraphNodeInstance);

    if(pPinInstance->ulVolumeNodeNumber == MAXULONG) {
        Assert(pPinInstance->pStartNodeInstance);
        pStartNode = pPinInstance->pStartNodeInstance->pStartNode;
        Assert(pStartNode);
        Assert(pStartNode->GetStartInfo());
        pPinInstance->ulVolumeNodeNumber =
          pStartNode->GetStartInfo()->ulVolumeNodeNumberPre;

        if(pStartNode->GetStartInfo()->ulVolumeNodeNumberSuperMix != MAXULONG &&
           pStartNode->GetStartInfo()->ulVolumeNodeNumberPost != MAXULONG) {

            Status = GetSuperMixCaps(
              &AudioMixCapTable,
              pPinInstance->pStartNodeInstance,
              pStartNode->GetStartInfo()->ulVolumeNodeNumberSuperMix);

            if(!NT_SUCCESS(Status)) {
                Status = STATUS_SUCCESS;
                goto exit;
            }
            if(AudioMixCapTable.OutputChannels != 1) {
                pPinInstance->ulVolumeNodeNumber = 
                  pStartNode->GetStartInfo()->ulVolumeNodeNumberPost;

                if(pVirtualSourceData != NULL) {
                    pVirtualSourceData->cChannels = 
                      AudioMixCapTable.OutputChannels;
                }
            }
        }
        DPF2(100, "GetVolumeNodeNumber: SN %08x %02x",
          pStartNode,
          pPinInstance->ulVolumeNodeNumber);
    }
exit:
    return(Status);
}

NTSTATUS
GetSuperMixCaps(
    OUT PKSAUDIO_MIXCAP_TABLE pAudioMixCapTable,
    IN PSTART_NODE_INSTANCE pStartNodeInstance,
    IN ULONG NodeId
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    KSNODEPROPERTY NodeProperty;
    PFILE_OBJECT pFileObject;
    ULONG BytesReturned;

    Assert(pStartNodeInstance);
    ASSERT(NodeId != MAXULONG);
      
    Status = pStartNodeInstance->GetTopologyNodeFileObject(
      &pFileObject,
      NodeId);

    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }

    NodeProperty.Property.Set = KSPROPSETID_Audio;
    NodeProperty.Property.Id = KSPROPERTY_AUDIO_MIX_LEVEL_CAPS;
    NodeProperty.Property.Flags = 
      KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_TOPOLOGY;
    NodeProperty.NodeId = pStartNodeInstance->pPinInstance->pFilterInstance->
      pGraphNodeInstance->papTopologyNode[NodeId]->ulRealNodeNumber;
    NodeProperty.Reserved = 0;
    ASSERT(NodeProperty.NodeId != MAXULONG);

    AssertFileObject(pFileObject);
    Status = KsSynchronousIoControlDevice(
      pFileObject,
      KernelMode,
      IOCTL_KS_PROPERTY,
      &NodeProperty,
      sizeof(KSNODEPROPERTY),
      pAudioMixCapTable,
      sizeof(KSAUDIO_MIXCAP_TABLE) - sizeof(KSAUDIO_MIX_CAPS),
      &BytesReturned);

exit:
    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\sysaudio\vsd.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   vsd.cpp
//
//  Description:
//
//  Virtual Source Data Class
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//  To Do:     Date	  Author      Comment
//
//@@END_MSINTERNAL
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"

// Default attenuation level for virtual source.
#define VIRTUAL_SOURCE_DEFAULT_ATTENUATION          0

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

CVirtualSourceData::CVirtualSourceData(
    PDEVICE_NODE pDeviceNode
)
{
    LONG i;

    cChannels = 2;
    MinimumValue = (-96 * 65536);
    MaximumValue = 0;
    Steps = (65536/2);

    for(i = 0; i < MAX_NUM_CHANNELS; i++) {
        this->lLevel[i] = (VIRTUAL_SOURCE_DEFAULT_ATTENUATION * 65536);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\sysaudio\vnd.h ===
//---------------------------------------------------------------------------
//
//  Module:   		vnd.h
//
//  Description:	Virtual Node Data Class
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Constants and Macros
//---------------------------------------------------------------------------

#define	MAX_NUM_CHANNELS	24

//---------------------------------------------------------------------------
// Classes
//---------------------------------------------------------------------------

typedef class CVirtualNodeData : public CListDoubleItem
{
public:
    CVirtualNodeData(
	PSTART_NODE_INSTANCE pStartNodeInstance,
	PVIRTUAL_SOURCE_DATA pVirtualSourceData
    );
    ~CVirtualNodeData();
    ENUMFUNC Destroy()
    {
	Assert(this);
	delete this;
	return(STATUS_CONTINUE);
    };
    PVIRTUAL_SOURCE_DATA pVirtualSourceData;
    PSTART_NODE_INSTANCE pStartNodeInstance;
    PFILE_OBJECT pFileObject;
    ULONG NodeId;
    LONG MinimumValue;				// Range to convert to
    LONG MaximumValue;				//
    LONG Steps;					//
    LONG lLevel[MAX_NUM_CHANNELS];		// Local volume
    DefineSignature(0x20444e56);		// VND

} VIRTUAL_NODE_DATA, *PVIRTUAL_NODE_DATA;

//---------------------------------------------------------------------------

typedef ListDoubleDestroy<VIRTUAL_NODE_DATA> LIST_VIRTUAL_NODE_DATA;

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\sysaudio\vsl.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   vsl.cpp
//
//  Description:
//
//	Virtual Source Line Class
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//  To Do:     Date	  Author      Comment
//
//@@END_MSINTERNAL
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#if defined(_M_IA64)
#define USE_ALLOC_TEXT
#endif
#include "common.h"

#if defined(ALLOC_PRAGMA) && defined(_M_IA64)
#pragma alloc_text(INIT, InitializeVirtualSourceLine)
#endif

//---------------------------------------------------------------------------

ALLOC_PAGEABLE_DATA PLIST_VIRTUAL_SOURCE_LINE gplstVirtualSourceLine = NULL;
ALLOC_PAGEABLE_DATA ULONG gcVirtualSources = 0;

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

#if !defined(_M_IA64)
#pragma INIT_CODE
#endif
#pragma INIT_DATA

NTSTATUS
InitializeVirtualSourceLine(
)
{
    if(gplstVirtualSourceLine == NULL) {
        gplstVirtualSourceLine = new LIST_VIRTUAL_SOURCE_LINE;
        if(gplstVirtualSourceLine == NULL) {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }
    }
    return(STATUS_SUCCESS);
}

#pragma PAGEABLE_CODE
#pragma PAGEABLE_DATA

VOID
UninitializeVirtualSourceLine(
)
{
    delete gplstVirtualSourceLine;
    gplstVirtualSourceLine = NULL;
}

//---------------------------------------------------------------------------

CVirtualSourceLine::CVirtualSourceLine(
    PSYSAUDIO_CREATE_VIRTUAL_SOURCE pCreateVirtualSource
)
{
    ASSERT(gplstVirtualSourceLine != NULL);
    //
    // NOTE: Virtual pins must end up first before the hardware's
    //       pins so wdmaud mixer line parsing works correctly.
    //
    AddListEnd(gplstVirtualSourceLine);

    if(pCreateVirtualSource->Property.Id ==
      KSPROPERTY_SYSAUDIO_CREATE_VIRTUAL_SOURCE_ONLY) {
        ulFlags |= VSL_FLAGS_CREATE_ONLY;
    }


    RtlCopyMemory(
      &guidCategory,
      &pCreateVirtualSource->PinCategory,
      sizeof(GUID));

    RtlCopyMemory(
      &guidName,
      &pCreateVirtualSource->PinName,
      sizeof(GUID));

    iVirtualSource = gcVirtualSources++;
}

CVirtualSourceLine::~CVirtualSourceLine(
)
{
    RemoveList(gplstVirtualSourceLine);
    gcVirtualSources--;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\sysaudio\vsl.h ===
//---------------------------------------------------------------------------
//
//  Module:   		vsl.h
//
//  Description:	Virtual Source Line Class
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Constants and Macros
//---------------------------------------------------------------------------

#define VSL_FLAGS_CREATE_ONLY		0x00000001

//---------------------------------------------------------------------------
// Classes
//---------------------------------------------------------------------------

typedef class CVirtualSourceLine : public CListSingleItem
{
public:
    CVirtualSourceLine(
	PSYSAUDIO_CREATE_VIRTUAL_SOURCE pCreateVirtualSource
    );
    ~CVirtualSourceLine(
    );
    ENUMFUNC Destroy(
    )
    {
	Assert(this);
	delete this;
	return(STATUS_CONTINUE);
    };
    GUID guidCategory;
    GUID guidName;
    ULONG iVirtualSource;
    ULONG ulFlags;
    DefineSignature(0x204C5356);		// VSL

} VIRTUAL_SOURCE_LINE, *PVIRTUAL_SOURCE_LINE;

//---------------------------------------------------------------------------

typedef ListSingleDestroy<VIRTUAL_SOURCE_LINE> LIST_VIRTUAL_SOURCE_LINE;
typedef LIST_VIRTUAL_SOURCE_LINE *PLIST_VIRTUAL_SOURCE_LINE;

//---------------------------------------------------------------------------
// Globals
//---------------------------------------------------------------------------

extern ALLOC_PAGEABLE_DATA PLIST_VIRTUAL_SOURCE_LINE gplstVirtualSourceLine;
extern ALLOC_PAGEABLE_DATA ULONG gcVirtualSources;

//---------------------------------------------------------------------------
// Local prototypes
//---------------------------------------------------------------------------

#if defined(_M_IA64)
extern "C"
#endif
NTSTATUS
InitializeVirtualSourceLine(
);

VOID
UninitializeVirtualSourceLine(
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\timebomb\timebomb.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 2000
//
//  File:       timebomb.c
//
//--------------------------------------------------------------------------

//
//  -- Add these lines after the #include's in the file that handles DriverEntry:
//
//      #ifdef TIME_BOMB
//      #include "..\..\timebomb\timebomb.c"
//      #endif
//
//  -- Add the following lines to the beginning of DriverEntry:
//
//      #ifdef TIME_BOMB
//      if (HasEvaluationTimeExpired()) {
//          return STATUS_EVALUATION_EXPIRATION;
//      }
//      #endif
//
//  -- If you want to override the default expiration value of 31 days after
//     compile, define the constant DAYS_UNTIL_EXPIRATION before you include
//     timebomb.c
//
//  -- Add -DTIME_BOMB to the $(C_DEFINES) line in the sources file.  If you haven't
//     already done so, you may also want to add -DDEBUG_LEVEL=DEBUGLVL_TERSE.
//
//  -- "Cleanly" recompile your binary with 'build -cZ'
//
//  -- NOTE: This uses the __DATE__ preprocessor directive which inserts a _very_
//           clear-text string into the binary which is easily modifiable with a
//           hex editor.  Suggestions on making this more secure are welcome.
//

#if !defined(_KSDEBUG_)
#include <ksdebug.h>
#endif

#ifndef DAYS_UNTIL_EXPIRATION
#define DAYS_UNTIL_EXPIRATION   31
#endif

typedef enum {
    Jan=1,
    Feb,
    Mar,
    Apr,
    May,
    Jun,
    Jul,
    Aug,
    Sep,
    Oct,
    Nov,
    Dec
} MONTH;

MONTH GetMonthFromDateString
(
    char *_BuildDate_
)
{
    MONTH BuildMonth = (MONTH)0;

    ASSERT(_BuildDate_);

    switch (_BuildDate_[0]) {
        case 'A':
            if (_BuildDate_[1] == 'u') {
                BuildMonth = Aug;
            }
            else {
                BuildMonth = Apr;
            }
            break;
        case 'D':
            BuildMonth = Dec;
            break;
        case 'F':
            BuildMonth = Feb;
            break;
        case 'J':
            if (_BuildDate_[1] == 'u') {
                if (_BuildDate_[2] == 'l') {
                    BuildMonth = Jul;
                } else {
                    BuildMonth = Jun;
                }
            } else {
                BuildMonth = Jan;
            }
            break;
        case 'M':
            if (_BuildDate_[2] == 'r') {
                BuildMonth = Mar;
            }
            else {
                BuildMonth = May;
            }
            break;
        case 'N':
            BuildMonth = Nov;
            break;
        case 'O':
            BuildMonth = Oct;
            break;
        case 'S':
            BuildMonth = Sep;
            break;
        default:
            ASSERT(0);
            break;
    }

    return BuildMonth;
}

BOOL HasEvaluationTimeExpired()
{
    //  Get the time that this file was compiled
    char            _BuildDate_[] = __DATE__;
    CSHORT          BuildYear,
                    BuildMonth,
                    BuildDay,
                    ThousandsDigit,
                    HundredsDigit,
                    TensDigit,
                    Digit;
    ULONG           BuildDays,
                    CurrentDays;
    LARGE_INTEGER   CurrentSystemTime;
    TIME_FIELDS     CurrentSystemTimeFields;

    //  Convert _BuildDate_ into something a little more palatable
    _DbgPrintF( DEBUGLVL_TERSE, ("Driver Build Date: %s",_BuildDate_) );

    BuildMonth = GetMonthFromDateString(_BuildDate_);

    //  Compensate for a ' ' in the tens digit
    if ( (_BuildDate_[4] >= '0') && (_BuildDate_[4] <= '9') ) {
        TensDigit = _BuildDate_[4] - '0';
    } else {
        TensDigit = 0;
    }
    Digit     = _BuildDate_[5] - '0';
    BuildDay  = (TensDigit * 10) + Digit;

    ThousandsDigit = _BuildDate_[7] - '0';
    HundredsDigit  = _BuildDate_[8] - '0';
    TensDigit      = _BuildDate_[9] - '0';
    Digit          = _BuildDate_[10] - '0';
    BuildYear      = (ThousandsDigit * 1000) + (HundredsDigit * 100) + (TensDigit * 10) + Digit;

    //  Get the current system time and convert to local time
    KeQuerySystemTime( &CurrentSystemTime ); // returns GMT
    RtlTimeToTimeFields( &CurrentSystemTime, &CurrentSystemTimeFields );

    //  For now, only let this binary float for 31 days
    BuildDays = (BuildYear * 365) +
                (BuildMonth * 31) +
                 BuildDay;
    CurrentDays = (CurrentSystemTimeFields.Year * 365) +
                  (CurrentSystemTimeFields.Month * 31) +
                   CurrentSystemTimeFields.Day;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("CurrentDays: %d  BuildDays: %d",CurrentDays, BuildDays) );
    if (CurrentDays > BuildDays + DAYS_UNTIL_EXPIRATION) {
        _DbgPrintF( DEBUGLVL_TERSE, ("Evaluation period expired!") );
        return TRUE;
    }
    else {
        _DbgPrintF( DEBUGLVL_TERSE, ("Evaluation days left: %d", (BuildDays + 31) - CurrentDays) );
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\bda\bdasup\bdasupi.h ===
//---------------------------------------------------------------------------
//  Bda Topology Implementation Internal Structures
//
//      Minidriver code should not attempt to access these structures
//      directly.
//
//---------------------------------------------------------------------------

#define FILTERNAME          "BdaTopology"
#define DYNAMIC_TOPOLOGY    TRUE


#if defined(__cplusplus)
extern "C" {
#endif // defined(__cplusplus)


//===========================================================================
//
//  MACRO definitions
//
//===========================================================================
#define BDA_PIN_STORAGE_INCREMENT   5

//===========================================================================
//
//  Advance declarations
//
//===========================================================================
typedef struct _BDA_PIN_FACTORY_CONTEXT      BDA_PIN_FACTORY_CONTEXT, 
                                        *PBDA_PIN_FACTORY_CONTEXT;



//===========================================================================
//
//  BDA Object Context Structures
//
//===========================================================================


typedef struct _BDA_CONTEXT_ENTRY
{
    PVOID       pvReference;
    PVOID       pvContext;
    ULONG       ulcbContext;

} BDA_CONTEXT_ENTRY, * PBDA_CONTEXT_ENTRY;

typedef struct _BDA_CONTEXT_LIST
{
    ULONG               ulcListEntries;
    ULONG               ulcMaxListEntries;
    ULONG               ulcListEntriesPerBlock;
    PBDA_CONTEXT_ENTRY  pListEntries;
    KSPIN_LOCK          lock;
    BOOLEAN             fInitialized;

} BDA_CONTEXT_LIST, * PBDA_CONTEXT_LIST;


typedef struct _BDA_TEMPLATE_PATH
{
    LIST_ENTRY      leLinkage;

    ULONG           ulInputPinType;
    ULONG           ulOutputPinType;
    ULONG           uliJoint;

    ULONG           ulcControlNodesInPath;
    PULONG          argulControlNodesInPath;

} BDA_TEMPLATE_PATH, * PBDA_TEMPLATE_PATH;

__inline NTSTATUS
NewBdaTemplatePath(
    PBDA_TEMPLATE_PATH *    ppTemplatePath
    )
{
    NTSTATUS            status = STATUS_SUCCESS;

    if (!ppTemplatePath)
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

    *ppTemplatePath = (PBDA_TEMPLATE_PATH) ExAllocatePool( 
                                               NonPagedPool,
                                               sizeof( BDA_TEMPLATE_PATH)
                                               );
    if (!*ppTemplatePath)
    {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto errExit;
    }

    RtlZeroMemory( *ppTemplatePath, sizeof( BDA_TEMPLATE_PATH));
    InitializeListHead( &(*ppTemplatePath)->leLinkage);

errExit:
    return status;
}

__inline NTSTATUS
DeleteBdaTemplatePath(
    PBDA_TEMPLATE_PATH  pTemplatePath
    )
{
    NTSTATUS            status = STATUS_SUCCESS;

    if (!pTemplatePath)
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

    if (pTemplatePath->argulControlNodesInPath)
    {
        ExFreePool( pTemplatePath->argulControlNodesInPath);
        pTemplatePath->argulControlNodesInPath = NULL;
    }

    RtlZeroMemory( pTemplatePath, sizeof( BDA_TEMPLATE_PATH));
    ExFreePool( pTemplatePath);

errExit:
    return status;
}



typedef struct _BDA_DEVICE_CONTEXT
{

    ULONG       ulStartEmpty;

    //$BUG  Add global statistics

} BDA_DEVICE_CONTEXT, *PBDA_DEVICE_CONTEXT;


typedef struct _BDA_PATH_STACK_ENTRY
{
    ULONG       ulHop;
    ULONG       uliConnection;
    BOOLEAN     fJoint;
} BDA_PATH_STACK_ENTRY, *PBDA_PATH_STACK_ENTRY;

typedef struct _BDA_NODE_CONTROL_INFO
{
    ULONG           ulNodeType;
    ULONG           ulControllingPinType;

} BDA_NODE_CONTROL_INFO, * PBDA_NODE_CONTROL_INFO;

typedef struct _BDA_PATH_INFO
{
    ULONG                   ulInputPin;
    ULONG                   ulOutputPin;
    ULONG                   ulcPathEntries;
    BDA_PATH_STACK_ENTRY    rgPathEntries[MIN_DIMENSION];

} BDA_PATH_INFO, * PBDA_PATH_INFO;


typedef struct _BDA_FILTER_FACTORY_CONTEXT
{
    const BDA_FILTER_TEMPLATE *     pBdaFilterTemplate;
    const KSFILTER_DESCRIPTOR *     pInitialFilterDescriptor;

    PKSFILTERFACTORY                pKSFilterFactory;

} BDA_FILTER_FACTORY_CONTEXT, *PBDA_FILTER_FACTORY_CONTEXT;

typedef struct _BDA_FILTER_CONTEXT
{
    PKSFILTER                       pKSFilter;
    const BDA_FILTER_TEMPLATE *     pBdaFilterTemplate;

    //  Pins are added as they are created.
    //  Note!  If the filter has m pin factories included in the
    //  initial filter descriptor then the first m entries in this array
    //  will contain null pointers.
    //
    ULONG                           ulcPinFactories;
    ULONG                           ulcPinFactoriesMax;
    PBDA_PIN_FACTORY_CONTEXT        argPinFactoryCtx;

    //  One node path will exist for each pin pairing.
    //
    //$REVIEW - Should we allow more than one path per pin pair?
    //
    ULONG                           ulcPathInfo;
    PBDA_PATH_INFO *                argpPathInfo;

} BDA_FILTER_CONTEXT, *PBDA_FILTER_CONTEXT;


typedef struct _BDA_PIN_FACTORY_CONTEXT
{
    ULONG                   ulPinType;
    ULONG                   ulPinFactoryId;
} BDA_PIN_FACTORY_CONTEXT, *PBDA_PIN_FACTORY_CONTEXT;


typedef struct _BDA_NODE_CONTEXT
{

    ULONG       ulStartEmpty;

} BDA_NODE_CONTEXT, *PBDA_NODE_CONTEXT;


//---------------------------------------------------------------------------
//  BDA Topology Implementation Internal Functions
//
//      Minidriver code should not call these routines directly.
//
//---------------------------------------------------------------------------

/*
**  BdaFindPinPair()
**
**      Returns a pointer to the BDA_PIN_PAIRING that corresponds
**      to the given input and output pins.
**
**  Arguments:
**
**      pTopology   Pointer to the BDA topology that contains the
**                  pin pairing.
**
**      InputPinId  Id of the input Pin to match
**
**      OutputPinId Id of the output Pin to match
**
**  Returns:
**
**      pPinPairing     Pointer to a valid BDA Pin Pairing structure
**
**      NULL            If no valid pin pairing exists with the
**                      given input and output pins.
**
** Side Effects:  none
*/

PBDA_PIN_PAIRING
BdaFindPinPair(
    PBDA_FILTER_TEMPLATE    pFilterTemplate,
    ULONG                   InputPinId,
    ULONG                   OutputPinId
    );


/*
**  BdaGetPinFactoryContext()
**
**  Finds a BDA PinFactory Context that corresponds
**  to the given KS Pin Instance.
**
** Arguments:
**
**
** Returns:
**
**
**
** Side Effects:  none
*/

STDMETHODIMP_(NTSTATUS)
BdaGetPinFactoryContext(
    PKSPIN                          pKSPin,
    PBDA_PIN_FACTORY_CONTEXT        pPinFactoryCtx
    );


/*
**  BdaInitFilterFactoryContext()
**
**      Initializes a BDA Filter Factory Context based on the filter's
**      template descriptor.
**
**
**  Arguments:
**
**
**      pFilterFactoryCtx
**
**  Returns:
**
**      NULL            If no valid pin pairing exists with the
**                      given input and output pins.
**
** Side Effects:  none
*/

STDMETHODIMP_(NTSTATUS)
BdaInitFilterFactoryContext(
    PBDA_FILTER_FACTORY_CONTEXT pFilterFactoryCtx
    );


/*
**  BdaAddNodeAutomationToPin()
**
**      Merges the automation tables for each node type that is controlled
**      by the pin type being created into the automation table for the
**      the pin factory.  This is how the automation tables for BDA
**      control nodes get linked to the controlling pin.  Otherwise the
**      nodes would not be accesable.
**
**
**  Arguments:
**
**
**      pFilterCtx      The BDA filter context to which the pin factory
**                      belongs.  Must have this to get at the template
**                      topology.
**
**      ulPinType       BDA Pin Type of the pin being created.  Need this
**                      to figure out which nodes are controlled by the
**                      pin.
**
**  Returns:
**
**
** Side Effects:  none
*/

STDMETHODIMP_(NTSTATUS)
BdaAddNodeAutomationToPin( 
    PBDA_FILTER_CONTEXT         pFilterCtx, 
    ULONG                       ulControllingPinType,
    KSOBJECT_BAG                ObjectBag,
    const KSAUTOMATION_TABLE *  pOriginalAutomationTable,
    PKSAUTOMATION_TABLE *       ppNewAutomationTable
    );


/*
**  BdaCreateTemplatePaths()
**
**      Creates a list of all possible paths through the template filter.
**      Determines the controlling pin type for each node type in the
**      template filter.
**
**
**  Arguments:
**
**
**      pFilterFactoryCtx
**
**  Returns:
**
**      NULL            If no valid pin pairing exists with the
**                      given input and output pins.
**
** Side Effects:  none
*/

STDMETHODIMP_(NTSTATUS)
BdaCreateTemplatePaths(
    const BDA_FILTER_TEMPLATE *     pBdaFilterTemplate,
    PULONG                          pulcPathInfo,
    PBDA_PATH_INFO **               pargpPathInfo
    );


ULONG __inline
OutputBufferLenFromIrp(
    PIRP    pIrp
    )
{
    PIO_STACK_LOCATION pIrpStack;

    ASSERT( pIrp);
    if (!pIrp)
    {
        return 0;
    }

    pIrpStack = IoGetCurrentIrpStackLocation( pIrp);
    ASSERT( pIrpStack);
    if (pIrpStack)
    {
        return pIrpStack->Parameters.DeviceIoControl.OutputBufferLength;
    }
    else
    {
        return 0;
    }
}



//---------------------------------------------------------------------------
//  BDA Topology Const Data
//
//      Minidriver code should not use these fields directly
//
//---------------------------------------------------------------------------

extern const KSAUTOMATION_TABLE     BdaDefaultPinAutomation;
extern const KSAUTOMATION_TABLE     BdaDefaultFilterAutomation;


#if defined(__cplusplus)
}
#endif // defined(__cplusplus)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\bda\bdasup\makefile.inc ===
# HACK ALERT: This target is solely to keep nmake from whining that it doesn't
# know how to make the dependency in rules that depend on the target executable.
$(TARGETPATHEX)\$(TARGETNAME).sys:

# Build SoftICE symbols
$(TARGETPATHEX)\$(TARGETNAME).nms: $(TARGETPATHEX)\$(TARGETNAME).sys
    echo $(TARGETPATHEX)\$(TARGETNAME) > target.txt
    nmsym /translate:source,package,always /source:. /output:$(TARGETPATHEX)\$(TARGETNAME).nms $(TARGETPATHEX)\$(TARGETNAME).sys

# Build WinDbg symbols
#
$(TARGETPATH)\$(TARGETNAME).dbg: $(TARGETPATHEX)\$(TARGETNAME).sys
    splitsym -s $(TARGETPATH)  $(TARGETPATHEX)\$(TARGETNAME).sys

# Delete built files
clean:
    -echo $(TARGETPATHEX)\$(TARGETNAME).*
    -del /s *.obj
    -del /s *.res
    -del build.log
    -del build.err
    -del /s _objects.mac
    -del $(TARGETPATHEX)\$(TARGETNAME).*
    -del $(TARGETPATH)\$(TARGETNAME).*
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\sysaudio\vsd.h ===
//---------------------------------------------------------------------------
//
//  Module:   		vsd.h
//
//  Description:	Virtual Source Data Class
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Constants and Macros
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Classes
//---------------------------------------------------------------------------

typedef class CVirtualSourceData : public CObj
{
public:
    CVirtualSourceData(
	PDEVICE_NODE pDeviceNode
    );

    PTOPOLOGY_NODE pTopologyNode;
    LONG MinimumValue;				// range to convert from
    LONG MaximumValue;				//
    LONG Steps;					//
    LONG cChannels;
    BOOL fMuted[MAX_NUM_CHANNELS];		// muted if TRUE
    LONG lLevel[MAX_NUM_CHANNELS];
    LIST_VIRTUAL_NODE_DATA lstVirtualNodeData;
    DefineSignature(0x20445356);		// VSD

} VIRTUAL_SOURCE_DATA, *PVIRTUAL_SOURCE_DATA;

//---------------------------------------------------------------------------
// Globals
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Local prototypes
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\bda\bdasup\bdatopgy.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;


#include <wdm.h>
#include <limits.h>
#include <unknown.h>
#include <ks.h>
#include <ksmedia.h>
#include <bdatypes.h>
#include <bdamedia.h>
#include <bdasup.h>
#include "bdasupi.h"

/*
 -  DriverEntry
 -
 *  This the the required DriverEntry for the BDA Support Driver.
 *  Though required, it is never actually called.
 *
 */
NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT    pDriverObject,
    IN PUNICODE_STRING   pszuRegistryPath
    )
//////////////////////////////////////////////////////////////////////////////////////
{
//$BUGBUG   This entry point is required but never called.

    return STATUS_SUCCESS;
}


STDMETHODIMP_(NTSTATUS)
BdaFindContextEntry(
    PBDA_CONTEXT_LIST   pContextList,
    PVOID               pvReference,
    PVOID *             ppvContext
    )
{
    NTSTATUS            status = STATUS_SUCCESS;
    ULONG               uliEntry;
    KIRQL               oldIrql;

    ASSERT( pContextList);
    ASSERT( ppvContext);

    if (!pContextList->fInitialized)
    {
        status = STATUS_NOT_FOUND;
        goto errExit;
    }

    //  NULL pvReference is not valid.
    //
    if (!pvReference)
    {
        status = STATUS_INVALID_PARAMETER;
        *ppvContext = NULL;
        goto errExit;
    }

    //  Lock down the list while we search it.
    //
    KeAcquireSpinLock( &(pContextList->lock), &oldIrql);

    //  Find a list entry with a matching pvReference
    //
    for (uliEntry = 0; uliEntry < pContextList->ulcListEntries; uliEntry++)
    {
        if (pContextList->pListEntries[uliEntry].pvReference == pvReference)
        {
            break;
        }
    }

    if (uliEntry >= pContextList->ulcListEntries)
    {
        //  No matching entry was found so return error.
        //
        status = STATUS_NOT_FOUND;
        *ppvContext = NULL;
    }
    else
    {
        //  Return the pvContext corresponding to the matching pvReference.
        //
        *ppvContext = pContextList->pListEntries[uliEntry].pvContext;
    }

    KeReleaseSpinLock( &(pContextList->lock), oldIrql);

errExit:
    return status;
}


STDMETHODIMP_(NTSTATUS)
BdaCreateContextEntry(
    PBDA_CONTEXT_LIST   pContextList,
    PVOID               pvReference,
    ULONG               ulcbContext,
    PVOID *             ppvContext
    )
{
    NTSTATUS            status = STATUS_SUCCESS;
    ULONG               uliEntry;
    KIRQL               oldIrql;

    ASSERT( pContextList);
    ASSERT( ppvContext);

    if (!pContextList->fInitialized)
    {
        KeInitializeSpinLock ( &(pContextList->lock));
        pContextList->fInitialized = TRUE;
    }

    //  See if a list entry has already been created.
    //
    status = BdaFindContextEntry( pContextList, pvReference, ppvContext);
    if (status != STATUS_NOT_FOUND)
    {
        goto errExit;
    }
    status = STATUS_SUCCESS;

    KeAcquireSpinLock( &(pContextList->lock), &oldIrql);

    //  If the current block of context entries is full, allocate
    //  a bigger block to put the new entry into.
    //
    if (pContextList->ulcListEntries >= pContextList->ulcMaxListEntries)
    {
        ULONG               ulcEntriesToAllocate;
        PBDA_CONTEXT_ENTRY  pNewList;

        ulcEntriesToAllocate =  pContextList->ulcMaxListEntries
                              + pContextList->ulcListEntriesPerBlock;

        pNewList = (PBDA_CONTEXT_ENTRY) ExAllocatePool(
                       NonPagedPool,
                       ulcEntriesToAllocate * sizeof( BDA_CONTEXT_ENTRY)
                       );
        if (!pNewList)
        {
            status = STATUS_NO_MEMORY;
            KeReleaseSpinLock( &(pContextList->lock), oldIrql);
            goto errExit;
        }

        RtlZeroMemory( pNewList,
                        ulcEntriesToAllocate * sizeof( BDA_CONTEXT_ENTRY)
                     );
        if (pContextList->pListEntries)
        {
	    // pNewList and pContextList->pListEntries are big enough (allocated in this file)
            RtlMoveMemory( pNewList,
                           pContextList->pListEntries,
                             pContextList->ulcMaxListEntries
                           * sizeof( BDA_CONTEXT_ENTRY)
                         );
            ExFreePool( pContextList->pListEntries);
        }

        pContextList->pListEntries = pNewList;
        pContextList->ulcMaxListEntries = ulcEntriesToAllocate;
    }

#ifdef SORTED_CONTEXT_ENTRIES

    //  Find the proper place to insert the new entry into the list.
    //
    for (uliEntry = 0; uliEntry < pContextList->ulcListEntries; uliEntry++)
    {
        if (pContextList->pListEntries[uliEntry].pvReference > pvReference)
        {
            break;
        }
    }

#else

    uliEntry = pContextList->ulcListEntries;

#endif // SORTED_CONTEXT_ENTRIES


    //  Allocate a new context entry
    //
    *ppvContext = ExAllocatePool( NonPagedPool, ulcbContext);
    if (!*ppvContext)
    {
        status = STATUS_NO_MEMORY;
        KeReleaseSpinLock( &(pContextList->lock), oldIrql);
        goto errExit;
    }

#ifdef SORTED_CONTEXT_ENTRIES

    //  If the new entry is in the middle of the list, then create
    //  a whole for it by moving the end of the list down.
    //
    if (uliEntry < pContextList->ulcListEntries)
    {
        //  NOTE!  RtlMoveMemory handles overlapped source and destination.
        //
        RtlMoveMemory( &(pContextList->pListEntries[uliEntry + 1]),
                       &(pContextList->pListEntries[uliEntry]),
                         (pContextList->ulcListEntries - uliEntry)
                       * sizeof( BDA_CONTEXT_ENTRY)
                     );
    }

#endif // SORTED_CONTEXT_ENTRIES


    RtlZeroMemory( *ppvContext, ulcbContext);
    pContextList->pListEntries[uliEntry].pvContext = *ppvContext;
    pContextList->pListEntries[uliEntry].ulcbContext = ulcbContext;
    pContextList->pListEntries[uliEntry].pvReference = pvReference;
    pContextList->ulcListEntries++;

    KeReleaseSpinLock( &(pContextList->lock), oldIrql);

errExit:
    return status;
}


STDMETHODIMP_(NTSTATUS)
BdaDeleteContextEntry(
    PBDA_CONTEXT_LIST   pContextList,
    PVOID               pvReference
    )
{
    NTSTATUS            status = STATUS_SUCCESS;
    ULONG               uliEntry;
    KIRQL               oldIrql;
    PVOID               pvContext;
    ULONG               ulcbContext;

    ASSERT( pContextList);
    ASSERT( pvReference);
    ASSERT( pContextList->fInitialized);

    if (!pContextList->fInitialized)
    {
        goto errExit;
    }

    KeAcquireSpinLock( &(pContextList->lock), &oldIrql);

    //  Find the Context Entry in the list
    //
    for (uliEntry = 0; uliEntry < pContextList->ulcListEntries; uliEntry++)
    {
        if (pContextList->pListEntries[uliEntry].pvReference == pvReference)
        {
            break;
        }
    }

    if (uliEntry >= pContextList->ulcListEntries)
    {
        status = STATUS_NOT_FOUND;
        KeReleaseSpinLock( &(pContextList->lock), oldIrql);
        goto errExit;
    }

    pvContext = pContextList->pListEntries[uliEntry].pvContext;
    ulcbContext = pContextList->pListEntries[uliEntry].ulcbContext;
    pContextList->pListEntries[uliEntry].pvContext = NULL;
    pContextList->pListEntries[uliEntry].pvReference = NULL;
    RtlZeroMemory( pvContext, ulcbContext);
    ExFreePool( pvContext);

    pContextList->ulcListEntries -= 1;
    if (uliEntry < pContextList->ulcListEntries)
    {
        //  NOTE!  RtlMoveMemory handles overlapped source and destination.
        //
	// pContextList->pListEntries is big enough (with index uliEntry(+1) as well)
        RtlMoveMemory( &(pContextList->pListEntries[uliEntry]),
                       &(pContextList->pListEntries[uliEntry + 1]),
                       (pContextList->ulcListEntries - uliEntry)
                       * sizeof( BDA_CONTEXT_ENTRY)
                     );
    }

    KeReleaseSpinLock( &(pContextList->lock), oldIrql);

errExit:
    return status;
}


STDMETHODIMP_(NTSTATUS)
BdaDeleteContextEntryByValue(
    PBDA_CONTEXT_LIST   pContextList,
    PVOID               pvContext
    )
{
    NTSTATUS            status = STATUS_SUCCESS;
    ULONG               uliEntry;
    KIRQL               oldIrql;
    ULONG               ulcbContext;

    ASSERT( pContextList);
    ASSERT( pvContext);
    ASSERT( pContextList->fInitialized);

    if (!pContextList->fInitialized)
    {
        goto errExit;
    }

    KeAcquireSpinLock( &(pContextList->lock), &oldIrql);

    //  Find the Context Entry in the list
    //
    for (uliEntry = 0; uliEntry < pContextList->ulcListEntries; uliEntry++)
    {
        if (pContextList->pListEntries[uliEntry].pvContext == pvContext)
        {
            break;
        }
    }

    if (uliEntry >= pContextList->ulcListEntries)
    {
        status = STATUS_NOT_FOUND;
        KeReleaseSpinLock( &(pContextList->lock), oldIrql);
        goto errExit;
    }

    ulcbContext = pContextList->pListEntries[uliEntry].ulcbContext;
    pContextList->pListEntries[uliEntry].pvContext = NULL;
    pContextList->pListEntries[uliEntry].pvReference = NULL;
    RtlZeroMemory( pvContext, ulcbContext);
    ExFreePool( pvContext);

    pContextList->ulcListEntries -= 1;
    if (uliEntry < pContextList->ulcListEntries)
    {
        //  NOTE!  RtlMoveMemory handles overlapped source and destination.
        //
	// pContextList->pListEntries is big enough (allocated in this file)
        RtlMoveMemory( &(pContextList->pListEntries[uliEntry]),
                       &(pContextList->pListEntries[uliEntry + 1]),
                       (pContextList->ulcListEntries - uliEntry)
                       * sizeof( BDA_CONTEXT_ENTRY)
                     );
    }

    KeReleaseSpinLock( &(pContextList->lock), oldIrql);

errExit:
    return status;
}


/*
**  BdaDeleteFilterFactoryContextByValue()
**
**  Finds the given BDA Filter Factory Context in the FilterFactory
**  context list and removes it.
**
**  This function is provided as a callback when the Filter Facotry Context
**  is added to the KSFilterFactory's Object Bag.  This allows KS to clean
**  up the context when the filter factory is unexpectedly closed.
**
** Arguments:
**
**
** Returns:
**
**
**
** Side Effects:  none
*/

BDA_CONTEXT_LIST    FilterFactoryContextList = { 0, 0, 4, NULL, 0, FALSE};

STDMETHODIMP_(VOID)
BdaDeleteFilterFactoryContextByValue(
    PVOID       pFilterFactoryCtx
    )
{
    BdaDeleteContextEntryByValue( &FilterFactoryContextList,
                                  pFilterFactoryCtx
                                );
}


/*
**  BdaCreateFilterFactoryContext()
**
**  Finds or creates a BDA Filter Factory Context that corresponds
**  to the given KS Filter Factory.
**
** Arguments:
**
**
** Returns:
**
**
**
** Side Effects:  none
*/

STDMETHODIMP_(NTSTATUS)
BdaCreateFilterFactoryContext(
    PKSFILTERFACTORY                pKSFilterFactory,
    PBDA_FILTER_FACTORY_CONTEXT *   ppFilterFactoryCtx
    )
{
    NTSTATUS                    status = STATUS_SUCCESS;

    status = BdaCreateContextEntry( &FilterFactoryContextList,
                                    pKSFilterFactory,
                                    sizeof( BDA_FILTER_FACTORY_CONTEXT),
                                    (PVOID *) ppFilterFactoryCtx
                                  );
    if (!NT_SUCCESS( status))
    {
        goto errExit;
    }

    status = KsAddItemToObjectBag( pKSFilterFactory->Bag,
                                   *ppFilterFactoryCtx,
                                   BdaDeleteFilterFactoryContextByValue
                                 );

errExit:
    return status;
}


/*
**  BdaDestructFilterContext()
**
**  Finds the given BDA Filter Context in the Filter
**  context list and removes it.
**
**  This function is provided as a callback when the Filter Context is
**  added to the KSFilter's Object Bag.  This allows KS to clean up the
**  context when the filter is unexpectedly closed.
**
** Arguments:
**
**
** Returns:
**
**
**
** Side Effects:  none
*/


STDMETHODIMP_(VOID)
BdaDestructFilterContext(
    PBDA_FILTER_CONTEXT       pFilterCtx
    )
{
    ULONG       uliPath;

    ASSERT( pFilterCtx);
    
    if (!pFilterCtx || !pFilterCtx->argpPathInfo)
    {
        goto exit;
    }

    //  Delete the path information.
    //

    for ( uliPath = 0; uliPath < pFilterCtx->ulcPathInfo; uliPath++)
    {
        if (pFilterCtx->argpPathInfo[uliPath])
        {
            ExFreePool( pFilterCtx->argpPathInfo[uliPath]);
            pFilterCtx->argpPathInfo[uliPath] = NULL;
        }
    }

    ExFreePool( pFilterCtx->argpPathInfo);
    pFilterCtx->argpPathInfo = NULL;
    pFilterCtx->ulcPathInfo = 0;

exit:
    return;
}


/*
**  BdaDeleteFilterContextByValue()
**
**  Finds the given BDA Filter Context in the Filter
**  context list and removes it.
**
**  This function is provided as a callback when the Filter Context is
**  added to the KSFilter's Object Bag.  This allows KS to clean up the
**  context when the filter is unexpectedly closed.
**
** Arguments:
**
**
** Returns:
**
**
**
** Side Effects:  none
*/

BDA_CONTEXT_LIST    FilterContextList = { 0, 0, 4, NULL, 0, FALSE};

STDMETHODIMP_(VOID)
BdaDeleteFilterContextByValue(
    PVOID       pFilterCtx
    )
{
    BdaDestructFilterContext( (PBDA_FILTER_CONTEXT) pFilterCtx);

    BdaDeleteContextEntryByValue( &FilterContextList,
                                  pFilterCtx
                                );
}


/*
**  BdaCreateFilterContext()
**
**  Finds or creates a BDA Filter Context that corresponds
**  to the given KS Filter.
**
** Arguments:
**
**
** Returns:
**
**
**
** Side Effects:  none
*/

STDMETHODIMP_(NTSTATUS)
BdaCreateFilterContext(
    PKSFILTER               pKSFilter,
    PBDA_FILTER_CONTEXT *   ppFilterCtx
    )
{
    NTSTATUS                    status = STATUS_SUCCESS;

    status = BdaCreateContextEntry( &FilterContextList,
                                    pKSFilter,
                                    sizeof( BDA_FILTER_CONTEXT),
                                    (PVOID *) ppFilterCtx
                                  );
    if (!NT_SUCCESS( status))
    {
        goto errExit;
    }

    status = KsAddItemToObjectBag( pKSFilter->Bag,
                                   *ppFilterCtx,
                                   BdaDeleteFilterContextByValue
                                 );

    (*ppFilterCtx)->pKSFilter = pKSFilter;

errExit:
    return status;
}


/*
**  BdaGetFilterContext()
**
**  Finds a BDA Filter Context that corresponds
**  to the given KS Filter Instance.
**
** Arguments:
**
**
** Returns:
**
**
**
** Side Effects:  none
*/

STDMETHODIMP_(NTSTATUS)
BdaGetFilterContext(
    PKSFILTER                       pKSFilter,
    PBDA_FILTER_CONTEXT *           ppFilterCtx
    )
{
    NTSTATUS                    status = STATUS_SUCCESS;

    status = BdaFindContextEntry( &FilterContextList,
                                  pKSFilter,
                                  (PVOID *) ppFilterCtx
                                );

    return status;
}


/*
**  BdaDeleteFilterContext()
**
**  Deletes a BDA Filter Context.
**
** Arguments:
**
**
** Returns:
**
**
**
** Side Effects:  none
*/

STDMETHODIMP_(NTSTATUS)
BdaDeleteFilterContext(
    PVOID               pvReference
    )
{
    NTSTATUS                    status = STATUS_SUCCESS;
    ULONG                       uliPath;
    PBDA_FILTER_CONTEXT         pFilterCtx;

    status = BdaGetFilterContext( (PKSFILTER) pvReference, &pFilterCtx);
    if (status == STATUS_SUCCESS)
    {
        BdaDestructFilterContext( pFilterCtx);
    }

    status = BdaDeleteContextEntry( &FilterContextList,
                                    pvReference
                                  );
    return status;
}


/*
**  BdaGetControllingPinType()
**
**  
**
** Arguments:
**
**
** Returns:
**
**
**
** Side Effects:  none
*/

STDMETHODIMP_(NTSTATUS)
BdaGetControllingPinType( 
    ULONG                       ulNodeType,
    ULONG                       ulInputPinType,
    ULONG                       ulOutputPinType,
    PBDA_FILTER_CONTEXT         pFilterCtx,
    PULONG                      pulControllingPinType
    )
{
    NTSTATUS                    status = STATUS_NOT_FOUND;
    ULONG                       ulControllingPinType;
    ULONG                       uliPath;
    const KSFILTER_DESCRIPTOR * pKSFilterDescriptor;

    ASSERT( pFilterCtx);
    ASSERT( pFilterCtx->pBdaFilterTemplate);
    ASSERT( pFilterCtx->pBdaFilterTemplate->pFilterDescriptor);

    if (   !pFilterCtx
        || !pFilterCtx->pBdaFilterTemplate
        || !pFilterCtx->pBdaFilterTemplate->pFilterDescriptor
       )
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

    if (   !pFilterCtx->ulcPathInfo
        || !pFilterCtx->argpPathInfo
        || !pFilterCtx->pBdaFilterTemplate->pFilterDescriptor->Connections
       )
    {
        goto errExit;
    }

    pKSFilterDescriptor = pFilterCtx->pBdaFilterTemplate->pFilterDescriptor;

    for (uliPath = 0; uliPath < pFilterCtx->ulcPathInfo; uliPath++)
    {
        PBDA_PATH_INFO      pPathInfo;
        ULONG               uliPathEntry;

        pPathInfo = pFilterCtx->argpPathInfo[uliPath];

        if (   !pPathInfo
            || (pPathInfo->ulInputPin != ulInputPinType)
            || (pPathInfo->ulOutputPin != ulOutputPinType)
           )
        {
            //  This is not the path for this pin pair.
            //
            continue;
        }

        //  Search the Path for the given node type.
        //
        ulControllingPinType = ulInputPinType;
        for ( uliPathEntry = 0
            ; uliPathEntry < pPathInfo->ulcPathEntries
            ; uliPathEntry++
            )
        {
            ULONG                           uliConnection;

            //  If we encounter topology joint then switch the controlling
            //  pin to be the output pin.
            //
            if (pPathInfo->rgPathEntries[uliPathEntry].fJoint)
            {
                ulControllingPinType = ulOutputPinType;
            }

            uliConnection = pPathInfo->rgPathEntries[uliPathEntry].uliConnection;
            if (pKSFilterDescriptor->Connections[uliConnection].ToNode == ulNodeType)
            {
                //  We found the controlling pin type for the node type.
                //  Indicate success and set the output parameter.
                //
                status = STATUS_SUCCESS;
                *pulControllingPinType = ulControllingPinType;
                break;
            }
        }

        if (uliPathEntry < pPathInfo->ulcPathEntries)
        {
            //  We found the controlling pin type for the node type.
            //
            break;
        }
    }
    
errExit:
    return status;
}


/*
**  BdaFilterInitTopologyData()
**
**  Initializes the common BDA filter context's topology info.
**
** Arguments:
**
**
** Returns:
**
**
**
** Side Effects:  none
*/

STDMETHODIMP_(NTSTATUS)
BdaFilterInitTopologyData(
    PBDA_FILTER_CONTEXT     pFilterCtx   
    )
{
    NTSTATUS                    status = STATUS_SUCCESS;
    ULONG                       ulcTemplateNodes;
    PBDA_NODE_CONTROL_INFO      pNodeControlInfo = NULL;

    ASSERT( pFilterCtx);
    ASSERT( pFilterCtx->pKSFilter);
    ASSERT( pFilterCtx->pBdaFilterTemplate);
    ASSERT( pFilterCtx->pBdaFilterTemplate->pFilterDescriptor);

    if (   !pFilterCtx
        || !pFilterCtx->pBdaFilterTemplate
        || !pFilterCtx->pBdaFilterTemplate->pFilterDescriptor
        || !pFilterCtx->pKSFilter
       )
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

#ifdef REMOVE

    ulcTemplateNodes 
        = pFilterCtx->pBdaFilterTemplate->pFilterDescriptor->NodeDescriptorsCount;

    if (ulcTemplateNodes)
    {
        PKSNODE_DESCRIPTOR  pCurNode;
        ULONG               uliNode;

        ASSERT( pFilterCtx->pBdaFilterTemplate->pFilterDescriptor->NodeDescriptors);
        ASSERT( pFilterCtx->pBdaFilterTemplate->pFilterDescriptor->NodeDescriptorSize);

        //  Allocate an array of node control info structures
        //
        pNodeControlInfo = ExAllocatePool( 
                               NonPagedPool, 
                               ulcTemplateNodes * sizeof( BDA_NODE_CONTROL_INFO)
                               );
        if (!pNodeControlInfo)
        {
            status = STATUS_NO_MEMORY;
            goto errExit;
        }
        RtlZeroMemory( pNodeControlInfo,
                       ulcTemplateNodes * sizeof( BDA_NODE_CONTROL_INFO)
                       );

        //  Add the allocation to the KS Filter's object bag so that it
        //  will be freed on filter destruction.
        //
        status = KsAddItemToObjectBag( pFilterCtx->pKSFilter->Bag,
                                       pNodeControlInfo,
                                       NULL
                                       );

        //  Point the BDA Filter Context at the node control info.
        //
        pFilterCtx->argNodeControlInfo = pNodeControlInfo;
    
        //  Determine the contolling pin type for each node type and fill
        //  it in to the node control array
        //
        for ( uliNode = 0
            ; uliNode < ulcTemplateNodes
            ; uliNode++, pNodeControlInfo++
            )
        {
            //  BdaSup.sys always uses the index of the node descriptor as
            //  the node type.
            //
            pNodeControlInfo->ulNodeType = uliNode;

            //  Determine which template pin type controls this node type.
            //
            status = BdaGetControllingPinType( 
                         uliNode, 
                         pFilterCtx->pBdaFilterTemplate,
                         &pNodeControlInfo->ulControllingPinType
                         );
            if (status != STATUS_SUCCESS)
            {
                goto errExit;
            }
            
            //  Add the node control info as we determine it.
            //
            pFilterCtx->ulcNodeControlInfo++;
        }
    }
#endif // REMOVE

errExit:
    return status;
}


/*
**  BdaAddPinFactoryContext()
**
**  Adds pin factory information to the array of pin factory context
**  structures for this filter instance.  It will enlarge the array
**  if necessary.
**  NOTE!  Since the array is an array of structure NOT pointers to
**  structures, AND since the array can be moved, one should NOT keep
**  pointers to the pin factory context entries.
**
** Arguments:
**
**
** Returns:
**
**
**
** Side Effects:  none
*/

STDMETHODIMP_(NTSTATUS)
BdaCreatePinFactoryContext(
    PKSFILTER                       pKSFilter,
    PBDA_FILTER_CONTEXT             pFilterCtx,
    ULONG                           uliPinId,
    ULONG                           ulPinType
    )
{
    NTSTATUS                    status = STATUS_SUCCESS;


    //  Add the Pin Factory info to the filter context.
    //
    if (uliPinId >= pFilterCtx->ulcPinFactoriesMax)
    {
        //  If there isn't enough room then add more.
        //
        PBDA_PIN_FACTORY_CONTEXT    argNewPinCtx = NULL;
        PVOID                       pvTemp;
        ULONG                       ulcPinFactoriesMax;

        ulcPinFactoriesMax = uliPinId + BDA_PIN_STORAGE_INCREMENT;

        argNewPinCtx = ExAllocatePool( 
                               NonPagedPool,
                               ulcPinFactoriesMax * sizeof(BDA_PIN_FACTORY_CONTEXT)
                               );
        if (!argNewPinCtx)
        {
            status = STATUS_NO_MEMORY;
            goto errExit;
        }
        
        if (pFilterCtx->argPinFactoryCtx)
        {

	    // argNewPinCtx, pFilterCtx->argPinFactoryCtx are big enough (allocated in this file)
            RtlMoveMemory( argNewPinCtx,
                           pFilterCtx->argPinFactoryCtx,
                           pFilterCtx->ulcPinFactoriesMax * sizeof(BDA_PIN_FACTORY_CONTEXT)
                           );
        }

        KsAddItemToObjectBag( pKSFilter->Bag,
                              argNewPinCtx,
                              NULL
                              );

        pvTemp = pFilterCtx->argPinFactoryCtx;
        pFilterCtx->argPinFactoryCtx = argNewPinCtx;
        pFilterCtx->ulcPinFactoriesMax = ulcPinFactoriesMax;

        KsRemoveItemFromObjectBag( pKSFilter->Bag,
                                   pvTemp,
                                   TRUE
                                   );
    }

    //  Fill in the pin factory context information.
    //
    pFilterCtx->argPinFactoryCtx[uliPinId].ulPinType = ulPinType;
    pFilterCtx->argPinFactoryCtx[uliPinId].ulPinFactoryId = uliPinId;
    if (uliPinId >= pFilterCtx->ulcPinFactories)
    {
        pFilterCtx->ulcPinFactories = uliPinId + 1;

    }

errExit:
    return status;
}


/*
**  BdaInitFilter()
**
**  Creates a BDA filter context for use by BdaCreatePinFactory etc.
**
** Arguments:
**
**
** Returns:
**
**
**
** Side Effects:  none
*/

STDMETHODIMP_(NTSTATUS)
BdaInitFilter(
    PKSFILTER                       pKSFilter,
    const BDA_FILTER_TEMPLATE *     pBdaFilterTemplate
    )
{
    NTSTATUS                    status = STATUS_SUCCESS;
    PBDA_FILTER_FACTORY_CONTEXT pFilterFactoryCtx = NULL;
    PBDA_FILTER_CONTEXT         pFilterCtx = NULL;
    PKSFILTERFACTORY            pKSFilterFactory = NULL;
    ULONG                       ulcPinFactoriesMax;
    const KSFILTER_DESCRIPTOR * pInitialFilterDescriptor = NULL;

    status = BdaFindContextEntry( &FilterContextList,
                                  pKSFilter,
                                  (PVOID *) &pFilterCtx
                                );
    if (NT_SUCCESS( status))
    {
        status = STATUS_SHARING_VIOLATION;
        goto errExit;
    }
    if (status != STATUS_NOT_FOUND)
    {
        goto errExit;
    }


    //  Get the filter factory context so that we can determine
    //  the initial pin list.
    //
    pKSFilterFactory = KsFilterGetParentFilterFactory( pKSFilter);

    ASSERT( pKSFilterFactory);

    if (!pKSFilterFactory)
    {
        status = STATUS_INVALID_DEVICE_STATE;
        goto errExit;
    }

    status = BdaFindContextEntry( &FilterFactoryContextList,
                                  pKSFilterFactory,
                                  (PVOID *) &pFilterFactoryCtx
                                );
    if (!NT_SUCCESS( status))
    {
        goto errExit;
    }

    if (!pFilterFactoryCtx)
    {
        status = STATUS_INVALID_DEVICE_STATE;
        goto errExit;
    }

    pInitialFilterDescriptor = pFilterFactoryCtx->pInitialFilterDescriptor;

    //  Create a BDA filter context and put it in the list so we can
    //  find it when BDA calls are made relative to the filter.
    //
    status = BdaCreateFilterContext( pKSFilter, &pFilterCtx);
    if (status != STATUS_SUCCESS)
    {
        goto errExit;
    }

    //  Point the BDA filter context at the template topology for the
    //  filter.
    //
    if (pBdaFilterTemplate)
    {
        pFilterCtx->pBdaFilterTemplate = pBdaFilterTemplate;
    }
    else
    {
        pFilterCtx->pBdaFilterTemplate
            = pFilterFactoryCtx->pBdaFilterTemplate;
    }
    
    //  Expand the template topology information into a list
    //  of paths keyed by the input-output pin type pair.
    //
    status = BdaCreateTemplatePaths( pFilterCtx->pBdaFilterTemplate,
                                     &pFilterCtx->ulcPathInfo,
                                     &pFilterCtx->argpPathInfo
                                     );
    if (!NT_SUCCESS( status))
    {
        goto errExit;
    }

    //$REVIEW - Should we allow filters with no input-output paths?
    //
    ASSERT( pFilterCtx->ulcPathInfo);
    ASSERT( pFilterCtx->argpPathInfo);

    //  Allocate space for the Pin Factory context information
    //
    ulcPinFactoriesMax = pBdaFilterTemplate->pFilterDescriptor->PinDescriptorsCount;
    ulcPinFactoriesMax += BDA_PIN_STORAGE_INCREMENT;
    pFilterCtx->argPinFactoryCtx 
        = ExAllocatePool( NonPagedPool,
                          ulcPinFactoriesMax * sizeof( BDA_PIN_FACTORY_CONTEXT)
                          );
    if (!pFilterCtx->argPinFactoryCtx)
    {
        status = STATUS_NO_MEMORY;
        goto errExit;
    }
    pFilterCtx->ulcPinFactories = 0;
    pFilterCtx->ulcPinFactoriesMax = ulcPinFactoriesMax;


    //  Loop through each initial pin descriptor and fill in the pin
    //  context info.
    //
    if (pInitialFilterDescriptor && pInitialFilterDescriptor->PinDescriptors)
    {
        ULONG   ulcbPinDescriptor;
        ULONG   uliPinType;

        if (pInitialFilterDescriptor->PinDescriptorsCount > pFilterCtx->ulcPinFactoriesMax)
        {
            status = STATUS_INVALID_DEVICE_STATE;
            goto errExit;
        }

        ulcbPinDescriptor = pInitialFilterDescriptor->PinDescriptorSize;
        for ( uliPinType = 0
            ; uliPinType < pInitialFilterDescriptor->PinDescriptorsCount
            ; uliPinType++
            )
        {
            ULONG   ulPinId;

            //  It is a BDA requirement that the index of all pins listed in the initial
            //  filter descriptor correspond to the index of its pin type
            //  in the BDA Template Descriptor.
            //

            status = BdaCreatePin( pKSFilter,
                                   uliPinType,
                                   &ulPinId
                                   );
            if (status != STATUS_SUCCESS)
            {
                goto errExit;
            }

            //
            //  We do not "CreateTopology" on the initial pins.  The
            //  initial pins are usually only input pins.  The Network
            //  Provider will create output pins and "CreateTopology".
            //
        }
    }


errExit:
    return status;
}


/*
**  BdaUninitFilter()
**
**  Deletes the BDA filter context for use by BdaCreatePinFactory etc.
**
** Arguments:
**
**
** Returns:
**
**
**
** Side Effects:  none
*/

STDMETHODIMP_(NTSTATUS)
BdaUninitFilter(
    PKSFILTER                       pKSFilter
    )
{
    NTSTATUS                    status = STATUS_SUCCESS;
#ifdef NO_KS_OBJECT_BAG
    status = BdaDeleteContextEntry( &FilterContextList,
                                    pKSFilter
                                );
    if (!NT_SUCCESS( status))
    {
        goto errExit;
    }

errExit:
#endif // def NO_KS_OBJECT_BAG
    return status;
}


/*
**  BdaCreateFilterFactoryEx()
**
**  Initializes the common BDA filter context.
**
** Arguments:
**
**
** Returns:
**
**
**
** Side Effects:  none
*/

STDMETHODIMP_(NTSTATUS)
BdaCreateFilterFactoryEx(
    PKSDEVICE                       pKSDevice,
    const KSFILTER_DESCRIPTOR *     pInitialFilterDescriptor,
    const BDA_FILTER_TEMPLATE *     pBdaFilterTemplate,
    PKSFILTERFACTORY *              ppKSFilterFactory
    )
{
    NTSTATUS                    status = STATUS_SUCCESS;
    PBDA_FILTER_FACTORY_CONTEXT pFilterFactoryCtx = NULL;
    PKSFILTERFACTORY            pKSFilterFactory = NULL;
    PKSFILTER_DESCRIPTOR        pFilterDescriptor = NULL;
    PKSAUTOMATION_TABLE         pNewAutomationTable = NULL;
    
    ASSERT( pKSDevice);
    if (!pKSDevice)
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }
    ASSERT( pInitialFilterDescriptor);
    if (!pInitialFilterDescriptor)
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }
    ASSERT( pBdaFilterTemplate);
    if (!pBdaFilterTemplate)
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

    //  Create a copy of the filter factory descriptor information and
    //  remove any pins and connections.  These will be added when
    //  the filter is initialized by BDAInitFilter.
    //
    pFilterDescriptor = ExAllocatePool( NonPagedPool,
                                        sizeof( KSFILTER_DESCRIPTOR)
                                        );
    if (!pFilterDescriptor)
    {
        status = STATUS_NO_MEMORY;
        goto errExit;
    }
    *pFilterDescriptor = *pInitialFilterDescriptor;
    pFilterDescriptor->PinDescriptorsCount = 0;
    pFilterDescriptor->PinDescriptors = NULL;
    pFilterDescriptor->NodeDescriptorsCount = 0;
    pFilterDescriptor->NodeDescriptors = NULL;
    pFilterDescriptor->ConnectionsCount = 0;
    pFilterDescriptor->Connections = NULL;
    
    status = KsMergeAutomationTables( 
                 &pNewAutomationTable,
                 (PKSAUTOMATION_TABLE) (pFilterDescriptor->AutomationTable),
                 (PKSAUTOMATION_TABLE) &BdaDefaultFilterAutomation,
                 NULL
                 );
    if (status != STATUS_SUCCESS)
    {
        goto errExit;
    }
    if (!pNewAutomationTable)
    {
        status = STATUS_NO_MEMORY;
        goto errExit;
    }
    pFilterDescriptor->AutomationTable = pNewAutomationTable;

    //$BUG - Check Filter Factory Dispatch for Filter Close.  If none
    //$BUG - we must add BdaDeleteFilterFactory to clean up.
    
    //  Create the KSFilterFactory
    //
    status = KsCreateFilterFactory(
                pKSDevice->FunctionalDeviceObject,
                pFilterDescriptor,
                NULL,   // RefString
                NULL,   // SecurityDescriptor
                0,      // CreateItemFlags
                NULL,   // SleepCallback
                NULL,   // WakeCallback
                &pKSFilterFactory
                );

    if ((status != STATUS_SUCCESS) || !pKSFilterFactory)
    {
        goto errExit;
    }


    //  Add our copy of the Filter Factory's new automation table to the
    //  KSFilterFactory's object bag.  This insures the memory will
    //  be freed when the filter factory is destroyed.
    //
    if (   pNewAutomationTable
        && (pNewAutomationTable != &BdaDefaultFilterAutomation)
       )
    {
        KsAddItemToObjectBag( pKSFilterFactory->Bag,
                              pNewAutomationTable,
                              NULL
                              );
    }
    pNewAutomationTable = NULL;


    //  Add our copy of the Filter Factory's descriptor to the
    //  KSFilterFactory's object bag.  This insures the memory will
    //  be freed when the filter factory is destroyed.
    //
    KsAddItemToObjectBag( pKSFilterFactory->Bag,
                          pFilterDescriptor,
                          NULL
                          );
    pFilterDescriptor = NULL;


    //  Merge our default filter automation table onto the filter
    //  factory descriptor
    //
    status = KsEdit( pKSFilterFactory, 
                     &(pKSFilterFactory->FilterDescriptor->AutomationTable),
                     'SadB'
                     );
    if (status != STATUS_SUCCESS)
    {
        goto errExit;
    }


    //  Create a filter factory context for BdaSup to use.
    //
    status = BdaCreateFilterFactoryContext( pKSFilterFactory,
                                            &pFilterFactoryCtx
                                            );
    if ((status != STATUS_SUCCESS) || !pFilterFactoryCtx)
    {
        KsDeleteFilterFactory( pKSFilterFactory);
        goto errExit;
    }

    //  Allow for the filter factory to use a default filter template
    //  topology when it creates a filter
    //
    //$REVIEW
    pFilterFactoryCtx->pInitialFilterDescriptor = pInitialFilterDescriptor;
    pFilterFactoryCtx->pBdaFilterTemplate = pBdaFilterTemplate;
    pFilterFactoryCtx->pKSFilterFactory = pKSFilterFactory;

    if (ppKSFilterFactory)
    {
        *ppKSFilterFactory = pKSFilterFactory;
    }

errExit:
    if (pFilterDescriptor)
    {
        ExFreePool( pFilterDescriptor);
        pFilterDescriptor = NULL;
    }

    if (   pNewAutomationTable
        && (pNewAutomationTable != &BdaDefaultFilterAutomation)
       )
    {
        ExFreePool( pNewAutomationTable);
        pNewAutomationTable = NULL;
    }

    return status;
}


/*
**  BdaCreateFilterFactory()
**
**  Initializes the common BDA filter context.
**
** Arguments:
**
**
** Returns:
**
**
**
** Side Effects:  none
*/

STDMETHODIMP_(NTSTATUS)
BdaCreateFilterFactory(
    PKSDEVICE                       pKSDevice,
    const KSFILTER_DESCRIPTOR *     pInitialFilterDescriptor,
    const BDA_FILTER_TEMPLATE *     pBdaFilterTemplate
    )
{
    NTSTATUS    Status = STATUS_SUCCESS;

    Status = BdaCreateFilterFactoryEx( pKSDevice,
                                       pInitialFilterDescriptor,
                                       pBdaFilterTemplate,
                                       NULL
                                       );
    return Status;
}


/*
**  BdaFilterFactoryUpdateCacheData()
**
**  Updates the pin data cache for the given filter factory.
**  The function will update the cached information for all pin factories
**  exposed by the given filter factory.  
**  
**  If the option filter descriptor is given, the function will update
**  the pin data cache for all pins listed in the given filter descriptor
**  instead of those in the filter factory.
**
**  Drivers will call this to update the pin data cache for all
**  pins that may be exposed by the filter factory.  The driver will
**  provide a filter descriptor listing pins that are not initially exposed
**  by the filter factory (this is usually the same as the template filter
**  descriptor).
**
** Arguments:
**
**
** Returns:
**
**
**
** Side Effects:  none
*/

STDMETHODIMP_(NTSTATUS)
BdaFilterFactoryUpdateCacheData(
    IN PKSFILTERFACTORY             pFilterFactory,
    IN const KSFILTER_DESCRIPTOR *  pFilterDescriptor OPTIONAL
    )
{
    NTSTATUS    Status = STATUS_SUCCESS;

    Status = KsFilterFactoryUpdateCacheData( pFilterFactory,
                                             pFilterDescriptor
                                             );

    return Status;
}


/*
**  BdaSyncTopology()
**
**  This routine updates the existing topology to complete all
**  Pending topology changes.
**
** Arguments:
**
**
** Returns:
**
**
**
** Side Effects:  none
*/

STDMETHODIMP_(NTSTATUS)
BdaSyncTopology(
    PKSFILTER       pKSFilter
    )
{
    NTSTATUS    Status = STATUS_SUCCESS;

    //$BUG  Implement topology sync.

    return STATUS_NOT_IMPLEMENTED;
}


// -------------------------------------------------------------------
// BDA Filter Global Property Set functions
// -------------------------------------------------------------------


/*
** BdaPropertyNodeTypes ()
**
**    Returns a list of ULONGS.
**
** Arguments:
**
**
** Returns:
**
** Side Effects:  none
*/
STDMETHODIMP_(NTSTATUS)
BdaPropertyNodeTypes(
    IN PIRP         Irp,
    IN PKSPROPERTY  Property,
    OUT ULONG *     pulProperty
    )
{
    NTSTATUS                    status = STATUS_SUCCESS;
    PKSFILTER                   pKSFilter;
    PBDA_FILTER_CONTEXT         pFilterCtx;
    const KSFILTER_DESCRIPTOR * pTemplateDesc;

    ASSERT( Irp);
    if (!Irp)
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }
    ASSERT( Property);
    if (!Property)
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

    pKSFilter = KsGetFilterFromIrp( Irp);

    status = BdaGetFilterContext( pKSFilter, &pFilterCtx);

    if (status != STATUS_SUCCESS)
    {
        goto errExit;
    }

    ASSERT( pFilterCtx);
    ASSERT( pFilterCtx->pBdaFilterTemplate);
    pTemplateDesc = pFilterCtx->pBdaFilterTemplate->pFilterDescriptor;
    ASSERT( pTemplateDesc);
    ASSERT( pTemplateDesc->NodeDescriptorSize == sizeof( KSNODE_DESCRIPTOR));

    if (pulProperty)
    {
	ULONG uliNodeDesc;
	if (OutputBufferLenFromIrp(Irp) < pTemplateDesc->NodeDescriptorsCount * sizeof(ULONG))
	    return STATUS_BUFFER_TOO_SMALL;
	
        for ( uliNodeDesc = 0
            ; uliNodeDesc < pTemplateDesc->NodeDescriptorsCount
            ; uliNodeDesc++, pulProperty++
            )
        {
            //  For this implementation, the NodeType is just the
            //  index into the NodeDescriptor table.
            //
            *pulProperty = uliNodeDesc;
        }

        Irp->IoStatus.Information = uliNodeDesc * sizeof( ULONG);
    }
    else
    {
        status = STATUS_MORE_ENTRIES;

        //  If there is no place to put the property then just
        //  return the data size.
        //
        Irp->IoStatus.Information
            = pTemplateDesc->NodeDescriptorsCount * sizeof( ULONG);
    }


errExit:
    return status;
}


/*
** BdaPropertyNodeDescriptors ()
**
**    Returns a list of GUIDS.  The index of the GUID in the list
**    corresponds to the Node type.
**
** Arguments:
**
**
** Returns:
**
** Side Effects:  none
*/
STDMETHODIMP_(NTSTATUS)
BdaPropertyNodeDescriptors(
    IN PIRP                     Irp,
    IN PKSPROPERTY              Property,
    OUT BDANODE_DESCRIPTOR *    pNodeDescripterProperty
    )
{
    NTSTATUS                    status = STATUS_SUCCESS;
    PKSFILTER                   pKSFilter;
    PBDA_FILTER_CONTEXT         pFilterCtx;
    const KSFILTER_DESCRIPTOR * pTemplateDesc;
    ULONG                       ulcPropertyEntries;
    ULONG                       ulcNodes;

    ASSERT( Irp);
    if (!Irp)
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }
    ASSERT( Property);
    if (!Property)
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

    //  Determine how many entries the input buffer can hold.
    //
    ulcPropertyEntries = OutputBufferLenFromIrp( Irp);
    ulcPropertyEntries = ulcPropertyEntries / sizeof( BDANODE_DESCRIPTOR);

    pKSFilter = KsGetFilterFromIrp( Irp);

    status = BdaGetFilterContext( pKSFilter, &pFilterCtx);

    if (status != STATUS_SUCCESS)
    {
        goto errExit;
    }

    ASSERT( pFilterCtx);

    if (   !pFilterCtx
        || !pFilterCtx->pBdaFilterTemplate
       )
    {
        status = STATUS_INVALID_DEVICE_STATE;
        goto errExit;
    }

    pTemplateDesc = pFilterCtx->pBdaFilterTemplate->pFilterDescriptor;
    ASSERT( pTemplateDesc);
    if (!pTemplateDesc)
    {
        status = STATUS_INVALID_DEVICE_STATE;
        goto errExit;
    }

    ASSERT( pTemplateDesc->NodeDescriptorSize == sizeof( KSNODE_DESCRIPTOR));

    //  Handle the case of a NULL NodeDesriptor array as 0 nodes.
    //
    if (!pTemplateDesc->NodeDescriptors)
    {
        ulcNodes = 0;
    }
    else
    {
        ulcNodes = pTemplateDesc->NodeDescriptorsCount;
    }

    if (!pNodeDescripterProperty || (ulcPropertyEntries < ulcNodes))
    {
        status = STATUS_MORE_ENTRIES;

        //  If there is no place to put the property then just
        //  return the data size.
        //
    }
    else
    {
        const KSNODE_DESCRIPTOR *   pNodeDesc;
        ULONG                       uliNodeDesc;
    
        pNodeDesc = pTemplateDesc->NodeDescriptors;

        if (pNodeDesc)
        {
	    if (OutputBufferLenFromIrp(Irp) < ulcNodes * sizeof(BDANODE_DESCRIPTOR))
		return STATUS_BUFFER_TOO_SMALL;
	    
            for ( uliNodeDesc = 0
                ; uliNodeDesc < ulcNodes
                ; uliNodeDesc++, pNodeDescripterProperty++
                )
            {
                //  For this implementation, the NodeType is just the
                //  index into the NodeDescriptor table.
                //
                pNodeDescripterProperty->ulBdaNodeType = uliNodeDesc;

                //  Fill in the function GUID for the node type.
                //  
                if (pNodeDesc->Type)
                {
                    pNodeDescripterProperty->guidFunction = *pNodeDesc->Type;
                }
                else 
                {
                    pNodeDescripterProperty->guidFunction = GUID_NULL;
                }

                //  Fill in the GUID that represents a displayable name
                //  for the node type.
                if (pNodeDesc->Name)
                {
                    pNodeDescripterProperty->guidName = *pNodeDesc->Name;
                }
                else
                {
                    pNodeDescripterProperty->guidName = GUID_NULL;
                }

                //  Point at the next node descriptor
                //
                pNodeDesc = (const KSNODE_DESCRIPTOR *)
                            ((BYTE *) pNodeDesc + pTemplateDesc->NodeDescriptorSize);
            }
        }
    }

    Irp->IoStatus.Information = ulcNodes * sizeof( BDANODE_DESCRIPTOR);


errExit:
    return status;
}


/*
** BdaPropertyNodeProperties ()
**
**    Returns a list of GUIDS.  The guid for each property set
**    supported by the specified node is included in the list.
**
** Arguments:
**
**
** Returns:
**
** Side Effects:  none
*/
STDMETHODIMP_(NTSTATUS)
BdaPropertyNodeProperties(
    IN PIRP         Irp,
    IN PKSP_NODE    Property,
    OUT GUID *      pguidProperty
    )
{
    NTSTATUS                    status = STATUS_SUCCESS;
    PKSFILTER                   pKSFilter;
    PBDA_FILTER_CONTEXT         pFilterCtx;
    const KSFILTER_DESCRIPTOR * pTemplateDesc;
    const KSNODE_DESCRIPTOR *   pNodeDesc;
    const KSAUTOMATION_TABLE*   pAutomationTable;
    ULONG                       uliNodeDesc;
    ULONG                       ulcInterfaces;
    ULONG                       ulcPropertyEntries;

    ASSERT( Irp);
    if (!Irp)
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }
    ASSERT( Property);
    if (!Property)
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

    //  Determine how many entries the input buffer can hold.
    //
    ulcPropertyEntries = OutputBufferLenFromIrp( Irp);
    ulcPropertyEntries = ulcPropertyEntries / sizeof( GUID);

    pKSFilter = KsGetFilterFromIrp( Irp);
    if (!pKSFilter)
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

    status = BdaGetFilterContext( pKSFilter, &pFilterCtx);
    if (status != STATUS_SUCCESS)
    {
        goto errExit;
    }
    ASSERT( pFilterCtx);
    ASSERT( pFilterCtx->pBdaFilterTemplate);
    if (!pFilterCtx->pBdaFilterTemplate)
    {
        status = STATUS_INVALID_DEVICE_STATE;
        goto errExit;
    }
    pTemplateDesc = pFilterCtx->pBdaFilterTemplate->pFilterDescriptor;
    ASSERT( pTemplateDesc);
    if (!pTemplateDesc)
    {
        status = STATUS_INVALID_DEVICE_STATE;
        goto errExit;
    }
    ASSERT( pTemplateDesc->NodeDescriptorSize == sizeof( KSNODE_DESCRIPTOR));

    uliNodeDesc = Property->NodeId;

    if (uliNodeDesc >= pTemplateDesc->NodeDescriptorsCount)
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

    pNodeDesc = pTemplateDesc->NodeDescriptors;
    ASSERT( pNodeDesc);
    if (!pNodeDesc)
    {
        status = STATUS_INVALID_DEVICE_STATE;
        goto errExit;
    }

    ASSERT( pTemplateDesc->NodeDescriptorSize);
    pNodeDesc = (const KSNODE_DESCRIPTOR *)
                ((BYTE *) pNodeDesc + uliNodeDesc * pTemplateDesc->NodeDescriptorSize);

    if (   !pNodeDesc->AutomationTable
        || !pNodeDesc->AutomationTable->PropertySets
       )
    {
        ulcInterfaces =  0;
    }
    else
    {
        ulcInterfaces =  pNodeDesc->AutomationTable->PropertySetsCount;
    }

    if (!pguidProperty || (ulcPropertyEntries < ulcInterfaces))
    {
        status = STATUS_MORE_ENTRIES;

        //  If there is no place to put the property then just
        //  return the data size.
        //
    }
    else
    {
        ULONG                   uliSet;
        const KSPROPERTY_SET *  pPropertySet;
        GUID *                  pguidOut;

        pguidOut = pguidProperty;
        
        pPropertySet = pNodeDesc->AutomationTable->PropertySets;
        if (pPropertySet)
        {
	    if (OutputBufferLenFromIrp(Irp) < ulcInterfaces * sizeof(GUID))
		return STATUS_BUFFER_TOO_SMALL;

            for ( uliSet = 0
                ; uliSet < ulcInterfaces
                ; uliSet++
                )
            {
		RtlMoveMemory( pguidOut,
			       pPropertySet->Set,
			       sizeof( GUID)
			       );
		
                pguidOut += 1;
                pPropertySet += 1;
            }
        }
    }

    Irp->IoStatus.Information = ulcInterfaces * sizeof( GUID);

errExit:
    return status;
}


/*
** BdaPropertyNodeMethods ()
**
**    Returns a list of GUIDS.  The guid for each property set
**    supported by the specified node is included in the list.
**
** Arguments:
**
**
** Returns:
**
** Side Effects:  none
*/
STDMETHODIMP_(NTSTATUS)
BdaPropertyNodeMethods(
    IN PIRP         Irp,
    IN PKSP_NODE    Property,
    OUT GUID *      pguidProperty
    )
{
    NTSTATUS                    status = STATUS_SUCCESS;
    PKSFILTER                   pKSFilter;
    PBDA_FILTER_CONTEXT         pFilterCtx;
    const KSFILTER_DESCRIPTOR * pTemplateDesc;
    const KSNODE_DESCRIPTOR *   pNodeDesc;
    const KSAUTOMATION_TABLE*   pAutomationTable;
    ULONG                       uliNodeDesc;
    ULONG                       ulcInterfaces;

    ASSERT( Irp);
    if (!Irp)
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }
    ASSERT( Property);
    if (!Property)
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

    pKSFilter = KsGetFilterFromIrp( Irp);

    status = BdaGetFilterContext( pKSFilter, &pFilterCtx);

    if (status != STATUS_SUCCESS)
    {
        goto errExit;
    }

    ASSERT( pFilterCtx);
    ASSERT( pFilterCtx->pBdaFilterTemplate);
    pTemplateDesc = pFilterCtx->pBdaFilterTemplate->pFilterDescriptor;
    ASSERT( pTemplateDesc);
    ASSERT( pTemplateDesc->NodeDescriptorSize == sizeof( KSNODE_DESCRIPTOR));

    uliNodeDesc = Property->NodeId;

    if (uliNodeDesc >= pTemplateDesc->NodeDescriptorsCount)
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

    pNodeDesc = pTemplateDesc->NodeDescriptors;
    ASSERT( pTemplateDesc->NodeDescriptorSize);
    pNodeDesc = (const KSNODE_DESCRIPTOR *)
                ((BYTE *) pNodeDesc + uliNodeDesc * pTemplateDesc->NodeDescriptorSize);

    ulcInterfaces =  pNodeDesc->AutomationTable->PropertySetsCount;

    if (pguidProperty)
    {
        ULONG                   uliSet;
        const KSMETHOD_SET *    pMethodSet;
        GUID *                  pguidOut;

        pguidOut = pguidProperty;
        ulcInterfaces = 0;
        
        pMethodSet = pNodeDesc->AutomationTable->MethodSets;
        if (pMethodSet)
        {

	    if (OutputBufferLenFromIrp(Irp) < pNodeDesc->AutomationTable->MethodSetsCount * sizeof(GUID))
		return STATUS_BUFFER_TOO_SMALL;
	    
            for ( uliSet = 0
		 ; uliSet < pNodeDesc->AutomationTable->MethodSetsCount
		 ; uliSet++
		  )
	    {
		RtlMoveMemory( pguidOut,
			       pMethodSet->Set,
			       sizeof( GUID)
			       );

		pguidOut += 1;
		pMethodSet += 1;
		ulcInterfaces += 1;
		
            }
        }

        Irp->IoStatus.Information = ulcInterfaces * sizeof( GUID);
    }
    else
    {
        status = STATUS_MORE_ENTRIES;

        //  If there is no place to put the property then just
        //  return the data size.
        //
        Irp->IoStatus.Information = ulcInterfaces * sizeof( GUID);
    }


errExit:
    return status;
}


/*
** BdaPropertyNodeEvents ()
**
**    Returns a list of GUIDS.  The guid for each event set
**    supported by the specified node is included in the list.
**
** Arguments:
**
**
** Returns:
**
** Side Effects:  none
*/
STDMETHODIMP_(NTSTATUS)
BdaPropertyNodeEvents(
    IN PIRP         Irp,
    IN PKSP_NODE    Property,
    OUT GUID *      pguidProperty
    )
{
    NTSTATUS                    status = STATUS_SUCCESS;
    PKSFILTER                   pKSFilter;
    PBDA_FILTER_CONTEXT         pFilterCtx;
    const KSFILTER_DESCRIPTOR * pTemplateDesc;
    const KSNODE_DESCRIPTOR *   pNodeDesc;
    const KSAUTOMATION_TABLE*   pAutomationTable;
    ULONG                       uliNodeDesc;
    ULONG                       ulcInterfaces;

    ASSERT( Irp);
    if (!Irp)
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }
    ASSERT( Property);
    if (!Property)
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

    pKSFilter = KsGetFilterFromIrp( Irp);

    status = BdaGetFilterContext( pKSFilter, &pFilterCtx);

    if (status != STATUS_SUCCESS)
    {
        goto errExit;
    }

    ASSERT( pFilterCtx);
    ASSERT( pFilterCtx->pBdaFilterTemplate);
    pTemplateDesc = pFilterCtx->pBdaFilterTemplate->pFilterDescriptor;
    ASSERT( pTemplateDesc);
    ASSERT( pTemplateDesc->NodeDescriptorSize == sizeof( KSNODE_DESCRIPTOR));

    uliNodeDesc = Property->NodeId;

    if (uliNodeDesc >= pTemplateDesc->NodeDescriptorsCount)
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

    pNodeDesc = pTemplateDesc->NodeDescriptors;
    ASSERT( pTemplateDesc->NodeDescriptorSize);
    pNodeDesc = (const KSNODE_DESCRIPTOR *)
                ((BYTE *) pNodeDesc + uliNodeDesc * pTemplateDesc->NodeDescriptorSize);

    ulcInterfaces =  pNodeDesc->AutomationTable->PropertySetsCount;

    if (pguidProperty)
    {
        ULONG                   uliSet;
        const KSEVENT_SET *     pEventSet;
        GUID *                  pguidOut;

        pguidOut = pguidProperty;
        ulcInterfaces = 0;
        
        pEventSet = pNodeDesc->AutomationTable->EventSets;
        if (pEventSet)
        {
	    if (OutputBufferLenFromIrp(Irp) < pNodeDesc->AutomationTable->EventSetsCount * sizeof(GUID))
		return STATUS_BUFFER_TOO_SMALL;

            for ( uliSet = 0
                ; uliSet < pNodeDesc->AutomationTable->EventSetsCount
                ; uliSet++
                )
            {
		RtlMoveMemory( pguidOut,
			       pEventSet->Set,
			       sizeof( GUID)
			       );

                pguidOut += 1;
                pEventSet += 1;
                ulcInterfaces += 1;
            }
        }

        Irp->IoStatus.Information = ulcInterfaces * sizeof( GUID);
    }
    else
    {
        status = STATUS_MORE_ENTRIES;

        //  If there is no place to put the property then just
        //  return the data size.
        //
        Irp->IoStatus.Information = ulcInterfaces * sizeof( GUID);
    }


errExit:
    return status;
}


/*
** BdaPropertyPinTypes ()
**
**    Returns a list of GUIDS.  The index of the GUID in the list
**    corresponds to the Node type.
**
** Arguments:
**
**
** Returns:
**
** Side Effects:  none
*/
STDMETHODIMP_(NTSTATUS)
BdaPropertyPinTypes(
    IN PIRP         Irp,
    IN PKSPROPERTY  Property,
    OUT ULONG *     pulProperty
    )
{
    NTSTATUS                    status = STATUS_SUCCESS;
    PKSFILTER                   pKSFilter;
    PBDA_FILTER_CONTEXT         pFilterCtx;
    const KSFILTER_DESCRIPTOR * pTemplateDesc;
    const KSPIN_DESCRIPTOR_EX * pPinDesc;
    ULONG                       uliPinDesc;

    ASSERT( Irp);
    if (!Irp)
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }
    ASSERT( Property);
    if (!Property)
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

    pKSFilter = KsGetFilterFromIrp( Irp);

    status = BdaGetFilterContext( pKSFilter, &pFilterCtx);

    if (status != STATUS_SUCCESS)
    {
        goto errExit;
    }

    ASSERT( pFilterCtx);
    ASSERT( pFilterCtx->pBdaFilterTemplate);
    pTemplateDesc = pFilterCtx->pBdaFilterTemplate->pFilterDescriptor;
    ASSERT( pTemplateDesc);
    ASSERT( pTemplateDesc->PinDescriptorSize == sizeof( KSPIN_DESCRIPTOR_EX));

    if (pulProperty)
    {
	if (OutputBufferLenFromIrp(Irp) < pTemplateDesc->PinDescriptorsCount * sizeof(ULONG))
	    return STATUS_BUFFER_TOO_SMALL;

        for ( uliPinDesc = 0
            ; uliPinDesc < pTemplateDesc->PinDescriptorsCount
            ; uliPinDesc++, pulProperty++
            )
        {
            //  For this implementation, the PinType is just the
            //  index into the PinDescriptor table.
            //
            *pulProperty = uliPinDesc;
        }

        Irp->IoStatus.Information = uliPinDesc * sizeof( ULONG);
    }
    else
    {
        status = STATUS_BUFFER_OVERFLOW;

        //  If there is no place to put the property then just
        //  return the data size.
        //
        Irp->IoStatus.Information
            = pTemplateDesc->PinDescriptorsCount * sizeof( ULONG);
    }

errExit:
    return status;
}


/*
** BdaPropertyTemplateConnections ()
**
**    Returns a list of KSTOPOLOGY_CONNECTIONS.  The list of connections
**    describs how pin types and node types are connected in the template
**    topology
**
** Arguments:
**
**
** Returns:
**
** Side Effects:  none
*/
STDMETHODIMP_(NTSTATUS)
BdaPropertyTemplateConnections(
    IN PIRP                     Irp,
    IN PKSPROPERTY              Property,
    OUT PKSTOPOLOGY_CONNECTION  pConnectionProperty
    )
{
    NTSTATUS                        status = STATUS_SUCCESS;
    PKSFILTER                       pKSFilter;
    PBDA_FILTER_CONTEXT             pFilterCtx;
    const KSFILTER_DESCRIPTOR *     pTemplateDesc;
    const KSTOPOLOGY_CONNECTION *   pConnection;
    ULONG                           uliConnection;

    ASSERT( Irp);
    if (!Irp)
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }
    ASSERT( Property);
    if (!Property)
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

    pKSFilter = KsGetFilterFromIrp( Irp);

    status = BdaGetFilterContext( pKSFilter, &pFilterCtx);

    if (status != STATUS_SUCCESS)
    {
        goto errExit;
    }

    ASSERT( pFilterCtx);
    ASSERT( pFilterCtx->pBdaFilterTemplate);
    pTemplateDesc = pFilterCtx->pBdaFilterTemplate->pFilterDescriptor;
    ASSERT( pTemplateDesc);


    if (pConnectionProperty)
    {
        for ( uliConnection = 0, pConnection = pTemplateDesc->Connections
            ; uliConnection < pTemplateDesc->ConnectionsCount
            ; uliConnection++, pConnection++, pConnectionProperty++
            )
        {
            *pConnectionProperty = *pConnection;
        }

        Irp->IoStatus.Information
            = uliConnection * sizeof( KSTOPOLOGY_CONNECTION);
    }
    else
    {
        status = STATUS_BUFFER_OVERFLOW;

        //  If there is no place to put the property then just
        //  return the data size.
        //
        Irp->IoStatus.Information
            = pTemplateDesc->ConnectionsCount * sizeof( KSTOPOLOGY_CONNECTION);
    }

errExit:
    return status;
}


/*
** BdaPinTypeFromPinId()
**
**    Gets the ID of the pin on which to submit node properties, methods
**    and events.
**
** Arguments:
**
**
** Returns:
**
** Side Effects:  none
*/
STDMETHODIMP_(NTSTATUS)
BdaPinTypeFromPinId(
    PBDA_FILTER_CONTEXT         pFilterCtx,
    ULONG                       ulPinId,
    PULONG                      pulPinType
    )
{
    NTSTATUS                        status = STATUS_SUCCESS;

    if (   !pFilterCtx
        || !pFilterCtx->argPinFactoryCtx
        || (ulPinId >= pFilterCtx->ulcPinFactories)
       )
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

    if (pFilterCtx->argPinFactoryCtx[ulPinId].ulPinFactoryId != ulPinId)
    {
        status = STATUS_NOT_FOUND;
        goto errExit;
    }

    *pulPinType = pFilterCtx->argPinFactoryCtx[ulPinId].ulPinType;

errExit:
    return status;
}

/*
** BdaGetControllingPinId ()
**
**    Gets the ID of the pin on which to submit node properties, methods
**    and events.
**
** Arguments:
**
**
** Returns:
**
** Side Effects:  none
*/
STDMETHODIMP_(NTSTATUS)
BdaGetControllingPinId(
    PBDA_FILTER_CONTEXT         pFilterCtx,
    ULONG                       ulInputPinId,
    ULONG                       ulOutputPinId,
    ULONG                       ulNodeType,
    PULONG                      pulControllingPinId
    )
{
    NTSTATUS                        status = STATUS_SUCCESS;
    ULONG                           ulInputPinType = 0;
    ULONG                           ulOutputPinType = -1;
    ULONG                           ulControllingPinType = -1;

    //  Get the input pin type.
    //
    status = BdaPinTypeFromPinId( pFilterCtx, 
                                  ulInputPinId,
                                  &ulInputPinType
                                  );
    if (status != STATUS_SUCCESS)
    {
        goto errExit;
    }


    //  Get the output pin type.
    //
    status = BdaPinTypeFromPinId( pFilterCtx, 
                                  ulOutputPinId,
                                  &ulOutputPinType
                                  );
    if (status != STATUS_SUCCESS)
    {
        goto errExit;
    }

    //  Determine the cotnrolling pin type.
    //
    status = BdaGetControllingPinType( ulNodeType,
                                       ulInputPinType,
                                       ulOutputPinType,
                                       pFilterCtx,
                                       &ulControllingPinType
                                       );
    if (status != STATUS_SUCCESS)
    {
        goto errExit;
    }

    //  Map the controlling pin type to the controlling pin ID.
    //
    if (ulControllingPinType == ulInputPinType)
    {
        *pulControllingPinId = ulInputPinId;
    }
    else if (ulControllingPinType == ulOutputPinType)
    {
        *pulControllingPinId = ulOutputPinId;
    }
    else
    {
        status = STATUS_NOT_FOUND;
    }


errExit:

    return status;
}

/*
** BdaPropertyGetControllingPinId ()
**
**    Gets the ID of the pin on which to submit node properties, methods
**    and events.
**
** Arguments:
**
**
** Returns:
**
** Side Effects:  none
*/
STDMETHODIMP_(NTSTATUS)
BdaPropertyGetControllingPinId(
    IN PIRP                     Irp,
    IN PKSP_BDA_NODE_PIN        Property,
    OUT PULONG                  pulControllingPinId
    )
{
    NTSTATUS                        status = STATUS_SUCCESS;
    PKSFILTER                       pKSFilter;
    PBDA_FILTER_CONTEXT             pFilterCtx;

    ASSERT( Irp);
    if (!Irp)
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }
    ASSERT( Property);
    if (!Property)
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

    pKSFilter = KsGetFilterFromIrp( Irp);

    status = BdaGetFilterContext( pKSFilter, &pFilterCtx);

    if (status != STATUS_SUCCESS)
    {
        goto errExit;
    }

    ASSERT( pFilterCtx);
    if (!pFilterCtx)
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }


    if (pulControllingPinId)
    {

	if (OutputBufferLenFromIrp(Irp) < sizeof(ULONG))
	    return STATUS_BUFFER_TOO_SMALL;
	
        status = BdaGetControllingPinId(
                                        pFilterCtx,
                                        Property->ulInputPinId,
                                        Property->ulOutputPinId,
                                        Property->ulNodeType,
                                        pulControllingPinId
                                        );

        if (status == STATUS_NOT_FOUND)
        {
            //  See if the pins were part of a static filter configuration.
            //
            //$BUG - Pins that are configured without template type information
            //       should always be controlled by the output pin.
            //
            if (Property->ulNodeType == 0)
            {
                *pulControllingPinId = Property->ulInputPinId;
            }
            else
            {
                *pulControllingPinId = Property->ulOutputPinId;
            }

            status = STATUS_SUCCESS;
        }

        Irp->IoStatus.Information = sizeof( ULONG);
    }
    else
    {
        status = STATUS_BUFFER_OVERFLOW;

        //  If there is no place to put the property then just
        //  return the data size.
        //
        Irp->IoStatus.Information = sizeof( ULONG);
    }

errExit:
    return status;
}


/*
** BdaStartChanges ()
**
**    Puts the filter into change state.  All changes to BDA topology
**    and properties changed after this will be in effect only after
**    CommitChanges.
**
** Arguments:
**
**
** Returns:
**
** Side Effects:  none
*/
STDMETHODIMP_(NTSTATUS)
BdaStartChanges(
    IN PIRP         pIrp
    )
{
    ASSERT( pIrp);
    if (!pIrp)
    {
        return STATUS_INVALID_PARAMETER;
    }
    return STATUS_SUCCESS;
}


/*
** BdaCheckChanges ()
**
**    Checks the changes to BDA interfaces that have occured since the
**    last StartChanges.  Returns the result that would have occurred if
**    CommitChanges had been called.
**
** Arguments:
**
**
** Returns:
**
** Side Effects:  none
*/
STDMETHODIMP_(NTSTATUS)
BdaCheckChanges(
    IN PIRP         pIrp
    )
{
    ASSERT( pIrp);
    if (!pIrp)
    {
        return STATUS_INVALID_PARAMETER;
    }
    return STATUS_SUCCESS;
}


/*
** BdaCommitChanges ()
**
**    Checks the changes to BDA interfaces that have occured since the
**    last StartChanges.
**
** Arguments:
**
**
** Returns:
**
** Side Effects:  none
*/
STDMETHODIMP_(NTSTATUS)
BdaCommitChanges(
    IN PIRP         pIrp
    )
{
    ASSERT( pIrp);
    if (!pIrp)
    {
        return STATUS_INVALID_PARAMETER;
    }
    return STATUS_SUCCESS;
}


/*
** BdaGetChangeState ()
**
**    Checks the changes to BDA interfaces that have occured since the
**    last StartChanges.
**
** Arguments:
**
**
** Returns:
**
** Side Effects:  none
*/
STDMETHODIMP_(NTSTATUS)
BdaGetChangeState(
    IN PIRP             pIrp,
    PBDA_CHANGE_STATE   pChangeState
    )
{
    ASSERT( pIrp);
    if (!pIrp)
    {
        return STATUS_INVALID_PARAMETER;
    }
    ASSERT( pChangeState);
    if (!pChangeState)
    {
        return STATUS_INVALID_PARAMETER;
    }
    *pChangeState = BDA_CHANGES_COMPLETE;

    return STATUS_SUCCESS;
}


/*
** BdaMethodCreatePin ()
**
**    Creates a new pin factory for the given pin type.
**
** Arguments:
**
**
** Returns:
**
** Side Effects:  none
*/
STDMETHODIMP_(NTSTATUS)
BdaMethodCreatePin(
    IN PIRP         pIrp,
    IN PKSMETHOD    pKSMethod,
    OUT PULONG      pulPinFactoryID
    )
{
    NTSTATUS        status = STATUS_SUCCESS;

    ASSERT(pIrp);
    if (pIrp)
    {
        PKSFILTER       pKSFilter;
        PKSM_BDA_PIN    pKSPinMethod;
        ULONG           ulPinId;

	if (OutputBufferLenFromIrp(pIrp) < sizeof(ULONG))
	    return STATUS_BUFFER_TOO_SMALL;


        pKSPinMethod = (PKSM_BDA_PIN) pKSMethod;

        pKSFilter = KsGetFilterFromIrp( pIrp);
    
        if (pKSFilter && pKSPinMethod)
        {

            status = BdaCreatePin( pKSFilter,
                                   pKSPinMethod->PinType,
                                   pulPinFactoryID
                                   );
        }
    }
    else
    {
        status = STATUS_INVALID_PARAMETER;
    }

    return status;
}


/*
** BdaMethodDeletePin ()
**
**    Deletes the given pin factory
**
** Arguments:
**
**
** Returns:
**
** Side Effects:  none
*/
STDMETHODIMP_(NTSTATUS)
BdaMethodDeletePin(
    IN PIRP         Irp,
    IN PKSMETHOD    Method,
    OPTIONAL PVOID  pvIgnored
    )
{
    ASSERT( Irp);
    if (!Irp)
    {
        return STATUS_INVALID_PARAMETER;
    }
    return STATUS_SUCCESS;
}


/*
** BdaPropertyGetPinControl ()
**
**    Returns a the BDA ID or BDA Template Type of the Pin.
**
** Arguments:
**
**
** Returns:
**
** Side Effects:  none
*/
STDMETHODIMP_(NTSTATUS)
BdaPropertyGetPinControl(
    IN PIRP         Irp,
    IN PKSPROPERTY  Property,
    OUT ULONG *     pulProperty
    )
{
    NTSTATUS                    status = STATUS_SUCCESS;
    PKSPIN                      pKSPin;
    BDA_PIN_FACTORY_CONTEXT     pinCtx;

    ASSERT( Irp);
    if (!Irp)
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }
    ASSERT( Property);
    if (!Property)
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

    pKSPin = KsGetPinFromIrp( Irp);

    status = BdaGetPinFactoryContext( pKSPin, &pinCtx);

    if (status != STATUS_SUCCESS)
    {
        goto errExit;
    }

    if (pulProperty)
    {
        Irp->IoStatus.Information = sizeof( ULONG);

        switch (Property->Id)
        {
        case KSPROPERTY_BDA_PIN_ID:
            //  Return the BDA ID of this pin
            //
            *pulProperty = pinCtx.ulPinFactoryId;
            break;

        case KSPROPERTY_BDA_PIN_TYPE:
            //  Return the BDA Type of this pin
            //
            *pulProperty = pinCtx.ulPinType;
            break;

        default:
            Irp->IoStatus.Information = 0;
            status = STATUS_INVALID_PARAMETER;
            ASSERT( FALSE);
        }
    }
    else
    {
        status = STATUS_MORE_ENTRIES;

        //  If there is no place to put the property then just
        //  return the data size.
        //
        Irp->IoStatus.Information = sizeof( ULONG);
    }


errExit:
    return status;
}


/*
** BdaValidateNodeProperty ()
**
**    Validates that the IRP is for a Pin and that
**    the property belongs to a node associated with that
**    Pin.
**
** Arguments:
**
**
** Returns:
**
** Side Effects:  none
*/
STDMETHODIMP_(NTSTATUS)
BdaValidateNodeProperty(
    IN PIRP         pIrp,
    IN PKSMETHOD    pKSProperty
    )
{
    ASSERT( pIrp);
    if (!pIrp)
    {
        return STATUS_INVALID_PARAMETER;
    }
    ASSERT( pKSProperty);
    if (!pKSProperty)
    {
        return STATUS_INVALID_PARAMETER;
    }
    return STATUS_SUCCESS;
}


/*
** BdaMethodCreateTopology ()
**
**    Creates the topology between the two given pin factories.
**
** Arguments:
**
**
** Returns:
**
** Side Effects:  none
*/
STDMETHODIMP_(NTSTATUS)
BdaMethodCreateTopology(
    IN PIRP         pIrp,
    IN PKSMETHOD    pKSMethod,
    OPTIONAL PVOID  pvIgnored
    )
{
    NTSTATUS            status = STATUS_SUCCESS;
    PKSFILTER           pKSFilter;
    PKSM_BDA_PIN_PAIR   pKSPinPairMethod;
    ULONG               ulPinId;

    if (pIrp)
    {
        pKSPinPairMethod = (PKSM_BDA_PIN_PAIR) pKSMethod;

        pKSFilter = KsGetFilterFromIrp( pIrp);
    
        if (pKSFilter && pKSPinPairMethod)
        {
            //  Obtain the KS Filter Mutex
            //
            //$BUG - Obtain the KS Filter Mutex

            status = BdaCreateTopology( pKSFilter,
                                        pKSPinPairMethod->InputPinId,
                                        pKSPinPairMethod->OutputPinId
                                        );
        
            //  Release the KS Filter Mutex
            //
            //$BUG - Obtain the KS Filter Mutex
        }
        else
        {
            status = STATUS_INVALID_PARAMETER;
        }
    }
    else
    {
        status = STATUS_INVALID_PARAMETER;
    }

    return status;
}


/*
**  BdaFindPinPair()
**
**      Returns a pointer to the BDA_PIN_PAIRING that corresponds
**      to the given input and output pins.
**
**  Arguments:
**
**      pTopology   Pointer to the BDA topology that contains the
**                  pin pairing.
**
**      InputPinId  Id of the input Pin to match
**
**      OutputPinId Id of the output Pin to match
**
**  Returns:
**
**      pPinPairing     Pointer to a valid BDA Pin Pairing structure
**
**      NULL            If no valid pin pairing exists with the
**                      given input and output pins.
**
** Side Effects:  none
*/

PBDA_PIN_PAIRING
BdaFindPinPair(
    PBDA_FILTER_TEMPLATE    pFilterTemplate,
    ULONG                   InputPinId,
    ULONG                   OutputPinId
    )
{
    return NULL;
}


/*
**  BdaGetPinFactoryContext()
**
**  Finds a BDA PinFactory Context that corresponds
**  to the given KS Pin Instance.
**
** Arguments:
**
**
** Returns:
**
**
**
** Side Effects:  none
*/

STDMETHODIMP_(NTSTATUS)
BdaGetPinFactoryContext(
    PKSPIN                          pKSPin,
    PBDA_PIN_FACTORY_CONTEXT        pPinFactoryCtx
    )
{
    NTSTATUS                    status = STATUS_SUCCESS;
    PKSFILTER                   pKSFilter;
    PBDA_FILTER_CONTEXT         pFilterCtx = NULL;

    if (!pKSPin || !pPinFactoryCtx)
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

    pKSFilter = KsPinGetParentFilter( pKSPin);
    if (!pKSFilter)
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }


    //  Find our Filter Context so that we can look up the pin type
    //  in the Template Topology.
    //
    status = BdaGetFilterContext( pKSFilter, &pFilterCtx);
    if (status != STATUS_SUCCESS)
    {
        goto errExit;
    }
    ASSERT( pFilterCtx);

    if (pKSPin->Id >= pFilterCtx->ulcPinFactories)
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

    *pPinFactoryCtx = pFilterCtx->argPinFactoryCtx[pKSPin->Id];

errExit:
    return status;
}


/*
**  BdaCreatePin()
**
**      Utility function creates a new pin in the given filter instance.
**
**
**  Arguments:
**
**
**
**      PinType         Pin type to create.
**
**      pPinId          Id of the Pin that was created.
**
**  Returns:
**
**
** Side Effects:  none
*/

STDMETHODIMP_(NTSTATUS)
BdaCreatePin(
    PKSFILTER                   pKSFilter,
    ULONG                       ulPinType,
    PULONG                      pulPinId
    )
{
    NTSTATUS                        status = STATUS_SUCCESS;
    PBDA_FILTER_CONTEXT             pFilterCtx;
    PBDA_PIN_FACTORY_CONTEXT        pPinFactoryCtx;
    KSPIN_DESCRIPTOR_EX             myKSPinDescriptorEx;
    KSAUTOMATION_TABLE *            pNewAutomationTable = NULL;
    const KSPIN_DESCRIPTOR_EX *     pKSPinDescriptorEx;
    const BDA_FILTER_TEMPLATE *     pBdaFilterTemplate;
    const KSFILTER_DESCRIPTOR *     pFilterDescriptor;


    ASSERT( pulPinId);
    if (!pulPinId)
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

    //  Find our Filter Context so that we can look up the pin type
    //  in the Template Topology.
    //
    status = BdaGetFilterContext( pKSFilter, &pFilterCtx);
    if (status != STATUS_SUCCESS)
    {
        goto errExit;
    }
    ASSERT( pFilterCtx);

    //  Locate this filter's Template Topology
    //
    if (   !pFilterCtx
        || !pFilterCtx->pBdaFilterTemplate
        || !pFilterCtx->pBdaFilterTemplate->pFilterDescriptor
       )
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }
    pFilterDescriptor = pFilterCtx->pBdaFilterTemplate->pFilterDescriptor;

    //  Locate the Pin Type in this filter's Template Topology
    //
    if (pFilterDescriptor->PinDescriptorsCount <= ulPinType)
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

    //  Get the KSPIN_DESCRIPTOR_EX for this pin type
    //
    pKSPinDescriptorEx = pFilterDescriptor->PinDescriptors;
    ASSERT( pKSPinDescriptorEx);
    ASSERT( pFilterDescriptor->PinDescriptorSize);
    pKSPinDescriptorEx = (const KSPIN_DESCRIPTOR_EX *)
                         (  (BYTE *) pKSPinDescriptorEx
                          + ulPinType * pFilterDescriptor->PinDescriptorSize
                         );

    //  Create a new copy of the pin descriptor so that it is easier to
    //  modify
    //
    myKSPinDescriptorEx = *pKSPinDescriptorEx;
    myKSPinDescriptorEx.AutomationTable = NULL;

    status = BdaAddNodeAutomationToPin( pFilterCtx, 
                                        ulPinType,
                                        pKSFilter->Bag,
                                        pKSPinDescriptorEx->AutomationTable,
                                        &pNewAutomationTable
                                      );
    if (status != STATUS_SUCCESS)
    {
        goto errExit;
    }

    //  Merge required properties for which BdaSup.sys provides a default
    //  implementation.
    //
    status = KsMergeAutomationTables( 
                 &((PKSAUTOMATION_TABLE)(myKSPinDescriptorEx.AutomationTable)),
                 pNewAutomationTable,
                 (PKSAUTOMATION_TABLE) &BdaDefaultPinAutomation,
                 pKSFilter->Bag
                 );
    if (status != STATUS_SUCCESS)
    {
        goto errExit;
    }


    status = KsFilterCreatePinFactory ( pKSFilter,
                                        &myKSPinDescriptorEx,
                                        pulPinId
                                      );
    if (status != STATUS_SUCCESS)
    {
        goto errExit;
    }

    status = BdaCreatePinFactoryContext( pKSFilter,
                                         pFilterCtx,
                                         *pulPinId,
                                         ulPinType
                                         );

errExit:

    return status;
}


/*
**  BdaAddNodeAutomationToPin()
**
**      Merges the automation tables for each node type that is controlled
**      by the pin type being created into the automation table for the
**      the pin factory.  This is how the automation tables for BDA
**      control nodes get linked to the controlling pin.  Otherwise the
**      nodes would not be accesable.
**
**
**  Arguments:
**
**
**      pFilterCtx      The BDA filter context to which the pin factory
**                      belongs.  Must have this to get at the template
**                      topology.
**
**      ulPinType       BDA Pin Type of the pin being created.  Need this
**                      to figure out which nodes are controlled by the
**                      pin.
**
**  Returns:
**      Always returns a resulting automation table, even on error.
**
**
** Side Effects:  none
*/

STDMETHODIMP_(NTSTATUS)
BdaAddNodeAutomationToPin( 
    PBDA_FILTER_CONTEXT         pFilterCtx, 
    ULONG                       ulControllingPinType,
    KSOBJECT_BAG                ObjectBag,
    const KSAUTOMATION_TABLE *  pOriginalAutomationTable,
    PKSAUTOMATION_TABLE *       ppNewAutomationTable
    )
{
    NTSTATUS                    status = STATUS_SUCCESS;
    const KSFILTER_DESCRIPTOR * pFilterDescriptor;      
    KSAUTOMATION_TABLE *        pNewAutomationTable = NULL;
    ULONG                       uliPath;
    ULONG                       ulcNodes;
    ULONG                       ulcbNodeDescriptor;

    //  Check for required parameters
    //
    if (!pFilterCtx || !ObjectBag)
    {
        status = STATUS_INVALID_PARAMETER;
        goto exit;
    }

    if (   !pFilterCtx->ulcPathInfo
        || !pFilterCtx->pBdaFilterTemplate
        || !pFilterCtx->pBdaFilterTemplate->pFilterDescriptor
        || !pFilterCtx->pBdaFilterTemplate->pFilterDescriptor->NodeDescriptorsCount
        || !pFilterCtx->pBdaFilterTemplate->pFilterDescriptor->NodeDescriptors
       )
    {
        goto exit;
    }

    pFilterDescriptor = pFilterCtx->pBdaFilterTemplate->pFilterDescriptor;

    //  If ulcNodeControlInfo is not zero the that array of control info
    //  structures must exist
    //
    ASSERT( pFilterCtx->argpPathInfo);
    if (!pFilterCtx->argpPathInfo)
    {
        status = STATUS_INVALID_DEVICE_STATE;
        goto exit;
    }

    //  Initial variables used to step through the list of node descriptors
    //  for the filter to which this pin type belongs.
    //
    ulcNodes = pFilterDescriptor->NodeDescriptorsCount;
    ulcbNodeDescriptor = pFilterDescriptor->NodeDescriptorSize;

    //  Step through each template node descriptor and, if it is controlled,
    //  by the given pin type, add its automation table to resulting table.
    //
    for ( uliPath = 0
        ; uliPath < pFilterCtx->ulcPathInfo
        ; uliPath++
        )
    {
        PBDA_PATH_INFO              pPathInfo;
        ULONG                       uliPathEntry;
        BOOLEAN                     fMergeNode = FALSE;

        pPathInfo = pFilterCtx->argpPathInfo[uliPath];

        //  Skip paths that don't include this pin type.
        //
        if (pPathInfo->ulInputPin == ulControllingPinType)
        {
            //  If the controlling pin is an input pin then we
            //  will start merging nodes right away and quit when
            //  we find a topology joint.
            //
            fMergeNode = TRUE;
        }
        else if (pPathInfo->ulOutputPin == ulControllingPinType)
        {
            //  If the controlling pin is an output pin then we
            //  will not merge nodes until we find a topology
            //  joint.
            //
            fMergeNode = FALSE;
        }
        else
        {
            //  The pin we're interested in isn't part of this path.
            continue;
        }

        //  Loop through each connection in the path to see if it points
        //  to a node whose automation table needs to be merged to the
        //  pin.
        //
        for ( uliPathEntry = 0
            ; uliPathEntry < pPathInfo->ulcPathEntries
            ; uliPathEntry++
            )
        {
            const KSTOPOLOGY_CONNECTION *   pConnection;
            ULONG                           uliConnection;
            const KSNODE_DESCRIPTOR *       pNodeDescriptor;
            ULONG                           uliNode;

            if (pPathInfo->rgPathEntries[uliPathEntry].fJoint)
            {
                //  Switch the merge state on a topology joint.
                //
                fMergeNode = !fMergeNode;
                if (!fMergeNode)
                {
                    //  If we were merging input side nodes then we're done
                    //
                    break;
                }
            }

            if (!fMergeNode)
            {
                continue;
            }

            //  Get the "ToNode" from this connection and, if it is not
            //  an output pin, merge its automation table.
            //
            uliConnection = pPathInfo->rgPathEntries[uliPathEntry].uliConnection;
            pConnection = &(pFilterDescriptor->Connections[uliConnection]);
            uliNode = pConnection->ToNode;
            if (   (uliNode == -1)
                || (uliNode >= pFilterDescriptor->NodeDescriptorsCount)
               )
            {
                //  This connection's "ToNode" is an output pin so
                //  skip it.
                //
                continue;
            }
    
            //  Find the Node Descriptor for the node type
            //
            pNodeDescriptor = pFilterDescriptor->NodeDescriptors;
            pNodeDescriptor = (const KSNODE_DESCRIPTOR *)
                                 (  (const BYTE *) (pNodeDescriptor)
                                  + (ulcbNodeDescriptor * uliNode)
                                 );
        
            //  Merge the nodes automation table into the resulting automation
            //  table.
            //
            //$BUGBUG - KsMergeAutomationTables should take const xxx *
            //
            if (!pOriginalAutomationTable)
            {
                pOriginalAutomationTable 
                    = (PKSAUTOMATION_TABLE) (pNodeDescriptor->AutomationTable);
            }
            else
            {
                status = KsMergeAutomationTables( 
                             &pNewAutomationTable,
                             (PKSAUTOMATION_TABLE) pOriginalAutomationTable,
                             (PKSAUTOMATION_TABLE) (pNodeDescriptor->AutomationTable),
                             ObjectBag
                             );
                if (status != STATUS_SUCCESS)
                {
                    goto exit;
                }
                ASSERT( pNewAutomationTable);
        
                pOriginalAutomationTable = pNewAutomationTable;
                pNewAutomationTable = NULL;
            }
        }

    }

exit:
    *ppNewAutomationTable = (PKSAUTOMATION_TABLE) pOriginalAutomationTable;
    return status;
}


/*
**  BdaDeletePin()
**
**      Utility function deletes a pin from the given filter instance.
**
**
**  Arguments:
**
**
**      PinType         Pin type to create.
**
**      pPinId          Id of the Pin that was created.
**
**  Returns:
**
**
** Side Effects:  none
*/

STDMETHODIMP_(NTSTATUS)
BdaDeletePin(
    PKSFILTER                   pKSFilter,
    PULONG                      pulPinId
    )
{
    NTSTATUS                status = STATUS_SUCCESS;
    PBDA_FILTER_CONTEXT     pFilterCtx;

    status = BdaGetFilterContext( pKSFilter, &pFilterCtx);

    if (status != STATUS_SUCCESS)
    {
        goto errExit;
    }

    ASSERT( pFilterCtx);

errExit:
    return status;
}


/*
**  BdaPathExists()
**
**      Utility function checks if there is a path between the input and
**      the output.
**
**
**  Arguments:
**
**      InputPinId
**
**      OutPutPinId
**
**  Returns:
**
**      TRUE            If a path exists.
**      FALSE           If no path exists.
**
** Side Effects:  none
*/

STDMETHODIMP_(BOOLEAN)
BdaPathExists(
    const KSFILTER_DESCRIPTOR * pFilterDescriptor,
    ULONG                       ulInputPinId,
    ULONG                       ulOutputPinId
    )
{
    const KSTOPOLOGY_CONNECTION *   pConnection;
    ULONG                           ulcConnections;
    ULONG                           uliConnection;

    if (   !pFilterDescriptor
        || !pFilterDescriptor->ConnectionsCount
        || !pFilterDescriptor->Connections
       )
    {
        return FALSE;
    }

    //$REVIEW - Assume only DShow style internal connections.
    //$REVIEW   (ie connections between pins with no intervening nodes)
    //
    ulcConnections = pFilterDescriptor->ConnectionsCount;
    pConnection = pFilterDescriptor->Connections;
    for (uliConnection = 0; uliConnection < ulcConnections; uliConnection++)
    {
        if (   (pConnection[uliConnection].FromNode == -1)
            && (pConnection[uliConnection].FromNodePin == ulInputPinId)
            && (pConnection[uliConnection].ToNode == -1)
            && (pConnection[uliConnection].ToNodePin == ulOutputPinId)
           )
        {
            break;
        }
    }

    return (uliConnection < ulcConnections);
}


/*
**  BdaCreateTopology()
**
**      Utility function creates the topology between two pins.
**
**
**  Arguments:
**
**
**      InputPinId
**
**      OutPutPinId
**
**  Returns:
**
**      NULL            If no valid pin pairing exists with the
**                      given input and output pins.
**
** Side Effects:  none
*/

STDMETHODIMP_(NTSTATUS)
BdaCreateTopology(
    PKSFILTER                   pKSFilter,
    ULONG                       ulInputPinId,
    ULONG                       ulOutputPinId
    )
{
    NTSTATUS                    status = STATUS_SUCCESS;
    PBDA_FILTER_CONTEXT         pFilterCtx = NULL;
    const KSFILTER_DESCRIPTOR * pFilterDesc;
    ULONG                       uliPinPair;
    ULONG                       ulcPinPairs;
    const BDA_PIN_PAIRING *     pPinPairs;
    ULONG                       ulInputPinType;
    ULONG                       ulOutputPinType;

    if (!pKSFilter)
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

    status = BdaGetFilterContext( pKSFilter, &pFilterCtx);

    if (status != STATUS_SUCCESS)
    {
        goto errExit;
    }

    ASSERT( pFilterCtx);
    if (!pFilterCtx)
    {
        status = STATUS_INVALID_DEVICE_STATE;
        goto errExit;
    }

    ASSERT( pFilterCtx->pBdaFilterTemplate);
    if (!pFilterCtx->pBdaFilterTemplate)
    {
        status = STATUS_INVALID_DEVICE_STATE;
        goto errExit;
    }

    pPinPairs = pFilterCtx->pBdaFilterTemplate->pPinPairs;
    ulcPinPairs = pFilterCtx->pBdaFilterTemplate->ulcPinPairs;

    pFilterDesc = pKSFilter->Descriptor;

    if (   !pFilterDesc
        || (ulInputPinId >= pFilterDesc->PinDescriptorsCount)
        || (ulOutputPinId >= pFilterDesc->PinDescriptorsCount)
       )
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

    if (BdaPathExists( pFilterDesc, ulInputPinId, ulOutputPinId))
    {
        goto errExit;
    }

    //  Get the input pin type.
    //
    status = BdaPinTypeFromPinId( pFilterCtx, 
                                  ulInputPinId,
                                  &ulInputPinType
                                  );
    if (status != STATUS_SUCCESS)
    {
        goto errExit;
    }

    //  Get the output pin type.
    //
    status = BdaPinTypeFromPinId( pFilterCtx, 
                                  ulOutputPinId,
                                  &ulOutputPinType
                                  );
    if (status != STATUS_SUCCESS)
    {
        goto errExit;
    }

    //  See if there is a pin pairing to match the requested topology.
    //
    for (uliPinPair = 0; uliPinPair < ulcPinPairs; uliPinPair++)
    {
        if (   (pPinPairs[uliPinPair].ulInputPin == ulInputPinType)
            && (pPinPairs[uliPinPair].ulOutputPin == ulOutputPinType)
           )
        {
            break;
        }
    }
    if (uliPinPair >= ulcPinPairs)
    {
        status = STATUS_INVALID_DEVICE_REQUEST;
        goto errExit;
    }

    {
        KSTOPOLOGY_CONNECTION   ksConnection;

        //  Add a path between the pins to the filter descriptor
        //
        ksConnection.FromNode = -1;
        ksConnection.FromNodePin = ulInputPinId;
        ksConnection.ToNode = -1;
        ksConnection.ToNodePin = ulOutputPinId;
    
        status = KsFilterAddTopologyConnections ( pKSFilter,
                                                  1,
                                                  &ksConnection
                                                  );
    }

errExit:
    return status;
}


/*
**  BdaInitFilterFactoryContext()
**
**      Initializes a BDA Filter Factory Context based on the filter's
**      template descriptor.
**
**
**  Arguments:
**
**
**      pFilterFactoryCtx
**
**  Returns:
**
**      NULL            If no valid pin pairing exists with the
**                      given input and output pins.
**
** Side Effects:  none
*/

STDMETHODIMP_(NTSTATUS)
BdaInitFilterFactoryContext(
    PBDA_FILTER_FACTORY_CONTEXT pFilterFactoryCtx
    )
{
    NTSTATUS                status = STATUS_SUCCESS;

    ASSERT( pFilterFactoryCtx);
    if (!pFilterFactoryCtx)
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

    if (!pFilterFactoryCtx->pBdaFilterTemplate)
    {
        goto errExit;
    }

errExit:
    return status;
}


/*
**  BdaPushNextPathHop()
**
**      Recursively pushes connections onto the connection stack until
**      (starting with the input pin of the pin pair) until either the
**      output pin is found or there are no connections that can be pushed.
**
**
**  Arguments:
**
**
**      pFilterFactoryCtx
**
**  Returns:
**
**      NULL            If no valid pin pairing exists with the
**                      given input and output pins.
**
** Side Effects:  none
*/

STDMETHODIMP_(NTSTATUS)
BdaPushNextPathHop(
    PULONG                          puliPathStack,
    PBDA_PATH_STACK_ENTRY           pPathStack,
    ULONG                           ulcConnections,
    const KSTOPOLOGY_CONNECTION *   pConnections,
    const BDA_PIN_PAIRING *         pPinPair
    )
{
    NTSTATUS                        status = STATUS_SUCCESS;
    ULONG                           ulHop;
    ULONG                           ulFromNode;
    ULONG                           ulFromNodePin;
    ULONG                           uliConnection;

    //  Determine which node we are currently finding connection to.
    //
    if (!*puliPathStack)
    {
        //  We are pushing the first hop.
        //
        ulHop = 0;

        //  Hop 0 is always the input pin
        //
        ulFromNode = -1;
        ulFromNodePin = pPinPair->ulInputPin;
    }
    else
    {
        //  We are pushing the next hop.
        //
        ulHop = pPathStack[*puliPathStack - 1].ulHop + 1;

        //  We will be looking for connections from the "ToNode" of the
        //  connection at the top of the stack.
        //
        uliConnection = pPathStack[*puliPathStack - 1].uliConnection;
        ulFromNode = pConnections[uliConnection].ToNode;
        ulFromNodePin = pConnections[uliConnection].ToNodePin;
    }

    //  GO through each connection in the filter factories connection
    //  and push any connection to ulFromNode onto the connections stack.
    //  If a connection from ulFromNode to the output pin of the given
    //  pin pair is found then we have found a complete path for the
    //  pin pair.
    //
    for ( uliConnection = 0
        ; uliConnection < ulcConnections
        ; uliConnection++
        )
    {
        ULONG           uliJoints;
        const ULONG *   pJoints;


        if (pConnections[uliConnection].FromNode != ulFromNode)
        {
            //  Connection is not from the node at the top of the stack.
            //
            continue;
        }

        if (   (pConnections[uliConnection].FromNode == -1)
            && (pConnections[uliConnection].FromNodePin != ulFromNodePin)
           )
        {
            //  The input pin is at the top of the stack and this connection
            //  is not from the input pin of the pin pair.
            //
            continue;
        }
        
        //
        //  This connection is from the node that was on top of the stack
        //  when this function was called.  Push it onto the stack.
        //

        if (*puliPathStack >= ulcConnections)
        {
            //  Stack overflow
            //  Can only occur when the BDA topology contains
            //  cirular references.
            //
            status = STATUS_INVALID_PARAMETER;
            goto errExit;
        }
        
        //  Write the connection info to the next stack entry.
        //
        pPathStack[*puliPathStack].ulHop = ulHop;
        pPathStack[*puliPathStack].uliConnection = uliConnection;
        pPathStack[*puliPathStack].fJoint = FALSE;

        //  See if this connection is also a topology joint.
        //
        for ( uliJoints = 0, pJoints = pPinPair->pTopologyJoints
            ; (uliJoints < pPinPair->ulcTopologyJoints) && pJoints
            ; uliJoints++ 
            )
        {
            if (pJoints[uliJoints] == uliConnection)
            {
                pPathStack[*puliPathStack].fJoint = TRUE;
                break;
            }
        }
        
        //  Increment the stack pointer
        //
        *puliPathStack += 1;

        //  Now that the connection has been pushed on the stack.  See if it
        //  completes a path between the input and output pin pair.
        //
        if (   (pConnections[uliConnection].ToNode == -1)
            && (pConnections[uliConnection].ToNodePin == pPinPair->ulOutputPin)
           )
        {
            //  If this connection completes the path, then complete
            //  now so that the caller will find the end of the path
            //  at the top of the stack.
            //
            break;
        }
    }

errExit:

    return status;
}


/*
**  BdaPopPathSegment()
**
**      Pops the stack back to the next path segment to try.
**
**
**  Arguments:
**
**
**  Returns:
**
**
** Side Effects:  none
*/

BdaPopPathSegment(
    PULONG                          puliPathStack,
    PBDA_PATH_STACK_ENTRY           pPathStack
    )
{
    NTSTATUS                        status = STATUS_SUCCESS;
    ULONG                           ulCurHop;
    ULONG                           ulNewHop;

    ulCurHop = pPathStack[*puliPathStack].ulHop;
    while (*puliPathStack)
    {
        *puliPathStack -= 1;

        if (!*puliPathStack)
        {
            //  Empty Stack
            //
            break;
        }

        if (pPathStack[(*puliPathStack) - 1].ulHop == ulCurHop)
        {
            //  Stop here if there is another entry on the stack at
            //  the current hop count.
            // 
            break;
        }

        //  We've popped back to a new hop count, so set the current
        //  hop count and pop off another entry.
        //
        ulCurHop = pPathStack[(*puliPathStack) - 1].ulHop;
    }
    
    return status;
}


/*
**  BdaPathInfoFromPathStack()
**
**      Builds a connection path between the input and output pins of
**      a pin pair.
**
**
**  Arguments:
**
**
**  Returns:
**
**
** Side Effects:  none
*/

STDMETHODIMP_(NTSTATUS)
BdaPathInfoFromPathStack(
    ULONG                           uliPathStack,
    PBDA_PATH_STACK_ENTRY           pPathStack,
    ULONG                           ulcConnections,
    const KSTOPOLOGY_CONNECTION *   pConnections,
    const BDA_PIN_PAIRING *         pPinPair,
    PBDA_PATH_INFO *                ppPathInfo
    )
{
    NTSTATUS            status = STATUS_SUCCESS;
    PBDA_PATH_INFO      pPathInfo = NULL;
    ULONG               uliConnection;
    ULONG               ulHop;

    ASSERT( uliPathStack);
    ASSERT( pPathStack);
    ASSERT( uliPathStack <= ulcConnections);
    ASSERT( ulcConnections);
    ASSERT( pConnections);
    ASSERT( ppPathInfo);
    ASSERT( pPinPair);

    if (   !ppPathInfo
        || !pConnections
        || !pPathStack
        || !pPinPair
        || !uliPathStack
        || !ulcConnections
        || (uliPathStack > ulcConnections)
       )
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

    //  Make sure the connection at the top of the path stack points
    //  to the output pin of the pin pair.
    //
    uliConnection = pPathStack[uliPathStack - 1].uliConnection;
    if (   (pConnections[uliConnection].ToNode != -1)
        || (pConnections[uliConnection].ToNodePin != pPinPair->ulOutputPin)
       )
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }
    
    //  Start filling in from the node at the last hop.  If the last
    //  hop == 0 then there was only one connection between the input
    //  and output pins with no intervening nodes.
    //
    ulHop = pPathStack[uliPathStack - 1].ulHop;

    //  Allocate enough space for the node path structure and all
    //  nodes in the path.
    //
    pPathInfo = ExAllocatePool( 
                           NonPagedPool,
                             sizeof( BDA_PATH_INFO)
                           + (ulHop + 1) * sizeof( BDA_PATH_STACK_ENTRY)
                           );
    if (!pPathInfo)
    {
        status = STATUS_NO_MEMORY;
        goto errExit;
    }

    pPathInfo->ulInputPin = pPinPair->ulInputPin;
    pPathInfo->ulOutputPin = pPinPair->ulOutputPin;
    pPathInfo->ulcPathEntries = ulHop + 1;

    while (uliPathStack)
    {
        //  Enter the Connection info into the path connection list
        //
        //
        pPathInfo->rgPathEntries[ulHop] = pPathStack[uliPathStack - 1];

        //  Pop the path stack up to the top entry of the next lower hop.
        //  If exhaust the path stack then we are either done or the path
        //  stack didn't reflect a complete path from input pin to
        //  output pin.
        //
        ulHop -= 1;
        while (   uliPathStack
               && (pPathStack[uliPathStack - 1].ulHop != ulHop)
              )
        {
            uliPathStack -= 1;
        }
    }

    //  We should alway end up pointing to a connection between the input
    //  pin and the first node of the path to the output pin.
    //
    ASSERT( ulHop == -1);
    if (ulHop != -1)
    {
        status = STATUS_INVALID_DEVICE_STATE;
        goto errExit;
    }

    //  Make sure the last connection points back to the input pin.
    //
    uliConnection = pPathInfo->rgPathEntries[0].uliConnection;
    if (   (pConnections[uliConnection].FromNode != -1)
        || (pConnections[uliConnection].FromNodePin != pPinPair->ulInputPin)
       )
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

exit:
    *ppPathInfo = pPathInfo;
    pPathInfo = NULL;

    return status;

errExit:
    if (pPathInfo)
    {
        ExFreePool( pPathInfo);
        pPathInfo = NULL;
    }

    goto exit;
}


/*
**  BdaBuildPath()
**
**      Builds a connection path between the input and output pins of
**      a pin pair.
**
**
**  Arguments:
**
**
**  Returns:
**
**
** Side Effects:  none
*/

STDMETHODIMP_(NTSTATUS)
BdaBuildPath(
    ULONG                           ulcConnections,
    const KSTOPOLOGY_CONNECTION *   pConnections,
    const BDA_PIN_PAIRING *         pPinPair,
    PBDA_PATH_INFO *                ppPathInfo
    )
{
    NTSTATUS                        status = STATUS_SUCCESS;
    ULONG                           uliStackPointer;
    PBDA_PATH_STACK_ENTRY           pPathStack = NULL;
    ULONG                           ulcAttempts;
    ULONG                           uliConnection;


    //  Allocate a stack on which to put unfollowed connections to a path.
    //
    pPathStack = ExAllocatePool( 
                               NonPagedPool, 
                               ulcConnections * sizeof( BDA_PATH_STACK_ENTRY)
                               );
    if (!pPathStack)
    {
        status = STATUS_NO_MEMORY;
        goto errExit;
    }


    //  Initialize the unfollowed connection stack
    //
    uliStackPointer = 0;

    //  Build a path stack by pushing each connection that connects from
    //  the previous hop.
    //
    //  It isn't possible to attempt to push the next hop more times than
    //  there are connections.  If this happens then there is an illegal
    //  circular path in the connection list.
    //
    for (ulcAttempts = 0; ulcAttempts < ulcConnections; ulcAttempts++)
    {
        ULONG   uliPrevStackPointer;

        uliPrevStackPointer = uliStackPointer;

        status = BdaPushNextPathHop( &uliStackPointer, 
                                     pPathStack, 
                                     ulcConnections,
                                     pConnections,
                                     pPinPair
                            );

        if (!uliStackPointer)
        {
            //  If the stack is empty at this point then there is
            //  no path from the input pin to the output pin.
            //
            break;
        }

        //  See if the connection at the top of the stack connects to
        //  the output pin of the pin pair.
        //
        uliConnection = pPathStack[uliStackPointer - 1].uliConnection;
        if (   (pConnections[uliConnection].ToNode == -1)
            && (pConnections[uliConnection].ToNodePin == pPinPair->ulOutputPin)
           )
        {
            //  A path from the input pin to the output pin has been
            //  located.
            //
            break;
        }

        //  If no hop could be pushed onto the connnection at the top of
        //  the stack then it is a dead end.
        //
        if (uliStackPointer <= uliPrevStackPointer)
        {
            //  Pop connections from the stack until we reach a viable
            //  (new) candidate to attempt a path from.
            //
            BdaPopPathSegment( &uliStackPointer, pPathStack);

            if (!uliStackPointer)
            {
                //  If the stack is empty at this point then there is
                //  no path from the input pin to the output pin.
                //
                break;
            }
        }
    }

    if (!uliStackPointer || (ulcAttempts >= ulcConnections))
    {
        //  Either there is no path from the input pin to the output pin
        //  or there is an illegal circular path in the connection list
        //
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

    //  Create a BDA node path structure from the Path Stack
    //
    //$REVIEW - Should we allow more than one path per pin pair
    //
    status = BdaPathInfoFromPathStack( uliStackPointer,
                                       pPathStack,
                                       ulcConnections,
                                       pConnections,
                                       pPinPair,
                                       ppPathInfo
                                       );

errExit:
    if (pPathStack)
    {
        ExFreePool( pPathStack);
        pPathStack = NULL;
    }

    return status;
}


/*
**  BdaCreateTemplatePaths()
**
**      Creates a list of all possible paths through the template filter.
**      Determines the controlling pin type for each node type in the
**      template filter.
**
**
**  Arguments:
**
**
**      pFilterFactoryCtx
**
**  Returns:
**
**      NULL            If no valid pin pairing exists with the
**                      given input and output pins.
**
** Side Effects:  none
*/

STDMETHODIMP_(NTSTATUS)
BdaCreateTemplatePaths(
    const BDA_FILTER_TEMPLATE *     pBdaFilterTemplate,
    PULONG                          pulcPathInfo,
    PBDA_PATH_INFO **               pargpPathInfo
    )
{
    NTSTATUS                        status = STATUS_SUCCESS;
    const BDA_FILTER_TEMPLATE *     pFilterTemplate;
    ULONG                           uliPinPair;
    ULONG                           ulcPinPairs;
    const BDA_PIN_PAIRING *         pPinPairs;
    ULONG                           ulcConnections;
    const KSTOPOLOGY_CONNECTION *   pConnections;
    PBDA_PATH_INFO *                argpPathInfo = NULL;

    ASSERT( pBdaFilterTemplate);
    ASSERT( pBdaFilterTemplate->pFilterDescriptor);
    ASSERT( pBdaFilterTemplate->ulcPinPairs);

    if (   !pBdaFilterTemplate
        || !pBdaFilterTemplate->pFilterDescriptor
        || !pBdaFilterTemplate->ulcPinPairs
       )
    {
        goto errExit;
    }

    if (   !pBdaFilterTemplate->pFilterDescriptor->ConnectionsCount
        || !pBdaFilterTemplate->pFilterDescriptor->Connections
        || !pBdaFilterTemplate->pPinPairs
       )
    {
        status = STATUS_INVALID_DEVICE_STATE;
        goto errExit;
    }

    ulcPinPairs = pBdaFilterTemplate->ulcPinPairs;
    pPinPairs = pBdaFilterTemplate->pPinPairs;
    ulcConnections = pBdaFilterTemplate->pFilterDescriptor->ConnectionsCount;
    pConnections = pBdaFilterTemplate->pFilterDescriptor->Connections;


    //  Allocate the node path list (one entry for each pin pairing).
    //
    //$REVIEW - Should we allow more than one path per pin pair
    //
    argpPathInfo = ExAllocatePool(
                     NonPagedPool,
                     ulcPinPairs * sizeof( PBDA_PATH_INFO)
                     );
    if (!argpPathInfo)
    {
        status = STATUS_NO_MEMORY;
        goto errExit;
    }


    for (uliPinPair = 0; uliPinPair < ulcPinPairs; uliPinPair++)
    {
        status = BdaBuildPath(
                    ulcConnections,
                    pConnections,
                    &(pPinPairs[uliPinPair]),
                    &(argpPathInfo[uliPinPair])
                    );
        if (status != STATUS_SUCCESS)
        {
            goto errExit;
        }
    }

    *pulcPathInfo = ulcPinPairs;
    *pargpPathInfo = argpPathInfo;
    argpPathInfo = NULL;


errExit:
    if (argpPathInfo)
    {
        ExFreePool( argpPathInfo);
        argpPathInfo = NULL;
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\bda\bdasup\objdesc.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    ObjDesc.cpp

Abstract:

    Static object description data structures.

    This file includes Property, Method, and Event descriptors that
    the BDA Support Library will add to client filters and pins

--*/



#include <wdm.h>
#include <limits.h>
#include <unknown.h>
#include <ks.h>
#include <ksmedia.h>
#include <bdatypes.h>
#include <bdamedia.h>
#include <bdasup.h>
#include "bdasupi.h"


#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif // ALLOC_DATA_PRAGMA

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA


#if defined(__cplusplus)
extern "C" {
#endif // defined(__cplusplus)


//
//  Filter BDA_Topology property Set.
//
//  Defines the dispatch routines for the Default BDA_Topology
//  properties added to a BDA filter.
//
DEFINE_KSPROPERTY_TABLE(BdaTopologyProperties)
{
    DEFINE_KSPROPERTY_ITEM_BDA_NODE_TYPES(
        BdaPropertyNodeTypes,
        NULL
        ),
    DEFINE_KSPROPERTY_ITEM_BDA_PIN_TYPES(
        BdaPropertyPinTypes,
        NULL
        ),
    DEFINE_KSPROPERTY_ITEM_BDA_TEMPLATE_CONNECTIONS(
        BdaPropertyTemplateConnections,
        NULL
        ),
    DEFINE_KSPROPERTY_ITEM_BDA_NODE_METHODS(
        BdaPropertyNodeMethods,
        NULL
        ),
    DEFINE_KSPROPERTY_ITEM_BDA_NODE_PROPERTIES(
        BdaPropertyNodeProperties,
        NULL
        ),
    DEFINE_KSPROPERTY_ITEM_BDA_NODE_EVENTS(
        BdaPropertyNodeEvents,
        NULL
        ),
    DEFINE_KSPROPERTY_ITEM_BDA_CONTROLLING_PIN_ID(
        BdaPropertyGetControllingPinId,
        NULL
        ),
    DEFINE_KSPROPERTY_ITEM_BDA_NODE_DESCRIPTORS(
        BdaPropertyNodeDescriptors,
        NULL
        )
};


//
//  Filter BDA_DeviceConfiguration Method Set.
//
//  Defines the dispatch routines for the Default BdaDeviceConfiguration
//  properties added to a BDA filter.
//
DEFINE_KSMETHOD_TABLE(BdaDeviceConfigurationMethods)
{
    DEFINE_KSMETHOD_ITEM_BDA_CREATE_PIN_FACTORY(
        BdaMethodCreatePin,
        NULL
        ),
    DEFINE_KSMETHOD_ITEM_BDA_CREATE_TOPOLOGY(
        BdaMethodCreateTopology,
        NULL
        )
};


//
//  Filter Property Sets supported by defualt
//
//  This table defines all property sets added to filters by
//  the BDA Support Library
//
DEFINE_KSPROPERTY_SET_TABLE(BdaFilterPropertySets)
{
    DEFINE_KSPROPERTY_SET
    (
        &KSPROPSETID_BdaTopology,                   // Set
        SIZEOF_ARRAY(BdaTopologyProperties),        // PropertiesCount
        BdaTopologyProperties,                      // PropertyItems
        0,                                          // FastIoCount
        NULL                                        // FastIoTable
    ),
};


//
//  Filter Mtehod Sets supported by defualt
//
//  This table defines all method sets added to filters by
//  the BDA Support Library
//
DEFINE_KSMETHOD_SET_TABLE(BdaFilterMethodSets)
{
    DEFINE_KSMETHOD_SET
    (
        &KSMETHODSETID_BdaDeviceConfiguration,          // Set
        SIZEOF_ARRAY(BdaDeviceConfigurationMethods),    // PropertiesCount
        BdaDeviceConfigurationMethods,                  // PropertyItems
        0,                                              // FastIoCount
        NULL                                            // FastIoTable
    ),
};


//
//  Pin Control Property Set
//
//  Defines the dispatch routines for the BDA Control Properties
//  on a pin
//
DEFINE_KSPROPERTY_TABLE(BdaPinControlProperties)
{
    DEFINE_KSPROPERTY_ITEM_BDA_PIN_ID(
        BdaPropertyGetPinControl,
        NULL
        ),
    DEFINE_KSPROPERTY_ITEM_BDA_PIN_TYPE(
        BdaPropertyGetPinControl,
        NULL
        )
};


//
//  Pin Property Sets supported by defualt
//
//  This table defines all property sets added to pins by
//  the BDA Support Library
//
DEFINE_KSPROPERTY_SET_TABLE(BdaPinPropertySets)
{
    DEFINE_KSPROPERTY_SET
    (
        &KSPROPSETID_BdaPinControl,                 // Set
        SIZEOF_ARRAY(BdaPinControlProperties),      // PropertiesCount
        BdaPinControlProperties,                    // PropertyItems
        0,                                          // FastIoCount
        NULL                                        // FastIoTable
    )
};


//
//  BDA Pin Automation Table
//
//  Lists all Property, Method, and Event Set tables added to a pin's
//  automation table by the BDA Support Library
//
DEFINE_KSAUTOMATION_TABLE(BdaDefaultPinAutomation) {
    DEFINE_KSAUTOMATION_PROPERTIES(BdaPinPropertySets),
    DEFINE_KSAUTOMATION_METHODS_NULL,
    DEFINE_KSAUTOMATION_EVENTS_NULL
};


//
//  BDA Filter Automation Table
//
//  Lists all Property, Method, and Event Set tables added to a filter's
//  automation table by the BDA Support Library
//
DEFINE_KSAUTOMATION_TABLE(BdaDefaultFilterAutomation) {
    DEFINE_KSAUTOMATION_PROPERTIES(BdaFilterPropertySets),
    DEFINE_KSAUTOMATION_METHODS(BdaFilterMethodSets),
    DEFINE_KSAUTOMATION_EVENTS_NULL
};

#if defined(__cplusplus)
}
#endif // defined(__cplusplus)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\bda\ipsink\inc\link.h ===
/////////////////////////////////////////////////////////////////////////
//
//
typedef struct _LINK_
{
    KSPIN_LOCK       spinLock;
    PDEVICE_OBJECT   pDeviceObject;
    PFILE_OBJECT     pFileObject;
    USHORT           flags;
} LINK, *PLINK;


#define LINK_ESTABLISHED 0x00000001

//////////////////////////////////////////////////////////////////////////////
//
//
//
NTSTATUS
CreateDevice (
    PDRIVER_OBJECT  DriverObject,
    PUNICODE_STRING DeviceName,
    PUNICODE_STRING SymbolicName,
    ULONG ulcbDeviceExtension,
    PDEVICE_OBJECT  pDeviceObject
    );

VOID
CloseLink (
    PLINK pLink
    );

PLINK
OpenLink (
    PLINK   pLink,
    UNICODE_STRING  DriverName
    );

NTSTATUS
SendIOCTL (
    PLINK     pLink,
    ULONG     ulIoctl,
    PVOID     pData,
    ULONG     ulcbData
    );

NTSTATUS
CreateWaitForNdisThread (
    PVOID pContext
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\bda\ipsink\inc\forward.h ===
//////////////////////////////////////////////////////////
//
//
//
typedef struct _FRAME_POOL_ FRAME_POOL,   *PFRAME_POOL;
typedef struct _FRAME_      FRAME,        *PFRAME;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\bda\ipsink\ndis\adapter.c ===
/////////////////////////////////////////////////////////////////////////////
//
//
// Copyright (c) 1996, 1997  Microsoft Corporation
//
//
// Module Name:
//      test.c
//
// Abstract:
//
//      This file is a test to find out if dual binding to NDIS and KS works
//
// Author:
//
//      P Porzuczek
//
// Environment:
//
// Revision History:
//
//
//////////////////////////////////////////////////////////////////////////////

#include <forward.h>
#include <memory.h>
#include <ndis.h>
#include <link.h>
#include <ipsink.h>

#include "device.h"
#include "NdisApi.h"
#include "frame.h"
#include "mem.h"
#include "adapter.h"
#include "main.h"

//////////////////////////////////////////////////////////
//
//
//
PADAPTER       global_pAdapter;
UCHAR          achGlobalVendorDescription [] = "Microsoft TV/Video Connection";
ULONG          ulGlobalInstance              = 1;


//////////////////////////////////////////////////////////
//
//
const ADAPTER_VTABLE AdapterVTable =
    {
    Adapter_QueryInterface,
    Adapter_AddRef,
    Adapter_Release,
    Adapter_IndicateData,
    Adapter_IndicateReset,
    Adapter_GetDescription,
    Adapter_CloseLink
    };


//////////////////////////////////////////////////////////
//
//
#pragma pack (push, 1)

typedef ULONG CHECKSUM;

typedef struct _MAC_ADDRESS_
{
    UCHAR Address [6];

} MAC_ADDRESS, *PMAC_ADDRESS;

typedef struct _HEADER_802_3
{
    MAC_ADDRESS DestAddress;
    MAC_ADDRESS SourceAddress;
    UCHAR       Type[2];

} HEADER_802_3, *PHEADER_802_3;


typedef struct _HEADER_IP_
{
    UCHAR  ucVersion_Length;
    UCHAR  ucTOS;
    USHORT usLength;
    USHORT usId;
    USHORT usFlags_Offset;
    UCHAR  ucTTL;
    UCHAR  ucProtocol;
    USHORT usHdrChecksum;
    UCHAR  ucSrcAddress [4];
    UCHAR  ucDestAddress [4];

} HEADER_IP, *PHEADER_IP;

#pragma pack (pop)


//////////////////////////////////////////////////////////
//
//
const HEADER_802_3 h802_3Template =
{
    {0x01, 0x00, 0x5e, 0, 0, 0}
  , {0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
  , {0x08, 0x00}
};

#if DBG

//////////////////////////////////////////////////////////////////////////////
VOID
DumpData (
    PUCHAR pData,
    ULONG  ulSize
    )
//////////////////////////////////////////////////////////////////////////////
{
  ULONG  ulCount;
  ULONG  ul;
  UCHAR  uc;

  while (ulSize)
  {
      ulCount = 16 < ulSize ? 16 : ulSize;

      for (ul = 0; ul < ulCount; ul++)
      {
          uc = *pData;

          TEST_DEBUG (TEST_DBG_TRACE, ("%02X ", uc));
          ulSize -= 1;
          pData  += 1;
      }

      TEST_DEBUG (TEST_DBG_TRACE, ("\n"));
  }

}

#endif

//////////////////////////////////////////////////////////////////////////////
NTSTATUS
CreateAdapter (
    PADAPTER *ppAdapter,
    NDIS_HANDLE ndishWrapper,
    NDIS_HANDLE ndishAdapterContext
    )
//////////////////////////////////////////////////////////////////////////////
{
    NTSTATUS nsResult;
    PADAPTER pAdapter;
    UCHAR    tmp_buffer [32] = {0};


    //
    // Init the output paramter
    //
    *ppAdapter = NULL;

    //
    //  Allocate memory for the adapter block now.
    //
    nsResult = AllocateMemory (&pAdapter, sizeof(ADAPTER));
    if (nsResult != NDIS_STATUS_SUCCESS)
    {
        return nsResult;
    }
    NdisZeroMemory (pAdapter, sizeof (ADAPTER));

    //
    // Init the reference count
    //
    pAdapter->ulRefCount = 1;

    //
    // Save the pAdapter into global storage
    //
    global_pAdapter = pAdapter;

    //
    // Initialize the adapter structure fields
    //
    pAdapter->ndishMiniport = ndishAdapterContext;

    //
    // Initialize the adapter vtable
    //
    pAdapter->lpVTable = (PADAPTER_VTABLE) &AdapterVTable;

    //
    // Save off the instance for this adapter
    //
    pAdapter->ulInstance = ulGlobalInstance++;


    //
    // init the spinlock for this adapter
    //

    NdisAllocateSpinLock(&(pAdapter->ndisSpinLock));

    //Enable adapter 
    pAdapter->BDAAdapterEnable =1 ;
    
    //
    // Setup the vendor description string for this instance
    //
    nsResult = AllocateMemory (&pAdapter->pVendorDescription, sizeof(achGlobalVendorDescription) + 8);
    if (nsResult != NDIS_STATUS_SUCCESS)
    {
        return nsResult;
    }
    NdisZeroMemory (pAdapter->pVendorDescription, sizeof (achGlobalVendorDescription) + 8);

    NdisMoveMemory (pAdapter->pVendorDescription, (PVOID) achGlobalVendorDescription, sizeof (achGlobalVendorDescription));
/*
#if DBG
    MyStrCat (pAdapter->pVendorDescription, "(");
    MyStrCat (pAdapter->pVendorDescription, MyUlToA (pAdapter->ulInstance, tmp_buffer, 10));
    MyStrCat (pAdapter->pVendorDescription, ")");

    DbgPrint ("Vendor description: %s\n", pAdapter->pVendorDescription);
#endif // DEBUG

*/
    //
    // Set default completion timeout to IGNORE
    //
    //  WARNING!  The interface type is not optional!
    //
    NdisMSetAttributesEx (
        ndishAdapterContext,
        pAdapter,
        4,
        NDIS_ATTRIBUTE_IGNORE_PACKET_TIMEOUT |
        NDIS_ATTRIBUTE_IGNORE_REQUEST_TIMEOUT |
        NDIS_ATTRIBUTE_DESERIALIZE ,
        NdisInterfaceInternal);


    #ifndef WIN9X

    //
    // Create a device so other drivers (ie Streaming minidriver) can
    // link up with us
    //
    nsResult = (NTSTATUS) ntInitializeDeviceObject (
                         ndishWrapper,
                         pAdapter,
                         &pAdapter->pDeviceObject,
                         &pAdapter->ndisDeviceHandle);

    if (nsResult != NDIS_STATUS_SUCCESS)
    {
        return nsResult;
    }

    #endif

    ///////////////////////////////////////////////////
    //
    // Allocate a buffer pool.  This pool will be used
    // to indicate the streaming data frames.
    //
    CreateFramePool (pAdapter,
                     &pAdapter->pFramePool,
                     IPSINK_NDIS_MAX_BUFFERS,
                     IPSINK_NDIS_BUFFER_SIZE,
                     sizeof (IPSINK_MEDIA_SPECIFIC_INFORMATION)
                     );


    return nsResult;

}


///////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Adapter_QueryInterface (
    PADAPTER pAdapter
    )
///////////////////////////////////////////////////////////////////////////////////
{
    return STATUS_NOT_IMPLEMENTED;
}

///////////////////////////////////////////////////////////////////////////////////
ULONG
Adapter_AddRef (
    PADAPTER pAdapter
    )
///////////////////////////////////////////////////////////////////////////////////
{
    if (pAdapter)
    {
        pAdapter->ulRefCount += 1;
        return pAdapter->ulRefCount;
    }

    return 0;
}

///////////////////////////////////////////////////////////////////////////////////
ULONG
Adapter_Release (
    PADAPTER pAdapter
    )
///////////////////////////////////////////////////////////////////////////////////
{
    ULONG ulRefCount = 0L;

    if (pAdapter)
    {
        pAdapter->ulRefCount -= 1;

        ulRefCount = pAdapter->ulRefCount;

        if (pAdapter->ulRefCount == 0)
        {
            FreeMemory (pAdapter, sizeof (ADAPTER));
        }
    }

    return ulRefCount;
}


//////////////////////////////////////////////////////////////////////////////
VOID
Adapter_IndicateReset (
    PADAPTER pAdapter
    )
//////////////////////////////////////////////////////////////////////////////
{
    if (pAdapter)
    {
        if (pAdapter->pCurrentFrame != NULL)
        {
            if (pAdapter->pCurrentFrame->pFramePool)
            {
                TEST_DEBUG (TEST_DBG_TRACE, ("Putting Current Frame %08X back on Available Queue\n", pAdapter->pCurrentFrame));
                PutFrame (pAdapter->pCurrentFrame->pFramePool, &pAdapter->pCurrentFrame->pFramePool->leAvailableQueue, pAdapter->pCurrentFrame);
            }

            pAdapter->pCurrentFrame = NULL;
            pAdapter->pIn  = NULL;
            pAdapter->ulPR = 0;
        }
    }

}


//////////////////////////////////////////////////////////////////////////////
ULONG
Adapter_GetDescription (
    PADAPTER pAdapter,
    PUCHAR  pDescription
    )
//////////////////////////////////////////////////////////////////////////////
{
    ULONG ulLength;

    ulLength = MyStrLen (pAdapter->pVendorDescription) + 1;   // add 1 to include terminator

    //
    // If the description pointer is NULL, then pass back the length only
    //
    if (pDescription != NULL)
    {
        NdisMoveMemory (pDescription, pAdapter->pVendorDescription, ulLength);
    }

    return ulLength;
}

//////////////////////////////////////////////////////////////////////////////
VOID
Adapter_CloseLink (
    PADAPTER pAdapter
    )
//////////////////////////////////////////////////////////////////////////////
{
    if (pAdapter)
    {
        if (pAdapter->pFilter != NULL)
        {
            pAdapter->pFilter->lpVTable->Release (pAdapter->pFilter);
            pAdapter->pFilter = NULL;
        }
    }

}

//////////////////////////////////////////////////////////////////////////////
NTSTATUS
GetNdisFrame (
    PADAPTER  pAdapter,
    PFRAME   *ppFrame
    )
//////////////////////////////////////////////////////////////////////////////
{
    PFRAME pFrame            = NULL;
    NTSTATUS ntStatus        = STATUS_UNSUCCESSFUL;
    PHEADER_802_3 pEthHeader = NULL;
    PHEADER_IP pIPHeader     = NULL;

    *ppFrame = NULL;

    pFrame = GetFrame (pAdapter->pFramePool, &pAdapter->pFramePool->leAvailableQueue);
    TEST_DEBUG (TEST_DBG_TRACE, ("Getting Frame %08X from the Available Queue\n", pFrame));

    if (pFrame)
    {
        ntStatus = STATUS_SUCCESS;

        *ppFrame = pFrame;
    }

    return ntStatus;
}

#define SWAP_WORD(A) ((A >> 8) & 0x00FF) + ((A << 8) & 0xFF00)


//////////////////////////////////////////////////////////////////////////////
USHORT
sizeof_packet (
    PHEADER_IP pIpHdr
    )
//////////////////////////////////////////////////////////////////////////////
{
    USHORT usLength;

    usLength = pIpHdr->usLength;

    usLength = SWAP_WORD (usLength);

    return usLength;
}



//////////////////////////////////////////////////////////////////////////////
NTSTATUS
TranslateAndIndicate (
    PADAPTER pAdapter,
    PUCHAR   pOut,
    ULONG    ulSR
    )
//////////////////////////////////////////////////////////////////////////////
{
    NTSTATUS nsResult = STATUS_SUCCESS;
    ULONG    ulAmtToCopy;
    ULONG    uliNextByte;

    ASSERT (pAdapter);
    ASSERT (pOut);
    
    for ( uliNextByte = 0; uliNextByte < ulSR; )
    {
        HEADER_802_3 *  pHeader802_3;
        HEADER_IP *     pHeaderIP=NULL;

        ulAmtToCopy = 0;

        //  If there is no current frame then sync up to a new
        //  802.3 (RFC 894) ethernet frame.
        //
        if (pAdapter->pCurrentFrame == NULL)
        {
            //  Sync to a valid looking 802.3 frame
            //
            while ((ulSR - uliNextByte) >= (sizeof (HEADER_802_3) + sizeof (HEADER_IP)))
            {
                pHeader802_3 = (HEADER_802_3 *) &(pOut[uliNextByte]);
                pHeaderIP = (HEADER_IP *) &(pOut[uliNextByte + sizeof(HEADER_802_3)]);

                if (   (pHeader802_3->Type[0] == 0x08)
                    && (pHeader802_3->Type[1] == 0x00)
                    && (pHeaderIP->ucVersion_Length == 0x45)
                    && (sizeof_packet( pHeaderIP) <= MAX_IP_PACKET_SIZE)
                   )
                {
                    break;
                }
                uliNextByte++;
            }

            if ((ulSR - uliNextByte) < (sizeof (HEADER_802_3) + sizeof (HEADER_IP)))
            {
                TEST_DEBUG (TEST_DBG_INFO, ("Stream buffer consumed while searching for valid IP packet\n"));
                nsResult = STATUS_SUCCESS;
                goto ret;
            }

            //
            //  Everything looks good...get a new frame and start data transfer
            //
            nsResult = GetNdisFrame( pAdapter, 
                                     &pAdapter->pCurrentFrame
                                     );
            if (nsResult != STATUS_SUCCESS)
            {
                TEST_DEBUG (TEST_DBG_ERROR, ("Get NDIS frame failed.  No more NDIS frames available. No Frame built\n"));
                nsResult = STATUS_SUCCESS;
                pAdapter->stats.ulOID_GEN_RCV_NO_BUFFER += 1;
                pAdapter->pIn = NULL;
                pAdapter->pCurrentFrame = NULL;
                pAdapter->ulPR = 0;
                goto ret;
            }

            //Assert((pHeaderIP)!=NULL) can be used for nonretail builds here
            //check if any valid null pHeaderIP case ever exists

            if(!pHeaderIP)
            {
              nsResult = !(STATUS_SUCCESS);
              goto ret;

            }



            //
            // Update the reference count for this frame
            //
            pAdapter->pCurrentFrame->lpVTable->AddRef( pAdapter->pCurrentFrame);

            //
            // define pointers to the data in and out buffers, and init the packet size field
            //
            pAdapter->pIn = (PUCHAR) (pAdapter->pCurrentFrame->pvMemory);
            pAdapter->ulPR = sizeof_packet( pHeaderIP) + sizeof (HEADER_802_3);
            pAdapter->pCurrentFrame->ulcbData = pAdapter->ulPR;

            TEST_DEBUG (TEST_DBG_TRACE, ("CREATING NEW NDIS FRAME %08X, packet size %d\n", pAdapter->pCurrentFrame, pAdapter->ulPR));
        }

        if (pAdapter->ulPR <= (ulSR - uliNextByte))
        {
            ulAmtToCopy = pAdapter->ulPR;
        }
        else
        {
            ulAmtToCopy = ulSR - uliNextByte;
        }

        NdisMoveMemory( pAdapter->pIn, 
                        &(pOut[uliNextByte]), 
                        ulAmtToCopy
                        );
        pAdapter->pIn += ulAmtToCopy;
        pAdapter->ulPR -= ulAmtToCopy;
        uliNextByte += ulAmtToCopy;

        if (pAdapter->ulPR == 0)
        {
            BOOLEAN bResult;
            PINDICATE_CONTEXT pIndicateContext = NULL;
            NDIS_HANDLE SwitchHandle = NULL;

            AllocateMemory (&pIndicateContext, sizeof (INDICATE_CONTEXT));
            if(!pIndicateContext)
            {
                nsResult = STATUS_NO_MEMORY;
                goto ret;
            }

            pIndicateContext->pAdapter = pAdapter;

            //
            // Place the frame on the indicateQueue
            //
            TEST_DEBUG (TEST_DBG_TRACE, ("Putting Frame %08X on Indicate Queue\n", pAdapter->pCurrentFrame));
            PutFrame (pAdapter->pFramePool, &pAdapter->pFramePool->leIndicateQueue, pAdapter->pCurrentFrame);

            pAdapter->pCurrentFrame = NULL;



  	     //Check status of SourceRouting flag
  	     SourceRoutingStatusPoll(); 
            //
            //
            // Switch to a state which allows us to call NDIS functions
            //
            NdisAcquireSpinLock(&(pAdapter->ndisSpinLock));
            IndicateCallbackHandler (pAdapter->ndishMiniport, (PVOID) pIndicateContext);
            NdisReleaseSpinLock(&(pAdapter->ndisSpinLock));
         
            
        }
    }

ret:

    return nsResult;
}

//////////////////////////////////////////////////////////////////////////////
NTSTATUS
Adapter_IndicateData (
    IN PADAPTER pAdapter,
    IN PVOID pvData,
    IN ULONG ulcbData
    )
//////////////////////////////////////////////////////////////////////////////
{
    NTSTATUS ntStatus        = STATUS_SUCCESS;

    ntStatus = TranslateAndIndicate (pAdapter, pvData, ulcbData);

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\bda\ipsink\ndis\device.h ===
//////////////////////////////////////////////////////////////////////////////\
//
//  Copyright (c) 1990  Microsoft Corporation
//
//  Module Name:
//
//     ipndis.h
//
//  Abstract:
//
//     The main header for the NDIS/KS test driver
//
//  Author:
//
//     P Porzuczek
//
//  Environment:
//
//  Notes:
//
//  Revision History:
//
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _IP_NDIS_H
#define _IP_NDIS_H


NTSTATUS
ntInitializeDeviceObject(
    IN  PVOID           nhWrapperHandle,
    IN  PADAPTER        pAdapter,
    OUT PDEVICE_OBJECT *pndisDriverObject,
    OUT PVOID           pndisDeviceHandle
    );


#endif // _IP_NDIS_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\bda\ipsink\ndis\adapter.h ===
//////////////////////////////////////////////////////////////////////////////\
//
//  Copyright (c) 1990  Microsoft Corporation
//
//  Module Name:
//
//     ipndis.h
//
//  Abstract:
//
//     The main header for the NDIS/KS test driver
//
//  Author:
//
//     P Porzuczek
//
//  Environment:
//
//  Notes:
//
//  Revision History:
//
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _ADAPTER_H
#define _ADAPTER_H


//////////////////////////////////////////////////////////////////////////////\
//
//
//  Prototypes
//
//
NTSTATUS
Adapter_QueryInterface (
    IN PADAPTER pAdapter
    );

ULONG
Adapter_AddRef (
    IN PADAPTER pAdapter
    );

ULONG
Adapter_Release (
    IN PADAPTER pAdapter
    );

NTSTATUS
Adapter_IndicateData (
    IN PADAPTER pAdapter,
    IN PVOID pvData,
    ULONG ulcbData
    );

NTSTATUS
Adapter_IndicateStatus (
    IN PADAPTER pAdapter,
    IN PVOID pvData
    );

ULONG
Adapter_GetDescription (
    PADAPTER pAdapter,
    PUCHAR  pDescription
    );

VOID
Adapter_IndicateReset (
    IN PADAPTER pAdapter
    );

VOID
Adapter_CloseLink (
    IN PADAPTER pAdapter
    );

#endif // _ADAPTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\bda\ipsink\inc\ipsink.h ===
/////////////////////////////////////////////////////////////////////////////
//
//
// Copyright (c) 1996, 1997  Microsoft Corporation
//
//
// Module Name:
//      ipsink.h
//
// Abstract:
//
//
// Author:
//
//      P Porzuczek
//
// Environment:
//
// Revision History:
//
//
//////////////////////////////////////////////////////////////////////////////

#ifndef _IPSINK_H_
#define _IPSINK_H_
//Per ndis.h resetting this flag uses ntddk.Avoids header conflicts.
//ntddk is used here for ProbeForRead and ProbeForWrite functions.
#if defined(BINARY_COMPATIBLE)
#undef BINARY_COMPATIBLE
#define BINARY_COMPATIBLE 0
#endif

#include <ndis.h>

#if defined(BINARY_COMPATIBLE)
#undef BINARY_COMPATIBLE
#define BINARY_COMPATIBLE 1
#endif

/////////////////////////////////////////////////////////////////////////////
//
//
#define BDA_NDIS_MINIPORT        L"\\Device\\NDIS_IPSINK"
#define BDA_NDIS_SYMBOLIC_NAME   L"\\DosDevices\\NDIS_IPSINK"

#define BDA_NDIS_STARTUP         L"\\Device\\NDIS_IPSINK_STARTUP"

//////////////////////////////////////////////////////////
//
//
#define MULTICAST_LIST_SIZE             256
#define ETHERNET_ADDRESS_LENGTH         6


/////////////////////////////////////////////////////////////////////////////
//
//
#define NTStatusFromNdisStatus(nsResult)  ((NTSTATUS) nsResult)


/////////////////////////////////////////////////////////////////////////////
//
//
typedef struct _ADAPTER  ADAPTER,  *PADAPTER;
typedef struct _IPSINK_FILTER_  IPSINK_FILTER,   *PIPSINK_FILTER;
typedef struct _LINK_    LINK,     *PLINK;


/////////////////////////////////////////////////////////////////////////////
//
//
//
typedef enum
{
    IPSINK_EVENT_SHUTDOWN = 0x00000001,
    IPSINK_EVENT_MAX

} IPSINK_EVENT;


/////////////////////////////////////////////////////////////////////////////
//
//
//
typedef NTSTATUS (*QUERY_INTERFACE) (PVOID pvContext);
typedef ULONG    (*ADD_REF) (PVOID pvContext);
typedef ULONG    (*RELEASE) (PVOID pvContext);

/////////////////////////////////////////////////////////////////////////////
//
//
//
typedef NTSTATUS (*NDIS_INDICATE_DATA)   (PVOID pvContext, PVOID pvData, ULONG ulcbData);
typedef NTSTATUS (*NDIS_INDICATE_STATUS) (PVOID pvContext, PVOID pvEvent);
typedef VOID     (*NDIS_INDICATE_RESET)  (PVOID pvContext);
typedef ULONG    (*NDIS_GET_DESCRIPTION) (PVOID pvContext, PUCHAR pDescription);
typedef VOID     (*NDIS_CLOSE_LINK)      (PVOID pvContext);

typedef struct
{
    QUERY_INTERFACE      QueryInterface;
    ADD_REF              AddRef;
    RELEASE              Release;
    NDIS_INDICATE_DATA   IndicateData;
    NDIS_INDICATE_RESET  IndicateReset;
    NDIS_GET_DESCRIPTION GetDescription;
    NDIS_CLOSE_LINK      CloseLink;

} ADAPTER_VTABLE, *PADAPTER_VTABLE;


/////////////////////////////////////////////////////////////////////////////
//
//
//
typedef NTSTATUS (*STREAM_SET_MULTICASTLIST) (PVOID pvContext, PVOID pvMulticastList, ULONG ulcbList);
typedef NTSTATUS (*STREAM_SIGNAL_EVENT)      (PVOID pvContext, ULONG ulEvent);
typedef NTSTATUS (*STREAM_RETURN_FRAME)      (PVOID pvContext, PVOID pvFrame);

typedef struct
{
    QUERY_INTERFACE          QueryInterface;
    ADD_REF                  AddRef;
    RELEASE                  Release;
    STREAM_SET_MULTICASTLIST SetMulticastList;
    STREAM_SIGNAL_EVENT      IndicateStatus;
    STREAM_RETURN_FRAME      ReturnFrame;

} FILTER_VTABLE, *PFILTER_VTABLE;


/////////////////////////////////////////////////////////////////////////////
//
//
//
typedef struct
{
    QUERY_INTERFACE    QueryInterface;
    ADD_REF            AddRef;
    RELEASE            Release;

} FRAME_POOL_VTABLE, *PFRAME_POOL_VTABLE;


/////////////////////////////////////////////////////////////////////////////
//
//
//
typedef struct
{
    QUERY_INTERFACE    QueryInterface;
    ADD_REF            AddRef;
    RELEASE            Release;

} FRAME_VTABLE, *PFRAME_VTABLE;


/////////////////////////////////////////////////////////////////////////////
//
//
//
typedef struct
{

    ULONG       ulOID_GEN_XMIT_OK;
    ULONG       ulOID_GEN_RCV_OK;
    ULONG       ulOID_GEN_XMIT_ERROR;
    ULONG       ulOID_GEN_RCV_ERROR;
    ULONG       ulOID_GEN_RCV_NO_BUFFER;
    ULONG       ulOID_GEN_DIRECTED_BYTES_XMIT;
    ULONG       ulOID_GEN_DIRECTED_FRAMES_XMIT;
    ULONG       ulOID_GEN_MULTICAST_BYTES_XMIT;
    ULONG       ulOID_GEN_MULTICAST_FRAMES_XMIT;
    ULONG       ulOID_GEN_BROADCAST_BYTES_XMIT;
    ULONG       ulOID_GEN_BROADCAST_FRAMES_XMIT;
    ULONG       ulOID_GEN_DIRECTED_BYTES_RCV;
    ULONG       ulOID_GEN_DIRECTED_FRAMES_RCV;
    ULONG       ulOID_GEN_MULTICAST_BYTES_RCV;
    ULONG       ulOID_GEN_MULTICAST_FRAMES_RCV;
    ULONG       ulOID_GEN_BROADCAST_BYTES_RCV;
    ULONG       ulOID_GEN_BROADCAST_FRAMES_RCV;
    ULONG       ulOID_GEN_RCV_CRC_ERROR;
    ULONG       ulOID_GEN_TRANSMIT_QUEUE_LENGTH;

} NDISIP_STATS, *PNDISIP_STATS;


/////////////////////////////////////////////////////////////////////////////
//
//  The NDIS Adapter structure
//
typedef struct _ADAPTER
{
    ULONG               ulRefCount;

    //
    //  Adapter Context passed in by NDIS to the miniport.
    //
    PVOID               ndishMiniport;

    PDEVICE_OBJECT      pDeviceObject;

    PVOID               ndisDeviceHandle;

    PUCHAR              pVendorDescription;

    ULONG               ulInstance;

    PIPSINK_FILTER      pFilter;

    PADAPTER_VTABLE     lpVTable;

    PFRAME_POOL         pFramePool;

    PFRAME              pCurrentFrame;
    PUCHAR              pIn;
    ULONG               ulPR;

    ULONG               ulPacketFilter;

    NDISIP_STATS        stats;


    ULONG               ulcbMulticastListEntries;

    UCHAR               multicastList[MULTICAST_LIST_SIZE][ETHERNET_ADDRESS_LENGTH];

   NDIS_SPIN_LOCK ndisSpinLock;

   UINT	BDAAdapterEnable;
};

typedef struct _STATS_
{
    ULONG ulTotalPacketsWritten;
    ULONG ulTotalPacketsRead;

    ULONG ulTotalStreamIPPacketsWritten;
    ULONG ulTotalStreamIPBytesWritten;
    ULONG ulTotalStreamIPFrameBytesWritten;

    ULONG ulTotalNetPacketsWritten;
    ULONG ulTotalUnknownPacketsWritten;

} STATS, *PSTATS;


//
// definition of the full HW device extension structure This is the structure
// that will be allocated in HW_INITIALIZATION by the stream class driver
// Any information that is used in processing a device request (as opposed to
// a STREAM based request) should be in this structure.  A pointer to this
// structure will be passed in all requests to the minidriver. (See
// HW_STREAM_REQUEST_BLOCK in STRMINI.H)
//

typedef struct _IPSINK_FILTER_
{

    LIST_ENTRY                          AdapterSRBQueue;
    KSPIN_LOCK                          AdapterSRBSpinLock;
    BOOLEAN                             bAdapterQueueInitialized;

    //
    // Statistics
    //
    STATS                               Stats;

    //
    // Link to NDIS Component
    //
    LINK                                NdisLink;

    //
    // NDIS VTable
    //
    PADAPTER                            pAdapter;

    //
    //
    //
    PDEVICE_OBJECT                      DeviceObject;

    //
    //
    //
    PDRIVER_OBJECT                      DriverObject;

    //
    //
    //
    PFILTER_VTABLE                      lpVTable;

    //
    //
    //
    //WORK_QUEUE_ITEM                     WorkItem;

    //
    //
    //
    ULONG                               ulRefCount;

    //
    //
    //
    PKEVENT                             pNdisStartEvent;
    PHANDLE                             hNdisStartEvent;

    //
    //
    //
    BOOLEAN                             bTerminateWaitForNdis;

    //
    //
    //
    BOOLEAN                             bInitializationComplete;

    //
    //
    //
    PVOID                               pStream [2][1];

    ULONG                               ulActualInstances [2];   // Count of instances per stream

    //
    // NIC Description string pointer
    //
    PUCHAR                              pAdapterDescription;
    ULONG                               ulAdapterDescriptionLength;

    //
    // NIC Address string
    //
    PUCHAR                              pAdapterAddress;
    ULONG                               ulAdapterAddressLength;

    //
    // Multicast list local storage
    //
    ULONG               ulcbMulticastListEntries;

    UCHAR               multicastList[MULTICAST_LIST_SIZE]
                                     [ETHERNET_ADDRESS_LENGTH];


};



/////////////////////////////////////////////
//
//
typedef enum
{
    RECEIVE_DATA,
    MAX_IOCTLS
};

/////////////////////////////////////////////
//
//
typedef enum
{
    CMD_QUERY_INTERFACE = 0x00000001,
    MAX_COMMANDS
};


/////////////////////////////////////////////
//
//
typedef struct _IPSINK_NDIS_COMMAND
{
    ULONG ulCommandID;

    union
    {
        struct
        {
            PVOID pNdisAdapter;
            PVOID pStreamAdapter;

        } Query;

    } Parameter;

} IPSINK_NDIS_COMMAND, *PIPSINK_NDIS_COMMAND;


/////////////////////////////////////////////
//
//
#define _IPSINK_CTL_CODE(function, method, access) CTL_CODE(FILE_DEVICE_NETWORK, function, method, access)
#define IOCTL_GET_INTERFACE     _IPSINK_CTL_CODE(RECEIVE_DATA, METHOD_NEITHER, FILE_ANY_ACCESS)


#endif  // _IPSINK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\bda\ipsink\ndis\device.c ===
/////////////////////////////////////////////////////////////////////////////
//
//
// Copyright (c) 1996, 1997  Microsoft Corporation
//
//
// Module Name:
//      test.c
//
// Abstract:
//
//      This file is a test to find out if dual binding to NDIS and KS works
//
// Author:
//
//      P Porzuczek
//
// Environment:
//
// Revision History:
//
//
//////////////////////////////////////////////////////////////////////////////

#ifndef DWORD
#define DWORD ULONG
#endif

#include <forward.h>
#include <wdm.h>
#include <link.h>
#include <ipsink.h>

#include "device.h"
#include "main.h"


VOID
vUnload(IN PDRIVER_OBJECT pDriverObject);

//////////////////////////////////////////////////////////////////////////////
//
//
NTSTATUS
RegisterDevice(
        IN      PVOID              NdisWrapperHandle,
        IN      UNICODE_STRING     *DeviceName,
        IN      UNICODE_STRING     *SymbolicName,
        IN      PDRIVER_DISPATCH   MajorFunctions[],
        OUT     PDEVICE_OBJECT    *pDeviceObject,
        OUT     PVOID             *NdisDeviceHandle
        );


//////////////////////////////////////////////////////////////////////////////
NTSTATUS
ntDispatchOpenClose(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    )
//////////////////////////////////////////////////////////////////////////////
{
    NTSTATUS status           = STATUS_SUCCESS;
    PIO_STACK_LOCATION pIrpSp = NULL;

    //
    // Make sure status information is consistent every time.
    //
    IoMarkIrpPending (pIrp);
    pIrp->IoStatus.Status      = STATUS_PENDING;
    pIrp->IoStatus.Information = 0;

    //
    // Get a pointer to the current stack location in the IRP.  This is where
    // the function codes and parameters are stored.
    //
    pIrpSp = IoGetCurrentIrpStackLocation (pIrp);

    //
    // Case on the function that is being performed by the requestor.  If the
    // operation is a valid one for this device, then make it look like it was
    // successfully completed, where possible.
    //

    switch (pIrpSp->MajorFunction)
    {

    //
    // The Create function opens a transport object (either address or
    // connection).  Access checking is performed on the specified
    // address to ensure security of transport-layer addresses.
    //
        case IRP_MJ_CREATE:
            status = STATUS_SUCCESS;
            break;


        case IRP_MJ_CLEANUP:
            status = STATUS_SUCCESS;
            break;


        case IRP_MJ_CLOSE:
            status = STATUS_SUCCESS;
            break;

        default:
            status = STATUS_INVALID_DEVICE_REQUEST;

    }


    if (status != STATUS_PENDING)
    {
        pIrpSp->Control &= ~SL_PENDING_RETURNED;
        pIrp->IoStatus.Status = status;
        IoCompleteRequest (pIrp, IO_NETWORK_INCREMENT);
    }

   return status;
}




//////////////////////////////////////////////////////////////////////////////
NTSTATUS
ntDispatchInternal (
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    )
//////////////////////////////////////////////////////////////////////////////
{
    NTSTATUS ntStatus         = STATUS_SUCCESS;
    PIO_STACK_LOCATION pIrpSp = NULL;

    ULONG ulIoctl        = 0L;
    ULONG ulInputLen     = 0L;
    ULONG ulOutputLen    = 0L;
    PVOID pvInputBuffer  = NULL;
    PVOID pvOutputBuffer = NULL;

    PIPSINK_NDIS_COMMAND pCmd = NULL;


    //
    // Make sure status information is consistent every time.
    //
    IoMarkIrpPending (pIrp);
    pIrp->IoStatus.Status      = STATUS_PENDING;
    pIrp->IoStatus.Information = 0;

    //
    // Get a pointer to the current stack location in the IRP.  This is where
    // the function codes and parameters are stored.
    //
    pIrpSp = IoGetCurrentIrpStackLocation (pIrp);

    ulIoctl     = pIrpSp->Parameters.DeviceIoControl.IoControlCode;
    ulInputLen  = pIrpSp->Parameters.DeviceIoControl.InputBufferLength;
    ulOutputLen = pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;
    pvInputBuffer = pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer;

    //
    // Case on the function that is being performed by the requestor.  If the
    // operation is a valid one for this device, then make it look like it was
    // successfully completed, where possible.
    //
    switch (pIrpSp->MajorFunction)
    {

        case IRP_MJ_CREATE:
            TEST_DEBUG (TEST_DBG_TRACE, ("ntDispatchInternal called, IRP_MJ_CREATE\n"));
            TEST_DEBUG (TEST_DBG_TRACE, ("    FileObject: %08X\n", pIrpSp->FileObject));
            ntStatus = STATUS_SUCCESS;
            break;


        case IRP_MJ_CLEANUP:
            TEST_DEBUG (TEST_DBG_TRACE, ("ntDispatchInternal called, IRP_MJ_CLEANUP\n"));
            ntStatus = STATUS_SUCCESS;
            break;


        case IRP_MJ_CLOSE:
            TEST_DEBUG (TEST_DBG_TRACE, ("ntDispatchInternal called, IRP_MJ_CLOSE\n"));
            ntStatus = STATUS_SUCCESS;
            break;

        case IRP_MJ_INTERNAL_DEVICE_CONTROL:
            TEST_DEBUG (TEST_DBG_TRACE, ("ntDispatchInternal called, IRP_MJ_INTERNAL_DEVICE_CONTROL\n"));

            switch (pIrpSp->Parameters.DeviceIoControl.IoControlCode)
            {
                case IOCTL_GET_INTERFACE:
                    TEST_DEBUG (TEST_DBG_TRACE, ("ntDispatchInternal control code: IOCTL_GET_NDIS_INTERFACE\n"));

                    pCmd = (PIPSINK_NDIS_COMMAND) pvInputBuffer;

                    switch (pCmd->ulCommandID)
                    {
                        case CMD_QUERY_INTERFACE:
                            TEST_DEBUG (TEST_DBG_TRACE, ("ntDispatchInternal control code: QueryInterface Command\n"));

                            //
                            // Define paramters we're returning to the streaming component
                            //
                            pCmd->Parameter.Query.pNdisAdapter = (PVOID) global_pAdapter;

                            //
                            // Save a pointer to the Streaming components vtable
                            //
                            global_pAdapter->pFilter = (PIPSINK_FILTER) pCmd->Parameter.Query.pStreamAdapter;

                            //
                            // Increment the reference count for the filter
                            //
                            global_pAdapter->pFilter->lpVTable->AddRef (global_pAdapter->pFilter);


                            ntStatus = STATUS_SUCCESS;
                            break;

                        default:
                            ntStatus = STATUS_INVALID_DEVICE_REQUEST;
                            break;
                    }
                    break;


                default:
                    ntStatus = STATUS_INVALID_DEVICE_REQUEST;
                    break;
            }
            break;

        default:
            ntStatus = STATUS_INVALID_DEVICE_REQUEST;
            break;

    }

//ret:

    if (ntStatus != STATUS_PENDING)
    {
        pIrpSp->Control &= ~SL_PENDING_RETURNED;
        pIrp->IoStatus.Status = ntStatus;
        IoCompleteRequest (pIrp, IO_NETWORK_INCREMENT);
    }

   return ntStatus;
}


//////////////////////////////////////////////////////////////////////////////
NTSTATUS
ntInitializeDeviceObject(
    IN PVOID            nhWrapperHandle,
    IN PADAPTER         pAdapter,
    OUT PDEVICE_OBJECT *pndisDriverObject,
    OUT PVOID          *pndisDeviceHandle
    )
//////////////////////////////////////////////////////////////////////////////
{
    NTSTATUS status                                             = 0l;
    PDEVICE_OBJECT   pDeviceObject                              = NULL;
    PVOID            ndisDeviceHandle                           = NULL;
    UNICODE_STRING   DeviceName;
    UNICODE_STRING   SymbolicName;
    PDRIVER_DISPATCH pDispatchTable[IRP_MJ_MAXIMUM_FUNCTION+1]    = {NULL}; //wdm defines IRP_MJ_MAXIMUM_FUNCTION = IRP_MJ_PNP

    //
    // Set the dispatch entries we are interested in.
    //
    pDispatchTable[IRP_MJ_CREATE]                  = ntDispatchOpenClose;
    pDispatchTable[IRP_MJ_CLOSE]                   = ntDispatchOpenClose;
    pDispatchTable[IRP_MJ_CLEANUP]                 = ntDispatchOpenClose;
    pDispatchTable[IRP_MJ_INTERNAL_DEVICE_CONTROL] = ntDispatchInternal;
    
    pDispatchTable[IRP_MJ_DEVICE_CONTROL]          = NULL;
    pDispatchTable[IRP_MJ_FLUSH_BUFFERS]           = NULL;
    pDispatchTable[IRP_MJ_PNP]		           = NULL;
    pDispatchTable[IRP_MJ_POWER]       		   = NULL;
    pDispatchTable[IRP_MJ_QUERY_INFORMATION]       = NULL;
    pDispatchTable[IRP_MJ_READ]       		   = NULL;
    pDispatchTable[IRP_MJ_SET_INFORMATION]         = NULL;
    pDispatchTable[IRP_MJ_SHUTDOWN]      	   = NULL;
    pDispatchTable[IRP_MJ_SYSTEM_CONTROL]   	   = NULL;
    pDispatchTable[IRP_MJ_WRITE]	           = NULL;


    //
    // Initialize the device, dosdevice and symbolic names.
    //
    RtlInitUnicodeString(&DeviceName, BDA_NDIS_MINIPORT);
    RtlInitUnicodeString(&SymbolicName, BDA_NDIS_SYMBOLIC_NAME);

    status = RegisterDevice (nhWrapperHandle,
                             &DeviceName,
                             &SymbolicName,
                             pDispatchTable,
                             &pDeviceObject,
                             &ndisDeviceHandle);

    if (status == STATUS_SUCCESS)
    {
        *pndisDeviceHandle = ndisDeviceHandle;
        *pndisDriverObject = pDeviceObject;
    }

    CTL_CODE(FILE_DEVICE_UNKNOWN,IOCTL_GET_INTERFACE,METHOD_BUFFERED,FILE_READ_ACCESS);
    
    return status;
}


#ifdef WIN9X


//////////////////////////////////////////////////////////////////////////////
NTSTATUS
ntCreateDeviceContext(
    IN PDRIVER_OBJECT pDriverObject
    )
//////////////////////////////////////////////////////////////////////////////
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_OBJECT  pDeviceObject;
    UNICODE_STRING  DeviceName;
    UNICODE_STRING  dosdeviceName;
    UNICODE_STRING  symbolicName;

    //
    // Create the device object for the sample transport, allowing
    // room at the end for the device name to be stored (for use
    // in logging errors).
    //

    RtlInitUnicodeString(&DeviceName, BDA_NDIS_MINIPORT);
    ntStatus = IoCreateDevice(
                 pDriverObject,
                 0,
                 &DeviceName,
                 0x00000022,  // FILE_DEVICE_UNKNOWN
                 0,
                 FALSE,
                 &pDeviceObject);

    CTL_CODE(FILE_DEVICE_UNKNOWN,IOCTL_GET_INTERFACE,METHOD_BUFFERED,FILE_READ_ACCESS);

    if (ntStatus != STATUS_SUCCESS)
    {
        goto ret;
    }

    //
    // Set device flag(s).
    //

    pDeviceObject->Flags |= DO_DIRECT_IO;

    //
    // Create Symbolic Link
    //
    RtlInitUnicodeString(&dosdeviceName, BDA_NDIS_MINIPORT);
    RtlInitUnicodeString(&symbolicName,  BDA_NDIS_SYMBOLIC_NAME);

    ntStatus = IoCreateSymbolicLink(
                &symbolicName,
                &dosdeviceName );

    if (ntStatus != STATUS_SUCCESS)
    {
        ASSERT (FALSE);
    }

    pDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

ret:

    return ntStatus;
}



//////////////////////////////////////////////////////////////////////////////
NTSTATUS
ntInitializeDriverObject(
    PDRIVER_OBJECT *ppDriverObject
    )
//////////////////////////////////////////////////////////////////////////////
{
    NTSTATUS ntStatus = 0l;
    UNICODE_STRING  objectName;
    PDRIVER_OBJECT  pDriverObject = *ppDriverObject;

    //
    // In case we did not create this driver object, set our global variable
    // equal to the one supplied.
    //
    pGlobalDriverObject = pDriverObject;
    *ppDriverObject = pDriverObject;

    //
    // Create a device object and symbolic name.
    //
    ntStatus = ntCreateDeviceContext(pDriverObject);
    if(ntStatus)
    {
        goto ret;
    }

ret:

    return ntStatus;
}

//////////////////////////////////////////////////////////////////////////////
VOID
vSetDriverDispatchTable(
    PDRIVER_OBJECT pDriverObject
    )
//////////////////////////////////////////////////////////////////////////////
{

    //
    // Initialize the driver object with this driver's entry points.
    //

    pDriverObject->MajorFunction [IRP_MJ_CREATE] = ntDispatchOpenClose;
    pDriverObject->MajorFunction [IRP_MJ_CLOSE] = ntDispatchOpenClose;
    pDriverObject->MajorFunction [IRP_MJ_CLEANUP] = ntDispatchOpenClose;
    pDriverObject->MajorFunction [IRP_MJ_INTERNAL_DEVICE_CONTROL] = ntDispatchInternal;
    pDriverObject->MajorFunction [IRP_MJ_DEVICE_CONTROL] = NULL;
    pDriverObject->DriverUnload = vUnload;

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\bda\ipsink\ndis\frame.c ===
/////////////////////////////////////////////////////////////////////////////
//
//
// Copyright (c) 1996, 1997  Microsoft Corporation
//
//
// Module Name:
//      test.c
//
// Abstract:
//
//      This file is a test to find out if dual binding to NDIS and KS works
//
// Author:
//
//      P Porzuczek
//
// Environment:
//
// Revision History:
//
//
//////////////////////////////////////////////////////////////////////////////
#include <forward.h>
#include <memory.h>

//Per ndis.h resetting this flag uses ntddk.Avoids header conflicts.
//ntddk is used here for ProbeForRead and ProbeForWrite functions.
#if defined(BINARY_COMPATIBLE)
#undef BINARY_COMPATIBLE
#define BINARY_COMPATIBLE 0
#endif

#include <ndis.h>

#if defined(BINARY_COMPATIBLE)
#undef BINARY_COMPATIBLE
#define BINARY_COMPATIBLE 1
#endif

#include <link.h>
#include <ipsink.h>


#include "NdisApi.h"
#include "frame.h"
#include "mem.h"
#include "main.h"

#define SourceRoutingFlagCheckCycle 5000
#define EnableIPRouting 1
extern PADAPTER        global_pAdapter;
//////////////////////////////////////////////////////////
//
//
const FRAME_POOL_VTABLE FramePoolVTable =
    {
    FramePool_QueryInterface,
    FramePool_AddRef,
    FramePool_Release,
    };



//////////////////////////////////////////////////////////
//
//
const FRAME_VTABLE FrameVTable =
    {
    Frame_QueryInterface,
    Frame_AddRef,
    Frame_Release,
    };



///////////////////////////////////////////////////////////////////////////////////
NTSTATUS
CreateFramePool (
 PADAPTER pAdapter,
 PFRAME_POOL  *pFramePool,
 ULONG    ulNumFrames,
 ULONG    ulFrameSize,
 ULONG    ulcbMediaInformation
 )
///////////////////////////////////////////////////////////////////////////////////
{
    NTSTATUS nsResult = STATUS_UNSUCCESSFUL;
    PFRAME_POOL  pF = NULL;
    PFRAME pFrame = NULL;
    ULONG uli = 0;

    nsResult = AllocateMemory (&pF, sizeof (FRAME_POOL));
    if (nsResult != NDIS_STATUS_SUCCESS)
    {
        return nsResult;
    }

    NdisAllocateSpinLock (&pF->SpinLock);

    pF->pAdapter    = pAdapter;
    pF->ulFrameSize = ulFrameSize;
    pF->ulNumFrames = ulNumFrames;
    pF->ulRefCount  = 1;
    pF->lpVTable    = (PFRAME_POOL_VTABLE) &FramePoolVTable;

    //
    //  Allocate the NDIS buffer pool.
    //
    NdisAllocateBufferPool( &nsResult,
                            &pF->ndishBufferPool,
                            pF->ulNumFrames
                          );
    if (nsResult != NDIS_STATUS_SUCCESS)
    {
        return nsResult;
    }

    //
    //  Allocate the NDIS packet pool.
    //
    NdisAllocatePacketPool (&nsResult,
                            &pF->ndishPacketPool,
                            pF->ulNumFrames,
                            ulcbMediaInformation
                           );
    if (nsResult != NDIS_STATUS_SUCCESS)
    {
        return nsResult;
    }

    InitializeListHead (&pF->leAvailableQueue);
    InitializeListHead (&pF->leIndicateQueue);

    //
    // Create the frames
    //
    for (uli = 0; uli < pF->ulNumFrames; uli++)
    {
        nsResult = CreateFrame (&pFrame, pF->ulFrameSize, pF->ndishBufferPool, pF);
        if (nsResult != STATUS_SUCCESS)
        {
            pF->lpVTable->Release (pF);
            return nsResult;
        }


        //
        // Save the frame on the available frame queue
        //
        TEST_DEBUG (TEST_DBG_TRACE, ("Putting Frame %08X on Available Queue", pFrame));
        PutFrame (pF, &pF->leAvailableQueue, pFrame);
    }


    *pFramePool = pF;
    
    return nsResult;
}



///////////////////////////////////////////////////////////////////////////////////
NDIS_STATUS
FreeFramePool (
    PFRAME_POOL pFramePool
    )
///////////////////////////////////////////////////////////////////////////////////
{
    PLIST_ENTRY ple = NULL;
    PFRAME pFrame   = NULL;
    ULONG  uli      = 0;
    NDIS_STATUS nsResult = NDIS_STATUS_SUCCESS;

    if (pFramePool == NULL)
    {
        nsResult = NDIS_STATUS_FAILURE;
        return nsResult;
    }

    //
    // If there are any indicated frames we return an error
    //
    NdisAcquireSpinLock (&pFramePool->SpinLock);
    if (! IsListEmpty (&pFramePool->leIndicateQueue))
    {
        nsResult = NDIS_STATUS_FAILURE;
        goto ret;
    }

    //
    // Go thru each frame in the available queue delete it
    //
    for (uli = 0; uli < pFramePool->ulNumFrames; uli++)
    {
        if (! IsListEmpty (&pFramePool->leAvailableQueue))
        {
            ple = RemoveHeadList (&pFramePool->leAvailableQueue);
            pFrame = CONTAINING_RECORD (ple, FRAME, leLinkage);

            if (pFrame->lpVTable->Release (pFrame) != 0)
            { 
               //Force assertion failure 
               ASSERT(FALSE);
            }
        }
    }

    if (pFramePool->ndishBufferPool)
    {
        NdisFreeBufferPool (pFramePool->ndishBufferPool);
    }

    if (pFramePool->ndishPacketPool)
    {
        NdisFreePacketPool (pFramePool->ndishPacketPool);
    }

    nsResult = NDIS_STATUS_SUCCESS;

ret:

    NdisReleaseSpinLock (&pFramePool->SpinLock);

    if (nsResult == NDIS_STATUS_SUCCESS)
    {
        FreeMemory (pFramePool, sizeof (FRAME_POOL));
    }

    return nsResult;

}

///////////////////////////////////////////////////////////////////////////////////
NTSTATUS
FramePool_QueryInterface (
    PFRAME_POOL pFramePool
    )
///////////////////////////////////////////////////////////////////////////////////
{
    return STATUS_NOT_IMPLEMENTED;
}

///////////////////////////////////////////////////////////////////////////////////
ULONG
FramePool_AddRef (
    PFRAME_POOL pFramePool
    )
///////////////////////////////////////////////////////////////////////////////////
{
    if (pFramePool)
    {
        pFramePool->ulRefCount += 1;
        return pFramePool->ulRefCount;
    }

    return 0;
}

///////////////////////////////////////////////////////////////////////////////////
ULONG
FramePool_Release (
    PFRAME_POOL pFramePool
    )
///////////////////////////////////////////////////////////////////////////////////
{
    ULONG ulRefCount = 0L;

    if (pFramePool)
    {
        pFramePool->ulRefCount -= 1;
        ulRefCount = pFramePool->ulRefCount;

        if (pFramePool->ulRefCount == 0)
        {
            FreeFramePool (pFramePool);
            return ulRefCount;
        }
    }

    return ulRefCount;
}


///////////////////////////////////////////////////////////////////////////////////
PFRAME
GetFrame (
    PFRAME_POOL pFramePool,
    PLIST_ENTRY pQueue
    )
///////////////////////////////////////////////////////////////////////////////////
{
    PFRAME pFrame   = NULL;
    PLIST_ENTRY ple = NULL;

    if(pFramePool){
    NdisAcquireSpinLock (&pFramePool->SpinLock);

    if (IsListEmpty (pQueue))
    {
        NdisReleaseSpinLock (&pFramePool->SpinLock);
        return NULL;
    }


    ple = RemoveHeadList (pQueue);
    if (ple)
    {
        pFrame = CONTAINING_RECORD (ple, FRAME, leLinkage);

    }

    NdisReleaseSpinLock (&pFramePool->SpinLock);
    	}
    return pFrame;

}
///////////////////////////////////////////////////////////////////////////

NTSTATUS IsOverRideSet(UINT *DisableBDAMiniport)
{

    UNICODE_STRING      unicodeString;
    OBJECT_ATTRIBUTES   objectAttributes;
    HANDLE              hErrKey=0;
    NTSTATUS            status;
    ULONG               disposition=REG_OPENED_EXISTING_KEY;
    ULONG		DisableMiniport=1;

    WCHAR ValueBuffer[400];
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation;
    ULONG ResultLength=0;
    

    RtlInitUnicodeString (&unicodeString, L"\\Registry\\MACHINE\\SYSTEM\\CurrentControlSet\\Services\\NdisIP");
    InitializeObjectAttributes (
        &objectAttributes,
        &unicodeString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);


    status = ZwCreateKey (&hErrKey,
                          KEY_WRITE,
                          &objectAttributes,
                          0,
                          NULL,
                          REG_OPTION_NON_VOLATILE,
                          &disposition);

    if (!NT_SUCCESS(status)) {
        return status ;
    }

  
   switch(disposition)
    {
	case REG_CREATED_NEW_KEY:
		 RtlInitUnicodeString(&unicodeString, L"DisableWhileIPRoutingEnabled");
		 DisableMiniport = 1;
       	  ZwSetValueKey(hErrKey,
                                      &unicodeString,
                                      0,
                                      REG_DWORD,
                                      &DisableMiniport,
                                      sizeof(DisableMiniport));
		  *DisableBDAMiniport=1;
		  DbgPrint("3. BDA Disable miniport Key value created and set to 1\n ");
  
		 break;	
	case REG_OPENED_EXISTING_KEY: 
		 RtlInitUnicodeString(&unicodeString, L"DisableWhileIPRoutingEnabled");
                KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION)ValueBuffer;
                status = ZwQueryValueKey( hErrKey,
                                          &unicodeString,
                                          KeyValuePartialInformation,
                                          KeyValueInformation,
                                          sizeof( ValueBuffer ),
                                          &ResultLength
                                         );
                if (NT_SUCCESS(status)) {
                     if (KeyValueInformation->Type != REG_DWORD) 
                     	{
                              status = STATUS_UNSUCCESSFUL;
                             }
 		 	*DisableBDAMiniport=*(KeyValueInformation->Data);
		  DbgPrint("4. BDA Disable  miniport Key value read and now returning %d",*DisableBDAMiniport);
		   } 
                break;
       default: break;
 	
      }

    ZwClose(hErrKey);
    return status;

}

//////////////////////////////////////////////////////////////////////////
NTSTATUS SourceRouteFlagCheck(UINT * BDAAdapterEnable)
{
    OBJECT_ATTRIBUTES DeviceListAttributes;
     HANDLE KeyHandle;
     UNICODE_STRING uniName;
    NTSTATUS nsResult;
  
     RtlInitUnicodeString(&uniName,L"\\Registry\\MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters");

      InitializeObjectAttributes(
                        &DeviceListAttributes,
                        &uniName,
                        OBJ_CASE_INSENSITIVE,
                        NULL,
                        NULL);

      nsResult = ZwOpenKey(
                        &KeyHandle,
                        KEY_ALL_ACCESS,
                       &DeviceListAttributes
                        );
 
      if (NT_SUCCESS(nsResult)) {
      	
      	        UNICODE_STRING NameString;
      	         WCHAR ValueBuffer[400];
      	         PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation;
      	         ULONG ResultLength;
      	         
                RtlInitUnicodeString( &NameString, L"IPEnableRouter" );
                KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION)ValueBuffer;
                nsResult = ZwQueryValueKey( KeyHandle,
                                          &NameString,
                                          KeyValuePartialInformation,
                                          KeyValueInformation,
                                          sizeof( ValueBuffer ),
                                          &ResultLength
                                         );
                if (NT_SUCCESS(nsResult)) {
                     if (KeyValueInformation->Type != REG_DWORD) 
                     	{
                              nsResult = STATUS_UNSUCCESSFUL;
                              return nsResult;
                              }
                   		if(*(KeyValueInformation->Data)==EnableIPRouting){
					UINT DisableBDAMiniport=1;
					 if(NT_SUCCESS(IsOverRideSet(&DisableBDAMiniport)))	
					 	{  //If DisableBDAMiniport is set then leave the BDAAdapterEnable unchanged. Otherwise, disable
 						 if(DisableBDAMiniport==0)
 						 	{
 						 	 *BDAAdapterEnable = 1;
 		          			        DbgPrint("Disable BDA  is not set  %d\n",DisableBDAMiniport);
   						       }
 						 else
 						 	{
 						 	*BDAAdapterEnable = 0;
							DbgPrint("Disable BDA  is  set:Disabling NDIS indication now %d\n",DisableBDAMiniport);
 						        }
					       }
                                     else{ 
                                     	 //To be  fail safe if OverRide cannot be read, disable our port when IP Routing is enabled	
                                     	 *BDAAdapterEnable = 0;
                   			       nsResult=STATUS_UNSUCCESSFUL;
             			              DbgPrint("Source Routing is turned on:Disable BDA flag could not be read::Ndis disabled now\n");
                                     }
                   		}
                   		else{
				   *BDAAdapterEnable=1;	
                   		}
                  }
		  ZwClose( KeyHandle );
            }

      return nsResult;
}

/////////////////////////////////////////////////////////////////////////////

void
SourceRoutingStatusPoll()

{
       


 static ULONG ulFrameCnt = 0 ;
 
  	 if(((ulFrameCnt++)%SourceRoutingFlagCheckCycle)==1){
           	DbgPrint("Now calling AdapterStatusPollingThread");
               if (!NT_SUCCESS(SourceRouteFlagCheck(&(global_pAdapter->BDAAdapterEnable)))) {
            		 DbgPrint("Registry read for Routing info could not be read\n");
           	}
        }
 
}

/////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
NTSTATUS
IndicateFrame (
    IN  PFRAME    pFrame,
    IN  ULONG     ulcbData
    )
//////////////////////////////////////////////////////////////////////////////
{
    NDIS_STATUS  nsResult    = NDIS_STATUS_SUCCESS;
    PFRAME_POOL  pFramePool  = NULL;
    PNDIS_PACKET pNdisPacket = NULL;


    pFramePool = pFrame->pFramePool;

    if(pFramePool->pAdapter->BDAAdapterEnable==0)
             		{
			// DbgPrint("Source Routing is turned on: BDA overRide not set: STOPPED NDIS indicationfrom BDA adapter\n");

			// Release this frame since we're done using it
        	        pFrame->lpVTable->Release (pFrame);
                      PutFrame (pFrame->pFramePool, &pFrame->pFramePool->leAvailableQueue, pFrame);
          	       return STATUS_UNSUCCESSFUL;
              	}
     
    
    //
    //      Allocate and initialize an NDIS Packet.
    //
    NdisAllocatePacket (&nsResult, &pNdisPacket, pFramePool->ndishPacketPool);
    if (nsResult != NDIS_STATUS_SUCCESS)
    {
        pFramePool->pAdapter->stats.ulOID_GEN_RCV_NO_BUFFER += 1;
        goto ret;
    }


    NDIS_SET_PACKET_HEADER_SIZE (pNdisPacket, 14);
    NDIS_SET_PACKET_STATUS (pNdisPacket, NDIS_STATUS_SUCCESS);

    //
    //      Fill in the media specific info.
    //
    pFrame->MediaSpecificInformation.pFrame = pFrame;
    NDIS_SET_PACKET_MEDIA_SPECIFIC_INFO (
             pNdisPacket,
             &pFrame->MediaSpecificInformation,
             sizeof (IPSINK_MEDIA_SPECIFIC_INFORMATION)
             );

    //
    //      Add the data to the packet.
    //
    NdisChainBufferAtBack (pNdisPacket, pFrame->pNdisBuffer);

    //
    //  Set the number of bytes we'll be indicating
    //
    ASSERT( ulcbData <= pFrame->ulFrameSize );
    if(ulcbData > pFrame->ulFrameSize)
    	{
	nsResult = NDIS_STATUS_FAILURE;
	goto ret;
       }
    
    NdisAdjustBufferLength (pFrame->pNdisBuffer, ulcbData);


    TEST_DEBUG (TEST_DBG_TRACE, ("NdisIP: Indicating IP Packet, size: %d to Ndis\n", ulcbData));


    NdisMIndicateReceivePacket (pFramePool->pAdapter->ndishMiniport, &pNdisPacket, 1);

    pFramePool->pAdapter->stats.ulOID_GEN_RCV_OK += 1;
    pFramePool->pAdapter->stats.ulOID_GEN_MULTICAST_BYTES_RCV += ulcbData;
    pFramePool->pAdapter->stats.ulOID_GEN_MULTICAST_FRAMES_RCV += 1;


    nsResult = NDIS_GET_PACKET_STATUS( pNdisPacket);
    if (nsResult != NDIS_STATUS_PENDING)
    {
        //
        //      NDIS is through with the packet so we need to free it
        //      here.
        //
        NdisFreePacket (pNdisPacket);

        //
        // Release this frame since we're done using it
        //
        pFrame->lpVTable->Release (pFrame);

        //
        // Put Frame back on available queue.
        //
        if (nsResult != STATUS_SUCCESS)
        {
            TEST_DEBUG (TEST_DBG_TRACE, ("NdisIP: Frame %08X Rejected by NDIS...putting back on Available Queue\n", pFrame));
        }
        else
        {
            TEST_DEBUG (TEST_DBG_TRACE, ("NdisIP: Frame %08X successfully indicated\n", pFrame));
        }

        PutFrame (pFrame->pFramePool, &pFrame->pFramePool->leAvailableQueue, pFrame);
    }

ret:

    return NTStatusFromNdisStatus (nsResult);
}



///////////////////////////////////////////////////////////////////////////////////
PFRAME
PutFrame (
    PFRAME_POOL pFramePool,
    PLIST_ENTRY pQueue,
    PFRAME pFrame
    )
///////////////////////////////////////////////////////////////////////////////////
{
    PLIST_ENTRY ple = NULL;

    NdisAcquireSpinLock (&pFramePool->SpinLock);
    InsertTailList (pQueue, &pFrame->leLinkage);
    NdisReleaseSpinLock (&pFramePool->SpinLock);

    return pFrame;

}



///////////////////////////////////////////////////////////////////////////////////
NTSTATUS
CreateFrame (
    PFRAME *pFrame,
    ULONG  ulFrameSize,
    NDIS_HANDLE ndishBufferPool,
    PFRAME_POOL pFramePool
    )
///////////////////////////////////////////////////////////////////////////////////
{
    PFRAME pF;
    NDIS_STATUS nsResult;


    nsResult = AllocateMemory (&pF, sizeof (FRAME));
    if (nsResult != NDIS_STATUS_SUCCESS)
    {
        return nsResult;
    }

    nsResult = AllocateMemory (&pF->pvMemory, ulFrameSize);
    if (nsResult != NDIS_STATUS_SUCCESS)
    {
        FreeMemory (pF, sizeof (FRAME));
        return nsResult;
    }


    NdisAllocateBuffer (&nsResult,
                        &pF->pNdisBuffer,
                        ndishBufferPool,
                        pF->pvMemory,
                        ulFrameSize
                       );
    if (nsResult != NDIS_STATUS_SUCCESS)
    {
	 FreeMemory (pF->pvMemory, ulFrameSize);
        FreeMemory (pF, sizeof (FRAME));
        return nsResult;
    }

    pF->pFramePool       = pFramePool;
    pF->ulState          = 0;
    pF->ulFrameSize      = ulFrameSize;
    pF->ulRefCount       = 1;
    pF->lpVTable         = (PFRAME_VTABLE) &FrameVTable;

    *pFrame = pF;

    return nsResult;

}

///////////////////////////////////////////////////////////////////////////////////
NTSTATUS
FreeFrame (
    PFRAME pFrame
    )
///////////////////////////////////////////////////////////////////////////////////
{
    NTSTATUS nsResult = STATUS_UNSUCCESSFUL;

    if (pFrame)
    {
        NdisFreeBuffer (pFrame->pNdisBuffer);
        FreeMemory (pFrame->pvMemory, pFrame->ulFrameSize);
        FreeMemory (pFrame, sizeof (FRAME));
        nsResult = STATUS_SUCCESS;
    }

    return nsResult;
}

///////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Frame_QueryInterface (
    PFRAME pFrame
    )
///////////////////////////////////////////////////////////////////////////////////
{
    return STATUS_NOT_IMPLEMENTED;
}

///////////////////////////////////////////////////////////////////////////////////
ULONG
Frame_AddRef (
    PFRAME pFrame
    )
///////////////////////////////////////////////////////////////////////////////////
{
    if (pFrame)
    {
        pFrame->ulRefCount += 1;
        return pFrame->ulRefCount;
    }

    return 0;
}

///////////////////////////////////////////////////////////////////////////////////
ULONG
Frame_Release (
    PFRAME pFrame
    )
///////////////////////////////////////////////////////////////////////////////////
{
    ULONG ulRefCount = 0L;

    if (pFrame)
    {
        pFrame->ulRefCount -= 1;
        ulRefCount = pFrame->ulRefCount;

        if (pFrame->ulRefCount == 0)
        {
            FreeFrame (pFrame);
            return ulRefCount;
        }
    }

    return ulRefCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\bda\ipsink\ndis\frame.h ===
/////////////////////////////////////////////////////////////////////////////
//
//
// Copyright (c) 1996, 1997  Microsoft Corporation
//
//
// Module Name:
//      frame.h
//
// Abstract:
//
//      This file is the include file for frame objects
//
// Author:
//
//      P Porzuczek
//
// Environment:
//
// Revision History:
//
//
//////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//
//
#define IPSINK_NDIS_MAX_BUFFERS                 64
#define MAX_IP_PACKET_SIZE                      4082
#define IPSINK_NDIS_BUFFER_SIZE                 4096


//////////////////////////////////////////////////////////
//
//
//
typedef enum
{
    FRAME_STATE_AVAILABLE  = 0x00000001,
    FRAME_STATE_INDICATED,
    MAX_FRAME_STATES

} FRAME_STATE;

//////////////////////////////////////////////////////////
//
//
//
typedef struct _MEDIA_SPECIFIC_INFORMATION_
{
    PFRAME pFrame;

} IPSINK_MEDIA_SPECIFIC_INFORMATION, *PIPSINK_MEDIA_SPECIFIC_INFORAMTION;

//////////////////////////////////////////////////////////
//
//
//
typedef struct _FRAME_
{
    LIST_ENTRY    leLinkage;
    ULONG         ulRefCount;
    ULONG         ulFrameSize;
    ULONG         ulState;
    ULONG         ulcbData;
    PFRAME_POOL   pFramePool;
    PVOID         pvMemory;
    PNDIS_BUFFER  pNdisBuffer;
    PFRAME_VTABLE lpVTable;
    IPSINK_MEDIA_SPECIFIC_INFORMATION MediaSpecificInformation;
};

//////////////////////////////////////////////////////////
//
//
//
typedef struct _FRAME_POOL_
{
    PADAPTER    pAdapter;
    ULONG       ulRefCount;
    ULONG       ulNumFrames;
    ULONG       ulFrameSize;
    ULONG       ulState;
    NDIS_HANDLE ndishBufferPool;
    NDIS_HANDLE ndishPacketPool;
    LIST_ENTRY  leAvailableQueue;
    LIST_ENTRY  leIndicateQueue;
    NDIS_SPIN_LOCK SpinLock;
    PFRAME_POOL_VTABLE lpVTable;
};


///////////////////////////////////////////////////////////////////////////////////
//
//
//
NTSTATUS
CreateFramePool (
 PADAPTER pAdapter,
 PFRAME_POOL  *pFramePool,
 ULONG    ulNumFrames,
 ULONG    ulFrameSize,
 ULONG    ulcbMediaInformation
 );

NDIS_STATUS
FreeFramePool (
    PFRAME_POOL pFramePool
    );

NTSTATUS
FramePool_QueryInterface (
    PFRAME_POOL pFramePool
    );

ULONG
FramePool_AddRef (
    PFRAME_POOL pFramePool
    );

ULONG
FramePool_Release (
    PFRAME_POOL pFramePool
    );

PFRAME
GetFrame (
    PFRAME_POOL pFramePool,
    PLIST_ENTRY pQueue
    );

PFRAME
PutFrame (
    PFRAME_POOL pFramePool,
    PLIST_ENTRY pQueue,
    PFRAME pFrame
    );

///////////////////////////////////////////////////////////////////////////////////
//
//
//
NTSTATUS
CreateFrame (
    PFRAME *pFrame,
    ULONG  ulFrameSize,
    NDIS_HANDLE ndishBufferPool,
    PFRAME_POOL pFramePool
    );

NTSTATUS
Frame_QueryInterface (
    PFRAME pFrame
    );

ULONG
Frame_AddRef (
    PFRAME pFrame
    );

ULONG
Frame_Release (
    PFRAME pFrame
    );

NTSTATUS
IndicateFrame (
    IN  PFRAME    pFrame,
    IN  ULONG     ulcbData
    );


void
SourceRoutingStatusPoll(
	);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\bda\ipsink\ndis\makefile.inc ===
# HACK ALERT: This target is solely to keep nmake from whining that it doesn't
# know how to make the dependency in rules that depend on the target executable.
$(TARGETPATHEX)\$(TARGETNAME).sys:

# Build SoftICE symbols
$(TARGETPATHEX)\$(TARGETNAME).nms: $(TARGETPATHEX)\$(TARGETNAME).sys
    echo $(TARGETPATHEX)\$(TARGETNAME) > target.txt
    nmsym /translate:source,package,always /source:. /output:$(TARGETPATHEX)\$(TARGETNAME).nms $(TARGETPATHEX)\$(TARGETNAME).sys
    splitsym -s $(_NT_SYMBOL_PATH)  $(TARGETPATHEX)\$(TARGETNAME).sys

# Delete built files
clean:
    -echo $(TARGETPATHEX)\$(TARGETNAME).*
    -del /s *.obj
    -del /s *.res
    -del build.log
    -del build.err
    -del /s _objects.mac
    -del $(TARGETPATHEX)\$(TARGETNAME).*
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\bda\ipsink\ndis\mem.c ===
/////////////////////////////////////////////////////////////////////////////
//
//
// Copyright (c) 1996, 1997  Microsoft Corporation
//
//
// Module Name:
//      test.c
//
// Abstract:
//
//      This file is a test to find out if dual binding to NDIS and KS works
//
// Author:
//
//      P Porzuczek
//
// Environment:
//
// Revision History:
//
//
//////////////////////////////////////////////////////////////////////////////


#include <memory.h>
#include <ndis.h>

#include <strsafe.h>

#define MAX_STR_LEN 1024

NDIS_PHYSICAL_ADDRESS HighestAcceptableMax = NDIS_PHYSICAL_ADDRESS_CONST(-1,-1);

//////////////////////////////////////////////////////////////////////////////
VOID
FreeMemory (
    PVOID pvToFree,
    ULONG ulSize
    )
//////////////////////////////////////////////////////////////////////////////
{
    if (pvToFree != NULL)
    {
        NdisFreeMemory(pvToFree, ulSize, 0);
    }

    return;
}


//////////////////////////////////////////////////////////////////////////////
NTSTATUS
AllocateMemory (
    PVOID  *ppvAllocated,
    ULONG   ulcbSize
    )
//////////////////////////////////////////////////////////////////////////////
{
    PVOID pvBlock;
    NDIS_STATUS nsResult = NDIS_STATUS_SUCCESS;

    nsResult = NdisAllocateMemory (&pvBlock, ulcbSize, 0, HighestAcceptableMax);
    if (!pvBlock)
    {
        nsResult = NDIS_STATUS_RESOURCES;
    }

    if (nsResult != NDIS_STATUS_SUCCESS)
    {
        return nsResult;
    }

    NdisZeroMemory( pvBlock, ulcbSize);

    *ppvAllocated = pvBlock;

    return NDIS_STATUS_SUCCESS;
}

//////////////////////////////////////////////////////////////////////////////
ULONG
MyStrLen (
    PUCHAR p
    )
//////////////////////////////////////////////////////////////////////////////
{
    SIZE_T sizet = 0;

    if(StringCbLength(p,MAX_STR_LEN,&sizet)!=S_OK)
		return (0);
    return (ULONG)sizet;
}


//////////////////////////////////////////////////////////////////////////////
VOID
MyStrCat (
    PUCHAR pTarget,
    PUCHAR pSource
    )
//////////////////////////////////////////////////////////////////////////////
{
    PUCHAR p = pTarget + MyStrLen (pTarget);

    NdisMoveMemory (p, pSource, MyStrLen (pSource));

    return;
}

//////////////////////////////////////////////////////////////////////////////
PUCHAR
MyUlToA (
    ULONG  dwValue,
    PUCHAR pszStr,
    ULONG  dwRadix
    )
//////////////////////////////////////////////////////////////////////////////
{
    PUCHAR psz;
    char ch;

    for (psz = pszStr; dwValue != 0; dwValue/=dwRadix, psz++)
    {
        ch = (char)(dwValue%dwRadix);
        if (ch <= 9)
        {
            *psz = (char)(ch + '0');
        }
        else
        {
            *psz = (char)(ch - 10 + 'A');
        }
    }

    if (psz == pszStr)
    {
        pszStr[0] = '0';
        pszStr[1] = '\0';
    }
    else
    {
        PUCHAR psz2;

        *psz = '\0';
        for (psz2 = pszStr, psz--; psz2 < psz; psz2++, psz--)
        {
            ch = *psz2;
            *psz2 = *psz;
            *psz = ch;
        }
    }

    return pszStr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\bda\ipsink\ndis\main.c ===
/////////////////////////////////////////////////////////////////////////////
//
//
// Copyright (c) 1996, 1997  Microsoft Corporation
//
//
// Module Name:
//      test.c
//
// Abstract:
//
//      This file is a test to find out if dual binding to NDIS and KS works
//
// Author:
//
//      P Porzuczek
//
// Environment:
//
// Revision History:
//
//
//////////////////////////////////////////////////////////////////////////////


//
//
#include <forward.h>
#include <memory.h>
#include <ndis.h>
#include <link.h>
#include <ipsink.h>

#include "Main.h"
#include "NdisApi.h"

/////////////////////////////////////////////////////////////////////////////
//
// Highest accepatble memory address
//
NDIS_HANDLE global_ndishWrapper = NULL;



/////////////////////////////////////////////////////////////////////////////
//
// Default debug mode
//
ULONG TestDebugFlag = 0;
//ULONG TestDebugFlag = TEST_DBG_INFO | TEST_DBG_ERROR;

#ifdef  DBG

/////////////////////////////////////////////////////////////////////////////
// Debugging definitions
//


//
// Debug tracing defintions
//
#define TEST_LOG_SIZE 256
UCHAR TestLogBuffer[TEST_LOG_SIZE]={0};
UINT  TestLogLoc = 0;

/////////////////////////////////////////////////////////////////////////////
//
// Logging function in debug builds
//
extern VOID
TestLog (
    UCHAR c         // input character
    )
/////////////////////////////////////////////////////////////////////////////
{
    TestLogBuffer[TestLogLoc++] = c;

    TestLogBuffer[(TestLogLoc + 4) % TEST_LOG_SIZE] = '\0';

    if (TestLogLoc >= TEST_LOG_SIZE) {
        TestLogLoc = 0;
    }
}

#endif // DBG

//////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT    pDriverObject,
    IN PUNICODE_STRING   pszuRegistryPath
    )
//////////////////////////////////////////////////////////////////////////////////////
{
    NTSTATUS    ntStatus     = STATUS_SUCCESS;


    #ifdef BREAK_ON_STARTUP
    _asm {int 3};
    #endif

    //
    // Register the NDIS binding
    //
    ntStatus = NdisDriverInitialize (pDriverObject, pszuRegistryPath, &global_ndishWrapper);
    if (ntStatus != STATUS_SUCCESS)
    {
        goto ret;
    }




ret:

    TEST_DEBUG (TEST_DBG_TRACE, ("Driver Entry complete, ntStatus: %08X\n", ntStatus));

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\bda\ipsink\ndis\mem.h ===
/////////////////////////////////////////////////////////////////////////////
//
//
// Copyright (c) 1996, 1997  Microsoft Corporation
//
//
// Module Name:
//      test.c
//
// Abstract:
//
//      This file is a test to find out if dual binding to NDIS and KS works
//
// Author:
//
//      P Porzuczek
//
// Environment:
//
// Revision History:
//
//
//////////////////////////////////////////////////////////////////////////////

#ifndef _MEM_H_
#define _MEM_H_

VOID
FreeMemory (
    PVOID pvToFree,
    ULONG ulSize
    );

NTSTATUS
AllocateMemory (
    PVOID  *ppvAllocated,
    ULONG   ulcbSize
    );

ULONG
MyStrLen (
    PUCHAR p
    );

VOID
MyStrCat (
    PUCHAR pTarget,
    PUCHAR pSource
    );

      PUCHAR
MyUlToA (
    ULONG  dwValue,
    PUCHAR pszStr,
    ULONG  dwRadix
    );


#endif // _MEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\bda\ipsink\ndis\ndisapi.c ===
////////////////////////////////////////////////////////////////////////////
//
//
// Copyright (c) 1996, 1997  Microsoft Corporation
//
//
// Module Name:
//      test.c
//
// Abstract:
//
//      This file is a test to find out if dual binding to NDIS and KS works
//
// Author:
//
//      P Porzuczek
//
// Environment:
//
// Revision History:
//
//
//////////////////////////////////////////////////////////////////////////////

#include <forward.h>
#include <memory.h>

//Per ndis.h resetting this flag uses ntddk.Avoids header conflicts.
//ntddk is used here for ProbeForRead and ProbeForWrite functions.
#if defined(BINARY_COMPATIBLE)
#undef BINARY_COMPATIBLE
#define BINARY_COMPATIBLE 0
#endif

#include <ndis.h>

#if defined(BINARY_COMPATIBLE)
#undef BINARY_COMPATIBLE
#define BINARY_COMPATIBLE 1
#endif



#include <link.h>
#include <ipsink.h>

#include "device.h"
#include "main.h"
#include "NdisApi.h"
#include "frame.h"
#include "mem.h"
#include "adapter.h"

//////////////////////////////////////////////////////////
//
// Global vars
//
PDRIVER_OBJECT        pGlobalDriverObject                  = NULL;
extern ULONG          ulGlobalInstance;
extern UCHAR          achGlobalVendorDescription [];

//////////////////////////////////////////////////////////
//
// List of supported OID for this driver.
//
//
static UINT SupportedOids[] = {

    //
    //  Required General OIDs
    //
    OID_GEN_SUPPORTED_LIST,
    OID_GEN_HARDWARE_STATUS,
    OID_GEN_MEDIA_CAPABILITIES,
    OID_GEN_MEDIA_SUPPORTED,
    OID_GEN_MEDIA_IN_USE,
    OID_GEN_MAXIMUM_LOOKAHEAD,
    OID_GEN_MAXIMUM_FRAME_SIZE,
    OID_GEN_LINK_SPEED,
    OID_GEN_TRANSMIT_BUFFER_SPACE,
    OID_GEN_RECEIVE_BUFFER_SPACE,
    OID_GEN_TRANSMIT_BLOCK_SIZE,
    OID_GEN_RECEIVE_BLOCK_SIZE,
    OID_GEN_VENDOR_ID,
    OID_GEN_VENDOR_DESCRIPTION,
    OID_GEN_CURRENT_PACKET_FILTER,
    OID_GEN_CURRENT_LOOKAHEAD,
    OID_GEN_DRIVER_VERSION,
    OID_GEN_MAXIMUM_TOTAL_SIZE,
    OID_GEN_MAC_OPTIONS,
    OID_GEN_MEDIA_CONNECT_STATUS,
    OID_GEN_MAXIMUM_SEND_PACKETS,
    OID_GEN_VENDOR_DRIVER_VERSION,
    OID_GEN_TRANSPORT_HEADER_OFFSET,

    //
    //  Required General Statistics
    //
    OID_GEN_XMIT_OK,
    OID_GEN_RCV_OK,
    OID_GEN_XMIT_ERROR,
    OID_GEN_RCV_ERROR,
    OID_GEN_RCV_NO_BUFFER,

    //
    //  Optional General Statistics
    //
    OID_GEN_DIRECTED_BYTES_XMIT,
    OID_GEN_DIRECTED_FRAMES_XMIT,
    OID_GEN_MULTICAST_BYTES_XMIT,
    OID_GEN_MULTICAST_FRAMES_XMIT,
    OID_GEN_BROADCAST_BYTES_XMIT,
    OID_GEN_BROADCAST_FRAMES_XMIT,
    OID_GEN_DIRECTED_BYTES_RCV,
    OID_GEN_DIRECTED_FRAMES_RCV,
    OID_GEN_MULTICAST_BYTES_RCV,
    OID_GEN_MULTICAST_FRAMES_RCV,
    OID_GEN_BROADCAST_BYTES_RCV,
    OID_GEN_BROADCAST_FRAMES_RCV,
    OID_GEN_RCV_CRC_ERROR,
    OID_GEN_TRANSMIT_QUEUE_LENGTH,

    //
    //  Required 802.3 OIDs
    //
    OID_802_3_PERMANENT_ADDRESS,
    OID_802_3_CURRENT_ADDRESS,
    OID_802_3_MULTICAST_LIST,
    OID_802_3_MAXIMUM_LIST_SIZE,
    OID_802_3_MAC_OPTIONS,
    OID_802_3_RCV_ERROR_ALIGNMENT,
    OID_802_3_XMIT_ONE_COLLISION,
    OID_802_3_XMIT_MORE_COLLISIONS,


    };

//////////////////////////////////////////////////////////
//
//$BUGBUG - Fix Permanent Ethernet Address
//
//
UCHAR   rgchPermanentAddress[ETHERNET_ADDRESS_LENGTH] =
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };

//$BUGBUG - Fix Ethernet Station Address
UCHAR   rgchStationAddress[ETHERNET_ADDRESS_LENGTH] =
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };


NTSTATUS
ntInitializeDriverObject(
    PDRIVER_OBJECT *ppDriverObject
    );

VOID
vSetDriverDispatchTable(
    PDRIVER_OBJECT pDriverObject
    );


VOID
vUnload(
    IN PDRIVER_OBJECT pDriverObject
    )
{
    return;
}


//////////////////////////////////////////////////////////////////////////////
NTSTATUS
NdisDriverInitialize (
    IN PDRIVER_OBJECT    DriverObject,
    IN PUNICODE_STRING   RegistryPath,
    IN PNDIS_HANDLE      pNdishWrapper
    )
//////////////////////////////////////////////////////////////////////////////
{
    NTSTATUS        ntStatus = STATUS_SUCCESS;
    NDIS_STATUS     nsResult = NDIS_STATUS_SUCCESS;

    //
    // NDIS data
    //
    NDIS_MINIPORT_CHARACTERISTICS   ndisMiniChar = {0};
    NDIS_HANDLE                     ndishWrapper = {0};

    TEST_DEBUG (TEST_DBG_TRACE, ("NdisDriverInitialize Called\n"));


    //
    // Initialize Driver Object.
    // NOTE: The value of pDriverObject may change.
    //

    #ifdef WIN9X

    ntStatus = ntInitializeDriverObject(&DriverObject);
    if (ntStatus != STATUS_SUCCESS)
    {
        goto ret;
    }

    #endif

    //////////////////////////////////////////////////////
    //
    // Initialize the NDIS wrapper.
    //
    NdisMInitializeWrapper (&ndishWrapper,
                            DriverObject,
                            RegistryPath,
                            NULL);

    //////////////////////////////////////////////////////
    //
    // Initialize the Miniport Dispatch Table
    //
    ndisMiniChar.MajorNdisVersion            = 4;
    ndisMiniChar.MinorNdisVersion            = 0;

#ifdef NDIS30
    ndisMiniChar.Flags                       = 0;
#endif // NDIS30

    ndisMiniChar.HaltHandler                 = NdisIPHalt;
    ndisMiniChar.InitializeHandler           = NdisIPInitialize;
    ndisMiniChar.QueryInformationHandler     = NdisIPQueryInformation;
    ndisMiniChar.ResetHandler                = NdisIPReset;
    ndisMiniChar.SendHandler                 = NdisIPSend;
    ndisMiniChar.SetInformationHandler       = NdisIPSetInformation;
    ndisMiniChar.ReturnPacketHandler         = NdisIPReturnPacket;

    //
    // Register the miniport driver
    //
    nsResult = NdisMRegisterMiniport (ndishWrapper, &ndisMiniChar, sizeof(ndisMiniChar));
    if (nsResult != NDIS_STATUS_SUCCESS)
    {
        ntStatus = STATUS_UNSUCCESSFUL;
        goto ret;
    }



    *pNdishWrapper = ndishWrapper;

    #ifdef WIN9X

    vSetDriverDispatchTable (DriverObject);

    #endif

ret:

    TEST_DEBUG (TEST_DBG_TRACE, ("NdisDriverInitialize Called, ntStatus = %08X\n", ntStatus));

    return ntStatus;
}


///////////////////////////////////////////////////////////////////////////////////
extern
NDIS_STATUS
NdisIPInitialize(
    OUT PNDIS_STATUS   pnsOpenResult,
    OUT PUINT          puiSelectedMedium,
    IN PNDIS_MEDIUM    pNdisMediumArray,
    IN UINT            ucNdispNdisMediumArrayEntries,
    IN NDIS_HANDLE     ndishAdapterContext,
    IN NDIS_HANDLE     ndishWrapperConfiguration
    )
///////////////////////////////////////////////////////////////////////////////////
{
    NDIS_STATUS  nsResult            = NDIS_STATUS_SUCCESS;
    NDIS_HANDLE  ndishConfiguration  = NULL;
    PADAPTER     pAdapter            = NULL;
    UINT         uTemp               = 0;


    TEST_DEBUG (TEST_DBG_TRACE, ("NdisInitialize handler called\n"));

    //
    //  Search for the medium type (DSS) in the given array.
    //
    for ( uTemp = 0; uTemp < ucNdispNdisMediumArrayEntries; uTemp++)
    {
        if (pNdisMediumArray[uTemp] == NdisMedium802_3)
        {
            break;
        }
    }


    if (uTemp == ucNdispNdisMediumArrayEntries)
    {
        return NDIS_STATUS_UNSUPPORTED_MEDIA;
    }

   ASSERT(puiSelectedMedium);
   
    if(puiSelectedMedium==NULL)
    	{
    	 return NDIS_STATUS_FAILURE;
      }

    *puiSelectedMedium = uTemp;


    nsResult = CreateAdapter (&pAdapter, global_ndishWrapper, ndishAdapterContext);
    if (nsResult != NDIS_STATUS_SUCCESS)
    {
        return nsResult;
    }

    //
    // Initialize the information used to do indicates with
    //
    Adapter_IndicateReset (pAdapter);



    TEST_DEBUG (TEST_DBG_TRACE, ("NdisInitialize Handler Completed, nsResult = %08x\n", nsResult));


    return nsResult;
}


//////////////////////////////////////////////////////////////////////////////
// Removes an adapter that was previously initialized.
//
extern
VOID
NdisIPHalt(
    IN NDIS_HANDLE ndishAdapter
    )

//////////////////////////////////////////////////////////////////////////////
{
    PADAPTER   pAdapter = (PADAPTER) ndishAdapter;

    TEST_DEBUG (TEST_DBG_TRACE, ("NdisIPHalt Handler Called\n"));

    
    #ifndef WIN9X

    //
    // Deregister our device interface.  This should shut down the link to the
    // streaming component.
    //

   NdisMDeregisterDevice(pAdapter->ndisDeviceHandle);
    
    #endif

    //
    // Signal the Streaming component that we're halting.
    //
    if (pAdapter)
    {
        if (pAdapter->pFilter)
        {
            if (pAdapter->pFilter->lpVTable->IndicateStatus)
            {
                pAdapter->pFilter->lpVTable->IndicateStatus (pAdapter->pFilter, IPSINK_EVENT_SHUTDOWN);

                //
                // Release the filter reference
                //
                pAdapter->pFilter->lpVTable->Release (pAdapter->pFilter);

                //
                // Release the frame pool
                //
                pAdapter->pFramePool->lpVTable->Release (pAdapter->pFramePool);

            }
        }
    }


    
    //
    // Release the adapter
    //
    pAdapter->lpVTable->Release (pAdapter);

    return;

}

//////////////////////////////////////////////////////////////////////////////////////
// The TestReset request, instructs the Miniport to issue
// a hardware reset to the network adapter.  The driver also
// resets its software state.  See the description of NdisMReset
// for a detailed description of this request.
//
NDIS_STATUS
NdisIPReset(
    OUT PBOOLEAN    pfAddressingReset,
    IN NDIS_HANDLE  ndishAdapter
    )
//////////////////////////////////////////////////////////////////////////////////////
{
    NDIS_STATUS  nsResult      = NDIS_STATUS_SUCCESS;
    PADAPTER pAdapter = (PADAPTER) ndishAdapter;

    TEST_DEBUG (TEST_DBG_TRACE, ("NdisIPRest Handler Called\n"));

    nsResult = NDIS_STATUS_NOT_RESETTABLE;

    return nsResult;
}

//////////////////////////////////////////////////////////////////////////////////////
NDIS_STATUS
NdisIPQueryInformation (
    NDIS_HANDLE ndishAdapter,
    NDIS_OID    ndisOid,
    PVOID       pvInformationBuffer,
    ULONG       dwcbInformationBuffer,
    PULONG      pdwBytesWritten,
    PULONG      pdwBytesNeeded
    )
//////////////////////////////////////////////////////////////////////////////////////
{
    NDIS_STATUS                 nsResult       = NDIS_STATUS_SUCCESS;
    PADAPTER                    pAdapter       = (PADAPTER) ndishAdapter;
    ULONG                       ulcbWritten    = 0;
    ULONG                       ulcbNeeded     = 0;

    //
    // These variables hold the result of queries on General OIDS.
    //
    NDIS_HARDWARE_STATUS    ndisHardwareStatus  = NdisHardwareStatusReady;
    NDIS_MEDIUM             ndisMedium          = NdisMedium802_3;
    ULONG                   dwGeneric           = 0;
    USHORT                  wGeneric            = 0;
    UINT                    ucbToMove           = 0;
    PUCHAR                  pbMoveSource        = NULL;


    TEST_DEBUG (TEST_DBG_TRACE, ("NdisIPQuery Handler Called, ndsOid: %08X\n", ndisOid));

    if (!pAdapter || !pdwBytesWritten || !pdwBytesNeeded)
    {
        TEST_DEBUG (TEST_DBG_TRACE, ("NdisIPQuery Handler Complete, nsResult: NDIS_STATUS_INVALID_DATA,\n"));
        TEST_DEBUG (TEST_DBG_TRACE, ("NdisIPQuery Handler pAdapter: %08X    pdwBytesWritten: %08X   pdwBytesNeeded: %08X\n",
                                     pAdapter, pdwBytesWritten, pdwBytesNeeded));
        return (NDIS_STATUS_INVALID_DATA);
    }

    //
    //  Process OID's
    //
    pbMoveSource = (PUCHAR) (&dwGeneric);
    ulcbWritten = sizeof(ULONG);

    NdisAcquireSpinLock(&pAdapter->ndisSpinLock);

    switch (ndisOid)
    {


        case OID_GEN_MEDIA_CAPABILITIES:

            dwGeneric = NDIS_MEDIA_CAP_RECEIVE;
            break;


        case OID_GEN_MAC_OPTIONS:
            dwGeneric = (ULONG) (  NDIS_MAC_OPTION_TRANSFERS_NOT_PEND
                                 | NDIS_MAC_OPTION_RECEIVE_SERIALIZED
                                 | NDIS_MAC_OPTION_COPY_LOOKAHEAD_DATA
                                 | NDIS_MAC_OPTION_NO_LOOPBACK);
            break;


        case OID_GEN_SUPPORTED_LIST:
            pbMoveSource = (PUCHAR) (SupportedOids);
            ulcbWritten = sizeof(SupportedOids);
            break;

        case OID_GEN_MEDIA_SUPPORTED:
        case OID_GEN_MEDIA_IN_USE:
            pbMoveSource = (PUCHAR) (&ndisMedium);
            ulcbWritten = sizeof(NDIS_MEDIUM);
            break;

        case OID_GEN_MAXIMUM_LOOKAHEAD:
            dwGeneric = BDA_802_3_MAX_LOOKAHEAD;
            break;

        case OID_GEN_MAXIMUM_SEND_PACKETS:
            dwGeneric = 1;
            break;

        case OID_GEN_MAXIMUM_FRAME_SIZE:
            dwGeneric = BDA_802_3_MAX_LOOKAHEAD;
            break;

        case OID_GEN_MAXIMUM_TOTAL_SIZE:
            dwGeneric = (ULONG)(BDA_802_3_MAX_PACKET);
            break;

        case OID_GEN_TRANSMIT_BUFFER_SPACE:
            dwGeneric = (ULONG)(BDA_802_3_MAX_PACKET);
            break;

        case OID_GEN_TRANSMIT_BLOCK_SIZE:
            dwGeneric = BDA_802_3_MAX_LOOKAHEAD;
            break;

        case OID_GEN_RECEIVE_BLOCK_SIZE:
            dwGeneric = BDA_802_3_MAX_LOOKAHEAD;
            break;

        case OID_GEN_CURRENT_LOOKAHEAD:
            dwGeneric = BDA_802_3_MAX_LOOKAHEAD;
            break;


        case OID_GEN_CURRENT_PACKET_FILTER:
            dwGeneric = (ULONG) pAdapter->ulPacketFilter;
            break;


        case OID_GEN_XMIT_OK:
            dwGeneric = pAdapter->stats.ulOID_GEN_XMIT_OK;
            break;

        case OID_GEN_RCV_OK:
            dwGeneric = pAdapter->stats.ulOID_GEN_RCV_OK;
            break;

        case OID_GEN_XMIT_ERROR:
            dwGeneric = pAdapter->stats.ulOID_GEN_XMIT_ERROR;
            break;

        case OID_GEN_RCV_ERROR:
            dwGeneric = pAdapter->stats.ulOID_GEN_RCV_ERROR;
            break;

        case OID_GEN_RCV_NO_BUFFER:
            dwGeneric = pAdapter->stats.ulOID_GEN_RCV_NO_BUFFER;
            break;

        case OID_GEN_DIRECTED_BYTES_XMIT:
            dwGeneric = pAdapter->stats.ulOID_GEN_DIRECTED_BYTES_XMIT;
            break;

        case OID_GEN_DIRECTED_FRAMES_XMIT:
            dwGeneric = pAdapter->stats.ulOID_GEN_DIRECTED_FRAMES_XMIT;
            break;

        case OID_GEN_MULTICAST_BYTES_XMIT:
            dwGeneric = pAdapter->stats.ulOID_GEN_MULTICAST_BYTES_XMIT;
            break;
    
        case OID_GEN_MULTICAST_FRAMES_XMIT:
            dwGeneric = pAdapter->stats.ulOID_GEN_MULTICAST_FRAMES_XMIT;
            break;
    
        case OID_GEN_BROADCAST_BYTES_XMIT:
            dwGeneric = pAdapter->stats.ulOID_GEN_BROADCAST_BYTES_XMIT;
            break;
    
        case OID_GEN_BROADCAST_FRAMES_XMIT:
            dwGeneric = pAdapter->stats.ulOID_GEN_BROADCAST_FRAMES_XMIT;
            break;

        case OID_GEN_DIRECTED_BYTES_RCV:
            dwGeneric = pAdapter->stats.ulOID_GEN_DIRECTED_BYTES_RCV;
            break;

        case OID_GEN_DIRECTED_FRAMES_RCV:
            dwGeneric = pAdapter->stats.ulOID_GEN_DIRECTED_FRAMES_RCV;
            break;

        case OID_GEN_MULTICAST_BYTES_RCV:
            dwGeneric = pAdapter->stats.ulOID_GEN_MULTICAST_BYTES_RCV;
            break;

        case OID_GEN_MULTICAST_FRAMES_RCV:
            dwGeneric = pAdapter->stats.ulOID_GEN_MULTICAST_FRAMES_RCV;
            break;

        case OID_GEN_BROADCAST_BYTES_RCV:
            dwGeneric = pAdapter->stats.ulOID_GEN_BROADCAST_BYTES_RCV;
            break;

        case OID_GEN_BROADCAST_FRAMES_RCV:
            dwGeneric = pAdapter->stats.ulOID_GEN_BROADCAST_FRAMES_RCV;
            break;

        case OID_GEN_RCV_CRC_ERROR:
            dwGeneric = pAdapter->stats.ulOID_GEN_RCV_CRC_ERROR;
            break;

        case OID_GEN_TRANSMIT_QUEUE_LENGTH:
            dwGeneric = pAdapter->stats.ulOID_GEN_TRANSMIT_QUEUE_LENGTH;
            break;

        case OID_802_3_RCV_ERROR_ALIGNMENT:
            dwGeneric = 0;
            break;

        case OID_802_3_XMIT_ONE_COLLISION:
            dwGeneric = 0;
            break;

        case OID_802_3_XMIT_MORE_COLLISIONS:
            dwGeneric = 0;
            break;

        case OID_802_3_PERMANENT_ADDRESS:
            pbMoveSource = (PVOID)(rgchPermanentAddress);
            ulcbWritten = sizeof(rgchPermanentAddress);
            break;

        case OID_802_3_CURRENT_ADDRESS:
            pbMoveSource = (PVOID)(rgchStationAddress);
            ulcbWritten = sizeof(rgchStationAddress);
            break;

        case OID_802_3_MAXIMUM_LIST_SIZE:
            dwGeneric = MULTICAST_LIST_SIZE;
            break;

        case OID_GEN_HARDWARE_STATUS:
            ndisHardwareStatus = NdisHardwareStatusReady;
            pbMoveSource = (PUCHAR)(&ndisHardwareStatus);
            ulcbWritten = sizeof(NDIS_HARDWARE_STATUS);
            break;

        case OID_GEN_LINK_SPEED:
            dwGeneric = (ULONG)(300000);
            break;

        case OID_GEN_RECEIVE_BUFFER_SPACE:
            dwGeneric = BDA_802_3_MAX_PACKET * 20;
            break;

        case OID_GEN_DRIVER_VERSION:
            dwGeneric =  ((USHORT) 4 << 8) | 0;
            pbMoveSource = (PVOID)(&dwGeneric);
            ulcbWritten = sizeof(dwGeneric);
            break;

        case OID_GEN_VENDOR_ID:
            wGeneric = (USHORT) 0xDDDD;           // BOGUS ID
            pbMoveSource = (PVOID)(&wGeneric);
            ulcbWritten = sizeof(wGeneric);
            break;

        case OID_GEN_VENDOR_DESCRIPTION:
            pbMoveSource = (PVOID) pAdapter->pVendorDescription;
            ulcbWritten = MyStrLen (pAdapter->pVendorDescription);
            break;

        case OID_GEN_VENDOR_DRIVER_VERSION:
            dwGeneric = 0x0401;
            pbMoveSource = (PVOID)(&dwGeneric);
            ulcbWritten  = sizeof(dwGeneric);
            break;

        case OID_GEN_MEDIA_CONNECT_STATUS:
            dwGeneric = NdisMediaStateConnected;
            break;

        case OID_802_3_MAC_OPTIONS:
            dwGeneric = 0;
            break;

        case OID_PNP_CAPABILITIES:
            dwGeneric = 0;
            break;

        case OID_802_3_MULTICAST_LIST:
            pbMoveSource = (PVOID)(pAdapter->multicastList[0]);
            ulcbWritten  =  pAdapter->ulcbMulticastListEntries;
            break;

        case OID_PNP_QUERY_POWER:

            nsResult = NDIS_STATUS_SUCCESS;
            ulcbWritten = 0;
            break;

        case OID_TCP_TASK_OFFLOAD:
        case OID_TCP_TASK_IPSEC_ADD_SA:
        case OID_TCP_TASK_IPSEC_DELETE_SA:
        case OID_TCP_SAN_SUPPORT:
    
        case OID_FFP_SUPPORT:
        case OID_FFP_FLUSH:
        case OID_FFP_CONTROL:
        case OID_FFP_PARAMS:
        case OID_FFP_DATA:
        case OID_FFP_DRIVER_STATS:
        case OID_FFP_ADAPTER_STATS:

        case OID_PNP_WAKE_UP_OK:
        case OID_PNP_WAKE_UP_ERROR:

            nsResult = NDIS_STATUS_NOT_SUPPORTED;
            break;

        default:
            //
            nsResult = NDIS_STATUS_INVALID_OID;
            break;

    }


    
    //
    // First take care of the case where the size of the output buffer is
    // zero, or the pointer to the buffer is NULL
    //
    if (nsResult == NDIS_STATUS_SUCCESS)
    {

        ulcbNeeded = ulcbWritten;

        if (ulcbWritten > dwcbInformationBuffer)
        {
            //
            //  There isn't enough room in InformationBuffer.
            //  Don't move any of the info.
            //
            ulcbWritten = 0;
            nsResult = NDIS_STATUS_INVALID_LENGTH;
        }
        else if (ulcbNeeded && (pvInformationBuffer == NULL))
        {
            ulcbWritten = 0;
            nsResult = NDIS_STATUS_INVALID_LENGTH;
        }
        else if (ulcbNeeded)
        {
            //
            //  Move the requested information into the info buffer.
            //
            NdisMoveMemory (pvInformationBuffer, pbMoveSource, ulcbWritten);
        }
    }

  //Release SpinLock
  NdisReleaseSpinLock(&pAdapter->ndisSpinLock);


    if (nsResult == NDIS_STATUS_SUCCESS)
    {
        //
        // A status of success always indicates 0 bytes needed.
        //
        *pdwBytesWritten = ulcbWritten;
        *pdwBytesNeeded = 0;
    }
    else if (nsResult == NDIS_STATUS_INVALID_LENGTH)
    {
        //
        //  For us a failure status always indicates 0 bytes read.
        //
        *pdwBytesWritten = 0;
        *pdwBytesNeeded = ulcbNeeded;
    }

    TEST_DEBUG (TEST_DBG_TRACE, ("NdisIPQuery Handler Complete, nsResult: %08X\n", nsResult));

    return nsResult;

}


////////////////////////////////////////////////////////////////////////
extern
NDIS_STATUS
NdisIPSetInformation (
    NDIS_HANDLE ndishAdapterContext,
    NDIS_OID ndisOid,
    PVOID pvInformationBuffer,
    ULONG dwcbInformationBuffer,
    PULONG pdwBytesRead,
    PULONG pdwBytesNeeded
    )
////////////////////////////////////////////////////////////////////////
{
    ULONG          ulcbNeeded   = 0;
    NDIS_STATUS    nsResult     = NDIS_STATUS_SUCCESS;
    PADAPTER       pAdapter = (PADAPTER) ndishAdapterContext;


    #ifdef PFP

    ASSERT (pAdapter != NULL);
    ASSERT (pvInformationBuffer != NULL);
    ASSERT (pdwBytesRead != NULL);
    ASSERT (pdwBytesNeeded != NULL);

    #endif

    TEST_DEBUG (TEST_DBG_TRACE, ("NdisIPSetInfo Handler Called, ndsOid: %08X\n", ndisOid));

    if (!pAdapter || !pvInformationBuffer || !pdwBytesRead || !pdwBytesNeeded)
    {
        TEST_DEBUG (TEST_DBG_TRACE, ("NdisIPSetInfo Handler returns Invalid data\n"));
        return (NDIS_STATUS_INVALID_DATA);
    }

    NdisAcquireSpinLock(&pAdapter->ndisSpinLock);
   
    switch (ndisOid)
    {
        case OID_GEN_CURRENT_PACKET_FILTER:
            {
                pAdapter->ulPacketFilter = * ((PULONG) pvInformationBuffer);
                *pdwBytesRead = 4;
            }
            break;


        case OID_GEN_CURRENT_LOOKAHEAD:

            if (dwcbInformationBuffer != 4)
            {
                nsResult = NDIS_STATUS_INVALID_LENGTH;

                *pdwBytesRead = 0;

                break;
            }

            //
            // Current Lookahead is not set this way so just ignore the
            // data.
            //
            *pdwBytesRead = 4;
            break;



        case OID_802_3_MULTICAST_LIST:

            //  If our current multicast address buffer isn't big
            //  enough, then free it.
            //
            if (dwcbInformationBuffer > sizeof (pAdapter->multicastList))
            {
                nsResult = NDIS_STATUS_RESOURCES;
                break;
            }

            //  Copy the Multicast List.
            //
 
           RtlCopyMemory (pAdapter->multicastList,
                           pvInformationBuffer,
                           dwcbInformationBuffer
                         );

            pAdapter->ulcbMulticastListEntries = dwcbInformationBuffer;

            //
            // Now we send the multicast list to the stream component so
            // it can get passed on to the net provider filter
            //
            if (pAdapter)
            {
                if (pAdapter->pFilter)
                {
                    if (pAdapter->pFilter->lpVTable->SetMulticastList)
                    {
                        pAdapter->pFilter->lpVTable->SetMulticastList (
                             pAdapter->pFilter,
                             pAdapter->multicastList,
                             pAdapter->ulcbMulticastListEntries
                             );
                    }
                }
            }

            break;


        case OID_802_3_PERMANENT_ADDRESS:

      	if (dwcbInformationBuffer > ETHERNET_ADDRESS_LENGTH)
            {
                nsResult = NDIS_STATUS_RESOURCES;
                break;
            }	

         RtlCopyMemory (rgchPermanentAddress,
                           pvInformationBuffer,
                           dwcbInformationBuffer
                         );
            break;

        case OID_802_3_CURRENT_ADDRESS:
        	
	  if (dwcbInformationBuffer > ETHERNET_ADDRESS_LENGTH)
            {
                nsResult = NDIS_STATUS_RESOURCES;
                break;
            }	

            RtlCopyMemory (rgchStationAddress,
                           pvInformationBuffer,
                           dwcbInformationBuffer
                         );
            break;


        case OID_PNP_SET_POWER:

            nsResult = NDIS_STATUS_SUCCESS;
            ulcbNeeded = 0;
            break;


        default:

            nsResult = NDIS_STATUS_INVALID_OID;

            *pdwBytesRead = 0;
            ulcbNeeded = 0;

            break;
    }

   NdisReleaseSpinLock(&pAdapter->ndisSpinLock);
   
    if (nsResult == NDIS_STATUS_SUCCESS)
    {
        //
        // A status of success always indicates 0 bytes needed.
        //
        *pdwBytesRead = dwcbInformationBuffer;
        *pdwBytesNeeded = 0;

    }
    else
    {
        //
        //  A failure status always indicates 0 bytes read.
        //
        *pdwBytesRead = 0;
        *pdwBytesNeeded = ulcbNeeded;
    }


    TEST_DEBUG (TEST_DBG_TRACE, ("NdisIPSetInfo Handler Complete, nsResult: %08X\n", nsResult));

    return nsResult;

}



//////////////////////////////////////////////////////////////////////////////////////
VOID
NdisIPReturnPacket(
    IN NDIS_HANDLE     ndishAdapterContext,
    IN PNDIS_PACKET    pNdisPacket
    )
//////////////////////////////////////////////////////////////////////////////////////
{
    PFRAME pFrame = NULL;
    ULONG ulMediaSpecificInfoSize;
    PIPSINK_MEDIA_SPECIFIC_INFORAMTION pMediaSpecificInfo;

    TEST_DEBUG (TEST_DBG_TRACE, ("NdisIPReturnPacket Handler Called\n"));


    NDIS_GET_PACKET_MEDIA_SPECIFIC_INFO (pNdisPacket,&pMediaSpecificInfo,&ulMediaSpecificInfoSize);

    //
    // Make sure we free up any frames
    //
    if (pMediaSpecificInfo)
    {
        pFrame = (PFRAME) pMediaSpecificInfo->pFrame;
        ASSERT(pFrame);
    }

    //
    //      NDIS is through with the packet so we need to free it
    //      here.
    //
    NdisFreePacket (pNdisPacket);

    //
    // Put Frame back on available queue.
    //
    if (pFrame)
    {
        //
        // Release this frame since we're done using it
        //
        pFrame->lpVTable->Release (pFrame);

        //
        // Store the frame back on the available queue
        //
        TEST_DEBUG (TEST_DBG_TRACE, ("NdisIPReturnPacket: Putting frame %08X back on Available Queue\n", pFrame));
        PutFrame (pFrame->pFramePool, &pFrame->pFramePool->leAvailableQueue, pFrame);
    }


    return;
}


//////////////////////////////////////////////////////////////////////////////
NDIS_STATUS
NdisIPSend(
    IN NDIS_HANDLE ndishAdapterContext,
    IN PNDIS_PACKET Packet,
    IN UINT Flags
    )
//////////////////////////////////////////////////////////////////////////////
{
    PADAPTER       pAdapter = (PADAPTER) ndishAdapterContext;

    TEST_DEBUG (TEST_DBG_TRACE, ("NdisIPSend Handler Called\n"));

    NdisAcquireSpinLock(&pAdapter->ndisSpinLock);
    pAdapter->stats.ulOID_GEN_XMIT_ERROR += 1;
    NdisReleaseSpinLock(&pAdapter->ndisSpinLock);
    
    return NDIS_STATUS_FAILURE;
}


//////////////////////////////////////////////////////////////////////////////
extern VOID
NdisIPShutdown(
    IN PVOID ShutdownContext
    )
//////////////////////////////////////////////////////////////////////////////
{
    TEST_DEBUG (TEST_DBG_TRACE, ("NdisIPShutdown Handler Called\n"));

    //BREAK(0x10);
}

//////////////////////////////////////////////////////////////////////////////
NTSTATUS
RegisterDevice(
        IN      PVOID              NdisWrapperHandle,
        IN      UNICODE_STRING     *DeviceName,
        IN      UNICODE_STRING     *SymbolicName,
        IN      PDRIVER_DISPATCH   pDispatchTable[],
        OUT     PDEVICE_OBJECT    *pDeviceObject,
        OUT     PVOID             *NdisDeviceHandle
        )
//////////////////////////////////////////////////////////////////////////////
{

    NDIS_STATUS status;

    status = NdisMRegisterDevice ((NDIS_HANDLE) NdisWrapperHandle,
                                  DeviceName,
                                  SymbolicName,
                                  pDispatchTable,
                                  pDeviceObject,
                                  (NDIS_HANDLE *) NdisDeviceHandle);

    return (NTSTATUS) status;
}

//////////////////////////////////////////////////////////////////////////////
NTSTATUS
StreamIndicateEvent (
        IN PVOID  pvEvent
        )
//////////////////////////////////////////////////////////////////////////////
{
    NTSTATUS ntStatus = STATUS_SUCCESS;

    //ntStatus = StreamIPIndicateEvent (pvEvent);

    return ntStatus;
}


//////////////////////////////////////////////////////////////////////////////
NTSTATUS
IndicateCallbackHandler (
     IN NDIS_HANDLE  ndishMiniport,
     IN PINDICATE_CONTEXT  pIndicateContext
     )
//////////////////////////////////////////////////////////////////////////////
{
    PFRAME pFrame = NULL;
    PVOID pvData  = NULL;
    ULONG ulcbData = 0L;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PADAPTER pAdapter;


    pAdapter = pIndicateContext->pAdapter;

    //
    // Take the source data and stuff the data into a FRAME object
    //
    while ((pFrame = GetFrame (pAdapter->pFramePool, &pAdapter->pFramePool->leIndicateQueue)) != NULL)
    {
        TEST_DEBUG (TEST_DBG_TRACE, ("NdisIP: Getting Frame (%08X) from Indicate Queue\n", pFrame));
        //
        // Indicate the NDIS packet
        //
        ntStatus = IndicateFrame (pFrame, pFrame->ulcbData);
    }

    if (pFrame == NULL)
    {
        TEST_DEBUG (TEST_DBG_TRACE, ("NdisIP: No more frames on Indicate Queue\n", pFrame));
    }

    //
    // Free up the context area.  NOTE: this is alloc'ed in the indicate handler
    //
    FreeMemory (pIndicateContext, sizeof (INDICATE_CONTEXT));

    return ntStatus;

}



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\bda\ipsink\ndis\main.h ===
//////////////////////////////////////////////////////////////////////////////\
//
//  Copyright (c) 1990  Microsoft Corporation
//
//  Module Name:
//
//     test.h
//
//  Abstract:
//
//     The main header for the NDIS/KS test driver
//
//  Author:
//
//     P Porzuczek
//
//  Environment:
//
//  Notes:
//
//  Revision History:
//
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _TEST_H
#define _TEST_H


#if DBG

extern  ULONG TestDebugFlag;

#define TEST_DBG_NONE    0x00000000
#define TEST_DBG_TRACE   0x00000001

#define TEST_DBG_DETAIL  0x00001000
#define TEST_DBG_INFO    0x00002000
#define TEST_DBG_WARNING 0x00004000
#define TEST_DBG_ERROR   0x00008000

#ifdef DEBUG_EXTRAS
#define TEST_DEBUG(_Trace, _Msg)                 \
{                                               \
        __int64                 llTime = 0;             \
        ULONG                   ulTime = 0;                     \
        NdisGetCurrentSystemTime ((PLARGE_INTEGER)&llTime);     \
        ulTime = (ULONG) (llTime >> 2);         \
    if (_Trace & TestDebugFlag)                  \
    {                                           \
        DbgPrint ("%04X %08X %-10.10s %4d  ", ulTime & 0xffff, _Trace, &__FILE__[2], __LINE__); \
        DbgPrint _Msg;                          \
    }                                           \
}

#else
#define TEST_DEBUG(_Trace, _Msg)                 \
{                                               \
    if (_Trace & TestDebugFlag)                  \
    {                                           \
        DbgPrint _Msg;                          \
    }                                           \
}
#endif  // DEBUG_EXTRAS

#define IF_TESTDEBUG(f) if (TestDebugFlag & (f))

#define TEST_DEBUG_LOUD               0x00010000  // debugging info
#define TEST_DEBUG_VERY_LOUD          0x00020000  // excessive debugging info
#define TEST_DEBUG_LOG                0x00040000  // enable Log
#define TEST_DEBUG_CHECK_DUP_SENDS    0x00080000  // check for duplicate sends
#define TEST_DEBUG_TRACK_PACKET_LENS  0x00100000  // track directed packet lens
#define TEST_DEBUG_WORKAROUND1        0x00200000  // drop DFR/DIS packets
#define TEST_DEBUG_CARD_BAD           0x00400000  // dump data if CARD_BAD
#define TEST_DEBUG_CARD_TESTS         0x00800000  // print reason for failing


//
// Macro for deciding whether to print a lot of debugging information.
//
#define IF_LOUD(A) IF_TESTDEBUG( TEST_DEBUG_LOUD ) { A }
#define IF_VERY_LOUD(A) IF_TESTDEBUG( TEST_DEBUG_VERY_LOUD ) { A }


//
// Whether to use the Log buffer to record a trace of the driver.
//
#define IF_LOG(A) IF_TESTDEBUG( TEST_DEBUG_LOG ) { A }
extern VOID TESTLog(UCHAR);

//
// Whether to do loud init failure
//
#define IF_INIT(A) A

//
// Whether to do loud card test failures
//
#define IF_TEST(A) IF_TESTDEBUG( TEST_DEBUG_CARD_TESTS ) { A }

#else

//extern  ULONG TestDebugFlag;


#define TEST_NONE
#define TEST_FUNCTIONS
#define TEST_COMMANDS
#define TEST_CONNECTIONS
#define TEST_SCIDS
#define TEST_LIST_ALLOCS
#define TEST_POOL
#define TEST_INDICATES
#define TEST_ALLOCATION


#define TEST_DEBUG(_Trace, _Msg)

#define IF_TESTDEBUG(f)

#define TEST_DEBUG_LOUD
#define TEST_DEBUG_VERY_LOUD
#define TEST_DEBUG_LOG
#define TEST_DEBUG_CHECK_DUP_SENDS
#define TEST_DEBUG_TRACK_PACKET_LENS
#define TEST_DEBUG_WORKAROUND1
#define TEST_DEBUG_CARD_BAD
#define TEST_DEBUG_CARD_TESTS


//
// This is not a debug build, so make everything quiet.
//
#define IF_LOUD(A)
#define IF_VERY_LOUD(A)
#define IF_LOG(A)
#define IF_INIT(A)
#define IF_TEST(A)

#endif // DBG


extern PDRIVER_OBJECT  pGlobalDriverObject;
extern PADAPTER        global_pAdapter;


////////////////////////////////////////////////////////////////
//
// This structure contains information about the driver
// itself.  There is only have one of these structures.
//
typedef struct _DRIVER_BLOCK
{

    //
    // NDIS wrapper information.
    //
    PVOID         NdisMacHandle;      // returned from NdisRegisterMac
    PVOID         ndishWrapper;       // returned from NdisInitializeWrapper

} DRIVER_BLOCK, * PDRIVER_BLOCK;


NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT    pDriverObject,
    IN PUNICODE_STRING   pszuRegistryPath);


NTSTATUS
NdisDriverInitialize (
    IN PDRIVER_OBJECT    DriverObject,
    IN PUNICODE_STRING   RegistryPath,
    IN PVOID            *pNdishWrapper
    );


#endif // _TEST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\bda\ipsink\ndis\ndisapi.h ===
//////////////////////////////////////////////////////////////////////////////\
//
//  Copyright (c) 1990  Microsoft Corporation
//
//  Module Name:
//
//     ipndis.h
//
//  Abstract:
//
//     The main header for the NDIS/KS test driver
//
//  Author:
//
//     P Porzuczek
//
//  Environment:
//
//  Notes:
//
//  Revision History:
//
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _NDIS_MAIN_H
#define _NDIS_MAIN_H


/////////////////////////////////////////////////////////////////////////////
//
//
extern NDIS_HANDLE global_ndishWrapper;


//////////////////////////////////////////////////////////
//
//
//
#define ETHERNET_LENGTH_OF_ADDRESS      6
#define ETHERNET_HEADER_SIZE            14
#define BDA_802_3_MAX_LOOKAHEAD         ((4 * 1024) - ETHERNET_HEADER_SIZE)
#define BDA_802_3_MAX_PACKET            (BDA_802_3_MAX_LOOKAHEAD + ETHERNET_HEADER_SIZE)
#define MAX_IP_PACKET_LEN               BDA_802_3_MAX_LOOKAHEAD
#define BDALM_MAX_MULTICAST_LIST_SIZE   256


//////////////////////////////////////////////////////////
//
//
//
typedef struct _INDICATE_CONTEXT_
{
    PADAPTER pAdapter;

} INDICATE_CONTEXT, *PINDICATE_CONTEXT;


//////////////////////////////////////////////////////////////////////////////\
//
//
//  Prototypes
//
//
NTSYSAPI
VOID
NTAPI
RtlInitUnicodeString(
    PUNICODE_STRING DestinationString,
    PCWSTR SourceString
    );


VOID
NdisIPHalt(
    IN NDIS_HANDLE MiniportAdapterContext
    );


NDIS_STATUS
NdisIPInitialize(
    OUT PNDIS_STATUS OpenErrorStatus,
    OUT PUINT SelectedMediumIndex,
    IN PNDIS_MEDIUM MediumArray,
    IN UINT MediumArraySize,
    IN NDIS_HANDLE MiniportAdapterHandle,
    IN NDIS_HANDLE ConfigurationHandle
    );

NDIS_STATUS
NdisIPQueryInformation(
    IN NDIS_HANDLE MiniportAdapterContext,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesWritten,
    OUT PULONG BytesNeeded
    );

NDIS_STATUS
NdisIPReset(
    OUT PBOOLEAN AddressingReset,
    IN NDIS_HANDLE MiniportAdapterContext
    );


NDIS_STATUS
NdisIPSend(
    IN NDIS_HANDLE MiniportAdapterContext,
    IN PNDIS_PACKET Packet,
    IN UINT Flags
    );

NDIS_STATUS
NdisIPSetInformation(
    IN NDIS_HANDLE MiniportAdapterContext,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesRead,
    OUT PULONG BytesNeeded
    );

NTSTATUS
StreamIndicateEvent (
        IN PVOID  pvEvent
        );


VOID
NdisIPReturnPacket(
    IN NDIS_HANDLE     ndishAdapterContext,
    IN PNDIS_PACKET    pNdisPacket
    );

PFRAME
GetFrame (
    PFRAME_POOL pFramePool,
    PLIST_ENTRY pQueue
    );

PFRAME
PutFrame (
    PFRAME_POOL pFramePool,
    PLIST_ENTRY pQueue,
    PFRAME pFrame
    );

NTSTATUS
IndicateCallbackHandler (
     IN NDIS_HANDLE ndishMiniport,
     IN PINDICATE_CONTEXT  pIndicateContext
     );

NTSTATUS
CreateAdapter (
    PADAPTER *ppAdapter,
    NDIS_HANDLE ndishWrapper,
    NDIS_HANDLE ndishAdapterContext
    );

#endif // _NDIS_MAIN_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\bda\ipsink\stream\filter.h ===
#ifndef _FILTER_H_
#define _FILTER_H_


//////////////////////////////////////////////////////////////////
//
//
//
NTSTATUS
CreateFilter (
    PDRIVER_OBJECT DriverObject,
    PDEVICE_OBJECT DeviceObject,
    PIPSINK_FILTER pFilter
    );

NTSTATUS
Filter_QueryInterface (
    PIPSINK_FILTER pFilter
    );

ULONG
Filter_AddRef (
    PIPSINK_FILTER pFilter
    );

ULONG
Filter_Release (
    PIPSINK_FILTER pFilter
    );

NTSTATUS
Filter_SetMulticastList (
                  IN PVOID pvContext,
    IN PVOID pvMulticastList,
    IN ULONG ulcbList
    );

NTSTATUS
Filter_IndicateStatus (
    IN PVOID pvContext,
    IN ULONG ulEvent
    );

NTSTATUS
Filter_ReturnFrame (
    IN PVOID pvContext,
    IN PVOID pvFrame
    );

#endif  // _FILTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\bda\ipsink\stream\makefile.inc ===
# HACK ALERT: This target is solely to keep nmake from whining that it doesn't
# know how to make the dependency in rules that depend on the target executable.
$(TARGETPATHEX)\$(TARGETNAME).sys:

# Build SoftICE symbols
$(TARGETPATHEX)\$(TARGETNAME).nms: $(TARGETPATHEX)\$(TARGETNAME).sys
    echo $(TARGETPATHEX)\$(TARGETNAME) > target.txt
    nmsym /translate:source,package,always /source:. /output:$(TARGETPATHEX)\$(TARGETNAME).nms $(TARGETPATHEX)\$(TARGETNAME).sys
    splitsym -s $(_NT_SYMBOL_PATH)  $(TARGETPATHEX)\$(TARGETNAME).sys

# Delete built files
clean:
    -echo $(TARGETPATHEX)\$(TARGETNAME).*
    -del /s *.obj
    -del /s *.res
    -del build.log
    -del build.err
    -del /s _objects.mac
    -del $(TARGETPATHEX)\$(TARGETNAME).*
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\bda\ipsink\stream\ipmedia.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

#ifndef __MEDIA_H__
#define __MEDIA_H__


#ifdef DEFINE_GUIDEX
#undef DEFINE_GUIDEX
#include <ksguid.h>
#endif


////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
#define STATIC_IID_IBDA_IPSinkControl\
    0x3F4DC8E2L, 0x4050, 0x11D3, 0x8F, 0x4B, 0x00, 0xC0, 0x4F, 0x79, 0x71, 0xE2
DEFINE_GUIDSTRUCT("3F4DC8E2-4050-11d3-8F4B-00C04F7971E2", IID_IBDA_IPSinkControl);
#define IID_IBDA_IPSinkControl DEFINE_GUIDNAMED(IID_IBDA_IPSinkControl)

#define STATIC_IID_IBDA_IPSinkEvent\
    0x3F4DC8E3L, 0x4050, 0x11D3, 0x8F, 0x4B, 0x00, 0xC0, 0x4F, 0x79, 0x71, 0xE2
DEFINE_GUIDSTRUCT("3F4DC8E3-4050-11d3-8F4B-00C04F7971E2", IID_IBDA_IPSinkEvent);
#define IID_IBDA_IPSinkEvent DEFINE_GUIDNAMED(IID_IBDA_IPSinkEvent)

////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
#define STATIC_IID_IBDA_BDANetInterface\
    0x9AA4A2CCL, 0x81E0, 0x4CFD, 0x80, 0x2F, 0x0F, 0x74, 0x52, 0x6D, 0x2B, 0xD3
DEFINE_GUIDSTRUCT("9AA4A2CC-81E0-4CFD-802F-0F74526D2BD3", IID_IBDA_BDANetInterface);
#define IID_IBDA_BDANetInterface  DEFINE_GUIDNAMED(IID_IBDA_BDANetInterface)

typedef enum
{
    KSPROPERTY_IPSINK_MULTICASTLIST,
    KSPROPERTY_IPSINK_ADAPTER_DESCRIPTION,
    KSPROPERTY_IPSINK_ADAPTER_ADDRESS

} KSPROPERTY_IPSINK;

////////////////////////////////////////////////////////////////////////
//
//
//
typedef enum
{
    KSEVENT_IPSINK_MULTICASTLIST,
    KSEVENT_IPSINK_ADAPTER_DESCRIPTION,
    KSEVENT_IPSINK_SHUTDOWN

} KSEVENT_IPSINK;


/////////////////////////////////////////////////////////////
//
// PINNAME CATEGORY GUID
//
#define STATIC_PINNAME_IPSINK \
    0x3fdffa70L, 0xac9a, 0x11d2, 0x8f, 0x17, 0x00, 0xc0, 0x4f, 0x79, 0x71, 0xe2
DEFINE_GUIDSTRUCT("3fdffa70-ac9a-11d2-8f17-00c04f7971e2", PINNAME_IPSINK);
#define PINNAME_IPSINK   DEFINE_GUIDNAMED(PINNAME_IPSINK)

#define STATIC_PINNAME_BDA_NET_CONTROL \
    0xfb61415dL, 0x434b, 0x4cef, 0xac, 0xf4, 0x88, 0x66, 0xde, 0xdb, 0xec, 0x68
DEFINE_GUIDSTRUCT("FB61415D-434B-4cef-ACF4-8866DEDBEC68", PINNAME_BDA_NET_CONTROL);
#define PINNAME_BDA_NET_CONTROL   DEFINE_GUIDNAMED(PINNAME_BDA_NET_CONTROL)


/////////////////////////////////////////////////////////////
//
// IPSnk Data Format structure
//
typedef struct tagKS_DATAFORMAT_IPSINK_IP
{
   KSDATAFORMAT                 DataFormat;

} KS_DATAFORMAT_IPSINK_IP, *PKS_DATAFORMAT_IPSINK_IP;




#endif // __MEDIA_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\bda\ipsink\stream\filter.c ===
/////////////////////////////////////////////////////////////////////////////
//
//
// Copyright (c) 1996, 1997  Microsoft Corporation
//
//
// Module Name:
//      filter.c
//
// Abstract:
//
//      This file is a test to find out if dual binding to NDIS and KS works
//
// Author:
//
//      P Porzuczek
//
// Environment:
//
// Revision History:
//
//
//////////////////////////////////////////////////////////////////////////////

#ifndef DWORD
#define DWORD ULONG
#endif

#include <forward.h>
#include <strmini.h>
#include <link.h>
#include <ipsink.h>
#include <ksmedia.h>
#include <bdatypes.h>
#include <bdamedia.h>

#include "Main.h"
#include "ipmedia.h"
#include "streamip.h"
#include "filter.h"


//////////////////////////////////////////////////////////////////////////////
//
//
//
const FILTER_VTABLE FilterVTable =
    {
    Filter_QueryInterface,
    Filter_AddRef,
    Filter_Release,
    Filter_SetMulticastList,
    Filter_IndicateStatus,
    Filter_ReturnFrame
    };


///////////////////////////////////////////////////////////////////////////////////
NTSTATUS
CreateFilter (
    PDRIVER_OBJECT DriverObject,
    PDEVICE_OBJECT DeviceObject,
    PIPSINK_FILTER pFilter
    )
///////////////////////////////////////////////////////////////////////////////////
{
    NTSTATUS ntStatus = STATUS_SUCCESS;

    //
    // Save off our Device/Driver Objectsx in our context area
    //
    pFilter->DeviceObject          = DeviceObject;
    pFilter->DriverObject          = DriverObject;
    pFilter->lpVTable              = (PFILTER_VTABLE) &FilterVTable;
    pFilter->bTerminateWaitForNdis = FALSE;
    pFilter->ulRefCount            = 1;

    return ntStatus;
}


///////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Filter_QueryInterface (
    PIPSINK_FILTER pFilter
    )
///////////////////////////////////////////////////////////////////////////////////
{
    return STATUS_NOT_IMPLEMENTED;
}

///////////////////////////////////////////////////////////////////////////////////
ULONG
Filter_AddRef (
    PIPSINK_FILTER pFilter
    )
///////////////////////////////////////////////////////////////////////////////////
{
    if (pFilter)
    {
        pFilter->ulRefCount += 1;
        return pFilter->ulRefCount;
    }

    return 0;
}

///////////////////////////////////////////////////////////////////////////////////
ULONG
Filter_Release (
    PIPSINK_FILTER pFilter
    )
///////////////////////////////////////////////////////////////////////////////////
{
    ULONG ulRefCount = 0L;

    if (pFilter)
    {
        pFilter->ulRefCount -= 1;
        ulRefCount = pFilter->ulRefCount;

        if (pFilter->ulRefCount == 0)
        {
            // $$BUG  Free Filter here
            return ulRefCount;
        }
    }

    return ulRefCount;
}


//////////////////////////////////////////////////////////////////////////////
NTSTATUS
Filter_SetMulticastList (
    IN PVOID pvContext,
    IN PVOID pvMulticastList,
    IN ULONG ulcbList
    )
//////////////////////////////////////////////////////////////////////////////
{
    PKSEVENT_ENTRY pEventEntry = NULL;
    PIPSINK_FILTER pFilter = (PIPSINK_FILTER) pvContext;

    //
    // Save off the multicast locally then forward it to the net provider
    //
    pFilter->ulcbMulticastListEntries = ulcbList;

   ASSERT(pFilter->multicastList!=NULL);

    RtlCopyMemory (pFilter->multicastList, pvMulticastList, ulcbList);

    //
    // Signal the event to anyone waiting for it
    //
    pEventEntry = StreamClassGetNextEvent(
                      pFilter,
                      NULL,
                      (GUID *) &IID_IBDA_IPSinkEvent,
                      KSEVENT_IPSINK_MULTICASTLIST, //0,
                      NULL
                      );

    if (pEventEntry)
    {
        StreamClassDeviceNotification (SignalDeviceEvent, pFilter, pEventEntry);
    }



    return STATUS_SUCCESS;
}

//////////////////////////////////////////////////////////////////////////////
NTSTATUS
Filter_IndicateStatus (
    PVOID pvContext,
    IN ULONG ulEvent
    )
//////////////////////////////////////////////////////////////////////////////
{
    PIPSINK_FILTER pFilter = (PIPSINK_FILTER) pvContext;

    switch (ulEvent)
    {
        case IPSINK_EVENT_SHUTDOWN:

            //
            // The NDIS component is shutting down.
            //
            CloseLink (&pFilter->NdisLink);

            TEST_DEBUG (TEST_DBG_TRACE, ("Driver Link Severed\n"));

            //
            //  Deref the adapter object and set it to NULL
            //
            pFilter->pAdapter->lpVTable->Release (pFilter->pAdapter);
            pFilter->pAdapter = NULL;

            break;

        default:
            break;
    }

    return STATUS_SUCCESS;
}

//////////////////////////////////////////////////////////////////////////////
NTSTATUS
Filter_ReturnFrame (
    IN PVOID pvContext,
    IN PVOID pvFrame
    )
//////////////////////////////////////////////////////////////////////////////
{
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\bda\ipsink\stream\link.c ===
/////////////////////////////////////////////////////////////////////////////
//
//
// Copyright (c) 1996, 1997  Microsoft Corporation
//
//
// Module Name:
//      ipstream.c
//
// Abstract:
//
//      This file is a test to find out if dual binding to NDIS and KS works
//
// Author:
//
//      P Porzuczek
//
// Environment:
//
// Revision History:
//
//
//////////////////////////////////////////////////////////////////////////////

#ifndef DWORD
#define DWORD ULONG
#endif

#include <forward.h>
#include <strmini.h>
#include <link.h>
#include <ipsink.h>
#include "ipmedia.h"

#include "main.h"


//////////////////////////////////////////////////////////////////////////////
VOID
CloseLink (
    PLINK pLink
)
//////////////////////////////////////////////////////////////////////////////
{
    PDEVICE_OBJECT   pDeviceObject = NULL;
    PFILE_OBJECT     pFileObject = NULL;
    HANDLE           hFileHandle = 0;
    KIRQL            Irql;

    //  Validate the parameter
    //
    ASSERT( pLink);
    if (!pLink)
    {
        return;
    }

    //  Swap our new objects into the NdisLink.
    //
    KeAcquireSpinLock( &pLink->spinLock, &Irql);
    if (pLink->flags & LINK_ESTABLISHED)
    {
        pDeviceObject = pLink->pDeviceObject;
        pLink->pDeviceObject = NULL;

        pFileObject = pLink->pFileObject;
        pLink->pFileObject = NULL;

        pLink->flags &= ~LINK_ESTABLISHED;
    }
    KeReleaseSpinLock( &pLink->spinLock, Irql);

    //
    // DeReference the private interface handles.
    //

    if (pDeviceObject)
    {
        ObDereferenceObject(pDeviceObject);
        pDeviceObject = NULL;
    }

    if (pFileObject)
    {
        ObDereferenceObject(pFileObject);
        pFileObject = NULL;
    }

}


//////////////////////////////////////////////////////////////////////////////
PLINK
OpenLink (
    PLINK   pLink,
    UNICODE_STRING  DriverName
)
//////////////////////////////////////////////////////////////////////////////
{
    NTSTATUS    ntStatus = STATUS_SUCCESS;
    PWSTR       pwstr = (PWSTR)NULL;
    UNICODE_STRING uni = {0};
    OBJECT_ATTRIBUTES objAttrib = {0};
    IO_STATUS_BLOCK IoStatusBlock = {0};

    PDEVICE_OBJECT   pDeviceObject = NULL;
    PFILE_OBJECT     pFileObject = NULL;
    HANDLE           hFileHandle = 0;
    KIRQL            Irql;
    
    if (pLink->flags & LINK_ESTABLISHED)
    {
        goto err;
    }


    //
    // Set the link_established flag.  This will be cleared if the call fails.
    //


#ifndef WIN9X

    //
    // Look up the interface for NDISIP. This gets the full path used by
    // swenum to find and open NdisIp.sys.
    //

    ntStatus = IoGetDeviceInterfaces( (GUID *) &IID_IBDA_BDANetInterface,
                                      NULL,
                                      0,
                                      &pwstr);

    if (ntStatus != STATUS_SUCCESS || pwstr == NULL)
    {
        goto err;
    }

    //
    // Initialize a Unicode string to the NDIS driver's Software Enum Path/Name.
    //

    RtlInitUnicodeString( &uni, pwstr);

    //
    // Open Ndisip.sys via swenum.
    //

    InitializeObjectAttributes( &objAttrib,
                                &uni,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL);

    ntStatus = ZwCreateFile( &hFileHandle,
                             FILE_WRITE_DATA|FILE_READ_ATTRIBUTES,
                             &objAttrib,
                             &IoStatusBlock,
                             0,
                             FILE_ATTRIBUTE_NORMAL,
                             FILE_SHARE_WRITE|FILE_SHARE_READ,
                             FILE_OPEN_IF,
                             0,
                             NULL,
                             0);


    if (ntStatus != STATUS_SUCCESS)
    {
        goto err;
    }
#endif

    //
    // Now get get handles to the Ndisip.sys/streamip.sys private
    // data interface.
    //

    ntStatus = IoGetDeviceObjectPointer (
                   &DriverName,
                   FILE_READ_ATTRIBUTES,
                   &pFileObject,
                   &pDeviceObject);

    if (ntStatus != STATUS_SUCCESS)
    {
        goto err;
    }

    ObReferenceObject(pDeviceObject);
    ObReferenceObject(pFileObject);


    //  Swap our new objects into the NdisLink.
    //
    KeAcquireSpinLock( &pLink->spinLock, &Irql);
    pLink->flags |= LINK_ESTABLISHED;

    //  Exchange our new device object reference for the one currently used.
    //
    {
        PDEVICE_OBJECT   pDeviceObjectT;
        
        pDeviceObjectT = pLink->pDeviceObject;
        pLink->pDeviceObject = pDeviceObject;
        pDeviceObject = pDeviceObjectT;
    }

    //  Exchange our new file object reference for the one currently used.
    //
    {
        PFILE_OBJECT     pFileObjectT;

        pFileObjectT = pLink->pFileObject;
        pLink->pFileObject = pFileObject;
        pFileObject = pFileObjectT;
    }
    KeReleaseSpinLock( &pLink->spinLock, Irql);


err:
    
//  Clean up temp string allocation.
    //
    if(pwstr)
    {
        ExFreePool(pwstr);
        pwstr = NULL;
    }
    
    // DeReference any leaked objects.
    //
    //  These objects are leaked only if two or more calls to
    //  OpenLink collide or if an open failed in this routine.
    //
    if (pDeviceObject)
    {
        ObDereferenceObject( pDeviceObject);
        pDeviceObject = NULL;
    }
    if (pFileObject)
    {
        ObDereferenceObject( pFileObject);
        pFileObject = NULL;
    }
    if(hFileHandle)
    {
        ZwClose( hFileHandle);
        hFileHandle = 0;
    }

    return (pLink->flags & LINK_ESTABLISHED) ? pLink : NULL;
}

//////////////////////////////////////////////////////////////////////////////
NTSTATUS
SendIOCTL (
    PLINK     pLink,
    ULONG     ulIoctl,
    PVOID     pData,
    ULONG     ulcbData
)
//////////////////////////////////////////////////////////////////////////////
{
    PIRP pIrp                      = NULL;
    NTSTATUS ntStatus              = STATUS_SUCCESS;
    IO_STATUS_BLOCK  IoStatusBlock = {0};

    //
    // Create a control request block
    //
    pIrp = IoBuildDeviceIoControlRequest(
                ulIoctl,
                pLink->pDeviceObject,
                pData,
                ulcbData,
                0,                            // Optional output buffer
                0,                            // Optional output buffer length
                TRUE,                         // InternalDeviceIoControl == TRUE
                NULL,                         // Optional Event
                &IoStatusBlock);

    if (pIrp != NULL)
    {
        PIO_STACK_LOCATION   pNextStackLocation;

        pNextStackLocation = IoGetNextIrpStackLocation(pIrp);
        if (pNextStackLocation)
        {
            pNextStackLocation->FileObject = pLink->pFileObject;
    
            IoStatusBlock.Status = STATUS_SUCCESS;
    
            //
            // Feed the NDIS mini-driver
            //
            
            ntStatus = IoCallDriver( pLink->pDeviceObject, pIrp);
    
            if (ntStatus  != STATUS_SUCCESS ||
                IoStatusBlock.Status != STATUS_SUCCESS)
            {
                ntStatus = STATUS_UNSUCCESSFUL;
            }
        }
        else
        {
            ntStatus = STATUS_UNSUCCESSFUL;
        }
    }
    else
    {
        ntStatus = STATUS_UNSUCCESSFUL;
    }


    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\bda\ipsink\stream\bdastream.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

#ifndef __BDASTRM_H__
#define __BDASTRM_H__

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus


////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
DEFINE_KSPROPERTY_TABLE(IPSinkConnectionProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_CONNECTION_ALLOCATORFRAMING,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(KSALLOCATOR_FRAMING),            // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),

};

////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
DEFINE_KSPROPERTY_TABLE(StreamAllocatorProperties)
{
    DEFINE_KSPROPERTY_ITEM_STREAM_ALLOCATOR
    (
        FALSE,
        TRUE
    )
};

////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
DEFINE_KSPROPERTY_SET_TABLE(IPSinkStreamProperties)
{
    DEFINE_KSPROPERTY_SET
    (
        &KSPROPSETID_Connection,                        // Set
        SIZEOF_ARRAY(IPSinkConnectionProperties),       // PropertiesCount
        IPSinkConnectionProperties,                     // PropertyItems
        0,                                              // FastIoCount
        NULL                                            // FastIoTable
    ),

    DEFINE_KSPROPERTY_SET
    (
        &KSPROPSETID_Stream,                             // Set
        SIZEOF_ARRAY(StreamAllocatorProperties),         // PropertiesCount
        StreamAllocatorProperties,                       // PropertyItems
        0,                                               // FastIoCount
        NULL                                             // FastIoTable
    ),

};

#define NUMBER_IPSINK_STREAM_PROPERTIES (SIZEOF_ARRAY(IPSinkStreamProperties))


////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
DEFINE_KSPROPERTY_TABLE(IPSinkDefaultProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_IPSINK_MULTICASTLIST,
        TRUE,
        sizeof (KSPROPERTY),
        0,
        FALSE,
        NULL,
        0,
        NULL,
        NULL,
        0
     ),


    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_IPSINK_ADAPTER_DESCRIPTION,
        TRUE,
        sizeof (KSPROPERTY),
        0,
        FALSE,
        NULL,
        0,
        NULL,
        NULL,
        0
     ),


     DEFINE_KSPROPERTY_ITEM
     (
         KSPROPERTY_IPSINK_ADAPTER_ADDRESS,
         TRUE,                                   // GetSupported or Handler
         sizeof(KSPROPERTY),                     // MinProperty
         0,                                      // MinData
         TRUE,                                   // SetSupported or Handler
         NULL,                                   // Values
         0,                                      // RelationsCount
         NULL,                                   // Relations
         NULL,                                   // SupportHandler
         0                                       // SerializedSize
     )
};



////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
DEFINE_KSPROPERTY_SET_TABLE(IPSinkCodecProperties)
{
    DEFINE_KSPROPERTY_SET
    (
        &IID_IBDA_IPSinkControl,                        // Set
        SIZEOF_ARRAY(IPSinkDefaultProperties),          // PropertiesCount
        IPSinkDefaultProperties,                        // PropertyItems
        0,                                              // FastIoCount
        NULL                                            // FastIoTable

    ),

};

#define NUMBER_IPSINK_CODEC_PROPERTIES (SIZEOF_ARRAY(IPSinkCodecProperties))


////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
DEFINE_KSEVENT_TABLE(IPSinkDefaultEvents)
{
    DEFINE_KSEVENT_ITEM
    (
        KSEVENT_IPSINK_MULTICASTLIST,       // Event Id
        sizeof (KSEVENTDATA),               // Minimum size of event data
        0,                                  // size of extra data staorage
        NULL,                               // Add Handler
        NULL,                               // RemoveHandler
        NULL                                // SupportHandler
    ),
    DEFINE_KSEVENT_ITEM
    (
        KSEVENT_IPSINK_ADAPTER_DESCRIPTION, // Event Id
        sizeof (KSEVENTDATA),               // Minimum size of event data
        0,                                  // size of extra data staorage
        NULL,                               // Add Handler
        NULL,                               // RemoveHandler
        NULL                                // SupportHandler
    )
};


DEFINE_KSEVENT_SET_TABLE(IPSinkEvents)
{
    DEFINE_KSEVENT_SET
    (
        &IID_IBDA_IPSinkEvent,                          // Event GUID
        SIZEOF_ARRAY(IPSinkDefaultEvents),              // Event count
        IPSinkDefaultEvents                             // Event items
    ),
};

#define NUMBER_IPSINK_EVENTS (SIZEOF_ARRAY(IPSinkEvents))



//---------------------------------------------------------------------------
// All of the video and vbi data formats we might use
//---------------------------------------------------------------------------

KS_DATAFORMAT_IPSINK_IP StreamFormatIPSinkIP =
{
    //
    // KSDATARANGE
    //
    sizeof (KSDATAFORMAT),
    0,
    4096,               // sizeof an MPE section
    0,                  // Reserved
    { STATIC_KSDATAFORMAT_TYPE_BDA_IP },
    { STATIC_KSDATAFORMAT_SUBTYPE_BDA_IP },
    { STATIC_KSDATAFORMAT_SPECIFIER_BDA_IP }
};


KS_DATAFORMAT_IPSINK_IP StreamFormatNetControl =
{
    //
    // KSDATARANGE
    //
    sizeof (KSDATAFORMAT),
    0,
    4093,               // sizeof an IP Packet
    0,                  // Reserved
    { STATIC_KSDATAFORMAT_TYPE_BDA_IP_CONTROL },
    { STATIC_KSDATAFORMAT_SUBTYPE_BDA_IP_CONTROL },
    { STATIC_KSDATAFORMAT_SPECIFIER_NONE }
};



//---------------------------------------------------------------------------
//  STREAM_Input Formats
//---------------------------------------------------------------------------

static PKSDATAFORMAT Stream0Formats[] =
{
    (PKSDATAFORMAT) &StreamFormatIPSinkIP,

    // Add more formats here for to mirror output formats for "passthrough" mode
    // The idea is that upstream capture drivers may have done some decoding already
    // or downstream drivers may wish to have the raw data without any decoding at all.
    // In that case all we need to do is copy the data(if there is a pending SRB) OR
    // forward the SRB to the downstream client.
};

#define NUM_STREAM_0_FORMATS (SIZEOF_ARRAY(Stream0Formats))


//---------------------------------------------------------------------------
//  STREAM_Output Formats
//---------------------------------------------------------------------------

static PKSDATAFORMAT Stream1Formats[] =
{
    (PKSDATAFORMAT) &StreamFormatNetControl,

    //
    // Add more formats here for whatever output formats are supported.
    //
};
#define NUM_STREAM_1_FORMATS (SIZEOF_ARRAY (Stream1Formats))

//---------------------------------------------------------------------------
// Create an array that holds the list of all of the streams supported
//---------------------------------------------------------------------------

typedef struct _ALL_STREAM_INFO
{
    HW_STREAM_INFORMATION   hwStreamInfo;
    HW_STREAM_OBJECT        hwStreamObject;

} ALL_STREAM_INFO, *PALL_STREAM_INFO;

static ALL_STREAM_INFO Streams [] =
{
    {
        // HW_STREAM_INFORMATION -------------------------------------------
        {
            1,                                        // NumberOfPossibleInstances
            KSPIN_DATAFLOW_IN,                        // DataFlow
            TRUE,                                     // DataAccessible
            NUM_STREAM_0_FORMATS,                     // NumberOfFormatArrayEntries
            Stream0Formats,                           // StreamFormatsArray
            0,                                        // ClassReserved[0]
            0,                                        // ClassReserved[1]
            0,                                        // ClassReserved[2]
            0,                                        // ClassReserved[3]
            NUMBER_IPSINK_STREAM_PROPERTIES,          // Number of stream properties
            (PKSPROPERTY_SET) IPSinkStreamProperties, // Stream Property Array
            0,                                        // NumStreamEventArrayEntries
            0,                                        // StreamEventsArray
            NULL,                                     // Category
            (GUID*) &PINNAME_IPSINK,                  // Name
            0,                                        // MediumsCount
            NULL,                                     // Mediums
            FALSE,                                    // BridgeStream
            0, 0                                      // Reserved  
        },

        // HW_STREAM_OBJECT ------------------------------------------------
        {
            sizeof (HW_STREAM_OBJECT),              // SizeOfThisPacket
            0,                                      // StreamNumber
            (PVOID)NULL,                            // HwStreamExtension
            ReceiveDataPacket,
            ReceiveCtrlPacket,
            {                                       // HW_CLOCK_OBJECT
                NULL,                               // .HWClockFunction
                0,                                  // .ClockSupportFlags
            },
            FALSE,                                  // Dma
            TRUE,                                   // Pio
            (PVOID)NULL,                            // HwDeviceExtension
            //sizeof (KS_VBI_FRAME_INFO),           // StreamHeaderMediaSpecific
            0,
            0,                                      // StreamHeaderWorkspace
            FALSE,                                  // Allocator
            EventHandler,                           // HwEventRoutine
        },
    },

    //
    // Network Provider Control Interface Pin
    //
    {
        // HW_STREAM_INFORMATION -------------------------------------------
        {
            1,                                      // NumberOfPossibleInstances
            KSPIN_DATAFLOW_OUT,                     // DataFlow
            TRUE,                                   // DataAccessible
            NUM_STREAM_1_FORMATS,                   // NumberOfFormatArrayEntries
            Stream1Formats,                         // StreamFormatsArray
            0,                                      // ClassReserved[0]
            0,                                      // ClassReserved[1]
            0,                                      // ClassReserved[2]
            0,                                      // ClassReserved[3]
            NUMBER_IPSINK_STREAM_PROPERTIES,          // Number of stream properties
            (PKSPROPERTY_SET) IPSinkStreamProperties, // Stream Property Array
            0,
            0,
            NULL,
            (GUID *)&PINNAME_BDA_NET_CONTROL,       // Name
            0,                                      // MediumsCount
            NULL,                                   // Mediums
            FALSE,                                  // BridgeStream
            0, 0                                    // Reserved  
        },

        // HW_STREAM_OBJECT ------------------------------------------------
        {
            sizeof (HW_STREAM_OBJECT),              // SizeOfThisPacket
            0,                                      // StreamNumber
            (PVOID)NULL,                            // HwStreamExtension
            ReceiveDataPacket,                 // HwReceiveDataPacket
            ReceiveCtrlPacket,                 // HwReceiveControlPacket
            {                                       // HW_CLOCK_OBJECT
                NULL,                                // .HWClockFunction
                0,                                   // .ClockSupportFlags
            },
            FALSE,                                  // Dma
            TRUE,                                   // Pio
            (PVOID)NULL,                            // HwDeviceExtension
            //sizeof (KS_VBI_FRAME_INFO),             // StreamHeaderMediaSpecific
            0,
            0,                                      // StreamHeaderWorkspace
            FALSE,                                  // Allocator
            NULL,                                   // HwEventRoutine
        },
    }
};

#define DRIVER_STREAM_COUNT (SIZEOF_ARRAY (Streams))


//---------------------------------------------------------------------------
// Topology
//---------------------------------------------------------------------------


// Categories define what the device does.

static GUID Categories[] =
{
    STATIC_KSCATEGORY_BDA_IP_SINK
};

#define NUMBER_OF_CATEGORIES  SIZEOF_ARRAY (Categories)

static KSTOPOLOGY Topology = {
    NUMBER_OF_CATEGORIES,
    (GUID*) &Categories,
    0,
    (GUID*) NULL,
    0,
    NULL
};


//---------------------------------------------------------------------------
// The Main stream header
//---------------------------------------------------------------------------

static HW_STREAM_HEADER StreamHeader =
{
    DRIVER_STREAM_COUNT,                // NumberOfStreams
    sizeof (HW_STREAM_INFORMATION),     // Future proofing
    0,                                  // NumDevPropArrayEntries set at init time
    NULL,                               // DevicePropertiesArray  set at init time
    0,                                  // NumDevEventArrayEntries;
    NULL,                               // DeviceEventsArray;
    &Topology                           // Pointer to Device Topology
};

#ifdef    __cplusplus
}
#endif // __cplusplus

#endif // __BDASTRM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\bda\ipsink\stream\main.h ===
//////////////////////////////////////////////////////////////////////////////\
//
//  Copyright (c) 1990  Microsoft Corporation
//
//  Module Name:
//
//     test.h
//
//  Abstract:
//
//     The main header for the NDIS/KS test driver
//
//  Author:
//
//     P Porzuczek
//
//  Environment:
//
//  Notes:
//
//  Revision History:
//
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _MAIN_H
#define _MAIN_H


#ifdef DBG

extern  ULONG TestDebugFlag;

#define TEST_DBG_NONE    0x00000000
#define TEST_DBG_TRACE   0x00000001
#define TEST_DBG_GET     0x00000002
#define TEST_DBG_BUF     0x00000080

#define TEST_DBG_DETAIL  0x00001000
#define TEST_DBG_INFO    0x00002000
#define TEST_DBG_WARNING 0x00004000
#define TEST_DBG_ERROR   0x00008000

#define TEST_DEBUG(_Trace, _Msg)                 \
{                                               \
    if (_Trace & TestDebugFlag)                  \
    {                                           \
        DbgPrint _Msg;                          \
    }                                           \
}

#define IF_TESTDEBUG(f) if (TestDebugFlag & (f))

#define TEST_DEBUG_LOUD               0x00010000  // debugging info
#define TEST_DEBUG_VERY_LOUD          0x00020000  // excessive debugging info
#define TEST_DEBUG_LOG                0x00040000  // enable Log
#define TEST_DEBUG_CHECK_DUP_SENDS    0x00080000  // check for duplicate sends
#define TEST_DEBUG_TRACK_PACKET_LENS  0x00100000  // track directed packet lens
#define TEST_DEBUG_WORKAROUND1        0x00200000  // drop DFR/DIS packets
#define TEST_DEBUG_CARD_BAD           0x00400000  // dump data if CARD_BAD
#define TEST_DEBUG_CARD_TESTS         0x00800000  // print reason for failing


//
// Macro for deciding whether to print a lot of debugging information.
//
#define IF_LOUD(A) IF_TESTDEBUG( TEST_DEBUG_LOUD ) { A }
#define IF_VERY_LOUD(A) IF_TESTDEBUG( TEST_DEBUG_VERY_LOUD ) { A }


//
// Whether to use the Log buffer to record a trace of the driver.
//
#define IF_LOG(A) IF_TESTDEBUG( TEST_DEBUG_LOG ) { A }
extern VOID TESTLog(UCHAR);

//
// Whether to do loud init failure
//
#define IF_INIT(A) A

//
// Whether to do loud card test failures
//
#define IF_TEST(A) IF_TESTDEBUG( TEST_DEBUG_CARD_TESTS ) { A }

#else

//extern  ULONG TestDebugFlag;

#define TEST_NONE
#define TEST_FUNCTIONS
#define TEST_COMMANDS
#define TEST_CONNECTIONS
#define TEST_SCIDS
#define TEST_LIST_ALLOCS
#define TEST_POOL
#define TEST_INDICATES
#define TEST_ALLOCATION


#define TEST_DEBUG(_Trace, _Msg)

#define IF_TESTDEBUG(f)

#define TEST_DEBUG_LOUD
#define TEST_DEBUG_VERY_LOUD
#define TEST_DEBUG_LOG
#define TEST_DEBUG_CHECK_DUP_SENDS
#define TEST_DEBUG_TRACK_PACKET_LENS
#define TEST_DEBUG_WORKAROUND1
#define TEST_DEBUG_CARD_BAD
#define TEST_DEBUG_CARD_TESTS


//
// This is not a debug build, so make everything quiet.
//
#define IF_LOUD(A)
#define IF_VERY_LOUD(A)
#define IF_LOG(A)
#define IF_INIT(A)
#define IF_TEST(A)

#endif // DBG


NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT    pDriverObject,
    IN PUNICODE_STRING   pszuRegistryPath);


VOID
StreamIPFreeMemory (
    PVOID pvToFree,
    ULONG ulSize
    );

NTSTATUS
StreamIPAllocateMemory (
    PVOID  *ppvAllocated,
    ULONG   ulcbSize
    );


NTSTATUS
StreamDriverInitialize (
    IN PDRIVER_OBJECT    DriverObject,
    IN PUNICODE_STRING   RegistryPath
    );

#endif // _MAIN_H

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\bda\ipsink\stream\main.c ===
/////////////////////////////////////////////////////////////////////////////
//
//
// Copyright (c) 1996, 1997  Microsoft Corporation
//
//
// Module Name:
//      test.c
//
// Abstract:
//
//      This file is a test to find out if dual binding to NDIS and KS works
//
// Author:
//
//      P Porzuczek
//
// Environment:
//
// Revision History:
//
//
//////////////////////////////////////////////////////////////////////////////

//
//
#include <memory.h>
#include <ndis.h>

#include "Main.h"

NTSTATUS
CreateDeviceObject(
    IN PDRIVER_OBJECT pDriverObject
    );

/////////////////////////////////////////////////////////////////////////////
//
// Highest accepatble memory address
//
NDIS_PHYSICAL_ADDRESS HighestAcceptableMax = NDIS_PHYSICAL_ADDRESS_CONST(-1,-1);



/////////////////////////////////////////////////////////////////////////////
//
// Default debug mode
//
// ULONG TestDebugFlag = TEST_DBG_INFO;
ULONG TestDebugFlag = 0;


#ifdef DBG

/////////////////////////////////////////////////////////////////////////////
// Debugging definitions
//


//
// Debug tracing defintions
//
#define TEST_LOG_SIZE 256
UCHAR TestLogBuffer[TEST_LOG_SIZE]={0};
UINT  TestLogLoc = 0;

/////////////////////////////////////////////////////////////////////////////
//
// Logging function in debug builds
//
extern VOID
TestLog (
    UCHAR c         // input character
    )
/////////////////////////////////////////////////////////////////////////////
{
    TestLogBuffer[TestLogLoc++] = c;

    TestLogBuffer[(TestLogLoc + 4) % TEST_LOG_SIZE] = '\0';

    if (TestLogLoc >= TEST_LOG_SIZE) {
        TestLogLoc = 0;
    }
}

#endif // DBG

//////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT    pDriverObject,
    IN PUNICODE_STRING   pszuRegistryPath
    )
//////////////////////////////////////////////////////////////////////////////////////
{
    NTSTATUS                        ntStatus = STATUS_SUCCESS;

    //
    // Register the Stream Class binding
    //
    ntStatus = StreamDriverInitialize (pDriverObject,  pszuRegistryPath);
    if (ntStatus != STATUS_SUCCESS)
    {
        goto ret;
    }

ret:

    TEST_DEBUG (TEST_DBG_TRACE, ("Driver Entry complete, ntStatus: %08X\n", ntStatus));

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\bda\mpe\makefile.inc ===
# HACK ALERT: This target is solely to keep nmake from whining that it doesn't
# know how to make the dependency in rules that depend on the target executable.
$(TARGETPATHEX)\$(TARGETNAME).sys:

# Build SoftICE symbols
$(TARGETPATHEX)\$(TARGETNAME).nms: $(TARGETPATHEX)\$(TARGETNAME).sys
    echo $(TARGETPATHEX)\$(TARGETNAME) > target.txt
    nmsym /translate:source,package,always /source:. /output:$(TARGETPATHEX)\$(TARGETNAME).nms $(TARGETPATHEX)\$(TARGETNAME).sys
    splitsym -s $(_NT_SYMBOL_PATH)  $(TARGETPATHEX)\$(TARGETNAME).sys

# Delete built files
clean:
    -echo $(TARGETPATHEX)\$(TARGETNAME).*
    -del /s *.obj
    -del /s *.res
    -del build.log
    -del build.err
    -del /s _objects.mac
    -del $(TARGETPATHEX)\$(TARGETNAME).*
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\bda\mpe\filter.h ===
#ifndef _FILTER_H_
#define _FILTER_H_


//////////////////////////////////////////////////////////////////
//
//
//
NTSTATUS
CreateFilter (
    PDRIVER_OBJECT DriverObject,
    PDEVICE_OBJECT DeviceObject,
    PMPE_FILTER   pFilter
    );

NTSTATUS
Filter_QueryInterface (
    PMPE_FILTER pFilter
    );

ULONG
Filter_AddRef (
    PMPE_FILTER pFilter
    );

ULONG
Filter_Release (
    PMPE_FILTER pFilter
    );

#endif  // _FILTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\bda\mpe\filter.c ===
/////////////////////////////////////////////////////////////////////////////
//
//
// Copyright (c) 1996, 1997  Microsoft Corporation
//
//
// Module Name:
//      filter.c
//
// Abstract:
//
//      This file is a test to find out if dual binding to NDIS and KS works
//
// Author:
//
//      P Porzuczek
//
// Environment:
//
// Revision History:
//
//
//////////////////////////////////////////////////////////////////////////////

#include <wdm.h>
#include <strmini.h>

#include "mpe.h"
#include "Main.h"
#include "filter.h"


//////////////////////////////////////////////////////////////////////////////
//
//
//
const FILTER_VTABLE FilterVTable =
    {
    Filter_QueryInterface,
    Filter_AddRef,
    Filter_Release,
    };


///////////////////////////////////////////////////////////////////////////////////
NTSTATUS
CreateFilter (
    PDRIVER_OBJECT DriverObject,
    PDEVICE_OBJECT DeviceObject,
    PMPE_FILTER pFilter
    )
///////////////////////////////////////////////////////////////////////////////////
{
    NTSTATUS ntStatus = STATUS_SUCCESS;

    //
    // Save off our Device/Driver Objectsx in our context area
    //
    pFilter->DeviceObject          = DeviceObject;
    pFilter->DriverObject          = DriverObject;
    pFilter->lpVTable              = (PFILTER_VTABLE) &FilterVTable;
    pFilter->ulRefCount            = 1;

    pFilter->bDiscontinuity        = FALSE;

    return ntStatus;
}


///////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Filter_QueryInterface (
    PMPE_FILTER pFilter
    )
///////////////////////////////////////////////////////////////////////////////////
{
    return STATUS_NOT_IMPLEMENTED;
}

///////////////////////////////////////////////////////////////////////////////////
ULONG
Filter_AddRef (
    PMPE_FILTER pFilter
    )
///////////////////////////////////////////////////////////////////////////////////
{
    if (pFilter)
    {
        pFilter->ulRefCount += 1;
        return pFilter->ulRefCount;
    }

    return 0;
}

///////////////////////////////////////////////////////////////////////////////////
ULONG
Filter_Release (
    PMPE_FILTER pFilter
    )
///////////////////////////////////////////////////////////////////////////////////
{
    ULONG ulRefCount = 0L;

    if (pFilter)
    {
        pFilter->ulRefCount -= 1;
        ulRefCount = pFilter->ulRefCount;

        if (pFilter->ulRefCount == 0)
        {
            // $$BUG  Free Filter here
            return ulRefCount;
        }
    }

    return ulRefCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\bda\ipsink\stream\streamip.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

#ifndef __STREAMIP_H__
#define __STREAMIP_H__

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#define ENTRIES(a)  (sizeof(a)/sizeof(*(a)))

/**************************************************************/
/* Driver Name - Change this to reflect your executable name! */
/**************************************************************/

#define STREAMIPNAME            "STREAMIP"
#define STREAMIPNAMEUNICODE    L"STREAMIP"

// This defines the name of the WMI device that manages service IOCTLS
#define CodecDeviceName (L"\\\\.\\" STREAMIPNAMEUNICODE)
#define CodecSymbolicName (L"\\DosDevices\\" STREAMIPNAMEUNICODE)


// ------------------------------------------------------------------------
// The master list of all streams supported by this driver
// ------------------------------------------------------------------------

typedef enum
{
    STREAM_IP,
    STREAM_NET_CONTROL
};


// The MAX_STREAM_COUNT value must be equal to DRIVER_STREAM_COUNT
// This particular value must be defined here to avoid circular references
#define MAX_STREAM_COUNT    1

// We manage multiple instances of each pin up to this limit
#define MAX_PIN_INSTANCES   8

#define BIT(n)              (1L<<(n))
#define BITSIZE(v)          (sizeof(v)*8)
#define SETBIT(array,n)     (array[n/BITSIZE(*array)] |= BIT(n%BITSIZE(*array)))
#define CLEARBIT(array,n)   (array[n/BITSIZE(*array)] &= ~BIT(n%BITSIZE(*array)))

/*****************************************************************************
*
* The following structures are samples of information that could be used in
* a device extension structure
*
*****************************************************************************/

//
// this structure is our per stream extension structure.  This stores
// information that is relevant on a per stream basis.  Whenever a new stream
// is opened, the stream class driver will allocate whatever extension size
// is specified in the HwInitData.PerStreamExtensionSize.
//

typedef struct _STREAM_
{
    PIPSINK_FILTER                      pFilter;
    PHW_STREAM_OBJECT                   pStreamObject;      // For timer use
    KSSTATE                             KSState;            // Run, Stop, Pause
    REFERENCE_TIME                      FrameTime100ns;     // elapsed time based on frames captured
    HANDLE                              hMasterClock;
    HANDLE                              hClock;
    ULONG                               ulStreamInstance;   // 0..NumberOfPossibleInstances-1
    KSDATAFORMAT                        OpenedFormat;       // Based on the actual open request.

    KSDATARANGE                         MatchedFormat;

    KSPIN_LOCK                          StreamControlSpinLock;  // Command queue spin lock
    KSPIN_LOCK                          StreamDataSpinLock;     // Data queue spin lock
    LIST_ENTRY                          StreamDataQueue;        // Stream data queue
    LIST_ENTRY                          StreamControlQueue;     // Stream command queue

} STREAM, *PSTREAM;

//
// This structure is our per SRB extension, and carries the forward and backward
// links for the pending SRB queue.
//
typedef struct _SRB_EXTENSION
{
    LIST_ENTRY                      ListEntry;
    PHW_STREAM_REQUEST_BLOCK        pSrb;

} SRB_EXTENSION, *PSRB_EXTENSION;


/*****************************************************************************
*
* the following section defines prototypes for the minidriver initialization
* routines
*
******************************************************************************/

//
// This routine is called by the stream class driver with configuration
// information for an adapter that the mini driver should load on.  The mini
// driver should still perform a small verification to determine that the
// adapter is present at the specified addresses, but should not attempt to
// find an adapter as it would have with previous NT miniports.
//
// All initialization of the codec should also be performed at this time.
//

BOOLEAN CodecInitialize (IN OUT PHW_STREAM_REQUEST_BLOCK pSrb);


//
// This routine is called when the system is going to remove or disable the
// device.
//
// The mini-driver should free any system resources that it allocated at this
// time.  Note that system resources allocated for the mini-driver by the
// stream class driver will be free'd by the stream driver, and should not be
// free'd in this routine.  (Such as the HW_DEVICE_EXTENSION)
//

BOOLEAN CodecUnInitialize( PHW_STREAM_REQUEST_BLOCK pSrb);


BOOLEAN CodecQueryUnload ( PHW_STREAM_REQUEST_BLOCK pSrb);      // Not implemented currently


//
// This is the prototype for the Hardware Interrupt Handler.  This routine
// will be called if the minidriver registers for and receives an interrupt
//

BOOLEAN HwInterrupt (IN PIPSINK_FILTER pFilter);

//
// This is the prototype for the stream enumeration function.  This routine
// provides the stream class driver with the information on data stream types
// supported
//

VOID CodecStreamInfo(PHW_STREAM_REQUEST_BLOCK pSrb);

//
// This is the prototype for the stream open function
//

VOID CodecOpenStream(PHW_STREAM_REQUEST_BLOCK pSrb);

//
// This is the prototype for the stream close function
//

VOID CodecCloseStream(PHW_STREAM_REQUEST_BLOCK pSrb);

//
// This is the prototype for the CodecReceivePacket routine.  This is the
// entry point for command packets that are sent to the codec (not to a
// specific open stream)
//

VOID STREAMAPI CodecReceivePacket(IN PHW_STREAM_REQUEST_BLOCK Srb);

//
// This is the protoype for the cancel packet routine.  This routine enables
// the stream class driver to cancel an outstanding packet.
//

VOID STREAMAPI CodecCancelPacket(IN PHW_STREAM_REQUEST_BLOCK Srb);

//
// This is the packet timeout function.  The codec may choose to ignore a
// packet timeout, or reset the codec and cancel the requests, as required.
//

VOID STREAMAPI CodecTimeoutPacket(IN PHW_STREAM_REQUEST_BLOCK Srb);

VOID STREAMAPI CodecGetProperty(IN PHW_STREAM_REQUEST_BLOCK Srb);
VOID STREAMAPI CodecSetProperty(IN PHW_STREAM_REQUEST_BLOCK Srb);

BOOL
CodecVerifyFormat(IN KSDATAFORMAT *pKSDataFormat,
                  UINT StreamNumber,
                  PKSDATARANGE pMatchedFormat);

BOOL
CodecFormatFromRange(
        IN PHW_STREAM_REQUEST_BLOCK pSrb);

void
CompleteStreamSRB (
         IN PHW_STREAM_REQUEST_BLOCK pSrb,
         STREAM_MINIDRIVER_STREAM_NOTIFICATION_TYPE NotificationType1,
         BOOL fUseNotification2,
         STREAM_MINIDRIVER_STREAM_NOTIFICATION_TYPE NotificationType2
        );
void
CompleteDeviceSRB (
         IN PHW_STREAM_REQUEST_BLOCK pSrb,
         IN STREAM_MINIDRIVER_DEVICE_NOTIFICATION_TYPE NotificationType,
         BOOL fReadyForNext
        );

//
// prototypes for data handling routines
//
void            CompleteStreamIRP (IN PHW_STREAM_REQUEST_BLOCK pSrb, BOOLEAN ReadyForNext);

VOID STREAMAPI VideoReceiveDataPacket(IN PHW_STREAM_REQUEST_BLOCK pSrb);
VOID STREAMAPI VideoReceiveCtrlPacket(IN PHW_STREAM_REQUEST_BLOCK pSrb);
void           EnableIRQ(PHW_STREAM_OBJECT pstrm);
void           DisableIRQ(PHW_STREAM_OBJECT pstrm);

//
// prototypes for properties and states
//
VOID            VideoSetState(PHW_STREAM_REQUEST_BLOCK pSrb);
VOID            VideoGetState(PHW_STREAM_REQUEST_BLOCK pSrb);
VOID            VideoSetProperty(PHW_STREAM_REQUEST_BLOCK pSrb);
VOID            VideoGetProperty(PHW_STREAM_REQUEST_BLOCK pSrb);
//VOID          VideoStreamSetConnectionProperty (PHW_STREAM_REQUEST_BLOCK pSrb); // Not implemented
VOID            VideoStreamGetConnectionProperty (PHW_STREAM_REQUEST_BLOCK pSrb);
VOID            VideoStreamSetVBIFilteringProperty (PHW_STREAM_REQUEST_BLOCK pSrb);
VOID            VideoStreamGetVBIFilteringProperty (PHW_STREAM_REQUEST_BLOCK pSrb);

//
// system time functions
//

ULONGLONG       VideoGetSystemTime();

//
// stream clock functions
//
VOID            VideoIndicateMasterClock(PHW_STREAM_REQUEST_BLOCK pSrb);

//
// SRB Queue Management functions
//
BOOL STREAMAPI QueueAddIfNotEmpty(
                                                        IN PHW_STREAM_REQUEST_BLOCK,
                                                        IN PKSPIN_LOCK,
                           IN PLIST_ENTRY
                           );
BOOL STREAMAPI QueueAdd(
                                                        IN PHW_STREAM_REQUEST_BLOCK,
                                                        IN PKSPIN_LOCK,
                           IN PLIST_ENTRY
                           );
BOOL STREAMAPI QueueRemove(
                                                        IN OUT PHW_STREAM_REQUEST_BLOCK *,
                                                        IN PKSPIN_LOCK,
                           IN PLIST_ENTRY
                           );
BOOL STREAMAPI QueueRemoveSpecific(
                                                        IN PHW_STREAM_REQUEST_BLOCK,
                           IN PKSPIN_LOCK,
                           IN PLIST_ENTRY
                           );
BOOL STREAMAPI QueueEmpty(
                           IN PKSPIN_LOCK,
                           IN PLIST_ENTRY
                           );
#ifdef    __cplusplus
}
#endif // __cplusplus


VOID
STREAMAPI
CodecReceivePacket(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    );

BOOLEAN
CodecInitialize (
    IN OUT PHW_STREAM_REQUEST_BLOCK pSrb
    );

VOID
STREAMAPI
CodecCancelPacket(
    PHW_STREAM_REQUEST_BLOCK pSrb
    );

VOID
STREAMAPI
CodecTimeoutPacket(
    PHW_STREAM_REQUEST_BLOCK pSrb
    );

NTSTATUS
LinkToNdisHandler (
    PVOID pvContext
    );


BOOL
CompareGUIDsAndFormatSize(
    IN PKSDATARANGE pDataRange1,
    IN PKSDATARANGE pDataRange2,
    BOOLEAN bCheckSize
    );

BOOL
CompareStreamFormat (
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    );

BOOLEAN
VerifyFormat(
    IN KSDATAFORMAT *pKSDataFormat,
    UINT StreamNumber,
    PKSDATARANGE pMatchedFormat
    );

VOID
OpenStream (
    PHW_STREAM_REQUEST_BLOCK pSrb
    );

VOID
CloseStream (
    PHW_STREAM_REQUEST_BLOCK pSrb
    );

VOID
STREAMAPI
ReceiveDataPacket (
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    );

NTSTATUS
STREAMAPI
EventHandler (
    IN PHW_EVENT_DESCRIPTOR pEventDesriptor
    );

VOID
STREAMAPI
ReceiveCtrlPacket(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    );

VOID
IpSinkSetState(
    PHW_STREAM_REQUEST_BLOCK pSrb
    );

#endif // _STREAM_IP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\bda\ipsink\stream\streamip.c ===
/////////////////////////////////////////////////////////////////////////////
//
//
// Copyright (c) 1996, 1997  Microsoft Corporation
//
//
// Module Name:
//      ipstream.c
//
// Abstract:
//
//      This file is a test to find out if dual binding to NDIS and KS works
//
// Author:
//
//      P Porzuczek
//
// Environment:
//
// Revision History:
//
//
//////////////////////////////////////////////////////////////////////////////

#ifndef DWORD
#define DWORD ULONG
#endif

#include <forward.h>
#include <wdm.h>
#include <strmini.h>
#include <ksmedia.h>

#include <winerror.h>

#include <link.h>
#include <ipsink.h>
#include <BdaTypes.h>
#include <BdaMedia.h>

#include "IpMedia.h"
#include "StreamIP.h"
#include "bdastream.h"

#include "Main.h"
#include "filter.h"


#ifdef DEBUG

#define SRB_TABLE_SIZE  1000
PHW_STREAM_REQUEST_BLOCK     SRBTable [SRB_TABLE_SIZE] = {0};

//////////////////////////////////////////////////////////////////////////////
void
TraceSRB (
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    int i;
    PHW_STREAM_REQUEST_BLOCK *p = NULL;

    //
    // Find a NULL entry in the SRB Table
    //
    for (i = 0, p = SRBTable; i < SRB_TABLE_SIZE; i++, p++)
    {
        if (*p == NULL)
        {
            *p = pSRB;
            return;
        }
    }

    return;
}



//////////////////////////////////////////////////////////////////////////////
VOID STREAMAPI
MyStreamClassStreamNotification(
    IN STREAM_MINIDRIVER_STREAM_NOTIFICATION_TYPE NotificationType,
    IN PHW_STREAM_OBJECT StreamObject,
    PHW_STREAM_REQUEST_BLOCK pSrb
)
//////////////////////////////////////////////////////////////////////////////
{
    int i;
    PHW_STREAM_REQUEST_BLOCK *p = NULL;

    //
    // Find this SRB pointer in the SRB Table
    //
    for (i = 0, p = SRBTable; i < SRB_TABLE_SIZE; i++. p++)
    {
        if (*p == pSRB)
        {
            *p = NULL;
        }
    }

    StreamClassStreamNotification (NotificationType, StreamObject, pSrb );

    return;
}

//////////////////////////////////////////////////////////////////////////////
void
DumpSRBTable (
    void
    )
//////////////////////////////////////////////////////////////////////////////
{
    int i;
    PHW_STREAM_REQUEST_BLOCK *p = NULL;

    //
    // Find this SRB pointer in the SRB Table
    //
    for (i = 0, p = SRBTable; i < SRB_TABLE_SIZE; i++. p++)
    {
        if (*p != NULL)
        {
            TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: ERROR....SRB NOT Completed %08X\n, *p"));
        }
    }

    return;
}



#define StreamNotification(a,b,c) MyStreamClassStreamNotification (a,b,c)



#else

#define StreamNotification(a,b,c) StreamClassStreamNotification (a,b,c)
#define DumpSRBTable()

#endif



//////////////////////////////////////////////////////////////////////////////
//
//
VOID
DumpDataFormat (
    PKSDATAFORMAT   pF
    );


#ifdef DBG
BOOLEAN     fAllocatedDescription = FALSE;
#endif // DBG

//////////////////////////////////////////////////////////////////////////////
VOID
GetAdapterDescription (
    PIPSINK_FILTER pFilter
    )
//////////////////////////////////////////////////////////////////////////////
{
    PKSEVENT_ENTRY pEventEntry = NULL;

    ASSERT( pFilter);

    if (!pFilter->pAdapter)
    {
        //$REVIEW - Should we return a failure code?
        return;
    }

    //
    //  If we already got an adapter description then free it
    //
    if (pFilter->pAdapterDescription)
    {
        #if DBG
        ASSERT( fAllocatedDescription);
        #endif // DBG

        ExFreePool( pFilter->pAdapterDescription);
        pFilter->pAdapterDescription = NULL;
        pFilter->ulAdapterDescriptionLength = 0;
    }

    //
    // Get the length of the description string.  This should include the terminating NULL in the count
    //
    pFilter->ulAdapterDescriptionLength = pFilter->pAdapter->lpVTable->GetDescription (pFilter->pAdapter, NULL);

    if (pFilter->ulAdapterDescriptionLength)
    {
        pFilter->pAdapterDescription = ExAllocatePool(NonPagedPool, pFilter->ulAdapterDescriptionLength);

        #ifdef DBG
        fAllocatedDescription = TRUE;
        #endif // DBG

        //
        // Get the adapter description string.  This is passed up to the IPSINK
        // plugin, which then uses it to determine the NIC IP Address via calls to the
        // TCP/IP protocol.  NOTE:  This call should copy the description including the NULL terminator
        //
        if (pFilter->pAdapterDescription)
        {
            pFilter->pAdapter->lpVTable->GetDescription (pFilter->pAdapter, pFilter->pAdapterDescription);


            //
            // Signal the event to anyone waiting for it
            //
            pEventEntry = StreamClassGetNextEvent(
                              pFilter,
                              NULL,
                              (GUID *) &IID_IBDA_IPSinkEvent,
                              KSEVENT_IPSINK_ADAPTER_DESCRIPTION,
                              NULL
                              );

            if (pEventEntry)
            {
                StreamClassDeviceNotification (SignalDeviceEvent, pFilter, pEventEntry);
            }
        }
    }

    return;
}

//////////////////////////////////////////////////////////////////////////////
VOID
IPSinkGetConnectionProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    PSTREAM pStream                     = (PSTREAM)pSrb->StreamObject->HwStreamExtension;
    PSTREAM_PROPERTY_DESCRIPTOR pSPD    = pSrb->CommandData.PropertyInfo;
    ULONG Id                            = pSPD->Property->Id;              // index of the property
    ULONG ulStreamNumber                = pSrb->StreamObject->StreamNumber;

    pSrb->ActualBytesTransferred = 0;

    switch (Id)
    {
        case KSPROPERTY_CONNECTION_ALLOCATORFRAMING:
        {
            PKSALLOCATOR_FRAMING Framing = (PKSALLOCATOR_FRAMING) pSPD->PropertyInfo;

            Framing->RequirementsFlags   = KSALLOCATOR_REQUIREMENTF_SYSTEM_MEMORY    |
                                           KSALLOCATOR_REQUIREMENTF_INPLACE_MODIFIER |
                                           KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY;

            Framing->PoolType            = NonPagedPool;
            Framing->Frames              = 0;
            Framing->FrameSize           = 0;
            Framing->FileAlignment       = 0;         // None OR FILE_QUAD_ALIGNMENT-1 OR PAGE_SIZE-1;
            Framing->Reserved            = 0;

            switch (ulStreamNumber)
            {
                case STREAM_IP:
                    Framing->Frames    = 16;
                    Framing->FrameSize = pStream->OpenedFormat.SampleSize;
                    pSrb->Status = STATUS_SUCCESS;
                    break;

                case STREAM_NET_CONTROL:
                    Framing->Frames    = 4;
                    Framing->FrameSize = pStream->OpenedFormat.SampleSize;
                    pSrb->Status = STATUS_SUCCESS;
                    break;

                default:
                    pSrb->Status = STATUS_NOT_IMPLEMENTED;
                    break;
            }

            pSrb->ActualBytesTransferred = sizeof (KSALLOCATOR_FRAMING);
        }
        break;

        default:
            pSrb->Status = STATUS_NOT_IMPLEMENTED;
            break;
    }

    return;
}


//////////////////////////////////////////////////////////////////////////////
VOID
IPSinkGetCodecProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    PSTREAM_PROPERTY_DESCRIPTOR pSPD    = pSrb->CommandData.PropertyInfo;
    ULONG Id                            = pSPD->Property->Id;              // index of the property

    PIPSINK_FILTER pFilter              = (PIPSINK_FILTER)pSrb->HwDeviceExtension;
    PVOID pProperty                     = (PVOID) pSPD->PropertyInfo;

    PULONG pPacketCount                 = NULL;
    PBYTE  pMulticastList               = NULL;
    PBYTE  pDescription                 = NULL;
    PBYTE  pAddress                     = NULL;

    pSrb->ActualBytesTransferred = 0;

    switch (Id)
    {
        case KSPROPERTY_IPSINK_MULTICASTLIST:

            //
            // Check if the output buffer is large enough to hold the multicast list
            //
            if (pSPD->PropertyOutputSize < pFilter->ulcbMulticastListEntries)
            {
                TEST_DEBUG (TEST_DBG_GET, ("STREAMIP: GET Multicast buffer too small.  Buffer size needed: %08X\n", pFilter->ulcbMulticastListEntries));
                pSrb->ActualBytesTransferred = pFilter->ulcbMulticastListEntries;
                pSrb->Status = STATUS_MORE_ENTRIES;
                break;
            }

            pMulticastList = (PBYTE) pProperty;
          
            RtlCopyMemory (pMulticastList, pFilter->multicastList, pFilter->ulcbMulticastListEntries);
            TEST_DEBUG (TEST_DBG_GET, ("STREAMIP: GET Multicast property succeeded...Buffer size returned: %08X\n", pFilter->ulcbMulticastListEntries));
            pSrb->ActualBytesTransferred = pFilter->ulcbMulticastListEntries;
            pSrb->Status = STATUS_SUCCESS;

            break;


        case KSPROPERTY_IPSINK_ADAPTER_DESCRIPTION:
            //
            // Check to see if we actually have the data
            //
            if (pFilter->ulAdapterDescriptionLength == 0)
            {
                pSrb->ActualBytesTransferred = 0;
                pSrb->Status = STATUS_UNSUCCESSFUL;
                break;
            }

            //
            // Check if the output buffer is large enough to hold the adapter description string
            //
            if (pSPD->PropertyOutputSize < pFilter->ulAdapterDescriptionLength)
            {
                TEST_DEBUG (TEST_DBG_GET, ("STREAMIP: GET Adapter Description buffer too small.  Buffer size needed: %08X\n", pFilter->ulAdapterDescriptionLength));
                pSrb->ActualBytesTransferred = pFilter->ulAdapterDescriptionLength;
                pSrb->Status = STATUS_MORE_ENTRIES;
                break;
            }

            pDescription = (PBYTE) pProperty;

            if (pFilter->pAdapterDescription == NULL)
            {
                pSrb->ActualBytesTransferred = 0;
                pSrb->Status = STATUS_INVALID_PARAMETER;
                break;
            }
	    
            RtlCopyMemory (pDescription, pFilter->pAdapterDescription, pFilter->ulAdapterDescriptionLength);
            TEST_DEBUG (TEST_DBG_GET, ("STREAMIP: GET Adapter Description property succeeded...Buffer size returned: %08X\n", pFilter->ulAdapterDescriptionLength));
            pSrb->ActualBytesTransferred = pFilter->ulAdapterDescriptionLength;
            pSrb->Status = STATUS_SUCCESS;
            break;


        case KSPROPERTY_IPSINK_ADAPTER_ADDRESS:
            //
            // Check to see if we actually have the data
            //
            if (pFilter->ulAdapterAddressLength == 0)
            {
                pSrb->ActualBytesTransferred = 0;
                pSrb->Status = STATUS_UNSUCCESSFUL;
                break;
            }
     
     	
            //
            // Check if the output buffer is large enough to hold the adapter address string
            //
            if (pSPD->PropertyOutputSize < pFilter->ulAdapterAddressLength)
            {
                TEST_DEBUG (TEST_DBG_GET, ("STREAMIP: GET Adapter Address buffer too small.  Buffer size needed: %08X\n", pFilter->ulAdapterAddressLength));
                pSrb->ActualBytesTransferred = pFilter->ulAdapterAddressLength;
                pSrb->Status = STATUS_MORE_ENTRIES;
                break;
            }


	       if ( pFilter->pAdapterAddress == NULL)
            {
                pSrb->ActualBytesTransferred = 0;
                pSrb->Status = STATUS_INVALID_PARAMETER;
                break;
            }
	       
            pAddress = (PBYTE) pProperty;

            RtlCopyMemory (pAddress, pFilter->pAdapterAddress, pFilter->ulAdapterAddressLength);
            TEST_DEBUG (TEST_DBG_GET, ("STREAMIP: GET Adapter Address property succeeded...Buffer size returned: %08X\n", pFilter->ulAdapterAddressLength));
            pSrb->ActualBytesTransferred = pFilter->ulAdapterAddressLength;
            pSrb->Status = STATUS_SUCCESS;
            break;


        default:
            pSrb->Status = STATUS_NOT_IMPLEMENTED;
            break;
    }

    return;
}


//////////////////////////////////////////////////////////////////////////////
VOID
IPSinkGetProperty (
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;

    pSrb->Status = STATUS_SUCCESS;

    if (IsEqualGUID (&KSPROPSETID_Connection, &pSPD->Property->Set))
    {
        IPSinkGetConnectionProperty (pSrb);
    }
    else if (IsEqualGUID (&KSPROPSETID_Stream, &pSPD->Property->Set))
    {
        IPSinkGetConnectionProperty (pSrb);
    }
    else if (IsEqualGUID (&IID_IBDA_IPSinkControl, &pSPD->Property->Set))
    {
        IPSinkGetCodecProperty (pSrb);
    }
    else
    {
        pSrb->Status = STATUS_NOT_IMPLEMENTED;
    }

    return;
}


//////////////////////////////////////////////////////////////////////////////
VOID
IPSinkSetCodecProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    PSTREAM_PROPERTY_DESCRIPTOR pSPD    = pSrb->CommandData.PropertyInfo;
    ULONG Id                            = pSPD->Property->Id;              // index of the property

    PIPSINK_FILTER pFilter              = (PIPSINK_FILTER)pSrb->HwDeviceExtension;
    PVOID pProperty                     = (PVOID) pSPD->PropertyInfo;

    pSrb->ActualBytesTransferred = 0;

    switch (Id)
    {
        case KSPROPERTY_IPSINK_ADAPTER_ADDRESS:
           
            if (pFilter->pAdapterAddress != NULL)
            {
                ExFreePool (pFilter->pAdapterAddress);
            }

            pFilter->pAdapterAddress = ExAllocatePool(NonPagedPool, pSPD->PropertyOutputSize);
            if (pFilter->pAdapterAddress == NULL)
            {
                pSrb->Status = STATUS_NO_MEMORY;
                break;
            }

           if (pProperty== NULL)
            {
                pSrb->Status = STATUS_INVALID_PARAMETER;
                break;
            }
           pFilter->ulAdapterAddressLength = pSPD->PropertyOutputSize;
           RtlCopyMemory(pFilter->pAdapterAddress, pProperty, pFilter->ulAdapterAddressLength);

            pSrb->Status = STATUS_SUCCESS;

            break;


        default:
            pSrb->Status = STATUS_NOT_IMPLEMENTED;
            break;
    }

    return;
}


//////////////////////////////////////////////////////////////////////////////
VOID
IPSinkSetProperty (
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;

    pSrb->Status = STATUS_SUCCESS;

    if (IsEqualGUID (&IID_IBDA_IPSinkControl, &pSPD->Property->Set))
    {
        IPSinkSetCodecProperty (pSrb);
    }
    else
    {
        pSrb->Status = STATUS_NOT_IMPLEMENTED;
    }

    return;
}



//////////////////////////////////////////////////////////////////////////////
BOOLEAN
LinkEstablished (
    PIPSINK_FILTER pFilter
    )
//////////////////////////////////////////////////////////////////////////////
{
    return (pFilter->NdisLink.flags & LINK_ESTABLISHED);
}


//////////////////////////////////////////////////////////////////////////////
NTSTATUS
LinkToNdisHandler (
    PVOID pvContext
    )
//////////////////////////////////////////////////////////////////////////////
{
    NTSTATUS ntStatus           = STATUS_SUCCESS;
    IPSINK_NDIS_COMMAND Cmd     = {0};
    PIPSINK_FILTER pFilter      = (PIPSINK_FILTER) pvContext;
    UNICODE_STRING DriverName;

    TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: Linking to Ndis....\n"));

    if (   (pFilter->NdisLink.flags & LINK_ESTABLISHED)
        && pFilter->pAdapter
       )
    {
        //  Link already established.
        //
        return ntStatus;
    }

    //
    // Initialize a Unicode string to the NDIS driver's name
    //
    RtlInitUnicodeString(&DriverName, BDA_NDIS_MINIPORT);

    if (OpenLink (&pFilter->NdisLink, DriverName))
    {
        TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: Driver Link Established\n"));

        //
        // Get the NDIS VTable via a read over the link
        //
        Cmd.ulCommandID                    = CMD_QUERY_INTERFACE;
        Cmd.Parameter.Query.pStreamAdapter = (PVOID) pFilter;
        Cmd.Parameter.Query.pNdisAdapter   = NULL;

        ntStatus = SendIOCTL( &pFilter->NdisLink, 
                              IOCTL_GET_INTERFACE, 
                              &Cmd, 
                              sizeof( IPSINK_NDIS_COMMAND)
                              );
        if (!FAILED( ntStatus))
        {
            if (Cmd.Parameter.Query.pNdisAdapter)
            {
                //  Get the adapter object.
                //
                pFilter->pAdapter = (PVOID) Cmd.Parameter.Query.pNdisAdapter;
    
                // Increment the reference count on this object
                //
                //$REVIEW - Shoutn't the IOCTL_GET_INTERFACE return a
                //$REVIEW - reference?
                //
                pFilter->pAdapter->lpVTable->AddRef( pFilter->pAdapter);
            }
            else
            {
                TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: IOCTL_GET_INTERFACE didn't return an adapter.\n"));
                ntStatus = STATUS_UNSUCCESSFUL;
            }

        }
        else
        {
            TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: IOCTL_GET_INTERFACE failed.\n"));
        }
    }
    else
    {
        TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: Link cannot be established\n"));
        ntStatus = STATUS_UNSUCCESSFUL;
    }

    //  Make sure the link is closed on failure.
    //
    if (FAILED( ntStatus))
    {
        CloseLink( &pFilter->NdisLink);
    }


    TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: Driver Link NOT Established\n"));
    return ntStatus;
}

//////////////////////////////////////////////////////////////////////////////
NTSTATUS
StreamDriverInitialize (
    IN PDRIVER_OBJECT    DriverObject,
    IN PUNICODE_STRING   RegistryPath
    )
//////////////////////////////////////////////////////////////////////////////
{
    NTSTATUS ntStatus                        = STATUS_SUCCESS;
    HW_INITIALIZATION_DATA   HwInitData;
    UNICODE_STRING           DeviceNameString;
    UNICODE_STRING           SymbolicNameString;

    RtlZeroMemory(&HwInitData, sizeof(HwInitData));
    HwInitData.HwInitializationDataSize = sizeof(HwInitData);


    ////////////////////////////////////////////////////////////////
    //
    // Setup the stream class dispatch table
    //
    HwInitData.HwInterrupt                 = NULL; // HwInterrupt is only for HW devices

    HwInitData.HwReceivePacket             = CodecReceivePacket;
    HwInitData.HwCancelPacket              = CodecCancelPacket;
    HwInitData.HwRequestTimeoutHandler     = CodecTimeoutPacket;

    HwInitData.DeviceExtensionSize         = sizeof(IPSINK_FILTER);
    HwInitData.PerRequestExtensionSize     = sizeof(SRB_EXTENSION);
    HwInitData.FilterInstanceExtensionSize = 0;
    HwInitData.PerStreamExtensionSize      = sizeof(STREAM);
    HwInitData.BusMasterDMA                = FALSE;
    HwInitData.Dma24BitAddresses           = FALSE;
    HwInitData.BufferAlignment             = 3;
    HwInitData.TurnOffSynchronization      = TRUE;
    HwInitData.DmaBufferSize               = 0;


    ntStatus = StreamClassRegisterAdapter (DriverObject, RegistryPath, &HwInitData);
    if (ntStatus != STATUS_SUCCESS)
    {
        goto ret;
    }

ret:

    return ntStatus;
}


//
//
//////////////////////////////////////////////////////////////////////////////
BOOLEAN
CodecInitialize (
    IN OUT PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    NTSTATUS ntStatus                           = STATUS_SUCCESS;
    BOOLEAN bStatus                             = FALSE;
    PPORT_CONFIGURATION_INFORMATION pConfigInfo = pSrb->CommandData.ConfigInfo;
    PIPSINK_FILTER pFilter                      = (PIPSINK_FILTER) pConfigInfo->HwDeviceExtension;

    //
    // Define the default return codes
    //
    pSrb->Status = STATUS_SUCCESS;
    bStatus = TRUE;

    //
    // Initialize Statistics block
    //
    RtlZeroMemory(&pFilter->Stats, sizeof (STATS));

    //
    // Initialize members
    //
    pFilter->pAdapterDescription = NULL;
    pFilter->ulAdapterDescriptionLength = 0;


    //
    // Check out init flag so we don't try to init more then once.  The Streaming
    // Class driver appears to call the init handler several times for some reason.
    //
    if (pFilter->bInitializationComplete)
    {
        goto ret;
    }

    pFilter->NdisLink.flags = 0;


    if (pConfigInfo->NumberOfAccessRanges == 0)
    {
        pConfigInfo->StreamDescriptorSize = sizeof (HW_STREAM_HEADER) +
            DRIVER_STREAM_COUNT * sizeof (HW_STREAM_INFORMATION);

    }
    else
    {
        pSrb->Status = STATUS_NO_SUCH_DEVICE;
        bStatus = FALSE;
        goto ret;
    }


    //
    // Create a filter object to represent our context
    //
    pSrb->Status = CreateFilter (pConfigInfo->ClassDeviceObject->DriverObject, pConfigInfo->ClassDeviceObject, pFilter);
    if (pSrb->Status != STATUS_SUCCESS)
    {
        bStatus = FALSE;
        goto ret;
    }


    //
    // Start up a timer to poll until the NDIS driver loads
    //
    //IoInitializeTimer (pFilter->DeviceObject, LinkToNdisTimer, pFilter);

    //IoStartTimer (pFilter->DeviceObject);

    pFilter->bInitializationComplete = TRUE;

ret:

    return (bStatus);
}


//////////////////////////////////////////////////////////////////////////////
BOOLEAN
CodecUnInitialize (
    IN OUT PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    NTSTATUS ntStatus                           = STATUS_SUCCESS;
    BOOLEAN bStatus                             = FALSE;
    PPORT_CONFIGURATION_INFORMATION pConfigInfo = pSrb->CommandData.ConfigInfo;
    PIPSINK_FILTER pFilter                      = ((PIPSINK_FILTER)pSrb->HwDeviceExtension);
    PSTREAM pStream                             = NULL;
    KIRQL    Irql;

    //
    // Close our link to the NDIS component
    //
    KeAcquireSpinLock (&pFilter->AdapterSRBSpinLock, &Irql);

    //
    // Call adapter close link to give the adapter a chance to release its
    // reference to the filter
    //
    if (pFilter->pAdapter)
    {
        if (pFilter->pAdapter->lpVTable->CloseLink)
        {
            pFilter->pAdapter->lpVTable->CloseLink( pFilter->pAdapter);
        }

        pFilter->pAdapter = NULL;
    }

    //  Free the IP Sink NDIS Adapter's description
    //
    if (pFilter->pAdapterDescription)
    {
        ExFreePool( pFilter->pAdapterDescription);
        pFilter->pAdapterDescription = NULL;
        pFilter->ulAdapterDescriptionLength = 0;
    }

     if (pFilter->pAdapterAddress != NULL)
    {
         ExFreePool (pFilter->pAdapterAddress);
         pFilter->pAdapterAddress = NULL;
         
     }	
    KeReleaseSpinLock (&pFilter->AdapterSRBSpinLock, Irql);

    //  The call to CloseLink can only be made at PASSIVE_LEVEL and
    //  therefore must be outside the spinlock.
    //
    CloseLink( &pFilter->NdisLink);


    if (pSrb->StreamObject != NULL)
    {
        pStream = (PSTREAM)pSrb->StreamObject->HwStreamExtension;
    }

    if (pStream)
    {
        //
        // Clean up any queues we have and complete any outstanding SRB's
        //
        while (QueueRemove (&pSrb, &pStream->StreamDataSpinLock, &pStream->StreamDataQueue))
        {
            pSrb->Status = STATUS_CANCELLED;
            StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb );
        }


        while (QueueRemove (&pSrb, &pStream->StreamControlSpinLock, &pStream->StreamControlQueue))
        {
            pSrb->Status = STATUS_CANCELLED;
            StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb);
        }

    }

    while (QueueRemove (&pSrb, &pFilter->AdapterSRBSpinLock, &pFilter->AdapterSRBQueue))
    {
        pSrb->Status = STATUS_CANCELLED;
        StreamClassDeviceNotification (DeviceRequestComplete, pSrb->StreamObject, pSrb);
    }


    bStatus = TRUE;

    return (bStatus);
}


//////////////////////////////////////////////////////////////////////////////
VOID
CodecStreamInfo (
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    int j;

    PIPSINK_FILTER pFilter =
            ((PIPSINK_FILTER)pSrb->HwDeviceExtension);

    //
    // pick up the pointer to header which preceeds the stream info structs
    //
    PHW_STREAM_HEADER pstrhdr =
            (PHW_STREAM_HEADER)&(pSrb->CommandData.StreamBuffer->StreamHeader);

    //
    // pick up the pointer to the array of stream information data structures
    //
    PHW_STREAM_INFORMATION pstrinfo =
            (PHW_STREAM_INFORMATION)&(pSrb->CommandData.StreamBuffer->StreamInfo);


    //
    // Set the header
    //
    StreamHeader.NumDevPropArrayEntries = NUMBER_IPSINK_CODEC_PROPERTIES;
    StreamHeader.DevicePropertiesArray = (PKSPROPERTY_SET) IPSinkCodecProperties;

    //
    // Set events array
    //
    StreamHeader.NumDevEventArrayEntries = NUMBER_IPSINK_EVENTS;
    StreamHeader.DeviceEventsArray       = (PKSEVENT_SET) IPSinkEvents;

    *pstrhdr = StreamHeader;

    //
    // stuff the contents of each HW_STREAM_INFORMATION struct
    //
    for (j = 0; j < DRIVER_STREAM_COUNT; j++)
    {
       *pstrinfo++ = Streams[j].hwStreamInfo;
    }

    pSrb->Status = STATUS_SUCCESS;

}


//////////////////////////////////////////////////////////////////////////////
VOID
STREAMAPI
CodecCancelPacket(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    PSTREAM  pStream = (PSTREAM)pSrb->StreamObject->HwStreamExtension;
    PIPSINK_FILTER  pFilter = ((PIPSINK_FILTER)pSrb->HwDeviceExtension);

    //
    // Check whether the SRB to cancel is in use by this stream
    //

    TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: CancelPacket Called\n"));

    if (QueueRemoveSpecific (pSrb, &pStream->StreamDataSpinLock, &pStream->StreamDataQueue))
    {
        pSrb->Status = STATUS_CANCELLED;
        StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb );
        return;
    }


    if (QueueRemoveSpecific (pSrb, &pStream->StreamControlSpinLock, &pStream->StreamControlQueue))
    {
        pSrb->Status = STATUS_CANCELLED;
        StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb);
        return;
    }

    if (QueueRemoveSpecific (pSrb, &pFilter->AdapterSRBSpinLock, &pFilter->AdapterSRBQueue))
    {
        pSrb->Status = STATUS_CANCELLED;
        StreamClassDeviceNotification (DeviceRequestComplete, pSrb->StreamObject, pSrb);
        return;
    }

    return;
}


//////////////////////////////////////////////////////////////////////////////
VOID
STREAMAPI
CodecTimeoutPacket(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    //
    // if we timeout while playing, then we need to consider this
    // condition an error, and reset the hardware, and reset everything
    // as well as cancelling this and all requests
    //

    //
    // if we are not playing, and this is a CTRL request, we still
    // need to reset everything as well as cancelling this and all requests
    //

    //
    // if this is a data request, and the device is paused, we probably have
    // run out of data buffer, and need more time, so just reset the timer,
    // and let the packet continue
    //

    TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: TimeoutPacket Called\n"));

    pSrb->TimeoutCounter = 0;

    return;
}


//////////////////////////////////////////////////////////////////////////////
VOID
STREAMAPI
CodecReceivePacket(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    PIPSINK_FILTER pFilter = ((PIPSINK_FILTER)pSrb->HwDeviceExtension);
    IPSINK_NDIS_COMMAND  Cmd       = {0};


    //
    // Make sure queue & SL initted
    //
    if (!pFilter->bAdapterQueueInitialized)
    {
        InitializeListHead (&pFilter->AdapterSRBQueue);
        KeInitializeSpinLock (&pFilter->AdapterSRBSpinLock);
        KeInitializeSpinLock (&pFilter->NdisLink.spinLock);
        pFilter->bAdapterQueueInitialized = TRUE;
    }

    //
    // Assume success
    //
    pSrb->Status = STATUS_SUCCESS;

    //
    // determine the type of packet.
    //
    //if (QueueAddIfNotEmpty (pSrb, &pFilter->AdapterSRBSpinLock, &pFilter->AdapterSRBQueue))
    //{
    //    pSrb->Status = STATUS_SUCCESS;
    //    return;
    //}
    QueueAdd (pSrb, &pFilter->AdapterSRBSpinLock, &pFilter->AdapterSRBQueue);


    while (QueueRemove( &pSrb, &pFilter->AdapterSRBSpinLock, &pFilter->AdapterSRBQueue ))
    {
        switch (pSrb->Command)
        {

            case SRB_INITIALIZE_DEVICE:
                TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: SRB_INITIALIZE Command\n"));
                CodecInitialize(pSrb);
                break;

            case SRB_UNINITIALIZE_DEVICE:
                TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: SRB_UNINITIALIZE Command\n"));
                CodecUnInitialize(pSrb);
                break;

            case SRB_INITIALIZATION_COMPLETE:
                TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: SRB_INITIALIZE_COMPLETE Command\n"));
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
                break;

            case SRB_OPEN_STREAM:
                TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: SRB_OPEN_STREAM Command\n"));

                if (LinkToNdisHandler ((PVOID) pFilter) != STATUS_SUCCESS)
                {
                    pSrb->Status = STATUS_UNSUCCESSFUL;
                    break;
                }

                //
                // Get the Adapter description string.  This is used to determine the
                // adapter NIC address
                //
                GetAdapterDescription (pFilter);

                //
                // Open up the stream and connect
                //
                OpenStream (pSrb);
                break;

            case SRB_CLOSE_STREAM:
                TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: SRB_CLOSE_STREAM Command\n"));
                CloseStream (pSrb);
                break;

            case SRB_GET_STREAM_INFO:
                TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: SRB_GET_STREAM_INFO Command\n"));
                CodecStreamInfo (pSrb);
                break;

            case SRB_GET_DATA_INTERSECTION:
                TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: SRB_GET_DATA_INTERSECTION Command\n"));

                //
                // Compare our stream formats.  NOTE, the compare functions sets the SRB
                // status fields
                //
                CompareStreamFormat (pSrb);
                break;

            case SRB_OPEN_DEVICE_INSTANCE:
                TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: SRB_OPEN_DEVICE_INSTANCE Command\n"));
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
                break;

            case SRB_CLOSE_DEVICE_INSTANCE:
                TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: SRB_CLOSE_DEVICE_INSTANCE Command\n"));
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
                break;

            case SRB_UNKNOWN_DEVICE_COMMAND:
                TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: SRB_UNKNOWN_DEVICE Command\n"));
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
                break;

            case SRB_CHANGE_POWER_STATE:
                TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: SRB_CHANGE_POWER_STATE Command\n"));
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
                break;

            case SRB_GET_DEVICE_PROPERTY:
                TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: SRB_GET_DEVICE_PROPERTY Command\n"));
                IPSinkGetProperty(pSrb);
                break;

            case SRB_SET_DEVICE_PROPERTY:
                TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: SRB_SET_DEVICE_PROPERTY Command\n"));
                IPSinkSetProperty(pSrb);
                break;

            case SRB_UNKNOWN_STREAM_COMMAND:
                TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: SRB_UNKNOWN Command\n"));
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
                break;

            default:
                TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: SRB_DEFAULT Command\n"));
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
                break;

        };


        //
        // NOTE:
        //
        // All of the commands that we do, or do not understand can all be completed
        // syncronously at this point, so we can use a common callback routine here.
        // If any of the above commands require asyncronous processing, this will
        // have to change
        //

       StreamClassDeviceNotification (DeviceRequestComplete, pFilter, pSrb);

    } // while (QueueRemove( &pSrb, &pFilter->AdapterSRBSpinLock, &pFilter->AdapterSRBQueue ));

}


//////////////////////////////////////////////////////////////////////////////
BOOL STREAMAPI
QueueAdd (
    IN PHW_STREAM_REQUEST_BLOCK pSrb,
    IN PKSPIN_LOCK pQueueSpinLock,
    IN PLIST_ENTRY pQueue
    )
//////////////////////////////////////////////////////////////////////////////
{
    KIRQL           Irql;
    PSRB_EXTENSION  pSrbExtension;

    pSrbExtension = ( PSRB_EXTENSION )pSrb->SRBExtension;

    KeAcquireSpinLock( pQueueSpinLock, &Irql );

    pSrbExtension->pSrb = pSrb;
    InsertTailList( pQueue, &pSrbExtension->ListEntry );

    KeReleaseSpinLock( pQueueSpinLock, Irql );

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
BOOL STREAMAPI
QueueAddIfNotEmpty (
    IN PHW_STREAM_REQUEST_BLOCK pSrb,
    IN PKSPIN_LOCK pQueueSpinLock,
    IN PLIST_ENTRY pQueue
    )
//////////////////////////////////////////////////////////////////////////////
{
   KIRQL           Irql;
   PSRB_EXTENSION  pSrbExtension;
   BOOL            bAddedSRB = FALSE;

   pSrbExtension = ( PSRB_EXTENSION )pSrb->SRBExtension;

   KeAcquireSpinLock( pQueueSpinLock, &Irql );

   if( !IsListEmpty( pQueue ))
   {
       pSrbExtension->pSrb = pSrb;
       InsertTailList (pQueue, &pSrbExtension->ListEntry );
       bAddedSRB = TRUE;
   }

   KeReleaseSpinLock( pQueueSpinLock, Irql );

   return bAddedSRB;
}

//////////////////////////////////////////////////////////////////////////////
BOOL STREAMAPI
QueueRemove (
    IN OUT PHW_STREAM_REQUEST_BLOCK * pSrb,
    IN PKSPIN_LOCK pQueueSpinLock,
    IN PLIST_ENTRY pQueue
    )
//////////////////////////////////////////////////////////////////////////////
{
   KIRQL    Irql;
   BOOL     bRemovedSRB = FALSE;

   KeAcquireSpinLock (pQueueSpinLock, &Irql);

   *pSrb =  (PHW_STREAM_REQUEST_BLOCK) NULL;

   if( !IsListEmpty( pQueue ))
   {
       PHW_STREAM_REQUEST_BLOCK *pCurrentSrb = NULL;
       PUCHAR Ptr                            = (PUCHAR) RemoveHeadList(pQueue);

       pCurrentSrb = (PHW_STREAM_REQUEST_BLOCK *) (((PUCHAR)Ptr) + sizeof (LIST_ENTRY));

       *pSrb = *pCurrentSrb;
       bRemovedSRB = TRUE;

   }

   KeReleaseSpinLock (pQueueSpinLock, Irql);

   return bRemovedSRB;
}

//////////////////////////////////////////////////////////////////////////////
BOOL STREAMAPI
QueueRemoveSpecific (
    IN PHW_STREAM_REQUEST_BLOCK pSrb,
    IN PKSPIN_LOCK pQueueSpinLock,
    IN PLIST_ENTRY pQueue
    )
//////////////////////////////////////////////////////////////////////////////
{
   KIRQL Irql;
   BOOL  bRemovedSRB = FALSE;
   PLIST_ENTRY pCurrentEntry;
   PHW_STREAM_REQUEST_BLOCK * pCurrentSrb;

   KeAcquireSpinLock( pQueueSpinLock, &Irql );

   if( !IsListEmpty( pQueue ))
   {
       pCurrentEntry = pQueue->Flink;
       while ((pCurrentEntry != pQueue ) && !bRemovedSRB)
       {
           pCurrentSrb = (PHW_STREAM_REQUEST_BLOCK * ) ((( PUCHAR )pCurrentEntry ) + sizeof( LIST_ENTRY ));

           if( *pCurrentSrb == pSrb )
           {
               RemoveEntryList( pCurrentEntry );
               bRemovedSRB = TRUE;
           }
           pCurrentEntry = pCurrentEntry->Flink;
       }
   }
   KeReleaseSpinLock( pQueueSpinLock, Irql );

   return bRemovedSRB;
}

//////////////////////////////////////////////////////////////////////////////
NTSTATUS
StreamIPIndicateEvent (
    PVOID pvEvent
)
//////////////////////////////////////////////////////////////////////////////
{
    return STATUS_NOT_IMPLEMENTED;
}



//////////////////////////////////////////////////////////////////////////////
BOOL
CompareGUIDsAndFormatSize(
    IN PKSDATARANGE pDataRange1,
    IN PKSDATARANGE pDataRange2,
    BOOLEAN bCheckSize
    )
//////////////////////////////////////////////////////////////////////////////
{
    BOOL bResult = FALSE;

    if ( IsEqualGUID(&pDataRange1->MajorFormat, &KSDATAFORMAT_TYPE_WILDCARD) ||
         IsEqualGUID(&pDataRange2->MajorFormat, &KSDATAFORMAT_TYPE_WILDCARD) ||
         IsEqualGUID(&pDataRange1->MajorFormat, &pDataRange2->MajorFormat) )
    {

        if ( IsEqualGUID(&pDataRange1->SubFormat, &KSDATAFORMAT_SUBTYPE_WILDCARD) ||
             IsEqualGUID(&pDataRange2->SubFormat, &KSDATAFORMAT_SUBTYPE_WILDCARD) ||
             IsEqualGUID(&pDataRange1->SubFormat, &pDataRange2->SubFormat) )
        {

            if ( IsEqualGUID(&pDataRange1->Specifier, &KSDATAFORMAT_SPECIFIER_WILDCARD) ||
                 IsEqualGUID(&pDataRange2->Specifier, &KSDATAFORMAT_SPECIFIER_WILDCARD) ||
                 IsEqualGUID(&pDataRange1->Specifier, &pDataRange2->Specifier) )
            {
                if ( !bCheckSize || pDataRange1->FormatSize == pDataRange2->FormatSize)
                {
                    bResult = TRUE;
                }
            }
        }
    }

    return bResult;

}

//////////////////////////////////////////////////////////////////////////////
VOID
DumpDataFormat (
    PKSDATAFORMAT   pF
    )
//////////////////////////////////////////////////////////////////////////////
{
    TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: DATA Format\n"));
    TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP:     Format Size:   %08X\n", pF->FormatSize));
    TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP:     Flags:         %08X\n", pF->Flags));
    TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP:     SampleSize:    %08X\n", pF->SampleSize));
    TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP:     Reserved:      %08X\n", pF->Reserved));



    TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP:     Major GUID:  %08X %04X %04X %02X %02X %02X %02X %02X %02X %02X %02X\n",
                                                pF->MajorFormat.Data1,
                                                pF->MajorFormat.Data2,
                                                pF->MajorFormat.Data3,
                                                pF->MajorFormat.Data4[0],
                                                pF->MajorFormat.Data4[1],
                                                pF->MajorFormat.Data4[2],
                                                pF->MajorFormat.Data4[3],
                                                pF->MajorFormat.Data4[4],
                                                pF->MajorFormat.Data4[5],
                                                pF->MajorFormat.Data4[6],
                                                pF->MajorFormat.Data4[7]
                                ));

    TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP:     Sub GUID:    %08X %04X %04X %02X %02X %02X %02X %02X %02X %02X %02X\n",
                                                pF->SubFormat.Data1,
                                                pF->SubFormat.Data2,
                                                pF->SubFormat.Data3,
                                                pF->SubFormat.Data4[0],
                                                pF->SubFormat.Data4[1],
                                                pF->SubFormat.Data4[2],
                                                pF->SubFormat.Data4[3],
                                                pF->SubFormat.Data4[4],
                                                pF->SubFormat.Data4[5],
                                                pF->SubFormat.Data4[6],
                                                pF->SubFormat.Data4[7]
                                ));

    TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP:     Specifier:   %08X %04X %04X %02X %02X %02X %02X %02X %02X %02X %02X\n",
                                                pF->Specifier.Data1,
                                                pF->Specifier.Data2,
                                                pF->Specifier.Data3,
                                                pF->Specifier.Data4[0],
                                                pF->Specifier.Data4[1],
                                                pF->Specifier.Data4[2],
                                                pF->Specifier.Data4[3],
                                                pF->Specifier.Data4[4],
                                                pF->Specifier.Data4[5],
                                                pF->Specifier.Data4[6],
                                                pF->Specifier.Data4[7]
                                ));

    TEST_DEBUG (TEST_DBG_TRACE, ("\n"));
}


//////////////////////////////////////////////////////////////////////////////
BOOL
CompareStreamFormat (
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    BOOL                        bStatus = FALSE;
    PSTREAM_DATA_INTERSECT_INFO pIntersectInfo;
    PKSDATARANGE                pDataRange1;
    PKSDATARANGE                pDataRange2;
    ULONG                       FormatSize = 0;
    ULONG                       ulStreamNumber;
    ULONG                       j;
    ULONG                       ulNumberOfFormatArrayEntries;
    PKSDATAFORMAT               *pAvailableFormats;


    pIntersectInfo = pSrb->CommandData.IntersectInfo;
    ulStreamNumber = pIntersectInfo->StreamNumber;


    pSrb->ActualBytesTransferred = 0;


    TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: Comparing Stream Formats\n"));


    //
    // Check that the stream number is valid
    //
    if (ulStreamNumber < DRIVER_STREAM_COUNT)
    {
        ulNumberOfFormatArrayEntries = Streams[ulStreamNumber].hwStreamInfo.NumberOfFormatArrayEntries;

        //
        // Get the pointer to the array of available formats
        //
        pAvailableFormats = Streams[ulStreamNumber].hwStreamInfo.StreamFormatsArray;

        //
        // Walk the formats supported by the stream searching for a match
        // of the three GUIDs which together define a DATARANGE
        //
        for (pDataRange1 = pIntersectInfo->DataRange, j = 0;
             j < ulNumberOfFormatArrayEntries;
             j++, pAvailableFormats++)

        {
            bStatus = FALSE;
            pSrb->Status = STATUS_UNSUCCESSFUL;

            pDataRange2 = *pAvailableFormats;

            if (CompareGUIDsAndFormatSize (pDataRange1, pDataRange2, TRUE))
            {

                ULONG   ulFormatSize = pDataRange2->FormatSize;

                TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: Stream Formats compare\n"));

                //
                // Is the caller trying to get the format, or the size of the format?
                //
                if (pIntersectInfo->SizeOfDataFormatBuffer == sizeof (ULONG))
                {
                    TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: Returning Stream Format size\n"));

                    *(PULONG) pIntersectInfo->DataFormatBuffer = ulFormatSize;
                    pSrb->ActualBytesTransferred = sizeof (ULONG);
                    pSrb->Status = STATUS_SUCCESS;
                    bStatus = TRUE;
                }
                else
                {
                    //
                    // Verify that there is enough room in the supplied buffer for the whole thing
                    //
                    pSrb->Status = STATUS_BUFFER_TOO_SMALL;
                    bStatus = FALSE;

                    if (pIntersectInfo->SizeOfDataFormatBuffer >= ulFormatSize)
                    {
                        TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: Returning Stream Format\n"));
			
                        RtlCopyMemory (pIntersectInfo->DataFormatBuffer, pDataRange2, ulFormatSize);
                        pSrb->ActualBytesTransferred = ulFormatSize;
                        pSrb->Status = STATUS_SUCCESS;
                        bStatus = TRUE;
                    }
                    else
                    {
                        TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: Stream Format return buffer too small\n"));
                    }
                }
                break;
            }
            else
            {
                TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: Stream Formats DO NOT compare\n"));
            }
        }

        if ( j >= ulNumberOfFormatArrayEntries )
        {
            pSrb->ActualBytesTransferred = 0;
            pSrb->Status = STATUS_UNSUCCESSFUL;
            bStatus = FALSE;
        }

    }
    else
    {
        pSrb->ActualBytesTransferred = 0;
        pSrb->Status = STATUS_NOT_IMPLEMENTED;
        bStatus = FALSE;
    }

    return bStatus;
}


//////////////////////////////////////////////////////////////////////////////
VOID
CloseStream (
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    //
    // the stream extension structure is allocated by the stream class driver
    //
    PSTREAM         pStream                = (PSTREAM)pSrb->StreamObject->HwStreamExtension;
    PIPSINK_FILTER  pFilter                = (PIPSINK_FILTER)pSrb->HwDeviceExtension;
    ULONG           ulStreamNumber         = (ULONG) pSrb->StreamObject->StreamNumber;
    ULONG           ulStreamInstance       = pStream->ulStreamInstance;
    PHW_STREAM_REQUEST_BLOCK pCurrentSrb   = NULL;
    KIRQL    Irql;
    PLINK           pLink = NULL;

    //
    // Close our link to the NDIS component
    //
    KeAcquireSpinLock (&pFilter->AdapterSRBSpinLock, &Irql);

    //
    // Call adapter close link to give the adapter a chance to release its
    // reference to the filter
    //
    if (pFilter->pAdapter)
    {
        if (pFilter->pAdapter->lpVTable->CloseLink)
        {
            pFilter->pAdapter->lpVTable->CloseLink (pFilter->pAdapter);
        }

        pFilter->pAdapter = NULL;
    }

    pFilter->pAdapter = NULL;

    KeReleaseSpinLock (&pFilter->AdapterSRBSpinLock, Irql);

    //  The call to CloseLink can only be made at PASSIVE_LEVEL
    //  and thus is moved outside the spin lock
    //
    CloseLink (&pFilter->NdisLink);

    //
    // check that the stream index requested isn't too high
    // or that the maximum number of instances hasn't been exceeded
    //
    if (ulStreamNumber < DRIVER_STREAM_COUNT )
    {
        //
        // Clear this streams spot in the filters stream array
        //
        pFilter->pStream[ulStreamNumber][ulStreamInstance] = NULL;

        //
        // decrement the stream instance count for this filter
        //
        pFilter->ulActualInstances[ulStreamNumber]--;

        //
        // Flush the stream data queue
        //
        while (QueueRemove( &pCurrentSrb, &pStream->StreamDataSpinLock, &pStream->StreamDataQueue))
        {
           pCurrentSrb->Status = STATUS_CANCELLED;
           StreamClassStreamNotification( StreamRequestComplete, pCurrentSrb->StreamObject, pCurrentSrb);
        }

        //
        // Flush the stream control queue
        //
        while (QueueRemove( &pCurrentSrb, &pStream->StreamControlSpinLock, &pStream->StreamControlQueue))
        {
           pCurrentSrb->Status = STATUS_CANCELLED;
           StreamClassStreamNotification (StreamRequestComplete, pCurrentSrb->StreamObject, pCurrentSrb);
        }

        //
        // reset pointers to the handlers for the stream data and control handlers
        //
        pSrb->StreamObject->ReceiveDataPacket    = NULL;
        pSrb->StreamObject->ReceiveControlPacket = NULL;

        //
        // The DMA flag must be set when the device will be performing DMA directly
        // to the data buffer addresses passed in to the ReceiveDataPacket routines.
        //
        pSrb->StreamObject->Dma = 0;

        //
        // The PIO flag must be set when the mini driver will be accessing the data
        // buffers passed in using logical addressing
        //
        pSrb->StreamObject->Pio       = 0;
        pSrb->StreamObject->Allocator = 0;

        //
        // How many extra bytes will be passed up from the driver for each frame?
        //
        pSrb->StreamObject->StreamHeaderMediaSpecific = 0;
        pSrb->StreamObject->StreamHeaderWorkspace     = 0;

        //
        // Indicate the clock support available on this stream
        //
        //pSrb->StreamObject->HwClockObject = 0;

        //
        // Reset the stream state to stopped
        //
        pStream->KSState = KSSTATE_STOP;

        //
        // Reset the stream extension blob
        //
        RtlZeroMemory(pStream, sizeof (STREAM));

        pSrb->Status = STATUS_SUCCESS;

    }
    else
    {
        pSrb->Status = STATUS_INVALID_PARAMETER;
    }

    #ifdef DEBUG

    DumpSRBTable ();

    #endif // DEBUG
}


//////////////////////////////////////////////////////////////////////////////
VOID
OpenStream (
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    //
    // the stream extension structure is allocated by the stream class driver
    //
    PSTREAM         pStream        = (PSTREAM)pSrb->StreamObject->HwStreamExtension;
    PIPSINK_FILTER  pFilter        = ((PIPSINK_FILTER)pSrb->HwDeviceExtension);
    ULONG           ulStreamNumber = (ULONG) pSrb->StreamObject->StreamNumber;
    PKSDATAFORMAT   pKSDataFormat  = (PKSDATAFORMAT)pSrb->CommandData.OpenFormat;

    //
    // Initialize the stream extension blob
    //
    RtlZeroMemory(pStream, sizeof (STREAM));

    //
    // Initialize stream state
    //
    pStream->KSState = KSSTATE_STOP;

    //
    // check that the stream index requested isn't too high
    // or that the maximum number of instances hasn't been exceeded
    //
    if (ulStreamNumber < DRIVER_STREAM_COUNT )
    {
        ULONG ulStreamInstance;
        ULONG ulMaxInstances = Streams[ulStreamNumber].hwStreamInfo.NumberOfPossibleInstances;

        //
        // Search for next open slot
        //
        for (ulStreamInstance = 0; ulStreamInstance < ulMaxInstances; ++ulStreamInstance)
        {
            if (pFilter->pStream[ulStreamNumber][ulStreamInstance] == NULL)
            {
                break;
            }
        }

        if (ulStreamInstance < ulMaxInstances)
        {
            if (VerifyFormat(pKSDataFormat, ulStreamNumber, &pStream->MatchedFormat))
            {
                InitializeListHead(&pStream->StreamControlQueue);
                InitializeListHead(&pStream->StreamDataQueue);
                KeInitializeSpinLock(&pStream->StreamControlSpinLock);
                KeInitializeSpinLock(&pStream->StreamDataSpinLock);

                //
                // Maintain an array of all the StreamEx structures in the HwDevExt
                // so that we can reference IRPs from any stream
                //
                pFilter->pStream[ulStreamNumber][ulStreamInstance] = pStream;

                //
                // Save the Stream Format in the Stream Extension as well.
                //
                pStream->OpenedFormat = *pKSDataFormat;


                //
                // Set up pointers to the handlers for the stream data and control handlers
                //
                pSrb->StreamObject->ReceiveDataPacket =
                                                (PVOID) Streams[ulStreamNumber].hwStreamObject.ReceiveDataPacket;
                pSrb->StreamObject->ReceiveControlPacket =
                                                (PVOID) Streams[ulStreamNumber].hwStreamObject.ReceiveControlPacket;

                //
                // The DMA flag must be set when the device will be performing DMA directly
                // to the data buffer addresses passed in to the ReceiveDataPacket routines.
                //
                pSrb->StreamObject->Dma = Streams[ulStreamNumber].hwStreamObject.Dma;

                //
                // The PIO flag must be set when the mini driver will be accessing the data
                // buffers passed in using logical addressing
                //
                pSrb->StreamObject->Pio = Streams[ulStreamNumber].hwStreamObject.Pio;

                pSrb->StreamObject->Allocator = Streams[ulStreamNumber].hwStreamObject.Allocator;

                //
                // How many extra bytes will be passed up from the driver for each frame?
                //
                pSrb->StreamObject->StreamHeaderMediaSpecific =
                                        Streams[ulStreamNumber].hwStreamObject.StreamHeaderMediaSpecific;

                pSrb->StreamObject->StreamHeaderWorkspace =
                                        Streams[ulStreamNumber].hwStreamObject.StreamHeaderWorkspace;

                //
                // Indicate the clock support available on this stream
                //
                pSrb->StreamObject->HwClockObject =
                                        Streams[ulStreamNumber].hwStreamObject.HwClockObject;

                //
                // Increment the instance count on this stream
                //
                pStream->ulStreamInstance = ulStreamInstance;
                pFilter->ulActualInstances[ulStreamNumber]++;


                //
                // Retain a private copy of the HwDevExt and StreamObject in the stream extension
                // so we can use a timer
                //
                pStream->pFilter = pFilter;                     // For timer use
                pStream->pStreamObject = pSrb->StreamObject;        // For timer use


                pSrb->Status = STATUS_SUCCESS;

            }
            else
            {
                pSrb->Status = STATUS_INVALID_PARAMETER;
            }
        }
        else
        {
            pSrb->Status = STATUS_INVALID_PARAMETER;
        }

    }
    else
    {
        pSrb->Status = STATUS_INVALID_PARAMETER;
    }
}


//////////////////////////////////////////////////////////////////////////////
BOOLEAN
VerifyFormat(
    IN KSDATAFORMAT *pKSDataFormat,
    UINT StreamNumber,
    PKSDATARANGE pMatchedFormat
    )
//////////////////////////////////////////////////////////////////////////////
{
    BOOLEAN   bResult               = FALSE;
    ULONG     FormatCount           = 0;
    PKS_DATARANGE_VIDEO pThisFormat = NULL;

    TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: Verify Format\n"));

    for (FormatCount = 0; !bResult && FormatCount < Streams[StreamNumber].hwStreamInfo.NumberOfFormatArrayEntries;
        FormatCount++ )
    {


        pThisFormat = (PKS_DATARANGE_VIDEO) Streams [StreamNumber].hwStreamInfo.StreamFormatsArray [FormatCount];

        if (CompareGUIDsAndFormatSize( pKSDataFormat, &pThisFormat->DataRange, TRUE ) )
        {
            bResult = TRUE;
        }
    }

    if (bResult == TRUE && pMatchedFormat)
    {
        *pMatchedFormat = pThisFormat->DataRange;
    }

    return bResult;
}



//////////////////////////////////////////////////////////////////////////////
NTSTATUS
STREAMAPI
EventHandler (
    IN PHW_EVENT_DESCRIPTOR pEventDesriptor
    )
//////////////////////////////////////////////////////////////////////////////
{

    TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: EventHandler called\n"));

    return STATUS_NOT_IMPLEMENTED;
}


//////////////////////////////////////////////////////////////////////////////
VOID
STREAMAPI
ReceiveDataPacket (
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    ULONG             ulBuffers  = pSrb->NumberOfBuffers;
    PIPSINK_FILTER    pFilter    = (PIPSINK_FILTER) pSrb->HwDeviceExtension;
    PSTREAM           pStream    = (PSTREAM)pSrb->StreamObject->HwStreamExtension;
    int               iStream    = (int) pSrb->StreamObject->StreamNumber;
    PKSSTREAM_HEADER  pStreamHdr = pSrb->CommandData.DataBufferArray;
    ULONG             ul         = 0;

 

    TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: Receive Data packet handler called\n"));

    //
    // Default to success, disable timeouts
    //
    pSrb->Status = STATUS_SUCCESS;

    //
    // Check for last buffer
    //
    if (pStreamHdr->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_ENDOFSTREAM)
    {
        TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: Receive Data packet is LAST PACKET\n"));

        StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb);


        if (pFilter->pAdapter)
        {
            if (pFilter->pAdapter->lpVTable->IndicateReset)
            {
                pFilter->pAdapter->lpVTable->IndicateReset (pFilter->pAdapter);
            }
        }

        return;
    }


    //
    // determine the type of packet.
    //
    switch (pSrb->Command)
    {
        case SRB_WRITE_DATA:

            TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: Receive Data packet handler - SRB_WRITE_DATA, pSrb: %08X\n", pSrb));

            if (pStream->KSState == KSSTATE_STOP)
            //if ((pStream->KSState == KSSTATE_STOP) || (pStream->KSState == KSSTATE_PAUSE))
            {
                StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb );
                TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: StreamRequestComplete on pSrb: %08X\n", pSrb));

                break;
            }

            //
            // Update the total number of packets written statistic
            //
            pFilter->Stats.ulTotalPacketsWritten += 1;


            //
            // Handle data input, output requests differently.
            //
            switch (iStream)
            {
                //
                //  Frame input stream
                //
                case STREAM_IP:
                {
                    QueueAdd (pSrb, &pStream->StreamDataSpinLock, &pStream->StreamDataQueue);

                    while (QueueRemove( &pSrb, &pStream->StreamDataSpinLock,&pStream->StreamDataQueue ))

                    {
                        #ifdef DEBUG

                        DbgPrint ("SIW: S:%08X B:%08X\n", pSrb, pStreamHdr->Data);

                        #endif

                        TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: Processing pSrb: %08X\n", pSrb));

			  ulBuffers  = pSrb->NumberOfBuffers;
			  pStreamHdr = pSrb->CommandData.DataBufferArray;
    
                        for (ul = 0; ul < ulBuffers; ul++, pStreamHdr++)
                        {
                            //
                            // If Data Used is 0 then don't bother sending the packet
                            // to NdisIp.
                            //

                            if(pStreamHdr->DataUsed)
                            {
                                //
                                // Update stats for IP Stream count
                                //
                                pFilter->Stats.ulTotalStreamIPPacketsWritten += 1;
                                pFilter->Stats.ulTotalStreamIPBytesWritten   += pStreamHdr->DataUsed;
                                pFilter->Stats.ulTotalStreamIPFrameBytesWritten   += pStreamHdr->FrameExtent;
    
                                if (pFilter->pAdapter)
                                {
                                    if (pFilter->pAdapter->lpVTable->IndicateData)
                                    {
                                        pSrb->Status = pFilter->pAdapter->lpVTable->IndicateData (
                                                           pFilter->pAdapter,
                                                           pStreamHdr->Data,
                                                           pStreamHdr->DataUsed
                                                           );
    
                                        if (pSrb->Status != STATUS_SUCCESS)
                                        {
                                            TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: IndicateData returned ERROR %08X\n", pSrb->Status));
    
                                            pSrb->Status = STATUS_SUCCESS;
                                        }
                                    }
                                }
                            }
                            else
                            {
                                pSrb->Status = STATUS_SUCCESS;
                            }
                        }

                        StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb);
                        TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: StreamRequestComplete on pSrb: %08X\n", pSrb));
                    }
                }
                break;

                //
                // Other "unknown" streams are not valid and will be rejected.
                //
                case STREAM_NET_CONTROL:
                    TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: Receive Data packet handler called - SRB_WRITE - STREAM_NET_CONTROL\n"));
                    pSrb->Status = STATUS_NOT_IMPLEMENTED;

                    //
                    // Update stats for Net packet count
                    //
                    pFilter->Stats.ulTotalNetPacketsWritten += 1;

                    StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb);
                    TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: StreamRequestComplete on pSrb: %08X\n", pSrb));
                    break;

                default:
                    TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: Receive Data packet handler called - SRB_WRITE - Default\n"));
                    pSrb->Status = STATUS_NOT_IMPLEMENTED;

                    //
                    // Update stats for Unkown packet count
                    //
                    pFilter->Stats.ulTotalUnknownPacketsWritten += 1;

                    StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb);
                    TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: StreamRequestComplete on pSrb: %08X\n", pSrb));
                    break;
            }
            break;


        case SRB_READ_DATA:

            //
            // Update stats for Unkown packet count
            //
            pFilter->Stats.ulTotalPacketsRead += 1;

            switch (iStream)
            {
                case STREAM_NET_CONTROL:
                    TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: Receive Data packet handler called - SRB_READ - STREAM_NET_CONTROL, pSrb: %08X\n", pSrb));


                    // Take the SRB we get and  queue it up.  These Queued SRB's will be filled with data on a WRITE_DATA
                    // request, at which point they will be completed.
                    //
                    pSrb->Status = STATUS_SUCCESS;
                    QueueAdd (pSrb, &pStream->StreamDataSpinLock, &pStream->StreamDataQueue);
                    TEST_DEBUG( TEST_DBG_TRACE, ("IPSInk Queuing Output SRB %08X\n", pSrb));

                    //
                    // Since the stream state may have changed while we were adding the SRB to the queue
                    // we'll check it again, and cancel it if necessary
                    //
                    if (pStream->KSState == KSSTATE_STOP)
                    {
                        TEST_DEBUG (TEST_DBG_TRACE, ("IPSink: SRB_READ STOP SRB Status returned: %08X\n", pSrb->Status));

                        if (QueueRemoveSpecific (pSrb, &pStream->StreamDataSpinLock, &pStream->StreamDataQueue))
                        {
                            pSrb->Status = STATUS_CANCELLED;
                            StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb );
                            TEST_DEBUG( TEST_DBG_TRACE, ("IPSink Completed SRB %08X\n", pSrb));
                            return;
                        }
                        break;
                    }
                    
                    // StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb);
                    TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: StreamRequestComplete on pSrb: %08X\n", pSrb));
                    break;

                default:
                    TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: Receive Data packet handler called - SRB_READ - Default, pSrb: %08X\n"));
                    pSrb->Status = STATUS_NOT_IMPLEMENTED;
                    StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb);
                    TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: StreamRequestComplete on pSrb: %08X\n", pSrb));
                    break;

            }
            break;

        default:

            //
            // invalid / unsupported command. Fail it as such
            //
            TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: Receive Data packet handler called - Unsupported Command\n"));
            pSrb->Status = STATUS_NOT_IMPLEMENTED;
            StreamClassStreamNotification( StreamRequestComplete, pSrb->StreamObject, pSrb );
            TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: StreamRequestComplete on pSrb: %08X\n", pSrb));
            ASSERT (FALSE);
            break;

    }

    return;
}

//////////////////////////////////////////////////////////////////////////////
VOID
STREAMAPI
ReceiveCtrlPacket(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    PIPSINK_FILTER pFilter = (PIPSINK_FILTER) pSrb->HwDeviceExtension;
    PSTREAM pStream = (PSTREAM) pSrb->StreamObject->HwStreamExtension;

    TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: Receive Control packet handler called\n"));

    pSrb->Status = STATUS_SUCCESS;

    QueueAdd (pSrb, &pStream->StreamControlSpinLock, &pStream->StreamControlQueue);
    //if (QueueAddIfNotEmpty (pSrb, &pStream->StreamControlSpinLock, &pStream->StreamControlQueue))
    //{
    //    pSrb->Status = STATUS_SUCCESS;
    //    return;
    //}


    //do
    while (QueueRemove (&pSrb, &pStream->StreamControlSpinLock, &pStream->StreamControlQueue))
    {
        //
        // determine the type of packet.
        //
        switch (pSrb->Command)
        {
            case SRB_PROPOSE_DATA_FORMAT:
                TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: Receive Control packet handler - Propose data format\n"));
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
                break;

            case SRB_SET_STREAM_STATE:
                TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: Receive Control packet handler - Set Stream State\n"));
                pSrb->Status = STATUS_SUCCESS;
                IpSinkSetState (pSrb);
                break;

            case SRB_GET_STREAM_STATE:
                TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: Receive Control packet handler - Get Stream State\n"));
                pSrb->Status = STATUS_SUCCESS;
                pSrb->CommandData.StreamState = pStream->KSState;
                pSrb->ActualBytesTransferred = sizeof (KSSTATE);
                break;

            case SRB_GET_STREAM_PROPERTY:
                TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: Receive Control packet handler - Get Stream Property\n"));
                IPSinkGetProperty(pSrb);
                break;

            case SRB_SET_STREAM_PROPERTY:
                TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: Receive Control packet handler - Set Stream Property\n"));
                IPSinkSetProperty(pSrb);
                break;

            case SRB_INDICATE_MASTER_CLOCK:
                TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: Receive Control packet handler - Indicate Master Clock\n"));
                pSrb->Status = STATUS_SUCCESS;
                break;

            case SRB_SET_STREAM_RATE:
                TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: Receive Control packet handler - Set Stream Rate\n"));
                pSrb->Status = STATUS_SUCCESS;
                break;

            case SRB_PROPOSE_STREAM_RATE:
                TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: Receive Control packet handler - Propose Stream Rate\n"));
                pSrb->Status = STATUS_SUCCESS;
                break;

            default:
                TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: Receive Control packet handler - Default case\n"));
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
                break;

        }

        StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb);

    } //  while (QueueRemove (&pSrb, &pStream->StreamControlSpinLock, &pStream->StreamControlQueue));

}



//////////////////////////////////////////////////////////////////////////////
VOID
IpSinkSetState(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    PIPSINK_FILTER pFilter               = ((PIPSINK_FILTER) pSrb->HwDeviceExtension);
    PSTREAM pStream                      = (PSTREAM) pSrb->StreamObject->HwStreamExtension;
    PHW_STREAM_REQUEST_BLOCK pCurrentSrb = NULL;

    //
    // For each stream, the following states are used:
    //
    // Stop:    Absolute minimum resources are used.  No outstanding IRPs.
    // Acquire: KS only state that has no DirectShow correpondence
    //          Acquire needed resources.
    // Pause:   Getting ready to run.  Allocate needed resources so that
    //          the eventual transition to Run is as fast as possible.
    //          Read SRBs will be queued at either the Stream class
    //          or in your driver (depending on when you send "ReadyForNext")
    // Run:     Streaming.
    //
    // Moving to Stop to Run always transitions through Pause.
    //
    // But since a client app could crash unexpectedly, drivers should handle
    // the situation of having outstanding IRPs cancelled and open streams
    // being closed WHILE THEY ARE STREAMING!
    //
    // Note that it is quite possible to transition repeatedly between states:
    // Stop -> Pause -> Stop -> Pause -> Run -> Pause -> Run -> Pause -> Stop
    //
    switch (pSrb->CommandData.StreamState)
    {
        case KSSTATE_STOP:

            TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: Set Stream State KSSTATE_STOP\n"));

            //
            // If transitioning to STOP state, then complete any outstanding IRPs
            //
            while (QueueRemove(&pCurrentSrb, &pStream->StreamDataSpinLock, &pStream->StreamDataQueue))
            {
                pCurrentSrb->Status = STATUS_CANCELLED;
                pCurrentSrb->CommandData.DataBufferArray->DataUsed = 0;

                StreamClassStreamNotification(StreamRequestComplete, pCurrentSrb->StreamObject, pCurrentSrb);
            }

            pStream->KSState = pSrb->CommandData.StreamState;
            pSrb->Status = STATUS_SUCCESS;
            break;


        case KSSTATE_ACQUIRE:
            TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: Set Stream State KSSTATE_ACQUIRE\n"));
            pStream->KSState = pSrb->CommandData.StreamState;
            pSrb->Status = STATUS_SUCCESS;
            break;

        case KSSTATE_PAUSE:
            TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: Set Stream State KSSTATE_PAUSE\n"));
            pStream->KSState = pSrb->CommandData.StreamState;
            pSrb->Status = STATUS_SUCCESS;
            break;

        case KSSTATE_RUN:
            TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: Set Stream State KSSTATE_RUN\n"));
            pStream->KSState = pSrb->CommandData.StreamState;
            pSrb->Status = STATUS_SUCCESS;
            break;

    } // end switch (pSrb->CommandData.StreamState)

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\bda\mpe\main.c ===
/////////////////////////////////////////////////////////////////////////////
//
//
// Copyright (c) 1996, 1997  Microsoft Corporation
//
//
// Module Name:
//      test.c
//
// Abstract:
//
//
//
// Author:
//
//      P Porzuczek
//
// Environment:
//
// Revision History:
//
//
//////////////////////////////////////////////////////////////////////////////

//
//
#include <wdm.h>
#include <memory.h>
#include "Main.h"

/////////////////////////////////////////////////////////////////////////////
//
// Default debug mode
//
ULONG TestDebugFlag = TEST_DBG_NONE;

#if DBG

/////////////////////////////////////////////////////////////////////////////
// Debugging definitions
//


//
// Debug tracing defintions
//
#define TEST_LOG_SIZE 256
UCHAR TestLogBuffer[TEST_LOG_SIZE]={0};
ULONG TestLogLoc = 0;

/////////////////////////////////////////////////////////////////////////////
//
// Logging function in debug builds
//
extern VOID
TestLog (
    UCHAR c         // input character
    )
/////////////////////////////////////////////////////////////////////////////
{
    TestLogBuffer[TestLogLoc++] = c;

    TestLogBuffer[(TestLogLoc + 4) % TEST_LOG_SIZE] = '\0';

    if (TestLogLoc >= TEST_LOG_SIZE) {
        TestLogLoc = 0;
    }
}

#endif // DBG

//////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT    pDriverObject,
    IN PUNICODE_STRING   pszuRegistryPath
    )
//////////////////////////////////////////////////////////////////////////////////////
{
    NTSTATUS ntStatus = STATUS_SUCCESS;

    //
    // Register the Mpe Class binding
    //
    ntStatus = MpeDriverInitialize (pDriverObject,  pszuRegistryPath);
    if (ntStatus != STATUS_SUCCESS)
    {
        goto ret;
    }

ret:

    TEST_DEBUG (TEST_DBG_TRACE, ("MPE: Driver Entry complete, ntStatus: %08X\n", ntStatus));

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\bda\mpe\main.h ===
//////////////////////////////////////////////////////////////////////////////\
//
//  Copyright (c) 1990  Microsoft Corporation
//
//  Module Name:
//
//     test.h
//
//  Abstract:
//
//     The main header for the NDIS/KS test driver
//
//  Author:
//
//     P Porzuczek
//
//  Environment:
//
//  Notes:
//
//  Revision History:
//
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _MAIN_H
#define _MAIN_H


#ifdef DBG

extern  ULONG TestDebugFlag;

#define TEST_DBG_NONE       0x00000000
#define TEST_DBG_TRACE      0x00000001
#define TEST_DBG_WRITE_DATA 0x00000002
#define TEST_DBG_READ_DATA  0x00000004

#define TEST_DBG_RECV       0x00000008
#define TEST_DBG_SRB        0x00000010
#define TEST_DBG_CRC        0x00000020
#define TEST_DBG_MPE        0x00000040


#define TEST_DBG_DETAIL  0x00001000
#define TEST_DBG_INFO    0x00002000
#define TEST_DBG_WARNING 0x00004000
#define TEST_DBG_ERROR   0x00008000

#ifdef DEBUG_EXTRAS
#define TEST_DEBUG(_Trace, _Msg)                 \
{                                               \
        __int64                 llTime = 0;             \
        ULONG                   ulTime = 0;                     \
        NdisGetCurrentSystemTime ((PLARGE_INTEGER)&llTime);     \
        ulTime = (ULONG) (llTime >> 2);         \
    if (_Trace & TestDebugFlag)                  \
    {                                           \
        DbgPrint ("%04X %08X %-10.10s %4d  ", ulTime & 0xffff, _Trace, &__FILE__[2], __LINE__); \
        DbgPrint _Msg;                          \
    }                                           \
}

#else
#define TEST_DEBUG(_Trace, _Msg)                 \
{                                               \
    if (_Trace & TestDebugFlag)                  \
    {                                           \
        DbgPrint _Msg;                          \
    }                                           \
}
#endif  // DEBUG_EXTRAS

#define IF_TESTDEBUG(f) if (TestDebugFlag & (f))

#define TEST_DEBUG_LOUD               0x00010000  // debugging info
#define TEST_DEBUG_VERY_LOUD          0x00020000  // excessive debugging info
#define TEST_DEBUG_LOG                0x00040000  // enable Log
#define TEST_DEBUG_CHECK_DUP_SENDS    0x00080000  // check for duplicate sends
#define TEST_DEBUG_TRACK_PACKET_LENS  0x00100000  // track directed packet lens
#define TEST_DEBUG_WORKAROUND1        0x00200000  // drop DFR/DIS packets
#define TEST_DEBUG_CARD_BAD           0x00400000  // dump data if CARD_BAD
#define TEST_DEBUG_CARD_TESTS         0x00800000  // print reason for failing


//
// Macro for deciding whether to print a lot of debugging information.
//
#define IF_LOUD(A) IF_TESTDEBUG( TEST_DEBUG_LOUD ) { A }
#define IF_VERY_LOUD(A) IF_TESTDEBUG( TEST_DEBUG_VERY_LOUD ) { A }


//
// Whether to use the Log buffer to record a trace of the driver.
//
#define IF_LOG(A) IF_TESTDEBUG( TEST_DEBUG_LOG ) { A }
extern VOID TESTLog(UCHAR);

//
// Whether to do loud init failure
//
#define IF_INIT(A) A

//
// Whether to do loud card test failures
//
#define IF_TEST(A) IF_TESTDEBUG( TEST_DEBUG_CARD_TESTS ) { A }

#else

extern  ULONG TestDebugFlag;


#define TEST_NONE
#define TEST_FUNCTIONS
#define TEST_COMMANDS
#define TEST_CONNECTIONS
#define TEST_SCIDS
#define TEST_LIST_ALLOCS
#define TEST_POOL
#define TEST_INDICATES
#define TEST_ALLOCATION


#define TEST_DEBUG(_Trace, _Msg)

#define IF_TESTDEBUG(f)

#define TEST_DEBUG_LOUD
#define TEST_DEBUG_VERY_LOUD
#define TEST_DEBUG_LOG
#define TEST_DEBUG_CHECK_DUP_SENDS
#define TEST_DEBUG_TRACK_PACKET_LENS
#define TEST_DEBUG_WORKAROUND1
#define TEST_DEBUG_CARD_BAD
#define TEST_DEBUG_CARD_TESTS


//
// This is not a debug build, so make everything quiet.
//
#define IF_LOUD(A)
#define IF_VERY_LOUD(A)
#define IF_LOG(A)
#define IF_INIT(A)
#define IF_TEST(A)

#endif // DBG


NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT    pDriverObject,
    IN PUNICODE_STRING   pszuRegistryPath);


VOID
MpeFreeMemory (
    PVOID pvToFree,
    ULONG ulSize
    );

NTSTATUS
MpeAllocateMemory (
    PVOID  *ppvAllocated,
    ULONG   ulcbSize
    );


NTSTATUS
MpeDriverInitialize (
    IN PDRIVER_OBJECT    DriverObject,
    IN PUNICODE_STRING   RegistryPath
    );

#endif // _MAIN_H

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\bda\mpe\mpe.c ===
///////////////////////////////////////////////////////////////////////////
//
//
// Copyright (c) 1996, 1997  Microsoft Corporation
//
//
// Module Name:
//      mpe.c
//
// Abstract:
//
//
// Author:
//
//      P Porzuczek
//
// Environment:
//
// Revision History:
//
//
//////////////////////////////////////////////////////////////////////////////

#include <wdm.h>
#include <strmini.h>
#include <ksmedia.h>
#include <BdaTypes.h>
#include <BdaMedia.h>

#include "Mpe.h"
#include "MpeMedia.h"
#include "MpeStream.h"

#include "Main.h"
#include "filter.h"


#pragma pack (1)

typedef struct
{
    BYTE   table_id;
    USHORT section_syntax_indicator : 1;
    USHORT private_indicator: 1;
    USHORT reserved1: 2;
    USHORT section_length: 12;
    BYTE   MAC_address_6;
    BYTE   MAC_address_5;
    BYTE   reserved2 : 2;
    BYTE   payload_scrambling : 2;
    BYTE   address_scrambling : 2;
    BYTE   LLC_SNAP_flag : 1;
    BYTE   current_next_indicator : 1;
    BYTE   section_number;
    BYTE   last_section_number;
    BYTE   MAC_address_4;
    BYTE   MAC_address_3;
    BYTE   MAC_address_2;
    BYTE   MAC_address_1;
    BYTE   Data [0];

} SECTION_HEADER, *PSECTION_HEADER;

typedef struct
{
    BYTE   dsap;
    BYTE   ssap;
    BYTE   cntl;
    BYTE   org [3];
    USHORT type;
    BYTE Data [0];

} LLC_SNAP, *PLLC_SNAP;


typedef struct
{
    BYTE MAC_Dest_Address [6];
    BYTE MAC_Src_Address [6];
    USHORT usLength;

} MAC_Address, *PMAC_Address;

typedef struct _HEADER_IP_
{
    UCHAR  ucVersion_Length;
    UCHAR  ucTOS;
    USHORT usLength;
    USHORT usId;
    USHORT usFlags_Offset;
    UCHAR  ucTTL;
    UCHAR  ucProtocol;
    USHORT usHdrChecksum;
    UCHAR  ucSrcAddress [4];
    UCHAR  ucDestAddress [4];

} HEADER_IP, *PHEADER_IP;


#pragma pack ()



#define ES2(s) ((((s) >> 8) & 0x00FF) + (((s) << 8) & 0xFF00))


#ifdef DBG

//////////////////////////////////////////////////////////////////////////////
VOID
DumpData (
    PUCHAR pData,
    ULONG  ulSize
    )
//////////////////////////////////////////////////////////////////////////////
{
  ULONG  ulCount;
  ULONG  ul;
  UCHAR  uc;

  while (ulSize)
  {
      ulCount = 16 < ulSize ? 16 : ulSize;

      for (ul = 0; ul < ulCount; ul++)
      {
          uc = *pData;

          TEST_DEBUG (TEST_DBG_RECV, ("%02X ", uc));
          ulSize -= 1;
          pData  += 1;
      }

      TEST_DEBUG (TEST_DBG_RECV, ("\n"));
  }

}

#endif   //DBG



//////////////////////////////////////////////////////////////////////////////
BOOLEAN
ValidSection (
    PSECTION_HEADER pSection
    )
//////////////////////////////////////////////////////////////////////////////
{
    if (pSection->table_id != 0x3E)
    {
        return FALSE;
    }

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
BOOLEAN
ValidSnap (
    PLLC_SNAP pSnap
    )
//////////////////////////////////////////////////////////////////////////////
{

    if (pSnap->dsap != 0xAA)
    {
        return FALSE;
    }

    if (pSnap->ssap != 0xAA)
    {
        return FALSE;
    }

    if (pSnap->cntl != 0x03)
    {
        return FALSE;
    }

    if (pSnap->type != 0x0800)
    {
        return FALSE;
    }

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
VOID
NormalizeSection (
    PBYTE pStream,
    PSECTION_HEADER pSection
    )
//////////////////////////////////////////////////////////////////////////////
{
    PBYTE   pb = pStream;
    PUSHORT ps = (PUSHORT) pStream;

    if (pSection)
    {
        pSection->table_id = *pb;

        pb += 1;
        pSection->section_syntax_indicator = (*pb >> 7) & 0x01;
        pSection->private_indicator = (*pb >> 6 )& 0x01;
        pSection->reserved1 = (*pb >> 4) & 0x03;

        ps = (PUSHORT) pb;
        pSection->section_length = ES2 (*ps) & 0x0FFF;

        pb += 2;
        pSection->MAC_address_6 = *pb;

        pb += 1;
        pSection->MAC_address_5 = *pb;

        pb += 1;
        pSection->reserved2 = (*pb >> 6) & 0x03;
        pSection->payload_scrambling = (*pb >> 4) & 0x3;
        pSection->address_scrambling = (*pb >> 2) & 0x3;
        pSection->LLC_SNAP_flag = (*pb >> 1) & 0x01;
        pSection->current_next_indicator = *pb & 0x01;

        pb += 1;
        pSection->section_number = *pb;

        pb += 1;
        pSection->last_section_number = *pb;

        pb += 1;
        pSection->MAC_address_4 = *pb;

        pb += 1;
        pSection->MAC_address_3 = *pb;

        pb += 1;
        pSection->MAC_address_2 = *pb;

        pb += 1;
        pSection->MAC_address_1 = *pb;

    }

    return;

}

//////////////////////////////////////////////////////////////////////////////
VOID
NormalizeSnap (
    PBYTE pStream,
    PLLC_SNAP pSnap
    )
//////////////////////////////////////////////////////////////////////////////
{
    PUSHORT ps = (PUSHORT) pStream;

    if (pSnap)
    {
        pSnap->type = ES2 (pSnap->type);
    }

    return;

}

//////////////////////////////////////////////////////////////////////////////
//
//
VOID
DumpDataFormat (
    PKSDATAFORMAT   pF
    );


//////////////////////////////////////////////////////////////////////////////
VOID
MpeGetConnectionProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    PSTREAM pStream                     = (PSTREAM)pSrb->StreamObject->HwStreamExtension;
    PSTREAM_PROPERTY_DESCRIPTOR pSPD    = pSrb->CommandData.PropertyInfo;
    ULONG Id                            = pSPD->Property->Id;                // index of the property
    ULONG ulStreamNumber                = pSrb->StreamObject->StreamNumber;

    pSrb->ActualBytesTransferred = 0;

    switch (Id)
    {
        case KSPROPERTY_CONNECTION_ALLOCATORFRAMING:
        {
            PKSALLOCATOR_FRAMING Framing = (PKSALLOCATOR_FRAMING) pSPD->PropertyInfo;

            Framing->RequirementsFlags   = KSALLOCATOR_REQUIREMENTF_SYSTEM_MEMORY    |
                                           KSALLOCATOR_REQUIREMENTF_INPLACE_MODIFIER |
                                           KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY;

            Framing->PoolType            = NonPagedPool;
            Framing->Frames              = 0;
            Framing->FrameSize           = 0;
            Framing->FileAlignment       = 0;         // None OR FILE_QUAD_ALIGNMENT-1 OR PAGE_SIZE-1;
            Framing->Reserved            = 0;

            switch (ulStreamNumber)
            {
                case MPE_IPV4:
                    Framing->Frames    = 16;
                    Framing->FrameSize = pStream->OpenedFormat.SampleSize;
                    pSrb->Status = STATUS_SUCCESS;
                    break;

                case MPE_STREAM:
                    Framing->Frames    = 32;
                    Framing->FrameSize = pStream->OpenedFormat.SampleSize;
                    pSrb->Status = STATUS_SUCCESS;
                    break;

                default:
                    pSrb->Status = STATUS_NOT_IMPLEMENTED;
                    break;
            }

            pSrb->ActualBytesTransferred = sizeof (KSALLOCATOR_FRAMING);
        }
        break;

        default:
            pSrb->Status = STATUS_NOT_IMPLEMENTED;
            break;
    }


    return;
}


//////////////////////////////////////////////////////////////////////////////
NTSTATUS
MpeDriverInitialize (
    IN PDRIVER_OBJECT    DriverObject,
    IN PUNICODE_STRING   RegistryPath
    )
//////////////////////////////////////////////////////////////////////////////
{
    NTSTATUS ntStatus                        = STATUS_SUCCESS;
    HW_INITIALIZATION_DATA   HwInitData;
    UNICODE_STRING           DeviceNameString;
    UNICODE_STRING           SymbolicNameString;

    RtlZeroMemory(&HwInitData, sizeof(HwInitData));
    HwInitData.HwInitializationDataSize = sizeof(HwInitData);


    ////////////////////////////////////////////////////////////////
    //
    // Setup the stream class dispatch table
    //
    HwInitData.HwInterrupt                 = NULL; // HwInterrupt is only for HW devices

    HwInitData.HwReceivePacket             = CodecReceivePacket;
    HwInitData.HwCancelPacket              = CodecCancelPacket;
    HwInitData.HwRequestTimeoutHandler     = CodecTimeoutPacket;

    HwInitData.DeviceExtensionSize         = sizeof(MPE_FILTER);
    HwInitData.PerRequestExtensionSize     = sizeof(SRB_EXTENSION);
    HwInitData.FilterInstanceExtensionSize = 0;
    HwInitData.PerStreamExtensionSize      = sizeof(STREAM);
    HwInitData.BusMasterDMA                = FALSE;
    HwInitData.Dma24BitAddresses           = FALSE;
    HwInitData.BufferAlignment             = 3;
    HwInitData.TurnOffSynchronization      = TRUE;
    HwInitData.DmaBufferSize               = 0;


    ntStatus = StreamClassRegisterAdapter (DriverObject, RegistryPath, &HwInitData);
    if (ntStatus != STATUS_SUCCESS)
    {
        goto ret;
    }

ret:

    return ntStatus;
}


//
//
//////////////////////////////////////////////////////////////////////////////
BOOLEAN
CodecInitialize (
    IN OUT PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    NTSTATUS ntStatus                           = STATUS_SUCCESS;
    BOOLEAN bStatus                             = FALSE;
    PPORT_CONFIGURATION_INFORMATION pConfigInfo = pSrb->CommandData.ConfigInfo;
    PMPE_FILTER pFilter                      = (PMPE_FILTER) pConfigInfo->HwDeviceExtension;

    //
    // Define the default return codes
    //
    pSrb->Status = STATUS_SUCCESS;
    bStatus = TRUE;

    //
    // Check out init flag so we don't try to init more then once.  The Streaming
    // Class driver appears to call the init handler several times for some reason.
    //
    if (pFilter->bInitializationComplete)
    {
        goto ret;
    }

    //
    // Initialize Statistics block
    //
    RtlZeroMemory(&pFilter->Stats, sizeof (STATS));


    if (pConfigInfo->NumberOfAccessRanges == 0)
    {
        pConfigInfo->StreamDescriptorSize = sizeof (HW_STREAM_HEADER) +
            DRIVER_STREAM_COUNT * sizeof (HW_STREAM_INFORMATION);

    }
    else
    {
        pSrb->Status = STATUS_NO_SUCH_DEVICE;
        bStatus = FALSE;
        goto ret;
    }


    //
    // Create a filter object to represent our context
    //
    pSrb->Status = CreateFilter (pConfigInfo->ClassDeviceObject->DriverObject, pConfigInfo->ClassDeviceObject, pFilter);
    if (pSrb->Status != STATUS_SUCCESS)
    {
        bStatus = FALSE;
        goto ret;
    }

    pFilter->bInitializationComplete = TRUE;

ret:

    return (bStatus);
}


//////////////////////////////////////////////////////////////////////////////
BOOLEAN
CodecUnInitialize (
    IN OUT PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    NTSTATUS ntStatus                           = STATUS_SUCCESS;
    BOOLEAN bStatus                             = FALSE;
    PPORT_CONFIGURATION_INFORMATION pConfigInfo = pSrb->CommandData.ConfigInfo;
    PMPE_FILTER pFilter                      = ((PMPE_FILTER)pSrb->HwDeviceExtension);
    PSTREAM pStream                             = NULL;


    TEST_DEBUG (TEST_DBG_TRACE, ("MPE: Codec Unitialize called\n"));

    if (pSrb->StreamObject != NULL)
    {
        pStream = (PSTREAM)pSrb->StreamObject->HwStreamExtension;
    }

    if (pStream)
    {

        //
        // Clean up the NAB_STREAM QUEUE used for deframing
        //
        //$$BUG
        //DeleteNabStreamQueue (pFilter);

        //
        // Clean up any queues we have and complete any outstanding SRB's
        //
        while (QueueRemove (&pSrb, &pFilter->StreamUserSpinLock, &pFilter->StreamContxList))
        {
            pSrb->Status = STATUS_CANCELLED;
            StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb);
            TEST_DEBUG( TEST_DBG_SRB, ("MPE 5Completed SRB %08X\n", pSrb));

        }

        while (QueueRemove (&pSrb, &pFilter->IpV4StreamDataSpinLock, &pFilter->IpV4StreamDataQueue))
        {
            pSrb->Status = STATUS_CANCELLED;
            StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb );
            TEST_DEBUG( TEST_DBG_SRB, ("MPE 6Completed SRB %08X\n", pSrb));
        }


        while (QueueRemove (&pSrb, &pFilter->StreamDataSpinLock, &pFilter->StreamDataQueue))
        {
            pSrb->Status = STATUS_CANCELLED;
            StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb );
            TEST_DEBUG( TEST_DBG_SRB, ("MPE 7Completed SRB %08X\n", pSrb));
        }


        while (QueueRemove (&pSrb, &pFilter->StreamControlSpinLock, &pFilter->StreamControlQueue))
        {
            pSrb->Status = STATUS_CANCELLED;
            StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb);
            TEST_DEBUG( TEST_DBG_SRB, ("MPE 8Completed SRB %08X\n", pSrb));
        }

    }


    while (QueueRemove (&pSrb, &pFilter->AdapterSRBSpinLock, &pFilter->AdapterSRBQueue))
    {
        pSrb->Status = STATUS_CANCELLED;
        StreamClassDeviceNotification (DeviceRequestComplete, pSrb->StreamObject, pSrb);
        TEST_DEBUG( TEST_DBG_RECV, ("MPE 9Completed SRB %08X\n", pSrb));
    }


    bStatus = TRUE;

    TEST_DEBUG (TEST_DBG_TRACE, ("MPE: Codec Unitialize completed\n"));

    return (bStatus);
}


//////////////////////////////////////////////////////////////////////////////
VOID
CodecStreamInfo (
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    int j;

    PMPE_FILTER pFilter =
            ((PMPE_FILTER)pSrb->HwDeviceExtension);

    //
    // pick up the pointer to header which preceeds the stream info structs
    //
    PHW_STREAM_HEADER pstrhdr =
            (PHW_STREAM_HEADER)&(pSrb->CommandData.StreamBuffer->StreamHeader);

    //
    // pick up the pointer to the array of stream information data structures
    //
    PHW_STREAM_INFORMATION pstrinfo =
            (PHW_STREAM_INFORMATION)&(pSrb->CommandData.StreamBuffer->StreamInfo);


    //
    // Set the header
    //
    StreamHeader.NumDevPropArrayEntries = 0;
    StreamHeader.DevicePropertiesArray = (PKSPROPERTY_SET)NULL;

    *pstrhdr = StreamHeader;

    //
    // stuff the contents of each HW_STREAM_INFORMATION struct
    //
    for (j = 0; j < DRIVER_STREAM_COUNT; j++)
    {
       *pstrinfo++ = Streams[j].hwStreamInfo;
    }

    pSrb->Status = STATUS_SUCCESS;

}


//////////////////////////////////////////////////////////////////////////////
VOID
STREAMAPI
CodecCancelPacket(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    PSTREAM  pStream = (PSTREAM)pSrb->StreamObject->HwStreamExtension;
    PMPE_FILTER  pFilter = ((PMPE_FILTER)pSrb->HwDeviceExtension);

    //
    // Check whether the SRB to cancel is in use by this stream
    //

    TEST_DEBUG (TEST_DBG_TRACE, ("MPE: CancelPacket Called\n"));

    //
    //$$BUG
    //
    //CancelNabStreamSrb (pFilter, pSrb);


    if (QueueRemoveSpecific (pSrb, &pFilter->IpV4StreamDataSpinLock, &pFilter->IpV4StreamDataQueue))
    {
        pSrb->Status = STATUS_CANCELLED;
        StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb );
        TEST_DEBUG( TEST_DBG_SRB, ("MPE 10Completed SRB %08X\n", pSrb));
        return;
    }


    if (QueueRemoveSpecific (pSrb, &pFilter->StreamDataSpinLock, &pFilter->StreamDataQueue))
    {
        pSrb->Status = STATUS_CANCELLED;
        StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb );
        TEST_DEBUG( TEST_DBG_SRB, ("MPE 11Completed SRB %08X\n", pSrb));
        return;
    }


    if (QueueRemoveSpecific (pSrb, &pFilter->StreamControlSpinLock, &pFilter->StreamControlQueue))
    {
        pSrb->Status = STATUS_CANCELLED;
        StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb);
        TEST_DEBUG( TEST_DBG_SRB, ("MPE 12Completed SRB %08X\n", pSrb));
        return;
    }

    if (QueueRemoveSpecific (pSrb, &pFilter->AdapterSRBSpinLock, &pFilter->AdapterSRBQueue))
    {
        pSrb->Status = STATUS_CANCELLED;
        StreamClassDeviceNotification (DeviceRequestComplete, pSrb->StreamObject, pSrb);
        TEST_DEBUG( TEST_DBG_SRB, ("MPE 13Completed SRB %08X\n", pSrb));
        return;
    }

    return;
}


//////////////////////////////////////////////////////////////////////////////
VOID
STREAMAPI
CodecTimeoutPacket(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    //
    // if we timeout while playing, then we need to consider this
    // condition an error, and reset the hardware, and reset everything
    // as well as cancelling this and all requests
    //

    //
    // if we are not playing, and this is a CTRL request, we still
    // need to reset everything as well as cancelling this and all requests
    //

    //
    // if this is a data request, and the device is paused, we probably have
    // run out of data buffer, and need more time, so just reset the timer,
    // and let the packet continue
    //

    TEST_DEBUG (TEST_DBG_TRACE, ("MPE: TimeoutPacket Called\n"));

    pSrb->TimeoutCounter = 0;

    return;
}


//////////////////////////////////////////////////////////////////////////////
VOID
STREAMAPI
CodecReceivePacket(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    PMPE_FILTER pFilter = ((PMPE_FILTER)pSrb->HwDeviceExtension);


    //
    // Make sure queue & SL initted
    //
    if (!pFilter->bAdapterQueueInitialized)
    {
        InitializeListHead (&pFilter->AdapterSRBQueue);
        KeInitializeSpinLock (&pFilter->AdapterSRBSpinLock);
        pFilter->bAdapterQueueInitialized = TRUE;
    }

    //
    // Assume success
    //
    pSrb->Status = STATUS_SUCCESS;

    //
    // determine the type of packet.
    //
    QueueAdd (pSrb, &pFilter->AdapterSRBSpinLock, &pFilter->AdapterSRBQueue);
    TEST_DEBUG( TEST_DBG_SRB, ("MPE Queuing SRB %08X\n", pSrb));


    while (QueueRemove( &pSrb, &pFilter->AdapterSRBSpinLock, &pFilter->AdapterSRBQueue ))
    {
        switch (pSrb->Command)
        {

            case SRB_INITIALIZE_DEVICE:
                TEST_DEBUG (TEST_DBG_TRACE, ("MPE: SRB_INITIALIZE Command\n"));
                CodecInitialize(pSrb);
                break;

            case SRB_UNINITIALIZE_DEVICE:
                TEST_DEBUG (TEST_DBG_TRACE, ("MPE: SRB_UNINITIALIZE Command\n"));
                CodecUnInitialize(pSrb);
                break;

            case SRB_INITIALIZATION_COMPLETE:
                TEST_DEBUG (TEST_DBG_TRACE, ("MPE: SRB_INITIALIZE_COMPLETE Command\n"));
                pSrb->Status = STATUS_SUCCESS;
                break;

            case SRB_OPEN_STREAM:
                TEST_DEBUG (TEST_DBG_TRACE, ("MPE: SRB_OPEN_STREAM Command\n"));
                OpenStream (pSrb);
                break;

            case SRB_CLOSE_STREAM:
                TEST_DEBUG (TEST_DBG_TRACE, ("MPE: SRB_CLOSE_STREAM Command\n"));
                CloseStream (pSrb);
                break;

            case SRB_GET_STREAM_INFO:
                TEST_DEBUG (TEST_DBG_TRACE, ("MPE: SRB_GET_STREAM_INFO Command\n"));
                CodecStreamInfo (pSrb);
                break;

            case SRB_GET_DATA_INTERSECTION:
                TEST_DEBUG (TEST_DBG_TRACE, ("MPE: SRB_GET_DATA_INTERSECTION Command\n"));

                //
                // Compare our stream formats.  NOTE, the compare functions sets the SRB
                // status fields
                //
                CompareStreamFormat (pSrb);
                break;

            case SRB_OPEN_DEVICE_INSTANCE:
                TEST_DEBUG (TEST_DBG_TRACE, ("MPE: SRB_OPEN_DEVICE_INSTANCE Command\n"));
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
                break;

            case SRB_CLOSE_DEVICE_INSTANCE:
                TEST_DEBUG (TEST_DBG_TRACE, ("MPE: SRB_CLOSE_DEVICE_INSTANCE Command\n"));
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
                break;

            case SRB_UNKNOWN_DEVICE_COMMAND:
                TEST_DEBUG (TEST_DBG_TRACE, ("MPE: SRB_UNKNOWN_DEVICE Command\n"));
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
                break;

            case SRB_CHANGE_POWER_STATE:
                TEST_DEBUG (TEST_DBG_TRACE, ("MPE: SRB_CHANGE_POWER_STATE Command\n"));
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
                break;

            case SRB_GET_DEVICE_PROPERTY:
                TEST_DEBUG (TEST_DBG_TRACE, ("MPE: SRB_GET_DEVICE_PROPERTY Command\n"));
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
                break;

            case SRB_SET_DEVICE_PROPERTY:
                TEST_DEBUG (TEST_DBG_TRACE, ("MPE: SRB_SET_DEVICE_PROPERTY Command\n"));
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
                break;

            case SRB_UNKNOWN_STREAM_COMMAND:
                TEST_DEBUG (TEST_DBG_TRACE, ("MPE: SRB_UNKNOWN Command\n"));
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
                break;

            default:
                TEST_DEBUG (TEST_DBG_TRACE, ("MPE: SRB_DEFAULT Command\n"));
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
                break;

        };


        //
        // NOTE:
        //
        // All of the commands that we do, or do not understand can all be completed
        // syncronously at this point, so we can use a common callback routine here.
        // If any of the above commands require asyncronous processing, this will
        // have to change
        //

        TEST_DEBUG (TEST_DBG_TRACE, ("MPE: SRB Status returned: %08X\n", pSrb->Status));

        StreamClassDeviceNotification (DeviceRequestComplete, pFilter, pSrb);
        TEST_DEBUG( TEST_DBG_SRB, ("MPE 14Completed SRB %08X\n", pSrb));

    }




}


//////////////////////////////////////////////////////////////////////////////
BOOL STREAMAPI
QueueAdd (
    IN PHW_STREAM_REQUEST_BLOCK pSrb,
    IN PKSPIN_LOCK pQueueSpinLock,
    IN PLIST_ENTRY pQueue
    )
//////////////////////////////////////////////////////////////////////////////
{
    KIRQL           Irql;
    PSRB_EXTENSION  pSrbExtension;

    pSrbExtension = ( PSRB_EXTENSION )pSrb->SRBExtension;

    KeAcquireSpinLock( pQueueSpinLock, &Irql );

    pSrbExtension->pSrb = pSrb;
    InsertTailList( pQueue, &pSrbExtension->ListEntry );

    KeReleaseSpinLock( pQueueSpinLock, Irql );

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
BOOL STREAMAPI
QueuePush (
    IN PHW_STREAM_REQUEST_BLOCK pSrb,
    IN PKSPIN_LOCK pQueueSpinLock,
    IN PLIST_ENTRY pQueue
    )
//////////////////////////////////////////////////////////////////////////////
{
    KIRQL           Irql;
    PSRB_EXTENSION  pSrbExtension;

    pSrbExtension = ( PSRB_EXTENSION )pSrb->SRBExtension;

    KeAcquireSpinLock( pQueueSpinLock, &Irql );

    pSrbExtension->pSrb = pSrb;
    InsertHeadList( pQueue, &pSrbExtension->ListEntry );

    KeReleaseSpinLock( pQueueSpinLock, Irql );

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
BOOL STREAMAPI
QueueAddIfNotEmpty (
    IN PHW_STREAM_REQUEST_BLOCK pSrb,
    IN PKSPIN_LOCK pQueueSpinLock,
    IN PLIST_ENTRY pQueue
    )
//////////////////////////////////////////////////////////////////////////////
{
   KIRQL           Irql;
   PSRB_EXTENSION  pSrbExtension;
   BOOL            bAddedSRB = FALSE;

   pSrbExtension = ( PSRB_EXTENSION )pSrb->SRBExtension;

   KeAcquireSpinLock( pQueueSpinLock, &Irql );

   if( !IsListEmpty( pQueue ))
   {
       pSrbExtension->pSrb = pSrb;
       InsertTailList (pQueue, &pSrbExtension->ListEntry );
       bAddedSRB = TRUE;
   }

   KeReleaseSpinLock( pQueueSpinLock, Irql );

   return bAddedSRB;
}

//////////////////////////////////////////////////////////////////////////////
BOOL STREAMAPI
QueueRemove (
    IN OUT PHW_STREAM_REQUEST_BLOCK * pSrb,
    IN PKSPIN_LOCK pQueueSpinLock,
    IN PLIST_ENTRY pQueue
    )
//////////////////////////////////////////////////////////////////////////////
{
   KIRQL    Irql;
   BOOL     bRemovedSRB = FALSE;

   KeAcquireSpinLock (pQueueSpinLock, &Irql);

   *pSrb =  (PHW_STREAM_REQUEST_BLOCK) NULL;

   if( !IsListEmpty( pQueue ))
   {
       PHW_STREAM_REQUEST_BLOCK *pCurrentSrb = NULL;
       PUCHAR Ptr                            = (PUCHAR) RemoveHeadList(pQueue);

       pCurrentSrb = (PHW_STREAM_REQUEST_BLOCK *) (((PUCHAR)Ptr) + sizeof (LIST_ENTRY));

       *pSrb = *pCurrentSrb;
       bRemovedSRB = TRUE;

   }

   KeReleaseSpinLock (pQueueSpinLock, Irql);

   return bRemovedSRB;
}

//////////////////////////////////////////////////////////////////////////////
BOOL STREAMAPI
QueueRemoveSpecific (
    IN PHW_STREAM_REQUEST_BLOCK pSrb,
    IN PKSPIN_LOCK pQueueSpinLock,
    IN PLIST_ENTRY pQueue
    )
//////////////////////////////////////////////////////////////////////////////
{
   KIRQL Irql;
   BOOL  bRemovedSRB = FALSE;
   PLIST_ENTRY pCurrentEntry;
   PHW_STREAM_REQUEST_BLOCK * pCurrentSrb;

   KeAcquireSpinLock( pQueueSpinLock, &Irql );

   if( !IsListEmpty( pQueue ))
   {
       pCurrentEntry = pQueue->Flink;
       while ((pCurrentEntry != pQueue ) && !bRemovedSRB)
       {
           pCurrentSrb = (PHW_STREAM_REQUEST_BLOCK * ) ((( PUCHAR )pCurrentEntry ) + sizeof( LIST_ENTRY ));

           if( *pCurrentSrb == pSrb )
           {
               RemoveEntryList( pCurrentEntry );
               bRemovedSRB = TRUE;
           }
           pCurrentEntry = pCurrentEntry->Flink;
       }
   }
   KeReleaseSpinLock( pQueueSpinLock, Irql );

   return bRemovedSRB;
}

//////////////////////////////////////////////////////////////////////////////
NTSTATUS
StreamIPIndicateEvent (
    PVOID pvEvent
)
//////////////////////////////////////////////////////////////////////////////
{
    return STATUS_NOT_IMPLEMENTED;
}



//////////////////////////////////////////////////////////////////////////////
BOOL
CompareGUIDsAndFormatSize(
    IN PKSDATARANGE pDataRange1,
    IN PKSDATARANGE pDataRange2,
    BOOLEAN bCheckSize
    )
//////////////////////////////////////////////////////////////////////////////
{
    BOOL bResult = FALSE;

    if ( IsEqualGUID(&pDataRange1->MajorFormat, &KSDATAFORMAT_TYPE_WILDCARD) ||
         IsEqualGUID(&pDataRange2->MajorFormat, &KSDATAFORMAT_TYPE_WILDCARD) ||
         IsEqualGUID(&pDataRange1->MajorFormat, &pDataRange2->MajorFormat) )
    {

        if ( IsEqualGUID(&pDataRange1->SubFormat, &KSDATAFORMAT_SUBTYPE_WILDCARD) ||
             IsEqualGUID(&pDataRange2->SubFormat, &KSDATAFORMAT_SUBTYPE_WILDCARD) ||
             IsEqualGUID(&pDataRange1->SubFormat, &pDataRange2->SubFormat) )
        {

            if ( IsEqualGUID(&pDataRange1->Specifier, &KSDATAFORMAT_SPECIFIER_WILDCARD) ||
                 IsEqualGUID(&pDataRange2->Specifier, &KSDATAFORMAT_SPECIFIER_WILDCARD) ||
                 IsEqualGUID(&pDataRange1->Specifier, &pDataRange2->Specifier) )
            {
                if ( !bCheckSize || pDataRange1->FormatSize == pDataRange2->FormatSize)
                {
                    bResult = TRUE;
                }
            }
        }
    }

    return bResult;

}

//////////////////////////////////////////////////////////////////////////////
VOID
DumpDataFormat (
    PKSDATAFORMAT   pF
    )
//////////////////////////////////////////////////////////////////////////////
{
    TEST_DEBUG (TEST_DBG_TRACE, ("MPE: DATA Format\n"));
    TEST_DEBUG (TEST_DBG_TRACE, ("MPE:     Format Size:   %08X\n", pF->FormatSize));
    TEST_DEBUG (TEST_DBG_TRACE, ("MPE:     Flags:         %08X\n", pF->Flags));
    TEST_DEBUG (TEST_DBG_TRACE, ("MPE:     SampleSize:    %08X\n", pF->SampleSize));
    TEST_DEBUG (TEST_DBG_TRACE, ("MPE:     Reserved:      %08X\n", pF->Reserved));



    TEST_DEBUG (TEST_DBG_TRACE, ("MPE:     Major GUID:  %08X %04X %04X %02X %02X %02X %02X %02X %02X %02X %02X\n",
                                                pF->MajorFormat.Data1,
                                                pF->MajorFormat.Data2,
                                                pF->MajorFormat.Data3,
                                                pF->MajorFormat.Data4[0],
                                                pF->MajorFormat.Data4[1],
                                                pF->MajorFormat.Data4[2],
                                                pF->MajorFormat.Data4[3],
                                                pF->MajorFormat.Data4[4],
                                                pF->MajorFormat.Data4[5],
                                                pF->MajorFormat.Data4[6],
                                                pF->MajorFormat.Data4[7]
                                ));

    TEST_DEBUG (TEST_DBG_TRACE, ("MPE:     Sub GUID:    %08X %04X %04X %02X %02X %02X %02X %02X %02X %02X %02X\n",
                                                pF->SubFormat.Data1,
                                                pF->SubFormat.Data2,
                                                pF->SubFormat.Data3,
                                                pF->SubFormat.Data4[0],
                                                pF->SubFormat.Data4[1],
                                                pF->SubFormat.Data4[2],
                                                pF->SubFormat.Data4[3],
                                                pF->SubFormat.Data4[4],
                                                pF->SubFormat.Data4[5],
                                                pF->SubFormat.Data4[6],
                                                pF->SubFormat.Data4[7]
                                ));

    TEST_DEBUG (TEST_DBG_TRACE, ("MPE:     Specifier:   %08X %04X %04X %02X %02X %02X %02X %02X %02X %02X %02X\n",
                                                pF->Specifier.Data1,
                                                pF->Specifier.Data2,
                                                pF->Specifier.Data3,
                                                pF->Specifier.Data4[0],
                                                pF->Specifier.Data4[1],
                                                pF->Specifier.Data4[2],
                                                pF->Specifier.Data4[3],
                                                pF->Specifier.Data4[4],
                                                pF->Specifier.Data4[5],
                                                pF->Specifier.Data4[6],
                                                pF->Specifier.Data4[7]
                                ));

    TEST_DEBUG (TEST_DBG_TRACE, ("\n"));
}


//////////////////////////////////////////////////////////////////////////////
BOOL
CompareStreamFormat (
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    BOOL                        bStatus = FALSE;
    PSTREAM_DATA_INTERSECT_INFO pIntersectInfo;
    PKSDATARANGE                pDataRange1;
    PKSDATARANGE                pDataRange2;
    ULONG                       FormatSize = 0;
    ULONG                       ulStreamNumber;
    ULONG                       j;
    ULONG                       ulNumberOfFormatArrayEntries;
    PKSDATAFORMAT               *pAvailableFormats;


    pIntersectInfo = pSrb->CommandData.IntersectInfo;
    ulStreamNumber = pIntersectInfo->StreamNumber;


    pSrb->ActualBytesTransferred = 0;


    TEST_DEBUG (TEST_DBG_TRACE, ("MPE: Comparing Stream Formats\n"));


    //
    // Check that the stream number is valid
    //
    if (ulStreamNumber < DRIVER_STREAM_COUNT)
    {
        ulNumberOfFormatArrayEntries = Streams[ulStreamNumber].hwStreamInfo.NumberOfFormatArrayEntries;

        //
        // Get the pointer to the array of available formats
        //
        pAvailableFormats = Streams[ulStreamNumber].hwStreamInfo.StreamFormatsArray;

        //
        // Walk the formats supported by the stream searching for a match
        // of the three GUIDs which together define a DATARANGE
        //
        for (pDataRange1 = pIntersectInfo->DataRange, j = 0;
             j < ulNumberOfFormatArrayEntries;
             j++, pAvailableFormats++)

        {
            bStatus = FALSE;
            pSrb->Status = STATUS_UNSUCCESSFUL;

            pDataRange2 = *pAvailableFormats;

            if (CompareGUIDsAndFormatSize (pDataRange1, pDataRange2, TRUE))
            {

                ULONG   ulFormatSize = pDataRange2->FormatSize;

                TEST_DEBUG (TEST_DBG_TRACE, ("MPE: Stream Formats compare\n"));

                //
                // Is the caller trying to get the format, or the size of the format?
                //
                if (pIntersectInfo->SizeOfDataFormatBuffer == sizeof (ULONG))
                {
                    TEST_DEBUG (TEST_DBG_TRACE, ("MPE: Returning Stream Format size\n"));

                    *(PULONG) pIntersectInfo->DataFormatBuffer = ulFormatSize;
                    pSrb->ActualBytesTransferred = sizeof (ULONG);
                    pSrb->Status = STATUS_SUCCESS;
                    bStatus = TRUE;
                }
                else
                {
                    //
                    // Verify that there is enough room in the supplied buffer for the whole thing
                    //
                    pSrb->Status = STATUS_BUFFER_TOO_SMALL;
                    bStatus = FALSE;

                    if (pIntersectInfo->SizeOfDataFormatBuffer >= ulFormatSize)
                    {
                        TEST_DEBUG (TEST_DBG_TRACE, ("MPE: Returning Stream Format\n"));
                        RtlCopyMemory (pIntersectInfo->DataFormatBuffer, pDataRange2, ulFormatSize);
                        pSrb->ActualBytesTransferred = ulFormatSize;
                        pSrb->Status = STATUS_SUCCESS;
                        bStatus = TRUE;
                    }
                    else
                    {
                        TEST_DEBUG (TEST_DBG_TRACE, ("MPE: Stream Format return buffer too small\n"));
                    }
                }
                break;
            }
            else
            {
                TEST_DEBUG (TEST_DBG_TRACE, ("MPE: Stream Formats DO NOT compare\n"));
            }
        }

        if ( j >= ulNumberOfFormatArrayEntries )
        {
            pSrb->ActualBytesTransferred = 0;
            pSrb->Status = STATUS_UNSUCCESSFUL;
            bStatus = FALSE;
        }

    }
    else
    {
        pSrb->ActualBytesTransferred = 0;
        pSrb->Status = STATUS_NOT_IMPLEMENTED;
        bStatus = FALSE;
    }

    return bStatus;
}


//////////////////////////////////////////////////////////////////////////////
VOID
CloseStream (
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    //
    // the stream extension structure is allocated by the stream class driver
    //
    PSTREAM         pStream                = (PSTREAM)pSrb->StreamObject->HwStreamExtension;
    PMPE_FILTER  pFilter                = (PMPE_FILTER)pSrb->HwDeviceExtension;
    ULONG           ulStreamNumber         = (ULONG) pSrb->StreamObject->StreamNumber;
    ULONG           ulStreamInstance       = pStream->ulStreamInstance;
    PHW_STREAM_REQUEST_BLOCK pCurrentSrb   = NULL;

    //
    // check that the stream index requested isn't too high
    // or that the maximum number of instances hasn't been exceeded
    //
    if (ulStreamNumber < DRIVER_STREAM_COUNT )
    {
        //
        // Flush the stream data queue
        //
        while (QueueRemove( &pCurrentSrb, &pFilter->IpV4StreamDataSpinLock, &pFilter->IpV4StreamDataQueue))
        {
           pCurrentSrb->Status = STATUS_CANCELLED;
           StreamClassStreamNotification( StreamRequestComplete, pCurrentSrb->StreamObject, pCurrentSrb);
           TEST_DEBUG( TEST_DBG_SRB, ("MPE 15Completed SRB %08X\n", pCurrentSrb));
        }

        //
        // Flush the stream data queue
        //
        while (QueueRemove( &pCurrentSrb, &pFilter->StreamDataSpinLock, &pFilter->StreamDataQueue))
        {
           pCurrentSrb->Status = STATUS_CANCELLED;
           StreamClassStreamNotification( StreamRequestComplete, pCurrentSrb->StreamObject, pCurrentSrb);
           TEST_DEBUG( TEST_DBG_SRB, ("MPE 16Completed SRB %08X\n", pCurrentSrb));
        }

        //
        // Flush the stream control queue
        //
        while (QueueRemove( &pCurrentSrb, &pFilter->StreamControlSpinLock, &pFilter->StreamControlQueue))
        {
           pCurrentSrb->Status = STATUS_CANCELLED;
           StreamClassStreamNotification (StreamRequestComplete, pCurrentSrb->StreamObject, pCurrentSrb);
           TEST_DEBUG( TEST_DBG_SRB, ("MPE 17Completed SRB %08X\n", pCurrentSrb));
        }

        //
        // Clear this streams spot in the filters stream array
        //
        pFilter->pStream[ulStreamNumber][ulStreamInstance] = NULL;

        //
        // decrement the stream instance count for this filter
        //
        pFilter->ulActualInstances[ulStreamNumber]--;


        //
        // Reset the stream state to stopped
        //
        pStream->KSState = KSSTATE_STOP;

        //
        //
        //
        pStream->hMasterClock = NULL;

        //
        // Cleanup the streams transform buffer
        //
        if (pStream->pTransformBuffer)
        {
            ExFreePool (pStream->pTransformBuffer);
            pStream->pTransformBuffer = NULL;
        }

        //
        // Reset the stream extension blob
        //
        RtlZeroMemory(pStream, sizeof (STREAM));

        pSrb->Status = STATUS_SUCCESS;

    }
    else
    {
        pSrb->Status = STATUS_INVALID_PARAMETER;
    }
}


//////////////////////////////////////////////////////////////////////////////
VOID
OpenStream (
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    //
    // the stream extension structure is allocated by the stream class driver
    //
    PSTREAM         pStream        = (PSTREAM)pSrb->StreamObject->HwStreamExtension;
    PMPE_FILTER    pFilter        = ((PMPE_FILTER)pSrb->HwDeviceExtension);
    ULONG           ulStreamNumber = (ULONG) pSrb->StreamObject->StreamNumber;
    PKSDATAFORMAT   pKSDataFormat  = (PKSDATAFORMAT)pSrb->CommandData.OpenFormat;

    //
    // Initialize the next stream life check time.
    //
    KeQuerySystemTime( &pFilter->liLastTimeChecked );

    //
    // check that the stream index requested isn't too high
    // or that the maximum number of instances hasn't been exceeded
    //
    if (ulStreamNumber < DRIVER_STREAM_COUNT )
    {
        ULONG ulStreamInstance;
        ULONG ulMaxInstances = Streams[ulStreamNumber].hwStreamInfo.NumberOfPossibleInstances;

        //
        // Search for next open slot
        //
        for (ulStreamInstance = 0; ulStreamInstance < ulMaxInstances; ++ulStreamInstance)
        {
            if (pFilter->pStream[ulStreamNumber][ulStreamInstance] == NULL)
            {
                break;
            }
        }

        if (ulStreamInstance < ulMaxInstances)
        {
            if (VerifyFormat(pKSDataFormat, ulStreamNumber, &pStream->MatchedFormat))
            {
                //
                // Initialize Data queues and SpinLocks
                //
                InitializeListHead(&pFilter->StreamControlQueue);
                KeInitializeSpinLock(&pFilter->StreamControlSpinLock);

                InitializeListHead(&pFilter->StreamDataQueue);
                KeInitializeSpinLock(&pFilter->StreamDataSpinLock);

                InitializeListHead(&pFilter->IpV4StreamDataQueue);
                KeInitializeSpinLock(&pFilter->IpV4StreamDataSpinLock);

                InitializeListHead(&pFilter->StreamContxList);
                KeInitializeSpinLock(&pFilter->StreamUserSpinLock);


                //
                // Maintain an array of all the StreamEx structures in the HwDevExt
                // so that we can reference IRPs from any stream
                //
                pFilter->pStream[ulStreamNumber][ulStreamInstance] = pStream;

                //
                // Save the Stream Format in the Stream Extension as well.
                //
                pStream->OpenedFormat = *pKSDataFormat;

                //
                // Set up pointers to the handlers for the stream data and control handlers
                //
                pSrb->StreamObject->ReceiveDataPacket =
                                                (PVOID) Streams[ulStreamNumber].hwStreamObject.ReceiveDataPacket;
                pSrb->StreamObject->ReceiveControlPacket =
                                                (PVOID) Streams[ulStreamNumber].hwStreamObject.ReceiveControlPacket;

                //
                // The DMA flag must be set when the device will be performing DMA directly
                // to the data buffer addresses passed in to the ReceiveDataPacket routines.
                //
                pSrb->StreamObject->Dma = Streams[ulStreamNumber].hwStreamObject.Dma;

                //
                // The PIO flag must be set when the mini driver will be accessing the data
                // buffers passed in using logical addressing
                //
                pSrb->StreamObject->Pio = Streams[ulStreamNumber].hwStreamObject.Pio;

                pSrb->StreamObject->Allocator = Streams[ulStreamNumber].hwStreamObject.Allocator;

                //
                // How many extra bytes will be passed up from the driver for each frame?
                //
                pSrb->StreamObject->StreamHeaderMediaSpecific =
                                        Streams[ulStreamNumber].hwStreamObject.StreamHeaderMediaSpecific;

                pSrb->StreamObject->StreamHeaderWorkspace =
                                        Streams[ulStreamNumber].hwStreamObject.StreamHeaderWorkspace;

                //
                // Indicate the clock support available on this stream
                //
                pSrb->StreamObject->HwClockObject =
                                        Streams[ulStreamNumber].hwStreamObject.HwClockObject;

                //
                // Increment the instance count on this stream
                //
                pStream->ulStreamInstance = ulStreamInstance;
                pFilter->ulActualInstances[ulStreamNumber]++;

                //
                // Allocate a transform buffer
                //
                pStream->pTransformBuffer = ExAllocatePool (NonPagedPool, sizeof(SECTION_HEADER) + 4096);

                if (pStream->pTransformBuffer == NULL)
                {
                    pSrb->Status = STATUS_NO_MEMORY;
                    return;
                }

                RtlZeroMemory (pStream->pTransformBuffer, sizeof(SECTION_HEADER) + 4096);

                //
                // Initalize persistent pointer to output buffer to NULL
                //
                pStream->pOut = NULL;

                //
                // Initialize the exepected section number to zero
                //
                pStream->bExpectedSection = 0;


                //
                // Retain a private copy of the HwDevExt and StreamObject in the stream extension
                // so we can use a timer
                //
                pStream->pFilter = pFilter;                     // For timer use
                pStream->pStreamObject = pSrb->StreamObject;        // For timer use


                pSrb->Status = STATUS_SUCCESS;

            }
            else
            {
                pSrb->Status = STATUS_INVALID_PARAMETER;
            }
        }
        else
        {
            pSrb->Status = STATUS_INVALID_PARAMETER;
        }

    }
    else
    {
        pSrb->Status = STATUS_INVALID_PARAMETER;
    }
}


//////////////////////////////////////////////////////////////////////////////
BOOLEAN
VerifyFormat(
    IN KSDATAFORMAT *pKSDataFormat,
    UINT StreamNumber,
    PKSDATARANGE pMatchedFormat
    )
//////////////////////////////////////////////////////////////////////////////
{
    BOOLEAN   bResult               = FALSE;
    ULONG     FormatCount           = 0;
    PKS_DATARANGE_VIDEO pThisFormat = NULL;

    TEST_DEBUG (TEST_DBG_TRACE, ("MPE: Verify Format\n"));

    for (FormatCount = 0; !bResult && FormatCount < Streams[StreamNumber].hwStreamInfo.NumberOfFormatArrayEntries;
         FormatCount++ )
    {


        pThisFormat = (PKS_DATARANGE_VIDEO) Streams [StreamNumber].hwStreamInfo.StreamFormatsArray [FormatCount];

        if (CompareGUIDsAndFormatSize( pKSDataFormat, &pThisFormat->DataRange, FALSE ) )
        {
            bResult = FALSE;

            if (pThisFormat->DataRange.SampleSize >= pKSDataFormat->SampleSize)
            {
                bResult = TRUE;
            }
            else
            {
                TEST_DEBUG (TEST_DBG_TRACE, ("MPE: VerifyFormat: Data range Sample Sizes don't match\n"));
            }
        }
    }

    if (bResult == TRUE && pMatchedFormat)
    {
        *pMatchedFormat = pThisFormat->DataRange;
    }

    return bResult;
}


///////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
GetOutputBuffer (
    PMPE_FILTER pFilter,
    PHW_STREAM_REQUEST_BLOCK *ppSrb,
    PUCHAR *ppBuffer,
    PULONG pulSize
    )
///////////////////////////////////////////////////////////////////////////////////////
{
    NTSTATUS status                   = STATUS_INSUFFICIENT_RESOURCES;
    PKSSTREAM_HEADER  pStreamHdr      = NULL;
    PHW_STREAM_REQUEST_BLOCK pSrb     = NULL;



    if (QueueRemove( &pSrb, &pFilter->IpV4StreamDataSpinLock, &pFilter->IpV4StreamDataQueue))
    {

        pStreamHdr = pSrb->CommandData.DataBufferArray;

        *ppSrb    = pSrb;
        *ppBuffer = pStreamHdr->Data;
        *pulSize  = pStreamHdr->FrameExtent;

        status = STATUS_SUCCESS;

    }

    return status;
}

//////////////////////////////////////////////////////////////////////////////
VOID
STREAMAPI
ReceiveDataPacket (
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    PMPE_FILTER       pFilter         = (PMPE_FILTER) pSrb->HwDeviceExtension;
    PSTREAM           pStream         = (PSTREAM)pSrb->StreamObject->HwStreamExtension;
    int               iStream         = (int) pSrb->StreamObject->StreamNumber;
    PKSSTREAM_HEADER  pStreamHdr      = pSrb->CommandData.DataBufferArray;
    PKSDATAFORMAT     pKSDataFormat   = (PKSDATAFORMAT) &pStream->MatchedFormat;
    ULONG             ul              = 0;
    PHW_STREAM_REQUEST_BLOCK pOutSrb  = NULL;
    SECTION_HEADER    Section         = {0};
    PSECTION_HEADER   pSection        = NULL;
    PUCHAR            pIn             = NULL;
    PLLC_SNAP         pSnap           = NULL;
    ULONG             ulSize          = 0;
    ULONG             ulLength        = 0;

    PHEADER_IP        pIP             = NULL;


    TEST_DEBUG (TEST_DBG_TRACE, ("MPE: Receive Data packet handler called\n"));

    //
    // Default to success, disable timeouts
    //
    pSrb->TimeoutCounter = 0;
    pSrb->Status = STATUS_SUCCESS;

    //
    // Check for last buffer
    //
    if (pStreamHdr->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_ENDOFSTREAM)
    {
        TEST_DEBUG (TEST_DBG_TRACE, ("MPE: Receive Data packet is LAST PACKET\n"));

        StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb);
        TEST_DEBUG( TEST_DBG_SRB, ("MPE 18Completed SRB %08X\n", pSrb));

        return;
    }


    if (pStreamHdr->OptionsFlags != 0)
    {
        TEST_DEBUG (TEST_DBG_TRACE, ("MPE: OptionsFlags: %08X\n", pStreamHdr->OptionsFlags));
    }


    //
    // determine the type of packet.
    //
    switch (pSrb->Command)
    {
        case SRB_WRITE_DATA:


            if (pStream->KSState == KSSTATE_STOP)
            {
                pSrb->Status = STATUS_SUCCESS;

                TEST_DEBUG (TEST_DBG_TRACE, ("MPE: SRB_WRITE STOP SRB Status returned: %08X\n", pSrb->Status));

                StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb );
                TEST_DEBUG( TEST_DBG_SRB, ("MPE 19Completed SRB %08X\n", pSrb));

                break;
            }

            //
            // Update the total number of packets written statistic
            //
            pFilter->Stats.ulTotalSectionsWritten += 1;


            //
            // Handle data input, output requests differently.
            //
            switch (iStream)
            {
                //
                //  Frame input stream
                //
                case MPE_STREAM:
                {
                    ULONG             ulBuffers        = pSrb->NumberOfBuffers;
                    ULONG             ulSkip           = 0;

                    TEST_DEBUG (TEST_DBG_TRACE, ("MPE: Receive Data packet handler - SRB_WRITE - MPE_STREAM\n"));

                    //
                    // Initialize SRB Status to success
                    //
                    pSrb->Status = STATUS_SUCCESS;

                    //
                    // copy the contents of all buffers into one big buffer
                    //
                    ASSERT( ulBuffers == 1);
                    {
                        //ASSERT( pStreamHdr);
                        //ASSERT( pStreamHdr->DataUsed <= (sizeof(SECTION_HEADER) + 4096));
                        if (   pStreamHdr
                            && (pStreamHdr->DataUsed <= (sizeof(SECTION_HEADER) + 4096))
                           )
                        {
                            // Copy the data
                            RtlCopyMemory (pStream->pTransformBuffer,
                                           pStreamHdr->Data,
                                           pStreamHdr->DataUsed
                                           );
                        }
                        else
                        	{
			   	            pFilter->Stats.ulTotalInvalidSections += 1;
	                     	StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb);
	                        pStream->bExpectedSection = 0;
        	                pStream->pOut = NULL;
                	        pOutSrb = NULL;
	                        TEST_DEBUG( TEST_DBG_SRB, ("MPE 20Completed SRB %08X\n - Invalid TableID", pSrb));
       	                	break;

                           }
                    }

                    //
                    // Process the transform buffer
                    //
                    pSection = (PSECTION_HEADER) pStream->pTransformBuffer;
                    NormalizeSection (pStream->pTransformBuffer, &Section);

                    //
                    // Do a quick check of the section header to confirm it looks valid
                    //
                    if (! ValidSection (&Section))
                    {
                        //  Ignore non-MPE sections
                        //
                        StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb);
                        pStream->bExpectedSection = 0;

                        pFilter->Stats.ulTotalInvalidSections += 1;

                        //
                        // Since we're discarding the data at this point, we'll re-queue the output
                        // SRB and re-use it when we get re-synched.
                        //
                        if (pOutSrb)
                        {
                            //$REVIEW - Can this cause out of order completion of sections.
                            //
                            QueuePush (pOutSrb, &pFilter->IpV4StreamDataSpinLock, &pFilter->IpV4StreamDataQueue);
                        }
                        pStream->pOut = NULL;
                        pOutSrb = NULL;
                        TEST_DEBUG( TEST_DBG_SRB, ("MPE 20Completed SRB %08X\n - Invalid TableID", pSrb));
                        break;
                    }

                    //
                    // Update our UnNormalized section header with our normalized one.
                    //
		      RtlCopyMemory (pStream->pTransformBuffer, &Section, sizeof (SECTION_HEADER));

                    //
                    // Check our section number and see if it's what we expect
                    //
                    if (pSection->section_number != pStream->bExpectedSection)
                    {
                        StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb);
                        pStream->bExpectedSection = 0;

                        pFilter->Stats.ulTotalUnexpectedSections += 1;

                        //
                        // Since we're discarding the data at this point, we'll re-queue the output
                        // SRB and re-use it when we get re-synched.
                        //
                        if (pOutSrb)
                        {
                            //$REVIEW - Can this cause out of order completion of sections.
                            //
                            QueuePush (pOutSrb, &pFilter->IpV4StreamDataSpinLock, &pFilter->IpV4StreamDataQueue);
                        }
                        pStream->pOut = NULL;
                        pOutSrb = NULL;
                        TEST_DEBUG( TEST_DBG_SRB, ("MPE 20Completed SRB %08X\n - Invalid section_number", pSrb));
                        break;
                    }

                    //
                    // Process the 1st section
                    //
                    if (pSection->section_number == 0)
                    {
                        PMAC_Address pMAC = NULL;

                        //
                        // Initialize packet length to zero
                        //
                        ulLength = 0;

                        //
                        //
                        //
                        if (GetOutputBuffer (pFilter, &pOutSrb, &pStream->pOut, &ulSize) != STATUS_SUCCESS)
                        {
                            //
                            // Failure....no buffers available most likely
                            //
                            pFilter->Stats.ulTotalUnavailableOutputBuffers += 1;
                            StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb);
                            TEST_DEBUG( TEST_DBG_SRB, ("MPE 20Completed SRB %08X\n - Can't get SRB for output pin", pSrb));
                            break;
                        }

                        if (ulSize < (pSection->section_length - (sizeof (SECTION_HEADER) - 3)))
                        {
                            StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb);
                            pStream->bExpectedSection = 0;
                            pFilter->Stats.ulTotalOutputBuffersTooSmall += 1;

                            //
                            // Since we're discarding the data at this point, we'll re-queue the output
                            // SRB and re-use it when we get re-synched.
                            //
                            if (pOutSrb)
                            {
                                //$REVIEW - Can this cause out of order completion of sections.
                                //
                                QueuePush (pOutSrb, &pFilter->IpV4StreamDataSpinLock, &pFilter->IpV4StreamDataQueue);
                            }
                            pStream->pOut = NULL;
                            pOutSrb = NULL;

                            TEST_DEBUG( TEST_DBG_SRB, ("MPE 20Completed SRB %08X\n - Section too big", pSrb));
                            break;
                        }

                        pIP = (PHEADER_IP) pSection->Data;
                        if (pSection->LLC_SNAP_flag == 0x1)
                        {
                            pSnap = (PLLC_SNAP) pSection->Data;
                            pIP = (PHEADER_IP) pSnap->Data;
                            ulSkip = sizeof( LLC_SNAP);
                        }

                        //
                        // Add the MAC address to the buffer.  The MAC address prefix's the IP packet
                        //
                        pMAC = (PMAC_Address) pStream->pOut;
                        pMAC->MAC_Dest_Address [0] = pSection->MAC_address_1;
                        pMAC->MAC_Dest_Address [1] = pSection->MAC_address_2;
                        pMAC->MAC_Dest_Address [2] = pSection->MAC_address_3;
                        pMAC->MAC_Dest_Address [3] = pSection->MAC_address_4;
                        pMAC->MAC_Dest_Address [4] = pSection->MAC_address_5;
                        pMAC->MAC_Dest_Address [5] = pSection->MAC_address_6;

                        pMAC->MAC_Src_Address [0] = 0x00;
                        pMAC->MAC_Src_Address [1] = 0x00;
                        pMAC->MAC_Src_Address [2] = 0x00;
                        pMAC->MAC_Src_Address [3] = 0x00;
                        pMAC->MAC_Src_Address [4] = 0x00;
                        pMAC->MAC_Src_Address [5] = 0x00;

                        pMAC->usLength = 0x0008;

                        //
                        // Adjust pointer to output buffer where we'll put data
                        //
                        pStream->pOut += sizeof (MAC_Address);

                        pIn = pSection->Data;

                        if (pSection->LLC_SNAP_flag == 0x1)
                        {
                            pSnap = (PLLC_SNAP) pSection->Data;

                            if (pSnap->type != 0x0008)
                            {
                                StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb);

                                //
                                // Next expected Section should be zero
                                //
                                pStream->bExpectedSection = 0;
                                pFilter->Stats.ulTotalInvalidIPSnapHeaders += 1;

                                //
                                // Since we're discarding the data at this point, we'll re-queue the output
                                // SRB and re-use it when we get re-synched.
                                //
                                if (pOutSrb)
                                {
                                    //$REVIEW - Can this cause out of order completion of sections.
                                    //
                                    QueuePush (pOutSrb, &pFilter->IpV4StreamDataSpinLock, &pFilter->IpV4StreamDataQueue);
                                }
                                pStream->pOut = NULL;
                                pOutSrb = NULL;

                                TEST_DEBUG( TEST_DBG_SRB, ("MPE 20Completed SRB %08X\n - Bad Snap Type", pSrb));
                                break;
                            }

                            pIn = pSnap->Data;

                        }

                        ulLength = sizeof (MAC_Address);
                    }

                    //
                    // pOut should be NULL unless we've found the 1st section.
                    //
                    if (pStream->pOut)
                    {
                        ULONG ulTmp = 0;
                        PKSSTREAM_HEADER  pOutStreamHdr;

                        //
                        // Update the datasize field of the Output SRB
                        //
                        pOutStreamHdr = (PKSSTREAM_HEADER) pOutSrb->CommandData.DataBufferArray;


                        //
                        // Copy data from transform section to output SRB buffer
                        //
                        // Compute the number of bytes to copy.  We subtract of 9 bytes
                        // only if this is a LLSNAP packet.
                        //
                        ulTmp  = pSection->section_length;
                        ulTmp -= ulSkip;


                        ASSERT(pIn);
                        ASSERT(pStream->pOut);
	              

                        if (ulSize < (ulTmp +sizeof (MAC_Address) +3))
                        {
                            StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb);
                            pStream->bExpectedSection = 0;
                            pFilter->Stats.ulTotalOutputBuffersTooSmall += 1;

                            //
                            // Since we're discarding the data at this point, we'll re-queue the output
                            // SRB and re-use it when we get re-synched.
                            //
                            if (pOutSrb)
                            {
                                //$REVIEW - Can this cause out of order completion of sections.
                                //
                                QueuePush (pOutSrb, &pFilter->IpV4StreamDataSpinLock, &pFilter->IpV4StreamDataQueue);
                            }
                            pStream->pOut = NULL;
                            pOutSrb = NULL;

                            TEST_DEBUG( TEST_DBG_SRB, ("MPE 20Completed SRB %08X\n - Section too big", pSrb));
                            break;
                        }

	              
		       RtlCopyMemory (pStream->pOut, pIn, ulTmp);
                       ulLength += ulTmp;
                       pOutStreamHdr->DataUsed += ulLength;

                        ulLength = 0;
		 }

                    if (pSection->section_number == pSection->last_section_number)
                    {

                        pFilter->Stats.ulTotalIPPacketsWritten += 1;

                        pOutSrb->Status = STATUS_SUCCESS;
                        StreamClassStreamNotification (StreamRequestComplete, pOutSrb->StreamObject, pOutSrb);
                        TEST_DEBUG( TEST_DBG_SRB, ("MPE 20Completed SRB %08X\n", pSrb));

                        pOutSrb = NULL;
                        pStream->pOut    = NULL;
                        ulSize  = 0;
                    }
                    else
                    {
                     if (pOutSrb)
                            {
                                //$REVIEW - Can this cause out of order completion of sections.
                                //
                                QueuePush (pOutSrb, &pFilter->IpV4StreamDataSpinLock, &pFilter->IpV4StreamDataQueue);
                            }

                    }


                    StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb);
                    TEST_DEBUG( TEST_DBG_SRB, ("MPE 20Completed SRB %08X\n - Packet Sent", pSrb));

                }
                break;


                default:
                    TEST_DEBUG (TEST_DBG_TRACE, ("MPE: Receive Data packet handler called - SRB_WRITE - Default\n"));
                    pSrb->Status = STATUS_NOT_IMPLEMENTED;

                    //
                    // Update stats for Unkown packet count
                    //
                    pFilter->Stats.ulTotalUnknownPacketsWritten += 1;

                    TEST_DEBUG (TEST_DBG_TRACE, ("MPE: DEFAULT SRB Status returned: %08X\n", pSrb->Status));

                    StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb);
                    TEST_DEBUG( TEST_DBG_SRB, ("MPE 22Completed SRB %08X\n", pSrb));

                    break;
            }
            break;


        case SRB_READ_DATA:

            if (pStream->KSState == KSSTATE_STOP)
            {
                pSrb->Status = STATUS_SUCCESS;
                TEST_DEBUG (TEST_DBG_TRACE, ("MPE: SRB_READ STOP SRB Status returned: %08X\n", pSrb->Status));

                StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb );
                TEST_DEBUG( TEST_DBG_SRB, ("MPE 23Completed SRB %08X\n", pSrb));

                break;
            }

            //
            // Update stats for Unkown packet count
            //
            pFilter->Stats.ulTotalPacketsRead += 1;

            switch (iStream)
            {
                #ifdef OLD

                case MPE_NET_CONTROL:
                    TEST_DEBUG (TEST_DBG_TRACE, ("MPE: Receive Data packet handler called - SRB_READ - STREAM_NET_CONTROL\n"));
                    pSrb->Status = STATUS_SUCCESS;
                    TEST_DEBUG (TEST_DBG_TRACE, ("MPE: MPE_NET_CONTROL SRB Status returned: %08X\n", pSrb->Status));
                    StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb);
                    TEST_DEBUG( TEST_DBG_SRB, ("MPE 24Completed SRB %08X\n", pSrb));
                    break;

                #endif

                case MPE_IPV4:
                {
                    ULONG             ulBuffers       = pSrb->NumberOfBuffers;

                    TEST_DEBUG (TEST_DBG_TRACE, ("MPE: Receive Data packet handler called - SRB_READ - MPE_IPV4\n"));

                    if (pSrb->CommandData.DataBufferArray->FrameExtent < pKSDataFormat->SampleSize)
                    {
                        pSrb->Status = STATUS_BUFFER_TOO_SMALL;
                        TEST_DEBUG (TEST_DBG_TRACE, ("MPE: MPE_IPV4 SRB Buffer too small.... Status returned: %08X\n", pSrb->Status));
                        StreamClassStreamNotification(StreamRequestComplete, pSrb->StreamObject, pSrb);
                        TEST_DEBUG( TEST_DBG_SRB, ("MPE 25Completed SRB %08X\n", pSrb));
                    }
                    else
                    {
                        //
                        // Take the SRB we get and  queue it up.  These Queued SRB's will be filled with data on a WRITE_DATA
                        // request, at which point they will be completed.
                        //
                        QueueAdd (pSrb, &pFilter->IpV4StreamDataSpinLock, &pFilter->IpV4StreamDataQueue);
                        TEST_DEBUG( TEST_DBG_SRB, ("MPE Queuing IPv4 SRB %08X\n", pSrb));


                        //
                        // Since the stream state may have changed while we were adding the SRB to the queue
                        // we'll check it again, and cancel it if necessary
                        //
                        if (pStream->KSState == KSSTATE_STOP)
                        {
                            TEST_DEBUG (TEST_DBG_TRACE, ("MPE: SRB_READ STOP SRB Status returned: %08X\n", pSrb->Status));

                            if (QueueRemoveSpecific (pSrb, &pFilter->IpV4StreamDataSpinLock, &pFilter->IpV4StreamDataQueue))
                            {
                                pSrb->Status = STATUS_CANCELLED;
                                StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb );
                                TEST_DEBUG( TEST_DBG_SRB, ("MPE 26Completed SRB %08X\n", pSrb));
                                return;
                            }
                            break;
                        }
                        
                    }
                }
                break;


                default:
                    TEST_DEBUG (TEST_DBG_TRACE, ("MPE: Receive Data packet handler called - SRB_READ - Default\n"));
                    pSrb->Status = STATUS_NOT_IMPLEMENTED;
                    TEST_DEBUG (TEST_DBG_TRACE, ("MPE: DEFAULT SRB Status returned: %08X\n", pSrb->Status));
                    StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb);
                    TEST_DEBUG( TEST_DBG_SRB, ("MPE 27Completed SRB %08X\n", pSrb));
                    break;

            }
            break;

        default:

            //
            // invalid / unsupported command. Fail it as such
            //
            TEST_DEBUG (TEST_DBG_TRACE, ("MPE: Receive Data packet handler called - Unsupported Command\n"));
            pSrb->Status = STATUS_NOT_IMPLEMENTED;
            TEST_DEBUG (TEST_DBG_TRACE, ("MPE: DEFAULT SRB Status returned: %08X\n", pSrb->Status));
            StreamClassStreamNotification( StreamRequestComplete, pSrb->StreamObject, pSrb );
            TEST_DEBUG( TEST_DBG_SRB, ("MPE 28Completed SRB %08X\n", pSrb));
            ASSERT (FALSE);
            break;

    }


    TEST_DEBUG (TEST_DBG_TRACE, ("MPE: Receive Data packet handler called...status: %08X\n", pSrb->Status));

    return;
}



//////////////////////////////////////////////////////////////////////////////
VOID
MpeGetProperty (
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;

    pSrb->Status = STATUS_SUCCESS;

    if (IsEqualGUID (&KSPROPSETID_Connection, &pSPD->Property->Set))
    {
        MpeGetConnectionProperty (pSrb);
    }
    else
    {
        pSrb->Status = STATUS_NOT_IMPLEMENTED;
    }

    TEST_DEBUG (TEST_DBG_TRACE, ("MPE: MpeGetProperty Status: %08X\n", pSrb->Status));

    return;
}


//////////////////////////////////////////////////////////////////////////////
VOID
IndicateMasterClock(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    PSTREAM pStream = (PSTREAM) pSrb->StreamObject->HwStreamExtension;

    pStream->hClock = pSrb->CommandData.MasterClockHandle;
}

//////////////////////////////////////////////////////////////////////////////
VOID
STREAMAPI
ReceiveCtrlPacket(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    PMPE_FILTER pFilter = (PMPE_FILTER) pSrb->HwDeviceExtension;
    PSTREAM pStream = (PSTREAM) pSrb->StreamObject->HwStreamExtension;

    TEST_DEBUG (TEST_DBG_TRACE, ("MPE: Receive Control packet handler called\n"));

    pSrb->Status = STATUS_SUCCESS;

    QueueAdd (pSrb, &pFilter->StreamControlSpinLock, &pFilter->StreamControlQueue);
    TEST_DEBUG( TEST_DBG_SRB, ("MPE Queuing Control Packet SRB %08X\n", pSrb));

    while (QueueRemove (&pSrb, &pFilter->StreamControlSpinLock, &pFilter->StreamControlQueue))
    {
        //
        // determine the type of packet.
        //
        switch (pSrb->Command)
        {
            case SRB_PROPOSE_DATA_FORMAT:
                TEST_DEBUG (TEST_DBG_TRACE, ("MPE: Receive Control packet handler - Propose data format\n"));
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
                break;

            case SRB_SET_STREAM_STATE:
                TEST_DEBUG (TEST_DBG_TRACE, ("MPE: Receive Control packet handler - Set Stream State\n"));
                pSrb->Status = STATUS_SUCCESS;
                MpeSetState (pSrb);
                break;

            case SRB_GET_STREAM_STATE:
                TEST_DEBUG (TEST_DBG_TRACE, ("MPE: Receive Control packet handler - Get Stream State\n"));
                pSrb->Status = STATUS_SUCCESS;
                pSrb->CommandData.StreamState = pStream->KSState;
                pSrb->ActualBytesTransferred = sizeof (KSSTATE);
                break;

            case SRB_GET_STREAM_PROPERTY:
                TEST_DEBUG (TEST_DBG_TRACE, ("MPE: Receive Control packet handler - Get Stream Property\n"));
                MpeGetProperty(pSrb);
                break;

            case SRB_SET_STREAM_PROPERTY:
                TEST_DEBUG (TEST_DBG_TRACE, ("MPE: Receive Control packet handler - Set Stream Property\n"));
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
                break;

            case SRB_INDICATE_MASTER_CLOCK:
                TEST_DEBUG (TEST_DBG_TRACE, ("MPE: Receive Control packet handler - Indicate Master Clock\n"));
                pSrb->Status = STATUS_SUCCESS;
                IndicateMasterClock (pSrb);
                break;

            case SRB_SET_STREAM_RATE:
                TEST_DEBUG (TEST_DBG_TRACE, ("MPE: Receive Control packet handler - Set Stream Rate\n"));
                pSrb->Status = STATUS_SUCCESS;
                break;

            case SRB_PROPOSE_STREAM_RATE:
                TEST_DEBUG (TEST_DBG_TRACE, ("MPE: Receive Control packet handler - Propose Stream Rate\n"));
                pSrb->Status = STATUS_SUCCESS;
                break;

            default:
                TEST_DEBUG (TEST_DBG_TRACE, ("MPE: Receive Control packet handler - Default case\n"));
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
                break;

        }

        TEST_DEBUG (TEST_DBG_TRACE, ("MPE: SRB Status returned: %08X\n", pSrb->Status));

        StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb);
        TEST_DEBUG( TEST_DBG_SRB, ("MPE 29Completed SRB %08X\n", pSrb));

    }

}



//////////////////////////////////////////////////////////////////////////////
VOID
MpeSetState(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    PMPE_FILTER pFilter                 = ((PMPE_FILTER) pSrb->HwDeviceExtension);
    PSTREAM pStream                      = (PSTREAM) pSrb->StreamObject->HwStreamExtension;
    PHW_STREAM_REQUEST_BLOCK pCurrentSrb = NULL;

    //
    // For each stream, the following states are used:
    //
    // Stop:    Absolute minimum resources are used.  No outstanding IRPs.
    // Acquire: KS only state that has no DirectShow correpondence
    //          Acquire needed resources.
    // Pause:   Getting ready to run.  Allocate needed resources so that
    //          the eventual transition to Run is as fast as possible.
    //          Read SRBs will be queued at either the Stream class
    //          or in your driver (depending on when you send "ReadyForNext")
    // Run:     Streaming.
    //
    // Moving to Stop to Run always transitions through Pause.
    //
    // But since a client app could crash unexpectedly, drivers should handle
    // the situation of having outstanding IRPs cancelled and open streams
    // being closed WHILE THEY ARE STREAMING!
    //
    // Note that it is quite possible to transition repeatedly between states:
    // Stop -> Pause -> Stop -> Pause -> Run -> Pause -> Run -> Pause -> Stop
    //
    switch (pSrb->CommandData.StreamState)
    {
        case KSSTATE_STOP:

            TEST_DEBUG (TEST_DBG_TRACE, ("MPE: Set Stream State KSSTATE_STOP\n"));

            pStream->KSState = pSrb->CommandData.StreamState; 
            //
            // If transitioning to STOP state, then complete any outstanding IRPs
            //
            while (QueueRemove(&pCurrentSrb, &pFilter->IpV4StreamDataSpinLock, &pFilter->IpV4StreamDataQueue))
            {
                pCurrentSrb->Status = STATUS_CANCELLED;
                pCurrentSrb->CommandData.DataBufferArray->DataUsed = 0;

                StreamClassStreamNotification(StreamRequestComplete, pCurrentSrb->StreamObject, pCurrentSrb);
                TEST_DEBUG( TEST_DBG_SRB, ("MPE 30Completed SRB %08X\n", pCurrentSrb));
           }
           while (QueueRemove(&pCurrentSrb, &pFilter->StreamControlSpinLock, &pFilter->StreamControlQueue))
            {
                pCurrentSrb->Status = STATUS_CANCELLED;
                pCurrentSrb->CommandData.DataBufferArray->DataUsed = 0;

                StreamClassStreamNotification(StreamRequestComplete, pCurrentSrb->StreamObject, pCurrentSrb);
                TEST_DEBUG( TEST_DBG_SRB, ("MPE 30Completed SRB %08X\n", pCurrentSrb));
            }

            while (QueueRemove(&pCurrentSrb, &pFilter->StreamDataSpinLock, &pFilter->StreamDataQueue))
            {
                pCurrentSrb->Status = STATUS_CANCELLED;
                pCurrentSrb->CommandData.DataBufferArray->DataUsed = 0;

                StreamClassStreamNotification(StreamRequestComplete, pCurrentSrb->StreamObject, pCurrentSrb);
                TEST_DEBUG( TEST_DBG_SRB, ("MPE 30Completed SRB %08X\n", pCurrentSrb));
            }

            while (QueueRemove(&pCurrentSrb, &pFilter->StreamUserSpinLock, &pFilter->StreamContxList))
            {
                pCurrentSrb->Status = STATUS_CANCELLED;
                pCurrentSrb->CommandData.DataBufferArray->DataUsed = 0;

                StreamClassStreamNotification(StreamRequestComplete, pCurrentSrb->StreamObject, pCurrentSrb);
                TEST_DEBUG( TEST_DBG_SRB, ("MPE 30Completed SRB %08X\n", pCurrentSrb));
            }
              
            
            pSrb->Status = STATUS_SUCCESS;
            break;


        case KSSTATE_ACQUIRE:
            TEST_DEBUG (TEST_DBG_TRACE, ("MPE: Set Stream State KSSTATE_ACQUIRE\n"));
            pStream->KSState = pSrb->CommandData.StreamState;
            pSrb->Status = STATUS_SUCCESS;
            break;

        case KSSTATE_PAUSE:
            TEST_DEBUG (TEST_DBG_TRACE, ("MPE: Set Stream State KSSTATE_PAUSE\n"));
            pStream->KSState = pSrb->CommandData.StreamState;
            pSrb->Status = STATUS_SUCCESS;
            break;

        case KSSTATE_RUN:
            TEST_DEBUG (TEST_DBG_TRACE, ("MPE: Set Stream State KSSTATE_RUN\n"));
            pStream->KSState = pSrb->CommandData.StreamState;
            pSrb->Status = STATUS_SUCCESS;
            break;

    } // end switch (pSrb->CommandData.StreamState)

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\bda\mpe\mpe.h ===
/////////////////////////////////////////////////////////////////////////////
//
//
// Copyright (c) 1996, 1997  Microsoft Corporation
//
//
// Module Name:
//      Mpe.h
//
// Abstract:
//
//
// Author:
//
//      P Porzuczek
//
// Environment:
//
// Revision History:
//
//
//////////////////////////////////////////////////////////////////////////////

#ifndef _MPE_H_
#define _MPE_H_

#define ENTRIES(a)  (sizeof(a)/sizeof(*(a)))

///////////////////////////////////////////////////////////////////////////////
//
//
#define MPENAME            "MPE"
#define MPENAMEUNICODE    L"MPE"

///////////////////////////////////////////////////////////////////////////////
//
// This defines the name of the WMI device that manages service IOCTLS
//
#define CodecDeviceName   (L"\\\\.\\" MPENAMEUNICODE)
#define CodecSymbolicName (L"\\DosDevices\\" MPENAMEUNICODE)


///////////////////////////////////////////////////////////////////////////////
//
//
typedef struct
{
    ULONG ulSize;
    UCHAR data;

} MPE_BUFFER, *PMPE_BUFFER;


///////////////////////////////////////////////////////////////////////////////
//
//
typedef enum
{
    MPE_STREAM = 0,
    MPE_IPV4

} MPE_STREAMS;

///////////////////////////////////////////////////////////////////////////////
//
// The MAX_STREAM_COUNT value must be equal to DRIVER_STREAM_COUNT
// This particular value must be defined here to avoid circular references
//
#define MAX_STREAM_COUNT    DRIVER_STREAM_COUNT



/////////////////////////////////////////////////////////////////////////////
//
//
//
typedef NTSTATUS (*QUERY_INTERFACE) (PVOID pvContext);
typedef ULONG    (*ADD_REF) (PVOID pvContext);
typedef ULONG    (*RELEASE) (PVOID pvContext);



/////////////////////////////////////////////////////////////////////////////
//
//
//
typedef struct _STATS_
{
    ULONG ulTotalSectionsWritten;
    ULONG ulTotalPacketsRead;

    ULONG ulTotalInvalidSections;
    ULONG ulTotalUnexpectedSections;
    ULONG ulTotalUnavailableOutputBuffers;
    ULONG ulTotalOutputBuffersTooSmall;
    ULONG ulTotalInvalidIPSnapHeaders;
    ULONG ulTotalIPPacketsWritten;

    ULONG ulTotalIPBytesWritten;
    ULONG ulTotalIPFrameBytesWritten;

    ULONG ulTotalNetPacketsWritten;
    ULONG ulTotalUnknownPacketsWritten;

} STATS, *PSTATS;


/////////////////////////////////////////////////////////////////////////////
//
//
//
typedef struct
{
    QUERY_INTERFACE          QueryInterface;
    ADD_REF                  AddRef;
    RELEASE                  Release;

} FILTER_VTABLE, *PFILTER_VTABLE;


/////////////////////////////////////////////////////////////////////////////
//
//
// definition of the full HW device extension structure This is the structure
// that will be allocated in HW_INITIALIZATION by the stream class driver
// Any information that is used in processing a device request (as opposed to
// a STREAM based request) should be in this structure.  A pointer to this
// structure will be passed in all requests to the minidriver. (See
// HW_STREAM_REQUEST_BLOCK in STRMINI.H)
//
typedef struct _MPE_FILTER_
{

    LIST_ENTRY                          AdapterSRBQueue;
    KSPIN_LOCK                          AdapterSRBSpinLock;
    BOOLEAN                             bAdapterQueueInitialized;

    //
    //
    //
    BOOLEAN                             bInitializationComplete;

    //
    // Statistics
    //
    STATS                               Stats;

    //
    //
    //
    PDEVICE_OBJECT                      DeviceObject;

    //
    //
    //
    PDRIVER_OBJECT                      DriverObject;

    //
    //
    //
    PFILTER_VTABLE                      lpVTable;

    //
    //
    //
    ULONG                               ulRefCount;

    //
    //
    //
    PVOID                               pStream [2][1];

    //
    //
    //
    ULONG                               ulActualInstances [2];   // Count of instances per stream

    //
    //
    //
    KSPIN_LOCK                          IpV4StreamDataSpinLock; // Data queue spin lock
    LIST_ENTRY                          IpV4StreamDataQueue;    // Stream data queue

    KSPIN_LOCK                          StreamControlSpinLock;  // Command queue spin lock
    LIST_ENTRY                          StreamControlQueue;     // Stream command queue

    KSPIN_LOCK                          StreamDataSpinLock;     // Data queue spin lock
    LIST_ENTRY                          StreamDataQueue;        // Stream data queue

    //
    //
    //
    KSPIN_LOCK                          StreamUserSpinLock;
    LIST_ENTRY                          StreamContxList;
    LARGE_INTEGER                       liLastTimeChecked;

    BOOLEAN                             bDiscontinuity;


} MPE_FILTER, *PMPE_FILTER;

/////////////////////////////////////////////////////////////////////////////
//
// this structure is our per stream extension structure.  This stores
// information that is relevant on a per stream basis.  Whenever a new stream
// is opened, the stream class driver will allocate whatever extension size
// is specified in the HwInitData.PerStreamExtensionSize.
//

typedef struct _STREAM_
{
    PMPE_FILTER                         pFilter;
    PHW_STREAM_OBJECT                   pStreamObject;          // For timer use
    KSSTATE                             KSState;                // Run, Stop, Pause
    HANDLE                              hMasterClock;
    HANDLE                              hClock;
    ULONG                               ulStreamInstance;       // 0..NumberOfPossibleInstances-1
    KSDATAFORMAT                        OpenedFormat;           // Based on the actual open request.

    KSDATARANGE                         MatchedFormat;

    ULONG                               Type;                   // type of this structure
    ULONG                               Size;                   // size of this structure

    PUCHAR                              pTransformBuffer;       // temp buffer used for translating MPE to IP
    PUCHAR                              pOut;                   // pointer to next insertion point in output buffer

    BYTE                                bExpectedSection;       // expected section number

} STREAM, *PSTREAM;

///////////////////////////////////////////////////////////////////////////////
//
// This structure is our per SRB extension, and carries the forward and backward
// links for the pending SRB queue.
//
typedef struct _SRB_EXTENSION
{
    LIST_ENTRY                      ListEntry;
    PHW_STREAM_REQUEST_BLOCK        pSrb;

} SRB_EXTENSION, *PSRB_EXTENSION;


//////////////////////////////////////////////////////////////////////////////
//
// the following section defines prototypes for the minidriver initialization
// routines
//

BOOLEAN
CodecInitialize (
    IN OUT PHW_STREAM_REQUEST_BLOCK pSrb
    );


BOOLEAN
CodecUnInitialize(
    PHW_STREAM_REQUEST_BLOCK pSrb
    );



VOID
CodecStreamInfo(
    PHW_STREAM_REQUEST_BLOCK pSrb
    );

VOID
CodecOpenStream(
    PHW_STREAM_REQUEST_BLOCK pSrb
    );

VOID
CodecCloseStream(
    PHW_STREAM_REQUEST_BLOCK pSrb
    );

VOID STREAMAPI
CodecReceivePacket(
    IN PHW_STREAM_REQUEST_BLOCK Srb
    );

VOID STREAMAPI
CodecCancelPacket(
    IN PHW_STREAM_REQUEST_BLOCK Srb
    );

VOID STREAMAPI
CodecTimeoutPacket(
    IN PHW_STREAM_REQUEST_BLOCK Srb
    );

VOID STREAMAPI
CodecGetProperty(
    IN PHW_STREAM_REQUEST_BLOCK Srb
    );

VOID STREAMAPI
CodecSetProperty(
    IN PHW_STREAM_REQUEST_BLOCK Srb
    );

BOOL
CodecVerifyFormat(
    IN KSDATAFORMAT *pKSDataFormat,
    UINT StreamNumber,
    PKSDATARANGE pMatchedFormat
    );

BOOL
CodecFormatFromRange(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    );

/////////////////////////////////////////////////////////////////////////////////////
//
// SRB Queue Management functions
//
BOOL STREAMAPI
QueueAddIfNotEmpty(
    IN PHW_STREAM_REQUEST_BLOCK,
    IN PKSPIN_LOCK,
    IN PLIST_ENTRY
    );

BOOL STREAMAPI
QueueAdd(
    IN PHW_STREAM_REQUEST_BLOCK,
    IN PKSPIN_LOCK,
    IN PLIST_ENTRY
    );

BOOL STREAMAPI
QueueRemove(
    IN OUT PHW_STREAM_REQUEST_BLOCK *,
    IN PKSPIN_LOCK,
    IN PLIST_ENTRY
    );

BOOL STREAMAPI
QueuePush (
    IN PHW_STREAM_REQUEST_BLOCK pSrb,
    IN PKSPIN_LOCK pQueueSpinLock,
    IN PLIST_ENTRY pQueue
    );

BOOL STREAMAPI
QueueRemoveSpecific(
    IN PHW_STREAM_REQUEST_BLOCK,
    IN PKSPIN_LOCK,
    IN PLIST_ENTRY
    );

BOOL STREAMAPI
QueueEmpty(
    IN PKSPIN_LOCK,
    IN PLIST_ENTRY
    );

VOID
STREAMAPI
CodecReceivePacket(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    );

BOOLEAN
CodecInitialize (
    IN OUT PHW_STREAM_REQUEST_BLOCK pSrb
    );

VOID
STREAMAPI
CodecCancelPacket(
    PHW_STREAM_REQUEST_BLOCK pSrb
    );

VOID
STREAMAPI
CodecTimeoutPacket(
    PHW_STREAM_REQUEST_BLOCK pSrb
    );


BOOL
CompareGUIDsAndFormatSize(
    IN PKSDATARANGE pDataRange1,
    IN PKSDATARANGE pDataRange2,
    BOOLEAN bCheckSize
    );

BOOL
CompareStreamFormat (
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    );

BOOLEAN
VerifyFormat(
    IN KSDATAFORMAT *pKSDataFormat,
    UINT StreamNumber,
    PKSDATARANGE pMatchedFormat
    );

VOID
OpenStream (
    PHW_STREAM_REQUEST_BLOCK pSrb
    );

VOID
CloseStream (
    PHW_STREAM_REQUEST_BLOCK pSrb
    );

VOID
STREAMAPI
ReceiveDataPacket (
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    );

VOID
STREAMAPI
ReceiveCtrlPacket(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    );

VOID
MpeSetState(
    PHW_STREAM_REQUEST_BLOCK pSrb
    );

VOID
MpeGetState(
    PHW_STREAM_REQUEST_BLOCK pSrb
    );


#endif  // _MPE_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\bda\samples\bdacapture\bdacap.h ===
/**************************************************************************

    BDA/AVStream Simulated Hardware Sample

    Copyright (c) 2001, Microsoft Corporation.

    File:

        BdaCap.h

    Abstract:

        BDA/AVStream Simulated Hardware Sample header file.  This is the 
        main header.

    History:

        created 3/12/2001

**************************************************************************/

/*************************************************

    Standard Includes

*************************************************/

extern "C" {
#include <wdm.h>
}

#include <windef.h>
#include <stdio.h>
#include <stdlib.h>
#include <windef.h>
#define NOBITMAP
#include <mmreg.h>
#undef NOBITMAP
#include <unknown.h>
#include <ks.h>
#include <ksmedia.h>
#include <bdatypes.h>
#include <bdamedia.h>
#include <kcom.h>

/*************************************************

    Misc Definitions

*************************************************/

#define ABS(x) ((x) < 0 ? (-(x)) : (x))
#define MS_SAMPLE_CAPTURE_POOL_TAG 'CadB'

#ifndef mmioFOURCC    
#define mmioFOURCC( ch0, ch1, ch2, ch3 )                \
        ( (DWORD)(BYTE)(ch0) | ( (DWORD)(BYTE)(ch1) << 8 ) |    \
        ( (DWORD)(BYTE)(ch2) << 16 ) | ( (DWORD)(BYTE)(ch3) << 24 ) )
#endif

#define FOURCC_YUV422       mmioFOURCC('U', 'Y', 'V', 'Y')

//
// CAPTURE_OUT_PIN_DATA_RANGE_COUNT:
//
// The number of ranges supported on the capture output pin.
//
#define CAPTURE_OUT_PIN_DATA_RANGE_COUNT 1

//
// CAPTURE_IN_PIN_DATA_RANGE_COUNT:
//
// The number of ranges supported on the capture input pin.
//
#define CAPTURE_IN_PIN_DATA_RANGE_COUNT 1

//
// CAPTURE_FILTER_PIN_COUNT:
//
// The number of pins on the capture filter.
//
#define CAPTURE_FILTER_PIN_COUNT 2

//
// CAPTURE_FILTER_CATEGORIES_COUNT:
//
// The number of categories for the capture filter.
//
#define CAPTURE_FILTER_CATEGORIES_COUNT 1

/*************************************************

    Externed information

*************************************************/

//
// filter.cpp externs:
//
extern
const
KSFILTER_DISPATCH
CaptureFilterDispatch;

extern
const
KSFILTER_DESCRIPTOR
CaptureFilterDescriptor;

extern
const
KSPIN_DESCRIPTOR_EX
CaptureFilterPinDescriptors [CAPTURE_FILTER_PIN_COUNT];

extern
const
GUID
CaptureFilterCategories [CAPTURE_FILTER_CATEGORIES_COUNT];

//
// capture.cpp externs:
//
extern 
const
KSALLOCATOR_FRAMING_EX
CapturePinAllocatorFraming;

extern 
const
KSPIN_DISPATCH
CapturePinDispatch;

extern 
const
KSPIN_DISPATCH
InputPinDispatch;

extern
const
PKSDATARANGE
CaptureOutPinDataRanges [CAPTURE_OUT_PIN_DATA_RANGE_COUNT];

extern
const
PKSDATARANGE
CaptureInPinDataRanges [CAPTURE_IN_PIN_DATA_RANGE_COUNT];

/*************************************************

    Enums / Typedefs

*************************************************/

typedef enum _HARDWARE_STATE {

    HardwareStopped = 0,
    HardwarePaused,
    HardwareRunning

} HARDWARE_STATE, *PHARDWARE_STATE;

/*************************************************

    Class Definitions

*************************************************/

//
// IHardwareSink:
//
// This interface is used by the hardware simulation to fake interrupt
// service routines.  The Interrupt method is called at DPC as a fake
// interrupt.
//
class IHardwareSink {

public:

    virtual
    void
    Interrupt (
        ) = 0;

};

//
// ICaptureSink:
//
// This is a capture sink interface.  The device level calls back the
// CompleteMappings method passing the number of completed mappings for
// the capture pin.  This method is called during the device DPC.
//
class ICaptureSink {

public:

    virtual
    void
    CompleteMappings (
        IN ULONG NumMappings
        ) = 0;

};

/*************************************************

    Internal Includes

*************************************************/

#include "TStream.h"
#include "hwsim.h"
#include "device.h"
#include "filter.h"
#include "capture.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\bda\mpe\mpemedia.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

#ifndef __MY_MEDIA_H__
#define __MY_MEDIA_H__


#ifdef DEFINE_GUIDEX
#undef DEFINE_GUIDEX
#include <ksguid.h>
#endif

//===========================================================================
//
// IPSink PINNAME GUID
//
//===========================================================================

#define STATIC_PINNAME_IPSINK_INPUT \
    0x3fdffa70L, 0xac9a, 0x11d2, 0x8f, 0x17, 0x00, 0xc0, 0x4f, 0x79, 0x71, 0xe2
DEFINE_GUIDSTRUCT("3fdffa70-ac9a-11d2-8f17-00c04f7971e2", PINNAME_IPSINK_INPUT);
#define PINNAME_IPSINK_INPUT   DEFINE_GUIDNAMED(PINNAME_IPSINK_INPUT)


//===========================================================================
//
// MPE PINNAME GUID
//
//===========================================================================

#define STATIC_PINNAME_MPE \
    0xc1b06d73L, 0x1dbb, 0x11d3, 0x8f, 0x46, 0x00, 0xC0, 0x4f, 0x79, 0x71, 0xE2
DEFINE_GUIDSTRUCT("C1B06D73-1DBB-11d3-8F46-00C04F7971E2", PINNAME_MPE);
#define PINNAME_MPE   DEFINE_GUIDNAMED(PINNAME_MPE)


/////////////////////////////////////////////////////////////
//
// Mpe Data Format structure
//
typedef struct tagKS_DATAFORMAT_MPE
{
   KSDATAFORMAT                 DataFormat;

} KS_DATAFORMAT_MPE, *PKS_DATAFORMAT_MPE;




#endif // __MY_MEDIA_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\bda\mpe\mpestream.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

#ifndef __MPE_STREAM_H__
#define __MPE_STREAM_H__

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus


// ------------------------------------------------------------------------
// Property set for all video capture streams
// ------------------------------------------------------------------------

DEFINE_KSPROPERTY_TABLE(MpeConnectionProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_CONNECTION_ALLOCATORFRAMING,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(KSALLOCATOR_FRAMING),            // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    )
};

// ------------------------------------------------------------------------
// Array of all of the property sets supported by video streams
// ------------------------------------------------------------------------

DEFINE_KSPROPERTY_SET_TABLE(MpeStreamProperties)
{
    DEFINE_KSPROPERTY_SET
    (
        &KSPROPSETID_Connection,                        // Set
        SIZEOF_ARRAY(MpeConnectionProperties),       // PropertiesCount
        MpeConnectionProperties,                     // PropertyItems
        0,                                              // FastIoCount
        NULL                                            // FastIoTable
    ),
};


#define NUMBER_MPE_STREAM_PROPERTIES (SIZEOF_ARRAY(MpeStreamProperties))

//---------------------------------------------------------------------------
// All of the video and vbi data formats we might use
//---------------------------------------------------------------------------

KSDATARANGE StreamFormatIPv4 =
{
    //
    // KSDATARANGE
    //
    sizeof (KSDATAFORMAT),
    0,
    4096,               // sizeof a IPv4 Packet
    0,                  // Reserved
    { STATIC_KSDATAFORMAT_TYPE_BDA_IP },
    { STATIC_KSDATAFORMAT_SUBTYPE_BDA_IP },
    { STATIC_KSDATAFORMAT_SPECIFIER_BDA_IP }
};


KSDATARANGE StreamFormatMPE =
{
    sizeof (KSDATARANGE),
    0,
    4093, //max sizeof (MPE_BUFFER),
    0,                  // Reserved
    { STATIC_KSDATAFORMAT_TYPE_MPE },
    { STATIC_KSDATAFORMAT_SUBTYPE_NONE },
    { STATIC_KSDATAFORMAT_SPECIFIER_NONE }
};


//---------------------------------------------------------------------------
//  STREAM_Input Formats
//---------------------------------------------------------------------------

static PKSDATAFORMAT Stream0Formats[] =
{
    (PKSDATAFORMAT) &StreamFormatMPE


    // Add more formats here for to mirror output formats for "passthrough" mode
    // The idea is that upstream capture drivers may have done some decoding already
    // or downstream drivers may wish to have the raw data without any decoding at all.
    // In that case all we need to do is copy the data(if there is a pending SRB) OR
    // forward the SRB to the downstream client.
};

#define NUM_STREAM_0_FORMATS (SIZEOF_ARRAY(Stream0Formats))


//---------------------------------------------------------------------------
//  STREAM_Output Formats
//---------------------------------------------------------------------------

static PKSDATAFORMAT Stream1Formats[] =
{
    (PKSDATAFORMAT) &StreamFormatIPv4,

    //
    // Add more formats here for whatever output formats are supported.
    //
};
#define NUM_STREAM_1_FORMATS (SIZEOF_ARRAY (Stream1Formats))

//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Create an array that holds the list of all of the streams supported
//---------------------------------------------------------------------------

typedef struct _ALL_STREAM_INFO
{
    HW_STREAM_INFORMATION   hwStreamInfo;
    HW_STREAM_OBJECT        hwStreamObject;

} ALL_STREAM_INFO, *PALL_STREAM_INFO;

static ALL_STREAM_INFO Streams [] =
{
    //
    // MPE Input Stream
    //

    {
        // HW_STREAM_INFORMATION -------------------------------------------
        {
            1,                                        // NumberOfPossibleInstances
            KSPIN_DATAFLOW_IN,                        // DataFlow
            TRUE,                                     // DataAccessible
            NUM_STREAM_0_FORMATS,                     // NumberOfFormatArrayEntries
            Stream0Formats,                           // StreamFormatsArray
            0,                                        // ClassReserved[0]
            0,                                        // ClassReserved[1]
            0,                                        // ClassReserved[2]
            0,                                        // ClassReserved[3]
            NUMBER_MPE_STREAM_PROPERTIES,             // Number of stream properties
            (PKSPROPERTY_SET) MpeStreamProperties,    // Stream Property Array
            0,                                        // NumStreamEventArrayEntries
            0,                                        // StreamEventsArray
            NULL,                                     // Category
            (GUID *)&PINNAME_MPE,                     // Name
            0,                                        // MediumsCount
            NULL,                                     // Mediums
        },

        // HW_STREAM_OBJECT ------------------------------------------------
        {
            sizeof (HW_STREAM_OBJECT),              // SizeOfThisPacket
            0,                                      // StreamNumber
            (PVOID)NULL,                            // HwStreamExtension
            ReceiveDataPacket,
            ReceiveCtrlPacket,
            {                                       // HW_CLOCK_OBJECT
                NULL,                               // .HWClockFunction
                0,                                  // .ClockSupportFlags
            },
            FALSE,                                  // Dma
            TRUE,                                   // Pio
            (PVOID)NULL,                            // HwDeviceExtension
            0,                                      // StreamHeaderMediaSpecific
            0,                                      // StreamHeaderWorkspace
            TRUE,                                   // Allocator
            NULL,                                   // HwEventRoutine
        },
    },

    //
    // IPv4 Control Interface Pin
    //
    {
        // HW_STREAM_INFORMATION -------------------------------------------
        {
            1,                                      // NumberOfPossibleInstances
            KSPIN_DATAFLOW_OUT,                     // DataFlow
            TRUE,                                   // DataAccessible
            NUM_STREAM_1_FORMATS,                   // NumberOfFormatArrayEntries
            Stream1Formats,                         // StreamFormatsArray
            0,                                      // ClassReserved[0]
            0,                                      // ClassReserved[1]
            0,                                      // ClassReserved[2]
            0,                                      // ClassReserved[3]
            NUMBER_MPE_STREAM_PROPERTIES,           // Number of stream properties
            (PKSPROPERTY_SET) MpeStreamProperties,  // Stream Property Array
            0,                                      // NumStreamEventArrayEntries
            0,                                      // StreamEventsArray
            NULL,                                   // Category
            (GUID *)&PINNAME_IPSINK_INPUT,          // Name
            0,                                      // MediumsCount
            NULL,                                   // Mediums
        },

        // HW_STREAM_OBJECT ------------------------------------------------
        {
            sizeof (HW_STREAM_OBJECT),              // SizeOfThisPacket
            0,                                      // StreamNumber
            (PVOID)NULL,                            // HwStreamExtension
            ReceiveDataPacket,                      // HwReceiveDataPacket Handler
            ReceiveCtrlPacket,                      // HwReceiveControlPacket Handler
            {                                       // HW_CLOCK_OBJECT
                NULL,                                // .HWClockFunction
                0,                                   // .ClockSupportFlags
            },
            FALSE,                                  // Dma
            TRUE,                                   // Pio
            (PVOID)NULL,                            // HwDeviceExtension
            0,                                      // StreamHeaderMediaSpecific
            0,                                      // StreamHeaderWorkspace
            TRUE,                                   // Allocator
            NULL,                                   // HwEventRoutine
        },
    }

};

#define DRIVER_STREAM_COUNT (SIZEOF_ARRAY (Streams))


//---------------------------------------------------------------------------
// Topology
//---------------------------------------------------------------------------

// Topology connections

KSTOPOLOGY_CONNECTION   rgConnections[] =
{
    {-1, 0, -1, 1}
};

// Categories define what the device does.

static GUID Categories[] =
{
    STATIC_KSCATEGORY_BDA_RECEIVER_COMPONENT
};

#define NUMBER_OF_CATEGORIES  SIZEOF_ARRAY (Categories)

static KSTOPOLOGY Topology = {
    NUMBER_OF_CATEGORIES,
    (GUID*) &Categories,
    0,
    (GUID*) NULL,
    1,
    rgConnections,
    NULL,
    0
};


//---------------------------------------------------------------------------
// The Main stream header
//---------------------------------------------------------------------------

static HW_STREAM_HEADER StreamHeader =
{
    DRIVER_STREAM_COUNT,                // NumberOfStreams
    sizeof (HW_STREAM_INFORMATION),     // Future proofing
    0,                                  // NumDevPropArrayEntries set at init time
    NULL,                               // DevicePropertiesArray  set at init time
    0,                                  // NumDevEventArrayEntries;
    NULL,                               // DeviceEventsArray;
    &Topology                           // Pointer to Device Topology
};

#ifdef    __cplusplus
}
#endif // __cplusplus

#endif //  __MPE_STREAM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\bda\samples\bdacapture\filter.cpp ===
/**************************************************************************

    AVStream Simulated Hardware Sample

    Copyright (c) 2001, Microsoft Corporation.

    File:

        filter.cpp

    Abstract:

        This file contains the filter level implementation for the 
        capture filter.

    History:

        created 3/12/2001

**************************************************************************/

#include "BDACap.h"

/**************************************************************************

    PAGEABLE CODE

**************************************************************************/

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA


NTSTATUS
CCaptureFilter::
DispatchCreate (
    IN PKSFILTER Filter,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the creation dispatch for the capture filter.  It creates
    the CCaptureFilter object, associates it with the AVStream filter
    object, and bag the CCaptureFilter for later cleanup.

Arguments:

    Filter -
        The AVStream filter being created

    Irp -
        The creation Irp

Return Value:
    
    Success / failure

--*/

{

    PAGED_CODE();

    NTSTATUS Status = STATUS_SUCCESS;

    CCaptureFilter *CapFilter = new (NonPagedPool, 'RysI') CCaptureFilter (Filter);

    if (!CapFilter) {
        //
        // Return failure if we couldn't create the filter.
        //
        Status = STATUS_INSUFFICIENT_RESOURCES;

    } else {
        //
        // Add the item to the object bag if we we were successful. 
        // Whenever the filter closes, the bag is cleaned up and we will be
        // freed.
        //
        Status = KsAddItemToObjectBag (
            Filter -> Bag,
            reinterpret_cast <PVOID> (CapFilter),
            reinterpret_cast <PFNKSFREE> (CCaptureFilter::Cleanup)
            );

        if (!NT_SUCCESS (Status)) {
            delete CapFilter;
        } else {
            Filter -> Context = reinterpret_cast <PVOID> (CapFilter);
        }

    }

    return Status;

}

/**************************************************************************

    DESCRIPTOR AND DISPATCH LAYOUT

**************************************************************************/

GUID g_PINNAME_VIDEO_CAPTURE = {STATIC_PINNAME_VIDEO_CAPTURE};

//
// CaptureFilterCategories:
//
// The list of category GUIDs for the capture filter.
//
const
GUID
CaptureFilterCategories [CAPTURE_FILTER_CATEGORIES_COUNT] = {
    STATICGUIDOF (KSCATEGORY_BDA_RECEIVER_COMPONENT)
};


//  Medium GUIDs for the Transport Output Pin.
//
//  This insures contection to the correct Capture Filter pin.
//
// {F102C41F-7FA1-4842-A0C8-DC41176EC844}
#define GUID_BdaSWRcv   0xf102c41f, 0x7fa1, 0x4842, 0xa0, 0xc8, 0xdc, 0x41, 0x17, 0x6e, 0xc8, 0x44
const KSPIN_MEDIUM TransportPinMedium =
{
    GUID_BdaSWRcv, 0, 0
};

//
// CaptureFilterPinDescriptors:
//
// The list of pin descriptors on the capture filter.  
//
const 
KSPIN_DESCRIPTOR_EX
CaptureFilterPinDescriptors [CAPTURE_FILTER_PIN_COUNT] = {
    //
    // Capture Input Pin
    //
    {
        &InputPinDispatch,
        NULL,             
        {
            NULL,                           // Interfaces (NULL, 0 == default)
            0,
            1,  // Mediums
            &TransportPinMedium,
            SIZEOF_ARRAY (CaptureInPinDataRanges), // Range Count
            CaptureInPinDataRanges,           // Ranges
            KSPIN_DATAFLOW_IN,              // Dataflow
            KSPIN_COMMUNICATION_BOTH,       // Communication
            NULL,         // Category
            NULL,         // Name
            0                               // Reserved
        },
        
        KSPIN_FLAG_DO_NOT_USE_STANDARD_TRANSPORT | 
        KSPIN_FLAG_FRAMES_NOT_REQUIRED_FOR_PROCESSING | 
        KSPIN_FLAG_FIXED_FORMAT,
        1,      // InstancesPossible
        1,      // InstancesNecessary
        NULL,   // Allocator Framing
        NULL    // PinIntersectHandler
    },

    //
    // Capture Output Pin
    //
    {
        &CapturePinDispatch,
        NULL,             
        {
            NULL,                           // Interfaces (NULL, 0 == default)
            0,
            NULL,                           // Mediums (NULL, 0 == default)
            0,
            SIZEOF_ARRAY (CaptureOutPinDataRanges), // Range Count
            CaptureOutPinDataRanges,           // Ranges
            KSPIN_DATAFLOW_OUT,             // Dataflow
            KSPIN_COMMUNICATION_BOTH,       // Communication
            NULL,         // Category
            NULL,         // Name
            0                               // Reserved
        },
        
        KSPIN_FLAG_GENERATE_MAPPINGS |      // Pin Flags
        KSPIN_FLAG_PROCESS_IN_RUN_STATE_ONLY,
        1,                                  // Instances Possible
        1,                                  // Instances Necessary
        &CapturePinAllocatorFraming,        // Allocator Framing
        NULL                                // Format Intersect Handler
    }
    
};

//
// CaptureFilterDispatch:
//
// This is the dispatch table for the capture filter.  It provides notification
// of creation, closure, processing (for filter-centrics, not for the capture
// filter), and resets (for filter-centrics, not for the capture filter).
//
const 
KSFILTER_DISPATCH
CaptureFilterDispatch = {
    CCaptureFilter::DispatchCreate,         // Filter Create
    NULL,                                   // Filter Close
    NULL,                                   // Filter Process
    NULL                                    // Filter Reset
};

//
//  Define the name GUID for our digital capture filter.
//
//  NOTE!  You must use a different GUID for each type of filter that
//  your driver exposes.
//
#define STATIC_KSNAME_BdaSWCaptureFilter\
    074649feL, 0x2dd8, 0x4c12, 0x8a, 0x23, 0xbd, 0x82, 0x8b, 0xad, 0xff, 0xfa
DEFINE_GUIDSTRUCT("074649FE-2DD8-4C12-8A23-BD828BADFFFA", KSNAME_BdaSWCaptureFilter);
#define KSNAME_BdaSWCaptureFilter DEFINE_GUIDNAMED(KSNAME_BdaSWCaptureFilter)


//  Must match the KSSTRING used in the installation INFs interface sections
//  AND must match the KSNAME GUID above.
//
#define KSSTRING_BdaSWCaptureFilter L"{074649FE-2DD8-4C12-8A23-BD828BADFFFA}"

// Create a connection through the capture filter so that graph render will
// work.
//
const
KSTOPOLOGY_CONNECTION FilterConnections[] =
{   // KSFILTER_NODE  is defined as ((ULONG)-1) in ks.h 
    { KSFILTER_NODE, 0,                 KSFILTER_NODE, 1 }
};

//
// CaptureFilterDescription:
//
// The descriptor for the capture filter.
//
const 
KSFILTER_DESCRIPTOR 
CaptureFilterDescriptor = {
    &CaptureFilterDispatch,                 // Dispatch Table
    NULL,                                   // Automation Table
    KSFILTER_DESCRIPTOR_VERSION,            // Version
    0,                                      // Flags
    &KSNAME_BdaSWCaptureFilter,             // Reference GUID

    // Pin Descriptor Table
    //
    // PinDescriptorsCount; exposes all template pins 
    // PinDescriptorSize; size of each item
    // PinDescriptors; table of pin descriptors
    //
    DEFINE_KSFILTER_PIN_DESCRIPTORS (CaptureFilterPinDescriptors),

    // Category Table
    //
    // CategoriesCount; number of categories in the table
    // Categories; table of categories
    //
    DEFINE_KSFILTER_CATEGORIES (CaptureFilterCategories),

    //  Node Descriptor Table
    //
    // NodeDescriptorsCount; exposes all template nodes
    // NodeDescriptorSize; size of each item
    // NodeDescriptors; table of node descriptors
    //
    0,
    sizeof (KSNODE_DESCRIPTOR),
    NULL,

    //  Filter connection table
    //
    // ConnectionsCount; number of connections in the table
    // Connections; table of connections
    //
    DEFINE_KSFILTER_CONNECTIONS(FilterConnections), 

    NULL                                    // Component ID
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\bda\samples\bdacapture\device.cpp ===
/**************************************************************************

    AVStream Simulated Hardware Sample

    Copyright (c) 2001, Microsoft Corporation.

    File:

        device.cpp

    Abstract:

        This file contains the device level implementation of the AVStream
        hardware sample.  Note that this is not the "fake" hardware.  The
        "fake" hardware is in hwsim.cpp.

    History:

        created 3/9/2001

**************************************************************************/

#include "BDACap.h"

/**************************************************************************

    PAGEABLE CODE

**************************************************************************/

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA


NTSTATUS
CCaptureDevice::
DispatchCreate (
    IN PKSDEVICE Device
    )

/*++

Routine Description:

    Create the capture device.  This is the creation dispatch for the
    capture device.

Arguments:

    Device -
        The AVStream device being created.

Return Value:

    Success / Failure

--*/

{

    PAGED_CODE();

    NTSTATUS Status;

    CCaptureDevice *CapDevice = new (NonPagedPool, MS_SAMPLE_CAPTURE_POOL_TAG) CCaptureDevice (Device);

    if (!CapDevice) {
        //
        // Return failure if we couldn't create the pin.
        //
        Status = STATUS_INSUFFICIENT_RESOURCES;

    } else {

        //
        // Add the item to the object bag if we were successful.
        // Whenever the device goes away, the bag is cleaned up and
        // we will be freed.
        //
        // For backwards compatibility with DirectX 8.0, we must grab
        // the device mutex before doing this.  For Windows XP, this is
        // not required, but it is still safe.
        //
        KsAcquireDevice (Device);
        Status = KsAddItemToObjectBag (
            Device -> Bag,
            reinterpret_cast <PVOID> (CapDevice),
            reinterpret_cast <PFNKSFREE> (CCaptureDevice::Cleanup)
            );
        KsReleaseDevice (Device);

        if (!NT_SUCCESS (Status)) {
            delete CapDevice;
        } else {
            Device -> Context = reinterpret_cast <PVOID> (CapDevice);
        }

    }

    return Status;

}

/*************************************************/


NTSTATUS
CCaptureDevice::
PnpStart (
    IN PCM_RESOURCE_LIST TranslatedResourceList,
    IN PCM_RESOURCE_LIST UntranslatedResourceList
    )

/*++

Routine Description:

    Called at Pnp start.  We start up our virtual hardware simulation.

Arguments:

    TranslatedResourceList -
        The translated resource list from Pnp

    UntranslatedResourceList -
        The untranslated resource list from Pnp

Return Value:

    Success / Failure

--*/

{

    PAGED_CODE();

    //
    // Normally, we'd do things here like parsing the resource lists and
    // connecting our interrupt.  Since this is a simulation, there isn't
    // much to parse.  The parsing and connection should be the same as
    // any WDM driver.  The sections that will differ are illustrated below
    // in setting up a simulated DMA.
    //

    NTSTATUS Status = STATUS_SUCCESS;

    //
    // By PnP, it's possible to receive multiple starts without an intervening
    // stop (to reevaluate resources, for example).  Thus, we only perform
    // creations of the simulation on the initial start and ignore any 
    // subsequent start.  Hardware drivers with resources should evaluate
    // resources and make changes on 2nd start.
    //
    if (!m_Device -> Started) {

	m_HardwareSimulation = new (NonPagedPool, MS_SAMPLE_CAPTURE_POOL_TAG) CHardwareSimulation (this);
	if (!m_HardwareSimulation) {
	    //
            // If we couldn't create the hardware simulation, fail.
            //
            Status = STATUS_INSUFFICIENT_RESOURCES;
	    return Status;
	    
	} else {
	    //
	    // Add the item to the object bag if we were successful. 
	    //
	    
	    Status = KsAddItemToObjectBag (
		       m_Device -> Bag,
		       reinterpret_cast <PVOID> (m_HardwareSimulation),
		       reinterpret_cast <PFNKSFREE> (CCaptureDevice::CleanupHW)
		       );
	    if (!NT_SUCCESS(Status)) {
		delete m_HardwareSimulation;
		return Status;
	    }
	    
	}	
    
	INTERFACE_TYPE InterfaceBuffer;
	ULONG InterfaceLength;
	DEVICE_DESCRIPTION DeviceDescription;
	NTSTATUS IfStatus;
	
	if (NT_SUCCESS (Status)) {
	    //
	    // Set up DMA...
	    //
	    IfStatus = IoGetDeviceProperty (
                    m_Device -> PhysicalDeviceObject,
		    DevicePropertyLegacyBusType,
		    sizeof (INTERFACE_TYPE),
		    &InterfaceBuffer,
		    &InterfaceLength
		    );

            //
            // Initialize our fake device description.  We claim to be a 
            // bus-mastering 32-bit scatter/gather capable piece of hardware.
            //
            // Ordinarilly, we'd be using InterfaceBuffer or 
            // InterfaceTypeUndefined if !NT_SUCCESS (IfStatus) as the 
            // InterfaceType below; however, for the purposes of this sample, 
            // we lie and say we're on the PCI Bus.  Otherwise, we're using map
            // registers on x86 32 bit physical to 32 bit logical and this isn't
            // what I want to show in this sample.
            //
            DeviceDescription.Version = DEVICE_DESCRIPTION_VERSION;
            DeviceDescription.DmaChannel = ((ULONG) ~0);
            DeviceDescription.InterfaceType = PCIBus;
            DeviceDescription.DmaWidth = Width32Bits;
            DeviceDescription.DmaSpeed = Compatible;
            DeviceDescription.ScatterGather = TRUE;
            DeviceDescription.Master = TRUE;
            DeviceDescription.Dma32BitAddresses = TRUE;
            DeviceDescription.AutoInitialize = FALSE;
            DeviceDescription.MaximumLength = (ULONG) -1;
    
            //
            // Get a DMA adapter object from the system.
            //
            m_DmaAdapterObject = IoGetDmaAdapter (
                m_Device -> PhysicalDeviceObject,
                &DeviceDescription,
                &m_NumberOfMapRegisters
                );
    
            if (!m_DmaAdapterObject) {
                Status = STATUS_UNSUCCESSFUL;
            }
    
	}
	
	if (NT_SUCCESS (Status)) {
            //
            // Initialize our DMA adapter object with AVStream.  This is 
            // **ONLY** necessary **IF** you are doing DMA directly into
            // capture buffers as this sample does.  For this,
            // KSPIN_FLAG_GENERATE_MAPPINGS must be specified on a queue.
            //
    
            //
            // The (1 << 20) below is the maximum size of a single s/g mapping
            // that this hardware can handle.  Note that I have pulled this
            // number out of thin air for the "fake" hardware.
            //
            KsDeviceRegisterAdapterObject (
		m_Device,
                m_DmaAdapterObject,
                (1 << 20),
                sizeof (KSMAPPING)
                );
	    
        }
	
    }
    
    
    return Status;

}

/*************************************************/


void
CCaptureDevice::
PnpStop (
    )

/*++

Routine Description:

    This is the pnp stop dispatch for the capture device.  It releases any
    adapter object previously allocated by IoGetDmaAdapter during Pnp Start.

Arguments:

    None

Return Value:

    None

--*/

{

    if (m_DmaAdapterObject) {
        //
        // Return the DMA adapter back to the system.
        //
        m_DmaAdapterObject -> DmaOperations -> 
            PutDmaAdapter (m_DmaAdapterObject);

        m_DmaAdapterObject = NULL;
    }

}

/*************************************************/


NTSTATUS
CCaptureDevice::
AcquireHardwareResources (
    IN ICaptureSink *CaptureSink,
    IN PBDA_TRANSPORT_INFO TransportInfo
    )

/*++

Routine Description:

    Acquire hardware resources for the capture hardware.  If the 
    resources are already acquired, this will return an error.
    The hardware configuration must be passed as a VideoInfoHeader.

Arguments:

    CaptureSink -
        The capture sink attempting to acquire resources.  When scatter /
        gather mappings are completed, the capture sink specified here is
        what is notified of the completions.

    VideoInfoHeader -
        Information about the capture stream.  This **MUST** remain
        stable until the caller releases hardware resources.  Note
        that this could also be guaranteed by bagging it in the device
        object bag as well.

Return Value:

    Success / Failure

--*/

{

    PAGED_CODE();

    NTSTATUS Status = STATUS_SUCCESS;

    //
    // If we're the first pin to go into acquire (remember we can have
    // a filter in another graph going simultaneously), grab the resources.
    //
    if (InterlockedCompareExchange (
        &m_PinsWithResources,
        1,
        0) == 0) {

        m_TransportInfo = TransportInfo;

        //
        // If there's an old hardware simulation sitting around for some
        // reason, blow it away.
        //
        if (m_TsSynth) {

	    delete m_TsSynth;
	    m_TsSynth = NULL;

        }

        //
        // Create the necessary type of transport stream synthesizer.
        //
        if (m_TransportInfo)
        {
            m_TsSynth = new (NonPagedPool, MS_SAMPLE_CAPTURE_POOL_TAG) 
                CTsSynthesizer (
                    m_TransportInfo -> ulcbPhyiscalPacket,
                    m_TransportInfo -> ulcbPhyiscalFrame / m_TransportInfo -> ulcbPhyiscalPacket
                    );
        }
        else
            //
            // We don't synthesize anything but RGB 24 and UYVY.
            //
            Status = STATUS_INVALID_PARAMETER;
    
        if (NT_SUCCESS (Status) && !m_TsSynth) {
    
            Status = STATUS_INSUFFICIENT_RESOURCES;
    
        } 

	//
	// If everything has succeeded thus far, set the capture sink.
	//
	if (NT_SUCCESS(Status))
	    m_CaptureSink = CaptureSink;
	else {
	    ReleaseHardwareResources();
	}

    } else {
	
        //
        // TODO: Better status code?
        //
        Status = STATUS_SHARING_VIOLATION;
	
    }
    
    return Status;

}

/*************************************************/


void
CCaptureDevice::
ReleaseHardwareResources (
    )

/*++

Routine Description:

    Release hardware resources.  This should only be called by
    an object which has acquired them.

Arguments:

    None

Return Value:

    None

--*/

{

    PAGED_CODE();

    //
    // Blow away the image synth.
    //
    if (m_TsSynth) {

	delete m_TsSynth;
        m_TsSynth = NULL;

    }

    m_TransportInfo = NULL;
    m_CaptureSink = NULL;

    //
    // Release our "lock" on hardware resources.  This will allow another
    // pin (perhaps in another graph) to acquire them.
    //
    InterlockedExchange (
        &m_PinsWithResources,
        0
        );

}

/*************************************************/


NTSTATUS
CCaptureDevice::
Start (
    )

/*++

Routine Description:

    Start the capture device based on the video info header we were told
    about when resources were acquired.

Arguments:

    None

Return Value:

    Success / Failure

--*/

{

    PAGED_CODE();

    m_LastMappingsCompleted = 0;
    m_InterruptTime = 0;

    return
        m_HardwareSimulation -> Start (
            m_TsSynth,
            m_TransportInfo -> AvgTimePerFrame,
            m_TransportInfo -> ulcbPhyiscalPacket,
            m_TransportInfo -> ulcbPhyiscalFrame / m_TransportInfo -> ulcbPhyiscalPacket
            );


}

/*************************************************/


NTSTATUS
CCaptureDevice::
Pause (
    IN BOOLEAN Pausing
    )

/*++

Routine Description:

    Pause or unpause the hardware simulation.  This is an effective start
    or stop without resetting counters and formats.  Note that this can
    only be called to transition from started -> paused -> started.  Calling
    this without starting the hardware with Start() does nothing.

Arguments:

    Pausing -
        An indicatation of whether we are pausing or unpausing

        TRUE -
            Pause the hardware simulation

        FALSE -
            Unpause the hardware simulation

Return Value:

    Success / Failure

--*/

{

    PAGED_CODE();

    return
        m_HardwareSimulation -> Pause (
            Pausing
            );

}

/*************************************************/


NTSTATUS
CCaptureDevice::
Stop (
    )

/*++

Routine Description:

    Stop the capture device.

Arguments:

    None

Return Value:

    Success / Failure

--*/

{

    PAGED_CODE();

    return
        m_HardwareSimulation -> Stop ();

}

/*************************************************/


ULONG
CCaptureDevice::
ProgramScatterGatherMappings (
    IN PUCHAR *Buffer,
    IN PKSMAPPING Mappings,
    IN ULONG MappingsCount
    )

/*++

Routine Description:

    Program the scatter / gather mappings for the "fake" hardware.

Arguments:

    Buffer -
        Points to a pointer to the virtual address of the topmost
        scatter / gather chunk.  The pointer will be updated as the
        device "programs" mappings.  Reason for this is that we get
        the physical addresses and sizes, but must calculate the virtual
        addresses...  This is used as scratch space for that.

    Mappings -
        An array of mappings to program

    MappingsCount -
        The count of mappings in the array

Return Value:

    The number of mappings successfully programmed

--*/

{

    PAGED_CODE();

    return 
        m_HardwareSimulation -> ProgramScatterGatherMappings (
            Buffer,
            Mappings,
            MappingsCount,
            sizeof (KSMAPPING)
            );

}

/*************************************************************************

    LOCKED CODE

**************************************************************************/

#ifdef ALLOC_PRAGMA
#pragma code_seg()
#endif // ALLOC_PRAGMA


ULONG
CCaptureDevice::
QueryInterruptTime (
    )

/*++

Routine Description:

    Return the number of frame intervals that have elapsed since the
    start of the device.  This will be the frame number.

Arguments:

    None

Return Value:

    The interrupt time of the device (the number of frame intervals that
    have elapsed since the start of the device).

--*/

{

    return m_InterruptTime;

}

/*************************************************/


void
CCaptureDevice::
Interrupt (
    )

/*++

Routine Description:

    This is the "faked" interrupt service routine for this device.  It
    is called at dispatch level by the hardware simulation.

Arguments:

    None

Return Value:

    None

--*/

{

    m_InterruptTime++;

    //
    // Realistically, we'd do some hardware manipulation here and then queue
    // a DPC.  Since this is fake hardware, we do what's necessary here.  This
    // is pretty much what the DPC would look like short of the access
    // of hardware registers (ReadNumberOfMappingsCompleted) which would likely
    // be done in the ISR.
    //
    ULONG NumMappingsCompleted = 
        m_HardwareSimulation -> ReadNumberOfMappingsCompleted ();

    //
    // Inform the capture sink that a given number of scatter / gather
    // mappings have completed.
    //
    m_CaptureSink -> CompleteMappings (
        NumMappingsCompleted - m_LastMappingsCompleted
        );

    m_LastMappingsCompleted = NumMappingsCompleted;

}

/**************************************************************************

    DESCRIPTOR AND DISPATCH LAYOUT

**************************************************************************/

//
// CaptureFilterDescriptor:
//
// The filter descriptor for the capture device.
DEFINE_KSFILTER_DESCRIPTOR_TABLE (FilterDescriptors) { 
    &CaptureFilterDescriptor
};

//
// CaptureDeviceDispatch:
//
// This is the dispatch table for the capture device.  Plug and play
// notifications as well as power management notifications are dispatched
// through this table.
//
const
KSDEVICE_DISPATCH
CaptureDeviceDispatch = {
    CCaptureDevice::DispatchCreate,         // PnP Add Device
    CCaptureDevice::DispatchPnpStart,       // PnP Start
    NULL,                                   // Post-Start
    NULL,                                   // Pnp Query Stop
    NULL,                                   // Pnp Cancel Stop
    CCaptureDevice::DispatchPnpStop,        // Pnp Stop
    NULL,                                   // Pnp Query Remove
    NULL,                                   // Pnp Cancel Remove
    NULL,                                   // Pnp Remove
    NULL,                                   // Pnp Query Capabilities
    NULL,                                   // Pnp Surprise Remove
    NULL,                                   // Query Power
    NULL                                    // Set Power
};


//
// CaptureDeviceDescriptor:
//
// This is the device descriptor for the capture device.  It points to the
// dispatch table and contains a list of filter descriptors that describe
// filter-types that this device supports.  Note that the filter-descriptors

// can be created dynamically and the factories created via 
// KsCreateFilterFactory as well.  
//
const
KSDEVICE_DESCRIPTOR
CaptureDeviceDescriptor = {
    &CaptureDeviceDispatch,
    SIZEOF_ARRAY (FilterDescriptors),
    FilterDescriptors,
    KSDEVICE_DESCRIPTOR_VERSION
};

/**************************************************************************

    INITIALIZATION CODE

**************************************************************************/


extern "C"
NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    Driver entry point.  Pass off control to the AVStream initialization
    function (KsInitializeDriver) and return the status code from it.

Arguments:

    DriverObject -
        The WDM driver object for our driver

    RegistryPath -
        The registry path for our registry info

Return Value:

    As from KsInitializeDriver

--*/

{
    NTSTATUS    Status = STATUS_SUCCESS;

    //
    // Simply pass the device descriptor and parameters off to AVStream
    // to initialize us.  This will cause filter factories to be set up
    // at add & start.  Everything is done based on the descriptors passed
    // here.
    //
    Status = KsInitializeDriver (
                DriverObject,
                RegistryPath,
                &CaptureDeviceDescriptor
                );

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\bda\samples\bdacapture\capture.cpp ===
/**************************************************************************

    AVStream Simulated Hardware Sample

    Copyright (c) 2001, Microsoft Corporation.

    File:

        capture.cpp

    Abstract:

        This file contains source for the video capture pin on the capture
        filter.  The capture sample performs "fake" DMA directly into
        the capture buffers.  Common buffer DMA will work slightly differently.

        For common buffer DMA, the general technique would be DPC schedules
        processing with KsPinAttemptProcessing.  The processing routine grabs
        the leading edge, copies data out of the common buffer and advances.
        Cloning would not be necessary with this technique.  It would be 
        similiar to the way "AVSSamp" works, but it would be pin-centric.

    History:

        created 3/8/2001

**************************************************************************/

#include "BDACap.h"

/**************************************************************************

    PAGEABLE CODE

**************************************************************************/

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA


CCapturePin::
CCapturePin (
    IN PKSPIN Pin
    ) :
    m_Pin (Pin)

/*++

Routine Description:

    Construct a new capture pin.

Arguments:

    Pin -
        The AVStream pin object corresponding to the capture pin

Return Value:

    None

--*/

{

    PAGED_CODE();

    PKSDEVICE Device = KsPinGetDevice (Pin);

    //
    // Set up our device pointer.  This gives us access to "hardware I/O"
    // during the capture routines.
    //
    m_Device = reinterpret_cast <CCaptureDevice *> (Device -> Context);

}

/*************************************************/


NTSTATUS
CCapturePin::
DispatchCreate (
    IN PKSPIN Pin,
    IN PIRP Irp
    )

/*++

Routine Description:

    Create a new capture pin.  This is the creation dispatch for
    the video capture pin.

Arguments:

    Pin -
        The pin being created

    Irp -
        The creation Irp

Return Value:

    Success / Failure

--*/

{

    PAGED_CODE();

    NTSTATUS Status = STATUS_SUCCESS;

    CCapturePin *CapPin = new (NonPagedPool, MS_SAMPLE_CAPTURE_POOL_TAG) CCapturePin (Pin);

    if (!CapPin) {
        //
        // Return failure if we couldn't create the pin.
        //
        Status = STATUS_INSUFFICIENT_RESOURCES;

    } else {
        //
        // Add the item to the object bag if we we were successful. 
        // Whenever the pin closes, the bag is cleaned up and we will be
        // freed.
        //
        Status = KsAddItemToObjectBag (
            Pin -> Bag,
            reinterpret_cast <PVOID> (CapPin),
            reinterpret_cast <PFNKSFREE> (CCapturePin::Cleanup)
            );

        if (!NT_SUCCESS (Status)) {
            delete CapPin;
        } else {
            Pin -> Context = reinterpret_cast <PVOID> (CapPin);
        }

    }

    //
    // If we succeeded so far, stash the video info header away and change
    // our allocator framing to reflect the fact that only now do we know
    // the framing requirements based on the connection format.
    //
    PBDA_TRANSPORT_INFO TransportInfo = NULL;

    if (NT_SUCCESS (Status)) {

        TransportInfo = CapPin -> CaptureBdaTransportInfo ();
        if (!TransportInfo) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    if (NT_SUCCESS (Status)) {
        
        //
        // We need to edit the descriptor to ensure we don't mess up any other
        // pins using the descriptor or touch read-only memory.
        //
        Status = KsEdit (Pin, &Pin -> Descriptor, 'aChS');

        if (NT_SUCCESS (Status)) {
            Status = KsEdit (
                Pin, 
                &(Pin -> Descriptor -> AllocatorFraming),
                'aChS'
                );
        }

        //
        // If the edits proceeded without running out of memory, adjust 
        // the framing based on the video info header.
        //
        if (NT_SUCCESS (Status)) {

            //
            // We've KsEdit'ed this...  I'm safe to cast away constness as
            // long as the edit succeeded.
            //
            PKSALLOCATOR_FRAMING_EX Framing =
                const_cast <PKSALLOCATOR_FRAMING_EX> (
                    Pin -> Descriptor -> AllocatorFraming
                    );

            Framing -> FramingItem [0].Frames = 8;

            //
            // The physical and optimal ranges must be biSizeImage.  We only
            // support one frame size, precisely the size of each capture
            // image.
            //
            Framing -> FramingItem [0].PhysicalRange.MinFrameSize =
                Framing -> FramingItem [0].PhysicalRange.MaxFrameSize =
                Framing -> FramingItem [0].FramingRange.Range.MinFrameSize =
                Framing -> FramingItem [0].FramingRange.Range.MaxFrameSize =
                TransportInfo -> ulcbPhyiscalFrame;

            Framing -> FramingItem [0].PhysicalRange.Stepping = 
                Framing -> FramingItem [0].FramingRange.Range.Stepping =
                0;

        }

    }

    return Status;

}

/*************************************************/


PBDA_TRANSPORT_INFO 
CCapturePin::
CaptureBdaTransportInfo (
    )

/*++

Routine Description:

    Capture the video info header out of the connection format.  This
    is what we use to base synthesized images off.

Arguments:

    None

Return Value:

    The captured video info header or NULL if there is insufficient
    memory.

--*/

{

    PAGED_CODE();

    m_TransportInfo = reinterpret_cast <PBDA_TRANSPORT_INFO> (
        ExAllocatePool (
            NonPagedPool,
            sizeof(BDA_TRANSPORT_INFO)
            )
        );

    if (!m_TransportInfo)
        return NULL;

    //
    // Bag the newly allocated header space.  This will get cleaned up
    // automatically when the pin closes.
    //
    NTSTATUS Status =
        KsAddItemToObjectBag (
            m_Pin -> Bag,
            reinterpret_cast <PVOID> (m_TransportInfo),
            NULL
            );

    if (!NT_SUCCESS (Status)) {

        ExFreePool (m_TransportInfo);
        return NULL;

    } else {

        m_TransportInfo->ulcbPhyiscalPacket = 188;
        m_TransportInfo->ulcbPhyiscalFrame = 188 * 312;
        m_TransportInfo->ulcbPhyiscalFrameAlignment = 1;
        m_TransportInfo->AvgTimePerFrame = (19200 * 10000 * 8) / (188 * 312);

    }

    return m_TransportInfo;

}

/*************************************************/


NTSTATUS
CCapturePin::
Process (
    )

/*++

Routine Description:

    The process dispatch for the pin bridges to this location.
    We handle setting up scatter gather mappings, etc...

Arguments:

    None

Return Value:

    Success / Failure

--*/

{

    PAGED_CODE();

    NTSTATUS Status = STATUS_SUCCESS;
    PKSSTREAM_POINTER Leading;

    Leading = KsPinGetLeadingEdgeStreamPointer (
        m_Pin,
        KSSTREAM_POINTER_STATE_LOCKED
        );

    while (NT_SUCCESS (Status) && Leading) {

        PKSSTREAM_POINTER ClonePointer;
        PSTREAM_POINTER_CONTEXT SPContext;

        //
        // For optimization sake in this particular sample, I will only keep
        // one clone stream pointer per frame.  This complicates the logic
        // here but simplifies the completions.
        //
        // I'm also choosing to do this since I need to keep track of the
        // virtual addresses corresponding to each mapping since I'm faking
        // DMA.  It simplifies that too.
        //
        if (!m_PreviousStreamPointer) {
            //
            // First thing we need to do is clone the leading edge.  This allows
            // us to keep reference on the frames while they're in DMA.
            //
            Status = KsStreamPointerClone (
                Leading,
                NULL,
                sizeof (STREAM_POINTER_CONTEXT),
                &ClonePointer
                );

            //
            // I use this for easy chunking of the buffer.  We're not really
            // dealing with physical addresses.  This keeps track of what 
            // virtual address in the buffer the current scatter / gather 
            // mapping corresponds to for the fake hardware.
            //
            if (NT_SUCCESS (Status)) {

                //
                // Set the stream header data used to 0.  We update this 
                // in the DMA completions.  For queues with DMA, we must
                // update this field ourselves.
                //
                ClonePointer -> StreamHeader -> DataUsed = 0;

                SPContext = reinterpret_cast <PSTREAM_POINTER_CONTEXT> 
                    (ClonePointer -> Context);

                SPContext -> BufferVirtual = 
                    reinterpret_cast <PUCHAR> (
                        ClonePointer -> StreamHeader -> Data
                        );
            }

        } else {

            ClonePointer = m_PreviousStreamPointer;
            SPContext = reinterpret_cast <PSTREAM_POINTER_CONTEXT> 
                (ClonePointer -> Context);
            Status = STATUS_SUCCESS;
        }

        //
        // If the clone failed, likely we're out of resources.  Break out
        // of the loop for now.  We may end up starving DMA.
        //
        if (!NT_SUCCESS (Status)) {
            KsStreamPointerUnlock (Leading, FALSE);
            break;
        }

        //
        // Program the fake hardware.  I would use Clone -> OffsetOut.*, but
        // because of the optimization of one stream pointer per frame, it
        // doesn't make complete sense.
        //
        ULONG MappingsUsed =
            m_Device -> ProgramScatterGatherMappings (
                &(SPContext -> BufferVirtual),
                Leading -> OffsetOut.Mappings,
                Leading -> OffsetOut.Remaining
                );

        //
        // In order to keep one clone per frame and simplify the fake DMA
        // logic, make a check to see if we completely used the mappings in
        // the leading edge.  Set a flag.
        //
        if (MappingsUsed == Leading -> OffsetOut.Remaining) {
            m_PreviousStreamPointer = NULL;
        } else {
            m_PreviousStreamPointer = ClonePointer;
        }

        if (MappingsUsed) {
            //
            // If any mappings were added to scatter / gather queues, 
            // advance the leading edge by that number of mappings.  If 
            // we run off the end of the queue, Status will be 
            // STATUS_DEVICE_NOT_READY.  Otherwise, the leading edge will
            // point to a new frame.  The previous one will not have been
            // dismissed (unless "DMA" completed) since there's a clone
            // pointer referencing the frames.
            //
            Status =
                KsStreamPointerAdvanceOffsets (
                    Leading,
                    0,
                    MappingsUsed,
                    FALSE
                    );
        } else {

            //
            // The hardware was incapable of adding more entries.  The S/G
            // table is full.
            //
            Status = STATUS_PENDING;
            break;

        }

    }

    //
    // If the leading edge failed to lock (this is always possible, remember
    // that locking CAN occassionally fail), don't blow up passing NULL
    // into KsStreamPointerUnlock.  Also, set m_PendIo to kick us later...
    //
    if (!Leading) {

        m_PendIo = TRUE;

        //
        // If the lock failed, there's no point in getting called back 
        // immediately.  The lock could fail due to insufficient memory,
        // etc...  In this case, we don't want to get called back immediately.
        // Return pending.  The m_PendIo flag will cause us to get kicked
        // later.
        //
        Status = STATUS_PENDING;
    }

    //
    // If we didn't run the leading edge off the end of the queue, unlock it.
    //
    if (NT_SUCCESS (Status) && Leading) {
        KsStreamPointerUnlock (Leading, FALSE);
    } else {
        //
        // DEVICE_NOT_READY indicates that the advancement ran off the end
        // of the queue.  We couldn't lock the leading edge.
        //
        if (Status == STATUS_DEVICE_NOT_READY) Status = STATUS_SUCCESS;
    }

    //
    // If we failed with something that requires pending, set the pending I/O
    // flag so we know we need to start it again in a completion DPC.
    //
    if (!NT_SUCCESS (Status) || Status == STATUS_PENDING) {
        m_PendIo = TRUE;
    }

    return Status;

}

/*************************************************/


NTSTATUS
CCapturePin::
CleanupReferences (
    )

/*++

Routine Description:

    Clean up any references we're holding on frames after we abruptly
    stop the hardware.

Arguments:

    None

Return Value:

    Success / Failure

--*/

{

    PAGED_CODE();

    PKSSTREAM_POINTER Clone = KsPinGetFirstCloneStreamPointer (m_Pin);
    PKSSTREAM_POINTER NextClone = NULL;

    //
    // Walk through the clones, deleting them, and setting DataUsed to
    // zero since we didn't use any data!
    //
    while (Clone) {

        NextClone = KsStreamPointerGetNextClone (Clone);

        Clone -> StreamHeader -> DataUsed = 0;
        KsStreamPointerDelete (Clone);

        Clone = NextClone;

    }

    return STATUS_SUCCESS;

}

/*************************************************/


NTSTATUS
CCapturePin::
SetState (
    IN KSSTATE ToState,
    IN KSSTATE FromState
    )

/*++

Routine Description:

    This is called when the caputre pin transitions state.  The routine
    attempts to acquire / release any hardware resources and start up
    or shut down capture based on the states we are transitioning to
    and away from.

Arguments:

    ToState -
        The state we're transitioning to

    FromState -
        The state we're transitioning away from

Return Value:

    Success / Failure

--*/

{

    PAGED_CODE();

    NTSTATUS Status = STATUS_SUCCESS;

    switch (ToState) {

        case KSSTATE_STOP:

            //
            // First, stop the hardware if we actually did anything to it.
            //
            if (m_HardwareState != HardwareStopped) {
                Status = m_Device -> Stop ();
                ASSERT (NT_SUCCESS (Status));

                m_HardwareState = HardwareStopped;
            }

            //
            // We've stopped the "fake hardware".  It has cleared out
            // it's scatter / gather tables and will no longer be 
            // completing clones.  We had locks on some frames that were,
            // however, in hardware.  This will clean them up.  An
            // alternative location would be in the reset dispatch.
            // Note, however, that the reset dispatch can occur in any
            // state and this should be understood.
            //
            // Some hardware may fill all S/G mappings before stopping...
            // in this case, you may not have to do this.  The 
            // "fake hardware" here simply stops filling mappings and 
            // cleans its scatter / gather tables out on the Stop call.
            //
            Status = CleanupReferences ();

            //
            // Release any hardware resources related to this pin.
            //
            if (m_AcquiredResources) {
                //
                // If we got an interface to the clock, we must release it.
                //
                if (m_Clock) {
                    m_Clock -> Release ();
                    m_Clock = NULL;
                }

                m_Device -> ReleaseHardwareResources (
                    );

                m_AcquiredResources = FALSE;
            }

            break;

        case KSSTATE_ACQUIRE:
            //
            // Acquire any hardware resources related to this pin.  We should
            // only acquire them here -- **NOT** at filter create time. 
            // This means we do not fail creation of a filter because of
            // limited hardware resources.
            //
            if (FromState == KSSTATE_STOP) {
                Status = m_Device -> AcquireHardwareResources (
                    this,
                    m_TransportInfo
                    );

                if (NT_SUCCESS (Status)) {
                    m_AcquiredResources = TRUE;

                    //
                    // Attempt to get an interface to the master clock.
                    // This will fail if one has not been assigned.  Since
                    // one must be assigned while the pin is still in 
                    // KSSTATE_STOP, this is a guranteed method of getting
                    // the clock should one be assigned.
                    //
                    if (!NT_SUCCESS (
                        KsPinGetReferenceClockInterface (
                            m_Pin,
                            &m_Clock
                            )
                        )) {

                        //
                        // If we could not get an interface to the clock,
                        // don't use one.  
                        //
                        m_Clock = NULL;

                    }

                } else {
                    m_AcquiredResources = FALSE;
                }

            } else {
                //
                // Standard transport pins will always receive transitions in
                // +/- 1 manner.  This means we'll always see a PAUSE->ACQUIRE
                // transition before stopping the pin.  
                //
                // The below is done because on DirectX 8.0, when the pin gets
                // a message to stop, the queue is inaccessible.  The reset 
                // which comes on every stop happens after this (at which time
                // the queue is inaccessible also).  So, for compatibility with
                // DirectX 8.0, I am stopping the "fake" hardware at this
                // point and cleaning up all references we have on frames.  See
                // the comments above regarding the CleanupReferences call.
                //
                // If this sample were targeting XP only, the below code would
                // not be here.  Again, I only do this so the sample does not
                // hang when it is stopped running on a configuration such as
                // Win2K + DX8. 
                //
                if (m_HardwareState != HardwareStopped) {
                    Status = m_Device -> Stop ();
                    ASSERT (NT_SUCCESS (Status));

                    m_HardwareState = HardwareStopped;
                }

                Status = CleanupReferences ();
            }

            break;

        case KSSTATE_PAUSE:
            //
            // Stop the hardware simulation if we're coming down from run.
            //
            if (FromState == KSSTATE_RUN) {

                Status = m_Device -> Pause (TRUE);

                if (NT_SUCCESS (Status)) {
                    m_HardwareState = HardwarePaused;
                }

            }
            break;

        case KSSTATE_RUN:
            //
            // Start the hardware simulation or unpause it depending on
            // whether we're initially running or we've paused and restarted.
            //
            if (m_HardwareState == HardwarePaused) {
                Status = m_Device -> Pause (FALSE);
            } else {
                Status = m_Device -> Start ();
            }

            if (NT_SUCCESS (Status)) {
                m_HardwareState = HardwareRunning;
            }

            break;

    }

    return Status;

}


/**************************************************************************

    LOCKED CODE

**************************************************************************/

#ifdef ALLOC_PRAGMA
#pragma code_seg()
#endif // ALLOC_PRAGMA


void
CCapturePin::
CompleteMappings (
    IN ULONG NumMappings
    )

/*++

Routine Description:

    Called to notify the pin that a given number of scatter / gather
    mappings have completed.  Let the buffers go if possible.
    We're called at DPC.

Arguments:

    NumMappings -
        The number of mappings that have completed.

Return Value:

    None

--*/

{

    ULONG MappingsRemaining = NumMappings;

    //
    // Walk through the clones list and delete clones whose time has come.
    // The list is guaranteed to be kept in the order they were cloned.
    //
    PKSSTREAM_POINTER Clone = KsPinGetFirstCloneStreamPointer (m_Pin);

    while (MappingsRemaining && Clone) {

        PKSSTREAM_POINTER NextClone = KsStreamPointerGetNextClone (Clone);

        //
        // Count up the number of bytes we've completed and mark this
        // in the Stream Header.  In mapped queues 
        // (KSPIN_FLAG_GENERATE_MAPPINGS), this is the responsibility of
        // the minidriver.  In non-mapped queues, AVStream performs this.
        //
        ULONG MappingsToCount = 
            (MappingsRemaining > Clone -> OffsetOut.Remaining) ?
                 Clone -> OffsetOut.Remaining :
                 MappingsRemaining;

        //
        // Update DataUsed according to the mappings.
        //
        for (ULONG CurMapping = 0; CurMapping < MappingsToCount; CurMapping++) {
            Clone -> StreamHeader -> DataUsed +=
                Clone -> OffsetOut.Mappings [CurMapping].ByteCount;
        }

        // 
        // If we have completed all remaining mappings in this clone, it
        // is an indication that the clone is ready to be deleted and the
        // buffer released.  Set anything required in the stream header which
        // has not yet been set.  If we have a clock, we can timestamp the
        // sample.
        //
        if (MappingsRemaining >= Clone -> OffsetOut.Remaining) {

            Clone -> StreamHeader -> Duration =
                m_TransportInfo -> AvgTimePerFrame;

            Clone -> StreamHeader -> PresentationTime.Numerator =
                Clone -> StreamHeader -> PresentationTime.Denominator = 1;

            //
            // If a clock has been assigned, timestamp the packets with the
            // time shown on the clock. 
            //
            if (m_Clock) {

                LONGLONG ClockTime = m_Clock -> GetTime ();

                Clone -> StreamHeader -> PresentationTime.Time = ClockTime;

                Clone -> StreamHeader -> OptionsFlags =
                    KSSTREAM_HEADER_OPTIONSF_TIMEVALID |
                    KSSTREAM_HEADER_OPTIONSF_DURATIONVALID;

            } else {
                //
                // If there is no clock, don't time stamp the packets.
                //
                Clone -> StreamHeader -> PresentationTime.Time = 0;

            }

            //
            // If all of the mappings in this clone have been completed,
            // delete the clone.  We've already updated DataUsed above.
            //

            MappingsRemaining -= Clone -> OffsetOut.Remaining;
            KsStreamPointerDelete (Clone);


        } else {
            //
            // If only part of the mappings in this clone have been completed,
            // update the pointers.  Since we're guaranteed this won't advance
            // to a new frame by the check above, it won't fail.
            //
            KsStreamPointerAdvanceOffsets (
                Clone,
                0,
                MappingsRemaining,
                FALSE
                );

            MappingsRemaining = 0;

        }

        //
        // Go to the next clone.
        //
        Clone = NextClone;

    }

    //
    // If we've used all the mappings in hardware and pended, we can kick
    // processing to happen again if we've completed mappings.
    //
    if (m_PendIo) {
        m_PendIo = TRUE;
        KsPinAttemptProcessing (m_Pin, TRUE);
    }

}

/**************************************************************************

    DISPATCH AND DESCRIPTOR LAYOUT

**************************************************************************/

#define TS_PAYLOAD 188
#define TS_PACKETS_PER_BUFFER 312

//
// This is the data range description of the capture output pin.
//
const
KSDATARANGE FormatCaptureOut =
{
   // insert the KSDATARANGE and KSDATAFORMAT here
    {
        sizeof( KSDATARANGE),                               // FormatSize
        0,                                                  // Flags - (N/A)
        TS_PACKETS_PER_BUFFER * TS_PAYLOAD,                 // SampleSize
        0,                                                  // Reserved
        { STATIC_KSDATAFORMAT_TYPE_STREAM },                // MajorFormat
        { STATIC_KSDATAFORMAT_SUBTYPE_BDA_MPEG2_TRANSPORT },// SubFormat
        { STATIC_KSDATAFORMAT_SPECIFIER_NONE }              // Specifier
    }
};

//
// This is the data range description of the capture input pin.
//
const
KS_DATARANGE_BDA_TRANSPORT FormatCaptureIn =
{
   // insert the KSDATARANGE and KSDATAFORMAT here
    {
        sizeof( KS_DATARANGE_BDA_TRANSPORT),                // FormatSize
        0,                                                  // Flags - (N/A)
        0,                                                  // SampleSize - (N/A)
        0,                                                  // Reserved
        { STATIC_KSDATAFORMAT_TYPE_STREAM },                // MajorFormat
        { STATIC_KSDATAFORMAT_TYPE_MPEG2_TRANSPORT },       // SubFormat
        { STATIC_KSDATAFORMAT_SPECIFIER_BDA_TRANSPORT }     // Specifier
    },
    // insert the BDA_TRANSPORT_INFO here
    {
        TS_PAYLOAD,                         //  ulcbPhyiscalPacket
        TS_PACKETS_PER_BUFFER * TS_PAYLOAD, //  ulcbPhyiscalFrame
        0,          //  ulcbPhyiscalFrameAlignment (no requirement)
        0           //  AvgTimePerFrame (not known)
    }
};

//
// CapturePinDispatch:
//
// This is the dispatch table for the capture pin.  It provides notifications
// about creation, closure, processing, data formats, etc...
//
const
KSPIN_DISPATCH
CapturePinDispatch = {
    CCapturePin::DispatchCreate,            // Pin Create
    NULL,                                   // Pin Close
    CCapturePin::DispatchProcess,           // Pin Process
    NULL,                                   // Pin Reset
    NULL,                                   // Pin Set Data Format
    CCapturePin::DispatchSetState,          // Pin Set Device State
    NULL,                                   // Pin Connect
    NULL,                                   // Pin Disconnect
    NULL,                                   // Clock Dispatch
    NULL                                    // Allocator Dispatch
};

//
// InputPinDispatch:
//
// This is the dispatch table for the capture pin.  It provides notifications
// about creation, closure, processing, data formats, etc...
//
const
KSPIN_DISPATCH
InputPinDispatch = {
    CCapturePin::DispatchCreate,            // Pin Create
    NULL,                                   // Pin Close
    NULL,                                   // Pin Process
    NULL,                                   // Pin Reset
    NULL,                                   // Pin Set Data Format
    NULL,                                   // Pin Set Device State
    NULL,                                   // Pin Connect
    NULL,                                   // Pin Disconnect
    NULL,                                   // Clock Dispatch
    NULL                                    // Allocator Dispatch
};

//
// CapturePinAllocatorFraming:
//
// This is the simple framing structure for the capture pin.  Note that this
// will be modified via KsEdit when the actual capture format is determined.
//
DECLARE_SIMPLE_FRAMING_EX (
    CapturePinAllocatorFraming,                     //  FramingExName
    STATICGUIDOF (KSMEMORY_TYPE_KERNEL_NONPAGED),   //  MemoryType
    KSALLOCATOR_REQUIREMENTF_SYSTEM_MEMORY |
        KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY,  //  Flags
    8,                                              //  Frames
    0,                                              //  Alignment
    188 * 312,                                      //  MinFrameSize
    188 * 312                                       //  MaxFrameSize
    );

//
// CaptureOutPinDataRanges:
//
// This is the list of data ranges supported on the capture output pin.
//
const 
PKSDATARANGE 
CaptureOutPinDataRanges [CAPTURE_OUT_PIN_DATA_RANGE_COUNT] = {
    (PKSDATARANGE) &FormatCaptureOut
    };

//
// CaptureInPinDataRanges:
//
// This is the list of data ranges supported on the capture input pin.
//
const 
PKSDATARANGE 
CaptureInPinDataRanges [CAPTURE_IN_PIN_DATA_RANGE_COUNT] = {
    (PKSDATARANGE) &FormatCaptureIn
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\bda\samples\bdacapture\device.h ===
/**************************************************************************

    AVStream Simulated Hardware Sample

    Copyright (c) 2001, Microsoft Corporation.

    File:

        device.h

    Abstract:

        The header for the device level of the simulated hardware.  This is
        not actually the hardware simulation itself.  The hardware simulation
        is contained in hwsim.*, image.*.
        
    History:

        created 3/9/2001

**************************************************************************/

class CCaptureDevice :
    public IHardwareSink {

private:

    //
    // The AVStream device we're associated with.
    //
    PKSDEVICE m_Device;

    //
    // Number of pins with resources acquired.  This is used as a locking
    // mechanism for resource acquisition on the device.
    //
    LONG m_PinsWithResources;

    //
    // Since we don't have physical hardware, this provides the hardware
    // simulation.  m_HardwareSimulation provides the fake ISR, fake DPC,
    // etc...  m_TsSynth provides a place to put transport stream synthesis
    // in software.
    //
    CHardwareSimulation *m_HardwareSimulation;
    CTsSynthesizer *m_TsSynth;

    //
    // The number of ISR's that have occurred since capture started.
    //
    ULONG m_InterruptTime;

    //
    // The last reading of mappings completed.
    //
    ULONG m_LastMappingsCompleted;

    //
    // The Dma adapter object we acquired through IoGetDmaAdapter() during
    // Pnp start.  This must be initialized with AVStream in order to perform
    // Dma directly into the capture buffers.
    //
    PADAPTER_OBJECT m_DmaAdapterObject;

    //
    // The number of map registers returned from IoGetDmaAdapter().
    //
    ULONG m_NumberOfMapRegisters;

    //
    // The capture sink.  When we complete scatter / gather mappings, we
    // notify the capture sink.
    //
    ICaptureSink *m_CaptureSink;

    //
    // The video info header we're basing hardware settings on.  The pin
    // provides this to us when acquiring resources and must guarantee its
    // stability until resources are released.
    //
    PBDA_TRANSPORT_INFO m_TransportInfo;

    //
    // Cleanup():
    //
    // This is the free callback for the bagged capture device.  Not providing
    // one will call ExFreePool, which is not what we want for a constructed
    // C++ object.  This simply deletes the capture device.
    //
    static
    void
    Cleanup (
        IN CCaptureDevice *CapDevice
        )
    {
        delete CapDevice;
    }

    // CleanupHW()
    //
    // Cleanup the hwsimulation object associated with this device.  This is the
    // free callback for the bagged hwsim.
    //
    static
    void
    CleanupHW(
	      IN CHardwareSimulation *hwSim
	      ) 
    {
	delete hwSim;
    }

    //
    // CleanupSynth():
    //
    // Cleanup the image synth associated with this device.  This is the
    // free callback for the bagged image synth.
    //
    static
    void
    CleanupSynth (
        IN CTsSynthesizer *TsSynth
        )
    {
        delete TsSynth;
    }

    //
    // PnpStart():
    //
    // This is the Pnp start routine for our simulated hardware.  Note that
    // DispatchStart bridges to here in the context of the CCaptureDevice.
    //
    NTSTATUS
    PnpStart (
        IN PCM_RESOURCE_LIST TranslatedResourceList,
        IN PCM_RESOURCE_LIST UntranslatedResourceList
        );

    //
    // PnpStop():
    //
    // This is the Pnp stop routine for our simulated hardware.  Note that
    // DispatchStop bridges to here in the context of the CCaptureDevice.
    //
    void
    PnpStop (
        );

public:

    //
    // CCaptureDevice():
    //
    // The capture device class constructor.  Since everything should have
    // been zero'ed by the new operator, don't bother setting anything to
    // zero or NULL.  Only initialize non-NULL, non-0 fields.
    //
    CCaptureDevice (
        IN PKSDEVICE Device
        ) :
        m_Device (Device)
    {
    }

    //
    // ~CCaptureDevice():
    //
    // The capture device destructor.
    //
    ~CCaptureDevice (
        )
    {
    }

    //
    // DispatchCreate():
    //
    // This is the Add Device dispatch for the capture device.  It creates
    // the CCaptureDevice and associates it with the device via the bag.
    //
    static
    NTSTATUS
    DispatchCreate (
        IN PKSDEVICE Device
        );

    //
    // DispatchPnpStart():
    //
    // This is the Pnp Start dispatch for the capture device.  It simply
    // bridges to PnpStart() in the context of the CCaptureDevice.
    //
    static
    NTSTATUS
    DispatchPnpStart (
        IN PKSDEVICE Device,
        IN PIRP Irp,
        IN PCM_RESOURCE_LIST TranslatedResourceList,
        IN PCM_RESOURCE_LIST UntranslatedResourceList
        )
    {
        return 
            (reinterpret_cast <CCaptureDevice *> (Device -> Context)) ->
            PnpStart (
                TranslatedResourceList,
                UntranslatedResourceList
                );
    }

    //
    // DispatchPnpStop():
    //
    // This is the Pnp stop dispatch for the capture device.  It simply
    // bridges to PnpStop() in the context of the CCaptureDevice.
    //
    static
    void
    DispatchPnpStop (
        IN PKSDEVICE Device,
        IN PIRP Irp
        )
    {
        return
            (reinterpret_cast <CCaptureDevice *> (Device -> Context)) ->
            PnpStop (
                );
    }

    //
    // AcquireHardwareResources():
    //
    // Called to acquire hardware resources for the device based on a given
    // video info header.  This will fail if another object has already
    // acquired hardware resources since we emulate a single capture
    // device.
    //
    NTSTATUS
    AcquireHardwareResources (
        IN ICaptureSink *CaptureSink,
        IN PBDA_TRANSPORT_INFO TransportInfo
        );

    //
    // ReleaseHardwareResources():
    //
    // Called to release hardware resources for the device.
    //
    void
    ReleaseHardwareResources (
        );

    //
    // Start():
    //
    // Called to start the hardware simulation.  This causes us to simulate
    // interrupts, simulate filling buffers with synthesized data, etc...
    //
    NTSTATUS
    Start (
        );

    //
    // Pause():
    //
    // Called to pause or unpause the hardware simulation.  This will be
    // indentical to a start or stop but it will not reset formats and 
    // counters.
    //
    NTSTATUS
    Pause (
        IN BOOLEAN Pausing
        );

    //
    // Stop():
    //
    // Called to stop the hardware simulation.  This causes interrupts to
    // stop issuing.  When this call returns, the "fake" hardware has
    // stopped accessing all s/g buffers, etc...
    //
    NTSTATUS
    Stop (
        );

    //
    // ProgramScatterGatherMappings():
    //
    // Called to program the hardware simulation's scatter / gather table.
    // This synchronizes with the "fake" ISR and hardware simulation via
    // a spinlock.
    //
    ULONG
    ProgramScatterGatherMappings (
        IN PUCHAR *Buffer,
        IN PKSMAPPING Mappings,
        IN ULONG MappingsCount
        );

    //
    // QueryInterruptTime():
    //
    // Determine the frame number that this frame corresponds to.  
    //
    ULONG
    QueryInterruptTime (
        );

    //
    // IHardwareSink::Interrupt():
    //
    // The interrupt service routine as called through the hardware sink
    // interface.  The "fake" hardware uses this method to inform the device
    // of a "fake" ISR.  The routine is called at dispatch level and must
    // be in locked code.
    //
    virtual
    void
    Interrupt (
        );

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\bda\samples\bdacapture\hwsim.h ===
/**************************************************************************

    AVStream Simulated Hardware Sample

    Copyright (c) 2001, Microsoft Corporation.

    File:

        hwsim.cpp

    Abstract:
        
        This file is the hardware simulation header.  

        The simulation fakes "DMA" transfers, scatter gather mapping handling, 
        ISR's, etc...  The ISR routine in here will be called when an ISR 
        would be generated by the fake hardware and it will directly call into 
        the device level ISR for more accurate simulation.

    History:

        created 3/9/2001

**************************************************************************/

//
// SCATTER_GATHER_MAPPINGS_MAX:
//
// The maximum number of entries in the hardware's scatter/gather list.  I
// am making this so large for a few reasons:
//
//     1) we're faking this with uncompressed surfaces -- 
//            these are large buffers which will map to a lot of s/g entries
//     2) the fake hardware implementation requires at least one frame's
//            worth of s/g entries to generate a frame
//
#define SCATTER_GATHER_MAPPINGS_MAX 128

//
// SCATTER_GATHER_ENTRY:
//
// This structure is used to keep the scatter gather table for the fake
// hardware as a doubly linked list.
//
typedef struct _SCATTER_GATHER_ENTRY {

    LIST_ENTRY ListEntry;
    PUCHAR Virtual;
    ULONG ByteCount;

} SCATTER_GATHER_ENTRY, *PSCATTER_GATHER_ENTRY;

//
// CHardwareSimulation:
//
// The hardware simulation class.
//
class CHardwareSimulation {

private:

    //
    // The transport stream synthesizer.  This is a piece of code which
    // fills in the requested transport stream.
    //
    CTsSynthesizer *m_TsSynth;

    //
    // The synthesis buffer.  This is a private buffer we use to generate the
    // transport stream in.  The fake "scatter / gather" mappings are filled
    // in from this buffer during each interrupt.
    //
    PUCHAR m_SynthesisBuffer;

    //
    // Key information regarding the frames we generate.
    //
    LONGLONG m_TimePerFrame;
    ULONG m_PacketSize;
    ULONG m_PacketsPerSample;
    ULONG m_SampleSize;

    //
    // Scatter gather mappings for the simulated hardware.
    //
    KSPIN_LOCK m_ListLock;
    LIST_ENTRY m_ScatterGatherMappings;

    //
    // Lookaside for memory for the scatter / gather entries on the scatter /
    // gather list.
    //
    NPAGED_LOOKASIDE_LIST m_ScatterGatherLookaside;

    //
    // The current state of the fake hardware.
    //
    HARDWARE_STATE m_HardwareState;

    //
    // The pause / stop hardware flag and event.
    //
    BOOLEAN m_StopHardware;
    KEVENT m_HardwareEvent;

    //
    // Maximum number of scatter / gather mappins in the s/g table of the
    // fake hardware.
    //
    ULONG m_ScatterGatherMappingsMax;

    //
    // Number of scatter / gather mappings that have been completed (total)
    // since the start of the hardware or any reset.
    //
    ULONG m_NumMappingsCompleted;

    //
    // Number of scatter / gather mappings that are queued for this hardware.
    //
    ULONG m_ScatterGatherMappingsQueued;
    ULONG m_ScatterGatherBytesQueued;

    //
    // Number of frames skipped due to lack of scatter / gather mappings.
    //
    ULONG m_NumFramesSkipped;

    //
    // The "Interrupt Time".  Number of "fake" interrupts that have occurred
    // since the hardware was started.
    // 
    ULONG m_InterruptTime;

    //
    // The system time at start.
    //
    LARGE_INTEGER m_StartTime;
    
    //
    // The DPC used to "fake" ISR
    //
    KDPC m_IsrFakeDpc;
    KTIMER m_IsrTimer;

    //
    // The hardware sink that will be used for interrupt notifications.
    //
    IHardwareSink *m_HardwareSink;


    //
    // FakeHardware():
    //
    // Called from the simulated interrupt.  First we fake the hardware's
    // actions (at DPC) then we call the "Interrupt service routine" on
    // the hardware sink.
    //
    void 
    FakeHardware (
        );

    //
    // SimulatedInterrupt():
    //
    // This is the hardware's simulated interrupt.  Really, it's just a DPC.
    // We'll use a spinlock instead of any KeSynchronizeExecutions.
    //
    static
    void
    SimulatedInterrupt (
        IN PKDPC Dpc,
        IN CHardwareSimulation *HardwareSim,
        IN PVOID SystemArg1,
        IN PVOID SystemArg2
        )
    {
        HardwareSim -> FakeHardware ();
    }

    //
    // FillScatterGatherBuffers():
    //
    // This is called by the hardware simulation to fill a series of scatter /
    // gather buffers with synthesized data.
    //
    NTSTATUS
    FillScatterGatherBuffers (
        );

public:

    //
    // CHardwareSimulation():
    //
    // The hardware simulation constructor.  Since the new operator will
    // have zeroed the memory, only initialize non-NULL, non-0 fields. 
    //
    CHardwareSimulation (
        IN IHardwareSink *HardwareSink
        );

    //
    // ~CHardwareSimulation():
    //
    // The hardware simulation destructor.
    //
    ~CHardwareSimulation (
        )
    {
    }

    //
    // Start():
    //
    // "Start" the fake hardware.  This will start issuing interrupts and 
    // DPC's. 
    //
    // The sample rate, sample size, and a synthesizer must be provided.
    //
    NTSTATUS
    Start (
        CTsSynthesizer *TsSynth,
        IN LONGLONG TimePerSample,
        IN ULONG PacketWidth,
        IN ULONG PacketsPerSample
        );

    //
    // Pause():
    //
    // "Pause" or "unpause" the fake hardware.  This will stop issuing 
    // interrupts or DPC's on a pause and restart them on an unpause.  Note
    // that this will not reset counters as a Stop() would.
    //
    NTSTATUS
    Pause (
        IN BOOLEAN Pausing
        );

    //
    // Stop():
    //
    // "Stop" the fake hardware.  This will stop issuing interrupts and
    // DPC's.
    //
    NTSTATUS
    Stop (
        );

    //
    // ProgramScatterGatherMappings():
    //
    // Program a series of scatter gather mappings into the fake hardware.
    //
    ULONG
    ProgramScatterGatherMappings (
        IN PUCHAR *Buffer,
        IN PKSMAPPING Mappings,
        IN ULONG MappingsCount,
        IN ULONG MappingStride
        );

    //
    // ReadNumberOfMappingsCompleted():
    //
    // Read the number of mappings completed since the last hardware reset.
    //
    ULONG
    ReadNumberOfMappingsCompleted (
        );

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\bda\samples\bdacapture\capture.h ===
/**************************************************************************

    AVStream Simulated Hardware Sample

    Copyright (c) 2001, Microsoft Corporation.

    File:

        capture.h

    Abstract:

        This file contains header for the video capture pin on the capture
        filter.  The capture sample performs "fake" DMA directly into
        the capture buffers.  Common buffer DMA will work slightly differently.

        For common buffer DMA, the general technique would be DPC schedules
        processing with KsPinAttemptProcessing.  The processing routine grabs
        the leading edge, copies data out of the common buffer and advances.
        Cloning would not be necessary with this technique.  It would be 
        similiar to the way "AVSSamp" works, but it would be pin-centric.

    History:

        created 3/8/2001

**************************************************************************/

//
// STREAM_POINTER_CONTEXT:
//
// This is the context structure we associate with all clone stream pointers.
// It allows the mapping code to rip apart the buffer into chunks the same
// size as the scatter/gather mappings in order to fake scatter / gather
// bus-master DMA.
//
typedef struct _STREAM_POINTER_CONTEXT {
    
    PUCHAR BufferVirtual;

} STREAM_POINTER_CONTEXT, *PSTREAM_POINTER_CONTEXT;

//
// CCapturePin:
//
// The video capture pin class.
//
class CCapturePin :
    public ICaptureSink {

private:

    //
    // The AVStream pin we're associated with.
    //
    PKSPIN m_Pin;

    //
    // Pointer to the internal device object for our capture device.
    // We access the "fake" hardware through this object.
    //
    CCaptureDevice *m_Device;

    //
    // The state we've put the hardware into.  This allows us to keep track
    // of whether to do things like unpausing or restarting.
    //
    HARDWARE_STATE m_HardwareState;

    //
    // The clock we've been assigned.  As with other capture filters, we do
    // not expose a clock.  If one has been assigned, we will use it to
    // time stamp packets (plus a reasonable delta to work the capture stream
    // in a preview graph).
    //
    PIKSREFERENCECLOCK m_Clock;

    //
    // The transport information for this capture pin.  The settings for "fake" hardware will be
    // programmed for this transport info.
    //
    PBDA_TRANSPORT_INFO m_TransportInfo;

    //
    // If we are unable to insert all of the mappings in a stream pointer into
    // the "fake" hardware's scatter / gather table, we set this to the
    // stream pointer that's incomplete.  This is done both to make the 
    // relasing easier and to make it easier to fake the scatter / gather
    // hardware.
    //
    PKSSTREAM_POINTER m_PreviousStreamPointer;

    //
    // An indication of whether or not we pended I/O for some reason.  If this
    // is set, the DPC will resume I/O when any mappings are completed.
    //
    BOOLEAN m_PendIo;

    //
    // An indication of whether or not this pin has acquired the necessary
    // hardware resources to operate.  When the pin reaches KSSTATE_ACQUIRE,
    // we attempt to acquire the hardware.  This flag will be set based on
    // our success / failure.
    //
    BOOLEAN m_AcquiredResources;

    //
    // CleanupReferences():
    //
    // Clean up any references we hold on frames in the queue.  This is called
    // when we abruptly stop the fake hardware.
    //
    NTSTATUS
    CleanupReferences (
        );

    //
    // SetState():
    //
    // This is the state transition handler for the capture pin.  It attempts
    // to acquire resources for the capture pin (or releasing them if
    // necessary) and starts and stops the hardware as required.
    //
    NTSTATUS
    SetState (
        IN KSSTATE ToState,
        IN KSSTATE FromState
        );

    //
    // Process():
    //
    // This is the processing dispatch for the capture pin.  It handles
    // programming the scatter / gather tables for the hardware as buffers
    // become available.  This processing routine is designed for a direct
    // into the capture buffers kind of DMA as opposed to common-buffer
    // and copy strategies.
    //
    NTSTATUS
    Process (
        );

    //
    // CaptureBdaTransportInfo():
    //
    // This routine stashes the BDA Transport Info for the pin connection
    // in the CCapturePin object.  This is used to base hardware settings.
    //
    PBDA_TRANSPORT_INFO
    CaptureBdaTransportInfo (
        );

    //
    // Cleanup():
    //
    // This is the free callback from the bagged item (CCapturePin).  If we
    // do not provide a callback when we bag the CCapturePin, ExFreePool
    // would be called.  This is not desirable for C++ constructed objects.
    // We merely delete the object here.
    //
    static
    void
    Cleanup (
        IN CCapturePin *Pin
        )
    {
        delete Pin;
    }

public:

    //
    // CCapturePin():
    //
    // The capture pin's constructor.  Initialize any non-0, non-NULL fields
    // (since new will have zero'ed the memory anyway) and set up our
    // device level pointers for access during capture routines.
    //
    CCapturePin (
        IN PKSPIN Pin
        );

    //
    // ~CCapturePin():
    //
    // The capture pin's destructor.
    //
    ~CCapturePin (
        )
    {
    }

    //
    // ICaptureSink::CompleteMappings()
    //
    // This is the capture sink notification mechanism for mapping completion.
    // When the device DPC detects that a given number of mappings have been
    // completed by the fake hardware, it signals the capture sink of this
    // through this method.
    //
    virtual
    void
    CompleteMappings (
        IN ULONG NumMappings
        );

    /*************************************************

        Dispatch Routines

    *************************************************/

    //
    // DispatchCreate():
    //
    // This is the creation dispatch for the capture pin.  It creates
    // the CCapturePin object and associates it with the AVStream object
    // bagging it in the process.
    //
    static
    NTSTATUS
    DispatchCreate (
        IN PKSPIN Pin,
        IN PIRP Irp
        );

    //
    // DispatchSetState():
    //
    // This is the set device state dispatch for the pin.  The routine bridges
    // to SetState() in the context of the CCapturePin.
    //
    static
    NTSTATUS
    DispatchSetState (
        IN PKSPIN Pin,
        IN KSSTATE ToState,
        IN KSSTATE FromState
        )
    {
        return 
            (reinterpret_cast <CCapturePin *> (Pin -> Context)) ->
                SetState (ToState, FromState);
    }

    //
    // DispatchProcess():
    //
    // This is the processing dispatch for the capture pin.  The routine 
    // bridges to Process() in the context of the CCapturePin.
    //
    static 
    NTSTATUS
    DispatchProcess (
        IN PKSPIN Pin
        )
    {
        return 
            (reinterpret_cast <CCapturePin *> (Pin -> Context)) ->
                Process ();
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\bda\samples\bdacapture\hwsim.cpp ===
/**************************************************************************

    AVStream Simulated Hardware Sample

    Copyright (c) 2001, Microsoft Corporation.

    File:

        hwsim.cpp

    Abstract:
        
        This file contains the hardware simulation.  It fakes "DMA" transfers,
        scatter gather mapping handling, ISR's, etc...  The ISR routine in
        here will be called when an ISR would be generated by the fake hardware
        and it will directly call into the device level ISR for more accurate
        simulation.

    History:

        created 3/9/2001

**************************************************************************/

#include "BDACap.h"

/**************************************************************************

    PAGEABLE CODE

**************************************************************************/

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA


CHardwareSimulation::
CHardwareSimulation (
    IN IHardwareSink *HardwareSink
    ) :
    m_HardwareSink (HardwareSink),
    m_ScatterGatherMappingsMax (SCATTER_GATHER_MAPPINGS_MAX)

/*++

Routine Description:

    Construct a hardware simulation

Arguments:

    HardwareSink -
        The hardware sink interface.  This is used to trigger
        fake interrupt service routines from.

Return Value:

    Success / Failure

--*/

{

    PAGED_CODE();

    //
    // Initialize the DPC's, timer's, and locks necessary to simulate
    // this capture hardware.
    //
    KeInitializeDpc (
        &m_IsrFakeDpc, 
        reinterpret_cast <PKDEFERRED_ROUTINE> 
            (CHardwareSimulation::SimulatedInterrupt),
        this
        );

    KeInitializeEvent (
        &m_HardwareEvent,
        SynchronizationEvent,
        FALSE
        );

    KeInitializeTimer (&m_IsrTimer);

    KeInitializeSpinLock (&m_ListLock);

}

/*************************************************/


NTSTATUS
CHardwareSimulation::
Start (
    IN CTsSynthesizer *TsSynth,
    IN LONGLONG TimePerFrame,
    IN ULONG PacketSize,
    IN ULONG PacketsPerSample
    )

/*++

Routine Description:

    Start the hardware simulation.  This will kick the interrupts on,
    begin issuing DPC's, filling in capture information, etc...
    We keep track of starvation starting at this point.

Arguments:

    TsSynth -
        The transport stream synthesizer to use to generate TS packets
        on the capture buffer.

    TimePerFrame -
        The time per frame...  we issue interrupts this often.

    PacketSize -
        The size of a single transport stream packet.

    PacketsPerSample -
        The number of packets in a single capture sample

Return Value:

    Success / Failure (typical failure will be out of memory on the 
    scratch buffer, etc...)

--*/

{

    PAGED_CODE();

    NTSTATUS Status = STATUS_SUCCESS;

    m_TsSynth = TsSynth;
    m_TimePerFrame = TimePerFrame;
    m_SampleSize = PacketSize * PacketsPerSample;
    m_PacketSize = PacketSize;
    m_PacketsPerSample = PacketsPerSample;

    InitializeListHead (&m_ScatterGatherMappings);
    m_NumMappingsCompleted = 0;
    m_ScatterGatherMappingsQueued = 0;
    m_NumFramesSkipped = 0;
    m_InterruptTime = 0;

    KeQuerySystemTime (&m_StartTime);

    //
    // Allocate a scratch buffer for the synthesizer.
    //
    m_SynthesisBuffer = reinterpret_cast <PUCHAR> (
        ExAllocatePool (
            NonPagedPool,
            m_SampleSize
            )
        );

    if (!m_SynthesisBuffer) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // If everything is ok, start issuing interrupts.
    //
    if (NT_SUCCESS (Status)) {

        //
        // Initialize the entry lookaside.
        //
        ExInitializeNPagedLookasideList (
            &m_ScatterGatherLookaside,
            NULL,
            NULL,
            0,
            sizeof (SCATTER_GATHER_ENTRY),
            'nEGS',
            0
            );

        //
        // Set up the synthesizer with the width, height, and scratch buffer.
        //
        m_TsSynth -> SetSampleSize (m_PacketSize, m_PacketsPerSample);
        m_TsSynth -> SetBuffer (m_SynthesisBuffer);

        LARGE_INTEGER NextTime;
        NextTime.QuadPart = m_StartTime.QuadPart + m_TimePerFrame;

        m_HardwareState = HardwareRunning;
        KeSetTimer (&m_IsrTimer, NextTime, &m_IsrFakeDpc);

    }

    return Status;
        
}

/*************************************************/


NTSTATUS
CHardwareSimulation::
Pause (
    BOOLEAN Pausing
    )

/*++

Routine Description:

    Pause the hardware simulation...  When the hardware simulation is told
    to pause, it stops issuing interrupts, etc...  but it does not reset
    the counters 

Arguments:

    Pausing -
        Indicates whether the hardware is pausing or not. 

        TRUE -
            Pause the hardware

        FALSE -
            Unpause the hardware from a previous pause


Return Value:

    Success / Failure

--*/

{

    PAGED_CODE();

    if (Pausing && m_HardwareState == HardwareRunning) {
        //
        // If we were running, stop completing mappings, etc...
        //
        m_StopHardware = TRUE;
    
        KeWaitForSingleObject (
            &m_HardwareEvent,
            Suspended,
            KernelMode,
            FALSE,
            NULL
            );

        ASSERT (m_StopHardware == FALSE);

        m_HardwareState = HardwarePaused; 

    } else if (!Pausing && m_HardwareState == HardwarePaused) {

        //
        // For unpausing the hardware, we need to compute the relative time
        // and restart interrupts.
        //
        LARGE_INTEGER UnpauseTime;

        KeQuerySystemTime (&UnpauseTime);
        m_InterruptTime = (ULONG) (
            (UnpauseTime.QuadPart - m_StartTime.QuadPart) /
            m_TimePerFrame
            );

        UnpauseTime.QuadPart = m_StartTime.QuadPart +
            (m_InterruptTime + 1) * m_TimePerFrame;

        m_HardwareState = HardwareRunning;
        KeSetTimer (&m_IsrTimer, UnpauseTime, &m_IsrFakeDpc);

    }

    return STATUS_SUCCESS;

}

/*************************************************/


NTSTATUS
CHardwareSimulation::
Stop (
    )

/*++

Routine Description:

    Stop the hardware simulation....  Wait until the hardware simulation
    has successfully stopped and then return.

Arguments:

    None

Return Value:

    Success / Failure

--*/

{

    PAGED_CODE();

    //
    // If the hardware is told to stop while it's running, we need to
    // halt the interrupts first.  If we're already paused, this has
    // already been done.
    //
    if (m_HardwareState == HardwareRunning) {
    
        m_StopHardware = TRUE;
    
        KeWaitForSingleObject (
            &m_HardwareEvent,
            Suspended,
            KernelMode,
            FALSE,
            NULL
            );
    
        ASSERT (m_StopHardware == FALSE);

    }

    m_HardwareState = HardwareStopped;

    //
    // The image synthesizer may still be around.  Just for safety's
    // sake, NULL out the image synthesis buffer and toast it.
    //
    m_TsSynth -> SetBuffer (NULL);

    if (m_SynthesisBuffer) {
        ExFreePool (m_SynthesisBuffer);
        m_SynthesisBuffer = NULL;
    }

    //
    // Delete the scatter / gather lookaside for this run.
    //
    ExDeleteNPagedLookasideList (&m_ScatterGatherLookaside);

    return STATUS_SUCCESS;

}

/**************************************************************************

    LOCKED CODE

**************************************************************************/

#ifdef ALLOC_PRAGMA
#pragma code_seg()
#endif // ALLOC_PRAGMA


ULONG
CHardwareSimulation::
ReadNumberOfMappingsCompleted (
    )

/*++

Routine Description:

    Read the number of scatter / gather mappings which have been
    completed (TOTAL NUMBER) since the last reset of the simulated
    hardware

Arguments:

    None

Return Value:

    Total number of completed mappings.

--*/

{

    //
    // Don't care if this is being updated this moment in the DPC...  I only
    // need a number to return which isn't too great (too small is ok).
    // In real hardware, this wouldn't be done this way anyway.
    //
    return m_NumMappingsCompleted;

}

/*************************************************/


ULONG
CHardwareSimulation::
ProgramScatterGatherMappings (
    IN PUCHAR *Buffer,
    IN PKSMAPPING Mappings,
    IN ULONG MappingsCount,
    IN ULONG MappingStride
    )

/*++

Routine Description:

    Program the scatter gather mapping list.  This shoves a bunch of 
    entries on a list for access during the fake interrupt.  Note that
    we have physical addresses here only for simulation.  We really
    access via the virtual address....  although we chunk it into multiple
    buffers to more realistically simulate S/G

Arguments:

    Buffer -
        The virtual address of the buffer mapped by the mapping list 

    Mappings -
        The KSMAPPINGS array corresponding to the buffer

    MappingsCount -
        The number of mappings in the mappings array

    MappingStride -
        The mapping stride used in initialization of AVStream DMA

Return Value:

    Number of mappings actually inserted.

--*/

{

    KIRQL Irql;

    ULONG MappingsInserted = 0;

    //
    // Protect our S/G list with a spinlock.
    //
    KeAcquireSpinLock (&m_ListLock, &Irql);

    //
    // Loop through the scatter / gather list and break the buffer up into
    // chunks equal to the scatter / gather mappings.  Stuff the virtual
    // addresses of these chunks on a list somewhere.  We update the buffer
    // pointer the caller passes as a more convenient way of doing this.
    //
    // If I could just remap physical in the list to virtual easily here,
    // I wouldn't need to do it.
    //
    for (ULONG MappingNum = 0; 
        MappingNum < MappingsCount &&
            m_ScatterGatherMappingsQueued < m_ScatterGatherMappingsMax; 
        MappingNum++) {

        PSCATTER_GATHER_ENTRY Entry =
            reinterpret_cast <PSCATTER_GATHER_ENTRY> (
                ExAllocateFromNPagedLookasideList (
                    &m_ScatterGatherLookaside
                    )
                );

        if (!Entry) {
            break;
        }

        Entry -> Virtual = *Buffer;
        Entry -> ByteCount = Mappings -> ByteCount;

        //
        // Move forward a specific number of bytes in chunking this into
        // mapping sized va buffers.
        //
        *Buffer += Entry -> ByteCount;
        Mappings = reinterpret_cast <PKSMAPPING> (
            (reinterpret_cast <PUCHAR> (Mappings) + MappingStride)
            );

        InsertTailList (&m_ScatterGatherMappings, &(Entry -> ListEntry));
        MappingsInserted++;
        m_ScatterGatherMappingsQueued++;
        m_ScatterGatherBytesQueued += Entry -> ByteCount;

    }

    KeReleaseSpinLock (&m_ListLock, Irql);

    return MappingsInserted;

}

/*************************************************/


NTSTATUS
CHardwareSimulation::
FillScatterGatherBuffers (
    )

/*++

Routine Description:

    The hardware has synthesized a buffer in scratch space and we're to
    fill scatter / gather buffers.

Arguments:

    None

Return Value:

    Success / Failure

--*/

{

    //
    // We're using this list lock to protect our scatter / gather lists instead
    // of some hardware mechanism / KeSynchronizeExecution / whatever.
    //
    KeAcquireSpinLockAtDpcLevel (&m_ListLock);

    PUCHAR Buffer = reinterpret_cast <PUCHAR> (m_SynthesisBuffer);
    ULONG BufferRemaining = m_SampleSize;

    //
    // For simplification, if there aren't enough scatter / gather buffers
    // queued, we don't partially fill the ones that are available.  We just
    // skip the frame and consider it starvation.
    //
    // This could be enforced by only programming scatter / gather mappings
    // for a buffer if all of them fit in the table also...
    //
    while (BufferRemaining &&
        m_ScatterGatherMappingsQueued > 0 &&
        m_ScatterGatherBytesQueued >= BufferRemaining) {

        LIST_ENTRY *listEntry = RemoveHeadList (&m_ScatterGatherMappings);
        m_ScatterGatherMappingsQueued--;

        PSCATTER_GATHER_ENTRY SGEntry =  
            reinterpret_cast <PSCATTER_GATHER_ENTRY> (
                CONTAINING_RECORD (
                    listEntry,
                    SCATTER_GATHER_ENTRY,
                    ListEntry
                    )
                );

        //
        // Since we're software, we'll be accessing this by virtual address...
        //
        ULONG BytesToCopy = 
            (BufferRemaining < SGEntry -> ByteCount) ?
            BufferRemaining :
            SGEntry -> ByteCount;

        RtlCopyMemory (
            SGEntry -> Virtual,
            Buffer,
            BytesToCopy
            );

        BufferRemaining -= BytesToCopy;
        Buffer += BytesToCopy;
        m_NumMappingsCompleted++;
        m_ScatterGatherBytesQueued -= SGEntry -> ByteCount;

        //
        // Release the scatter / gather entry back to our lookaside.
        //
        ExFreeToNPagedLookasideList (
            &m_ScatterGatherLookaside,
            reinterpret_cast <PVOID> (SGEntry)
            );

    }
    
    KeReleaseSpinLockFromDpcLevel (&m_ListLock);

    if (BufferRemaining) return STATUS_INSUFFICIENT_RESOURCES;
    else return STATUS_SUCCESS;
    
}

/*************************************************/


void
CHardwareSimulation::
FakeHardware (
    )

/*++

Routine Description:

    Simulate an interrupt and what the hardware would have done in the
    time since the previous interrupt.

Arguments:

    None

Return Value:

    None

--*/

{

    m_InterruptTime++;

    //
    // The hardware can be in a pause state in which case, it issues interrupts
    // but does not complete mappings.  In this case, don't bother synthesizing
    // a frame and doing the work of looking through the mappings table.
    //
    if (m_HardwareState == HardwareRunning) {
    
        //
        // Fill scatter gather buffers
        //
        if (!NT_SUCCESS (FillScatterGatherBuffers ())) {
            InterlockedIncrement (PLONG (&m_NumFramesSkipped));
        }

    }
        
    //
    // Issue an interrupt to our hardware sink.  This is a "fake" interrupt.
    // It will occur at DISPATCH_LEVEL.
    //
    m_HardwareSink -> Interrupt ();

    //
    // Reschedule the timer if the hardware isn't being stopped.
    //
    if (!m_StopHardware) {

        //
        // Reschedule the timer for the next interrupt time.
        //
        LARGE_INTEGER NextTime;
        NextTime.QuadPart = m_StartTime.QuadPart + 
            (m_TimePerFrame * (m_InterruptTime + 1));

        KeSetTimer (&m_IsrTimer, NextTime, &m_IsrFakeDpc);
        
    } else {
        //
        // If someone is waiting on the hardware to stop, raise the stop
        // event and clear the flag.
        //
        m_StopHardware = FALSE;
        KeSetEvent (&m_HardwareEvent, IO_NO_INCREMENT, FALSE);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\bda\samples\bdacapture\filter.h ===
/**************************************************************************

    AVStream Simulated Hardware Sample

    Copyright (c) 2001, Microsoft Corporation.

    File:

        filter.h

    Abstract:

        This file contains the filter level header for the capture filter.

    History:

        created 3/12/2001

**************************************************************************/

class CCaptureFilter {

private:

    //
    // The AVStream filter object associated with this CCaptureFilter.
    //
    PKSFILTER m_Filter;

    //
    // Cleanup():
    //
    // This is the bag cleanup callback for the CCaptureFilter.  Not providing
    // one would cause ExFreePool to be used.  This is not good for C++
    // constructed objects.  We simply delete the object here.
    //
    static
    void
    Cleanup (
        IN CCaptureFilter *CapFilter
        )
    {
        delete CapFilter;
    }

public:

    //
    // CCaptureFilter():
    //
    // The capture filter object constructor.  Since the new operator will
    // have zeroed the memory, do not bother initializing any NULL or 0
    // fields.  Only initialize non-NULL, non-0 fields.
    //
    CCaptureFilter (
        IN PKSFILTER Filter
        ) :
        m_Filter (Filter)
    {
    }

    //
    // ~CCaptureFilter():
    //
    // The capture filter destructor.
    //
    ~CCaptureFilter (
        )
    {
    }

    //
    // DispatchCreate():
    //
    // This is the filter creation dispatch for the capture filter.  It
    // creates the CCaptureFilter object, associates it with the AVStream
    // object, and bags it for easy cleanup later.
    //
    static
    NTSTATUS
    DispatchCreate (
        IN PKSFILTER Filter,
        IN PIRP Irp
        );

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\bda\samples\bdatuner\bdaguid.c ===
#include <wdm.h>
#include <windef.h>
#include <ks.h>
#include <ksmedia.h>
#include <bdatypes.h>

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif // ALLOC_PRAGMA

//  KSGuid.h defines INITGUID and some other macros that are useful in the
//  the actual definition of GUIDs.
//  KSGuid.h should be included immediately before those include files that
//  contain the GUIDS that you need defined.  Do NOT put it before include
//  files like KSMedia.h.  If you need definitions of GUIDS that are declared
//  there, use KSGuid.lib.
//
#include <ksguid.h>

#include <bdamedia.h>
#include <atsmedia.h>

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif // ALLOC_DATA_PRAGMA
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\bda\samples\bdacapture\tstream.cpp ===
/**************************************************************************

    AVStream Simulated Hardware Sample

    Copyright (c) 2001, Microsoft Corporation.

    File:

        TStream.cpp

    Abstract:


    History:

        created 1/16/2001

**************************************************************************/

#include "BDACap.h"

/**************************************************************************

    Constants

**************************************************************************/

/**************************************************************************

    LOCKED CODE

**************************************************************************/

#ifdef ALLOC_PRAGMA
#pragma code_seg()
#endif // ALLOC_PRAGMA


void
CTsSynthesizer::
SynthesizeTS (
    )

/*++

Routine Description:

    Synthesize a transport stream.  The synthesized packets should be placed
    into the current synthesis buffer.

Arguments:

    None

Return Value:

    None

--*/

{
    
    //
    // Copy the synthesized transport stream to the synthesis buffer
    //

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\bda\samples\bdatuner\bdadebug.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;


#ifndef __BDADEBUG_H
#define __BDADEBUG_H
#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

//======================================================;
//  Interfaces provided by this file:
//
//      All interfaces provided by this file only exist and generate
//      code when DEBUG is defined.  No code or data are generated when
//      DEBUG is not defined.
//
//      CDEBUG_BREAK()
//          Causes a trap #3, which hopefully will put you
//          in your debugger.
//
//      MDASSERT(exp)
//          If <exp> evaluates to false, prints a failure message
//          and calls CDEBUG_BREAK()
//
//      CdebugPrint(level, (printf_args));
//          If <level> is >= _CDebugLevel, then calls
//          DbgPrint(printf_args)
//
//======================================================;

#define DEBUG_BREAK     DbgBreakPoint()


#ifdef DEBUG

#define DEBUG_LEVEL     DEBUGLVL_VERBOSE     //DEBUGLVL_TERSE

#  if _X86_
#    define CDEBUG_BREAK()  { __asm { int 3 }; }
#  else
#    define CDEBUG_BREAK()  DbgBreakPoint()
#  endif

   extern char _CDebugAssertFail[];
#  define MDASSERT(exp) {\
    if ( !(exp) ) {\
        DbgPrint(_CDebugAssertFail, #exp, __FILE__, __LINE__); \
        CDEBUG_BREAK(); \
    }\
    }

extern enum STREAM_DEBUG_LEVEL _CDebugLevel;

#  define CDebugPrint(level, args) { if (level <= _CDebugLevel) DbgPrint args; }

#else /*DEBUG*/

#  define CDEBUG_BREAK()
#  define MDASSERT(exp)
#  define CDebugPrint(level, args)

#endif /*DEBUG*/


#ifdef __cplusplus
}
#endif // __cplusplus
#endif // #ifndef __BDADEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\bda\samples\bdatuner\common.h ===
#ifndef _COMMON_H
#define _COMMON_H_

extern "C" {
#include <wdm.h>
#include "wdmdebug.h"
}

// #include <limits.h>
#include <winerror.h>
#include <unknown.h>
#include <ks.h>
#include <ksmedia.h>
#include <bdatypes.h>
#include <bdamedia.h>
#include <atsmedia.h>
#include <bdasup.h>

//#include "medguid.h"
#include <kcom.h>
#include <ksdebug.h>
#include "splmedia.h"

#undef INTERFACE



#endif //_COMMON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\bda\samples\bdatuner\bdatuner.h ===
#include "common.h"

#include "bdadebug.h"

#define IsEqualGUID(rguid1, rguid2) (!memcmp(rguid1, rguid2, sizeof(GUID)))

/**************************************************************/
/* Driver Name - Change the driver name to reflect your executable name! */
/**************************************************************/

#define MODULENAME           "BDA Generic Tuner Sample"
#define MODULENAMEUNICODE   L"BDA Generic Tuner Sample"

#define STR_MODULENAME      MODULENAME

// This defines the name of the WMI device that manages service IOCTLS
#define DEVICENAME (L"\\\\.\\" MODULENAMEUNICODE)
#define SYMBOLICNAME (L"\\DosDevices\\" MODULENAMEUNICODE)

#define ATSC_RECEIVER   1
//#define DVBS_RECEIVER    1
// #define DVBT_RECEIVER    1
// #define CABLE_RECEIVER   1

// Must define exactly one of the 4 above
# if !(defined(ATSC_RECEIVER) || defined(DVBT_RECEIVER) || defined(DVBS_RECEIVER) || defined (CABLE_RECEIVER))
#error "Must define exactly one of ATSC, DVBT, DVBS or CABLE"
#endif
# if defined(ATSC_RECEIVER) && (defined(DVBT_RECEIVER) || defined(DVBS_RECEIVER) || defined (CABLE_RECEIVER))
#error Multiple tranport definitions"
# elif defined(DVBT_RECEIVER) && (defined(ATSC_RECEIVER) || defined(DVBS_RECEIVER) || defined (CABLE_RECEIVER))
#error Multiple tranport definitions"
# elif defined(DVBS_RECEIVER) && (defined(ATSC_RECEIVER) || defined(DVBT_RECEIVER) || defined (CABLE_RECEIVER))
#error Multiple tranport definitions"
# elif defined(CABLE_RECEIVER) && (defined(ATSC_RECEIVER) || defined(DVBS_RECEIVER) || defined (DVBT_RECEIVER))
#error Multiple tranport definitions"
#endif

#define MS_SAMPLE_TUNER_POOL_TAG 'TadB'


//  Define a structure that represents what the underlying device can do.
//
//  Note -  It is possible to set conflicting settings.  In this case, the 
//  CFilter::CheckChanges method should return an error. Only a 
//  self-consistent resource should be submitted to the underlying device.
//
typedef struct _BDATUNER_DEVICE_RESOURCE
{
    //  Tuner Resources
    //
    ULONG               ulCarrierFrequency;
    ULONG               ulFrequencyMultiplier;
    GUID                guidDemodulator;

    //  Demodulator Resources
    //
    ULONG               ulDemodProperty1;
    ULONG               ulDemodProperty2;
    ULONG               ulDemodProperty3;
} BDATUNER_DEVICE_RESOURCE, * PBDATUNER_DEVICE_RESOURCE;


//  Define a structure that represents the underlying device status.
//
typedef struct _BDATUNER_DEVICE_STATUS
{
    //  Tuner Status
    //
    BOOLEAN             fCarrierPresent;

    //  Demodulator Status
    //
    BOOLEAN             fSignalLocked;
} BDATUNER_DEVICE_STATUS, * PBDATUNER_DEVICE_STATUS;


extern const KSDEVICE_DESCRIPTOR DeviceDescriptor;

//
// Define the filter class.
//
class CFilter {
public:

    //
    //  Define the AVStream Filter Dispatch Functions
    //  Network provider and AVStream use these functions 
    //  to create or remove a filter instance
    //
    static
    STDMETHODIMP_(NTSTATUS)
    Create(
        IN OUT PKSFILTER Filter,
        IN PIRP Irp
        );

    static
    STDMETHODIMP_(NTSTATUS)
    FilterClose(
        IN OUT PKSFILTER Filter,
        IN PIRP Irp
        );

/**************************************************************/
/* Only used to process frames. 
 *  Filters that transport data do not implement this dispatch function.
    static
    STDMETHODIMP
    Process(
        IN PKSFILTER Filter,
        IN PKSPROCESSPIN_INDEXENTRY ProcessPinsIndex
        );*/
/**************************************************************/

    //
    //  KSMETHODSETID_BdaChangeSync 
    //  Filter change sync methods
    //
    static
    STDMETHODIMP_(NTSTATUS)
    StartChanges(
        IN PIRP         pIrp,
        IN PKSMETHOD    pKSMethod,
        OPTIONAL PVOID  pvIgnored
        );

    static
    STDMETHODIMP_(NTSTATUS)
    CheckChanges(
        IN PIRP         pIrp,
        IN PKSMETHOD    pKSMethod,
        OPTIONAL PVOID  pvIgnored
        );

    static
    STDMETHODIMP_(NTSTATUS)
    CommitChanges(
        IN PIRP         pIrp,
        IN PKSMETHOD    pKSMethod,
        OPTIONAL PVOID  pvIgnored
        );

    static
    STDMETHODIMP_(NTSTATUS)
    GetChangeState(
        IN PIRP         pIrp,
        IN PKSMETHOD    pKSMethod,
        OUT PULONG      pulChangeState
        );

    static
    STDMETHODIMP_(NTSTATUS)
    GetMedium(
        IN PIRP             pIrp,
        IN PKSPROPERTY      pKSProperty,
        IN KSPIN_MEDIUM *   pulProperty
        );

    //
    //  KSMETHODSETID_BdaDeviceConfiguration 
    //  Methods to modify filter topology.
    //
    static
    STDMETHODIMP_(NTSTATUS)
    CreateTopology(
        IN PIRP         pIrp,
        IN PKSMETHOD    pKSMethod,
        OPTIONAL PVOID  pvIgnored
        );

    //
    //  Filter Implementation Methods
    //
    STDMETHODIMP_(class CDevice *)
    GetDevice() { return m_pDevice;};

    STDMETHODIMP_(NTSTATUS)
    PutFrequency(
        IN ULONG        ulBdaParameter
        )
        {
            m_NewResource.ulCarrierFrequency = ulBdaParameter;
            m_BdaChangeState = BDA_CHANGES_PENDING;

            return STATUS_SUCCESS;
        };

    STDMETHODIMP_(NTSTATUS)
    GetFrequency(
        IN PULONG        pulBdaParameter
        )
        {
            *pulBdaParameter = m_CurResource.ulCarrierFrequency;
            
            return STATUS_SUCCESS;
        };

    STDMETHODIMP_(NTSTATUS)
    SetDemodulator(
        IN const GUID *       pguidDemodulator
        );

    STDMETHODIMP_(NTSTATUS)
    SetDemodProperty1(
        IN ULONG        ulDemodProperty1
        )
    {
            m_NewResource.ulDemodProperty1 = ulDemodProperty1;
            m_BdaChangeState = BDA_CHANGES_PENDING;

            return STATUS_SUCCESS;
    }

    STDMETHODIMP_(NTSTATUS)
    GetDemodProperty1(
        IN PULONG       pulDemodProperty1
        )
    {
        if (pulDemodProperty1)
        {
            *pulDemodProperty1 = m_CurResource.ulDemodProperty1;
            return STATUS_SUCCESS;
        }
        else
        {
            return STATUS_INVALID_PARAMETER;
        }
    }

    STDMETHODIMP_(NTSTATUS)
    SetDemodProperty2(
        IN ULONG        ulDemodProperty2
        )
    {
            m_NewResource.ulDemodProperty2 = ulDemodProperty2;
            m_BdaChangeState = BDA_CHANGES_PENDING;

            return STATUS_SUCCESS;
    }

    STDMETHODIMP_(NTSTATUS)
    GetDemodProperty3(
        IN PULONG       pulDemodProperty3
        )
    {
        if (pulDemodProperty3)
        {
            *pulDemodProperty3 = m_CurResource.ulDemodProperty3;
            return STATUS_SUCCESS;
        }
        else
        {
            return STATUS_INVALID_PARAMETER;
        }
    }

    STDMETHODIMP_(NTSTATUS)
    GetStatus(
        PBDATUNER_DEVICE_STATUS     pDeviceStatus
        );

    STDMETHODIMP_(NTSTATUS)
    SetDeviceState(
        KSSTATE     newKsState
        )
    {
        m_KsState = newKsState;
        return STATUS_SUCCESS;
    };

    STDMETHODIMP_(NTSTATUS)
    AcquireResources();

    STDMETHODIMP_(NTSTATUS)
    ReleaseResources();

private:
    class CDevice * m_pDevice;

    //  Filter Properties
    //

    //  Filter Resources
    //
    KSSTATE                     m_KsState;
    BDA_CHANGE_STATE            m_BdaChangeState;
    BDATUNER_DEVICE_RESOURCE    m_CurResource;
    BDATUNER_DEVICE_RESOURCE    m_NewResource;
    ULONG                       m_ulResourceID;
    BOOLEAN                     m_fResourceAcquired;
};

//
// Define the device class.
//
class CDevice {
public:

    //
    //  Define the AVStream Device Dispatch Functions
    //  AVStream uses these functions to create and start the device
    //
    static
    STDMETHODIMP_(NTSTATUS)
    Create(
        IN PKSDEVICE    pKSDevice
        );

    static
    STDMETHODIMP_(NTSTATUS)
    Start(
        IN PKSDEVICE            pKSDevice,
        IN PIRP                 pIrp,
        IN PCM_RESOURCE_LIST    pTranslatedResourceList OPTIONAL,
        IN PCM_RESOURCE_LIST    pUntranslatedResourceList OPTIONAL
        );

    //
    //  Utility functions for the device
    //  An instance of the filter uses these functions 
    //  to manage resources on the device. 
    //

    STDMETHODIMP_(NTSTATUS)
    InitializeHW(
        );

    STDMETHODIMP_(NTSTATUS)
    GetStatus(
        PBDATUNER_DEVICE_STATUS     pDeviceStatus
        );

    STDMETHODIMP_(NTSTATUS)
    GetImplementationGUID(
        GUID *                      pguidImplementation
        )
    {
        if (pguidImplementation)
        {
            *pguidImplementation = m_guidImplemenation;
            return STATUS_SUCCESS;
        }
        else
        {
            return STATUS_INVALID_PARAMETER;
        }
    }

    STDMETHODIMP_(NTSTATUS)
    GetDeviceInstance(
        ULONG *                     pulDeviceInstance
        )
    {
        if (pulDeviceInstance)
        {
            *pulDeviceInstance = m_ulDeviceInstance;
            return STATUS_SUCCESS;
        }
        else
        {
            return STATUS_INVALID_PARAMETER;
        }
    }

    NTSTATUS
    AcquireResources(
        PBDATUNER_DEVICE_RESOURCE     pNewResource,
        PULONG                        pulAcquiredResourceID
        );

    NTSTATUS
    UpdateResources(
        PBDATUNER_DEVICE_RESOURCE     pNewResource,
        ULONG                         ulResourceID
        );

    NTSTATUS
    ReleaseResources(
        ULONG                   ulResourceID
        );


private:

    PKSDEVICE                 m_pKSDevice;

    GUID                      m_guidImplemenation;
    ULONG                     m_ulDeviceInstance;
    BDATUNER_DEVICE_RESOURCE  m_CurResource;
    ULONG                     m_ulCurResourceID; 
    ULONG                     m_ulcResourceUsers;
};


//
// Define the Input-pin class.
//
class CAntennaPin {
public:
    //
    //  Define the AVStream Pin Dispatch Functions
    //  Network provider and AVStream use these functions 
    //  to create or remove a pin instance or to change the pin's 
    //  state after the minidriver receives a connection state 
    //  property 'set' IOCTL. 
    //
    static
    STDMETHODIMP_(NTSTATUS)
    PinCreate(
        IN OUT PKSPIN Pin,
        IN PIRP Irp
        );

    static
    STDMETHODIMP_(NTSTATUS)
    PinClose(
        IN OUT PKSPIN Pin,
        IN PIRP Irp
        );

    static
    STDMETHODIMP_(NTSTATUS)
    PinSetDeviceState(
        IN PKSPIN Pin,
        IN KSSTATE ToState,
        IN KSSTATE FromState
        );

    //
    //  Define a data intersection handler function for the 
    //  pin (KSPIN_DESCRIPTOR_EX structure). 
    //  Network provider and AVStream use this function 
    //  to connect the input pin with an upstream filter.   
    //
    static
    STDMETHODIMP_(NTSTATUS)
    IntersectDataFormat(
        IN PVOID pContext,
        IN PIRP pIrp,
        IN PKSP_PIN Pin,
        IN PKSDATARANGE DataRange,
        IN PKSDATARANGE MatchingDataRange,
        IN ULONG DataBufferSize,
        OUT PVOID Data OPTIONAL,
        OUT PULONG DataSize
        );

    //
    //  Network provider and AVStream use these functions 
    //  to set and get properties of nodes that are controlled 
    //  by the input pin. 
    //
    static
    STDMETHODIMP_(NTSTATUS)
    GetCenterFrequency(
        IN PIRP         Irp,
        IN PKSPROPERTY  pKSProperty,
        IN PULONG       pulProperty
        );

    static
    STDMETHODIMP_(NTSTATUS)
    PutCenterFrequency(
        IN PIRP         Irp,
        IN PKSPROPERTY  pKSProperty,
        IN PULONG       pulProperty
        );

    static
    STDMETHODIMP_(NTSTATUS)
    GetSignalStatus(
        IN PIRP         Irp,
        IN PKSPROPERTY  pKSProperty,
        IN PULONG       pulProperty
        );


    //
    //  Utility functions for the pin
    //
    STDMETHODIMP_(class CFilter *)
    GetFilter() { return m_pFilter;};

    STDMETHODIMP_(void)
    SetFilter(class CFilter * pFilter) { m_pFilter = pFilter;};

private:
    class CFilter*  m_pFilter;
    ULONG           ulReserved;
    KSSTATE         m_KsState;

    //  Node Properties
    //
    BOOLEAN         m_fResourceChanged;
    ULONG           m_ulCurrentFrequency;
    ULONG           m_ulPendingFrequency;
};


//
// Define the Output-pin class.
//
class CTransportPin{
public:
    //
    //  Define the AVStream Pin Dispatch Functions
    //  Network provider and AVStream use these functions 
    //  to create or remove a pin instance or to change the pin's 
    //  state after the minidriver receives a connection state 
    //  property 'set' IOCTL. 
    //
    static
    STDMETHODIMP_(NTSTATUS)
    PinCreate(
        IN OUT PKSPIN Pin,
        IN PIRP Irp
        );

    static
    STDMETHODIMP_(NTSTATUS)
    PinClose(
        IN OUT PKSPIN Pin,
        IN PIRP Irp
        );

    //
    //  Define a data intersection handler function for the 
    //  pin (KSPIN_DESCRIPTOR_EX structure). 
    //  Network provider and AVStream use this function 
    //  to connect the output pin with a downstream filter.   
    //
    static
    STDMETHODIMP_(NTSTATUS)
    IntersectDataFormat(
        IN PVOID pContext,
        IN PIRP pIrp,
        IN PKSP_PIN Pin,
        IN PKSDATARANGE DataRange,
        IN PKSDATARANGE MatchingDataRange,
        IN ULONG DataBufferSize,
        OUT PVOID Data OPTIONAL,
        OUT PULONG DataSize
        );

    //
    //  BDA Signal Properties
    //
    static
    STDMETHODIMP_(NTSTATUS)
    GetSignalStatus(
        IN PIRP         Irp,
        IN PKSPROPERTY  pKSProperty,
        IN PULONG       pulProperty
        );

    static
    STDMETHODIMP_(NTSTATUS)
    PutAutoDemodProperty(
        IN PIRP         Irp,
        IN PKSPROPERTY  pKSProperty,
        IN PULONG       pulProperty
        );

#if !ATSC_RECEIVER
    static
    STDMETHODIMP_(NTSTATUS)
    GetDigitalDemodProperty(
        IN PIRP         Irp,
        IN PKSPROPERTY  pKSProperty,
        IN PULONG       pulProperty
        );

    static
    STDMETHODIMP_(NTSTATUS)
    PutDigitalDemodProperty(
        IN PIRP         Irp,
        IN PKSPROPERTY  pKSProperty,
        IN PULONG       pulProperty
        );
#endif // !ATSC_RECEIVER

    static
    STDMETHODIMP_(NTSTATUS)
    GetExtensionProperties(
        IN PIRP         Irp,
        IN PKSPROPERTY  pKSProperty,
        IN PULONG       pulProperty
        );

    static
    STDMETHODIMP_(NTSTATUS)
    PutExtensionProperties(
        IN PIRP         Irp,
        IN PKSPROPERTY  pKSProperty,
        IN PULONG       pulProperty
        );

    STDMETHODIMP_(class CFilter *)
    GetFilter() { return m_pFilter;};

    STDMETHODIMP_(void)
    SetFilter(class CFilter * pFilter) { m_pFilter = pFilter;};

private:
    class CFilter*  m_pFilter;
    ULONG           ulReserved;
    KSSTATE         m_KsState;

    //  Node Properties
    //
    BOOLEAN         m_fResourceChanged;
    ULONG           m_ulCurrentProperty1;
    ULONG           m_ulPendingProperty1;

    ULONG           m_ulCurrentProperty2;

    ULONG           m_ulCurrentProperty3;
    ULONG           m_ulPendingProperty3;
};

//
//  Topology Constants
//
typedef enum {
    PIN_TYPE_ANTENNA = 0,
    PIN_TYPE_TRANSPORT
} FilterPinTypes;

typedef enum {
    INITIAL_ANNTENNA_PIN_ID = 0
} InitialPinIDs;

//
//  Data declarations
//

extern const BDA_FILTER_TEMPLATE    BdaFilterTemplate;
extern const KSFILTER_DESCRIPTOR    InitialFilterDescriptor;
extern const KSFILTER_DESCRIPTOR    TemplateFilterDescriptor;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\bda\samples\bdacapture\tstream.h ===
/**************************************************************************

    AVStream Simulated Hardware Sample

    Copyright (c) 2001, Microsoft Corporation.

    File:

        TStream.h

    Abstract:

    History:

        created 8/1/2001

**************************************************************************/

/**************************************************************************

    Constants

**************************************************************************/

/*************************************************

    CTsSynthesizer

    This class synthesizes a transport stream for output from the
    capture filter.

*************************************************/

class CTsSynthesizer {

protected:

    //
    // The packet size of the transport stream
    //
    ULONG m_PacketSize;

    //
    // The number of packets in a capture buffer
    //
    ULONG m_PacketsPerBuffer;

    //
    // The size of the actual data in the capture buffer
    //
    ULONG m_SampleSize;

    //
    // The synthesis buffer.  All transport stream samples are created in this
    // buffer.  This must be set with SetBuffer() before any sample creation
    // routines are called.
    //
    PUCHAR m_SynthesisBuffer;

    //
    // The default cursor.  This is a pointer into the synthesis buffer where
    // the next transport stream byte will be placed. 
    //
    PUCHAR m_Cursor;

public:

    //
    // SetSampleSize():
    //
    // Set the size of the synthesis buffer.
    //
    void
    SetSampleSize (
        ULONG PacketSize,
        ULONG PacketsPerBuffer
        )
    {
        m_PacketSize = PacketSize;
        m_PacketsPerBuffer = PacketsPerBuffer;
        m_SampleSize = PacketSize * PacketsPerBuffer;
    }

    //
    // SetBuffer():
    //
    // Set the buffer the synthesizer generates images to.
    //
    void
    SetBuffer (
        PUCHAR SynthesisBuffer
        )
    {
        m_SynthesisBuffer = SynthesisBuffer;
    }

    //
    // GetTsLocation():
    //
    // Set the cursor to point at the given packet index.
    //
    virtual PUCHAR
    GetTsLocation (
        ULONG PacketIndex
        )
    {
        if (   m_SynthesisBuffer 
            && m_PacketSize 
            && (PacketIndex < m_PacketsPerBuffer)
           )
        {
            m_Cursor = m_SynthesisBuffer + (PacketIndex * m_PacketSize);
        }
        else
        {
            m_Cursor = NULL;
        }

        return m_Cursor;
    }

    //
    // PutPacket():
    //
    // Place a transport stream packet at the default cursor location.
    // The cursor location must be set via GetTsLocation(PacketIndex).
    //
    virtual void
    PutPacket (
        PUCHAR  TsPacket
        )

    {
        //
        //  Copy the transport packet to the synthesis buffer.
        //
        RtlCopyMemory (
            m_Cursor,
            TsPacket,
            m_PacketSize
            );
        m_Cursor += m_PacketSize;
    }
    
    //
    // SynthesizeTS():
    //
    // Synthesize the next transport stream buffer to be captured.
    //
    virtual void
    SynthesizeTS (
        );

    //
    // DEFAULT CONSTRUCTOR
    //
    CTsSynthesizer (
        ) :
        m_PacketSize (0),
        m_PacketsPerBuffer (0),
        m_SynthesisBuffer (NULL)
    {
    }

    //
    // CONSTRUCTOR:
    //
    CTsSynthesizer (
        ULONG PacketSize,
        ULONG PacketsPerBuffer
        ) :
        m_PacketSize (PacketSize),
        m_PacketsPerBuffer (PacketsPerBuffer),
        m_SynthesisBuffer (NULL)
    {
    }

    //
    // DESTRUCTOR:
    //
    virtual
    ~CTsSynthesizer (
        )
    {
    }

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\bda\samples\bdatuner\filter.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    filter.cpp

Abstract:

    Filter core, initialization, etc.

--*/

#include "BDATuner.h"

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif // ALLOC_DATA_PRAGMA

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA

/*
** Create() method of the CFilter class
**
**    Creates the filter object,
**    associates it with the device object, and 
**    initializes member variables for it.
**
*/
STDMETHODIMP_(NTSTATUS)
CFilter::Create(
    IN OUT PKSFILTER pKSFilter,
    IN PIRP Irp
    )
{
    NTSTATUS    Status = STATUS_SUCCESS;
    ULONG       ulPinId;  // just useful when no network provider is present
    PKSDEVICE   pKSDevice = NULL;
    CDevice *   pDevice = NULL;

    _DbgPrintF(DEBUGLVL_VERBOSE,("FilterCreate"));

    ASSERT(pKSFilter);
    ASSERT(Irp);


    //  Create a filter object for the filter instance.
    //
    CFilter* pFilter = new(PagedPool,MS_SAMPLE_TUNER_POOL_TAG) CFilter; // Tags the allocated memory
    if (!pFilter)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto errExit;
    }
    //  Link the filter context to the passed in pointer to the KSFILTER structure.
    //
    pKSFilter->Context = pFilter;

    //  Point to the KS device object for this filter.
    //
    pKSDevice = KsFilterGetDevice( pKSFilter);
    ASSERT( pKSDevice);
    if (!pKSDevice)
    {
        Status = STATUS_DEVICE_NOT_CONNECTED;
        goto errExit;
    }

    //  Get the device object from the retrieved pointer to the KSDevice for this filter.
    //
    pDevice = reinterpret_cast<CDevice *>(pKSDevice->Context);
    ASSERT( pDevice);
    if (!pDevice)
    {
        Status = STATUS_DEVICE_NOT_CONNECTED;
        goto errExit;
    }

    //  Link the filter context to the device context.
    //  That is, set the filter's device pointer data member to the obtained device pointer.
    //
    pFilter->m_pDevice = pDevice;

    //  Initialize member variables.
    //
    pFilter->m_KsState = KSSTATE_STOP;
    pFilter->m_BdaChangeState = BDA_CHANGES_COMPLETE;
    pFilter->m_ulResourceID = 0;

    //  Configure the initial resource for ATSC reception of channel 39.
    pFilter->m_CurResource.ulCarrierFrequency = 621250000L;
    pFilter->m_CurResource.ulFrequencyMultiplier = 1;
    pFilter->m_CurResource.guidDemodulator = KSNODE_BDA_8VSB_DEMODULATOR;
    pFilter->m_fResourceAcquired = FALSE;

    //  Call the BDA support library to initialize the
    //  filter instance with the default template topology.
    //
    Status = BdaInitFilter( pKSFilter, &BdaFilterTemplate);
    if (NT_ERROR( Status))
    {
        goto errExit;
    }

#ifdef NO_NETWORK_PROVIDER
    //
    //  This code can be used for initial testing of a filter when
    //  a network provider can't be used to configure the filter.
    //  This situation may arise when the receiver topology includes
    //  filters that have not yet been written or when a new network
    //  type does not yet have a network provider implementation.
    //
    //  This code should NOT be used when a driver is delivered into
    //  a working BDA receiver solution.
    //

    //  Create the transport output pin
    //
    Status = BdaCreatePin( pKSFilter, 
                           PIN_TYPE_TRANSPORT, 
                           &ulOutputPinId
                           );
    if (!NT_SUCCESS(Status))
    {
        goto errExit;
    }
    
    //  Create the topology between the antenna input and
    //  transport output pins.
    //
    //  Note that the antenna input pin was automatically created
    //  because it was included in the pin descriptor list of the
    //  initial filter descriptor passed to BdaCreateFilterFactory.
    //
    Status = BdaCreateTopology( pKSFilter, 
                                INITIAL_ANNTENNA_PIN_ID, 
                                ulOutputPinId
                                );
    if (!NT_SUCCESS(Status))
    {
        goto errExit;
    }

#endif // NO_NETWORK_PROVIDER

exit:
    return Status;

errExit:
    if (pFilter)
    {
        delete pFilter;
    }
    pKSFilter->Context = NULL;

    goto exit;
}


/*
** FilterClose() method of the CFilter class
**
**    Deletes the previously created filter object.
**
*/
STDMETHODIMP_(NTSTATUS)
CFilter::FilterClose(
    IN OUT PKSFILTER Filter,
    IN PIRP Irp
    )
{
    _DbgPrintF(DEBUGLVL_VERBOSE,("FilterClose"));

    ASSERT(Filter);
    ASSERT(Irp);

    CFilter* filter = reinterpret_cast<CFilter*>(Filter->Context);
    ASSERT(filter);

    delete filter;

    return STATUS_SUCCESS;
}

/*
** StartChanges() method of the CFilter class
**
**    Puts the filter into change state.  All changes to BDA topology
**    and properties changed after this will be in effect only after
**    a call to the CFilter::CommitChanges() method.
**
*/
NTSTATUS
CFilter::StartChanges(
    IN PIRP         pIrp,
    IN PKSMETHOD    pKSMethod,
    OPTIONAL PVOID  pvIgnored
    )
{
    NTSTATUS        Status = STATUS_SUCCESS;
    CFilter *       pFilter;

    ASSERT( pIrp);
    ASSERT( pKSMethod);

    //  Obtain a "this" pointer to the filter object.
    //
    //  Because the property dispatch table calls the CFilter::StartChanges() method 
    //  directly, the method must retrieve a pointer to the underlying filter object.
    //
    pFilter = reinterpret_cast<CFilter *>(KsGetFilterFromIrp(pIrp)->Context);
    ASSERT( pFilter);

    //  Call the BDA support library to 
    //  reset any pending BDA topolgoy changes.
    //
    Status = BdaStartChanges( pIrp);
    if (NT_SUCCESS( Status))
    {
        //  Reset any pending resource changes.
        //
        pFilter->m_NewResource = pFilter->m_CurResource;
        pFilter->m_BdaChangeState = BDA_CHANGES_COMPLETE;
    }

    return Status;
}


/*
** CheckChanges() method of the CFilter class
**
**    Checks the changes to BDA interfaces that have occured since the
**    last call to the CFilter::StartChanges() method.  Returns the identical 
**    result that the CFilter::CommitChanges() method returns.
**
*/
NTSTATUS
CFilter::CheckChanges(
    IN PIRP         pIrp,
    IN PKSMETHOD    pKSMethod,
    OPTIONAL PVOID  pvIgnored
    )
{
    NTSTATUS            Status = STATUS_SUCCESS;
    CFilter *           pFilter;
    BDA_CHANGE_STATE    topologyChangeState;

    ASSERT( pIrp);
    ASSERT( pKSMethod);

    //  Obtain a "this" pointer to the filter object.
    //
    //  Because the property dispatch table calls the CFilter::CheckChanges() method 
    //  directly, the method must retrieve a pointer to the underlying filter object.
    //
    pFilter = reinterpret_cast<CFilter *>(KsGetFilterFromIrp(pIrp)->Context);
    ASSERT( pFilter);

    //  Call the BDA support library to 
    //  verify a new set of BDA topology changes.
    //
    Status = BdaCheckChanges( pIrp);
    if (NT_SUCCESS( Status))
    {
        //
        //  Validate the new resource list here.
        //  In this driver the new resource list is always valid.
        //
    }

    return Status;
}


/*
** CommitChanges() method of the CFilter class
**
**    Checks and commits the changes to BDA interfaces that have occured since the
**    last call to the CFilter::StartChanges() method.  
**
*/
NTSTATUS
CFilter::CommitChanges(
    IN PIRP         pIrp,
    IN PKSMETHOD    pKSMethod,
    OPTIONAL PVOID  pvIgnored
    )
{
    NTSTATUS        Status = STATUS_SUCCESS;
    CFilter *       pFilter;

    ASSERT( pIrp);
    ASSERT( pKSMethod);

    //  Obtain a "this" pointer to the filter object.
    //
    //  Because the property dispatch table calls the CFilter::CommitChanges() method 
    //  directly, the method must retrieve a pointer to the underlying filter object.
    //
    pFilter = reinterpret_cast<CFilter *>(KsGetFilterFromIrp(pIrp)->Context);
    ASSERT( pFilter);

    //
    //  Validate the new resource list here.
    //  In this driver the new resource list is always valid.
    //

    //  Mark the changes as having been made.
    //
    pFilter->m_CurResource = pFilter->m_NewResource;
    pFilter->m_BdaChangeState = BDA_CHANGES_COMPLETE;
    
    if (pFilter->m_KsState != KSSTATE_STOP)
    {
        //  Commit the resources on the underlying device
        //
        Status = pFilter->AcquireResources( );
        ASSERT( NT_SUCCESS( Status));
    }

    //  Call the BDA support library to 
    //  commit a new set of BDA topology changes.
    //
    Status = BdaCommitChanges( pIrp);

    return Status;
}


/*
** GetChangeState() method of the CFilter class
**
**    Returns the current BDA change state.
**
*/
NTSTATUS
CFilter::GetChangeState(
    IN PIRP         pIrp,
    IN PKSMETHOD    pKSMethod,
    OUT PULONG      pulChangeState
    )
{
    NTSTATUS            Status = STATUS_SUCCESS;
    CFilter *           pFilter;
    BDA_CHANGE_STATE    topologyChangeState;

    ASSERT( pIrp);
    ASSERT( pKSMethod);
    // pulChangeState needs to be verified because minData is zero
    // in the KSMETHOD_ITEM definition in bdamedia.h
    if (!pulChangeState)
    {
        pIrp->IoStatus.Information = sizeof(ULONG);
        return STATUS_MORE_ENTRIES;
    }   

    //  Obtain a "this" pointer to the filter object.
    //
    //  Because the property dispatch table calls the CFilter::GetChangeState() method 
    //  directly, the method must retrieve a pointer to the underlying filter object.
    //
    pFilter = reinterpret_cast<CFilter *>(KsGetFilterFromIrp(pIrp)->Context);
    ASSERT( pFilter);


    //  Call the BDA support library to 
    //  verify for any pending BDA topology changes.
    //
    Status = BdaGetChangeState( pIrp, &topologyChangeState);
    if (NT_SUCCESS( Status))
    {
        //  Figure out if there are changes pending.
        //
        if (   (topologyChangeState == BDA_CHANGES_PENDING)
            || (pFilter->m_BdaChangeState == BDA_CHANGES_PENDING)
           )
        {
            *pulChangeState = BDA_CHANGES_PENDING;
        }
        else
        {
            *pulChangeState = BDA_CHANGES_COMPLETE;
        }
    }


    return Status;
}


/*
** GetMedium() method of the CFilter class
**
** Identifies specific connection on a communication bus 
**
*/
NTSTATUS
CFilter::GetMedium(
    IN PIRP             pIrp,
    IN PKSMETHOD        pKSProperty,
    OUT KSPIN_MEDIUM *  pKSMedium
    )
{
    NTSTATUS            Status = STATUS_SUCCESS;
    CFilter *           pFilter;
    ULONG               ulPinType;
    PKSFILTER           pKSFilter;
    KSP_PIN *           pKSPPin = (KSP_PIN *) pKSProperty;

    ASSERT( pIrp);
    ASSERT( pKSProperty);
    // pulChangeState needs to be verified because minData is zero
    // in the KSMETHOD_ITEM definition in bdamedia.h
    if (!pKSMedium)
    {
        pIrp->IoStatus.Information = sizeof(KSPIN_MEDIUM);
        return STATUS_MORE_ENTRIES;
    }   


    //  Obtain a "this" pointer to the filter object.
    //
    //  Because the property dispatch table calls the CFilter::CreateTopology() method 
    //  directly, the method must retrieve a pointer to the underlying filter object.
    //
    pFilter = reinterpret_cast<CFilter *>(KsGetFilterFromIrp(pIrp)->Context);
    ASSERT( pFilter);

    //  Because there is a max of one instance of each pin for a given filter
    //  instance, we can use the same GUID for the medium on each pin.
    //

    //  We use a GUID specific to this implementation of the
    //  device to differentiate from other implemenations of the same
    //  device.
    //
    Status = pFilter->m_pDevice->GetImplementationGUID( &pKSMedium->Set);
    if (!NT_SUCCESS( Status))
    {
        pKSMedium->Set = KSMEDIUMSETID_Standard;
        Status = STATUS_SUCCESS;
    }

    //  Further, we must differentiate this instance of this implementation
    //  from other intances of the same implementation.  We use a device
    //  instance number to do this.
    //
    Status = pFilter->m_pDevice->GetDeviceInstance( &pKSMedium->Id);
    if (!NT_SUCCESS( Status))
    {
        pKSMedium->Id = 0;
        Status = STATUS_SUCCESS;
    }

    //  Across all filters that represent this device there can only be one
    //  input pin instance and one output pin instance with the same
    //  media type so we don't have to distinguish between pin instances.
    //
    pKSMedium->Flags = 0;

    return Status;
}


/*
** CreateTopology() method of the CFilter class
**
**    Keeps track of the topology association between input and output pins
**
*/
NTSTATUS
CFilter::CreateTopology(
    IN PIRP         pIrp,
    IN PKSMETHOD    pKSMethod,
    PVOID           pvIgnored
    )
{
    NTSTATUS            Status = STATUS_SUCCESS;
    CFilter *           pFilter;
    ULONG               ulPinType;
    PKSFILTER           pKSFilter;

    ASSERT( pIrp);
    ASSERT( pKSMethod);

    //  Obtain a "this" pointer to the filter object.
    //
    //  Because the property dispatch table calls the CFilter::CreateTopology() method 
    //  directly, the method must retrieve a pointer to the underlying filter object.
    //
    pFilter = reinterpret_cast<CFilter *>(KsGetFilterFromIrp(pIrp)->Context);
    ASSERT( pFilter);

    //
    //  Configure the hardware to complete its internal connection between
    //  the input pin and output pin here.
    //

    //  Call the BDA support library to create the standard topology and 
    //  validate the method, instance count, etc.
    //
    Status = BdaMethodCreateTopology( pIrp, pKSMethod, pvIgnored);


    return Status;
}


/*
** SetDemodulator ()
**
**    Sets the type of the demodulator.
**
** Arguments:
**
**
** Returns:
**
** Side Effects:  none
*/
STDMETHODIMP_(NTSTATUS)
CFilter::SetDemodulator(
    IN const GUID *       pguidDemodulator
    )
{
    NTSTATUS        Status = STATUS_SUCCESS;
    ASSERT (pguidDemodulator);
    if (!pguidDemodulator)
    {
        return STATUS_INVALID_PARAMETER;
    }   

    //  Make sure the demodulator is supported.
    //
#if ATSC_RECEIVER
    if (IsEqualGUID( pguidDemodulator, &KSNODE_BDA_8VSB_DEMODULATOR))
#elif DVBT_RECEIVER
    if (IsEqualGUID( pguidDemodulator, &KSNODE_BDA_COFDM_DEMODULATOR))
#elif DVBS_RECEIVER
    if (IsEqualGUID( pguidDemodulator, &KSNODE_BDA_QPSK_DEMODULATOR))
#elif CABLE_RECEIVER
    if (IsEqualGUID( pguidDemodulator, &KSNODE_BDA_QAM_DEMODULATOR))
#endif
    {
        m_NewResource.guidDemodulator = *pguidDemodulator;
        m_BdaChangeState = BDA_CHANGES_PENDING;
    }
    else
    {
        Status = STATUS_NOT_SUPPORTED;
    }

    return Status;
}


/*
** GetStatus() method of the CFilter class
**
**    Gets the current device status for this filter instance.
**
*/
NTSTATUS
CFilter::GetStatus(
    PBDATUNER_DEVICE_STATUS     pDeviceStatus
    )
{
    if (m_KsState == KSSTATE_STOP)
    {
        //  If we're in stop state then the device status
        //  doesn't reflect our resource list.
        //
        pDeviceStatus->fCarrierPresent = FALSE;
        pDeviceStatus->fSignalLocked = FALSE;
        return STATUS_SUCCESS;
    }
    else
    {
        ASSERT( m_pDevice);
        return m_pDevice->GetStatus( pDeviceStatus);
    }
};


/*
** AcquireResources() method of the CFilter class
**
**    Acquires resources for the underlying device.
**
*/
NTSTATUS
CFilter::AcquireResources(
    )
{
    NTSTATUS        Status = STATUS_SUCCESS;

    if (m_fResourceAcquired)
    {
        Status = m_pDevice->UpdateResources(
                                &m_CurResource,
                                m_ulResourceID
                                );
    }
    else
    {
        //  Commit the resources on the underlying device
        //
        Status = m_pDevice->AcquireResources(
                                &m_CurResource,
                                &m_ulResourceID
                                );
        m_fResourceAcquired = NT_SUCCESS( Status);
    }
    
    return Status;
}


/*
** ReleaseResources() method of the CFilter class
**
**    Releases resources from the underlying device.
**
*/
NTSTATUS
CFilter::ReleaseResources(
    )
{
    NTSTATUS        Status = STATUS_SUCCESS;

    //  Release the resources on the underlying device
    //
    if (m_fResourceAcquired)
    {
        Status = m_pDevice->ReleaseResources(
                                m_ulResourceID
                                );
        m_ulResourceID = 0;
        m_fResourceAcquired = FALSE;
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\bda\samples\bdatuner\device.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    device.cpp

Abstract:

    Device driver core, initialization, etc.

--*/

#define KSDEBUG_INIT

#include "BDATuner.h"
#include "wdmdebug.h"

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif // ALLOC_DATA_PRAGMA

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA



extern "C"
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPathName
    )
/*++

Routine Description:

    Sets up the driver object.

Arguments:

    DriverObject -
        Driver object for this instance.

    RegistryPathName -
        Contains the registry path which was used to load this instance.

Return Values:

    Returns STATUS_SUCCESS if the driver was initialized.

--*/
{
    NTSTATUS    Status = STATUS_SUCCESS;

    _DbgPrintF(DEBUGLVL_VERBOSE,("DriverEntry"));

    // DEBUG_BREAK;

    Status = KsInitializeDriver( DriverObject,
                                 RegistryPathName,
                                 &DeviceDescriptor);

    // DEBUG_BREAK;

    return Status;
}

//  Driver Global Device instance #
//
static ULONG    ulDeviceInstance = 0;

STDMETHODIMP_(NTSTATUS)
CDevice::
Create(
    IN PKSDEVICE Device
    )
{
    NTSTATUS    Status = STATUS_SUCCESS;
    CDevice *   pDevice = NULL;

    // DEBUG_BREAK;

    _DbgPrintF(DEBUGLVL_VERBOSE,("CDevice::Create"));

    ASSERT(Device);


    //  Allocate memory for the our device class.
    //
    pDevice = new(PagedPool,MS_SAMPLE_TUNER_POOL_TAG) CDevice; // Tags the allocated memory 

    
    
    if (pDevice)
    {

       //
        // Add the item to the object bag if we were successful.
        // Whenever the device goes away, the bag is cleaned up and
        // we will be freed.
        //
        // For backwards compatibility with DirectX 8.0, we must grab
        // the device mutex before doing this.  For Windows XP, this is
        // not required, but it is still safe.
        //
        KsAcquireDevice (Device);
        Status = KsAddItemToObjectBag (
            Device -> Bag,
            reinterpret_cast <PVOID> (pDevice),
	    NULL
            );
        KsReleaseDevice (Device);

        if (!NT_SUCCESS (Status)) {
            delete pDevice;
	    return Status;
        }

        //  Point the KSDEVICE at our device class.
        //
        Device->Context = pDevice;
    
        //  Point back to the KSDEVICE.
        //
        pDevice->m_pKSDevice = Device;

        //  Make the resource available for a filter to use.
        //
        pDevice->m_ulcResourceUsers = 0;
        pDevice->m_ulCurResourceID = 0;

        //  Get the instance number of this device.
        //
        pDevice->m_ulDeviceInstance = ulDeviceInstance++;

        //  Set the implementation GUID.  For cases where a single
        //  driver is used for multiple implementations the INF
        //  which installs the device would write the implementation
        //  GUID into the registery.  This code would then
        //  read the Implementation GUID from the registry.
        //
        pDevice->m_guidImplemenation = KSMEDIUMSETID_MyImplementation;
    } else
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return Status;
}


STDMETHODIMP_(NTSTATUS)
CDevice::
Start(
    IN PKSDEVICE            pKSDevice,
    IN PIRP                 pIrp,
    IN PCM_RESOURCE_LIST    pTranslatedResourceList OPTIONAL,
    IN PCM_RESOURCE_LIST    pUntranslatedResourceList OPTIONAL
    )
{
    NTSTATUS            Status = STATUS_SUCCESS;
    CDevice *           pDevice;
    PKSFILTERFACTORY    pKSFilterFactory = NULL;


    // DEBUG_BREAK;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("CDevice::Start"));
    ASSERT( pKSDevice);

    // DEBUG_BREAK;

    pDevice = reinterpret_cast<CDevice *>(pKSDevice->Context);
    ASSERT(pDevice);

    // initialize private class variables in pDevice here

    //  Initialize the hardware.
    //
    Status = pDevice->InitializeHW();
    if (Status == STATUS_SUCCESS)
    {
        //  Create the the Filter Factory.  This factory is used to
        //  create instances of the filter.
        //
        Status = BdaCreateFilterFactoryEx( pKSDevice,
                                           &InitialFilterDescriptor,
                                           &BdaFilterTemplate,
                                           &pKSFilterFactory
                                       );
    }

    if ((Status == STATUS_SUCCESS) && pKSFilterFactory)
    {
        BdaFilterFactoryUpdateCacheData( 
                        pKSFilterFactory,
                        BdaFilterTemplate.pFilterDescriptor
                        );
    }

    return Status;
}


NTSTATUS
CDevice::
InitializeHW(
    )
{
    NTSTATUS    Status = STATUS_SUCCESS;

    //
    //  Initialize the device hardware here.
    //

    return Status;
}


NTSTATUS
CDevice::
GetStatus(
    PBDATUNER_DEVICE_STATUS     pDeviceStatus
    )
{
    NTSTATUS    Status = STATUS_SUCCESS;

    //
    //  Get the signal status from the HW here
    //

    //  Since we don't have HW we'll fake it here.
    //
    {
        LONGLONG    llhzFrequency;

        //  Let's pretend that Channels 10, 25, 38, and 39 have
        //  active ATSC signals and channels 4, 5 and 7 have analog
        //  signals present.
        //
        llhzFrequency = m_CurResource.ulCarrierFrequency;
        llhzFrequency *= m_CurResource.ulFrequencyMultiplier;
        llhzFrequency /= 1000;
        if (   (llhzFrequency == (LONGLONG) 193250L)
            || (llhzFrequency == (LONGLONG) 537250L)
            || (llhzFrequency == (LONGLONG) 615250L)
            || (llhzFrequency == (LONGLONG) 621250L)
           )
        {
            pDeviceStatus->fCarrierPresent = TRUE;
            pDeviceStatus->fSignalLocked = TRUE;
        }
        else if (   (llhzFrequency == (LONGLONG) 67250L)
                 || (llhzFrequency == (LONGLONG) 77250L)
                 || (llhzFrequency == (LONGLONG) 83250L)
                )
        {
            pDeviceStatus->fCarrierPresent = TRUE;
            pDeviceStatus->fSignalLocked = FALSE;
        }
        else
        {
            pDeviceStatus->fCarrierPresent = FALSE;
            pDeviceStatus->fSignalLocked = FALSE;
        }
    }

    return Status;
}


NTSTATUS
CDevice::
AcquireResources(
    PBDATUNER_DEVICE_RESOURCE   pNewResource,
    PULONG                      pulAcquiredResourceID
    )
{
    NTSTATUS    Status = STATUS_SUCCESS;
    LONGLONG    ulhzFrequency;

    //
    //  Validate the requested resource here.
    //

    //  Check to see if the resources are being used by another
    //  filter instance.
    //
    if (!m_ulcResourceUsers)
    {
        m_CurResource = *pNewResource;

        //  Generate a new resource ID and hand it back.
        //
        m_ulCurResourceID += 25;
        *pulAcquiredResourceID = m_ulCurResourceID;
        m_ulcResourceUsers += 1;

        //
        //  Configure the new resource on the hardware here.
        //
    }
#ifdef RESOURCE_SHARING
    //  For resource sharing the IsEqualResource method should be
    //  implemented
    //
    else if (IsEqualResource( pNewResource, &m_CurResource))
    {
        *pulAcquiredResourceID = m_ulCurResourceID;
        m_ulcResourceUsers += 1;
    }
#endif // RESOURCE_SHARING
    else
    {
        //  We only allow one active filter at a time in this implementation.
        //
        Status = STATUS_DEVICE_BUSY;
    }

    return Status;
}


NTSTATUS
CDevice::
UpdateResources(
    PBDATUNER_DEVICE_RESOURCE   pNewResource,
    ULONG                       ulResourceID
    )
{
    NTSTATUS    Status = STATUS_SUCCESS;
    LONGLONG    ulhzFrequency;

    //
    //  Validate the requested resource here.
    //

    //  Check to see if the resources are being used by another
    //  filter instance.
    //
    if (   m_ulcResourceUsers
        && (ulResourceID == m_ulCurResourceID)
       )
    {
        m_CurResource = *pNewResource;

        //
        //  Configure the updated resource on the hardware here.
        //
    }
    else
    {
        //  We only allow one active filter at a time in this implementation.
        //
        Status = STATUS_INVALID_DEVICE_REQUEST;
    }

    return Status;
}


NTSTATUS
CDevice::
ReleaseResources(
    ULONG                   ulResourceID
    )
{
    NTSTATUS    Status = STATUS_SUCCESS;

    if (   m_ulcResourceUsers
        && (ulResourceID == m_ulCurResourceID)
       )
    {
        //  Free the resource to be used by another filter.
        //
        m_ulcResourceUsers--;
    }
    else
    {
        Status = STATUS_INVALID_DEVICE_REQUEST;
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\bda\samples\bdatuner\inpin.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    inpin.cpp

Abstract:

    Antenna input pin code.

--*/

#include "BDATuner.h"

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif // ALLOC_DATA_PRAGMA

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA

/*
**    (Static) PinCreate() method of the CAntennaPin class
**
**    Creates the input pin object and
**    associates it with the filter object. 
**
*/
NTSTATUS
CAntennaPin::PinCreate(
    IN OUT PKSPIN pKSPin,
    IN PIRP Irp
    )
{
    NTSTATUS            Status = STATUS_SUCCESS;
    CAntennaPin*      pPin;
    CFilter*            pFilter;

    _DbgPrintF(DEBUGLVL_VERBOSE,("CAntennaPin::PinCreate"));

    ASSERT(pKSPin);
    ASSERT(Irp);

    //  Obtain a pointer to the filter object for which the input pin is created.
    //
    pFilter = reinterpret_cast<CFilter*>(KsGetFilterFromIrp(Irp)->Context);

    //  Create the Antenna input pin object.
    //
    pPin = new(PagedPool,MS_SAMPLE_TUNER_POOL_TAG) CAntennaPin;  // Tags the allocated memory 
    if (pPin)
    {
        //  Link the input pin object to the filter object.
        //  That is, set the input pin's filter pointer data member to the obtained filter pointer.
        //
        pPin->SetFilter( pFilter);
    
        //  Link the Antenna input pin object to the passed in pointer to the KSPIN structure
        //  by assigning the pointer to the pin object to the KSPIN structure's context member.
        //
        pKSPin->Context = pPin;
    }
    else
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return Status;
}


/*
** PinClose() method of the CAntennaPin class
**
**    Deletes the previously created input pin object.
**
*/
NTSTATUS
CAntennaPin::PinClose(
    IN OUT PKSPIN Pin,
    IN PIRP Irp
    )
{
    _DbgPrintF(DEBUGLVL_VERBOSE,("CAntennaPin::PinClose"));

    ASSERT(Pin);
    ASSERT(Irp);

    //  Retrieve the Antenna input pin object from the passed in 
    //  KSPIN structure's context member.
    //
    CAntennaPin* pPin = reinterpret_cast<CAntennaPin*>(Pin->Context);

    ASSERT(pPin);

    delete pPin;

    return STATUS_SUCCESS;
}

/*
** IntersectDataFormat() method of the CAntennaPin class
**
**    Enables connection of the input pin with an upstream filter.
**
*/
NTSTATUS
CAntennaPin::IntersectDataFormat(
    IN PVOID pContext,
    IN PIRP pIrp,
    IN PKSP_PIN Pin,
    IN PKSDATARANGE DataRange,
    IN PKSDATARANGE MatchingDataRange,
    IN ULONG DataBufferSize,
    OUT PVOID Data OPTIONAL,
    OUT PULONG DataSize
     )
{
    if ( DataBufferSize < sizeof(KS_DATARANGE_BDA_ANTENNA) )
    {
        *DataSize = sizeof( KS_DATARANGE_BDA_ANTENNA );
        return STATUS_BUFFER_OVERFLOW;
    }
    else if (DataRange->FormatSize < sizeof(KS_DATARANGE_BDA_ANTENNA)) 
    {
	return STATUS_NO_MATCH;
    } else 
    {
        ASSERT(DataBufferSize == sizeof(KS_DATARANGE_BDA_ANTENNA));
	
        *DataSize = sizeof( KS_DATARANGE_BDA_ANTENNA );
        RtlCopyMemory( Data, (PVOID)DataRange, sizeof(KS_DATARANGE_BDA_ANTENNA));

        return STATUS_SUCCESS;
    }
}

/*
** PinSetDeviceState() method of the CAntennaPin class
**
**    Because the most upstream pin (input pin) is the last to transition, 
**    use this pin's state to set the state of the filter.
**    
**    Also, release filter resouces if the pin's state transitions to stop, and
**    acquire resources if the pin's state transitions from stop.
**
*/
NTSTATUS
CAntennaPin::PinSetDeviceState(
    IN PKSPIN Pin,
    IN KSSTATE ToState,
    IN KSSTATE FromState
    )
{
    NTSTATUS        Status = STATUS_SUCCESS;
    PKSDEVICE       pKSDevice;
    CAntennaPin *   pPin;
    CDevice *       pDevice;

    _DbgPrintF( DEBUGLVL_VERBOSE,
                ("CAntennaPin::PinSetDeviceState"));

    ASSERT(Pin);

    //  Obtain a pointer to the device object from 
    //  the passed in pointer to the KSPIN structure.
    //
    pKSDevice = KsPinGetDevice( Pin);

    //  Obtain a pointer to the pin object from context member of
    //  the passed in pointer to the KSPIN structure.
    //
    pPin = reinterpret_cast<CAntennaPin*>(Pin->Context);
    ASSERT( pPin);

    //  Obtain a pointer to the device object from context member of
    //  the retrieved pointer to the KSDEVICE structure.
    //
    pDevice = reinterpret_cast<CDevice *>(pKSDevice->Context);
    ASSERT(pDevice);

    pPin->m_pFilter->SetDeviceState( pPin->m_KsState);

    if ((ToState == KSSTATE_STOP) && (FromState != KSSTATE_STOP))
    {
        //  Because the driver allocates resources on a filter wide basis,
        //  inform the filter to release resources when the last pin
        //  (that is, the most upstream pin) transitions to the stop state.
        //
        //  The input pin is the last pin to transition to the stop state,
        //  therefore inform the filter to release its resources.
        //
        Status = pPin->m_pFilter->ReleaseResources();
        pPin->m_KsState = ToState;
    }
    else if ((ToState == KSSTATE_ACQUIRE) && (FromState == KSSTATE_STOP))
    {
        //  Because the driver allocates resources on a filter wide basis,
        //  inform the filter to acquire resources when the last pin
        //  (that is, the most upstream pin) transitions from the stop state.
        //
        //  The input pin is the last pin to transition from the stop state,
        //  therefore inform the filter to acquire its resources.
        //
        Status = pPin->m_pFilter->AcquireResources();
        if (NT_SUCCESS( Status))
        {
            pPin->m_KsState = ToState;
        }
    }
    else if (ToState > KSSTATE_RUN)
    {
        _DbgPrintF( DEBUGLVL_TERSE,
                    ("CAntennaPin::PinSetDeviceState - Invalid Device State. ToState 0x%08x.  FromState 0x%08x.",
                     ToState, FromState));
        Status = STATUS_INVALID_PARAMETER;
    }
    else
    {
        pPin->m_KsState = ToState;
    }

    return Status;
}

/*
** GetSignalStatus() method of the CAntennaPin class
**
**    Retrieves the value of the tuner node signal statistics properties.
**
*/
NTSTATUS
CAntennaPin::GetSignalStatus(
    IN PIRP         pIrp,
    IN PKSPROPERTY  pKSProperty,
    IN PULONG       pulProperty
    )
{
    NTSTATUS                    Status = STATUS_SUCCESS;
    CAntennaPin *               pPin;
    CFilter*                    pFilter;
    BDATUNER_DEVICE_STATUS      DeviceStatus;

    _DbgPrintF(DEBUGLVL_VERBOSE,("CAntennaPin::GetSignalStatus"));

    ASSERT(pIrp);
    ASSERT(pKSProperty);
    ASSERT(pulProperty);


    //  Call the BDA support library to 
    //  validate that the node type is associated with this pin.
    //
    Status = BdaValidateNodeProperty( pIrp, pKSProperty);
    if (NT_SUCCESS( Status))
    {
        //  Obtain a pointer to the pin object.
        //
        //  Because the property dispatch table calls the CAntennaPin::GetTunerSignalStatus() 
        //  method directly, the method must retrieve a pointer to the underlying pin object.
        //
        pPin = reinterpret_cast<CAntennaPin *>(KsGetPinFromIrp(pIrp)->Context);
        ASSERT(pPin);
    
        //  Retrieve the filter context from the pin context.
        //
        pFilter = pPin->GetFilter();
        ASSERT( pFilter);
    
        Status = pFilter->GetStatus( &DeviceStatus);
        if (Status == STATUS_SUCCESS)
        {
            switch (pKSProperty->Id)
            {
            case KSPROPERTY_BDA_SIGNAL_PRESENT:
                *pulProperty = DeviceStatus.fCarrierPresent;
                break;
        
            default:
                Status = STATUS_INVALID_PARAMETER;
            }
        }
    }
    
    return Status;
}


/*
** GetCenterFrequency() method of the CAntennaPin class
**
**    Retrieves the value of the type 1 property of node 1.
**
*/
NTSTATUS
CAntennaPin::GetCenterFrequency(
    IN PIRP         pIrp,
    IN PKSPROPERTY  pKSProperty,
    IN PULONG       pulProperty
    )
{
    NTSTATUS        Status = STATUS_SUCCESS;
    CAntennaPin*    pPin;
    CFilter*        pFilter;

    _DbgPrintF(DEBUGLVL_VERBOSE,("CAntennaPin::GetCenterFrequency"));

    ASSERT(pIrp);
    ASSERT(pKSProperty);
    ASSERT(pulProperty);

    //  Call the BDA support library to 
    //  validate that the node type is associated with this pin.
    //
    Status = BdaValidateNodeProperty( pIrp, pKSProperty);
    if (NT_SUCCESS( Status))
    {
        //  Obtain a pointer to the pin object.
        //
        //  Because the property dispatch table calls the CAntennaPin::GetCenterFrequency() 
        //  method directly, the method must retrieve a pointer to the underlying pin object.
        //
        pPin = reinterpret_cast<CAntennaPin *>(KsGetPinFromIrp(pIrp)->Context);
        ASSERT(pPin);
    
        //  Retrieve the filter context from the pin context.
        //
        pFilter = pPin->GetFilter();
        ASSERT( pFilter);
    
        //  Retrieve the actual filter parameter. 
        //
        Status = pFilter->GetFrequency( pulProperty);
    }

    return Status;
}


/*
** PutCenterFrequency() method of the CAntennaPin class
**
**    Sets the value of the type 1 property of node 1 along with the 
**    resource of the filter to which the node belongs.
**
*/
NTSTATUS
CAntennaPin::PutCenterFrequency(
    IN PIRP         pIrp,
    IN PKSPROPERTY  pKSProperty,
    IN PULONG       pulProperty
    )
{
    NTSTATUS        Status = STATUS_SUCCESS;
    CAntennaPin*    pPin;
    CFilter*        pFilter;

    _DbgPrintF(DEBUGLVL_VERBOSE,("CAntennaPin::PutCenterFrequency"));

    ASSERT(pIrp);
    ASSERT(pKSProperty);
    ASSERT(pulProperty);


    //  Call the BDA support library to 
    //  validate that the node type is associated with this pin.
    //
    Status = BdaValidateNodeProperty( pIrp, pKSProperty);
    if (NT_SUCCESS( Status))
    {
        //  Obtain a pointer to the pin object.
        //
        //  Because the property dispatch table calls the CAntennaPin::PutCenterFrequency() 
        //  method directly, the method must retrieve a pointer to the underlying pin object.
        //
        pPin = reinterpret_cast<CAntennaPin *>(KsGetPinFromIrp(pIrp)->Context);
        ASSERT( pPin);
    
        //  Retrieve the filter context from the pin context.
        //
        pFilter = pPin->GetFilter();
        ASSERT( pFilter);
    
        //  Change the actual filter parameter. 
        //
        Status = pFilter->PutFrequency( *pulProperty);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\bda\samples\bdatuner\objdesc.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    ObjDesc.cpp

Abstract:

    Static object description data structures.

    This file includes initial descriptors for all filter, pin, and node
    objects exposed by this driver.  It also include descriptors for the
    properties, methods, and events on those objects.

--*/

#include "BDATuner.h"

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif // ALLOC_DATA_PRAGMA

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA


//
// Before defining structures for nodes, pins, and filters, 
// it may be useful to show the filter's template topology here. 
//
// The sample filter's topology:
//
//                     Node Type 0           Node Type 1
//                          |                     |
//                          v                     v   
//                   ---------------     --------------------
//   Antenna         |             |     |                  |             Transport 
//   In Pin  --------|  Tuner Node |--X--| Demodulator Node |------------   Out Pin
//     ^       ^     |             |  ^  |                  | ^                ^
//     |       |     ---------------  |  -------------------- |                |
//     |       |                      |                       |                |
//     |       -- Connection 0        -- Connection 1         -- Connection 2  |
//     |                                 Topology Joint                        |
//     ---- Pin Type 0                                           Pin Type 1 ----
//
//

//===========================================================================
//
//  Node  definitions
//
//  Nodes are special in that, though they are defined at the filter level,
//  they are actually associated with a pin type.  The filter's node
//  descriptor list is actually a list of node types.
//  
//  BDA allows a node type to appear only once in a template topology.
//  This means that a node in an actual filter topology can be uniquely
//  identified by specifying the node type along with the actual input and
//  output pin IDs of the the path that the node appears in.
//
//  Note that the dispatch routines for nodes actually point to
//  pin-specific methods because the context data associated with
//  a node is stored in the pin context.
//
//  Node property begin with a KSP_NODE structure that contains the node type of the node to which
//  that property applies. This begs the question:
//
//  "How is a node uniquely identified by only the node type?"
//
//  The BDA Support Library uses the concept of a topology joint to solve
//  this problem.  Nodes upstream of a topology joint have their properties
//  dispatched to the input pin of the path.  Properties for nodes
//  downstream of the joint are dispatched to the output pin of the path
//  containing the node.
//
//  Node properties and methods should only be accessed from the 
//  appropriate pin.  The BDA Support Library helps assure this by
//  automatically merging a node type's automation table onto the automation
//  table of the correct pin.  This pin is called the controlling pin
//  for that node type.
//
//===========================================================================

typedef enum {
    BDA_SAMPLE_TUNER_NODE = 0,
    BDA_SAMPLE_DEMODULATOR_NODE
}BDA_SAMPLE_NODES;


//===========================================================================
//
//  BDA Sample Tuner Node (Node Type 0) definitions
//
//  Define structures here for the Properties, Methods, and Events
//  available on the BDA Sample Tuner Node.
//
//  This node is associated with an antenna input pin, therefore, the node
//  properties should be set/retrieved using the antenna input pin.  The
//  BDA Support Library will automatically merge the node's automation
//  table into the automation table for the antenna input pin.
//
//  Properties and methods are dispatched to the Antenna class.
//
//===========================================================================


//
//  BDA Sample Tune Frequency Filter
//
//  Define dispatch routines for specific properties.
//
//  One property is used to get and set the tuner's center frequency. 
//  For this property, define dispatch routines to get and set the frequency.
//
//  Other properties can be used to get and set the tuner's frequency range,
//  as well as to report signal strength.
//
//  These properties must be supported by BDA and 
//  defined elsewhere (for example, in Bdamedia.h).
//
DEFINE_KSPROPERTY_TABLE(SampleTunerNodeFrequencyProperties)
{
    DEFINE_KSPROPERTY_ITEM_BDA_RF_TUNER_FREQUENCY(
        CAntennaPin::GetCenterFrequency,
        CAntennaPin::PutCenterFrequency
        ),
    DEFINE_KSPROPERTY_ITEM_BDA_RF_TUNER_FREQUENCY_MULTIPLIER(
        NULL, NULL
        ),

#ifdef SATELLITE_TUNER
    DEFINE_KSPROPERTY_ITEM_BDA_RF_TUNER_POLARITY(
        NULL, NULL
        ),
    DEFINE_KSPROPERTY_ITEM_BDA_RF_TUNER_RANGE(
        NULL, NULL
        ),
#endif // SATELLITE_TUNER

#ifdef CHANNEL_BASED_TUNER
    DEFINE_KSPROPERTY_ITEM_BDA_RF_TUNER_TRANSPONDER(
        NULL, NULL
        ),
#endif // CHANNEL_BASED_TUNER

#ifdef DVBT_TUNER
    DEFINE_KSPROPERTY_ITEM_BDA_RF_TUNER_BANDWIDTH(
        NULL, NULL
        ),
#endif // DVBT_TUNER
};


//
//  BDA Signal Statistics Properties
//
//  Defines the dispatch routines for the Signal Statistics Properties
//  on the RF Tuner, Demodulator, and PID Filter Nodes
//
DEFINE_KSPROPERTY_TABLE(SampleRFSignalStatsProperties)
{
#ifdef OPTIONAL_SIGNAL_STATISTICS
    DEFINE_KSPROPERTY_ITEM_BDA_SIGNAL_STRENGTH(
        NULL, NULL
        ),
#endif // OPTIONAL_SIGNAL_STATISTICS
    
    DEFINE_KSPROPERTY_ITEM_BDA_SIGNAL_PRESENT(
        CAntennaPin::GetSignalStatus,
        NULL
        ),
};


//
//  Define the Property Sets for the sample tuner node from the 
//  previously defined node properties and from property sets
//  that BDA supports.
//  These supported property sets must be defined elsewhere 
//  (for example, in Bdamedia.h).
//
//  Associate the sample tuner node with the antenna input pin. 
//
DEFINE_KSPROPERTY_SET_TABLE(SampleTunerNodePropertySets)
{
    DEFINE_KSPROPERTY_SET
    (
        &KSPROPSETID_BdaFrequencyFilter,    // Property Set defined elsewhere
        SIZEOF_ARRAY(SampleTunerNodeFrequencyProperties),  // Number of properties in the array
        SampleTunerNodeFrequencyProperties,  // Property set array
        0,      // FastIoCount
        NULL    // FastIoTable
    ),
    DEFINE_KSPROPERTY_SET
    (
        &KSPROPSETID_BdaSignalStats,    // Property Set defined elsewhere
        SIZEOF_ARRAY(SampleRFSignalStatsProperties),  // Number of properties in the array
        SampleRFSignalStatsProperties,  // Property set array
        0,      // FastIoCount
        NULL    // FastIoTable
    )
};


//
//  Define the Automation Table for the BDA sample tuner node.
//
DEFINE_KSAUTOMATION_TABLE(SampleTunerNodeAutomation) {
    DEFINE_KSAUTOMATION_PROPERTIES(SampleTunerNodePropertySets),
    DEFINE_KSAUTOMATION_METHODS_NULL,
    DEFINE_KSAUTOMATION_EVENTS_NULL
};



//===========================================================================
//
//  Sample Demodulator Node definitions
//
//  This structure defines the Properties, Methods, and Events
//  available on the BDA Demodulator Node.
//
//  This node is associated with a transport output pin and thus the node
//  properties should be set/put using the transport output pin.
//
//===========================================================================


//
//  BDA Signal Statistics Properties for Demodulator Node
//
//  Defines the dispatch routines for the Signal Statistics Properties
//  on the Demodulator Node.
//
DEFINE_KSPROPERTY_TABLE(SampleDemodSignalStatsProperties)
{
#ifdef OPTIONAL_SIGNAL_STATISTICS
    DEFINE_KSPROPERTY_ITEM_BDA_SIGNAL_QUALITY(
        NULL, NULL
        ),
#endif // OPTIONAL_SIGNAL_STATISTICS

    DEFINE_KSPROPERTY_ITEM_BDA_SIGNAL_LOCKED(
        CTransportPin::GetSignalStatus,
        NULL
        ),
};


DEFINE_KSPROPERTY_TABLE(SampleAutoDemodProperties)
{
    DEFINE_KSPROPERTY_ITEM_BDA_AUTODEMODULATE_START(
        NULL,
        CTransportPin::PutAutoDemodProperty
        ),
    DEFINE_KSPROPERTY_ITEM_BDA_AUTODEMODULATE_STOP(
        NULL,
        CTransportPin::PutAutoDemodProperty
        )
};

#if !ATSC_RECEIVER

//
//  BDA Digital Demodulator Property Set for Demodulator Node
//
//  Defines the dispatch routines for the Digital Demodulator Properties
//  on the Demodulator Node.
//
DEFINE_KSPROPERTY_TABLE(SampleDigitalDemodProperties)
{
    DEFINE_KSPROPERTY_ITEM_BDA_MODULATION_TYPE(
        CTransportPin::GetDigitalDemodProperty,
        CTransportPin::PutDigitalDemodProperty
        ),
    DEFINE_KSPROPERTY_ITEM_BDA_INNER_FEC_TYPE(
        CTransportPin::GetDigitalDemodProperty,
        CTransportPin::PutDigitalDemodProperty
        ),
    DEFINE_KSPROPERTY_ITEM_BDA_INNER_FEC_RATE(
        CTransportPin::GetDigitalDemodProperty,
        CTransportPin::PutDigitalDemodProperty
        ),
    DEFINE_KSPROPERTY_ITEM_BDA_OUTER_FEC_TYPE(
        CTransportPin::GetDigitalDemodProperty,
        CTransportPin::PutDigitalDemodProperty
        ),
    DEFINE_KSPROPERTY_ITEM_BDA_OUTER_FEC_RATE(
        CTransportPin::GetDigitalDemodProperty,
        CTransportPin::PutDigitalDemodProperty
        ),
    DEFINE_KSPROPERTY_ITEM_BDA_SYMBOL_RATE(
        CTransportPin::GetDigitalDemodProperty,
        CTransportPin::PutDigitalDemodProperty
        ),

#if DVBS_RECEIVER
    DEFINE_KSPROPERTY_ITEM_BDA_SPECTRAL_INVERSION(
        CTransportPin::GetDigitalDemodProperty,
        CTransportPin::PutDigitalDemodProperty
        ),
#endif // DVBS_RECEIVER

#if DVBT_RECEIVER
    DEFINE_KSPROPERTY_ITEM_BDA_GUARD_INTERVAL(
        CTransportPin::GetDigitalDemodProperty,
        CTransportPin::PutDigitalDemodProperty
        ),
    DEFINE_KSPROPERTY_ITEM_BDA_TRANSMISSION_MODE(
        CTransportPin::GetDigitalDemodProperty,
        CTransportPin::PutDigitalDemodProperty
        )
#endif // DVBT_RECEIVER
};

#endif // !ATSC_RECEIVER

//
//  Sample Demodulator Node Extension Properties
//
//  Define dispatch routines for a set of driver specific
//  demodulator node properties.  This is how venders add support
//  for properties that are specific to their hardware.  They can
//  access these properties through a KSProxy plugin.
//
DEFINE_KSPROPERTY_TABLE(BdaSampleDemodExtensionProperties)
{
    DEFINE_KSPROPERTY_ITEM_BDA_SAMPLE_DEMOD_EXTENSION_PROPERTY1(  // A read and write property
        CTransportPin::GetExtensionProperties, // or NULL if not method to get the property
        CTransportPin::PutExtensionProperties // or NULL if not method to put the property
        ),
    DEFINE_KSPROPERTY_ITEM_BDA_SAMPLE_DEMOD_EXTENSION_PROPERTY2(  //A read only property
        CTransportPin::GetExtensionProperties, // or NULL if not method to get the property
        NULL // or NULL if not method to put the property
        ),
    DEFINE_KSPROPERTY_ITEM_BDA_SAMPLE_DEMOD_EXTENSION_PROPERTY3(  //A write only property
        NULL, // or NULL if not method to get the property
        CTransportPin::PutExtensionProperties // or NULL if not method to put the property
        ),
};


//
//  Demodulator Node Property Sets supported
//
//  This table defines all property sets supported by the
//  Demodulator Node associated with the transport output pin.
//
DEFINE_KSPROPERTY_SET_TABLE(SampleDemodNodePropertySets)
{
    DEFINE_KSPROPERTY_SET
    (
        &KSPROPSETID_BdaAutodemodulate,                // Set
        SIZEOF_ARRAY(SampleAutoDemodProperties),   // PropertiesCount
        SampleAutoDemodProperties,                 // PropertyItems
        0,                                          // FastIoCount
        NULL                                        // FastIoTable
    ),

#if !ATSC_RECEIVER

    DEFINE_KSPROPERTY_SET
    (
        &KSPROPSETID_BdaDigitalDemodulator,                // Set
        SIZEOF_ARRAY(SampleDigitalDemodProperties),   // PropertiesCount
        SampleDigitalDemodProperties,                 // PropertyItems
        0,                                          // FastIoCount
        NULL                                        // FastIoTable
    ),

#endif // !ATSC_RECEIVER


    DEFINE_KSPROPERTY_SET
    (
        &KSPROPSETID_BdaSignalStats,                // Set
        SIZEOF_ARRAY(SampleDemodSignalStatsProperties),   // PropertiesCount
        SampleDemodSignalStatsProperties,                 // PropertyItems
        0,                                          // FastIoCount
        NULL                                        // FastIoTable
    ),
    DEFINE_KSPROPERTY_SET
    (
        &KSPROPSETID_BdaSampleDemodExtensionProperties, // Set
        SIZEOF_ARRAY(BdaSampleDemodExtensionProperties), // Number of properties in the array
        BdaSampleDemodExtensionProperties, // Property set array
        0,                                                                              // FastIoCount
        NULL                                                                      // FastIoTable
    ),

    //
    //  Additional property sets for the node can be added here.
    //
};


//
//  Demodulator Node Automation Table
//
//  This structure defines the Properties, Methods, and Events
//  available on the BDA Demodulator Node.
//  These are used to set the symbol rate, and Viterbi rate,
//  as well as to report signal lock and signal quality.
//
DEFINE_KSAUTOMATION_TABLE(SampleDemodulatorNodeAutomation) {
    DEFINE_KSAUTOMATION_PROPERTIES( SampleDemodNodePropertySets),
    DEFINE_KSAUTOMATION_METHODS_NULL,
    DEFINE_KSAUTOMATION_EVENTS_NULL
};


//===========================================================================
//
//  Antenna Pin Definitions
//
//===========================================================================

//
//  The BDA Support Library automatically merges the RF tuner node properties,
//  methods, and events onto the antenna pin's automation table. It also
//  merges properties, methods, and events the that are require and
//  supplied by the BDA Support Library.
//

//  
//  The hardware vendor may want to provide driver specific properties,
//  methods, or events on the antenna pin or override those provided by
//  the BDA Support Library.  Such roperties, methods, and events will
//  be defined here.
//

//
//  Define the Automation Table for the antenna pin.
//
//
DEFINE_KSAUTOMATION_TABLE(AntennaAutomation) {
    DEFINE_KSAUTOMATION_PROPERTIES_NULL,
    DEFINE_KSAUTOMATION_METHODS_NULL,
    DEFINE_KSAUTOMATION_EVENTS_NULL
};


//
//  Dispatch Table for the antenna pin.
//
const
KSPIN_DISPATCH
AntennaPinDispatch =
{
    CAntennaPin::PinCreate,  // Create
    CAntennaPin::PinClose,  // Close
    NULL,  // Process siganl data
    NULL,  // Reset
    NULL,  // SetDataFormat
    CAntennaPin::PinSetDeviceState,  // SetDeviceState
    NULL,  // Connect
    NULL,  // Disconnect
    NULL,  // Clock
    NULL   // Allocator
};


//
//  Format the input antenna stream connection.
//
//  Used to connect the input antenna pin to a specific upstream filter,
//  such as the network provider.
//
const KS_DATARANGE_BDA_ANTENNA AntennaPinRange =
{
   // insert the KSDATARANGE and KSDATAFORMAT here
    {
        sizeof( KS_DATARANGE_BDA_ANTENNA), // FormatSize
        0,                                 // Flags - (N/A)
        0,                                 // SampleSize - (N/A)
        0,                                 // Reserved
        { STATIC_KSDATAFORMAT_TYPE_BDA_ANTENNA },  // MajorFormat
        { STATIC_KSDATAFORMAT_SUBTYPE_NONE },  // SubFormat
        { STATIC_KSDATAFORMAT_SPECIFIER_NONE } // Specifier
    }
};

//  Format Ranges of Antenna Input Pin.
//
static PKSDATAFORMAT AntennaPinRanges[] =
{
    (PKSDATAFORMAT) &AntennaPinRange,

    // Add more formats here if additional antenna signal formats are supported.
    //
};


//===========================================================================
//
//  Transport Output Pin Definitions
//
//===========================================================================

//
//  The BDA Support Library automatically merges the RF tuner node properties,
//  methods, and events onto the antenna pin's automation table. It also
//  merges properties, methods, and events the that are require and
//  supplied by the BDA Support Library.
//

//  
//  The hardware vendor may want to provide driver specific properties,
//  methods, or events on the antenna pin or override those provided by
//  the BDA Support Library.  Such roperties, methods, and events will
//  be defined here.
//

//
//  Define the Automation Table for the transport pin.
//
//
DEFINE_KSAUTOMATION_TABLE(TransportAutomation) {
    DEFINE_KSAUTOMATION_PROPERTIES_NULL,
    DEFINE_KSAUTOMATION_METHODS_NULL,
    DEFINE_KSAUTOMATION_EVENTS_NULL
};

//
//  Dispatch Table for the transport Output pin.
//
//  Since data on the transport is actually delivered to the
//  PCI bridge in hardware, this pin does not process data.
//
//  Connection of, and state transitions on, this pin help the
//  driver to determine when to allocate hardware resources for
//  each node.
//
const
KSPIN_DISPATCH
TransportPinDispatch =
{
    CTransportPin::PinCreate,     // Create
    CTransportPin::PinClose,      // Close
    NULL,                               // Process
    NULL,                               // Reset
    NULL,                               // SetDataFormat
    NULL,                               //SetDeviceState
    NULL,                               // Connect
    NULL,                               // Disconnect
    NULL,                               // Clock
    NULL                                // Allocator
};


//
//  Format the output Transport Stream Connection
//
//  Used to connect the output pin to a specific downstream filter
//
const KS_DATARANGE_BDA_TRANSPORT TransportPinRange =
{
   // insert the KSDATARANGE and KSDATAFORMAT here
    {
        sizeof( KS_DATARANGE_BDA_TRANSPORT),               // FormatSize
        0,                                                 // Flags - (N/A)
        0,                                                 // SampleSize - (N/A)
        0,                                                 // Reserved
        { STATIC_KSDATAFORMAT_TYPE_STREAM },               // MajorFormat
        { STATIC_KSDATAFORMAT_TYPE_MPEG2_TRANSPORT },      // SubFormat
        { STATIC_KSDATAFORMAT_SPECIFIER_BDA_TRANSPORT }    // Specifier
    },
    // insert the BDA_TRANSPORT_INFO here
    {
        188,        //  ulcbPhyiscalPacket
        312 * 188,  //  ulcbPhyiscalFrame
        0,          //  ulcbPhyiscalFrameAlignment (no requirement)
        0           //  AvgTimePerFrame (not known)
    }
};

//  Format Ranges of Transport Output Pin.
//
static PKSDATAFORMAT TransportPinRanges[] =
{
    (PKSDATAFORMAT) &TransportPinRange,

    // Add more formats here if additional transport formats are supported.
    //
};


//  Medium GUIDs for the Transport Output Pin.
//
//  This insures contection to the correct Capture Filter pin.
//
// {F102C41F-7FA1-4842-A0C8-DC41176EC844}
#define GUID_BdaSWRcv   0xf102c41f, 0x7fa1, 0x4842, 0xa0, 0xc8, 0xdc, 0x41, 0x17, 0x6e, 0xc8, 0x44
const KSPIN_MEDIUM TransportPinMedium =
{
    GUID_BdaSWRcv, 0, 0
};


//===========================================================================
//
//  Filter  definitions
//
//  Define arrays here that contain the types of nodes and pins that are possible for the filter 
//  Define structures here that describe Properties, Methods, and Events available on the filter
//
//  Properties can be used to set and retrieve information for the filter.
//  Methods can be used to perform operations on the filter. 
//
//===========================================================================

//
//  Template Node Descriptors
//
//  Define an array that contains all the node types that are available in the template
//  topology of the filter.
//  These node types must be supported by BDA and 
//  defined elsewhere (for example, in Bdamedia.h).
//
const
KSNODE_DESCRIPTOR
NodeDescriptors[] =
{
    {
        &SampleTunerNodeAutomation, // Point to KSAUTOMATION_TABLE structure for the node's automation table
        &KSNODE_BDA_RF_TUNER, // Point to the guid that defines function of the node
        NULL // Point to the guid that represents the name of the topology node
    },
#if ATSC_RECEIVER
    {
        &SampleDemodulatorNodeAutomation, // Point to KSAUTOMATION_TABLE 
        &KSNODE_BDA_8VSB_DEMODULATOR, // Point to the guid that defines the topology node
        NULL // Point to the guid that represents the name of the topology node
    }
#elif DVBS_RECEIVER
    {
        &SampleDemodulatorNodeAutomation, // Point to KSAUTOMATION_TABLE 
        &KSNODE_BDA_QPSK_DEMODULATOR, // Point to the guid that defines the topology node
        NULL // Point to the guid that represents the name of the topology node
    }
#elif DVBT_RECEIVER
    {
        &SampleDemodulatorNodeAutomation, // Point to KSAUTOMATION_TABLE 
        &KSNODE_BDA_COFDM_DEMODULATOR, // Point to the guid that defines the topology node
        NULL // Point to the guid that represents the name of the topology node
    }
#elif CABLE_RECEIVER
    {
        &SampleDemodulatorNodeAutomation, // Point to KSAUTOMATION_TABLE 
        &KSNODE_BDA_QAM_DEMODULATOR, // Point to the guid that defines the topology node
        NULL // Point to the guid that represents the name of the topology node
    }
#endif
};


//
//  Initial Pin Descriptors
//
//  This data structure defines the pins that will appear on the filer
//  when it is first created.
//
//  All BDA filters should expose at lease one input pin to insure that
//  the filter can be properly inserted in a BDA receiver graph.  The
//  initial pins can be created in a number of ways.
//
//  The initial filters descriptor passed in to BdaInitFilter can include
//  a list of n pin descriptors that correspond to the first n of m pin
//  descriptors in the template filter descriptor.  This list of pin
//  descriptors will usually only include those input pins that are
//  ALWAYS exposed by the filter in question.
//
//  Alternatively, the driver may call BdaCreatePin from its filter Create
//  dispatch function for each pin that it ALWAYS wants exposed.
//
//  This filter uses an initial filter descriptor to force the Antenna
//  input pin to always be exposed.
//
const
KSPIN_DESCRIPTOR_EX
InitialPinDescriptors[] =
{
    //  Antenna Input Pin
    //
    {
        &AntennaPinDispatch,   // Point to the dispatch table for the input pin
        &AntennaAutomation,   // Point to the automation table for the input pin
        {  // Specify members of a KSPIN_DESCRIPTOR structure for the input pin
            0,  // Interfaces
            NULL,
            0,  // Mediums
            NULL,
            SIZEOF_ARRAY(AntennaPinRanges),
            AntennaPinRanges,  
            KSPIN_DATAFLOW_IN,  // specifies that data flow is into the pin
            KSPIN_COMMUNICATION_BOTH, // specifies that the pin factory instantiates pins 
                                                                               // that are both IRP sinks and IRP sources
            NULL,   //  Category GUID
            NULL,   // GUID of the localized Unicode string name for the pin type
            0
        },  // Specify flags
        KSPIN_FLAG_DO_NOT_USE_STANDARD_TRANSPORT | 
            KSPIN_FLAG_FRAMES_NOT_REQUIRED_FOR_PROCESSING | 
            KSPIN_FLAG_FIXED_FORMAT,
        1,  // Specify the maximum number of possible instances of the input pin
        1,      // Specify the number of instances of this pin type that are necessary for proper functioning of this filter
        NULL,   // Point to KSALLOCATOR_FRAMING_EX structure for allocator framing
        CAntennaPin::IntersectDataFormat    // Point to the data intersection handler function
    }
};


//
//  Template Pin Descriptors
//
//  This data structure defines the pin types available in the filters
//  template topology.  These structures will be used to create a
//  KDPinFactory for a pin type when BdaCreatePin or BdaMethodCreatePin
//  are called.
//
//  This structure defines ALL pins the filter is capable of supporting,
//  including those pins which may only be created dynamically by a ring
//  3 component such as a Network Provider.
//
//
const
KSPIN_DESCRIPTOR_EX
TemplatePinDescriptors[] =
{
    //  Antenna Input Pin
    //
    {
        &AntennaPinDispatch,   // Point to the dispatch table for the input pin
        &AntennaAutomation,   // Point to the automation table for the input pin
        {  // Specify members of a KSPIN_DESCRIPTOR structure for the input pin
            0,  // Interfaces
            NULL,
            0,  // Mediums
            NULL,
            SIZEOF_ARRAY(AntennaPinRanges),
            AntennaPinRanges,  
            KSPIN_DATAFLOW_IN,  // specifies that data flow is into the pin
            KSPIN_COMMUNICATION_BOTH, // specifies that the pin factory instantiates pins 
                                                                               // that are both IRP sinks and IRP sources
            NULL,   //  Category GUID
            NULL,   // GUID of the localized Unicode string name for the pin type
            0
        },  // Specify flags
        KSPIN_FLAG_DO_NOT_USE_STANDARD_TRANSPORT | 
            KSPIN_FLAG_FRAMES_NOT_REQUIRED_FOR_PROCESSING | 
            KSPIN_FLAG_FIXED_FORMAT,
        1,  // Specify the maximum number of possible instances of the input pin
        1,  // Specify the number of instances of this pin type that are necessary for proper functioning of this filter
        NULL,   // Point to KSALLOCATOR_FRAMING_EX structure for allocator framing
        CAntennaPin::IntersectDataFormat    // Point to the data intersection handler function
    },

    //  Tranport Output Pin
    //
    {
        &TransportPinDispatch,   // Point to the dispatch table for the output pin
        &TransportAutomation,   // Point to the automation table for the output pin
        {  // Specify members of a KSPIN_DESCRIPTOR structure for the output pin
            0,  // Interfaces
            NULL,
            1,  // Mediums
            &TransportPinMedium,
            SIZEOF_ARRAY(TransportPinRanges),
            TransportPinRanges,
//            0,
//            NULL,
            KSPIN_DATAFLOW_OUT, // specifies that data flow is out of the pin
            KSPIN_COMMUNICATION_BOTH, // specifies that the pin factory instantiates pins 
                                                                               // that are both IRP sinks and IRP sources
//            NULL,//Name
//            NULL,//Category
            (GUID *) &PINNAME_BDA_TRANSPORT,   //  Category GUID
            (GUID *) &PINNAME_BDA_TRANSPORT,   // GUID of the localized Unicode string 
                                                                                              // name for the pin type
            0
        },  // Specify flags
        KSPIN_FLAG_DO_NOT_USE_STANDARD_TRANSPORT | 
            KSPIN_FLAG_FRAMES_NOT_REQUIRED_FOR_PROCESSING | 
            KSPIN_FLAG_FIXED_FORMAT,
        1,  // Specify the maximum number of possible instances of the output pin
        0,  // Specify the number of instances of this pin type that are necessary for proper functioning of this filter
        NULL,   // Allocator Framing
        CTransportPin::IntersectDataFormat    // Point to the data intersection handler function
    }
};


//
//  BDA Device Topology Property Set
//
//  The BDA Support Library supplies a default implementation of the
//  BDA Device Topology Property Set.  If the driver needs to override
//  this default implemenation, the definitions for the override properties
//  will be defined here.
//


//
//  BDA Change Sync Method Set
//
//  The Change Sync Method Set is required on BDA filters.  Setting a
//  node property should not become effective on the underlying device
//  until CommitChanges is called.
//
//  The BDA Support Library provides routines that handle committing
//  changes to topology.  The BDA Support Library routines should be
//  called from the driver's implementation before the driver implementation
//  returns.
//
DEFINE_KSMETHOD_TABLE(BdaChangeSyncMethods)
{
    DEFINE_KSMETHOD_ITEM_BDA_START_CHANGES(
        CFilter::StartChanges, // Calls BdaStartChanges
        NULL
        ),
    DEFINE_KSMETHOD_ITEM_BDA_CHECK_CHANGES(
        CFilter::CheckChanges, // Calls BdaCheckChanges
        NULL
        ),
    DEFINE_KSMETHOD_ITEM_BDA_COMMIT_CHANGES(
        CFilter::CommitChanges, // Calls BdaCommitChanges
        NULL
        ),
    DEFINE_KSMETHOD_ITEM_BDA_GET_CHANGE_STATE(
        CFilter::GetChangeState, // Calls BdaGetChangeState
        NULL
        )
};


//  Override the standard pin medium property set so that we can provide
//  device specific medium information.
//
//  Because the property is on a Pin Factory and not on a pin instance,
//  this is a filter property.
//
DEFINE_KSPROPERTY_TABLE( SampleFilterPropertyOverrides)
{

    DEFINE_KSPROPERTY_ITEM_PIN_MEDIUMS(
        CFilter::GetMedium
        )
};

DEFINE_KSPROPERTY_SET_TABLE(SampleFilterPropertySets)
{
    DEFINE_KSPROPERTY_SET
    (
        &KSPROPSETID_Pin,                            // Property Set GUID
        SIZEOF_ARRAY(SampleFilterPropertyOverrides), // Number of Properties
        SampleFilterPropertyOverrides,               // Array of KSPROPERTY_ITEM structures 
        0,                                           // FastIoCount
        NULL                                         // FastIoTable
    )

    //
    //  Additional property sets for the filter can be added here.
    //
};


//
//  BDA Device Configuration Method Set
//
//  The BDA Support Library provides a default implementation of
//  the BDA Device Configuration Method Set.  In this example, the
//  driver overrides the CreateTopology method.  Note that the
//  support libraries CreateTopology method is called before the
//  driver's implementation returns.
//
DEFINE_KSMETHOD_TABLE(BdaDeviceConfigurationMethods)
{
    DEFINE_KSMETHOD_ITEM_BDA_CREATE_TOPOLOGY(
        CFilter::CreateTopology, // Calls BdaMethodCreateTopology
        NULL
        )
};


//
//  Define an array of method sets that the filter supports
//
DEFINE_KSMETHOD_SET_TABLE(FilterMethodSets)
{
    DEFINE_KSMETHOD_SET
    (
        &KSMETHODSETID_BdaChangeSync,       // Method set GUID
        SIZEOF_ARRAY(BdaChangeSyncMethods), // Number of methods
        BdaChangeSyncMethods,               // Array of KSMETHOD_ITEM structures 
        0,                                  // FastIoCount
        NULL                                // FastIoTable
    ),

    DEFINE_KSMETHOD_SET
    (
        &KSMETHODSETID_BdaDeviceConfiguration,       // Method set GUID
        SIZEOF_ARRAY(BdaDeviceConfigurationMethods), // Number of methods
        BdaDeviceConfigurationMethods,  // Array of KSMETHOD_ITEM structures 
        0,                                           // FastIoCount
        NULL                                         // FastIoTable
    )
};


//
//  Filter Automation Table
//
//  Lists all Property, Method, and Event Set tables for the filter
//
DEFINE_KSAUTOMATION_TABLE(FilterAutomation) {
    //DEFINE_KSAUTOMATION_PROPERTIES(SampleFilterPropertySets),
    DEFINE_KSAUTOMATION_PROPERTIES_NULL,
    DEFINE_KSAUTOMATION_METHODS(FilterMethodSets),
    DEFINE_KSAUTOMATION_EVENTS_NULL
};


//
//  Filter Dispatch Table
//
//  Lists the dispatch routines for major events at the filter
//  level.
//
const
KSFILTER_DISPATCH
FilterDispatch =
{
    CFilter::Create,        // Create
    CFilter::FilterClose,   // Close
    NULL,                   // Process
    NULL                    // Reset
};

//
//  Define the name GUID for our digital tuner filter.
//
//  NOTE!  You must use a different GUID for each type of filter that
//  your driver exposes.
//
#define STATIC_KSNAME_BdaSWTunerFilter\
    0x91b0cc87L, 0x9905, 0x4d65, 0xa0, 0xd1, 0x58, 0x61, 0xc6, 0xf2, 0x2c, 0xbf
DEFINE_GUIDSTRUCT("91B0CC87-9905-4d65-A0D1-5861C6F22CBF", KSNAME_BdaSWTunerFilter);
#define KSNAME_BdaSWTunerFilter DEFINE_GUIDNAMED(KSNAME_BdaSWTunerFilter)

//  Must match the KSSTRING used in the installation INFs interface sections
//  AND must match the KSNAME GUID above.
//
#define KSSTRING_BdaSWTunerFilter L"{91B0CC87-9905-4d65-A0D1-5861C6F22CBF}"


//
//  Define the Filter Factory Descriptor for the filter
//
//  This structure brings together all of the structures that define
//  the tuner filter as it appears when it is first instantiated.
//  Note that not all of the template pin and node types may be exposed as
//  pin and node factories when the filter is first instanciated.
//
//  If a driver exposes more than one filter, each filter must have a
//  unique ReferenceGuid.
//
DEFINE_KSFILTER_DESCRIPTOR(InitialFilterDescriptor)
{
    &FilterDispatch,        // Dispatch
    &FilterAutomation,  // AutomationTable
    KSFILTER_DESCRIPTOR_VERSION,  // Version
    0,                                 // Flags
    &KSNAME_BdaSWTunerFilter,  // ReferenceGuid
    DEFINE_KSFILTER_PIN_DESCRIPTORS(InitialPinDescriptors), 
                                       // PinDescriptorsCount; must expose at least one pin
                                       // PinDescriptorSize; size of each item
                                       // PinDescriptors; table of pin descriptors
    DEFINE_KSFILTER_CATEGORY(KSCATEGORY_BDA_NETWORK_TUNER),
                                       // CategoriesCount; number of categories in the table
                                       // Categories; table of categories
    DEFINE_KSFILTER_NODE_DESCRIPTORS_NULL,              
                                       // NodeDescriptorsCount; in this case, 0
                                       // NodeDescriptorSize; in this case, 0
                                       // NodeDescriptors; in this case, NULL
    DEFINE_KSFILTER_DEFAULT_CONNECTIONS,
    // Automatically fills in the connections table for a filter which defines no explicit connections
                                       // ConnectionsCount; number of connections in the table
                                       // Connections; table of connections
    NULL                        // ComponentId; in this case, no ID is provided
};


//===========================================================================
//
//  Define Filter Template Topology 
//
//===========================================================================

//
//  Define BDA Template Topology Connections
//
//  Lists the Connections that are possible between pin types and
//  node types.  This, together with the Template Filter Descriptor, and
//  the Pin Pairings, describe how topologies can be created in the filter.
//
//                 ===========         ============
//  AntennaPin ----| RF Node |--Joint--|Demod Node|----TransportPin
//                 ===========         ============
//
//  The RF Node of this filter is controlled by the Antenna input pin.
//  RF properties will be set as NODE properties (with NodeType == 0)
//  on the filter's Antenna Pin
//
//  The Demodulator Node of this filter is controlled by the Transport output pin.
//  Demod properties will be set as NODE properties (with NodeType == 1)
//  on the filter's Transport Pin
//
const
KSTOPOLOGY_CONNECTION TemplateFilterConnections[] =
{   // KSFILTER_NODE  is defined as ((ULONG)-1) in ks.h 
     // Indicate pin types by the item number is the TemplatePinDescriptors array.
     // Indicate node types by either the item number in the NodeDescriptors array
     // or the element in the BDA_SAMPLE_NODE enumeration.
    { KSFILTER_NODE, 0,                 BDA_SAMPLE_TUNER_NODE, 0},
    { BDA_SAMPLE_TUNER_NODE, 1,         BDA_SAMPLE_DEMODULATOR_NODE, 0},
    { BDA_SAMPLE_DEMODULATOR_NODE, 1,   KSFILTER_NODE, 1}
};


//
//  Template Joints between the Antenna and Transport Pin Types.
//
//  Lists the template joints between the Antenna Input Pin Type and
//  the Transport Output Pin Type.
//
//  In this case the RF Node is considered to belong to the antennea input
//  pin and the 8VSB Demodulator Node is considered to belong to the
//  tranport stream output pin.
//
const
ULONG   AntennaTransportJoints[] =
{
    1 // joint occurs between the two node types (second element in array)
       // indicates that 1st node is controlled by input pin and 2nd node by output pin
};

//
//  Define Template Pin Parings.
//
//  Array of BDA_PIN_PAIRING structures that are used to determine 
//  which nodes get duplicated when more than one output pin type is 
//  connected to a single input pin type or when more that one input pin 
//  type is connected to a single output pin type.
//  
const
BDA_PIN_PAIRING TemplatePinPairings[] =
{
    //  Input pin to Output pin Topology Joints
    //
    {
        0,  // ulInputPin; 0 element in the TemplatePinDescriptors array.
        1,  // ulOutputPin; 1 element in the TemplatePinDescriptors array.
        1,  // ulcMaxInputsPerOutput
        1,  // ulcMinInputsPerOutput
        1,  // ulcMaxOutputsPerInput
        1,  // ulcMinOutputsPerInput
        SIZEOF_ARRAY(AntennaTransportJoints),   // ulcTopologyJoints
        AntennaTransportJoints   // pTopologyJoints; array of joints
    }
    //  If applicable, list topology of joints between other pins.
    //
};


//
//  Define the Filter Factory Descriptor that the BDA support library uses 
//  to create template topology for the filter.
//
//  This KSFILTER_DESCRIPTOR structure combines the structures that 
//  define the topologies that the filter can assume as a result of
//  pin factory and topology creation methods.
//  Note that not all of the template pin and node types may be exposed as
//  pin and node factories when the filter is first instanciated.
//
DEFINE_KSFILTER_DESCRIPTOR(TemplateFilterDescriptor)
{
    &FilterDispatch,  // Dispatch
    &FilterAutomation,  // AutomationTable
    KSFILTER_DESCRIPTOR_VERSION,  // Version
    0,  // Flags
    &KSNAME_BdaSWTunerFilter,  // ReferenceGuid
    DEFINE_KSFILTER_PIN_DESCRIPTORS(TemplatePinDescriptors),
                                       // PinDescriptorsCount; exposes all template pins 
                                       // PinDescriptorSize; size of each item
                                       // PinDescriptors; table of pin descriptors
    DEFINE_KSFILTER_CATEGORY(KSCATEGORY_BDA_NETWORK_TUNER),
                                       // CategoriesCount; number of categories in the table
                                       // Categories; table of categories
    DEFINE_KSFILTER_NODE_DESCRIPTORS(NodeDescriptors),  
                                      // NodeDescriptorsCount; exposes all template nodes
                                      // NodeDescriptorSize; size of each item
                                      // NodeDescriptors; table of node descriptors
    DEFINE_KSFILTER_CONNECTIONS(TemplateFilterConnections), 
                                      // ConnectionsCount; number of connections in the table
                                       // Connections; table of connections
    NULL                        // ComponentId; in this case, no ID is provided
};

//
//  Define BDA Template Topology Descriptor for the filter.
//
//  This structure combines the filter descriptor and pin pairings that
//  the BDA support library uses to create an instance of the filter.
//
const
BDA_FILTER_TEMPLATE
BdaFilterTemplate =
{
    &TemplateFilterDescriptor,
    SIZEOF_ARRAY(TemplatePinPairings),
    TemplatePinPairings
};


//===========================================================================
//
//  Define the Device 
//
//===========================================================================


//
//  Define Device Dispatch Table
//
//  List the dispatch routines for the major events that occur 
//  during the existence of the underlying device.
//
extern
const
KSDEVICE_DISPATCH
DeviceDispatch =
{
    CDevice::Create,    // Add
    CDevice::Start,     // Start
    NULL,               // PostStart
    NULL,               // QueryStop
    NULL,               // CancelStop
    NULL,               // Stop
    NULL,               // QueryRemove
    NULL,               // CancelRemove
    NULL,               // Remove
    NULL,               // QueryCapabilities
    NULL,               // SurpriseRemoval
    NULL,               // QueryPower
    NULL                // SetPower
};


//
//  Define Device Descriptor
//
//  Combines structures that define the device and any non-BDA
//  intial filter factories that can be created on it.
//  Note that this structure does not include the template topology
//  structures as they are specific to BDA.
//
extern
const
KSDEVICE_DESCRIPTOR
DeviceDescriptor =
{
    &DeviceDispatch,    // Dispatch
    0,      // SIZEOF_ARRAY( FilterDescriptors),   // FilterDescriptorsCount
    NULL,   // FilterDescriptors                   // FilterDescriptors
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\bda\samples\bdatuner\wdmdebug.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
// WDMDEBUG.H
//==========================================================================;


#ifndef __WDMDEBUG_H
#define __WDMDEBUG_H

#define DebugAssert(exp)

#ifdef DEBUG
#define DebugInfo(x) KdPrint(x)
#define DBG1(String) DebugPrint((DebugLevelVerbose, String))
#define TRAP DbgBreakPoint() //DEBUG_BREAKPOINT();
#else
#define DebugInfo(x)
#define DBG1(String)
#define TRAP
#endif


#if DBG

#define _DebugPrint(x)  ::StreamClassDebugPrint x

#else

#define _DebugPrint(x)

#endif // #if DBG

#endif // #ifndef __WDMDEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\bda\slip\filter.c ===
/////////////////////////////////////////////////////////////////////////////
//
//
// Copyright (c) 1996, 1997  Microsoft Corporation
//
//
// Module Name:
//      filter.c
//
// Abstract:
//
//      This file is a test to find out if dual binding to NDIS and KS works
//
// Author:
//
//      P Porzuczek
//
// Environment:
//
// Revision History:
//
//
//////////////////////////////////////////////////////////////////////////////

#include <wdm.h>
#include <strmini.h>

#include "slip.h"
#include "Main.h"
#include "filter.h"


//////////////////////////////////////////////////////////////////////////////
//
//
//
const FILTER_VTABLE FilterVTable =
    {
    Filter_QueryInterface,
    Filter_AddRef,
    Filter_Release,
    };


///////////////////////////////////////////////////////////////////////////////////
NTSTATUS
CreateFilter (
    PDRIVER_OBJECT DriverObject,
    PDEVICE_OBJECT DeviceObject,
    PSLIP_FILTER pFilter
    )
///////////////////////////////////////////////////////////////////////////////////
{
    NTSTATUS ntStatus = STATUS_SUCCESS;

    //
    // Save off our Device/Driver Objectsx in our context area
    //
    pFilter->DeviceObject          = DeviceObject;
    pFilter->DriverObject          = DriverObject;
    pFilter->lpVTable              = (PFILTER_VTABLE) &FilterVTable;
    pFilter->ulRefCount            = 1;

    pFilter->bDiscontinuity        = FALSE;

    InitializeListHead(&pFilter->StreamControlQueue);
    KeInitializeSpinLock(&pFilter->StreamControlSpinLock);

    InitializeListHead(&pFilter->StreamDataQueue);
    KeInitializeSpinLock(&pFilter->StreamDataSpinLock);

    InitializeListHead(&pFilter->IpV4StreamDataQueue);
    KeInitializeSpinLock(&pFilter->IpV4StreamDataSpinLock);

    InitializeListHead(&pFilter->StreamContxList);
    KeInitializeSpinLock(&pFilter->StreamUserSpinLock);
	
    return ntStatus;
}


///////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Filter_QueryInterface (
    PSLIP_FILTER pFilter
    )
///////////////////////////////////////////////////////////////////////////////////
{
    return STATUS_NOT_IMPLEMENTED;
}

///////////////////////////////////////////////////////////////////////////////////
ULONG
Filter_AddRef (
    PSLIP_FILTER pFilter
    )
///////////////////////////////////////////////////////////////////////////////////
{
    if (pFilter)
    {
        pFilter->ulRefCount += 1;
        return pFilter->ulRefCount;
    }

    return 0;
}

///////////////////////////////////////////////////////////////////////////////////
ULONG
Filter_Release (
    PSLIP_FILTER pFilter
    )
///////////////////////////////////////////////////////////////////////////////////
{
    ULONG ulRefCount = 0L;

    if (pFilter)
    {
        pFilter->ulRefCount -= 1;
        ulRefCount = pFilter->ulRefCount;

        if (pFilter->ulRefCount == 0)
        {
            // $$BUG  Free Filter here
            return ulRefCount;
        }
    }

    return ulRefCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\bda\slip\makefile.inc ===
# HACK ALERT: This target is solely to keep nmake from whining that it doesn't
# know how to make the dependency in rules that depend on the target executable.
$(TARGETPATHEX)\$(TARGETNAME).sys:

# Build SoftICE symbols
$(TARGETPATHEX)\$(TARGETNAME).nms: $(TARGETPATHEX)\$(TARGETNAME).sys
    echo $(TARGETPATHEX)\$(TARGETNAME) > target.txt
    nmsym /translate:source,package,always /source:. /output:$(TARGETPATHEX)\$(TARGETNAME).nms $(TARGETPATHEX)\$(TARGETNAME).sys
    splitsym -s $(_NT_SYMBOL_PATH)  $(TARGETPATHEX)\$(TARGETNAME).sys

# Delete built files
clean:
    -echo $(TARGETPATHEX)\$(TARGETNAME).*
    -del /s *.obj
    -del /s *.res
    -del build.log
    -del build.err
    -del /s _objects.mac
    -del $(TARGETPATHEX)\$(TARGETNAME).*
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\bda\samples\bdatuner\outpin.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    outpin.cpp

Abstract:

    Transport Ouput pin code.

--*/

#include "BDATuner.h"

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif // ALLOC_DATA_PRAGMA

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA

/*
** (Static) PinCreate() method of the CTransportPin class
**
**    Creates the output pin object and
**    associates it with the filter object. 
**
*/
NTSTATUS
CTransportPin::PinCreate(
    IN OUT PKSPIN pKSPin,
    IN PIRP Irp
    )
{
    NTSTATUS            Status = STATUS_SUCCESS;
    CTransportPin*      pPin;
    CFilter*            pFilter;

    _DbgPrintF(DEBUGLVL_VERBOSE,("CTransportPin::PinCreate"));

    ASSERT(pKSPin);
    ASSERT(Irp);

    //  Obtain a pointer to the filter object for which the output pin is created.
    //
    pFilter = reinterpret_cast<CFilter*>(KsGetFilterFromIrp(Irp)->Context);

    //  Create the transport output pin object.
    //
    pPin = new(PagedPool,MS_SAMPLE_TUNER_POOL_TAG) CTransportPin;  // Tags the allocated memory 
    if (pPin)
    {
        //  Link the pin context to the filter context.
        //  That is, set the output pin's filter pointer data member to the obtained filter pointer.
        //
        pPin->SetFilter( pFilter);
    
        //  Link the pin context to the passed in pointer to the KSPIN structure.
        //
        pKSPin->Context = pPin;
    }
    else
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return Status;
}


/*
** PinClose() method of the CTransportPin class
**
**    Deletes the previously created output pin object.
**
*/
NTSTATUS
CTransportPin::PinClose(
    IN OUT PKSPIN Pin,
    IN PIRP Irp
    )
{
    _DbgPrintF(DEBUGLVL_VERBOSE,("CTransportPin::PinClose"));

    ASSERT(Pin);
    ASSERT(Irp);

    //  Retrieve the transport output pin object from the passed in 
    //  KSPIN structure's context member.
    //
    CTransportPin* pPin = reinterpret_cast<CTransportPin*>(Pin->Context);

    ASSERT(pPin);

    delete pPin;

    return STATUS_SUCCESS;
}

/*
** IntersectDataFormat() method of the CTransportPin class
**
**    Enables connection of the output pin with a downstream filter.
**
*/
NTSTATUS
CTransportPin::IntersectDataFormat(
    IN PVOID pContext,
    IN PIRP pIrp,
    IN PKSP_PIN Pin,
    IN PKSDATARANGE DataRange,
    IN PKSDATARANGE MatchingDataRange,
    IN ULONG DataBufferSize,
    OUT PVOID Data OPTIONAL,
    OUT PULONG DataSize
     )
{
    if ( DataBufferSize < sizeof(KS_DATARANGE_BDA_TRANSPORT) )
    {
        *DataSize = sizeof( KS_DATARANGE_BDA_TRANSPORT );
        return STATUS_BUFFER_OVERFLOW;
    }
    else if (DataRange -> FormatSize < sizeof (KS_DATARANGE_BDA_TRANSPORT)) 
    {
	return STATUS_NO_MATCH;
    } else
    {
        ASSERT(DataBufferSize == sizeof(KS_DATARANGE_BDA_TRANSPORT));

        *DataSize = sizeof( KS_DATARANGE_BDA_TRANSPORT );
        RtlCopyMemory( Data, (PVOID)DataRange, sizeof(KS_DATARANGE_BDA_TRANSPORT));

        return STATUS_SUCCESS;
    }
}

/*
** GetSignalStatus() method of the CTransportPin class
**
**    Retrieves the value of the demodulator node signal statistics properties.
**
*/
NTSTATUS
CTransportPin::GetSignalStatus(
    IN PIRP         pIrp,
    IN PKSPROPERTY  pKSProperty,
    IN PULONG       pulProperty
    )
{
    NTSTATUS                    Status = STATUS_SUCCESS;
    CTransportPin *             pPin;
    CFilter*                    pFilter;
    BDATUNER_DEVICE_STATUS      DeviceStatus;

    _DbgPrintF(DEBUGLVL_VERBOSE,("CTransportPin::GetSignalStatus"));

    ASSERT(pIrp);
    ASSERT(pKSProperty);
    ASSERT(pulProperty);


    //  Call the BDA support library to 
    //  validate that the node type is associated with this pin.
    //
    Status = BdaValidateNodeProperty( pIrp, pKSProperty);
    if (NT_SUCCESS( Status))
    {
        //  Obtain a pointer to the pin object.
        //
        //  Because the property dispatch table calls the CTransportPin::GetSignalStatus() 
        //  method directly, the method must retrieve a pointer to the underlying pin object.
        //
        pPin = reinterpret_cast<CTransportPin *>(KsGetPinFromIrp(pIrp)->Context);
        ASSERT(pPin);
    
        //  Retrieve the filter context from the pin context.
        //
        pFilter = pPin->GetFilter();
        ASSERT( pFilter);
    
        Status = pFilter->GetStatus( &DeviceStatus);
        if (Status == STATUS_SUCCESS)
        {
            switch (pKSProperty->Id)
            {
            case KSPROPERTY_BDA_SIGNAL_LOCKED:
                *pulProperty = DeviceStatus.fSignalLocked;
                break;
        
            default:
                Status = STATUS_INVALID_PARAMETER;
            }
        }
    }

    return Status;
}


/*
** PutAutoDemodProperty() method of the CTransportPin class
**
**    Starts or Stops automatic demodulation.
**
*/
NTSTATUS
CTransportPin::PutAutoDemodProperty(
    IN PIRP         pIrp,
    IN PKSPROPERTY  pKSProperty,
    IN PULONG       pulProperty
    )
{
    NTSTATUS        Status = STATUS_SUCCESS;
    CTransportPin*  pPin;
    CFilter*        pFilter;

    _DbgPrintF(DEBUGLVL_VERBOSE,("CTransportPin::PutAutoDemodProperty"));

    ASSERT(pIrp);
    ASSERT(pKSProperty);
    ASSERT(pulProperty);


    //  Call the BDA support library to 
    //  validate that the node type is associated with this pin.
    //
    Status = BdaValidateNodeProperty( pIrp, pKSProperty);
    if (NT_SUCCESS( Status))
    {
        //  Obtain a pointer to the pin object.
        //
        //  Because the property dispatch table calls the CTransportPin::PutAutoDemodProperty() 
        //  method directly, the method must retrieve a pointer to the underlying pin object.
        //
        pPin = reinterpret_cast<CTransportPin *>(KsGetPinFromIrp(pIrp)->Context);
        ASSERT( pPin);
    
        //  Retrieve the filter context from the pin context.
        //
        pFilter = pPin->GetFilter();
        ASSERT( pFilter);
    
        switch (pKSProperty->Id)
        {
        case KSPROPERTY_BDA_AUTODEMODULATE_START:
            //  Start Demodulator if stopped.
            //  NOTE!  The default state of the demod should match the
            //         graph run state.  This property will only be set
            //         if KSPROPERTY_BDA_AUTODEMODULATE_STOP was previously
            //         set.
            break;
    
        case KSPROPERTY_BDA_AUTODEMODULATE_STOP:
            //  Stop Demodulator
            //  A demodulator stop/start sequence may be used in an
            //  attempt to retrain the demodulator after a channel change.
            break;
    
        default:
            Status = STATUS_INVALID_PARAMETER;
        }
    }

    return Status;
}

#if !ATSC_RECEIVER
/*
** PutDigitalDemodProperty() method of the CTransportPin class
**
**    Sets the value of the digital demodulator node properties.
**
*/
NTSTATUS
CTransportPin::PutDigitalDemodProperty(
    IN PIRP         pIrp,
    IN PKSPROPERTY  pKSProperty,
    IN PULONG       pulProperty
    )
{
    NTSTATUS        Status = STATUS_SUCCESS;
    CTransportPin*  pPin;
    CFilter*        pFilter;

    _DbgPrintF(DEBUGLVL_VERBOSE,("CTransportPin::PutDigitalDemodProperty"));

    ASSERT(pIrp);
    ASSERT(pKSProperty);
    ASSERT(pulProperty);


    //  Call the BDA support library to 
    //  validate that the node type is associated with this pin.
    //
    Status = BdaValidateNodeProperty( pIrp, pKSProperty);
    if (NT_SUCCESS( Status))
    {
        //  Obtain a pointer to the pin object.
        //
        //  Because the property dispatch table calls the CTransportPin::PutDigitalDemodProperty() 
        //  method directly, the method must retrieve a pointer to the underlying pin object.
        //
        pPin = reinterpret_cast<CTransportPin *>(KsGetPinFromIrp(pIrp)->Context);
        ASSERT( pPin);
    
        //  Retrieve the filter context from the pin context.
        //
        pFilter = pPin->GetFilter();
        ASSERT( pFilter);
    
        switch (pKSProperty->Id)
        {
        case KSPROPERTY_BDA_MODULATION_TYPE:
            break;
    
        case KSPROPERTY_BDA_INNER_FEC_TYPE:
            break;
    
        case KSPROPERTY_BDA_INNER_FEC_RATE:
            break;
    
        case KSPROPERTY_BDA_OUTER_FEC_TYPE:
            break;
    
        case KSPROPERTY_BDA_OUTER_FEC_RATE:
            break;
    
        case KSPROPERTY_BDA_SYMBOL_RATE:
            break;
    
        case KSPROPERTY_BDA_SPECTRAL_INVERSION:
            break;
    
        case KSPROPERTY_BDA_GUARD_INTERVAL:
            break;
    
        case KSPROPERTY_BDA_TRANSMISSION_MODE:
            break;
    
        default:
            Status = STATUS_INVALID_PARAMETER;
        }
    }

    return Status;
}


/*
** GetDigitalDemodProperty() method of the CTransportPin class
**
**    Gets the value of the digital demodulator node properties.
**
*/
NTSTATUS
CTransportPin::GetDigitalDemodProperty(
    IN PIRP         pIrp,
    IN PKSPROPERTY  pKSProperty,
    IN PULONG       pulProperty
    )
{
    NTSTATUS        Status = STATUS_SUCCESS;
    CTransportPin*  pPin;
    CFilter*        pFilter;

    _DbgPrintF(DEBUGLVL_VERBOSE,("CTransportPin::GetDigitalDemodProperty"));

    ASSERT(pIrp);
    ASSERT(pKSProperty);
    ASSERT(pulProperty);


    //  Call the BDA support library to 
    //  validate that the node type is associated with this pin.
    //
    Status = BdaValidateNodeProperty( pIrp, pKSProperty);
    if (NT_SUCCESS( Status))
    {
        //  Obtain a pointer to the pin object.
        //
        //  Because the property dispatch table calls the CTransportPin::GetDigitalDemodProperty() 
        //  method directly, the method must retrieve a pointer to the underlying pin object.
        //
        pPin = reinterpret_cast<CTransportPin *>(KsGetPinFromIrp(pIrp)->Context);
        ASSERT( pPin);
    
        //  Retrieve the filter context from the pin context.
        //
        pFilter = pPin->GetFilter();
        ASSERT( pFilter);
    
        switch (pKSProperty->Id)
        {
        case KSPROPERTY_BDA_MODULATION_TYPE:
            break;
    
        case KSPROPERTY_BDA_INNER_FEC_TYPE:
            break;
    
        case KSPROPERTY_BDA_INNER_FEC_RATE:
            break;
    
        case KSPROPERTY_BDA_OUTER_FEC_TYPE:
            break;
    
        case KSPROPERTY_BDA_OUTER_FEC_RATE:
            break;
    
        case KSPROPERTY_BDA_SYMBOL_RATE:
            break;
    
        case KSPROPERTY_BDA_SPECTRAL_INVERSION:
            break;
    
        case KSPROPERTY_BDA_GUARD_INTERVAL:
            break;
    
        case KSPROPERTY_BDA_TRANSMISSION_MODE:
            break;
    
        default:
            Status = STATUS_INVALID_PARAMETER;
        }
    }

    return Status;
}
#endif // !ATSC_RECEIVER


/*
** PutExtensionProperties() method of the CTransportPin class
**
**    Sets the value of the demodulator node extension properties.
**
*/
NTSTATUS
CTransportPin::PutExtensionProperties(
    IN PIRP         pIrp,
    IN PKSPROPERTY  pKSProperty,
    IN PULONG       pulProperty
    )
{
    NTSTATUS        Status = STATUS_SUCCESS;
    CTransportPin*  pPin;
    CFilter*        pFilter;

    _DbgPrintF(DEBUGLVL_VERBOSE,("CTransportPin::PutExtensionProperties"));

    ASSERT(pIrp);
    ASSERT(pKSProperty);
    ASSERT(pulProperty);


    //  Call the BDA support library to 
    //  validate that the node type is associated with this pin.
    //
    Status = BdaValidateNodeProperty( pIrp, pKSProperty);
    if (NT_SUCCESS( Status))
    {
        //  Obtain a pointer to the pin object.
        //
        //  Because the property dispatch table calls the CTransportPin::PutExtensionProperties() 
        //  method directly, the method must retrieve a pointer to the underlying pin object.
        //
        pPin = reinterpret_cast<CTransportPin *>(KsGetPinFromIrp(pIrp)->Context);
        ASSERT( pPin);
    
        //  Retrieve the filter context from the pin context.
        //
        pFilter = pPin->GetFilter();
        ASSERT( pFilter);
    
        switch (pKSProperty->Id)
        {
        case KSPROPERTY_BDA_SAMPLE_DEMOD_EXTENSION_PROPERTY1:
            Status = pFilter->SetDemodProperty1(*pulProperty);
            break;
    
        case KSPROPERTY_BDA_SAMPLE_DEMOD_EXTENSION_PROPERTY2:
            Status = pFilter->SetDemodProperty1(*pulProperty);
            break;
    
	// KSPROPERTY_BDA_SAMPLE_DEMOD_EXTENSION_PROPERTY3 does not have a SetHandler
        // according to declaration of BdaSampleDemodExtensionProperties

        default:
            Status = STATUS_INVALID_PARAMETER;
        }
    }

    return Status;
}

/*
** GetExtensionProperties() method of the CTransportPin class
**
**    Retrieves the value of the demodulator node extension properties.
**
*/
NTSTATUS
CTransportPin::GetExtensionProperties(
    IN PIRP         Irp,
    IN PKSPROPERTY  pKSProperty,
    IN PULONG       pulProperty
    )
{
    NTSTATUS        Status = STATUS_SUCCESS;
    CTransportPin * pPin;
    CFilter*        pFilter;

    _DbgPrintF(DEBUGLVL_VERBOSE,("CTransportPin::GetExtensionProperties"));

    ASSERT(Irp);
    ASSERT(pKSProperty);
    ASSERT(pulProperty);

    //  Obtain a pointer to the pin object.
    //
    //  Because the property dispatch table calls the CTransportPin::GetExtensionProperties() 
    //  method directly, the method must retrieve a pointer to the underlying pin object.
    //
    pPin = reinterpret_cast<CTransportPin *>(KsGetPinFromIrp(Irp)->Context);
    ASSERT(pPin);

    //  Retrieve the filter context from the pin context.
    //
    pFilter = pPin->GetFilter();
    ASSERT( pFilter);

    switch (pKSProperty->Id)
    {
    case KSPROPERTY_BDA_SAMPLE_DEMOD_EXTENSION_PROPERTY1:
        Status = pFilter->GetDemodProperty1(pulProperty);
        break;

    // KSPROPERTY_BDA_SAMPLE_DEMOD_EXTENSION_PROPERTY2 does not have a GetHandler
    // according to declaration of BdaSampleDemodExtensionProperties

    case KSPROPERTY_BDA_SAMPLE_DEMOD_EXTENSION_PROPERTY3:
        Status = pFilter->GetDemodProperty3(pulProperty);
        break;

    default:
        Status = STATUS_INVALID_PARAMETER;
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\bda\samples\bdatuner\splmedia.h ===
/*++

Copyright (c) 1996 Microsoft Corporation.

Module Name:

    SplMedia.h

Abstract:

    Definitions for Sample Property, Method, and Events
    for the Generic Broadcast Driver Architecture Sample

--*/

#if !defined(_KSMEDIA_)
#error KSMEDIA.H must be included before BDAMEDIA.H
#endif // !defined(_KSMEDIA_)

#if !defined(_BDATYPES_)
#error BDATYPES.H must be included before BDAMEDIA.H
#endif // !defined(_BDATYPES_)

#if !defined(_BDAMEDIA_)
#define _BDAMEDIA_
#endif // !defined(_BDAMEDIA_)

#if !defined(_SPLMEDIA_)
#define _SPLMEDIA_

#if defined(__cplusplus)
extern "C" {
#endif // defined(__cplusplus)



//===========================================================================
//
//  Implementation GUID for BDA Generic Sample Tuner
//
//  This will match the implementation GUID in the BDA Generic Sample Capture
//
//===========================================================================

//  Define the implementation GUID.  This GUID will be the same for all
//  drivers that are used to implement a single receiver implemenation.
//  In this case there will be a capture driver that must use the same
//  implementation GUID to insure that pins are correctly connected.
//
//  If the driver set is used by only one implementation, as is the case here,
//  we can hard code the implementation GUID in the driver.  If more than
//  one receiver implementation uses the same driver, then the implementation
//  GUID should be written into the registry by the INF that installs a
//  particular implementation.
//
//  NOTE!  DON'T USE THIS GUID FOR YOUR DRIVER!
//  Generate a new guid using guidgen.exe
//
// {7036ED35-881D-4c50-ADEC-710ECA227DB3}
//
#define STATIC_KSMEDIUMSETID_MyImplementation \
    0x7036ed35L, 0x881d, 0x4c50, 0xad, 0xec, 0x71, 0x0e, 0xca, 0x22, 0x7d, 0xb3 
DEFINE_GUIDSTRUCT("7036ED35-881D-4c50-ADEC-710ECA227DB3", KSMEDIUMSETID_MyImplementation);
#define KSMEDIUMSETID_MyImplementation DEFINE_GUIDNAMED(KSMEDIUMSETID_MyImplementation)



//===========================================================================
//
//  KSProperty Set Definitions for BDA Generic Sample
//
//===========================================================================



//------------------------------------------------------------
//
//
//  BDA Sample Demodulator Node Extension Properties
//
//  NOTE!  DO NOT USE THIS GUID IN YOUR DRIVER!
//
//  You need to create a unique GUID to prevent plugin CLSID collisions.
//  Do not use the following one for BDA Sample Property Set
// {C8417B10-88FC-49d3-88DB-AD33260655D6}
//
#define STATIC_KSPROPSETID_BdaSampleDemodExtensionProperties \
    0xc8417b10, 0x88fc, 0x49d3, 0x88, 0xdb, 0xad, 0x33, 0x26, 0x6, 0x55, 0xd6
DEFINE_GUIDSTRUCT("C8417B10-88FC-49d3-88DB-AD33260655D6", KSPROPSETID_BdaSampleDemodExtensionProperties);
#define KSPROPSETID_BdaSampleDemodExtensionProperties DEFINE_GUIDNAMED(KSPROPSETID_BdaSampleDemodExtensionProperties)

typedef enum {
    KSPROPERTY_BDA_SAMPLE_DEMOD_EXTENSION_PROPERTY1 = 0,
    KSPROPERTY_BDA_SAMPLE_DEMOD_EXTENSION_PROPERTY2,
    KSPROPERTY_BDA_SAMPLE_DEMOD_EXTENSION_PROPERTY3
} KSPROPERTY_BDA_SAMPLE_DEMOD_EXTENSION;

// specify the sizeof the actual property to retrieve here 
#define DEFINE_KSPROPERTY_ITEM_BDA_SAMPLE_DEMOD_EXTENSION_PROPERTY1(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_SAMPLE_DEMOD_EXTENSION_PROPERTY1,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(ULONG),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

// specify the sizeof the actual property to retrieve here
#define DEFINE_KSPROPERTY_ITEM_BDA_SAMPLE_DEMOD_EXTENSION_PROPERTY2(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_SAMPLE_DEMOD_EXTENSION_PROPERTY2,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(ULONG),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

// specify the sizeof the actual property to retrieve here 
#define DEFINE_KSPROPERTY_ITEM_BDA_SAMPLE_DEMOD_EXTENSION_PROPERTY3(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_SAMPLE_DEMOD_EXTENSION_PROPERTY3,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(ULONG),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)


#if defined(__cplusplus)
}
#endif // defined(__cplusplus)

#endif // !defined(_SPLMEDIA_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\bda\slip\filter.h ===
#ifndef _FILTER_H_
#define _FILTER_H_


//////////////////////////////////////////////////////////////////
//
//
//
NTSTATUS
CreateFilter (
    PDRIVER_OBJECT DriverObject,
    PDEVICE_OBJECT DeviceObject,
    PSLIP_FILTER   pFilter
    );

NTSTATUS
Filter_QueryInterface (
    PSLIP_FILTER pFilter
    );

ULONG
Filter_AddRef (
    PSLIP_FILTER pFilter
    );

ULONG
Filter_Release (
    PSLIP_FILTER pFilter
    );

#endif  // _FILTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\bda\slip\mpegcrc.c ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (C) 1996-1997  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:   mpegcrc.c
//
//  PURPOSE:  calculate a standard MPEG 13818-1 style MSB CRC 32.
//
//  FUNCTIONS:
//
//  COMMENTS:   Routine replaced with known good algorithm 4/9/1999 =tkb
//
///////////////////////////////////////////////////////////////////////////////

#include <stdlib.h>
#include <stdio.h>
#include <winsock2.h>
#include <windows.h>

///////////////////////////////////////////////////////////////////////////////
//
//
// Build crc table the first time
//
//
#define MPEGCRC_POLY 0x04c11db7     // MPEG polynomial

ULONG crc32_table[256];


///////////////////////////////////////////////////////////////////////////////
void
init_mpegcrc (
    )
///////////////////////////////////////////////////////////////////////////////
{
        int i, j;
        ULONG c;

        for (i = 0; i < 256; ++i) {
                for (c = i << 24, j = 8; j > 0; --j)
                        c = c & 0x80000000 ? (c << 1) ^ MPEGCRC_POLY : (c << 1);
                crc32_table[i] = c;
        }
}

///////////////////////////////////////////////////////////////////////////////
void
MpegCrcUpdate (
    ULONG * crc,
    UINT len,
    UCHAR * buf
    )
///////////////////////////////////////////////////////////////////////////////
{
        UCHAR *p;

        if (!crc32_table[1])    /* if not already done, */
                init_mpegcrc();   /* build table */

        for (p = buf; len > 0; ++p, --len)
                *crc = (*crc << 8) ^ crc32_table[(*crc >> 24) ^ *p];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\bda\slip\recv.h ===
/////////////////////////////////////////////////////////////////////////////
//
//
// Copyright (c) 1996, 1997  Microsoft Corporation
//
//
// Module Name:
//      recv.h
//
// Abstract:
//
//
// Author:
//
//      P Porzuczek
//
// Environment:
//
// Revision History:
//
//
//////////////////////////////////////////////////////////////////////////////

#ifndef _RECV_H_
#define _RECV_H_


///////////////////////////////////////////////////////////////////////////////////////
//
// some character values
//
#define FRAME_ESCAPE        0xDB
#define FRAME_END           0xC0
#define TRANS_FRAME_END     0xDC
#define TRANS_FRAME_ESCAPE  0xDD
#define PROTO_ID            0x00
#define PROTO_ID_OLD        0x03

#define NORMAL_COMPRESSED_HEADER      4
#define IP_ID_SIZE                    2
#define UDP_CHKSUM_SIZE               2

#define PACKET_COMPRESSED(x)  (x & 0x80)
#define IP_STREAM_INDEX(x)    (x & 0x7f)


#define NABTSIP_MAX_PACKET         1514
#define NABTSIP_MAX_LOOKAHEAD      (NABTSIP_MAX_PACKET - ETHERNET_HEADER_SIZE)
#define NABTSIP_MAX_PAYLOAD        (NABTSIP_MAX_LOOKAHEAD + MPEG_CRC_SIZE)
#define MPEG_CRC_SIZE              4
#define ETHERNET_HEADER_SIZE       14
#define ETHERNET_LENGTH_OF_ADDRESS 6


///////////////////////////////////////////////////////////////////////////////////////
//
//
//
//
// Size of the ethernet address
//
typedef struct _Header802_3
{
   UCHAR DestAddress[ETHERNET_LENGTH_OF_ADDRESS];
   UCHAR SourceAddress[ETHERNET_LENGTH_OF_ADDRESS];
   UCHAR Type[2];
} Header802_3, * PHeader802_3;

///////////////////////////////////////////////////////////////////////////////////////
//
//
//
#define htons(x)     ((((x) >> 8) & 0x00FF) | (((x) << 8) & 0xFF00))

///////////////////////////////////////////////////////////////////////////////////////
//
//
//
#define NabtsNtoHl(l)                               \
            ( ( ((l) >> 24) & 0x000000FFL ) |       \
              ( ((l) >>  8) & 0x0000FF00L ) |       \
              ( ((l) <<  8) & 0x00FF0000L ) |       \
              ( ((l) << 24) & 0xFF000000L ) )

///////////////////////////////////////////////////////////////////////////////////////
//
//
//
#define NabtsNtoHs(s)                               \
            ( ( ((s) >> 8) & 0x00FF ) |             \
              ( ((s) << 8) & 0xFF00 ) )


///////////////////////////////////////////////////////////////////////////////////////
//
// IP Compression States.
//
typedef enum
{
    NABTS_CS_UNCOMPRESSED = 0,
    NABTS_CS_COMPRESSED,
    NABTS_CS_CHKCRC
};


///////////////////////////////////////////////////////////////////////////////////////
//
//
//
struct _C
{
   UCHAR uc[4];
};

///////////////////////////////////////////////////////////////////////////////////////
//
//
//
struct _L
{
   ULONG ul;
};

///////////////////////////////////////////////////////////////////////////////////////
//
//
//
typedef union
{
   struct _C c;
   struct _L l;
}CL, *PCL;


///////////////////////////////////////////////////////////////////////////////////////
//
//  NABTSIP Group Range
//
#define NABTSIP_GROUP_ID_RANGE_LOW  0
#define NABTSIP_GROUP_ID_RANGE_HI   4096


///////////////////////////////////////////////////////////////////////////////////////
//
//
//
//#define NAB_STREAM_LIFE (LONGLONG)1000 * 1000 * 10 * 60 * 30 // 30 Minutes
#define NAB_STREAM_LIFE (LONGLONG)1000 * 1000 * 10 * 60 * 10 // 10 Minutes
#define NAB_STATUS_INTERVAL (LONGLONG)1000 * 1000 * 10 * 60 * 1 // 1 Minutes
#define NAB_STREAM_SIGNATURE            ((CSHORT)0xab05)

///////////////////////////////////////////////////////////////////////////////////////
//
//  Frame states.
//
typedef enum
{
    NABTS_FS_SYNC,
    NABTS_FS_SYNC_PROTO,
    NABTS_FS_COMPRESSION,
    NABTS_FS_COLLECT,
    NABTS_FS_COLLECT_ESCAPE
};



///////////////////////////////////////////////////////////////////////////////////////
//
//  Frame states.
//
typedef struct _AddrIP
{
   UCHAR ucHighMSB;
   UCHAR ucHighLSB;
   UCHAR ucLowMSB;
   UCHAR ucLowLSB;
} AddrIP, * PAddrIP;


///////////////////////////////////////////////////////////////////////////////////////
//
// IP Header
//
typedef struct _HeaderIP
{
   UCHAR ucVersHlen;
   UCHAR ucServiceType;
   UCHAR ucTotalLenHigh;
   UCHAR ucTotalLenLow;
   UCHAR ucIDHigh;
   UCHAR ucIDLow;
   UCHAR ucFlags;
   UCHAR ucOffsetLow;
   UCHAR ucTimeToLive;
   UCHAR ucProtocol;
   UCHAR ucChecksumHigh;
   UCHAR ucChecksumLow;
   AddrIP ipaddrSrc;
   AddrIP ipaddrDst;
} HeaderIP, * PHeaderIP;

///////////////////////////////////////////////////////////////////////////////////////
//
//
//
typedef struct _HeaderUDP
{
   UCHAR ucSourcePortMSB;
   UCHAR ucSourcePortLSB;
   UCHAR ucDestPortMSB;
   UCHAR ucDestPortLSB;
   UCHAR ucMsgLenHigh;
   UCHAR ucMsgLenLow;
   UCHAR ucChecksumHigh;
   UCHAR ucChecksumLow;
} HeaderUDP, *PHeaderUDP;

///////////////////////////////////////////////////////////////////////////////////////
//
//
//
typedef struct _IP_CACHE {
    HeaderIP    ipHeader;
    HeaderUDP   udpHeader;
    LARGE_INTEGER liLastUsed;
} NAB_HEADER_CACHE, *PNAB_HEADER_CACHE;


//
// IP Compression State Struct.
//
typedef struct _NAB_IP_COMPRESSION
{
    ULONG   usCompressionState;
    USHORT  uscbRequiredSize;
    USHORT  uscbHeaderOffset;
    USHORT  usrgCompressedHeader[3];
    LARGE_INTEGER liLastUsed;
}NAB_COMPRESSION_STATE, *PNAB_COMPRESSION_STATE;


///////////////////////////////////////////////////////////////////////////////////////
//
// NabtsIp Stream Context.
//

#define MAX_IP_STREAMS 128
#define MAX_STREAM_PAYLOAD 1600    

typedef struct _NAB_STREAM
{
    ULONG       ulType;
    ULONG       ulSize;
    ULONG       ulProtoID;
    BOOLEAN     fUsed;
    ULONG       groupID;
    PUCHAR      pszBuffer;
    ULONG       ulcbSize;
    ULONG       ulOffset;
    ULONG       ulFrameState;
    LIST_ENTRY  Linkage;
    ULONG       ulIPStreamIndex;
    PHW_STREAM_REQUEST_BLOCK pSrb;
    NAB_COMPRESSION_STATE NabCState[MAX_IP_STREAMS];
    NAB_HEADER_CACHE NabHeader[MAX_IP_STREAMS];
    ULONG       ulMpegCrc;
    ULONG       ulCrcBytesIndex;
    ULONG       ulLastCrcBytes;
    LARGE_INTEGER liLastTimeUsed;
    CHAR        rgBuf[MAX_STREAM_PAYLOAD];
} NAB_STREAM, *PNAB_STREAM;



///////////////////////////////////////////////////////////////////////////////////////
//
//
// Prototypes
//
//
VOID
vCheckNabStreamLife (
    PSLIP_FILTER pFilter
    );


NTSTATUS
ntCreateNabStreamContext(
    PSLIP_FILTER pFilter,
    ULONG groupID,
    PNAB_STREAM *ppNabStream
    );


NTSTATUS
ntGetNdisPacketForStream (
    PSLIP_FILTER pFilter,
    PNAB_STREAM pNabStream
    );
VOID
vDestroyNabStreamContext(
   PSLIP_FILTER pUser,
   PNAB_STREAM pNabStream,
   BOOLEAN fRemoveFromList
   );

NTSTATUS
ntAllocateNabStreamContext(
    PNAB_STREAM *ppNabStream
    );

NTSTATUS
ntNabtsRecv(
    PSLIP_FILTER pFilter,
    PNABTSFEC_BUFFER pNabData
    );

VOID
CancelNabStreamSrb (
    PSLIP_FILTER pFilter,
    PHW_STREAM_REQUEST_BLOCK pSrb
    );

VOID
DeleteNabStreamQueue (
    PSLIP_FILTER pFilter
    );


VOID
MpegCrcUpdate (
    ULONG * crc,
    UINT uiCount,
    UCHAR * pText
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\bda\slip\recv.c ===
//////////////////////////////////////////////////////////////////////////
//
//
// Copyright (c) 1996, 1997  Microsoft Corporation
//
//
// Module Name:
//      recv.c
//
// Abstract:
//
//
// Author:
//
//      P Porzuczek
//
// Environment:
//
// Revision History:
//
//
//////////////////////////////////////////////////////////////////////////////

#include <wdm.h>
#include <strmini.h>
#include <ksmedia.h>

#include "slip.h"
#include "main.h"
#include "recv.h"



//////////////////////////////////////////////////////////////////////////////
//
// Init 802.3 header template
//
Header802_3 h802_3Template =
{
    {0x01, 0x00, 0x5e, 0, 0, 0}
  , {0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
  , {0x08, 0x00}
};


#if DBG
UCHAR MyBuffer [1600] = {0};

UCHAR TestBuffer [] = { 0xC0, 0xC0, 0x00, 0xC7, 0xD3, 0x97, 0x00, 0x00, 0x5E, 0x56,
                        0x23, 0x11, 0x07, 0x00, 0x00, 0x00, 0x2C, 0x01, 0x00, 0x00, 0xAA, 0x58, 0x00, 0x00, 0x3D, 0xC5,
                        0x00, 0x00, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33,
                        0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33,
                        0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33,
                        0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33,
                        0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33,
                        0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33,
                        0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33,
                        0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33,
                        0x22, 0x11, 0x44, 0x33, 0xDC, 0xA2, 0x3B, 0x82, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33,
                        0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0xE9, 0xCE,
                        0xFA, 0x7D, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33,
                        0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33,
                        0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33,
                        0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33,
                        0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33,
                        0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33,
                        0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33,
                        0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33,
                        0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33,
                        0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33,
                        0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33,
                        0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33,
                        0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33,
                        0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33,
                        0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33,
                        0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33,
                        0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33,
                        0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33,
                        0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33,
                        0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33,
                        0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x53, 0x60, 0xBB, 0x03, 0xC0   };


//////////////////////////////////////////////////////////////////////////////
VOID
DumpData (
    PUCHAR pData,
    ULONG  ulSize
    )
//////////////////////////////////////////////////////////////////////////////
{
  ULONG  ulCount;
  ULONG  ul;
  UCHAR  uc;

  DbgPrint("Dump - Data: %x, Size: %x\n", pData, ulSize);
  while (ulSize)
  {
      ulCount = 16 < ulSize ? 16 : ulSize;

      for (ul = 0; ul < ulCount; ul++)
      {
          uc = *pData;

          DbgPrint("%02X ", uc);
          ulSize -= 1;
          pData  += 1;
      }

      DbgPrint("\n");
  }
  if(TestDebugFlag & TEST_DBG_ASSERT)
  {
      DEBUG_BREAKPOINT();
  }
}


///////////////////////////////////////////////////////////////////////////////////////
VOID
DumpNabStream (
    PNAB_STREAM pNabStream
    )
///////////////////////////////////////////////////////////////////////////////////////
{

    TEST_DEBUG (TEST_DBG_NAB, ("pszBuffer......: %08X\n", pNabStream->pszBuffer));
    TEST_DEBUG (TEST_DBG_NAB, ("ulcbSize.......: %08X\n", pNabStream->ulcbSize));
    TEST_DEBUG (TEST_DBG_NAB, ("ulOffset.......: %08X\n", pNabStream->ulOffset));
    TEST_DEBUG (TEST_DBG_NAB, ("ulMpegCrc......: %08X\n", pNabStream->ulMpegCrc));
    TEST_DEBUG (TEST_DBG_NAB, ("ulCrcBytesIndex: %08X\n", pNabStream->ulCrcBytesIndex));
    TEST_DEBUG (TEST_DBG_NAB, ("ulLastCrcBytes.: %08X\n", pNabStream->ulLastCrcBytes));
    TEST_DEBUG (TEST_DBG_NAB, ("ulIPStreamIndex: %08X\n", pNabStream->ulIPStreamIndex));

    return;
}

ULONG
Checksum ( char * psz, ULONG ulSize )
//////////////////////////////////////////////////////////////////////////////
{
    ULONG           Checksum = 0;
    ULONG           uli = 0;

    if(ulSize < 0x41d && ulSize)
    {
        for ( uli=0; uli <= ulSize-2; uli += 2)
        {
            Checksum += ((ULONG) (psz[uli]) << 8) + (ULONG) (psz[uli+1]);
        }

        Checksum = (Checksum >> 16) + (Checksum & 0xffff);
        Checksum += (Checksum >> 16);
        Checksum = ~Checksum;
    }
    return Checksum;
}

ULONG ulNumPacketsSent = 0;
ULONG ulIndicateEvery = 10;
ULONG ulIndicated = 0;

#endif   //DBG

///////////////////////////////////////////////////////////////////////////////////////
VOID
ResetNabStream (
    PSLIP_FILTER pFilter,
    PNAB_STREAM pNabStream,
    PHW_STREAM_REQUEST_BLOCK pSrb,
    PVOID pBuffer,
    ULONG ulBufSize
    )
///////////////////////////////////////////////////////////////////////////////////////
{

    if (pNabStream->ulOffset > sizeof (Header802_3))
    {
        pFilter->Stats.ulTotalSlipFramesIncomplete += 1;
        pFilter->Stats.ulTotalSlipBytesDropped += pNabStream->ulOffset - sizeof (Header802_3);
    }

    //
    // Reset the NAB_STREAM structure for this group ID
    //
    pNabStream->pSrb             = pSrb;
    pNabStream->pszBuffer        = pBuffer;
    pNabStream->ulcbSize         = ulBufSize;
    pNabStream->ulOffset         = 0;
    pNabStream->ulMpegCrc        = 0xFFFFFFFF;
    pNabStream->ulCrcBytesIndex  = 0l;
    pNabStream->ulLastCrcBytes   = 0l;

    if(pBuffer)
    {
        //  Copy the 802.3 header template into the frame.  We will replace
        //  the destination address and protocol on receive.
        //
        RtlCopyMemory (pNabStream->pszBuffer, &h802_3Template, sizeof (Header802_3));

        //
        //$$PFP update buffer offset
        //
        pNabStream->ulOffset = sizeof (Header802_3);
    }

    return;

}

///////////////////////////////////////////////////////////////////////////////////////
VOID
CancelNabStreamSrb (
    PSLIP_FILTER pFilter,
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
///////////////////////////////////////////////////////////////////////////////////////
{
    PLIST_ENTRY pFlink     = NULL;
    PLIST_ENTRY pQueue     = NULL;
    BOOLEAN bFound         = FALSE;
    PNAB_STREAM pNSTemp    = NULL;

    KIRQL Irql              = {0};

    pQueue = &pFilter->StreamContxList;


    KeAcquireSpinLock(&pFilter->StreamUserSpinLock, &Irql);


    if ( !IsListEmpty (pQueue))
    {
        pFlink = pQueue->Flink;
        while ((pFlink != pQueue ) && !bFound)
        {
            pNSTemp = CONTAINING_RECORD (pFlink, NAB_STREAM, Linkage);

            if (pSrb && pSrb == pNSTemp->pSrb)
            {
                pNSTemp->pSrb->Status = STATUS_CANCELLED;
                StreamClassStreamNotification (StreamRequestComplete, pNSTemp->pSrb->StreamObject, pNSTemp->pSrb);
                TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: StreamRequestComplete on pSrb: %08X\n", pNSTemp->pSrb));

                pNSTemp->pSrb  = NULL;
                bFound         = TRUE;
            }

            pFlink = pFlink->Flink;
        }

        if (bFound)
        {
            vDestroyNabStreamContext (pFilter, pNSTemp, FALSE);
        }

    }

    KeReleaseSpinLock(&pFilter->StreamUserSpinLock, Irql);
	

}
///////////////////////////////////////////////////////////////////////////////////////
VOID
DeleteNabStreamQueue (
    PSLIP_FILTER pFilter
    )
///////////////////////////////////////////////////////////////////////////////////////
{
    PLIST_ENTRY pFlink     = NULL;
    PLIST_ENTRY pQueue     = NULL;
    PNAB_STREAM pNSTemp    = NULL;
    KIRQL Irql={0};
    
    pQueue = &pFilter->StreamContxList;
    KeAcquireSpinLock(&pFilter->StreamUserSpinLock, &Irql);
    
    while ( !IsListEmpty (pQueue))
    {
        pFlink = RemoveHeadList (pQueue);
        pNSTemp = CONTAINING_RECORD (pFlink, NAB_STREAM, Linkage);

        if(pNSTemp && pNSTemp->pSrb)
        {
            pNSTemp->pSrb->Status = STATUS_CANCELLED;
            StreamClassStreamNotification (StreamRequestComplete, pNSTemp->pSrb->StreamObject, pNSTemp->pSrb);
            TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: StreamRequestComplete on pSrb: %08X\n", pNSTemp->pSrb));

            pNSTemp->pSrb = NULL;

            vDestroyNabStreamContext (pFilter, pNSTemp, FALSE);
        }
    }
  KeReleaseSpinLock(&pFilter->StreamUserSpinLock, Irql);

    return;
}


//////////////////////////////////////////////////////////////////////////////
ULONG
CalculateCrc (
    PUCHAR pPacket,
    ULONG  ulSize
    )
//////////////////////////////////////////////////////////////////////////////
{
    ULONG  ul            = 0;
    ULONG ulLastCrcBytes = 0;
    ULONG ulMpegCrc      = 0xFFFFFFFF;
    PUCHAR ptr           = NULL;
    PCL pcl              = (PCL)&ulLastCrcBytes;

    for (ptr = pPacket, ul = 0; ul < ulSize; ul++, ptr++)
    {
        //if (ul > 3)
        //{
            //MpegCrcUpdate (&ulMpegCrc, 1, &pcl->c.uc[3]);
            MpegCrcUpdate (&ulMpegCrc, 1, ptr);
        //}

        //pcl->l.ul = (ULONG)(pcl->l.ul) << 8;
        //pcl->c.uc[0] = *ptr;

        TEST_DEBUG( TEST_DBG_CRC, ("SLIP:  char: %02X   ul: %d  MpegCrc: %08X\n", *ptr, ul, ulMpegCrc));

    }

    return ulMpegCrc;
}


//////////////////////////////////////////////////////////////////////////////
VOID
vNabtsUpdateCrc (
    PNAB_STREAM pNabStream,
    UCHAR ucToCopy
    )
//////////////////////////////////////////////////////////////////////////////
{

    PCL pcl = (PCL)&pNabStream->ulLastCrcBytes;


    if (pNabStream->ulCrcBytesIndex++ > 3)
    {
        MpegCrcUpdate (&pNabStream->ulMpegCrc, 1, &pcl->c.uc[3]);
    }

    pcl->l.ul = (ULONG)(pcl->l.ul) << 8;
    pcl->c.uc[0] = ucToCopy;

    #ifdef DUMP_CRC

        TEST_DEBUG( TEST_DBG_CRC, ("SLIP:  char: %02X   ulLastCrcBytes: %08X  MpegCrc: %08X  ulCrcBytesIndex: %d\n",
             ucToCopy, pNabStream->ulLastCrcBytes, pNabStream->ulMpegCrc, pNabStream->ulCrcBytesIndex));

    #endif // DUMP_CRC

}

//////////////////////////////////////////////////////////////////////////////
VOID
ComputeIPChecksum (
    PHeaderIP    pIPHeader
    )
//////////////////////////////////////////////////////////////////////////////
{
    ULONG           Checksum;
    PUCHAR          NextChar;

    pIPHeader->ucChecksumHigh = pIPHeader->ucChecksumLow = 0;
    Checksum = 0;
    for ( NextChar = (PUCHAR) pIPHeader
        ; (NextChar - (PUCHAR) pIPHeader) <= (sizeof(HeaderIP) - 2)
        ; NextChar += 2)
    {
        Checksum += ((ULONG) (NextChar[0]) << 8) + (ULONG) (NextChar[1]);
    }

    Checksum = (Checksum >> 16) + (Checksum & 0xffff);
    Checksum += (Checksum >> 16);
    Checksum = ~Checksum;

    pIPHeader->ucChecksumHigh = (UCHAR) ((Checksum >> 8) & 0xff);
    pIPHeader->ucChecksumLow = (UCHAR) (Checksum & 0xff);
}


//////////////////////////////////////////////////////////////////////////////
//
// Looks in the user's StreamContxList for a matching
// Nabts Group ID.
// It uses it if it finds one - otherwise we allocate one.
//
NTSTATUS
ntFindNabtsStream(
    PSLIP_FILTER pFilter,
    PNABTSFEC_BUFFER pNabData,
    PNAB_STREAM *ppNabStream
    )
//////////////////////////////////////////////////////////////////////////////
{
    NTSTATUS status  = STATUS_SUCCESS;
    PLIST_ENTRY pFlink;
    PNAB_STREAM pNabStream = NULL;


    //
    // Check to see if the groupid is within the valid range.
    //
    if(pNabData->groupID > NABTSIP_GROUP_ID_RANGE_HI )
    {
        status = STATUS_INVALID_PARAMETER;
        ASSERT(status == STATUS_INVALID_PARAMETER);
        *ppNabStream = NULL;
        return status;
    }

    //
    // Go through the list one stream context at a time.
    //

    for (pFlink = pFilter->StreamContxList.Flink;
         pFlink != &pFilter->StreamContxList;
         pFlink = pFlink->Flink)
    {
        PNAB_STREAM pNSTemp;

        pNSTemp = CONTAINING_RECORD (pFlink, NAB_STREAM, Linkage);
        if(pNSTemp->groupID == pNabData->groupID)
        {
            pNabStream = pNSTemp;

            //
            // Mark the stream as having been used.  This flag is checked
            // in vCheckNabStreamLife.
            //
            pNabStream->fUsed = TRUE;

            break;
        }
    }

    //
    // if we did not find a stream then create one.
    //
    if (pNabStream == NULL)
    {
        status = ntCreateNabStreamContext(pFilter, pNabData->groupID, &pNabStream);
        if(status == STATUS_SUCCESS)
        {
            #if DBG

            TEST_DEBUG( TEST_DBG_NAB, ("SLIP Creating new NAB_STREAM for data...Group ID: %08X\n", pNabStream->groupID));

            #ifdef TEST_DBG_NAB
                DumpNabStream (pNabStream);
            #endif

            #endif //DBG
        }
    }
    else
    {
        TEST_DEBUG( TEST_DBG_NAB, ("SLIP Using existing NAB_STREAM for data.  Group ID: %08X\n", pNabStream->groupID));
        #ifdef TEST_DBG_NAB
            DumpNabStream (pNabStream);
        #endif
    }

    *ppNabStream = pNabStream;

    return status;
}

///////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
GetOutputSrbForStream (
    PSLIP_FILTER pFilter,
    PNAB_STREAM  pNabStream
    )
///////////////////////////////////////////////////////////////////////////////////////
{
    NTSTATUS status                   = STATUS_INSUFFICIENT_RESOURCES;
    PKSSTREAM_HEADER  pStreamHdr      = NULL;
    PHW_STREAM_REQUEST_BLOCK pSrbIPv4 = NULL;


    if (QueueRemove( &pSrbIPv4, &pFilter->IpV4StreamDataSpinLock, &pFilter->IpV4StreamDataQueue))
    {
        //
        // Save the SRB References.
        //

        pNabStream->pSrb = pSrbIPv4;
        pStreamHdr = pSrbIPv4->CommandData.DataBufferArray;

        TEST_DEBUG (TEST_DBG_WRITE_DATA, ("SLIP: OUTPUT SRB...FrameExtent: %d  DataUsed: %d  Data: %08X\n",
                                          pStreamHdr->FrameExtent,
                                          pStreamHdr->DataUsed,
                                          pStreamHdr->Data
                                          ));
        status = STATUS_SUCCESS;

    }
    return status;
}



//////////////////////////////////////////////////////////////////////////////
void
UpdateMACHeader (
    PHeader802_3 pMAC,
    PHeaderIP    pIP
    )
//////////////////////////////////////////////////////////////////////////////
{
    ASSERT (pMAC);
    ASSERT (pIP);

    //
    // Now we copy the low order 23 bits of the IP destination addresss to the 802.3 Header
    //
    if (pMAC && pIP)
    {
        pMAC->DestAddress [3] = pIP->ipaddrDst.ucHighLSB & 0x7F;
        pMAC->DestAddress [4] = pIP->ipaddrDst.ucLowMSB  & 0xFF;
        pMAC->DestAddress [5] = pIP->ipaddrDst.ucLowLSB  & 0xFF;
    }
}



//////////////////////////////////////////////////////////////////////////////
void
vRebuildIPPacketHeader (
    PNAB_STREAM pNabStream
    )
//////////////////////////////////////////////////////////////////////////////
{
    PNAB_HEADER_CACHE pPacketHeader;
    PNAB_HEADER_CACHE pSavedHeader = &pNabStream->NabHeader[pNabStream->ulIPStreamIndex];
    PUCHAR psz;

    //
    // Copy the uncompressed packet header to the buffer.
    //

    //The following assert never fails since all of parameters are constants. So RtlCopyMemory is safe
   ASSERT(sizeof(Header802_3)+sizeof(HeaderIP) + sizeof(HeaderUDP)<MAX_STREAM_PAYLOAD);

    RtlCopyMemory((pNabStream->pszBuffer + sizeof(Header802_3)),
                  ((PUCHAR)&pNabStream->NabHeader[pNabStream->ulIPStreamIndex]),
                  sizeof(HeaderIP) + sizeof(HeaderUDP));

    //
    // Copy the compressed header items into the uncompressed packet header.
    //

    pPacketHeader = (PNAB_HEADER_CACHE)pNabStream->pszBuffer + sizeof(Header802_3);

    //
    // Copy IP Packet ID.
    //
    psz = (PUCHAR)pNabStream->NabCState[pNabStream->ulIPStreamIndex].usrgCompressedHeader;

   //NabCState[pNabStream->ulIPStreamIndex].usrgCompressedHeader is USHORT and RtlCopyMemory copies discrete number of bytes
   //No vulnerability is seen in the RtlCopyMemory blocks below
       
    RtlCopyMemory(&pPacketHeader->ipHeader.ucIDHigh, psz, IP_ID_SIZE);

    //
    // Copy UDP Check Sum.
    //
    psz = (PUCHAR)(pNabStream->NabCState[pNabStream->ulIPStreamIndex].usrgCompressedHeader + 2);

   
    RtlCopyMemory(&pPacketHeader->udpHeader.ucChecksumHigh, psz, UDP_CHKSUM_SIZE);

}

//////////////////////////////////////////////////////////////////////////////
__inline VOID
CopyNabToPacketNew(
    UCHAR               uchToCopy,
    PNAB_STREAM         pNabStream,
    PSLIP_FILTER        pFilter
    )
//////////////////////////////////////////////////////////////////////////////
{
    if (pNabStream->ulOffset >= pNabStream->ulcbSize)
    {
        //
        //  The packet is too big.  Resync the SLIP stream.
        //
        pNabStream->ulFrameState = NABTS_FS_SYNC;
        pFilter->Stats.ulTotalSlipFramesTooBig += 1;
    }
    else
    {
        ULONG ulIPStream = pNabStream->ulIPStreamIndex;

        if(pNabStream->NabCState[ulIPStream].usCompressionState == NABTS_CS_UNCOMPRESSED)
        {
            //
            //  Copy the byte to the actual Packet buffer.
            //

            pNabStream->pszBuffer[pNabStream->ulOffset] = uchToCopy;

            //
            // Update the MpegCrc check.
            //

            vNabtsUpdateCrc (pNabStream, uchToCopy);

            //
            // If we are collecting the IP Header data then copy it to
            // a buffer so that we can use it later for uncompression.
            //
            if(pNabStream->ulOffset < sizeof (Header802_3) + sizeof(HeaderIP) + sizeof(HeaderUDP))
            {
                PUCHAR psz = (PUCHAR)&pNabStream->NabHeader[pNabStream->ulIPStreamIndex].ipHeader;
                *(psz + pNabStream->ulOffset - sizeof (Header802_3)) = uchToCopy;
            }

            //
            // Increment the data pointer.
            //

            pNabStream->ulOffset++;
        }
        else if(pNabStream->NabCState[ulIPStream].usCompressionState == NABTS_CS_COMPRESSED)
        {
            if(pNabStream->NabCState[ulIPStream].uscbHeaderOffset <
               pNabStream->NabCState[ulIPStream].uscbRequiredSize)
            {
                PUCHAR psz = (PUCHAR)pNabStream->NabCState[ulIPStream].usrgCompressedHeader;

                *(psz + pNabStream->NabCState[ulIPStream].uscbHeaderOffset++) = uchToCopy;

                //
                // Update the MpegCrc check.
                //

                vNabtsUpdateCrc (pNabStream, uchToCopy);

                if(pNabStream->NabCState[ulIPStream].uscbHeaderOffset ==
                   pNabStream->NabCState[ulIPStream].uscbRequiredSize)
                {

                    ASSERT(pNabStream->ulOffset == sizeof(Header802_3));
                    //
                    // Use the saved IP Packet header and the compressed IP Header
                    // to rebuil the IP Header to send up.
                    //

                    vRebuildIPPacketHeader( pNabStream );

                    //
                    // Set the buffer offset past the end of the IP/UDP headers
                    // We should start coping data now.
                    //

                    pNabStream->ulOffset += (sizeof(HeaderIP) + sizeof(HeaderUDP));

                }
            }
            else
            {
                //
                // We already have the header rebuilt.  Now copy the payload.
                //

                pNabStream->pszBuffer[pNabStream->ulOffset++] = uchToCopy;


                //
                // Update the MpegCrc check.
                //

                vNabtsUpdateCrc (pNabStream, uchToCopy);
            }
        }
        else
        {
            DbgBreakPoint();
        }
    }
}

//////////////////////////////////////////////////////////////////////////////
__inline VOID
CopyNabToPacketOld(
    UCHAR               uchToCopy,
    PNAB_STREAM         pNabStream,
    PSLIP_FILTER        pFilter

    )
//////////////////////////////////////////////////////////////////////////////
{
    if (pNabStream->ulOffset >= pNabStream->ulcbSize)
    {
        //
        //  The packet is too big.  Resync the SLIP stream.
        //

        pNabStream->ulFrameState = NABTS_FS_SYNC;
        pFilter->Stats.ulTotalSlipFramesTooBig += 1;
    }
    else
    {
        //  Copy the byte.
        //
        pNabStream->pszBuffer[pNabStream->ulOffset++] = uchToCopy;
    }
}


//////////////////////////////////////////////////////////////////////////////
__inline VOID
CopyNabToPacket(
    UCHAR               uchToCopy,
    PNAB_STREAM         pNabStream,
    PSLIP_FILTER        pFilter

    )
//////////////////////////////////////////////////////////////////////////////
{


    if(pNabStream->ulProtoID == PROTO_ID)
    {
        CopyNabToPacketNew(uchToCopy, pNabStream, pFilter);
    }
    else
    {
        CopyNabToPacketOld(uchToCopy, pNabStream, pFilter);
    }
}


//////////////////////////////////////////////////////////////////////////////
NTSTATUS
ntNabtsRecv(
    PSLIP_FILTER pFilter,
    PNABTSFEC_BUFFER pNabData
    )
//////////////////////////////////////////////////////////////////////////////
{
    NTSTATUS status              = STATUS_SUCCESS;
    PNAB_STREAM pNabStream       = NULL;
    PUCHAR pszNabIn              = NULL;
    PKSSTREAM_HEADER  pStreamHdr = NULL;
    LARGE_INTEGER liCurrentTime  = {0};
    LARGE_INTEGER liTimeToLive   = {0};
    LARGE_INTEGER liStatusInterval   = {0};
    KIRQL Irql                   = {0};
    ULONG ulIPStream             = 0;
    ULONG ulNabIn                = 0;


    TEST_DEBUG( TEST_DBG_RECV, ("\nEntering - ntNabtsRecv\n"));

    //
    // Get the current system time.
    //
    KeQuerySystemTime(&liCurrentTime);

    //
    // See if it is time the check for dead GroupIDs and Streams.
    // Get a lock so no one else is modifying the Stream list while we are looking.
    //
    KeAcquireSpinLock(&pFilter->StreamUserSpinLock, &Irql);


    liTimeToLive.QuadPart = NAB_STREAM_LIFE;
    if( (LONGLONG)(liCurrentTime.QuadPart - pFilter->liLastTimeChecked.QuadPart) > liTimeToLive.QuadPart)
    {
        vCheckNabStreamLife( pFilter );
        pFilter->liLastTimeChecked = liCurrentTime;
    }

    //
    // Find the Stream Context.
    //
    status = ntFindNabtsStream( pFilter, pNabData, &pNabStream );
    if(status != STATUS_SUCCESS)
    {
        ASSERT( status == STATUS_SUCCESS);
        pFilter->Stats.ulTotalSlipBuffersDropped += 1;
        KeReleaseSpinLock(&pFilter->StreamUserSpinLock, Irql);
        goto ret;
    }

    KeReleaseSpinLock(&pFilter->StreamUserSpinLock, Irql);


    liStatusInterval.QuadPart = NAB_STATUS_INTERVAL;
    if( (LONGLONG)(liCurrentTime.QuadPart - pFilter->liLastTimeStatsDumped.QuadPart) > liStatusInterval.QuadPart)
    {
        pFilter->liLastTimeStatsDumped = liCurrentTime;
        TEST_DEBUG (TEST_DBG_INFO, ("      "));
        TEST_DEBUG (TEST_DBG_INFO, ("SLIP: ulTotalDataSRBWrites: %d\n.", pFilter->Stats.ulTotalDataSRBWrites));
        TEST_DEBUG (TEST_DBG_INFO, ("      ulTotalBadPinSRBWrites: %d\n.", pFilter->Stats.ulTotalBadPinSRBWrites));
        TEST_DEBUG (TEST_DBG_INFO, ("      ulTotalDataSRBReads: %d\n.", pFilter->Stats.ulTotalDataSRBReads));
        TEST_DEBUG (TEST_DBG_INFO, ("      ulTotalBadPinSRBReads: %d\n.", pFilter->Stats.ulTotalBadPinSRBReads));
        TEST_DEBUG (TEST_DBG_INFO, ("      ulTotalSlipBuffersReceived: %d\n.", pFilter->Stats.ulTotalSlipBuffersReceived));
        TEST_DEBUG (TEST_DBG_INFO, ("      ulTotalSlipBuffersDropped: %d\n.", pFilter->Stats.ulTotalSlipBuffersDropped));
        TEST_DEBUG (TEST_DBG_INFO, ("      ulTotalSlipZeroLengthBuffers: %d\n.", pFilter->Stats.ulTotalSlipZeroLengthBuffers));
        TEST_DEBUG (TEST_DBG_INFO, ("      ulTotalSlipBytesReceived: %d\n.", pFilter->Stats.ulTotalSlipBytesReceived));
        TEST_DEBUG (TEST_DBG_INFO, ("      ulTotalSlipBytesDropped: %d\n.", pFilter->Stats.ulTotalSlipBytesDropped));
        TEST_DEBUG (TEST_DBG_INFO, ("      ulTotalSlipFramesReceived: %d\n.", pFilter->Stats.ulTotalSlipFramesReceived));
        TEST_DEBUG (TEST_DBG_INFO, ("      ulTotalSlipOldProtoFramesStarted: %d\n.", pFilter->Stats.ulTotalSlipOldProtoFramesStarted));
        TEST_DEBUG (TEST_DBG_INFO, ("      ulTotalSlipNewProtoFramesStarted: %d\n.", pFilter->Stats.ulTotalSlipNewProtoFramesStarted));
        TEST_DEBUG (TEST_DBG_INFO, ("      ulTotalSlipFramesIncomplete: %d\n.", pFilter->Stats.ulTotalSlipFramesIncomplete));
        TEST_DEBUG (TEST_DBG_INFO, ("      ulTotalSlipFramesBadCRC: %d\n.", pFilter->Stats.ulTotalSlipFramesBadCRC));
        TEST_DEBUG (TEST_DBG_INFO, ("      ulTotalSlipFramesTooBig: %d\n.", pFilter->Stats.ulTotalSlipFramesTooBig));
        TEST_DEBUG (TEST_DBG_INFO, ("      ulTotalSlipFramesTooSmall: %d\n.", pFilter->Stats.ulTotalSlipFramesTooSmall));
        TEST_DEBUG (TEST_DBG_INFO, ("      ulTotalIPPacketsFound: %d\n.", pFilter->Stats.ulTotalIPPacketsFound));
        TEST_DEBUG (TEST_DBG_INFO, ("      ulTotalIPBytesFound: %d\n.", pFilter->Stats.ulTotalIPBytesFound));
        TEST_DEBUG (TEST_DBG_INFO, ("      ulTotalIPPacketsSent: %d\n.", pFilter->Stats.ulTotalIPPacketsSent));
        TEST_DEBUG (TEST_DBG_INFO, ("      ulTotalIPBytesSent: %d\n.", pFilter->Stats.ulTotalIPBytesSent));
        TEST_DEBUG (TEST_DBG_INFO, ("      ulTotalIPPacketsTooBig: %d\n.", pFilter->Stats.ulTotalIPPacketsTooBig));
        TEST_DEBUG (TEST_DBG_INFO, ("      ulTotalIPPacketsTooSmall: %d\n.", pFilter->Stats.ulTotalIPPacketsTooSmall));
        TEST_DEBUG (TEST_DBG_INFO, ("      ulTotalIPPacketsDropped: %d\n.", pFilter->Stats.ulTotalIPPacketsDropped));
        TEST_DEBUG (TEST_DBG_INFO, ("      ulTotalIPBytesDropped: %d\n.", pFilter->Stats.ulTotalIPBytesDropped));
        TEST_DEBUG (TEST_DBG_INFO, ("      ulTotalNabStreamsCreated: %d\n.", pFilter->Stats.ulTotalNabStreamsCreated));
        TEST_DEBUG (TEST_DBG_INFO, ("      ulTotalNabStreamsTimedOut: %d\n.", pFilter->Stats.ulTotalNabStreamsTimedOut));
        TEST_DEBUG (TEST_DBG_INFO, ("      "));

    }

    //
    // Set the last time used for this stream.
    //

    pNabStream->liLastTimeUsed = liCurrentTime;

    //
    // Get a pointer to the input buffer.  We copy data from this pointer to
    // the output buffer
    //

    pszNabIn = (LPSTR) pNabData->data;

    // Validate the data size and that the start+end of the buffer are accessible
    ASSERT(pNabData->dataSize <= sizeof(pNabData->data) );

    //  What is really needed here is something like "MmIsValidAddress()", but for WDM drivers
    //  These assert just look at the start & end addresses of the buffer w/o regard to values.
    // ASSERT( (*(pszNabIn) + 1 > 0) );
    // ASSERT( (*(pszNabIn+pNabData->dataSize-1) + 1 > 0) );

    for (ulNabIn = pNabData->dataSize; ulNabIn; ulNabIn--, pszNabIn++)
    {
        switch (pNabStream->ulFrameState)
        {

            case NABTS_FS_SYNC:

                switch (*pszNabIn)
                {
                    case FRAME_END:
                        //
                        //  We found the start of frame sync.  Look for the
                        //  protocol character.
                        //
                        TEST_DEBUG( TEST_DBG_RECV, ("SLIP   Found Possible Start of Frame... pszNabIn %08X   ulNabIn: %08X\n", pszNabIn, ulNabIn));
                        pNabStream->ulFrameState = NABTS_FS_SYNC_PROTO;

                        ResetNabStream (pFilter, pNabStream, NULL, NULL, 0);

                        break;
                }
                break;

            case NABTS_FS_SYNC_PROTO:

                switch (*pszNabIn)
                {
                    case PROTO_ID:
                    case PROTO_ID_OLD:

                        TEST_DEBUG( TEST_DBG_RECV, ("SLIP   Found Start of Protocol...Building Packet.... pszNabIn %08X   ulNabIn: %08X\n", pszNabIn, ulNabIn));

                        // Record the stream type.
                        //
                        pNabStream->ulProtoID = *pszNabIn;

                        //  This is our protocol. Setup NAB_STREAM with an output
                        //  data buffer from the output SRB Queue
                        //
                        TEST_DEBUG( TEST_DBG_RECV, ("SLIP Setting Up Output buffer\n"));
                        ResetNabStream( pFilter, pNabStream, NULL, pNabStream->rgBuf, sizeof(pNabStream->rgBuf));

                        //  Copy the 802.3 header template into the frame.  We will replace
                        //  the destination address and protocol on receive.
                        //

                        RtlCopyMemory (pNabStream->pszBuffer, &h802_3Template, sizeof (Header802_3));

                        //  Update buffer offset
                        //
                        pNabStream->ulOffset = sizeof (Header802_3);

                        if(pNabStream->ulProtoID == PROTO_ID)
                        {
                            //
                            // Set the state to check the IP compression.
                            //
                            pFilter->Stats.ulTotalSlipNewProtoFramesStarted += 1;
                            TEST_DEBUG( TEST_DBG_RECV, ("SLIP Protocol ID is Compressed\n"));
                            pNabStream->ulFrameState = NABTS_FS_COMPRESSION;
                        }
                        else
                        {
                            //
                            //  Start collecting data.
                            //
                            pFilter->Stats.ulTotalSlipOldProtoFramesStarted += 1;
                            TEST_DEBUG( TEST_DBG_RECV, ("SLIP Protocol ID is not Compressed\n"));
                            pNabStream->ulFrameState = NABTS_FS_COLLECT;
                        }

                        // Update the MpegCrc check.
                        //
                        vNabtsUpdateCrc( pNabStream, *pszNabIn);

                        break;


                    case FRAME_END:
                        TEST_DEBUG( TEST_DBG_RECV, ("SLIP State is FRAME_END....going to FS_SYNC_PROTO\n"));
                        pNabStream->ulFrameState = NABTS_FS_SYNC_PROTO;
                        break;

                    default:
                        TEST_DEBUG( TEST_DBG_RECV, ("SLIP   Protocol Not Found...ReSyncing... pszNabIn %08X   ulNabIn: %08X\n", pszNabIn, ulNabIn));
                        pNabStream->ulFrameState = NABTS_FS_SYNC;
                        break;
                }
                break;


            case NABTS_FS_COMPRESSION:
            {

                TEST_DEBUG( TEST_DBG_RECV, ("SLIP State is NABTS_FS_COMPRESSION\n"));

                //
                // Get the index to the IP Compression Stream.
                //
                ulIPStream = IP_STREAM_INDEX(*pszNabIn);

                //
                // Check to see if this IP Packet has a compressed header.
                //
                if(!PACKET_COMPRESSED(*pszNabIn))
                {
                     pNabStream->NabCState[ulIPStream].usCompressionState = NABTS_CS_UNCOMPRESSED;
                }
                else if (PACKET_COMPRESSED (*pszNabIn))
                {
                    pNabStream->NabCState[ulIPStream].usCompressionState = NABTS_CS_COMPRESSED;
                    pNabStream->NabCState[ulIPStream].uscbRequiredSize = NORMAL_COMPRESSED_HEADER;
                }

                //
                // Retain the IP Stream Index.
                //
                pNabStream->ulIPStreamIndex = ulIPStream;

                //
                // Set the stats Last Used Time for this stream.
                //
                pNabStream->NabCState[pNabStream->ulIPStreamIndex].liLastUsed = liCurrentTime;

                //
                // Set the IP Header Data Length to zero.
                //
                pNabStream->NabCState[pNabStream->ulIPStreamIndex].uscbHeaderOffset = 0;

                //
                //  Start collecting data.
                //
                pNabStream->ulFrameState = NABTS_FS_COLLECT;

                //
                // Update the MpegCrc check.
                //
                vNabtsUpdateCrc (pNabStream, *pszNabIn);

                break;
            }


            case NABTS_FS_COLLECT:

                switch (*pszNabIn)
                {
                    case FRAME_ESCAPE:
                        //
                        //  We want to escape the next character.
                        //
                        TEST_DEBUG( TEST_DBG_RECV, ("SLIP   NABTS_FS_COLLECT_ESCAPE\n"));
                        pNabStream->ulFrameState = NABTS_FS_COLLECT_ESCAPE;
                        break;

                    case FRAME_END:

                        if (pNabStream->ulOffset >= sizeof(HeaderIP))
                        {
                            PHeaderIP pHeaderIp = (PHeaderIP)(PUCHAR)(pNabStream->pszBuffer + sizeof(Header802_3));
                            PUSHORT pusIpLen = (PUSHORT)&pHeaderIp->ucTotalLenHigh;


                            TEST_DEBUG( TEST_DBG_RECV, ("SLIP   End of Packet Found... pszNabIn %08X   ulNabIn: %08X  ulOffset: %d\n", pszNabIn, ulNabIn, pNabStream->ulOffset));

                            TEST_DEBUG( TEST_DBG_RECV, ("SLIP   ulProtoID %d  ulMpegCrc: %08X  ulLastCrcBytes: %08X  IpLen: %d\n",
                                                        pNabStream->ulProtoID, pNabStream->ulMpegCrc, pNabStream->ulLastCrcBytes, *pusIpLen));


                            //  If header compression is being used, we must
                            //  calculate the IP and UDP lengths and regenerate
                            //  the packet checksums.
                            //
                            if (pNabStream->ulProtoID == PROTO_ID)
                            {
                                PHeaderUDP pHeaderUDP = (PHeaderUDP)(PUCHAR)(pNabStream->pszBuffer + sizeof(Header802_3) + sizeof(HeaderIP));
                                PUSHORT pusUdpLen = (PUSHORT)&pHeaderUDP->ucMsgLenHigh;

                                TEST_DEBUG( TEST_DBG_CRC, ("SLIP:  GroupID: %d Stream CRC: %08X   Calculated CRC: %08X", pNabStream->groupID, pNabStream->ulLastCrcBytes, pNabStream->ulMpegCrc));

                                // All PROTO_ID packets have an MpegCrc on the end.  It is not
                                // part of the IP packet and needs to be stripped off.
                                //
                                pNabStream->ulOffset -= 4;

                                if (pNabStream->NabCState[pNabStream->ulIPStreamIndex].usCompressionState == NABTS_CS_COMPRESSED)
                                {
                                    // We use the ulOffset less the MAC Header and IP Header
                                    // sizes for the UDP Packet length.
                                    //
                                    // Note!  Fragmented UDP datagrams cannot be compressed
                                    //
                                    *pusUdpLen = htons ((USHORT)(pNabStream->ulOffset - sizeof(Header802_3) - sizeof(HeaderIP)));
    
                                    // We use the ulOffset less the MAC Header size for the
                                    // IP Packet length.
                                    //
                                    *pusIpLen = htons ((USHORT)(pNabStream->ulOffset - sizeof(Header802_3)));
    
                                    // Recalculate the IP header Checksum
                                    //
                                    ComputeIPChecksum (pHeaderIp);
                                }

                                //  If the CRC was bad then invalidate
                                //  the IP Checksum
                                //
                                if (pNabStream->ulMpegCrc != pNabStream->ulLastCrcBytes)
                                {
                                    TEST_DEBUG (TEST_DBG_CRC, ("   FAILED*****\n"));
                                    
                                    pFilter->Stats.ulTotalSlipFramesBadCRC += 1;

                                    pHeaderIp->ucChecksumHigh = ~(pHeaderIp->ucChecksumHigh);
                                    pHeaderIp->ucChecksumLow = 0xff;
                                }
                                else
                                {
                                    TEST_DEBUG (TEST_DBG_CRC, ("   PASSED\n"));
                                }
                            }
                            else if (pNabStream->ulProtoID != PROTO_ID_OLD)
                            {
                                TEST_DEBUG( TEST_DBG_RECV, ("SLIP   End of Packet Found....Bad PROTO_ID... pszNabIn %08X   ulNabIn: %08X  ulOffset: %d\n", pszNabIn, ulNabIn, pNabStream->ulOffset));
                                ASSERT(   (pNabStream->ulProtoID == PROTO_ID_OLD)
                                       || (pNabStream->ulProtoID == PROTO_ID)
                                      );
                                ResetNabStream (pFilter, pNabStream, NULL, NULL, 0);
                                pNabStream->ulFrameState = NABTS_FS_SYNC;
                                goto ret;
                            }
                            
                            if (NabtsNtoHs(*pusIpLen) <= NABTSIP_MAX_LOOKAHEAD)
                            {
                                //  Update the MAC address
                                //
                                UpdateMACHeader( 
                                    (PHeader802_3)(pNabStream->pszBuffer), 
                                    pHeaderIp
                                    );

                                // Get an SRB for outputting the data.
                                //
                                status = GetOutputSrbForStream(pFilter, 
                                                               pNabStream
                                                               );
                                if(status != STATUS_SUCCESS)
                                {
                                    ASSERT(status == STATUS_SUCCESS);
                                    pFilter->Stats.ulTotalIPPacketsDropped += 1;
                                    ResetNabStream( pFilter, pNabStream, NULL, NULL, 0);
                                    pNabStream->ulFrameState = NABTS_FS_SYNC;
                                    goto ret;
                                }

                                ASSERT(pNabStream->pSrb);
                                if (!pNabStream->pSrb)
                                {
                                    pFilter->Stats.ulTotalIPPacketsDropped += 1;
                                    ResetNabStream (pFilter, pNabStream, NULL, NULL, 0);
                                    pNabStream->ulFrameState = NABTS_FS_SYNC;
                                    goto ret;
                                }

                                // Get the StreamHdr.
                                //
                                pStreamHdr = (PKSSTREAM_HEADER) pNabStream->pSrb->CommandData.DataBufferArray;
                                ASSERT( pStreamHdr);
                                if (!pStreamHdr)
                                {
                                    pFilter->Stats.ulTotalIPPacketsDropped += 1;
                                    ResetNabStream (pFilter, pNabStream, NULL, NULL, 0);
                                    pNabStream->ulFrameState = NABTS_FS_SYNC;
                                    goto ret;
                                }

                                // If we had a discontinuity, we flag it.
                                //
                                if (pFilter->bDiscontinuity)
                                {
                                    pStreamHdr->OptionsFlags |= KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY;
                                    pFilter->bDiscontinuity = FALSE;
                                }

                                // Copy the data from the rgBuf to the Srb.
                                //
					
                                RtlCopyMemory (pStreamHdr->Data, 
                                               pNabStream->pszBuffer, 
                                               pNabStream->ulOffset
                                               );

                                // Update the datasize field of the Output SRB
                                //
                                pStreamHdr->DataUsed = pNabStream->ulOffset;

                                // Complete the output SRB
                                //
                                pFilter->Stats.ulTotalIPPacketsSent += 1;
                                pNabStream->ulOffset = 0;
                                StreamClassStreamNotification( 
                                    StreamRequestComplete, 
                                    pNabStream->pSrb->StreamObject, 
                                    pNabStream->pSrb
                                    );
                                TEST_DEBUG (TEST_DBG_SRB, ("SLIP: Completed SRB....Ptr %08X  Size %d\n", pStreamHdr->Data, pStreamHdr->DataUsed));

                                TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: StreamRequestComplete on pSrb: %08X\n", pNabStream->pSrb));
                            }
                            else
                            {
                                //  The packet is too big.  Resync the SLIP stream.
                                //
                                pFilter->Stats.ulTotalIPPacketsDropped += 1;
                                pFilter->Stats.ulTotalIPPacketsTooBig += 1;
                                TEST_DEBUG( TEST_DBG_RECV, ("SLIP   End of Packet Found....Packet Too BIG... pszNabIn %08X   ulNabIn: %08X  ulOffset: %d\n", pszNabIn, ulNabIn, pNabStream->ulOffset));
                            }
                        }
                        else
                        {
                            //  The packet is too small.  Resync the SLIP stream.
                            //
                            pFilter->Stats.ulTotalIPPacketsDropped += 1;
                            pFilter->Stats.ulTotalIPPacketsTooSmall += 1;
                            TEST_DEBUG( TEST_DBG_RECV, ("SLIP   End of Packet Found....Packet Too SMALL... pszNabIn %08X   ulNabIn: %08X  ulOffset: %d\n", pszNabIn, ulNabIn, pNabStream->ulOffset));
                        }

                        // Reset state for new packet.
                        //
                        ResetNabStream (pFilter, pNabStream, NULL, NULL, 0);
                        pNabStream->ulFrameState = NABTS_FS_SYNC;
                        break;


                    default:
                        //  Just copy the byte to the NDIS packet.
                        //
                        CopyNabToPacket( *pszNabIn, pNabStream, pFilter);
                        break;

                }
                break;


            case NABTS_FS_COLLECT_ESCAPE:

                pNabStream->ulFrameState = NABTS_FS_COLLECT;

                switch (*pszNabIn)
                {
                    case TRANS_FRAME_ESCAPE:
                        //
                        //  Special way to insert a FRAME_ESCAPE
                        //  character as part of the data.
                        //
                        TEST_DEBUG( TEST_DBG_RECV, ("SLIP   NABTS_FS_COLLECT_ESCAPE....TRANS_FRAME_ESCAPE\n"));
                        CopyNabToPacket( (UCHAR) FRAME_ESCAPE, pNabStream, pFilter);
                        break;


                    case TRANS_FRAME_END:
                        //
                        //  Special way to insert a FRAME_END
                        //  character as part of the data.
                        //
                        TEST_DEBUG( TEST_DBG_RECV, ("SLIP   NABTS_FS_COLLECT_ESCAPE.....TRANS_FRAME_END\n"));
                        CopyNabToPacket( (UCHAR) FRAME_END, pNabStream, pFilter);
                        break;

                    default:
                        //  Any other character that follows FRAME_ESCAPE
                        //  is just inserted into the packet.
                        //
                        CopyNabToPacket( *pszNabIn, pNabStream, pFilter);
                        break;
                }
                break;

            default:
                //
                //  We should never be in an unknown state.
                //
                TEST_DEBUG( TEST_DBG_RECV, ("SLIP   UNKNOWN STATE.....ReSyncing\n"));
                ASSERT( pNabStream->ulFrameState);
                ResetNabStream (pFilter, pNabStream, NULL, NULL, 0);
                pNabStream->ulFrameState = NABTS_FS_SYNC;

                break;
        }

    }

ret:

    TEST_DEBUG( TEST_DBG_RECV, ("SLIP   Completed ntNabtsRecv\n"));
    return status;
}

//////////////////////////////////////////////////////////////////////////////
//
// Create a NAB Stream Context.
//
NTSTATUS
ntCreateNabStreamContext(
    PSLIP_FILTER pFilter,
    ULONG groupID,
    PNAB_STREAM *ppNabStream
    )
//////////////////////////////////////////////////////////////////////////////
{
    NTSTATUS status         = STATUS_SUCCESS;
    PNAB_STREAM pNabStream  = NULL;

    TEST_DEBUG (TEST_DBG_NAB, ("********************************  Creating NAB STREAM for group ID %d\n", groupID));

    //
    // Initialize output paramter
    //
    *ppNabStream = NULL;

    //
    // Allocate a Nab Stream structure.
    //
    status = ntAllocateNabStreamContext (&pNabStream);
    if(status == STATUS_SUCCESS)
    {
        pNabStream->ulType           = (ULONG)NAB_STREAM_SIGNATURE;
        pNabStream->ulSize           = sizeof (NAB_STREAM);
        pNabStream->ulFrameState     = NABTS_FS_SYNC;
        pNabStream->ulMpegCrc        = 0xFFFFFFFF;
        pNabStream->fUsed            = TRUE;
        pNabStream->groupID          = groupID;

        //
        // Add the new Stream Context to the User's Stream Context List.
        //
        InsertTailList (&pFilter->StreamContxList, &pNabStream->Linkage);

        *ppNabStream = pNabStream;
    }

    return status;
}


//////////////////////////////////////////////////////////////////////////////
NTSTATUS
ntAllocateNabStreamContext(
    PNAB_STREAM *ppNabStream
    )
//////////////////////////////////////////////////////////////////////////////
{
    NTSTATUS status         = STATUS_SUCCESS;
    PNAB_STREAM pNabStream  = NULL;

    pNabStream = ExAllocatePool (NonPagedPool, sizeof(NAB_STREAM));

    if (pNabStream == NULL)
    {
        *ppNabStream = NULL;
        return (STATUS_NO_MEMORY);
    }

    RtlZeroMemory (pNabStream, sizeof(NAB_STREAM));

    *ppNabStream = pNabStream;

    return status;
}


//////////////////////////////////////////////////////////////////////////////
VOID
vDestroyNabStreamContext(
   PSLIP_FILTER pFilter,
   PNAB_STREAM pNabStream,
   BOOLEAN fUseSpinLock
   )
//////////////////////////////////////////////////////////////////////////////
{
    KIRQL Irql;

    if(fUseSpinLock)
    {
        //
        // Lock the user.
        //

        KeAcquireSpinLock( &pFilter->StreamUserSpinLock, &Irql);
    }

    //
    // Remove the stream context from the user's list.
    //

    RemoveEntryList (&pNabStream->Linkage);

    if(fUseSpinLock)
    {
        //
        // UnLock the user.
        //

        KeReleaseSpinLock( &pFilter->StreamUserSpinLock, Irql);
    }

    //
    // Free the stream's SRB, if any.
    //
    if (pNabStream->pSrb)
    {
        StreamClassStreamNotification (StreamRequestComplete, pNabStream->pSrb->StreamObject, pNabStream->pSrb);
        TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: StreamRequestComplete on pSrb: %08X\n", pNabStream->pSrb));
        pNabStream->pSrb = NULL;
    }

    //
    // Free the stream context memory.
    //
    TEST_DEBUG (TEST_DBG_NAB, ("Deleting  NAB STREAM for group ID: %d... ", pNabStream->groupID));
    ExFreePool (pNabStream);

}


//////////////////////////////////////////////////////////////////////////////
VOID
vCheckNabStreamLife (
    PSLIP_FILTER pFilter
    )
//////////////////////////////////////////////////////////////////////////////
{
    PNAB_STREAM pNabStream;
    PLIST_ENTRY pFlink;

    TEST_DEBUG( TEST_DBG_RECV, ("Entering - vCheckNabStreamLife - pFilter: %x\n", pFilter));

    //
    // Go through the StreamContextList. Remove any stream context structures that have
    // expired their life span.
    //

    for (pFlink = pFilter->StreamContxList.Flink;
         pFlink != &pFilter->StreamContxList;
         pFlink = pFlink->Flink)
    {
        pNabStream = CONTAINING_RECORD (pFlink, NAB_STREAM, Linkage);

        TEST_DEBUG (TEST_DBG_NAB, ("Checking NAB STREAM life for group ID %d ... ", pNabStream->groupID));

        if (pNabStream->fUsed)
        {
            TEST_DEBUG (TEST_DBG_NAB, ("   USED\n"));
        }
        else
        {
            TEST_DEBUG (TEST_DBG_NAB, ("   NOT USED\n"));
        }


        if(!pNabStream->fUsed)
        {

            //  Point at the previous Stream;

            pFlink = pFlink->Blink;

            //
            // Remove the stream from the User's stream context list.
            //

            //
            // vDestroyNabStreamContext returns the active NDIS Packet (if any) to
            // the adapter's free list, remove the stream context from the user list
            // (if specified) and free the stream context structure memory.
            //

            vDestroyNabStreamContext( pFilter, pNabStream, FALSE);
            pFilter->Stats.ulTotalNabStreamsTimedOut += 1;
        }
        else
        {
            //
            // This flag must be set back to TRUE before the next DPC fires or
            // this stream will be removed.
            //

            pNabStream->fUsed = FALSE;
        }
    }

    TEST_DEBUG ( TEST_DBG_RECV, ("Leaving - vCheckNabStreamLife\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\bda\slip\main.c ===
/////////////////////////////////////////////////////////////////////////////
//
//
// Copyright (c) 1996, 1997  Microsoft Corporation
//
//
// Module Name:
//      test.c
//
// Abstract:
//
//
//
// Author:
//
//      P Porzuczek
//
// Environment:
//
// Revision History:
//
//
//////////////////////////////////////////////////////////////////////////////

//
//
#include <wdm.h>
#include <memory.h>
#include "Main.h"

#if DBG

/////////////////////////////////////////////////////////////////////////////
//
// Default debug mode
//

ULONG TestDebugFlag = TEST_DBG_NONE;

/////////////////////////////////////////////////////////////////////////////
// Debugging definitions
//


//
// Debug tracing defintions
//
#define TEST_LOG_SIZE 256
UCHAR TestLogBuffer[TEST_LOG_SIZE]={0};
ULONG TestLogLoc = 0;

/////////////////////////////////////////////////////////////////////////////
//
// Logging function in debug builds
//
extern VOID
TestLog (
    UCHAR c         // input character
    )
/////////////////////////////////////////////////////////////////////////////
{
    TestLogBuffer[TestLogLoc++] = c;

    TestLogBuffer[(TestLogLoc + 4) % TEST_LOG_SIZE] = '\0';

    if (TestLogLoc >= TEST_LOG_SIZE) {
        TestLogLoc = 0;
    }
}

#else // DBG == 0

ULONG TestDebugFlag = 0;

#endif // DBG

//////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT    pDriverObject,
    IN PUNICODE_STRING   pszuRegistryPath
    )
//////////////////////////////////////////////////////////////////////////////////////
{
    NTSTATUS                        ntStatus = STATUS_SUCCESS;

    //
    // Register the Slip Class binding
    //
    ntStatus = SlipDriverInitialize (pDriverObject,  pszuRegistryPath);
    if (ntStatus != STATUS_SUCCESS)
    {
        goto ret;
    }

ret:

    TEST_DEBUG (TEST_DBG_TRACE, ("Driver Entry complete, ntStatus: %08X\n", ntStatus));

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\bda\slip\mpegcrc.h ===
// Copyright (C) 1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:   mpegcrc.h
//
//  PURPOSE:  header file for a very fast CRC, all in MSB format.
//
//  FUNCTIONS:
//  
//  COMMENTS:
//	    This was written by Stephen Dennis, and it's very very quick.
//
//

#ifndef __bridge_mpegcrc_h
#define __bridge_mpegcrc_h

#ifndef	EXTERN_C
#ifdef	__cplusplus
#define	EXTERN_C extern "C"
#else
#define	EXTERN_C
#endif
#endif

#define	MPEG_CRC_START_VALUE	0xFFFFFFFFUL

EXTERN_C	void	MpegCrcUpdate	(ULONG * crc, UINT length, UCHAR * data);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\bda\slip\main.h ===
//////////////////////////////////////////////////////////////////////////////\
//
//  Copyright (c) 1990  Microsoft Corporation
//
//  Module Name:
//
//     test.h
//
//  Abstract:
//
//     The main header for the NDIS/KS test driver
//
//  Author:
//
//     P Porzuczek
//
//  Environment:
//
//  Notes:
//
//  Revision History:
//
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _MAIN_H
#define _MAIN_H


#if DBG

extern  ULONG TestDebugFlag;

#define TEST_DBG_NONE       0x00000000
#define TEST_DBG_TRACE      0x00000001
#define TEST_DBG_WRITE_DATA 0x00000002
#define TEST_DBG_READ_DATA  0x00000004

#define TEST_DBG_RECV       0x00000008
#define TEST_DBG_SRB        0x00000010
#define TEST_DBG_CRC        0x00000020
#define TEST_DBG_NAB        0x00000040
#define TEST_DBG_BUF        0x00000080
#define TEST_DBG_ASSERT     0x00000100


#define TEST_DBG_DETAIL  0x00001000
#define TEST_DBG_INFO    0x00002000
#define TEST_DBG_WARNING 0x00004000
#define TEST_DBG_ERROR   0x00008000

#ifdef DEBUG_EXTRAS
#define TEST_DEBUG(_Trace, _Msg)                 \
{                                               \
        __int64                 llTime = 0;             \
        ULONG                   ulTime = 0;                     \
        NdisGetCurrentSystemTime ((PLARGE_INTEGER)&llTime);     \
        ulTime = (ULONG) (llTime >> 2);         \
    if (_Trace & TestDebugFlag)                  \
    {                                           \
        DbgPrint ("%04X %08X %-10.10s %4d  ", ulTime & 0xffff, _Trace, &__FILE__[2], __LINE__); \
        DbgPrint _Msg;                          \
    }                                           \
}

#else

#define TEST_DEBUG(_Trace, _Msg)                 \
{                                               \
    if (_Trace & TestDebugFlag)                  \
    {                                           \
        DbgPrint _Msg;                          \
    }                                           \
}

#endif  // DEBUG_EXTRAS

#define IF_TESTDEBUG(f) if (TestDebugFlag & (f))

#define TEST_DEBUG_LOUD               0x00010000  // debugging info
#define TEST_DEBUG_VERY_LOUD          0x00020000  // excessive debugging info
#define TEST_DEBUG_LOG                0x00040000  // enable Log
#define TEST_DEBUG_CHECK_DUP_SENDS    0x00080000  // check for duplicate sends
#define TEST_DEBUG_TRACK_PACKET_LENS  0x00100000  // track directed packet lens
#define TEST_DEBUG_WORKAROUND1        0x00200000  // drop DFR/DIS packets
#define TEST_DEBUG_CARD_BAD           0x00400000  // dump data if CARD_BAD
#define TEST_DEBUG_CARD_TESTS         0x00800000  // print reason for failing


//
// Macro for deciding whether to print a lot of debugging information.
//
#define IF_LOUD(A) IF_TESTDEBUG( TEST_DEBUG_LOUD ) { A }
#define IF_VERY_LOUD(A) IF_TESTDEBUG( TEST_DEBUG_VERY_LOUD ) { A }


//
// Whether to use the Log buffer to record a trace of the driver.
//
#define IF_LOG(A) IF_TESTDEBUG( TEST_DEBUG_LOG ) { A }
extern VOID TESTLog(UCHAR);

//
// Whether to do loud init failure
//
#define IF_INIT(A) A

//
// Whether to do loud card test failures
//
#define IF_TEST(A) IF_TESTDEBUG( TEST_DEBUG_CARD_TESTS ) { A }

#else

extern  ULONG TestDebugFlag;


#define TEST_NONE
#define TEST_FUNCTIONS
#define TEST_COMMANDS
#define TEST_CONNECTIONS
#define TEST_SCIDS
#define TEST_LIST_ALLOCS
#define TEST_POOL
#define TEST_INDICATES
#define TEST_ALLOCATION


#define TEST_DEBUG(_Trace, _Msg)

#define IF_TESTDEBUG(f)

#define TEST_DEBUG_LOUD
#define TEST_DEBUG_VERY_LOUD
#define TEST_DEBUG_LOG
#define TEST_DEBUG_CHECK_DUP_SENDS
#define TEST_DEBUG_TRACK_PACKET_LENS
#define TEST_DEBUG_WORKAROUND1
#define TEST_DEBUG_CARD_BAD
#define TEST_DEBUG_CARD_TESTS


//
// This is not a debug build, so make everything quiet.
//
#define IF_LOUD(A)
#define IF_VERY_LOUD(A)
#define IF_LOG(A)
#define IF_INIT(A)
#define IF_TEST(A)

#endif // DBG


NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT    pDriverObject,
    IN PUNICODE_STRING   pszuRegistryPath);


VOID
SlipFreeMemory (
    PVOID pvToFree,
    ULONG ulSize
    );

NTSTATUS
SlipAllocateMemory (
    PVOID  *ppvAllocated,
    ULONG   ulcbSize
    );


NTSTATUS
SlipDriverInitialize (
    IN PDRIVER_OBJECT    DriverObject,
    IN PUNICODE_STRING   RegistryPath
    );

#endif // _MAIN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\bda\slip\slip.h ===
/////////////////////////////////////////////////////////////////////////////
//
//
// Copyright (c) 1996, 1997  Microsoft Corporation
//
//
// Module Name:
//      slip.h
//
// Abstract:
//
//
// Author:
//
//      P Porzuczek
//
// Environment:
//
// Revision History:
//
//
//////////////////////////////////////////////////////////////////////////////

#ifndef _SLIP_H_
#define _SLIP_H_

#define ENTRIES(a)  (sizeof(a)/sizeof(*(a)))

///////////////////////////////////////////////////////////////////////////////
//
//
#define SLIPNAME            "SLIP"
#define SLIPNAMEUNICODE    L"SLIP"

///////////////////////////////////////////////////////////////////////////////
//
// This defines the name of the WMI device that manages service IOCTLS
//
#define CodecDeviceName   (L"\\\\.\\" SLIPNAMEUNICODE)
#define CodecSymbolicName (L"\\DosDevices\\" SLIPNAMEUNICODE)


///////////////////////////////////////////////////////////////////////////////
//
//
typedef enum
{
    SLIP_STREAM = 0,
    SLIP_IPV4,

} SLIP_STREAMS;

///////////////////////////////////////////////////////////////////////////////
//
// The MAX_STREAM_COUNT value must be equal to DRIVER_STREAM_COUNT
// This particular value must be defined here to avoid circular references
//
#define MAX_STREAM_COUNT    DRIVER_STREAM_COUNT

///////////////////////////////////////////////////////////////////////////////
//
// We manage multiple instances of each pin up to this limit
//
#define MAX_PIN_INSTANCES   8
#define BIT(n)              (1L<<(n))
#define BITSIZE(v)          (sizeof(v)*8)
#define SETBIT(array,n)     (array[n/BITSIZE(*array)] |= BIT(n%BITSIZE(*array)))
#define CLEARBIT(array,n)   (array[n/BITSIZE(*array)] &= ~BIT(n%BITSIZE(*array)))



/////////////////////////////////////////////////////////////////////////////
//
//
//
typedef NTSTATUS (*QUERY_INTERFACE) (PVOID pvContext);
typedef ULONG    (*ADD_REF) (PVOID pvContext);
typedef ULONG    (*RELEASE) (PVOID pvContext);



/////////////////////////////////////////////////////////////////////////////
//
//
//
typedef struct _STATS_
{
    ULONG ulTotalDataSRBWrites;
    ULONG ulTotalBadPinSRBWrites;
    ULONG ulTotalDataSRBReads;
    ULONG ulTotalBadPinSRBReads;

    ULONG ulTotalSlipBuffersReceived;
    ULONG ulTotalSlipBuffersDropped;
    ULONG ulTotalSlipZeroLengthBuffers;
    ULONG ulTotalSlipBytesReceived;
    ULONG ulTotalSlipBytesDropped;
    ULONG ulTotalSlipFramesReceived;
    ULONG ulTotalSlipOldProtoFramesStarted;
    ULONG ulTotalSlipNewProtoFramesStarted;
    ULONG ulTotalSlipFramesIncomplete;
    ULONG ulTotalSlipFramesBadCRC;
    ULONG ulTotalSlipFramesTooBig;
    ULONG ulTotalSlipFramesTooSmall;

    ULONG ulTotalIPPacketsFound;
    ULONG ulTotalIPBytesFound;
    ULONG ulTotalIPPacketsSent;
    ULONG ulTotalIPBytesSent;
    ULONG ulTotalIPPacketsTooBig;
    ULONG ulTotalIPPacketsTooSmall;
    ULONG ulTotalIPPacketsDropped;
    ULONG ulTotalIPBytesDropped;

    ULONG ulTotalNabStreamsCreated;
    ULONG ulTotalNabStreamsTimedOut;

} STATS, *PSTATS;


/////////////////////////////////////////////////////////////////////////////
//
//
//
typedef struct
{
    QUERY_INTERFACE          QueryInterface;
    ADD_REF                  AddRef;
    RELEASE                  Release;

} FILTER_VTABLE, *PFILTER_VTABLE;


/////////////////////////////////////////////////////////////////////////////
//
//
// definition of the full HW device extension structure This is the structure
// that will be allocated in HW_INITIALIZATION by the stream class driver
// Any information that is used in processing a device request (as opposed to
// a STREAM based request) should be in this structure.  A pointer to this
// structure will be passed in all requests to the minidriver. (See
// HW_STREAM_REQUEST_BLOCK in STRMINI.H)
//
typedef struct _SLIP_FILTER_
{

    LIST_ENTRY                          AdapterSRBQueue;
    KSPIN_LOCK                          AdapterSRBSpinLock;
    BOOLEAN                             bAdapterQueueInitialized;

    //
    //
    //
    BOOLEAN                             bInitializationComplete;

    //
    // Statistics
    //
    STATS                               Stats;

    //
    //
    //
    PDEVICE_OBJECT                      DeviceObject;

    //
    //
    //
    PDRIVER_OBJECT                      DriverObject;

    //
    //
    //
    PFILTER_VTABLE                      lpVTable;

    //
    //
    //
    ULONG                               ulRefCount;

    //
    //
    //
    PVOID                               pStream [2][1];

    //
    //
    //
    ULONG                               ulActualInstances [2];   // Count of instances per stream

    //
    //
    //
    KSPIN_LOCK                          IpV4StreamDataSpinLock; // Data queue spin lock
    LIST_ENTRY                          IpV4StreamDataQueue;    // Stream data queue

    KSPIN_LOCK                          StreamControlSpinLock;  // Command queue spin lock
    LIST_ENTRY                          StreamControlQueue;     // Stream command queue

    KSPIN_LOCK                          StreamDataSpinLock;     // Data queue spin lock
    LIST_ENTRY                          StreamDataQueue;        // Stream data queue

    //
    //
    //
    KSPIN_LOCK                          StreamUserSpinLock;
    LIST_ENTRY                          StreamContxList;
    LARGE_INTEGER                       liLastTimeChecked;
    LARGE_INTEGER                       liLastTimeStatsDumped;

    BOOLEAN                             bDiscontinuity;

} SLIP_FILTER, *PSLIP_FILTER;

/////////////////////////////////////////////////////////////////////////////
//
// this structure is our per stream extension structure.  This stores
// information that is relevant on a per stream basis.  Whenever a new stream
// is opened, the stream class driver will allocate whatever extension size
// is specified in the HwInitData.PerStreamExtensionSize.
//

typedef struct _STREAM_
{
    PSLIP_FILTER                          pFilter;
    PHW_STREAM_OBJECT	  	 pStreamObject;          // For timer use
    KSSTATE                                 KSState;                // Run, Stop, Pause
    ULONG                                    ulStreamInstance;       // 0..NumberOfPossibleInstances-1
    KSDATAFORMAT                      OpenedFormat;           // Based on the actual open request.
    KSDATARANGE                        MatchedFormat;
    ULONG                                    Type;                   // type of this structure
    ULONG                                    Size;                   // size of this structure
    KSPIN_LOCK				 KSStateSpinLock;

} STREAM, *PSTREAM;

///////////////////////////////////////////////////////////////////////////////
//
// This structure is our per SRB extension, and carries the forward and backward
// links for the pending SRB queue.
//
typedef struct _SRB_EXTENSION
{
    LIST_ENTRY                      ListEntry;
    PHW_STREAM_REQUEST_BLOCK        pSrb;

} SRB_EXTENSION, *PSRB_EXTENSION;


//////////////////////////////////////////////////////////////////////////////
//
// the following section defines prototypes for the minidriver initialization
// routines
//

BOOLEAN
CodecInitialize (
    IN OUT PHW_STREAM_REQUEST_BLOCK pSrb
    );


BOOLEAN
CodecUnInitialize(
    PHW_STREAM_REQUEST_BLOCK pSrb
    );


BOOLEAN
CodecQueryUnload (
    PHW_STREAM_REQUEST_BLOCK pSrb
    );      // Not implemented currently

BOOLEAN
HwInterrupt (
    IN PSLIP_FILTER pFilter
    );

VOID
CodecStreamInfo(
    PHW_STREAM_REQUEST_BLOCK pSrb
    );

VOID
CodecOpenStream(
    PHW_STREAM_REQUEST_BLOCK pSrb
    );

VOID
CodecCloseStream(
    PHW_STREAM_REQUEST_BLOCK pSrb
    );

VOID STREAMAPI
CodecReceivePacket(
    IN PHW_STREAM_REQUEST_BLOCK Srb
    );

VOID STREAMAPI
CodecCancelPacket(
    IN PHW_STREAM_REQUEST_BLOCK Srb
    );

VOID STREAMAPI
CodecTimeoutPacket(
    IN PHW_STREAM_REQUEST_BLOCK Srb
    );

VOID STREAMAPI
CodecGetProperty(
    IN PHW_STREAM_REQUEST_BLOCK Srb
    );

VOID STREAMAPI
CodecSetProperty(
    IN PHW_STREAM_REQUEST_BLOCK Srb
    );

BOOL
CodecVerifyFormat(
    IN KSDATAFORMAT *pKSDataFormat,
    UINT StreamNumber,
    PKSDATARANGE pMatchedFormat
    );

BOOL
CodecFormatFromRange(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    );

void
CompleteStreamSRB (
    IN PHW_STREAM_REQUEST_BLOCK pSrb,
    STREAM_MINIDRIVER_STREAM_NOTIFICATION_TYPE NotificationType1,
    BOOL fUseNotification2,
    STREAM_MINIDRIVER_STREAM_NOTIFICATION_TYPE NotificationType2
    );

void
CompleteDeviceSRB (
    IN PHW_STREAM_REQUEST_BLOCK pSrb,
    IN STREAM_MINIDRIVER_DEVICE_NOTIFICATION_TYPE NotificationType,
    BOOL fReadyForNext
    );

/////////////////////////////////////////////////////////////////////////////////////
//
// SRB Queue Management functions
//

BOOL STREAMAPI
QueueAdd(
    IN PHW_STREAM_REQUEST_BLOCK,
    IN PKSPIN_LOCK,
    IN PLIST_ENTRY
    );

BOOL STREAMAPI
QueueRemove(
    IN OUT PHW_STREAM_REQUEST_BLOCK *,
    IN PKSPIN_LOCK,
    IN PLIST_ENTRY
    );


BOOL STREAMAPI
QueueRemoveSpecific(
    IN PHW_STREAM_REQUEST_BLOCK,
    IN PKSPIN_LOCK,
    IN PLIST_ENTRY
    );

BOOL STREAMAPI
QueueEmpty(
    IN PKSPIN_LOCK,
    IN PLIST_ENTRY
    );

VOID
STREAMAPI
CodecReceivePacket(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    );

BOOLEAN
CodecInitialize (
    IN OUT PHW_STREAM_REQUEST_BLOCK pSrb
    );

VOID
STREAMAPI
CodecCancelPacket(
    PHW_STREAM_REQUEST_BLOCK pSrb
    );

VOID
STREAMAPI
CodecTimeoutPacket(
    PHW_STREAM_REQUEST_BLOCK pSrb
    );


BOOL
CompareGUIDsAndFormatSize(
    IN PKSDATARANGE pDataRange1,
    IN PKSDATARANGE pDataRange2,
    BOOLEAN bCheckSize
    );

BOOL
CompareStreamFormat (
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    );

BOOLEAN
VerifyFormat(
    IN KSDATAFORMAT *pKSDataFormat,
    UINT StreamNumber,
    PKSDATARANGE pMatchedFormat
    );

VOID
OpenStream (
    PHW_STREAM_REQUEST_BLOCK pSrb
    );

VOID
CloseStream (
    PHW_STREAM_REQUEST_BLOCK pSrb
    );

VOID
STREAMAPI
ReceiveDataPacket (
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    );

VOID
STREAMAPI
ReceiveCtrlPacket(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    );


VOID
SlipSetState(
    PHW_STREAM_REQUEST_BLOCK pSrb
    );

VOID
SlipGetState(
    PHW_STREAM_REQUEST_BLOCK pSrb
    );


#endif  // _SLIP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\bda\slip\slip.c ===
////////////////////////////////////////////////////////////////////////////
//
//
// Copyright (c) 1996, 1997  Microsoft Corporation
//
//
// Module Name:
//      slip.c
//
// Abstract:
//
//
// Author:
//
//      P Porzuczek
//
// Environment:
//
// Revision History:
//
//
//////////////////////////////////////////////////////////////////////////////

#include <wdm.h>
#include <strmini.h>
#include <ksmedia.h>
#include <BdaTypes.h>
#include <BdaMedia.h>

#include "Slip.h"
#include "SlipMedia.h"
#include "SlipStream.h"
#include "Recv.h"

#include "Main.h"
#include "filter.h"

//////////////////////////////////////////////////////////////////////////////
//
//
VOID
DumpDataFormat (
    PKSDATAFORMAT   pF
    );



typedef struct _IPHeader {
   UCHAR       ucIPVerLen;       // Version and length.
   UCHAR       ucIPTos;          // Type of service.
   USHORT      usLength;         // Total length of datagram.
   USHORT      usIPId;           // Identification.
   USHORT      usIPOffset;       // Flags and fragment offset.
   UCHAR       ucIPTtl;          // Time to live.
   UCHAR       ucProtocol  ;     // Protocol.
   USHORT      usChkSum;         // Header checksum.
   UCHAR       ulIPSrc [4];      // Source address.
   UCHAR       ulIPDst [4];      // Destination address.
} IPHEADER, * PIPHEADER;

//////////////////////////////////////////////////////////////////////////////
VOID
BuildTestIPFrame (
    PUCHAR pFrame
)
//////////////////////////////////////////////////////////////////////////////
{
    ULONG ul          = 0;
    PIPHEADER pHeader = (PIPHEADER) pFrame;

    if (pFrame == NULL)
    {
        return;
    }

    //
    // Do the header part 1st
    //
    pHeader->ucIPVerLen = 0x45;
    pHeader->ucIPTos    = 0x00;
    pHeader->usLength   = 0x1C01;
    pHeader->usIPId     = 0x980A;
    pHeader->usIPOffset = 0x0000;
    pHeader->ucIPTtl    = 0x08;
    pHeader->ucProtocol = 0x11;
    pHeader->usChkSum   = 0x72B6;


    pHeader->ulIPSrc [0] = 0xC0;
    pHeader->ulIPSrc [1] = 0xA8;
    pHeader->ulIPSrc [2] = 0x01;
    pHeader->ulIPSrc [3] = 0x64;

    pHeader->ulIPDst [0] = 0xE3;
    pHeader->ulIPDst [1] = 0x02;
    pHeader->ulIPDst [2] = 0x02;
    pHeader->ulIPDst [3] = 0x02;

    //
    // Do the Data Part
    //
    for (pFrame += sizeof (IPHEADER), ul = 0; ul < 0x11C; ul++)
    {
        *pFrame++ = 0x11;
    }

    return;
}


//////////////////////////////////////////////////////////////////////////////
VOID
SlipGetConnectionProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    PSTREAM pStream                     = (PSTREAM)pSrb->StreamObject->HwStreamExtension;
    PSTREAM_PROPERTY_DESCRIPTOR pSPD    = pSrb->CommandData.PropertyInfo;
    ULONG Id                            = pSPD->Property->Id;                // index of the property
    ULONG ulStreamNumber                = pSrb->StreamObject->StreamNumber;

    pSrb->ActualBytesTransferred = 0;

    switch (Id)
    {
        case KSPROPERTY_CONNECTION_ALLOCATORFRAMING:
        {
            PKSALLOCATOR_FRAMING Framing = (PKSALLOCATOR_FRAMING) pSPD->PropertyInfo;

            Framing->RequirementsFlags   = KSALLOCATOR_REQUIREMENTF_SYSTEM_MEMORY    |
                                           KSALLOCATOR_REQUIREMENTF_INPLACE_MODIFIER |
                                           KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY;

            Framing->PoolType            = NonPagedPool;
            Framing->Frames              = 0;
            Framing->FrameSize           = 0;
            Framing->FileAlignment       = 0;         // None OR FILE_QUAD_ALIGNMENT-1 OR PAGE_SIZE-1;
            Framing->Reserved            = 0;

            switch (ulStreamNumber)
            {
                case SLIP_IPV4:
                    Framing->Frames    = 64;
                    Framing->FrameSize = pStream->OpenedFormat.SampleSize;
                    pSrb->Status = STATUS_SUCCESS;
                    break;

                case SLIP_STREAM:
                    Framing->Frames    = 64;
                    Framing->FrameSize = pStream->OpenedFormat.SampleSize;
                    pSrb->Status = STATUS_SUCCESS;
                    break;

                default:
                    pSrb->Status = STATUS_NOT_IMPLEMENTED;
                    break;
            }
            pSrb->ActualBytesTransferred = sizeof (KSALLOCATOR_FRAMING);
        }
        break;

        default:
            pSrb->Status = STATUS_NOT_IMPLEMENTED;
            break;
    }


    return;
}


//////////////////////////////////////////////////////////////////////////////
NTSTATUS
SlipDriverInitialize (
    IN PDRIVER_OBJECT    DriverObject,
    IN PUNICODE_STRING   RegistryPath
    )
//////////////////////////////////////////////////////////////////////////////
{
    NTSTATUS ntStatus                        = STATUS_SUCCESS;
    HW_INITIALIZATION_DATA   HwInitData;
    UNICODE_STRING           DeviceNameString;
    UNICODE_STRING           SymbolicNameString;

    RtlZeroMemory(&HwInitData, sizeof(HwInitData));
    HwInitData.HwInitializationDataSize = sizeof(HwInitData);


    ////////////////////////////////////////////////////////////////
    //
    // Setup the stream class dispatch table
    //
    HwInitData.HwInterrupt                 = NULL; // HwInterrupt is only for HW devices

    HwInitData.HwReceivePacket             = CodecReceivePacket;
    HwInitData.HwCancelPacket              = CodecCancelPacket;
    HwInitData.HwRequestTimeoutHandler     = CodecTimeoutPacket;

    HwInitData.DeviceExtensionSize         = sizeof(SLIP_FILTER);
    HwInitData.PerRequestExtensionSize     = sizeof(SRB_EXTENSION);
    HwInitData.FilterInstanceExtensionSize = 0;
    HwInitData.PerStreamExtensionSize      = sizeof(STREAM);
    HwInitData.BusMasterDMA                = FALSE;
    HwInitData.Dma24BitAddresses           = FALSE;
    HwInitData.BufferAlignment             = 3;
    HwInitData.TurnOffSynchronization      = TRUE;
    HwInitData.DmaBufferSize               = 0;


    ntStatus = StreamClassRegisterAdapter (DriverObject, RegistryPath, &HwInitData);
    if (ntStatus != STATUS_SUCCESS)
    {
        goto ret;
    }

ret:

    return ntStatus;
}


//
//
//////////////////////////////////////////////////////////////////////////////
BOOLEAN
CodecInitialize (
    IN OUT PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    NTSTATUS ntStatus                           = STATUS_SUCCESS;
    BOOLEAN bStatus                             = FALSE;
    PPORT_CONFIGURATION_INFORMATION pConfigInfo = pSrb->CommandData.ConfigInfo;
    PSLIP_FILTER pFilter                      = (PSLIP_FILTER) pConfigInfo->HwDeviceExtension;

    //
    // Define the default return codes
    //
    pSrb->Status = STATUS_SUCCESS;
    bStatus = TRUE;

    //
    // Initialize Statistics block
    //
    RtlZeroMemory(&pFilter->Stats, sizeof (STATS));

    //
    // Check out init flag so we don't try to init more then once.  The Streaming
    // Class driver appears to call the init handler several times for some reason.
    //
    if (pFilter->bInitializationComplete)
    {
        goto ret;
    }

    if (pConfigInfo->NumberOfAccessRanges == 0)
    {
        pConfigInfo->StreamDescriptorSize = sizeof (HW_STREAM_HEADER) +
            DRIVER_STREAM_COUNT * sizeof (HW_STREAM_INFORMATION);

    }
    else
    {
        pSrb->Status = STATUS_NO_SUCH_DEVICE;
        bStatus = FALSE;
        goto ret;
    }


    //
    // Create a filter object to represent our context
    //
    pSrb->Status = CreateFilter (pConfigInfo->ClassDeviceObject->DriverObject, pConfigInfo->ClassDeviceObject, pFilter);
    if (pSrb->Status != STATUS_SUCCESS)
    {
        bStatus = FALSE;
        goto ret;
    }

    pFilter->bInitializationComplete = TRUE;

ret:

    return (bStatus);
}


//////////////////////////////////////////////////////////////////////////////
BOOLEAN
CodecUnInitialize (
    IN OUT PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    NTSTATUS ntStatus                           = STATUS_SUCCESS;
    BOOLEAN bStatus                             = FALSE;
    PPORT_CONFIGURATION_INFORMATION pConfigInfo = pSrb->CommandData.ConfigInfo;
    PSLIP_FILTER pFilter                      = ((PSLIP_FILTER)pSrb->HwDeviceExtension);
    PSTREAM pStream                             = NULL;


    TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: Codec Unitialize called\n"));

    if (pSrb->StreamObject != NULL)
    {
        pStream = (PSTREAM)pSrb->StreamObject->HwStreamExtension;
    }


    if (pStream)
    {

        //
        // Clean up the NAB_STREAM QUEUE used for deframing
        //
        DeleteNabStreamQueue (pFilter);

        //
        // Clean up any queues we have and complete any outstanding SRB's
        //
        while (QueueRemove (&pSrb, &pFilter->StreamUserSpinLock, &pFilter->StreamContxList))
        {
            pSrb->Status = STATUS_CANCELLED;
            StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb);
            TEST_DEBUG( TEST_DBG_SRB, ("SLIP 5Completed SRB %08X\n", pSrb));

        }

        while (QueueRemove (&pSrb, &pFilter->IpV4StreamDataSpinLock, &pFilter->IpV4StreamDataQueue))
        {
            pSrb->Status = STATUS_CANCELLED;
            StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb );
            TEST_DEBUG( TEST_DBG_SRB, ("SLIP 6Completed SRB %08X\n", pSrb));
        }


        while (QueueRemove (&pSrb, &pFilter->StreamDataSpinLock, &pFilter->StreamDataQueue))
        {
            pSrb->Status = STATUS_CANCELLED;
            StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb );
            TEST_DEBUG( TEST_DBG_SRB, ("SLIP 7Completed SRB %08X\n", pSrb));
        }


        while (QueueRemove (&pSrb, &pFilter->StreamControlSpinLock, &pFilter->StreamControlQueue))
        {
            pSrb->Status = STATUS_CANCELLED;
            StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb);
            TEST_DEBUG( TEST_DBG_SRB, ("SLIP 8Completed SRB %08X\n", pSrb));
        }

    }


    while (QueueRemove (&pSrb, &pFilter->AdapterSRBSpinLock, &pFilter->AdapterSRBQueue))
    {
        pSrb->Status = STATUS_CANCELLED;
        StreamClassDeviceNotification (DeviceRequestComplete, pSrb->StreamObject, pSrb);
        TEST_DEBUG( TEST_DBG_RECV, ("SLIP 9Completed SRB %08X\n", pSrb));
    }


    bStatus = TRUE;

    TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: Codec Unitialize completed\n"));

    return (bStatus);
}


//////////////////////////////////////////////////////////////////////////////
VOID
CodecStreamInfo (
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    int j;

    PSLIP_FILTER pFilter =
            ((PSLIP_FILTER)pSrb->HwDeviceExtension);

    //
    // pick up the pointer to header which preceeds the stream info structs
    //
    PHW_STREAM_HEADER pstrhdr =
            (PHW_STREAM_HEADER)&(pSrb->CommandData.StreamBuffer->StreamHeader);

    //
    // pick up the pointer to the array of stream information data structures
    //
    PHW_STREAM_INFORMATION pstrinfo =
            (PHW_STREAM_INFORMATION)&(pSrb->CommandData.StreamBuffer->StreamInfo);


    //
    // Set the header
    //
    StreamHeader.NumDevPropArrayEntries = 0;
    StreamHeader.DevicePropertiesArray = (PKSPROPERTY_SET)NULL;

    *pstrhdr = StreamHeader;

    //
    // stuff the contents of each HW_STREAM_INFORMATION struct
    //
    for (j = 0; j < DRIVER_STREAM_COUNT; j++)
    {
       *pstrinfo++ = Streams[j].hwStreamInfo;
    }

    pSrb->Status = STATUS_SUCCESS;

}


//////////////////////////////////////////////////////////////////////////////
VOID
STREAMAPI
CodecCancelPacket(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    PSTREAM  pStream = (PSTREAM)pSrb->StreamObject->HwStreamExtension;
    PSLIP_FILTER  pFilter = ((PSLIP_FILTER)pSrb->HwDeviceExtension);

    //
    // Check whether the SRB to cancel is in use by this stream
    //

    TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: CancelPacket Called\n"));


    CancelNabStreamSrb (pFilter, pSrb);


    if (QueueRemoveSpecific (pSrb, &pFilter->IpV4StreamDataSpinLock, &pFilter->IpV4StreamDataQueue))
    {
        pSrb->Status = STATUS_CANCELLED;
        StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb );
        TEST_DEBUG( TEST_DBG_SRB, ("SLIP 10Completed SRB %08X\n", pSrb));
        return;
    }


    if (QueueRemoveSpecific (pSrb, &pFilter->StreamDataSpinLock, &pFilter->StreamDataQueue))
    {
        pSrb->Status = STATUS_CANCELLED;
        StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb );
        TEST_DEBUG( TEST_DBG_SRB, ("SLIP 11Completed SRB %08X\n", pSrb));
        return;
    }


    if (QueueRemoveSpecific (pSrb, &pFilter->StreamControlSpinLock, &pFilter->StreamControlQueue))
    {
        pSrb->Status = STATUS_CANCELLED;
        StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb);
        TEST_DEBUG( TEST_DBG_SRB, ("SLIP 12Completed SRB %08X\n", pSrb));
        return;
    }

    if (QueueRemoveSpecific (pSrb, &pFilter->AdapterSRBSpinLock, &pFilter->AdapterSRBQueue))
    {
        pSrb->Status = STATUS_CANCELLED;
        StreamClassDeviceNotification (DeviceRequestComplete, pSrb->StreamObject, pSrb);
        TEST_DEBUG( TEST_DBG_SRB, ("SLIP 13Completed SRB %08X\n", pSrb));
        return;
    }

    return;
}


//////////////////////////////////////////////////////////////////////////////
VOID
STREAMAPI
CodecTimeoutPacket(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    //
    // if we timeout while playing, then we need to consider this
    // condition an error, and reset the hardware, and reset everything
    // as well as cancelling this and all requests
    //

    //
    // if we are not playing, and this is a CTRL request, we still
    // need to reset everything as well as cancelling this and all requests
    //

    //
    // if this is a data request, and the device is paused, we probably have
    // run out of data buffer, and need more time, so just reset the timer,
    // and let the packet continue
    //

    TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: TimeoutPacket Called\n"));

    pSrb->TimeoutCounter = 0;

    return;
}


//////////////////////////////////////////////////////////////////////////////
VOID
STREAMAPI
CodecReceivePacket(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    PSLIP_FILTER pFilter = ((PSLIP_FILTER)pSrb->HwDeviceExtension);


    //
    // Make sure queue & SL initted
    //
    if (!pFilter->bAdapterQueueInitialized)
    {
        InitializeListHead (&pFilter->AdapterSRBQueue);
        KeInitializeSpinLock (&pFilter->AdapterSRBSpinLock);
        pFilter->bAdapterQueueInitialized = TRUE;
    }

    //
    // Assume success
    //
    pSrb->Status = STATUS_SUCCESS;

    //
    // determine the type of packet.
    //
    QueueAdd (pSrb, &pFilter->AdapterSRBSpinLock, &pFilter->AdapterSRBQueue);
    TEST_DEBUG( TEST_DBG_SRB, ("SLIP Queuing SRB %08X\n", pSrb));


    while (QueueRemove( &pSrb, &pFilter->AdapterSRBSpinLock, &pFilter->AdapterSRBQueue ))
    {
        switch (pSrb->Command)
        {

            case SRB_INITIALIZE_DEVICE:
                TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: SRB_INITIALIZE Command\n"));
                CodecInitialize(pSrb);
                break;

            case SRB_UNINITIALIZE_DEVICE:
                TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: SRB_UNINITIALIZE Command\n"));
                CodecUnInitialize(pSrb);
                break;

            case SRB_INITIALIZATION_COMPLETE:
                TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: SRB_INITIALIZE_COMPLETE Command\n"));
                pSrb->Status = STATUS_SUCCESS;
                break;

            case SRB_OPEN_STREAM:
                TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: SRB_OPEN_STREAM Command\n"));
                OpenStream (pSrb);
                break;

            case SRB_CLOSE_STREAM:
                TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: SRB_CLOSE_STREAM Command\n"));
                CloseStream (pSrb);
                break;

            case SRB_GET_STREAM_INFO:
                TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: SRB_GET_STREAM_INFO Command\n"));
                CodecStreamInfo (pSrb);
                break;

            case SRB_GET_DATA_INTERSECTION:
                TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: SRB_GET_DATA_INTERSECTION Command\n"));

                //
                // Compare our stream formats.  NOTE, the compare functions sets the SRB
                // status fields
                //
                CompareStreamFormat (pSrb);
                break;

            case SRB_OPEN_DEVICE_INSTANCE:
                TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: SRB_OPEN_DEVICE_INSTANCE Command\n"));
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
                break;

            case SRB_CLOSE_DEVICE_INSTANCE:
                TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: SRB_CLOSE_DEVICE_INSTANCE Command\n"));
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
                break;

            case SRB_UNKNOWN_DEVICE_COMMAND:
                TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: SRB_UNKNOWN_DEVICE Command\n"));
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
                break;

            case SRB_CHANGE_POWER_STATE:
                TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: SRB_CHANGE_POWER_STATE Command\n"));
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
                break;

            case SRB_GET_DEVICE_PROPERTY:
                TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: SRB_GET_DEVICE_PROPERTY Command\n"));
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
                break;

            case SRB_SET_DEVICE_PROPERTY:
                TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: SRB_SET_DEVICE_PROPERTY Command\n"));
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
                break;

            case SRB_UNKNOWN_STREAM_COMMAND:
                TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: SRB_UNKNOWN Command\n"));
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
                break;

            default:
                TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: SRB_DEFAULT Command\n"));
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
                break;

        };


        //
        // NOTE:
        //
        // All of the commands that we do, or do not understand can all be completed
        // syncronously at this point, so we can use a common callback routine here.
        // If any of the above commands require asyncronous processing, this will
        // have to change
        //

        TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: SRB Status returned: %08X\n", pSrb->Status));

        StreamClassDeviceNotification (DeviceRequestComplete, pFilter, pSrb);
        TEST_DEBUG( TEST_DBG_SRB, ("SLIP 14Completed SRB %08X\n", pSrb));

    }




}


//////////////////////////////////////////////////////////////////////////////
BOOL STREAMAPI
QueueAdd (
    IN PHW_STREAM_REQUEST_BLOCK pSrb,
    IN PKSPIN_LOCK pQueueSpinLock,
    IN PLIST_ENTRY pQueue
    )
//////////////////////////////////////////////////////////////////////////////
{
    KIRQL           Irql;
    PSRB_EXTENSION  pSrbExtension;

    pSrbExtension = ( PSRB_EXTENSION )pSrb->SRBExtension;

    KeAcquireSpinLock( pQueueSpinLock, &Irql );

    pSrbExtension->pSrb = pSrb;
    InsertTailList( pQueue, &pSrbExtension->ListEntry );

    KeReleaseSpinLock( pQueueSpinLock, Irql );

    return TRUE;
}



//////////////////////////////////////////////////////////////////////////////
BOOL STREAMAPI
QueueRemove (
    IN OUT PHW_STREAM_REQUEST_BLOCK * pSrb,
    IN PKSPIN_LOCK pQueueSpinLock,
    IN PLIST_ENTRY pQueue
    )
//////////////////////////////////////////////////////////////////////////////
{
   KIRQL    Irql;
   BOOL     bRemovedSRB = FALSE;

   KeAcquireSpinLock (pQueueSpinLock, &Irql);

   *pSrb =  (PHW_STREAM_REQUEST_BLOCK) NULL;

   if( !IsListEmpty( pQueue ))
   {
       PUCHAR Ptr                            = (PUCHAR) RemoveHeadList(pQueue);

       PSRB_EXTENSION pSRBExtension = CONTAINING_RECORD(Ptr,SRB_EXTENSION, ListEntry );
        *pSrb = (pSRBExtension->pSrb);
       bRemovedSRB = TRUE;

   }

   KeReleaseSpinLock (pQueueSpinLock, Irql);

   return bRemovedSRB;
}

//////////////////////////////////////////////////////////////////////////////
BOOL STREAMAPI
QueueRemoveSpecific (
    IN PHW_STREAM_REQUEST_BLOCK pSrb,
    IN PKSPIN_LOCK pQueueSpinLock,
    IN PLIST_ENTRY pQueue
    )
//////////////////////////////////////////////////////////////////////////////
{
   KIRQL Irql;
   BOOL  bRemovedSRB = FALSE;
   PLIST_ENTRY pCurrentEntry;
   PHW_STREAM_REQUEST_BLOCK  pCurrentSrb;

   KeAcquireSpinLock( pQueueSpinLock, &Irql );

   if( !IsListEmpty( pQueue ))
   {
       pCurrentEntry = pQueue->Flink;
       while ((pCurrentEntry != pQueue ) && !bRemovedSRB)
       {
	    PSRB_EXTENSION pSRBExtension = CONTAINING_RECORD(pCurrentEntry,SRB_EXTENSION, ListEntry );
           pCurrentSrb = pSRBExtension->pSrb;

           if( pCurrentSrb == pSrb )
           {
               RemoveEntryList( pCurrentEntry );
               bRemovedSRB = TRUE;
           }
           pCurrentEntry = pCurrentEntry->Flink;
       }
   }
   KeReleaseSpinLock( pQueueSpinLock, Irql );

   return bRemovedSRB;
}



//////////////////////////////////////////////////////////////////////////////
BOOL
CompareGUIDsAndFormatSize(
    IN PKSDATARANGE pDataRange1,
    IN PKSDATARANGE pDataRange2,
    BOOLEAN bCheckSize
    )
//////////////////////////////////////////////////////////////////////////////
{
    BOOL bResult = FALSE;

    if ( IsEqualGUID(&pDataRange1->MajorFormat, &KSDATAFORMAT_TYPE_WILDCARD) ||
         IsEqualGUID(&pDataRange2->MajorFormat, &KSDATAFORMAT_TYPE_WILDCARD) ||
         IsEqualGUID(&pDataRange1->MajorFormat, &pDataRange2->MajorFormat) )
    {

        if ( IsEqualGUID(&pDataRange1->SubFormat, &KSDATAFORMAT_SUBTYPE_WILDCARD) ||
             IsEqualGUID(&pDataRange2->SubFormat, &KSDATAFORMAT_SUBTYPE_WILDCARD) ||
             IsEqualGUID(&pDataRange1->SubFormat, &pDataRange2->SubFormat) )
        {

            if ( IsEqualGUID(&pDataRange1->Specifier, &KSDATAFORMAT_SPECIFIER_WILDCARD) ||
                 IsEqualGUID(&pDataRange2->Specifier, &KSDATAFORMAT_SPECIFIER_WILDCARD) ||
                 IsEqualGUID(&pDataRange1->Specifier, &pDataRange2->Specifier) )
            {
                if ( !bCheckSize || pDataRange1->FormatSize == pDataRange2->FormatSize)
                {
                    bResult = TRUE;
                }
            }
        }
    }

    return bResult;

}

//////////////////////////////////////////////////////////////////////////////
VOID
DumpDataFormat (
    PKSDATAFORMAT   pF
    )
//////////////////////////////////////////////////////////////////////////////
{
    TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: DATA Format\n"));
    TEST_DEBUG (TEST_DBG_TRACE, ("SLIP:     Format Size:   %08X\n", pF->FormatSize));
    TEST_DEBUG (TEST_DBG_TRACE, ("SLIP:     Flags:         %08X\n", pF->Flags));
    TEST_DEBUG (TEST_DBG_TRACE, ("SLIP:     SampleSize:    %08X\n", pF->SampleSize));
    TEST_DEBUG (TEST_DBG_TRACE, ("SLIP:     Reserved:      %08X\n", pF->Reserved));



    TEST_DEBUG (TEST_DBG_TRACE, ("SLIP:     Major GUID:  %08X %04X %04X %02X %02X %02X %02X %02X %02X %02X %02X\n",
                                                pF->MajorFormat.Data1,
                                                pF->MajorFormat.Data2,
                                                pF->MajorFormat.Data3,
                                                pF->MajorFormat.Data4[0],
                                                pF->MajorFormat.Data4[1],
                                                pF->MajorFormat.Data4[2],
                                                pF->MajorFormat.Data4[3],
                                                pF->MajorFormat.Data4[4],
                                                pF->MajorFormat.Data4[5],
                                                pF->MajorFormat.Data4[6],
                                                pF->MajorFormat.Data4[7]
                                ));

    TEST_DEBUG (TEST_DBG_TRACE, ("SLIP:     Sub GUID:    %08X %04X %04X %02X %02X %02X %02X %02X %02X %02X %02X\n",
                                                pF->SubFormat.Data1,
                                                pF->SubFormat.Data2,
                                                pF->SubFormat.Data3,
                                                pF->SubFormat.Data4[0],
                                                pF->SubFormat.Data4[1],
                                                pF->SubFormat.Data4[2],
                                                pF->SubFormat.Data4[3],
                                                pF->SubFormat.Data4[4],
                                                pF->SubFormat.Data4[5],
                                                pF->SubFormat.Data4[6],
                                                pF->SubFormat.Data4[7]
                                ));

    TEST_DEBUG (TEST_DBG_TRACE, ("SLIP:     Specifier:   %08X %04X %04X %02X %02X %02X %02X %02X %02X %02X %02X\n",
                                                pF->Specifier.Data1,
                                                pF->Specifier.Data2,
                                                pF->Specifier.Data3,
                                                pF->Specifier.Data4[0],
                                                pF->Specifier.Data4[1],
                                                pF->Specifier.Data4[2],
                                                pF->Specifier.Data4[3],
                                                pF->Specifier.Data4[4],
                                                pF->Specifier.Data4[5],
                                                pF->Specifier.Data4[6],
                                                pF->Specifier.Data4[7]
                                ));

    TEST_DEBUG (TEST_DBG_TRACE, ("\n"));
}


//////////////////////////////////////////////////////////////////////////////
BOOL
CompareStreamFormat (
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    BOOL                        bStatus = FALSE;
    PSTREAM_DATA_INTERSECT_INFO pIntersectInfo;
    PKSDATARANGE                pDataRange1;
    PKSDATARANGE                pDataRange2;
    ULONG                       FormatSize = 0;
    ULONG                       ulStreamNumber;
    ULONG                       j;
    ULONG                       ulNumberOfFormatArrayEntries;
    PKSDATAFORMAT               *pAvailableFormats;


    pIntersectInfo = pSrb->CommandData.IntersectInfo;
    ulStreamNumber = pIntersectInfo->StreamNumber;


    pSrb->ActualBytesTransferred = 0;


    TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: Comparing Stream Formats\n"));


    //
    // Check that the stream number is valid
    //
    if (ulStreamNumber < DRIVER_STREAM_COUNT)
    {
        ulNumberOfFormatArrayEntries = Streams[ulStreamNumber].hwStreamInfo.NumberOfFormatArrayEntries;

        //
        // Get the pointer to the array of available formats
        //
        pAvailableFormats = Streams[ulStreamNumber].hwStreamInfo.StreamFormatsArray;

        //
        // Walk the formats supported by the stream searching for a match
        // of the three GUIDs which together define a DATARANGE
        //
        for (pDataRange1 = pIntersectInfo->DataRange, j = 0;
             j < ulNumberOfFormatArrayEntries;
             j++, pAvailableFormats++)

        {
            bStatus = FALSE;
            pSrb->Status = STATUS_UNSUCCESSFUL;

            pDataRange2 = *pAvailableFormats;

            if (CompareGUIDsAndFormatSize (pDataRange1, pDataRange2, TRUE))
            {

                ULONG   ulFormatSize = pDataRange2->FormatSize;

                TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: Stream Formats compare\n"));

                //
                // Is the caller trying to get the format, or the size of the format?
                //
                if (pIntersectInfo->SizeOfDataFormatBuffer == sizeof (ULONG))
                {
                    TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: Returning Stream Format size\n"));

                    *(PULONG) pIntersectInfo->DataFormatBuffer = ulFormatSize;
                    pSrb->ActualBytesTransferred = sizeof (ULONG);
                    pSrb->Status = STATUS_SUCCESS;
                    bStatus = TRUE;
                }
                else
                {
                    //
                    // Verify that there is enough room in the supplied buffer for the whole thing
                    //
                    pSrb->Status = STATUS_BUFFER_TOO_SMALL;
                    bStatus = FALSE;

                    if (pIntersectInfo->SizeOfDataFormatBuffer >= ulFormatSize)
                    {
                        TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: Returning Stream Format\n"));
                        RtlCopyMemory (pIntersectInfo->DataFormatBuffer, pDataRange2, ulFormatSize);
                        pSrb->ActualBytesTransferred = ulFormatSize;
                        pSrb->Status = STATUS_SUCCESS;
                        bStatus = TRUE;
                    }
                    else
                    {
                        TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: Stream Format return buffer too small\n"));
                    }
                }
                break;
            }
            else
            {
                TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: Stream Formats DO NOT compare\n"));
            }
        }

        if ( j >= ulNumberOfFormatArrayEntries )
        {
            pSrb->ActualBytesTransferred = 0;
            pSrb->Status = STATUS_UNSUCCESSFUL;
            bStatus = FALSE;
        }

    }
    else
    {
        pSrb->ActualBytesTransferred = 0;
        pSrb->Status = STATUS_NOT_IMPLEMENTED;
        bStatus = FALSE;
    }

    return bStatus;
}


//////////////////////////////////////////////////////////////////////////////
VOID
CloseStream (
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    //
    // the stream extension structure is allocated by the stream class driver
    //
    PSTREAM         pStream                = (PSTREAM)pSrb->StreamObject->HwStreamExtension;
    PSLIP_FILTER  pFilter                = (PSLIP_FILTER)pSrb->HwDeviceExtension;
    ULONG           ulStreamNumber         = (ULONG) pSrb->StreamObject->StreamNumber;
    ULONG           ulStreamInstance       = pStream->ulStreamInstance;
    PHW_STREAM_REQUEST_BLOCK pCurrentSrb   = NULL;

    //
    // check that the stream index requested isn't too high
    // or that the maximum number of instances hasn't been exceeded
    //
    if (ulStreamNumber < DRIVER_STREAM_COUNT )
    {
        //
        // Flush the stream data queue
        //
        while (QueueRemove( &pCurrentSrb, &pFilter->IpV4StreamDataSpinLock, &pFilter->IpV4StreamDataQueue))
        {
           pCurrentSrb->Status = STATUS_CANCELLED;
           StreamClassStreamNotification( StreamRequestComplete, pCurrentSrb->StreamObject, pCurrentSrb);
           TEST_DEBUG( TEST_DBG_SRB, ("SLIP 15Completed SRB %08X\n", pCurrentSrb));
        }

        //
        // Flush the stream data queue
        //
        while (QueueRemove( &pCurrentSrb, &pFilter->StreamDataSpinLock, &pFilter->StreamDataQueue))
        {
           pCurrentSrb->Status = STATUS_CANCELLED;
           StreamClassStreamNotification( StreamRequestComplete, pCurrentSrb->StreamObject, pCurrentSrb);
           TEST_DEBUG( TEST_DBG_SRB, ("SLIP 16Completed SRB %08X\n", pCurrentSrb));
        }

        //
        // Flush the stream control queue
        //
        while (QueueRemove( &pCurrentSrb, &pFilter->StreamControlSpinLock, &pFilter->StreamControlQueue))
        {
           pCurrentSrb->Status = STATUS_CANCELLED;
           StreamClassStreamNotification (StreamRequestComplete, pCurrentSrb->StreamObject, pCurrentSrb);
           TEST_DEBUG( TEST_DBG_SRB, ("SLIP 17Completed SRB %08X\n", pCurrentSrb));
        }

        //
        // Clear this streams spot in the filters stream array
        //
        pFilter->pStream[ulStreamNumber][ulStreamInstance] = NULL;

        //
        // decrement the stream instance count for this filter
        //
        pFilter->ulActualInstances[ulStreamNumber]--;

        //
        // Indicate the clock support available on this stream
        //
        //pSrb->StreamObject->HwClockObject = 0;

        //
        // Reset the stream state to stopped
        //
        pStream->KSState = KSSTATE_STOP;

                 
        //
        // Reset the stream extension blob
        //
        RtlZeroMemory(pStream, sizeof (STREAM));

        pSrb->Status = STATUS_SUCCESS;

    }
    else
    {
        pSrb->Status = STATUS_INVALID_PARAMETER;
    }
}


//////////////////////////////////////////////////////////////////////////////
VOID
OpenStream (
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    //
    // the stream extension structure is allocated by the stream class driver
    //
    PSTREAM         pStream        = (PSTREAM)pSrb->StreamObject->HwStreamExtension;
    PSLIP_FILTER    pFilter        = ((PSLIP_FILTER)pSrb->HwDeviceExtension);
    ULONG           ulStreamNumber = (ULONG) pSrb->StreamObject->StreamNumber;
    PKSDATAFORMAT   pKSDataFormat  = (PKSDATAFORMAT)pSrb->CommandData.OpenFormat;

    //
    // Initialize the stream extension blob
    //
    //RtlZeroMemory(pStream, sizeof (STREAM));

    //
    // Initialize stream state
    //
    //pStream->KSState = KSSTATE_STOP;

    //
    // Initialize the next stream life check time.
    //
    KeQuerySystemTime( &pFilter->liLastTimeChecked );

    //
    // Initialize stats dump time
    //
    KeQuerySystemTime( &pFilter->liLastTimeStatsDumped );

    //
    // check that the stream index requested isn't too high
    // or that the maximum number of instances hasn't been exceeded
    //
    if (ulStreamNumber < DRIVER_STREAM_COUNT )
    {
        ULONG ulStreamInstance;
        ULONG ulMaxInstances = Streams[ulStreamNumber].hwStreamInfo.NumberOfPossibleInstances;

        //
        // Search for next open slot
        //
        for (ulStreamInstance = 0; ulStreamInstance < ulMaxInstances; ++ulStreamInstance)
        {
            if (pFilter->pStream[ulStreamNumber][ulStreamInstance] == NULL)
            {
                break;
            }
        }

        if (ulStreamInstance < ulMaxInstances)
        {
            if (VerifyFormat(pKSDataFormat, ulStreamNumber, &pStream->MatchedFormat))
            {
                //
                // Initialize Data queues and SpinLocks
                //
                KeInitializeSpinLock(&(pStream->KSStateSpinLock));
                
                // Maintain an array of all the StreamEx structures in the HwDevExt
                // so that we can reference IRPs from any stream
                //
                pFilter->pStream[ulStreamNumber][ulStreamInstance] = pStream;

                //
                // Save the Stream Format in the Stream Extension as well.
                //
                pStream->OpenedFormat = *pKSDataFormat;

                //
                // Set up pointers to the handlers for the stream data and control handlers
                //
                pSrb->StreamObject->ReceiveDataPacket =
                                                (PVOID) Streams[ulStreamNumber].hwStreamObject.ReceiveDataPacket;
                pSrb->StreamObject->ReceiveControlPacket =
                                                (PVOID) Streams[ulStreamNumber].hwStreamObject.ReceiveControlPacket;

                //
                // The DMA flag must be set when the device will be performing DMA directly
                // to the data buffer addresses passed in to the ReceiveDataPacket routines.
                //
                pSrb->StreamObject->Dma = Streams[ulStreamNumber].hwStreamObject.Dma;

                //
                // The PIO flag must be set when the mini driver will be accessing the data
                // buffers passed in using logical addressing
                //
                pSrb->StreamObject->Pio = Streams[ulStreamNumber].hwStreamObject.Pio;

                pSrb->StreamObject->Allocator = Streams[ulStreamNumber].hwStreamObject.Allocator;

                //
                // How many extra bytes will be passed up from the driver for each frame?
                //
                pSrb->StreamObject->StreamHeaderMediaSpecific =
                                        Streams[ulStreamNumber].hwStreamObject.StreamHeaderMediaSpecific;

                pSrb->StreamObject->StreamHeaderWorkspace =
                                        Streams[ulStreamNumber].hwStreamObject.StreamHeaderWorkspace;

                //
                // Indicate the clock support available on this stream
                //
                pSrb->StreamObject->HwClockObject =
                                        Streams[ulStreamNumber].hwStreamObject.HwClockObject;

                //
                // Increment the instance count on this stream
                //
                pStream->ulStreamInstance = ulStreamInstance;
                pFilter->ulActualInstances[ulStreamNumber]++;


                //
                // Retain a private copy of the HwDevExt and StreamObject in the stream extension
                // so we can use a timer
                //
                pStream->pFilter = pFilter;                     // For timer use
                pStream->pStreamObject = pSrb->StreamObject;        // For timer use


                pSrb->Status = STATUS_SUCCESS;

            }
            else
            {
                pSrb->Status = STATUS_INVALID_PARAMETER;
            }
        }
        else
        {
            pSrb->Status = STATUS_INVALID_PARAMETER;
        }

    }
    else
    {
        pSrb->Status = STATUS_INVALID_PARAMETER;
    }
}


//////////////////////////////////////////////////////////////////////////////
BOOLEAN
VerifyFormat(
    IN KSDATAFORMAT *pKSDataFormat,
    UINT StreamNumber,
    PKSDATARANGE pMatchedFormat
    )
//////////////////////////////////////////////////////////////////////////////
{
    BOOLEAN   bResult               = FALSE;
    ULONG     FormatCount           = 0;
    PKS_DATARANGE_VIDEO pThisFormat = NULL;

    TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: Verify Format\n"));

    for (FormatCount = 0; !bResult && FormatCount < Streams[StreamNumber].hwStreamInfo.NumberOfFormatArrayEntries;
         FormatCount++ )
    {


        pThisFormat = (PKS_DATARANGE_VIDEO) Streams [StreamNumber].hwStreamInfo.StreamFormatsArray [FormatCount];

        if (CompareGUIDsAndFormatSize( pKSDataFormat, &pThisFormat->DataRange, FALSE ) )
        {
            bResult = FALSE;

            if (pThisFormat->DataRange.SampleSize >= pKSDataFormat->SampleSize)
            {
                bResult = TRUE;
            }
            else
            {
                TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: VerifyFormat: Data range Sample Sizes don't match\n"));
            }
        }
    }

    if (bResult == TRUE && pMatchedFormat)
    {
        *pMatchedFormat = pThisFormat->DataRange;
    }

    return bResult;
}


//////////////////////////////////////////////////////////////////////////////
VOID
STREAMAPI
ReceiveDataPacket (
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    PSLIP_FILTER      pFilter         = (PSLIP_FILTER) pSrb->HwDeviceExtension;
    PSTREAM           pStream         = (PSTREAM)pSrb->StreamObject->HwStreamExtension;
    int               iStream         = (int) pSrb->StreamObject->StreamNumber;
    PKSSTREAM_HEADER  pStreamHdr      = pSrb->CommandData.DataBufferArray;
    PKSDATAFORMAT     pKSDataFormat   = (PKSDATAFORMAT) &pStream->MatchedFormat;
    ULONG             ul              = 0;
    PHW_STREAM_REQUEST_BLOCK pSrbIPv4 = NULL;

    TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: Receive Data packet handler called\n"));

    //
    // Default to success, disable timeouts
    //
    pSrb->TimeoutCounter = 0;
    pSrb->Status = STATUS_SUCCESS;

    //
    // Check for last buffer
    //
    if (pStreamHdr->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_ENDOFSTREAM)
    {
        TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: Receive Data packet is LAST PACKET\n"));

        StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb);
        TEST_DEBUG( TEST_DBG_SRB, ("SLIP: Completed SRB %08X\n", pSrb));

        return;
    }


    if (pStreamHdr->OptionsFlags != 0)
    {
        TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: OptionsFlags: %08X\n", pStreamHdr->OptionsFlags));
    }


    //
    // determine the type of packet.
    //
    switch (pSrb->Command)
    {
        case SRB_WRITE_DATA:

            if (pStream->KSState == KSSTATE_STOP)
            {
                pSrb->Status = STATUS_SUCCESS;

                TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: SRB_WRITE STOP SRB Status returned: %08X\n", pSrb->Status));

                StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb );
                TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: StreamRequestComplete on pSrb: %08X\n", pSrb));

                break;
            }

            //
            // Update the total number of packets written statistic
            //
            pFilter->Stats.ulTotalDataSRBWrites += 1;


            //
            // Handle data input, output requests differently.
            //
            switch (iStream)
            {
                //
                //  Frame input stream
                //
                case SLIP_STREAM:
                {
                    ULONG             ulBuffers        = pSrb->NumberOfBuffers;
                    PKSSTREAM_HEADER  pIPV4StreamHdr   = NULL;
                    PNABTSFEC_BUFFER  pNabData         = NULL;

                    TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: Receive Data packet handler - SRB_WRITE - SLIP_STREAM, Processing pSrb: %08X\n", pSrb));

                    //
                    // Initialize SRB Status to success
                    //
                    pSrb->Status = STATUS_SUCCESS;

                    //
                    // Process each chained buffer of data in the SRB
                    //
                    for (ul = 0; ul < ulBuffers; ul++, pStreamHdr++)
                    {
                        if (pStreamHdr)
                        {
                            //
                            // Update stats for IP Stream count
                            //
                            pFilter->Stats.ulTotalSlipBuffersReceived    += 1;
                            pFilter->Stats.ulTotalSlipBytesReceived      += pStreamHdr->DataUsed;

                            pNabData = (PNABTSFEC_BUFFER) pStreamHdr->Data;

                            if (pNabData && pStreamHdr->DataUsed > 0)
                            {
                                TEST_DEBUG (TEST_DBG_WRITE_DATA, ("SLIP: NAB_DATA[%d]....dataSize: %d  groupID: %d\n",
                                                                  ul,
                                                                  pNabData->dataSize,
                                                                 pNabData->groupID ));
                                
                                if(pNabData->dataSize > sizeof(pNabData->data))
                                {
                                    pSrb->Status = STATUS_SUCCESS;
                                    pFilter->bDiscontinuity = TRUE;
                                    break;
                                }
                                
                                ASSERT(pNabData->dataSize <= sizeof(pNabData->data));


                                if ((pSrb->Status = ntNabtsRecv (pFilter, pNabData)) != STATUS_SUCCESS)
                                {
                                    //
                                    // Something went wrong processing the data (such as running
                                    // out of output buffers).   We'll just complete the input SRB
                                    // and lose the data.  We'll return a successful status to make sure the
                                    // graph can continue to run.  Basically this error amounts to the SRB
                                    // being tossed out and never processed (ie. a Data Loss).
                                    //
                                    pSrb->Status = STATUS_SUCCESS;

                                    pFilter->bDiscontinuity = TRUE;

                                    break;
                                }
                            }
                            else
                            {
                                pFilter->Stats.ulTotalSlipZeroLengthBuffers += 1;
                            }
                        }
                    }


                    StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb);
                    TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: StreamRequestComplete on pSrb: %08X\n", pSrb));
                }
                break;

                //
                // Other "unknown" streams are not valid and will be rejected.
                //

                default:
                    TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: Receive Data packet handler called - SRB_WRITE - Default\n"));
                    pSrb->Status = STATUS_NOT_IMPLEMENTED;

                    //
                    // Update stats for Unkown packet count
                    //
                    pFilter->Stats.ulTotalBadPinSRBWrites += 1;

                    TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: DEFAULT SRB Status returned: %08X\n", pSrb->Status));

                    StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb);
                    TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: StreamRequestComplete on pSrb: %08X\n", pSrb));

                    break;
            }
            break;


        case SRB_READ_DATA:

            if (pStream->KSState == KSSTATE_STOP)
            {
                pSrb->Status = STATUS_SUCCESS;
                TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: SRB_READ STOP SRB Status returned: %08X\n", pSrb->Status));

                StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb );
                TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: StreamRequestComplete on pSrb: %08X\n", pSrb));

                break;
            }

            //
            // Update stats
            //
            pFilter->Stats.ulTotalDataSRBReads += 1;

            switch (iStream)
            {

                case SLIP_IPV4:
                {
                    ULONG             ulBuffers       = pSrb->NumberOfBuffers;

                    TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: Receive Data packet handler called - SRB_READ - SLIP_IPV4, Processing pSrb: %08X\n", pSrb));

                    if (pSrb->CommandData.DataBufferArray->FrameExtent < pKSDataFormat->SampleSize)
                    {
                        pSrb->Status = STATUS_BUFFER_TOO_SMALL;
                        TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: SLIP_IPV4 SRB Buffer too small.... Status returned: %08X\n", pSrb->Status));
                        StreamClassStreamNotification(StreamRequestComplete, pSrb->StreamObject, pSrb);
                        TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: StreamRequestComplete on pSrb: %08X\n", pSrb));
                    }
                    else
                    {

                        //
                        // Take the SRB we get and  queue it up.  These Queued SRB's will be filled with data on a WRITE_DATA
                        // request, at which point they will be completed.
                        //
                        QueueAdd (pSrb, &pFilter->IpV4StreamDataSpinLock, &pFilter->IpV4StreamDataQueue);
                        TEST_DEBUG( TEST_DBG_SRB, ("SLIP Queuing IPv4 SRB %08X\n", pSrb));


                        //
                        // Since the stream state may have changed while we were adding the SRB to the queue
                        // we'll check it again, and cancel it if necessary
                        //
                        if (pStream->KSState == KSSTATE_STOP)
                        {
                            TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: SRB_READ STOP SRB Status returned: %08X\n", pSrb->Status));

                            if (QueueRemoveSpecific (pSrb, &pFilter->IpV4StreamDataSpinLock, &pFilter->IpV4StreamDataQueue))
                            {
                                pSrb->Status = STATUS_CANCELLED;
                                StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb );
                                TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: StreamRequestComplete on pSrb: %08X\n", pSrb));
                                return;
                            }
                            break;
                        }

                    }
                }
                break;


                default:
                    TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: Receive Data packet handler called - SRB_READ - Default\n"));
                    pSrb->Status = STATUS_NOT_IMPLEMENTED;
                    TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: DEFAULT SRB Status returned: %08X\n", pSrb->Status));

                    //
                    // Update stats for Unkown packet count
                    //
                    pFilter->Stats.ulTotalBadPinSRBReads += 1;
                    
                    StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb);
                    TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: StreamRequestComplete on pSrb: %08X\n", pSrb));
                    break;

            }
            break;

        default:

            //
            // invalid / unsupported command. Fail it as such
            //
            TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: Receive Data packet handler called - Unsupported Command\n"));
            pSrb->Status = STATUS_NOT_IMPLEMENTED;
            TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: DEFAULT SRB Status returned: %08X\n", pSrb->Status));
            StreamClassStreamNotification( StreamRequestComplete, pSrb->StreamObject, pSrb );
            TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: StreamRequestComplete on pSrb: %08X\n", pSrb));
            ASSERT (FALSE);
            break;

    }


    TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: Receive Data packet handler called...status: %08X\n", pSrb->Status));

    return;
}



//////////////////////////////////////////////////////////////////////////////
VOID
SlipGetProperty (
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;

    pSrb->Status = STATUS_SUCCESS;

    if (IsEqualGUID (&KSPROPSETID_Connection, &pSPD->Property->Set))
    {
        SlipGetConnectionProperty (pSrb);
    }
    else
    {
        pSrb->Status = STATUS_NOT_IMPLEMENTED;
    }

    TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: SlipGetProperty Status: %08X\n", pSrb->Status));

    return;
}


//////////////////////////////////////////////////////////////////////////////
VOID
IndicateMasterClock(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    PSTREAM pStream = (PSTREAM) pSrb->StreamObject->HwStreamExtension;
}

//////////////////////////////////////////////////////////////////////////////
VOID
STREAMAPI
ReceiveCtrlPacket(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    PSLIP_FILTER pFilter = (PSLIP_FILTER) pSrb->HwDeviceExtension;
    PSTREAM pStream = (PSTREAM) pSrb->StreamObject->HwStreamExtension;

    TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: Receive Control packet handler called\n"));

    pSrb->Status = STATUS_SUCCESS;

    QueueAdd (pSrb, &pFilter->StreamControlSpinLock, &pFilter->StreamControlQueue);
    TEST_DEBUG( TEST_DBG_SRB, ("SLIP Queuing Control Packet SRB %08X\n", pSrb));

    while (QueueRemove (&pSrb, &pFilter->StreamControlSpinLock, &pFilter->StreamControlQueue))
    {
        //
        // determine the type of packet.
        //
        switch (pSrb->Command)
        {
            case SRB_PROPOSE_DATA_FORMAT:
                TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: Receive Control packet handler - Propose data format\n"));
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
                break;

            case SRB_SET_STREAM_STATE:
                TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: Receive Control packet handler - Set Stream State\n"));
                pSrb->Status = STATUS_SUCCESS;
                SlipSetState (pSrb);
                break;

            case SRB_GET_STREAM_STATE:
                TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: Receive Control packet handler - Get Stream State\n"));
                pSrb->Status = STATUS_SUCCESS;
                pSrb->CommandData.StreamState = pStream->KSState;
                pSrb->ActualBytesTransferred = sizeof (KSSTATE);
                break;

            case SRB_GET_STREAM_PROPERTY:
                TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: Receive Control packet handler - Get Stream Property\n"));
                SlipGetProperty(pSrb);
                break;

            case SRB_SET_STREAM_PROPERTY:
                TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: Receive Control packet handler - Set Stream Property\n"));
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
                break;

            case SRB_INDICATE_MASTER_CLOCK:
                TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: Receive Control packet handler - Indicate Master Clock\n"));
                pSrb->Status = STATUS_SUCCESS;
                IndicateMasterClock (pSrb);
                break;

            case SRB_SET_STREAM_RATE:
                TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: Receive Control packet handler - Set Stream Rate\n"));
                pSrb->Status = STATUS_SUCCESS;
                break;

            case SRB_PROPOSE_STREAM_RATE:
                TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: Receive Control packet handler - Propose Stream Rate\n"));
                pSrb->Status = STATUS_SUCCESS;
                break;

            default:
                TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: Receive Control packet handler - Default case\n"));
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
                break;

        }

        TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: SRB Status returned: %08X\n", pSrb->Status));

        StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb);
        TEST_DEBUG( TEST_DBG_SRB, ("SLIP 29Completed SRB %08X\n", pSrb));

    }

}



//////////////////////////////////////////////////////////////////////////////
VOID
SlipSetState(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    PSLIP_FILTER pFilter                 = ((PSLIP_FILTER) pSrb->HwDeviceExtension);
    PSTREAM pStream                      = (PSTREAM) pSrb->StreamObject->HwStreamExtension;
    PHW_STREAM_REQUEST_BLOCK pCurrentSrb = NULL;

    //
    // For each stream, the following states are used:
    //
    // Stop:    Absolute minimum resources are used.  No outstanding IRPs.
    // Acquire: KS only state that has no DirectShow correpondence
    //          Acquire needed resources.
    // Pause:   Getting ready to run.  Allocate needed resources so that
    //          the eventual transition to Run is as fast as possible.
    //          Read SRBs will be queued at either the Stream class
    //          or in your driver (depending on when you send "ReadyForNext")
    // Run:     Streaming.
    //
    // Moving to Stop to Run always transitions through Pause.
    //
    // But since a client app could crash unexpectedly, drivers should handle
    // the situation of having outstanding IRPs cancelled and open streams
    // being closed WHILE THEY ARE STREAMING!
    //
    // Note that it is quite possible to transition repeatedly between states:
    // Stop -> Pause -> Stop -> Pause -> Run -> Pause -> Run -> Pause -> Stop
    //
    KIRQL    Irql= {0};
   KeAcquireSpinLock (&(pStream->KSStateSpinLock), &Irql);

    
    switch (pSrb->CommandData.StreamState)
    {
        case KSSTATE_STOP:

            TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: Set Stream State KSSTATE_STOP\n"));

            //
            // If transitioning to STOP state, then complete any outstanding IRPs
            //
            while (QueueRemove(&pCurrentSrb, &pFilter->IpV4StreamDataSpinLock, &pFilter->IpV4StreamDataQueue))
            {
                pCurrentSrb->Status = STATUS_CANCELLED;
                pCurrentSrb->CommandData.DataBufferArray->DataUsed = 0;

                StreamClassStreamNotification(StreamRequestComplete, pCurrentSrb->StreamObject, pCurrentSrb);
                TEST_DEBUG( TEST_DBG_SRB, ("SLIP 30Completed SRB %08X\n", pCurrentSrb));
            }

            pStream->KSState = pSrb->CommandData.StreamState;
            pSrb->Status = STATUS_SUCCESS;
            break;


        case KSSTATE_ACQUIRE:
            TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: Set Stream State KSSTATE_ACQUIRE\n"));
            pStream->KSState = pSrb->CommandData.StreamState;
            pSrb->Status = STATUS_SUCCESS;
            break;

        case KSSTATE_PAUSE:
            TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: Set Stream State KSSTATE_PAUSE\n"));
            pStream->KSState = pSrb->CommandData.StreamState;
            pSrb->Status = STATUS_SUCCESS;
            break;

        case KSSTATE_RUN:
            TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: Set Stream State KSSTATE_RUN\n"));
            pStream->KSState = pSrb->CommandData.StreamState;
            pSrb->Status = STATUS_SUCCESS;
            break;

    } // end switch (pSrb->CommandData.StreamState)

  KeReleaseSpinLock (&(pStream->KSStateSpinLock), Irql);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\bda\slip\slipmedia.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

#ifndef __MY_MEDIA_H__
#define __MY_MEDIA_H__


#ifdef DEFINE_GUIDEX
#undef DEFINE_GUIDEX
#include <ksguid.h>
#endif

/////////////////////////////////////////////////////////////
//
// OUTPUT PINNAME GUID
//
#define STATIC_PINNAME_IPSINK_INPUT \
    0x3fdffa70L, 0xac9a, 0x11d2, 0x8f, 0x17, 0x00, 0xc0, 0x4f, 0x79, 0x71, 0xe2
DEFINE_GUIDSTRUCT("3fdffa70-ac9a-11d2-8f17-00c04f7971e2", PINNAME_IPSINK_INPUT);
#define PINNAME_IPSINK_INPUT   DEFINE_GUIDNAMED(PINNAME_IPSINK_INPUT)


/////////////////////////////////////////////////////////////
//
// NET CONTROL PINNAME GUID
//
#define STATIC_PINNAME_NET_CONTROL \
    0x390B713BL, 0xEB7D, 0x11d2, 0x8F, 0x37, 0x00, 0xC0, 0x4F, 0x79, 0x71, 0xE2
DEFINE_GUIDSTRUCT("390B713B-EB7D-11d2-8F37-00C04F7971E2", PINNAME_NET_CONTROL);
#define PINNAME_NET_CONTROL   DEFINE_GUIDNAMED(PINNAME_NET_CONTROL)

/////////////////////////////////////////////////////////////
//
// Slip Data Format structure
//
typedef struct tagKS_DATAFORMAT_SLIP
{
   KSDATAFORMAT                 DataFormat;

} KS_DATAFORMAT_SLIP, *PKS_DATAFORMAT_SLIP;




#endif // __MY_MEDIA_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\codec\msyuv\drvproc.c ===
/*----------------------------------------------------------------------+
|                                    |
| drvproc.c - driver procedure                        |
|                                    |
| Copyright (c) 1993 Microsoft Corporation.                |
| All Rights Reserved.                            |
|                                    |
+----------------------------------------------------------------------*/

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>

#include "msyuv.h"

HMODULE ghModule;     // Our DLL module handle


/***************************************************************************
 * DriverProc  -  The entry point for an installable driver.
 *
 * PARAMETERS
 * dwDriverId:  For most messages, <dwDriverId> is the DWORD
 *     value that the driver returns in response to a <DRV_OPEN> message.
 *     Each time that the driver is opened, through the <DrvOpen> API,
 *     the driver receives a <DRV_OPEN> message and can return an
 *     arbitrary, non-zero value. The installable driver interface
 *     saves this value and returns a unique driver handle to the
 *     application. Whenever the application sends a message to the
 *     driver using the driver handle, the interface routes the message
 *     to this entry point and passes the corresponding <dwDriverId>.
 *     This mechanism allows the driver to use the same or different
 *     identifiers for multiple opens but ensures that driver handles
 *     are unique at the application interface layer.
 *
 *     The following messages are not related to a particular open
 *     instance of the driver. For these messages, the dwDriverId
 *     will always be zero.
 *
 *         DRV_LOAD, DRV_FREE, DRV_ENABLE, DRV_DISABLE, DRV_OPEN
 *
 * hDriver: This is the handle returned to the application by the
 *    driver interface.
 *
 * uiMessage: The requested action to be performed. Message
 *     values below <DRV_RESERVED> are used for globally defined messages.
 *     Message values from <DRV_RESERVED> to <DRV_USER> are used for
 *     defined driver protocols. Messages above <DRV_USER> are used
 *     for driver specific messages.
 *
 * lParam1: Data for this message.  Defined separately for
 *     each message
 *
 * lParam2: Data for this message.  Defined separately for
 *     each message
 *
 * RETURNS
 *   Defined separately for each message.
 *
 ***************************************************************************/

LRESULT  DriverProc(PINSTINFO pi, HDRVR hDriver, UINT uiMessage, LPARAM lParam1, LPARAM lParam2)
{

    switch (uiMessage)
    {
    case DRV_LOAD:
        dprintf2((TEXT("DRV_LOAD:\n")));
#ifdef _WIN32
            if (ghModule) {
                // AVI explicitly loads us as well, but does not pass the
                // correct (as known by WINMM) driver handle.
            } else {
                ghModule = (HANDLE) GetDriverModuleHandle(hDriver);
            }
#endif
        return (LRESULT) 1L;

    case DRV_FREE:
        dprintf2((TEXT("DRV_FREE:\n")));
        return (LRESULT)1L;

        case DRV_OPEN:
        dprintf2((TEXT("DRV_OPEN\n")));
        // if being opened with no open struct, then return a non-zero
        // value without actually opening
        if (lParam2 == 0L)
                return 0xFFFF0000;

        return (LRESULT)(DWORD_PTR) Open((ICOPEN FAR *) lParam2);

    case DRV_CLOSE:
        dprintf2((TEXT("DRV_CLOSE:\n")));
#ifdef _WIN32
        if (pi != (PINSTINFO)(ULONG_PTR)0xFFFF0000)
#else
        if (pi)
#endif
        Close(pi);

        return (LRESULT)1L;

    /*********************************************************************

        state messages

    *********************************************************************/

    case DRV_QUERYCONFIGURE:    // configuration from drivers applet
        dprintf2((TEXT("DRV_QUERYCONFIGURE:\n")));
        return (LRESULT)0L;

    case DRV_CONFIGURE:
        dprintf2((TEXT("DRV_CONFIGURE:\n")));
        return DRV_OK;

    case ICM_CONFIGURE:
        dprintf2((TEXT("ICM_CONFIGURE:\n")));
        //
        //  return ICERR_OK if you will do a configure box, error otherwise
        //
        if (lParam1 == -1)
           return QueryConfigure(pi) ? ICERR_OK : ICERR_UNSUPPORTED;
        else
           return Configure(pi, (HWND)lParam1);

   case ICM_ABOUT:
        dprintf2((TEXT("ICM_ABOUT:\n")));
        //
        //  return ICERR_OK if you will do a about box, error otherwise
        //
        if (lParam1 == -1)
           return QueryAbout(pi) ? ICERR_OK : ICERR_UNSUPPORTED;
        else
           return About(pi, (HWND)lParam1);

    case ICM_GETSTATE:
        dprintf1((TEXT("ICM_GETSTATE:\n")));
        return GetState(pi, (LPVOID)lParam1, (DWORD)lParam2);

    case ICM_SETSTATE:
        dprintf1((TEXT("ICM_SETSTATE:\n")));
        return SetState(pi, (LPVOID)lParam1, (DWORD)lParam2);

    case ICM_GETINFO:
        dprintf1((TEXT("ICM_GETINFO:\n")));
        return GetInfo(pi, (ICINFO FAR *)lParam1, (DWORD)lParam2);

    case ICM_GETDEFAULTQUALITY:
        dprintf2((TEXT("ICM_GETDEFAULTQUALITY:\n")));
        if (lParam1) {
            *((LPDWORD)lParam1) = 7500;
            return ICERR_OK;
        }
        break;

#if 0
// NOT SUPPORTED
    /*********************************************************************

        compression messages

    *********************************************************************/

    case ICM_COMPRESS_QUERY:
        dprintf2((TEXT("ICM_COMPRESS_QUERY:\n")));
        return CompressQuery(pi,
             (LPBITMAPINFOHEADER)lParam1,
             (LPBITMAPINFOHEADER)lParam2);

    case ICM_COMPRESS_BEGIN:
        dprintf2((TEXT("ICM_COMPRESS_BEGIN:\n")));
        return CompressBegin(pi,
             (LPBITMAPINFOHEADER)lParam1,
             (LPBITMAPINFOHEADER)lParam2);

    case ICM_COMPRESS_GET_FORMAT:
        dprintf2((TEXT("ICM_COMPRESS_GET_FORMAT:\n")));
        return CompressGetFormat(pi,
             (LPBITMAPINFOHEADER)lParam1,
             (LPBITMAPINFOHEADER)lParam2);

    case ICM_COMPRESS_GET_SIZE:
        dprintf2((TEXT("ICM_COMPRESS_GET_SIZE:\n")));
        return CompressGetSize(pi,
             (LPBITMAPINFOHEADER)lParam1,
             (LPBITMAPINFOHEADER)lParam2);

    case ICM_COMPRESS:
        dprintf2((TEXT("ICM_COMPRESS:\n")));
        return Compress(pi,
                (ICCOMPRESS FAR *)lParam1, (DWORD)lParam2);

    case ICM_COMPRESS_END:
        dprintf2((TEXT("ICM_COMPRESS_END:\n")));
        return CompressEnd(pi);

#endif
    /*********************************************************************

        decompress messages

    *********************************************************************/

    case ICM_DECOMPRESS_QUERY:
        dprintf2((TEXT("\nICM_DECOMPRESS_QUERY:----------------\n")));
        return DecompressQuery(pi,
             (LPBITMAPINFOHEADER)lParam1,
             (LPBITMAPINFOHEADER)lParam2);

    case ICM_DECOMPRESS_BEGIN:
        dprintf2((TEXT("\nICM_DECOMPRESS_BEGIN:\n")));
        return DecompressBegin(pi,
             (LPBITMAPINFOHEADER)lParam1,
             (LPBITMAPINFOHEADER)lParam2);

    case ICM_DECOMPRESS_GET_FORMAT:
        dprintf2((TEXT("\nICM_DECOMPRESS_GET_FORMAT:================\n")));
        return DecompressGetFormat(pi,
             (LPBITMAPINFOHEADER)lParam1,
             (LPBITMAPINFOHEADER)lParam2);

    case ICM_DECOMPRESS_GET_PALETTE:
        dprintf2((TEXT("ICM_DECOMPRESS_GET_PALETTE:\n")));
        return DecompressGetPalette(pi,
             (LPBITMAPINFOHEADER)lParam1,
             (LPBITMAPINFOHEADER)lParam2);

    case ICM_DECOMPRESS:
        dprintf4((TEXT("ICM_DECOMPRESS:\n")));
        return Decompress(pi,
             (ICDECOMPRESS FAR *)lParam1, (DWORD)lParam2);

    case ICM_DECOMPRESS_END:
        dprintf2((TEXT("ICM_DECOMPRESS_END:\n")));
        return DecompressEnd(pi);


    // *EX
    case ICM_DECOMPRESSEX_QUERY:
        dprintf2((TEXT("\nICM_DECOMPRESSEX_QUERY:----------------\n")));
        return DecompressExQuery(pi, (ICDECOMPRESSEX *) lParam1,(DWORD) lParam2);

    case ICM_DECOMPRESSEX:
        dprintf4((TEXT("ICM_DECOMPRESSEX:\n")));
        return DecompressEx(pi, (ICDECOMPRESSEX *) lParam1, (DWORD) lParam2);

    case ICM_DECOMPRESSEX_BEGIN:
        dprintf2((TEXT("\nICM_DECOMPRESSEX_BEGIN:\n")));
        return DecompressExBegin(pi, (ICDECOMPRESSEX *) lParam1,(DWORD) lParam2);;

    case ICM_DECOMPRESSEX_END:
        dprintf2((TEXT("\nICM_DECOMPRESSEX_END:\n")));
        return DecompressExEnd(pi);;



    /*********************************************************************

        draw messages:

    *********************************************************************/
#ifdef ICM_DRAW_SUPPORTED
    case ICM_DRAW_BEGIN:
        dprintf2((TEXT("ICM_DRAW_BEGIN:\n")));
        /*
         * sent when a sequence of draw calls are about to start -
         * enable hardware.
         */
        //return DrawBegin(pi,(ICDRAWBEGIN FAR *)lParam1, (DWORD)lParam2);
        return( (DWORD) ICERR_OK);


    case ICM_DRAW:
        dprintf2((TEXT("ICM_DRAW:\n")));
        /*
         * frame ready for decompress. Since we don't have any pre-buffering,
         * it is ok to render the frame at this time too. If we had
         * pre-buffer, we would queue now, and start clocking frames out
         * on the draw-start message.
         */
        return Draw(pi,(ICDRAW FAR *)lParam1, (DWORD)lParam2);

    case ICM_DRAW_END:
        dprintf2((TEXT("ICM_DRAW_END:\n")));
        /*
         * this message is sent when the sequence of draw calls has finished -
         * note that the final frame should remain rendered!! - so we can't
         * disable the hardware yet.
         */
        //return DrawEnd(pi);
        //return((DWORD) ICERR_OK);


    case ICM_DRAW_WINDOW:
        dprintf2(("ICM_DRAW_WINDOW:\n"));
        /*
         * the window has changed position or z-ordering. re-sync the
         * hardware rendering.
         */
        return(DrawWindow(pi, (PRECT)lParam1));


    case ICM_DRAW_QUERY:
        dprintf2((TEXT("ICM_DRAW_QUERY:\n")));
        /*
         * can we draw this format ? (lParam2 may (should?) be null)
         */
        return DrawQuery(pi,
             (LPBITMAPINFOHEADER)lParam1,
             (LPBITMAPINFOHEADER)lParam2);

    case ICM_DRAW_START:
    case ICM_DRAW_STOP:
        dprintf2((TEXT("ICM_DRAW_START/END:\n")));
        /*
         * only relevant if you have pre-buffering.
         */
        return( (DWORD) ICERR_OK);
#endif

    /*********************************************************************

        standard driver messages

    *********************************************************************/

    case DRV_DISABLE:
    case DRV_ENABLE:
        dprintf2((TEXT("DRV_DISABLE/ENABLE:\n")));
        return (LRESULT)1L;

    case DRV_INSTALL:
    case DRV_REMOVE:
        dprintf2((TEXT("DRV_INSTALL/REMOVE:\n")));
        return (LRESULT)DRV_OK;
    }

    if (uiMessage < DRV_USER) {
        return DefDriverProc((UINT_PTR)pi, hDriver, uiMessage,lParam1,lParam2);
    } else {
        dprintf1((TEXT("DriverProc: ICM message ID (ICM_USER+%d) not supported.\n"), uiMessage-ICM_USER));
        return ICERR_UNSUPPORTED;
    }
}


#ifdef _WIN32
#if 0 // done on DRV_LOAD
BOOL DllInstanceInit(PVOID hModule, ULONG Reason, PCONTEXT pContext)
{
    if (Reason == DLL_PROCESS_ATTACH) {
        ghModule = (HANDLE) hModule;
    DisableThreadLibraryCalls(hModule);
    }
    return TRUE;
}
#endif
#endif
// #else

/****************************************************************************
 * LibMain - Library initialization code.
 *
 * PARAMETERS
 * hModule: Our module handle.
 *
 * wHeapSize: The heap size from the .def file.
 *
 * lpCmdLine: The command line.
 *
 * Returns 1 if the initialization was successful and 0 otherwise.
 ***************************************************************************/
//int NEAR PASCAL LibMain(HMODULE hModule, WORD wHeapSize, LPSTR lpCmdLine)
BOOL FAR PASCAL LibMain(HMODULE hModule, WORD wHeapSize, LPSTR lpCmdLine)
{
    ghModule = hModule;

    return 1;
}

// #endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\bda\slip\slipstream.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

#ifndef __SLIP_STREAM_H__
#define __SLIP_STREAM_H__

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus


// ------------------------------------------------------------------------
// Property set for all video capture streams
// ------------------------------------------------------------------------

DEFINE_KSPROPERTY_TABLE(SlipConnectionProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_CONNECTION_ALLOCATORFRAMING,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(KSALLOCATOR_FRAMING),            // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    )
};

// ------------------------------------------------------------------------
// Array of all of the property sets supported by video streams
// ------------------------------------------------------------------------

DEFINE_KSPROPERTY_SET_TABLE(SlipStreamProperties)
{
    DEFINE_KSPROPERTY_SET
    (
        &KSPROPSETID_Connection,                        // Set
        SIZEOF_ARRAY(SlipConnectionProperties),       // PropertiesCount
        SlipConnectionProperties,                     // PropertyItems
        0,                                              // FastIoCount
        NULL                                            // FastIoTable
    ),
};


#define NUMBER_SLIP_STREAM_PROPERTIES (SIZEOF_ARRAY(SlipStreamProperties))


//---------------------------------------------------------------------------
// All of the video and vbi data formats we might use
//---------------------------------------------------------------------------


KSDATARANGE StreamFormatIPv4 =
{
    //
    // KSDATARANGE
    //
    sizeof (KSDATAFORMAT),
    0,
    1548,               // sizeof a IPv4 Packet
    0,                  // Reserved
    { STATIC_KSDATAFORMAT_TYPE_BDA_IP },
    { STATIC_KSDATAFORMAT_SUBTYPE_BDA_IP },
    { STATIC_KSDATAFORMAT_SPECIFIER_BDA_IP }
};



KSDATARANGE StreamFormatNABTSFEC =
{
    sizeof (KSDATARANGE),
    0,
    sizeof (NABTSFEC_BUFFER),
    0,                  // Reserved
    { STATIC_KSDATAFORMAT_TYPE_NABTS },
    { STATIC_KSDATAFORMAT_SUBTYPE_NABTS_FEC },
    { STATIC_KSDATAFORMAT_SPECIFIER_NONE }
};


//---------------------------------------------------------------------------
//  STREAM_Input Formats
//---------------------------------------------------------------------------

static PKSDATAFORMAT Stream0Formats[] =
{
    (PKSDATAFORMAT) &StreamFormatNABTSFEC


    // Add more formats here for to mirror output formats for "passthrough" mode
    // The idea is that upstream capture drivers may have done some decoding already
    // or downstream drivers may wish to have the raw data without any decoding at all.
    // In that case all we need to do is copy the data(if there is a pending SRB) OR
    // forward the SRB to the downstream client.
};

#define NUM_STREAM_0_FORMATS (SIZEOF_ARRAY(Stream0Formats))


//---------------------------------------------------------------------------
//  STREAM_Output Formats
//---------------------------------------------------------------------------

static PKSDATAFORMAT Stream1Formats[] =
{
    (PKSDATAFORMAT) &StreamFormatIPv4,

    //
    // Add more formats here for whatever output formats are supported.
    //
};
#define NUM_STREAM_1_FORMATS (SIZEOF_ARRAY (Stream1Formats))

//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Create an array that holds the list of all of the streams supported
//---------------------------------------------------------------------------

typedef struct _ALL_STREAM_INFO
{
    HW_STREAM_INFORMATION   hwStreamInfo;
    HW_STREAM_OBJECT        hwStreamObject;

} ALL_STREAM_INFO, *PALL_STREAM_INFO;

static ALL_STREAM_INFO Streams [] =
{
    //
    // NABTS input stream
    //

    {
        // HW_STREAM_INFORMATION -------------------------------------------
        {
            1,                                        // NumberOfPossibleInstances
            KSPIN_DATAFLOW_IN,                        // DataFlow
            TRUE,                                     // DataAccessible
            NUM_STREAM_0_FORMATS,                     // NumberOfFormatArrayEntries
            Stream0Formats,                           // StreamFormatsArray
            0,                                        // ClassReserved[0]
            0,                                        // ClassReserved[1]
            0,                                        // ClassReserved[2]
            0,                                        // ClassReserved[3]
            NUMBER_SLIP_STREAM_PROPERTIES,            // Number of stream properties
            (PKSPROPERTY_SET) SlipStreamProperties,   // Stream Property Array
            0,                                        // NumStreamEventArrayEntries
            0,                                        // StreamEventsArray
            NULL,                                     // Category
            (GUID *)&PINNAME_VIDEO_NABTS,             // Name
            0,                                        // MediumsCount
            NULL,                                     // Mediums
        },

        // HW_STREAM_OBJECT ------------------------------------------------
        {
            sizeof (HW_STREAM_OBJECT),              // SizeOfThisPacket
            0,                                      // StreamNumber
            (PVOID)NULL,                            // HwStreamExtension
            ReceiveDataPacket,
            ReceiveCtrlPacket,
            {                                       // HW_CLOCK_OBJECT
                NULL,                               // .HWClockFunction
                0,                                  // .ClockSupportFlags
            },
            FALSE,                                  // Dma
            TRUE,                                   // Pio
            (PVOID)NULL,                            // HwDeviceExtension
            0,                                      // StreamHeaderMediaSpecific
            0,                                      // StreamHeaderWorkspace
            TRUE,                                   // Allocator
            NULL,                                   // HwEventRoutine
        },
    },

    //
    // IPv4 Control Interface Pin
    //
    {
        // HW_STREAM_INFORMATION -------------------------------------------
        {
            1,                                      // NumberOfPossibleInstances
            KSPIN_DATAFLOW_OUT,                     // DataFlow
            TRUE,                                   // DataAccessible
            NUM_STREAM_1_FORMATS,                   // NumberOfFormatArrayEntries
            Stream1Formats,                         // StreamFormatsArray
            0,                                      // ClassReserved[0]
            0,                                      // ClassReserved[1]
            0,                                      // ClassReserved[2]
            0,                                      // ClassReserved[3]
            NUMBER_SLIP_STREAM_PROPERTIES,          // Number of stream properties
            (PKSPROPERTY_SET) SlipStreamProperties, // Stream Property Array
            0,                                      // NumStreamEventArrayEntries
            0,                                      // StreamEventsArray
            NULL,                                   // Category
            (GUID *)&PINNAME_IPSINK_INPUT,          // Name
            0,                                      // MediumsCount
            NULL,                                   // Mediums
        },

        // HW_STREAM_OBJECT ------------------------------------------------
        {
            sizeof (HW_STREAM_OBJECT),              // SizeOfThisPacket
            0,                                      // StreamNumber
            (PVOID)NULL,                            // HwStreamExtension
            ReceiveDataPacket,                      // HwReceiveDataPacket Handler
            ReceiveCtrlPacket,                      // HwReceiveControlPacket Handler
            {                                       // HW_CLOCK_OBJECT
                NULL,                                // .HWClockFunction
                0,                                   // .ClockSupportFlags
            },
            FALSE,                                  // Dma
            TRUE,                                   // Pio
            (PVOID)NULL,                            // HwDeviceExtension
            0,                                      // StreamHeaderMediaSpecific
            0,                                      // StreamHeaderWorkspace
            TRUE,                                   // Allocator
            NULL,                                   // HwEventRoutine
        },
    }

};

#define DRIVER_STREAM_COUNT (SIZEOF_ARRAY (Streams))


//---------------------------------------------------------------------------
// Topology
//---------------------------------------------------------------------------

// Categories define what the device does.

static GUID Categories[] =
{
    STATIC_KSCATEGORY_BDA_RECEIVER_COMPONENT
};

#define NUMBER_OF_CATEGORIES  SIZEOF_ARRAY (Categories)

static KSTOPOLOGY Topology = {
    NUMBER_OF_CATEGORIES,
    (GUID*) &Categories,
    0,
    (GUID*) NULL,
    0,
    NULL
};


//---------------------------------------------------------------------------
// The Main stream header
//---------------------------------------------------------------------------

static HW_STREAM_HEADER StreamHeader =
{
    DRIVER_STREAM_COUNT,                // NumberOfStreams
    sizeof (HW_STREAM_INFORMATION),     // Future proofing
    0,                                  // NumDevPropArrayEntries set at init time
    NULL,                               // DevicePropertiesArray  set at init time
    0,                                  // NumDevEventArrayEntries;
    NULL,                               // DeviceEventsArray;
    &Topology                           // Pointer to Device Topology
};

#ifdef    __cplusplus
}
#endif // __cplusplus

#endif //  __SLIP_STREAM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\codec\msyuv\debug.c ===
/* Debug.c
 *
 * Debug printf and assertion functions
 */


#include <windows.h>
#include <stdarg.h>
#include <stdio.h>
#include "debug.h"



#ifdef _DEBUG

DWORD ModuleDebugLevel = 1;  // 0 to turn it off, but valid level go up to 4
DWORD ModuleDebugStamp = 0;  // Turn on to print __FILE__.__LINE__

/* _Assert(fExpr, szFile, iLine)
 *
 * If <fExpr> is TRUE, then do nothing.  If <fExpr> is FALSE, then display
 * an "assertion failed" message box allowing the user to abort the program,
 * enter the debugger (the "Retry" button), or igore the error.
 *
 * <szFile> is the name of the source file; <iLine> is the line number
 * containing the _Assert() call.
 */
#ifdef I386
#pragma optimize("", off)
#endif

BOOL FAR PASCAL
_Assert(
    BOOL fExpr, 
	TCHAR * szFile, //LPSTR szFile, 
	int iLine, 
	TCHAR * szExpr) // LPSTR szExpr)
{
	static TCHAR achTitle[256];
	int		id;

	/* check if assertion failed */
	if (fExpr)
		return fExpr;

	/* display error message */
	wsprintf(achTitle, TEXT("AssertFailed: %d:%s\n"), iLine, (LPSTR) szFile);
	id = MessageBox(NULL, szExpr, achTitle, MB_SYSTEMMODAL | MB_ICONHAND | MB_ABORTRETRYIGNORE);

	/* abort, debug, or ignore */
	switch (id)
	{

	case IDABORT:

		/* kill this application */
		ExitProcess(1);
		break;

	case IDRETRY:

		/* break into the debugger */
		DebugBreak();
		break;

	case IDIGNORE:

		/* ignore the assertion failure */
		break;

	}
	
	return FALSE;
}

#ifdef I386
#pragma optimize("", on)
#endif


DWORD dbgSetDebugLevel(int dbgLevel) {
    DWORD oldlevel = ModuleDebugLevel;
    ModuleDebugLevel = dbgLevel;
    return(oldlevel);
}


void PlaceStamp(
    TCHAR * lpszFile, // LPSTR lpszFile, 
	int iLineNum)
{
	TCHAR	szBuf[256];

	int i;
	TCHAR * lpszFilename = lpszFile;

	if (ModuleDebugLevel == 0) 
		return;

	if(ModuleDebugStamp) {	

    	for (i=0; i < lstrlen(lpszFile); i++)
	    	if (*(lpszFile+i) == '\\')
		    	lpszFilename = (lpszFile+i);
		
		if(wsprintf(szBuf, TEXT("MsYuv %12s %4d "), lpszFilename, iLineNum) > 0)
	         OutputDebugString(szBuf);

	} else {
	     OutputDebugString(TEXT("MsYuv.."));
	}
}

void dbgPrintf(TCHAR * szFormat, ...)
{
 	TCHAR	szBuf[256];
	va_list va;

	if (ModuleDebugLevel == 0)
		return;

	va_start(va, szFormat);
	wvsprintf(
		szBuf, 
		szFormat, 
		va);
	va_end(va);
	OutputDebugString(szBuf);
}


#endif  // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\codec\msyuv\debug.h ===
/*
 * debug macros
 *
 */

#if DBG
   #ifndef _DEBUG
      #define _DEBUG
   #endif
#endif

#ifndef _DEBUGH
#define _DEBUGH

#ifdef _DEBUG

    #define ModuleDebugLevel MsYuvDebugLevel
    #define ModuleDebugStamp MsYuvDebugStamp


    extern DWORD ModuleDebugLevel;
    extern DWORD ModuleStamp;

	void PlaceStamp(TCHAR * lpszFile, int iLineNum);
    void dbgPrintf(TCHAR * szFormat, ...);

    #define dprintf1(_x_) {if (ModuleDebugLevel >= 1) {PlaceStamp(__FILE__,__LINE__);dbgPrintf _x_ ;}}
    #define dprintf2(_x_) {if (ModuleDebugLevel >= 2) {PlaceStamp(__FILE__,__LINE__);dbgPrintf _x_ ;}}
    #define dprintf3(_x_) {if (ModuleDebugLevel >= 3) {PlaceStamp(__FILE__,__LINE__);dbgPrintf _x_ ;}}
    #define dprintf4(_x_) {if (ModuleDebugLevel >= 4) {PlaceStamp(__FILE__,__LINE__);dbgPrintf _x_ ;}}

	//BOOL FAR PASCAL _Assert(BOOL fExpr, LPSTR szFile, int iLine, LPSTR szExpr);
	BOOL FAR PASCAL _Assert(BOOL fExpr, TCHAR * szFile, int iLine, TCHAR * szExpr);

	#define ASSERT(expr)  _Assert((expr), __FILE__, __LINE__, #expr)

#else

	#define ASSERT(expr)

    #define dbgPrintf 0?0:
    #define dprintf(_x_)
    #define dprintf1(_x_)
    #define dprintf2(_x_)
    #define dprintf3(_x_)
    #define dprintf4(_x_)		

#endif

#endif // DEBUGH
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\codec\msyuv\msyuv.h ===
/*
 * msyuv.h   Microsoft YUV Codec
 *
 * Copyright (c) Microsoft 1993.
 */

#include <msviddrv.h>
#include <vfw.h>
#include "vcstruct.h"
#include "vcuser.h"
#include "debug.h"


#ifndef FOURCC_UYVY
#define FOURCC_UYVY		mmioFOURCC('U', 'Y', 'V', 'Y')  // UYVY
#endif

#ifndef FOURCC_YUY2
#define FOURCC_YUY2		mmioFOURCC('Y', 'U', 'Y', '2')  // YUYV
#endif

#ifndef FOURCC_YVYU
#define FOURCC_YVYU		mmioFOURCC('Y', 'V', 'Y', 'U')  // YUYV
#endif

typedef struct {
    DWORD   dwFlags;    // flags from ICOPEN
    DWORD 	dwFormat;	// format that pXlate is built for (FOURCC)
    PVOID	pXlate;		// xlate table (for decompress)
    BOOL 	bRGB565;	// true if 5-6-5 format output (otherwise 555)

    /* support for drawing */
    VCUSER_HANDLE vh;
    HWND	hwnd;
    RECT 	rcSource;
    RECT	rcDest;
    HBRUSH	hKeyBrush;


} INSTINFO, *PINSTINFO;




/*
 * message processing functions in msyuv.c
 */
INSTINFO * NEAR PASCAL Open(ICOPEN FAR * icinfo);
DWORD NEAR PASCAL Close(INSTINFO * pinst);
BOOL NEAR PASCAL QueryAbout(INSTINFO * pinst);
DWORD NEAR PASCAL About(INSTINFO * pinst, HWND hwnd);
BOOL NEAR PASCAL QueryConfigure(INSTINFO * pinst);
DWORD NEAR PASCAL Configure(INSTINFO * pinst, HWND hwnd);
DWORD NEAR PASCAL GetState(INSTINFO * pinst, LPVOID pv, DWORD dwSize);
DWORD NEAR PASCAL SetState(INSTINFO * pinst, LPVOID pv, DWORD dwSize);
DWORD NEAR PASCAL GetInfo(INSTINFO * pinst, ICINFO FAR *icinfo, DWORD dwSize);
DWORD FAR PASCAL CompressQuery(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut);
DWORD FAR PASCAL CompressGetFormat(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut);
DWORD FAR PASCAL CompressBegin(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut);
DWORD FAR PASCAL CompressGetSize(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut);
DWORD FAR PASCAL Compress(INSTINFO * pinst, ICCOMPRESS FAR *icinfo, DWORD dwSize);
DWORD FAR PASCAL CompressEnd(INSTINFO * pinst);
DWORD NEAR PASCAL DecompressQuery(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut);
DWORD NEAR PASCAL DecompressGetFormat(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut);
DWORD NEAR PASCAL DecompressBegin(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut);
DWORD NEAR PASCAL Decompress(INSTINFO * pinst, ICDECOMPRESS FAR *icinfo, DWORD dwSize);
DWORD NEAR PASCAL DecompressGetPalette(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut);
DWORD NEAR PASCAL DecompressEnd(INSTINFO * pinst);

DWORD NEAR PASCAL DecompressExQuery(INSTINFO * pinst, ICDECOMPRESSEX * pICD, DWORD dwICDSize);
DWORD NEAR PASCAL DecompressEx(INSTINFO * pinst, ICDECOMPRESSEX * pICD, DWORD dwICDSize);
DWORD NEAR PASCAL DecompressExBegin(INSTINFO * pinst, ICDECOMPRESSEX * pICD, DWORD dwICDSize);
DWORD NEAR PASCAL DecompressExEnd(INSTINFO * pinst);


DWORD DrawQuery(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut);
DWORD DrawBegin(INSTINFO * pinst,ICDRAWBEGIN FAR *icinfo, DWORD dwSize);
DWORD Draw(INSTINFO * pinst, ICDRAW FAR *icinfo, DWORD dwSize);
DWORD DrawEnd(INSTINFO * pinst);
DWORD DrawWindow(PINSTINFO pinst, PRECT prc);



/*
 * build UYVY -> RGB555 xlate table
 */
LPVOID BuildUYVYToRGB555(PINSTINFO pinst);

// build UYVY -> RGB32 xlate table
LPVOID BuildUYVYToRGB32(PINSTINFO pinst);

// build UYVY -> RGB565
LPVOID BuildUYVYToRGB565(PINSTINFO pinst);


// build UYVY -> RGB8
LPVOID BuildUYVYToRGB8(PINSTINFO pinst);

VOID UYVYToRGB32(PINSTINFO pinst,
		 LPBITMAPINFOHEADER lpbiInput,
		 LPVOID lpInput,
		 LPBITMAPINFOHEADER lpbiOutput,
		 LPVOID lpOutput);

VOID UYVYToRGB24(PINSTINFO pinst,
		 LPBITMAPINFOHEADER lpbiInput,
		 LPVOID lpInput,
		 LPBITMAPINFOHEADER lpbiOutput,
		 LPVOID lpOutput);

/*
 * translate one frame from uyvy to rgb 555 or 565
 */

VOID UYVYToRGB16(PINSTINFO pinst,
		 LPBITMAPINFOHEADER lpbiInput,
		 LPVOID lpInput,
		 LPBITMAPINFOHEADER lpbiOutput,
		 LPVOID lpOutput);

/*
 * translate one frame from uyvy to RGB8
 */

VOID UYVYToRGB8(PINSTINFO pinst,
		 LPBITMAPINFOHEADER lpbiInput,
		 LPVOID lpInput,
		 LPBITMAPINFOHEADER lpbiOutput,
		 LPVOID lpOutput);

VOID FreeXlate(PINSTINFO pinst);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\codec\msyuv\msyuv.c ===
/*----------------------------------------------------------------------+
| msyuv.c - Microsoft YUV Codec                                         |
|                                                                       |
| Copyright (c) 1993 Microsoft Corporation.                             |
| All Rights Reserved.                                                  |
|                                                                       |
+----------------------------------------------------------------------*/

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>

#ifndef _WIN32
#include "stdarg.h"
#endif

#ifdef _WIN32
#include <memory.h>        /* for memcpy */
#endif

#include "msyuv.h"

// ICINFO use WCHAR if _WIN32 is #defined; so force it to use WCHAR; where else are TCHAR
WCHAR    szDescription[] = L"Microsoft YUV";
WCHAR    szName[]        = L"MS-YUV";
WCHAR    szAbout[]       = L"About";

#define VERSION         0x00010000      // 1.0

// pull these in from amvideo.h
#define WIDTHBYTES(bits) ((DWORD)(((bits)+31) & (~31)) / 8)
#define DIBWIDTHBYTES(bi) (DWORD)WIDTHBYTES((DWORD)(bi)->biWidth * (DWORD)(bi)->biBitCount)
#define _DIBSIZE(bi) (DIBWIDTHBYTES(bi) * (DWORD)(bi)->biHeight)
#define DIBSIZE(bi) ((bi)->biHeight < 0 ? (-1)*(_DIBSIZE(bi)) : _DIBSIZE(bi))
        
/*****************************************************************************
 ****************************************************************************/
INSTINFO * NEAR PASCAL Open(ICOPEN FAR * icinfo)
{
    INSTINFO *  pinst;

    //
    // refuse to open if we are not being opened as a Video compressor
    //
    if (icinfo->fccType != ICTYPE_VIDEO)
        return NULL;

    // dwFlags contain wMode
    // Only support Decompress mode (or for Query purpose)
    if(   icinfo->dwFlags != ICMODE_DECOMPRESS              
       && icinfo->dwFlags != ICMODE_QUERY            // Open for infomational purpose
      ) {
        
        dprintf1((TEXT("Open: unsupported wMode=%d\n"), icinfo->dwFlags));
        return NULL;
    }


    pinst = (INSTINFO *)LocalAlloc(LPTR, sizeof(INSTINFO));

    if (!pinst) {
        icinfo->dwError = (DWORD)ICERR_MEMORY;
        return NULL;
    }

    //
    // init structure
    //
    pinst->dwFlags = icinfo->dwFlags;
    pinst->pXlate = NULL;

    //
    // return success.
    //
    icinfo->dwError = ICERR_OK;

    return pinst;
}

/*****************************************************************************
 ****************************************************************************/
DWORD NEAR PASCAL Close(INSTINFO * pinst)
{

    if (pinst->pXlate) {
        DecompressEnd(pinst);
    }

#ifdef ICM_DRAW_SUPPORTED
    if (pinst->vh) {
        dprintf1((TEXT("  pinst->vh = 0x%x\n"), pinst->vh));

        DrawEnd(pinst);
    }
#endif    


    LocalFree((HLOCAL)pinst);

    return 1;
}


/*****************************************************************************
 ****************************************************************************/

BOOL NEAR PASCAL QueryAbout(INSTINFO * pinst)
{
    return TRUE;
}

DWORD NEAR PASCAL About(INSTINFO * pinst, HWND hwnd)
{
    MessageBoxW(hwnd,szDescription,szAbout,MB_OK|MB_ICONINFORMATION);
    return ICERR_OK;
}

/*****************************************************************************
 ****************************************************************************/
BOOL NEAR PASCAL QueryConfigure(INSTINFO * pinst)
{
    return FALSE;
}

DWORD NEAR PASCAL Configure(INSTINFO * pinst, HWND hwnd)
{
    return (TRUE);
}

/*****************************************************************************
 ****************************************************************************/
/*
 * lossless translation - hence no need for state adjustments
 */
DWORD NEAR PASCAL GetState(INSTINFO * pinst, LPVOID pv, DWORD dwSize)
{
        return 0;

}

/*****************************************************************************
 ****************************************************************************/
DWORD NEAR PASCAL SetState(INSTINFO * pinst, LPVOID pv, DWORD dwSize)
{
    return(0);
}

/*****************************************************************************
 ****************************************************************************/
DWORD NEAR PASCAL GetInfo(INSTINFO * pinst, ICINFO FAR *icinfo, DWORD dwSize)
{
    if (icinfo == NULL)
        return sizeof(ICINFO);

    if (dwSize < sizeof(ICINFO))
        return 0;

    icinfo->dwSize            = sizeof(ICINFO);
    icinfo->fccType           = ICTYPE_VIDEO;
    icinfo->fccHandler        = FOURCC_UYVY; // default UYVY and also supports YUYV/YUY2; 
    icinfo->dwFlags           = 0;
    icinfo->dwVersion         = VERSION;
    icinfo->dwVersionICM      = ICVERSION;
    wcscpy(icinfo->szDescription, szDescription);
    wcscpy(icinfo->szName, szName);

    return sizeof(ICINFO);
}

/*****************************************************************************
 ****************************************************************************/
DWORD FAR PASCAL CompressQuery(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut)
{
    return ((DWORD) ICERR_BADFORMAT);
}

/*****************************************************************************
 ****************************************************************************/
DWORD FAR PASCAL CompressGetFormat(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut)
{

    return((DWORD) ICERR_BADFORMAT);

}

/*****************************************************************************
 ****************************************************************************/


DWORD FAR PASCAL CompressBegin(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut)
{

    return((DWORD) ICERR_ERROR);

}

/*****************************************************************************
 ****************************************************************************/
DWORD FAR PASCAL CompressGetSize(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut)
{
    return (0);
}

/*****************************************************************************
 ****************************************************************************/
DWORD FAR PASCAL Compress(INSTINFO * pinst, ICCOMPRESS FAR *icinfo, DWORD dwSize)
{
    return((DWORD) ICERR_ERROR);

}

/*****************************************************************************
 ****************************************************************************/
DWORD FAR PASCAL CompressEnd(INSTINFO * pinst)
{
    return (DWORD)ICERR_ERROR;

}




/*****************************************************************************
 ****************************************************************************/
DWORD NEAR PASCAL DecompressQuery(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut)
{
    //
    // determine if the input DIB data is in a format we like.
    //
    if (lpbiIn                == NULL         ||
        lpbiIn->biBitCount    != 16           ||  
        (lpbiIn->biCompression != FOURCC_UYVY &&
         lpbiIn->biCompression != FOURCC_YUY2 &&
         lpbiIn->biCompression != FOURCC_YVYU )) {
        dprintf1((TEXT("Bad input format: lpbiIn=%x; In.biBitCount=%d; FourCC %x != UYVY or YUY2\n"), 
            lpbiIn, lpbiIn->biBitCount, lpbiIn->biCompression));
        return (DWORD)ICERR_BADFORMAT;
    }


    //
    //  are we being asked to query just the input format?
    //
    if (lpbiOut == NULL) {
        return ICERR_OK;
    }

    /* must be 1:1 (no stretching) */
    if ((lpbiOut->biWidth != lpbiIn->biWidth) ||
        (abs(lpbiOut->biHeight) != abs(lpbiIn->biHeight))) {

        dprintf1((TEXT("##### Can't stretch: %dx%d != %dx%d\n"),
            lpbiIn->biWidth, lpbiIn->biHeight,
            lpbiOut->biWidth, lpbiOut->biHeight));

        return((DWORD) ICERR_BADFORMAT);
    }


    /*
     * we translate to 32/24/16/8 bits RGB
     */

    if (lpbiOut->biBitCount != 16 && lpbiOut->biBitCount != 8 && lpbiOut->biBitCount != 32 && lpbiOut->biBitCount != 24) {
        return((DWORD) ICERR_BADFORMAT);
    }

    dprintf2((TEXT("DeCmQry: In4CC(%x,%s)<==>Out(%x,%s); RGB565(%s);\n"),
           lpbiIn->biCompression,
           (CHAR *) &lpbiOut->biCompression,
           lpbiOut->biCompression,
           lpbiOut->biCompression == BI_RGB ? "RGB" : (CHAR *) &lpbiOut->biCompression,
           pinst->bRGB565?"T":"F"));

   dprintf2((TEXT(" In:%dx%dx%d=%d; Out:%dx%dx%d=%d\n"),
           lpbiIn->biWidth, lpbiIn->biHeight, lpbiIn->biBitCount, lpbiIn->biSizeImage,
           lpbiOut->biWidth, lpbiOut->biHeight, lpbiOut->biBitCount, lpbiOut->biSizeImage));


    // check output format to make sure we can convert to this
    // must be full dib
    if(lpbiOut->biCompression == BI_RGB) {
       dprintf2((TEXT("$$$$$ RGB: BI_RGB output\n")));
        pinst->bRGB565 = FALSE;

    } else if ((lpbiOut->biCompression == BI_BITFIELDS) &&
        (lpbiOut->biBitCount == 16 || lpbiOut->biBitCount == 8) &&
        (((LPDWORD)(lpbiOut+1))[0] == 0x00f800) &&
        (((LPDWORD)(lpbiOut+1))[1] == 0x0007e0) &&
        (((LPDWORD)(lpbiOut+1))[2] == 0x00001f))  {
        dprintf2((TEXT("$$$$$ BITF: rgb565 output\n")));
        pinst->bRGB565 = TRUE;

// Pass thru case:
        // !!! this is broken, since it will allow copying from
        // any of the three YUV formats to any of the others, and
        // we actually don't do this. If the AviDec allowed going from
        // YUV to YUV, we would see odd colors!
    } else if (lpbiOut->biCompression == FOURCC_UYVY || 
               lpbiOut->biCompression == FOURCC_YUY2 ||   
               lpbiOut->biCompression == FOURCC_YVYU ) {  
        if( lpbiIn->biCompression != lpbiOut->biCompression )
        {
            dprintf1((TEXT("cannot convert between YUV formats\n")));
            return (DWORD)ICERR_BADFORMAT;
        }
        dprintf2((TEXT("$$$$$ UYVY: rgb555 output\n")));
        pinst->bRGB565 = FALSE;
    } else {
        dprintf1((TEXT("bad compression for output\n")));
        return (DWORD)ICERR_BADFORMAT;
    }

    return ICERR_OK;
}

/*****************************************************************************
 ****************************************************************************/
DWORD NEAR PASCAL DecompressGetFormat(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut)
{
    DWORD dw;

    // Check input format only since lpbiOut is being asked for
    dw = DecompressQuery(pinst, lpbiIn, NULL);
    if (dw != ICERR_OK) {
        return dw;
    }

    //
    // if lpbiOut == NULL then, return the size required to hold a output
    // format
    //
    if (lpbiOut == NULL) {
        dprintf2((TEXT("get format size query\n")));
        return (int)lpbiIn->biSize + (int)lpbiIn->biClrUsed * sizeof(RGBQUAD);
    }

    memcpy(lpbiOut, lpbiIn, (int)lpbiIn->biSize + (int)lpbiIn->biClrUsed * sizeof(RGBQUAD));
    lpbiOut->biCompression = BI_RGB; 
    lpbiOut->biBitCount = 24; // we suggest 24 bit
    lpbiOut->biSizeImage = DIBSIZE( lpbiOut );

    dprintf2((TEXT("DeCmpGFmt: In:%dx%dx%d=%d; RGB565(%s); Out:%dx%dx%d=%d\n"),
        lpbiIn->biWidth, lpbiIn->biHeight, lpbiIn->biBitCount, lpbiIn->biSizeImage,
        pinst->bRGB565?TEXT("T"):TEXT("F"),
        lpbiOut->biWidth, lpbiOut->biHeight, lpbiOut->biBitCount, lpbiOut->biSizeImage));

    return ICERR_OK;
}



/*****************************************************************************
 ****************************************************************************/
DWORD NEAR PASCAL DecompressBegin(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut)
{
    DWORD dw;


    /* check that the conversion formats are valid */
    dw = DecompressQuery(pinst, lpbiIn, lpbiOut);
    if (dw != ICERR_OK) {
        return dw;
    }

    dprintf2((TEXT("DeCmBegin: In4CC(%x,%s)<==>Out(%x,%s); RGB565(%s);\n"),
        lpbiIn->biCompression,
        (PTCHAR) &lpbiOut->biCompression, //"UYVY",
        lpbiOut->biCompression,
        lpbiOut->biCompression == BI_RGB ? "RGB" : (PTCHAR) &lpbiOut->biCompression,
        pinst->bRGB565?TEXT("T"):TEXT("F")));

    dprintf2((TEXT(" In:%dx%dx%d=%d; Out:%dx%dx%d=%d\n"),
        lpbiIn->biWidth, lpbiIn->biHeight, lpbiIn->biBitCount, lpbiIn->biSizeImage,
        lpbiOut->biWidth, lpbiOut->biHeight, lpbiOut->biBitCount, lpbiOut->biSizeImage));



    /* init the yuv-to-rgb55 xlate table if not already inited */

    /* free up the existing table if the formats differ */
    if (lpbiIn->biCompression != pinst->dwFormat) {
        if (pinst->pXlate != NULL) {
            DecompressEnd(pinst);
       }
    }

    if (pinst->pXlate == NULL) {

        switch(lpbiIn->biCompression) {
        case FOURCC_YUY2:
        case FOURCC_UYVY:
        case FOURCC_YVYU:
        {
            switch( lpbiOut->biBitCount ) {
            case 8:
            {
                dprintf3((TEXT("pinst->pXlate = BuildUYVYToRGB8()\n")));
                pinst->pXlate = BuildUYVYToRGB8(pinst);
                break;
            }
            case 16:
            {
                if (pinst->bRGB565) {
                    dprintf3((TEXT("pinst->pXlate = BuildUYVYToRGB565()\n")));
                    pinst->pXlate = BuildUYVYToRGB565(pinst);

                } else {
                    dprintf3((TEXT("pinst->pXlate = BuildUYVYToRGB555()\n")));
                    pinst->pXlate = BuildUYVYToRGB555(pinst);
                }
                break;
            }
            case 24:
            {
                dprintf3((TEXT("pinst->pXlate = BuildUYVYToRGB32()\n")));
                pinst->pXlate = BuildUYVYToRGB32(pinst);
                break;
            }
            case 32:
            {
                dprintf3((TEXT("pinst->pXlate = BuildUYVYToRGB32()\n")));
                pinst->pXlate = BuildUYVYToRGB32(pinst);
                break;
            }
            default:
            {
                dprintf1((TEXT("Supported UYUV->RGB but unsupported output bitcount (%d); return ICERR_BADFOPRMAT\n"), lpbiOut->biBitCount));
                return((DWORD) ICERR_BADFORMAT);

            }
            } // switch biBitCount

            break;
        } // case FOURCC_ACCEPTABLE

        default:
            dprintf1((TEXT("UnSupported FourCC; return ICERR_BADFOPRMAT\n")));
            return((DWORD) ICERR_BADFORMAT);
        }

        if( ( lpbiOut->biBitCount != 8 ) && ( pinst->pXlate == NULL ) ) {
            dprintf1((TEXT("return ICERR_MEMORY\n")));
            return((DWORD) ICERR_MEMORY);
        }

        pinst->dwFormat = lpbiIn->biCompression;
    }

    return(ICERR_OK);

}

/*****************************************************************************
 ****************************************************************************/
DWORD NEAR PASCAL Decompress(INSTINFO * pinst, ICDECOMPRESS FAR *icinfo, DWORD dwSize)
{
    ASSERT(pinst && icinfo);
    if (!pinst || !icinfo)
        return((DWORD) ICERR_ERROR);

    if (pinst->dwFormat == FOURCC_UYVY ||
        pinst->dwFormat == FOURCC_YUY2 ||
        pinst->dwFormat == FOURCC_YVYU) {

        switch( icinfo->lpbiOutput->biBitCount )
        {
        case 8:
        {
            UYVYToRGB8(pinst,
                icinfo->lpbiInput,
                icinfo->lpInput,
                icinfo->lpbiOutput,
                icinfo->lpOutput);
            break;
        }
        case 16:
        {
            /* must have been a DecompressBegin first */
            if (pinst->pXlate == NULL) {
                dprintf1((TEXT("Decompress: pinst->pXlate == NULL\n")));
                return((DWORD) ICERR_ERROR);
            }
            UYVYToRGB16(pinst,
                icinfo->lpbiInput,
                icinfo->lpInput,
                icinfo->lpbiOutput,
                icinfo->lpOutput);
            break;
        }
        case 24:
        {
            if (pinst->pXlate == NULL) {
                dprintf1((TEXT("Decompress: pinst->pXlate == NULL\n")));
                return((DWORD) ICERR_ERROR);
            }
            UYVYToRGB24(pinst,
                icinfo->lpbiInput,
                icinfo->lpInput,
                icinfo->lpbiOutput,
                icinfo->lpOutput);
            break;
        }
        case 32:
        {
            if (pinst->pXlate == NULL) {
                dprintf1((TEXT("Decompress: pinst->pXlate == NULL\n")));
                return((DWORD) ICERR_ERROR);
            }
            UYVYToRGB32(pinst,
                icinfo->lpbiInput,
                icinfo->lpInput,
                icinfo->lpbiOutput,
                icinfo->lpOutput);
            break;
        }
        default:
        {
            dprintf1((TEXT("Decompress: Unsupported output bitcount(%d)\n"), icinfo->lpbiOutput->biBitCount)); 
        }
        } // switch bit count
    }


    return ICERR_OK;
}



/*****************************************************************************
 ****************************************************************************/
DWORD NEAR PASCAL DecompressEnd(INSTINFO * pinst)
{
    if (pinst->pXlate) {
        // 16bit RGB LUT is built dynamically.
        FreeXlate(pinst);
    }

    pinst->dwFormat = 0;

    return ICERR_OK;
}


/*****************************************************************************
    ehr: DecompressExQuery and DecompressEx don't suppor what they should
    support. DecompressEx should also support "normal" decompressing, that is,
    the same thing that Decompress would support. But it doesn't, it only
    supports memcpying the bitmap, which is really odd.
 ****************************************************************************/

/*
ICM_DECOMPRESSEX_QUERY wParam = (DWORD) (LPVOID) &icdex; 
lParam = sizeof(ICDECOMPRESSEX);

typedef struct {     
    DWORD              dwFlags; 
    LPBITMAPINFOHEADER lpbiSrc;     
    LPVOID             lpSrc; 
    LPBITMAPINFOHEADER lpbiDst;     
    LPVOID             lpDst; 
    int                xDst;     
    int                yDst; 
    int                dxDst;     
    int                dyDst; 
    int                xSrc;     
    int                ySrc; 
    int                dxSrc;     
    int                dySrc; } ICDECOMPRESSEX;  
*/ 
DWORD NEAR PASCAL DecompressExQuery(INSTINFO * pinst, ICDECOMPRESSEX * pICD, DWORD dwICDSize)
{
    LPBITMAPINFOHEADER pbmSrc, pbmDst;

    if (pICD == NULL) {
       dprintf1(("DeCmQEx: pICD== NULL\n"));
       return (DWORD)ICERR_BADFORMAT;
    }

    pbmSrc = pICD->lpbiSrc;
    pbmDst = pICD->lpbiDst;

    //
    // determine if the input DIB data is in a format we like.
    //
    if (pbmSrc                == NULL     ||
        pbmSrc->biBitCount    != 16       ||
        (pbmSrc->biCompression != FOURCC_UYVY &&
         pbmSrc->biCompression != FOURCC_YUY2 &&
         pbmSrc->biCompression != FOURCC_YVYU)) {

        dprintf1((TEXT("Bad input format: pbmSrc=%x; Src.biBitCount=%d; FourCC!= UYVY\n"), pbmSrc, pbmSrc->biBitCount));
        return (DWORD)ICERR_BADFORMAT;
    }

    dprintf2(("DeCmQEx: dwFlags=0x%x Src(%dx%dx%d=%d %s) Dst(%dx%dx%d=%d %s)\n",
        pICD->dwFlags,
        pbmSrc->biWidth, pbmSrc->biHeight, pbmSrc->biBitCount, pbmSrc->biSizeImage, (PTCHAR *) &pbmSrc->biCompression,
        pbmDst->biWidth, pbmDst->biHeight, pbmDst->biBitCount, pbmDst->biSizeImage, (PTCHAR *) &pbmDst->biCompression));
    dprintf2(("DeCmQEx:  SrcPoint(%d,%d) SizeSrc(%d,%d); DstPoint(%d,%d) SizeDst(%d,%d);\n",
        pICD->xSrc, pICD->ySrc, pICD->dxSrc, pICD->dySrc,
        pICD->xDst, pICD->yDst, pICD->dxDst, pICD->dyDst));

    /* must be 1:1 (no stretching) */
    if ((pbmDst->biWidth       != pbmSrc->biWidth)       ||
        (abs(pbmDst->biHeight) != abs(pbmSrc->biHeight)) ||  // Sign is ignored for YUV->YUV
        (pbmDst->biBitCount    != pbmSrc->biBitCount)    ||
        (pbmDst->biCompression != pbmSrc->biCompression) ||  // Pass thru
        // Start from the same origin        
        (pICD->xSrc            != 0                    ) || 
        (pICD->ySrc            != 0                    ) || 
        (pICD->xDst            != 0                    ) ||
        (pICD->yDst            != 0                    ) ||
        // 1:1
        (pICD->dxSrc           != pbmSrc->biWidth      ) ||
        (pICD->dySrc           != abs(pbmSrc->biHeight)) ||
        (pICD->dxDst           != pbmDst->biWidth      ) ||
        (pICD->dyDst           != abs(pbmDst->biHeight)) 
        ) {

        dprintf1((TEXT("DeCmQEx: Src/Dst format does not MATCH!\n")));
        return((DWORD) ICERR_BADFORMAT);
    }


    return (DWORD)ICERR_OK;
}

/*****************************************************************************
  This routine support transferring data to a DirectDraw rendering surface, 
  which always uses a top-down orientation with its lowest video address
  in the upper-left corder.
  Note: no stretching is supported.
 ****************************************************************************/
DWORD NEAR PASCAL DecompressEx(INSTINFO * pinst, ICDECOMPRESSEX * pICD, DWORD dwICDSize)
{
    LPBITMAPINFOHEADER pbmSrc, pbmDst;
    PBYTE pSrc, pDst;
    int Height, Width, WidthBytes, StrideWidthBytes;

    if(pICD == NULL) {
        dprintf1((TEXT("DeCmEx: pICD== NULL\n")));
        return (DWORD)ICERR_BADFORMAT;
    }

    pbmSrc = pICD->lpbiSrc;
    pbmDst = pICD->lpbiDst;

    if(pbmSrc->biCompression != pbmDst->biCompression) {
       dprintf1((TEXT("DeCmEx: Compression does not match! In(%s) != Out(%s)\n"), (PTCHAR) &pbmSrc->biCompression, (PTCHAR) &pbmDst->biCompression));
       return (DWORD)ICERR_BADFORMAT;
    }

    // Since no stretching, 
    //    SrcHeight == DstHeight
    //    SrcWidth  == DstWidth
    Height     = abs(pbmSrc->biHeight);
    Width      = pbmSrc->biWidth;
    WidthBytes = Width * pbmSrc->biBitCount / 8;

    StrideWidthBytes = pbmDst->biWidth * pbmDst->biBitCount / 8;

    pSrc = (PBYTE) pICD->lpSrc;

    /*
     * adjust the destination to point to the start of the last line, 
     * and work upwards (to flip vertically into DIB format) 
     * if biHeight for In/Out are different.  Else Top/down.
     */

    pDst = (PBYTE)pICD->lpDst;

    dprintf2(("DeCmEx: %dx%d; (%x %dx%dx%d=%d); (%x %dx%dx%d=%d); Stride=%d\n",
               Width, Height,
               (PCHAR) &pbmSrc->biCompression,
               pbmSrc->biWidth, pbmSrc->biHeight, pbmSrc->biBitCount, pbmSrc->biSizeImage, 
               (PCHAR) &pbmDst->biCompression,
               pbmDst->biWidth, pbmDst->biHeight, pbmDst->biBitCount, pbmDst->biSizeImage,
               StrideWidthBytes));

    ASSERT((pbmDst->biSizeImage <= pbmSrc->biSizeImage));

    // No stretching
    // pbmSrc->biSizeImage may not been defined so the image size is calculated from its 
    // known value of width, height and bitcount.
    memcpy(pDst, pSrc, Width * Height * pbmSrc->biBitCount / 8);


    return ICERR_OK;
}

/*****************************************************************************
 ****************************************************************************/
DWORD NEAR PASCAL DecompressExBegin(INSTINFO * pinst, ICDECOMPRESSEX * pICD, DWORD dwICDSize)
{
    DWORD dwRtn;
    LPBITMAPINFOHEADER pbmSrc, pbmDst;

    if (pICD == NULL) {
        dprintf1(("DeCmExBegin: pICD== NULL\n"));
        return (DWORD)ICERR_BADFORMAT;
    }

    pbmSrc = pICD->lpbiSrc;
    pbmDst = pICD->lpbiDst;

    /* check that the conversion formats are valid */
    dwRtn = DecompressExQuery(pinst, pICD, dwICDSize);
    if (dwRtn != ICERR_OK) {
        dprintf1(("DeCmExBegin return 0x%x", dwRtn));
        return dwRtn;
    }

    // No need to allocate any buffer

    dprintf1(("DeCmExBegin return ICERR_OK\n"));
    return ICERR_OK;
}

/*****************************************************************************
 ****************************************************************************/
DWORD NEAR PASCAL DecompressExEnd(INSTINFO * pinst)
{
    pinst->dwFormat = 0;

    return ICERR_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\codec\tsbyuv\debug.c ===
/* Debug.c
 *
 * Debug printf and assertion functions
 */


#include <windows.h>
#include <stdarg.h>
#include <stdio.h>
#include "debug.h"



#ifdef _DEBUG

DWORD ModuleDebugLevel = 1;  // 0 to turn it off, but valid level go up to 4
DWORD ModuleDebugStamp = 0;  // Turn on to print __FILE__.__LINE__

/* _Assert(fExpr, szFile, iLine)
 *
 * If <fExpr> is TRUE, then do nothing.  If <fExpr> is FALSE, then display
 * an "assertion failed" message box allowing the user to abort the program,
 * enter the debugger (the "Retry" button), or igore the error.
 *
 * <szFile> is the name of the source file; <iLine> is the line number
 * containing the _Assert() call.
 */
#ifdef I386
#pragma optimize("", off)
#endif

BOOL FAR PASCAL
_Assert(
    BOOL fExpr, 
	TCHAR * szFile, //LPSTR szFile, 
	int iLine, 
	TCHAR * szExpr) // LPSTR szExpr)
{
	static TCHAR achTitle[256];
	int		id;

	/* check if assertion failed */
	if (fExpr)
		return fExpr;

	/* display error message */
	wsprintf(achTitle, TEXT("AssertFailed: %d:%s\n"), iLine, (LPSTR) szFile);
	id = MessageBox(NULL, szExpr, achTitle, MB_SYSTEMMODAL | MB_ICONHAND | MB_ABORTRETRYIGNORE);

	/* abort, debug, or ignore */
	switch (id)
	{

	case IDABORT:

		/* kill this application */
		ExitProcess(1);
		break;

	case IDRETRY:

		/* break into the debugger */
		DebugBreak();
		break;

	case IDIGNORE:

		/* ignore the assertion failure */
		break;

	}
	
	return FALSE;
}

#ifdef I386
#pragma optimize("", on)
#endif


DWORD dbgSetDebugLevel(int dbgLevel) {
    DWORD oldlevel = ModuleDebugLevel;
    ModuleDebugLevel = dbgLevel;
    return(oldlevel);
}


void PlaceStamp(
    TCHAR * lpszFile, // LPSTR lpszFile, 
	int iLineNum)
{
	TCHAR	szBuf[256];

	int i;
	TCHAR * lpszFilename = lpszFile;

	if (ModuleDebugLevel == 0) 
		return;

	if(ModuleDebugStamp) {	

    	for (i=0; i < lstrlen(lpszFile); i++)
	    	if (*(lpszFile+i) == '\\')
		    	lpszFilename = (lpszFile+i);
		
		if(wsprintf(szBuf, TEXT("MsYuv %12s %4d "), lpszFilename, iLineNum) > 0)
	         OutputDebugString(szBuf);

	} else {
	     OutputDebugString(TEXT("MsYuv.."));
	}
}

void dbgPrintf(TCHAR * szFormat, ...)
{
 	TCHAR	szBuf[256];
	va_list va;

	if (ModuleDebugLevel == 0)
		return;

	va_start(va, szFormat);
	wvsprintf(
		szBuf, 
		szFormat, 
		va);
	va_end(va);
	OutputDebugString(szBuf);
}


#endif  // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\codec\msyuv\vcstruct.h ===
/*
 * Copyright (c) Microsoft Corporation 1993. All Rights Reserved.
 */

/*
 * vcstruct.h
 *
 * 32-bit Video Capture Driver
 *
 * This header describes structures used in the interface between the
 * kernel driver and the user-mode dll.
 *
 * Geraint Davies, Feb 93.
 */

#ifndef _VCSTRUCT_
#define _VCSTRUCT_

/* --- configuration ------------------------------------------------- */

/*
 * this structure contains configuration information generated
 * by the hardware-specific dialogs and sent to the hardware-specific
 * kernel-mode code. No one else knows its format.
 *
 * these generic structures are used so that driver writers can
 * change the user-mode dialogs and the supporting hardware-specific code
 * and yet still use the common code for interfacing between the
 * two and dealing with NT.
 */

typedef struct _CONFIG_INFO {
    ULONG ulSize;		/* size of struct including size field */
    BYTE ulData[1];		/* (ulSize - sizeof(ULONG)) bytes of data */
} CONFIG_INFO, *PCONFIG_INFO;



/* --- overlay keying and region setting ---------------------------- */


typedef struct _OVERLAY_MODE {
    ULONG ulMode;
} OVERLAY_MODE, *POVERLAY_MODE;

/* values for overlay mode field - or-ed together */
#define VCO_KEYCOLOUR		1	// true if a key colour supported
#define VCO_KEYCOLOUR_FIXED	2	// if not true, you can change it
#define VCO_KEYCOLOUR_RGB	4	// if not true, use palette index
#define VCO_SIMPLE_RECT		8	// if true, supports a single rect	
#define VCO_COMPLEX_REGION	0x10	// if true, supports complex regions.

/*
 * values indicating whether we can put data back into the frame
 * buffer for overlaying (we support the DrawFrame ioctl for the
 * Y411 and/or S422 formats
 */
#define VCO_CAN_DRAW_Y411	0x20	// 7-bit 4:1:1 yuv ala bravado
#define VCO_CAN_DRAW_S422	0x40	// 8-bit 4:2:2 yuv ala spigot
#define VCO_CAN_DRAW		0x60	// for testing: can he draw anything?


typedef struct _OVERLAY_RECTS {
    ULONG ulCount;	    // total number of rects in array
    RECT rcRects[1];	    // ulCount rectangles.
}OVERLAY_RECTS, *POVERLAY_RECTS;


typedef RGBQUAD * PRGBQUAD;

/* --- frame capture ------------------------------------------------ */

/*
 * declaring a real LPVIDEOHDR in the kernel driver is too much of a
 * pain with header files. So the kernel interface will use this declaration
 */
typedef struct _CAPTUREBUFFER {
    PUCHAR	lpData;		    /* buffer data area */
    ULONG	BufferLength;	    /* length of buffer */
    ULONG 	BytesUsed;	    /* actual bytes of data (size of dib) */
    ULONG	TimeCaptured;	    /* millisec time stamp */
    PVOID	Context;	    /* pointer to user context data */
    DWORD       dwFlags;            /* not used by kernel interface */

    /*
     * remaining are declared as 4 reserved dwords in orig struct
     * we use these fields for partial-frame requests
     */
    DWORD 	dwWindowOffset;	    /* current window offset from
				     * start of buffer
				     */
    DWORD	dwWindowLength;	    /* length of current window */

    DWORD       dwReserved[2];          /* not used */

} CAPTUREBUFFER, * PCAPTUREBUFFER;



/* --- drawing ------------------------------------------------------- */

/*
 * used by sample hardware codec to write data back into frame buffer
 */
typedef struct _DRAWBUFFER {
    PUCHAR	lpData;		/* frame data to be drawn */
    ULONG	ulWidth;	/* width of frame in pixels */
    ULONG	ulHeight;	/* height of frame in pixels */
    ULONG	Format;		/* h/w specific data format code */
    RECT	rcSource;	/* write only this rect to the device */
} DRAWBUFFER, *PDRAWBUFFER;



#endif //_VCSTRUCT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\codec\tsbyuv\debug.h ===
/*
 * debug macros
 *
 */

#if DBG
   #ifndef _DEBUG
      #define _DEBUG
   #endif
#endif

#ifndef _DEBUGH
#define _DEBUGH

#ifdef _DEBUG

    #define ModuleDebugLevel MsYuvDebugLevel
    #define ModuleDebugStamp MsYuvDebugStamp


    extern DWORD ModuleDebugLevel;
    extern DWORD ModuleStamp;

	void PlaceStamp(TCHAR * lpszFile, int iLineNum);
    void dbgPrintf(TCHAR * szFormat, ...);

    //
    // a ULONG Is always >= 0
    //
    #define dprintf(_x_)  {{PlaceStamp(__FILE__,__LINE__);dbgPrintf _x_ ;}}
    #define dprintf1(_x_) {if (ModuleDebugLevel >= 1) {PlaceStamp(__FILE__,__LINE__);dbgPrintf _x_ ;}}
    #define dprintf2(_x_) {if (ModuleDebugLevel >= 2) {PlaceStamp(__FILE__,__LINE__);dbgPrintf _x_ ;}}
    #define dprintf3(_x_) {if (ModuleDebugLevel >= 3) {PlaceStamp(__FILE__,__LINE__);dbgPrintf _x_ ;}}
    #define dprintf4(_x_) {if (ModuleDebugLevel >= 4) {PlaceStamp(__FILE__,__LINE__);dbgPrintf _x_ ;}}

	//BOOL FAR PASCAL _Assert(BOOL fExpr, LPSTR szFile, int iLine, LPSTR szExpr);
	BOOL FAR PASCAL _Assert(BOOL fExpr, TCHAR * szFile, int iLine, TCHAR * szExpr);

	#define ASSERT(expr)  _Assert((expr), __FILE__, __LINE__, #expr)

#else

	#define ASSERT(expr)

    #define dbgPrintf 0?0:
    #define dprintf(_x_)
    #define dprintf1(_x_)
    #define dprintf2(_x_)
    #define dprintf3(_x_)
    #define dprintf4(_x_)		

#endif

#endif // DEBUGH
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\codec\tsbyuv\vcstruct.h ===
/*
 * Copyright (c) Microsoft Corporation 1993. All Rights Reserved.
 */

/*
 * vcstruct.h
 *
 * 32-bit Video Capture Driver
 *
 * This header describes structures used in the interface between the
 * kernel driver and the user-mode dll.
 *
 * Geraint Davies, Feb 93.
 */

#ifndef _VCSTRUCT_
#define _VCSTRUCT_

/* --- configuration ------------------------------------------------- */

/*
 * this structure contains configuration information generated
 * by the hardware-specific dialogs and sent to the hardware-specific
 * kernel-mode code. No one else knows its format.
 *
 * these generic structures are used so that driver writers can
 * change the user-mode dialogs and the supporting hardware-specific code
 * and yet still use the common code for interfacing between the
 * two and dealing with NT.
 */

typedef struct _CONFIG_INFO {
    ULONG ulSize;		/* size of struct including size field */
    BYTE ulData[1];		/* (ulSize - sizeof(ULONG)) bytes of data */
} CONFIG_INFO, *PCONFIG_INFO;



/* --- overlay keying and region setting ---------------------------- */


typedef struct _OVERLAY_MODE {
    ULONG ulMode;
} OVERLAY_MODE, *POVERLAY_MODE;

/* values for overlay mode field - or-ed together */
#define VCO_KEYCOLOUR		1	// true if a key colour supported
#define VCO_KEYCOLOUR_FIXED	2	// if not true, you can change it
#define VCO_KEYCOLOUR_RGB	4	// if not true, use palette index
#define VCO_SIMPLE_RECT		8	// if true, supports a single rect	
#define VCO_COMPLEX_REGION	0x10	// if true, supports complex regions.

/*
 * values indicating whether we can put data back into the frame
 * buffer for overlaying (we support the DrawFrame ioctl for the
 * Y411 and/or S422 formats
 */
#define VCO_CAN_DRAW_Y411	0x20	// 7-bit 4:1:1 yuv ala bravado
#define VCO_CAN_DRAW_S422	0x40	// 8-bit 4:2:2 yuv ala spigot
#define VCO_CAN_DRAW		0x60	// for testing: can he draw anything?


typedef struct _OVERLAY_RECTS {
    ULONG ulCount;	    // total number of rects in array
    RECT rcRects[1];	    // ulCount rectangles.
}OVERLAY_RECTS, *POVERLAY_RECTS;


typedef RGBQUAD * PRGBQUAD;

/* --- frame capture ------------------------------------------------ */

/*
 * declaring a real LPVIDEOHDR in the kernel driver is too much of a
 * pain with header files. So the kernel interface will use this declaration
 */
typedef struct _CAPTUREBUFFER {
    PUCHAR	lpData;		    /* buffer data area */
    ULONG	BufferLength;	    /* length of buffer */
    ULONG 	BytesUsed;	    /* actual bytes of data (size of dib) */
    ULONG	TimeCaptured;	    /* millisec time stamp */
    PVOID	Context;	    /* pointer to user context data */
    DWORD       dwFlags;            /* not used by kernel interface */

    /*
     * remaining are declared as 4 reserved dwords in orig struct
     * we use these fields for partial-frame requests
     */
    DWORD 	dwWindowOffset;	    /* current window offset from
				     * start of buffer
				     */
    DWORD	dwWindowLength;	    /* length of current window */

    DWORD       dwReserved[2];          /* not used */

} CAPTUREBUFFER, * PCAPTUREBUFFER;



/* --- drawing ------------------------------------------------------- */

/*
 * used by sample hardware codec to write data back into frame buffer
 */
typedef struct _DRAWBUFFER {
    PUCHAR	lpData;		/* frame data to be drawn */
    ULONG	ulWidth;	/* width of frame in pixels */
    ULONG	ulHeight;	/* height of frame in pixels */
    ULONG	Format;		/* h/w specific data format code */
    RECT	rcSource;	/* write only this rect to the device */
} DRAWBUFFER, *PDRAWBUFFER;



#endif //_VCSTRUCT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\codec\tsbyuv\msyuv.h ===
/*
 * msyuv.h   Microsoft YUV Codec
 *
 * Copyright (c) Microsoft 1993.
 */

#include <winmm.h>
#include <vfw.h>
#include "debug.h"

// #define COLOR_MODIFY

#ifndef FOURCC_YUV411
#define FOURCC_YUV411           mmioFOURCC('Y', '4', '1', '1')
#endif

#ifndef FOURCC_YUV422
//
// compatible with the format produced by the 16-bit Spigot driver.
//
#define FOURCC_YUV422           mmioFOURCC('S', '4', '2', '2')
#endif

#ifdef  TOSHIBA
//
// compatible with the format produced by the Pistachio driver.
//
#ifndef FOURCC_YUV12
#if 1
#define FOURCC_YUV12            mmioFOURCC('T', '4', '2', '0')
#else
#define FOURCC_YUV12            mmioFOURCC('I', '4', '2', '0')
#endif
#endif

//
// compatible with the format produced by the Pistachio driver.
//
#ifndef FOURCC_YUV9
#define FOURCC_YUV9             mmioFOURCC('Y', 'V', 'U', '9')
#endif
#endif//TOSHIBA




typedef struct {
    DWORD       dwFlags;        // flags from ICOPEN
    DWORD       dwFormat;       // format that pXlate is built for (FOURCC)
    PVOID       pXlate;         // xlate table (for decompress)
    BOOL        bRGB565;        // true if 5-6-5 format output (otherwise 555)
#ifdef  TOSHIBA
#ifdef  COLOR_MODIFY
    BOOL        bRGB24;         // true if 24 bit format output (otherwise 16 bit)
#endif//COLOR_MODIFY
#endif//TOSHIBA

#if 0
    /* support for drawing */
    VCUSER_HANDLE vh;
    HWND        hwnd;
    RECT        rcSource;
    RECT        rcDest;
    HBRUSH      hKeyBrush;
#endif

} INSTINFO, *PINSTINFO;




/*
 * message processing functions in msyuv.c
 */
INSTINFO * NEAR PASCAL Open(ICOPEN FAR * icinfo);
DWORD NEAR PASCAL Close(INSTINFO * pinst);
BOOL NEAR PASCAL QueryAbout(INSTINFO * pinst);
DWORD NEAR PASCAL About(INSTINFO * pinst, HWND hwnd);
BOOL NEAR PASCAL QueryConfigure(INSTINFO * pinst);
DWORD NEAR PASCAL Configure(INSTINFO * pinst, HWND hwnd);
DWORD NEAR PASCAL GetState(INSTINFO * pinst, LPVOID pv, DWORD dwSize);
DWORD NEAR PASCAL SetState(INSTINFO * pinst, LPVOID pv, DWORD dwSize);
DWORD NEAR PASCAL GetInfo(INSTINFO * pinst, ICINFO FAR *icinfo, DWORD dwSize);
DWORD FAR PASCAL CompressQuery(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut);
DWORD FAR PASCAL CompressGetFormat(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut);
DWORD FAR PASCAL CompressBegin(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut);
DWORD FAR PASCAL CompressGetSize(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut);
DWORD FAR PASCAL Compress(INSTINFO * pinst, ICCOMPRESS FAR *icinfo, DWORD dwSize);
DWORD FAR PASCAL CompressEnd(INSTINFO * pinst);
DWORD NEAR PASCAL DecompressQuery(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut);
DWORD NEAR PASCAL DecompressGetFormat(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut);
DWORD NEAR PASCAL DecompressBegin(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut);
DWORD NEAR PASCAL Decompress(INSTINFO * pinst, ICDECOMPRESS FAR *icinfo, DWORD dwSize);
DWORD NEAR PASCAL DecompressGetPalette(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut);
DWORD NEAR PASCAL DecompressEnd(INSTINFO * pinst);


DWORD DrawQuery(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut);
DWORD DrawBegin(INSTINFO * pinst,ICDRAWBEGIN FAR *icinfo, DWORD dwSize);
DWORD Draw(INSTINFO * pinst, ICDRAW FAR *icinfo, DWORD dwSize);
DWORD DrawEnd(INSTINFO * pinst);
DWORD DrawWindow(PINSTINFO pinst, PRECT prc);


/* yuv411 or yuv422 to rgb translation, in xlate.c */

/*
 * build yuv411->RGB555 xlate table
 */
LPVOID BuildYUVToRGB555(PINSTINFO pinst);

// build yuv411 -> rgb565
LPVOID BuildYUVToRGB565(PINSTINFO pinst);


/*
 * build yuv422 -> RGB555 xlate table
 */
LPVOID BuildYUV422ToRGB555(PINSTINFO pinst);


// build yuv422 -> RGB565
LPVOID BuildYUV422ToRGB565(PINSTINFO pinst);


#ifdef  TOSHIBA
#ifdef  COLOR_MODIFY
/*
 * build yuv12 -> RGB555 xlate table
 */
LPVOID BuildYUVToRB(PINSTINFO pinst);

#else //COLOR_MODIFY
/*
 * build yuv12 -> RGB555 xlate table
 */
LPVOID BuildYUV12ToRGB555(PINSTINFO pinst);


// build yuv12 -> RGB565
LPVOID BuildYUV12ToRGB565(PINSTINFO pinst);
#endif//COLOR_MODIFY
#endif//TOSHIBA


/*
 * translate one frame from yuv411 to rgb 555 or 565
 */
VOID YUV411ToRGB(PINSTINFO pinst,
                 LPBITMAPINFOHEADER lpbiInput,
                 LPVOID lpInput,
                 LPBITMAPINFOHEADER lpbiOutput,
                 LPVOID lpOutput);

VOID YUV422ToRGB(PINSTINFO pinst,
                 LPBITMAPINFOHEADER lpbiInput,
                 LPVOID lpInput,
                 LPBITMAPINFOHEADER lpbiOutput,
                 LPVOID lpOutput);

#ifdef  TOSHIBA
#ifdef  COLOR_MODIFY
VOID YUV12ToRGB24(PINSTINFO pinst,
                 LPBITMAPINFOHEADER lpbiInput,
                 LPVOID lpInput,
                 LPBITMAPINFOHEADER lpbiOutput,
                 LPVOID lpOutput);

VOID YUV12ToRGB565(PINSTINFO pinst,
                 LPBITMAPINFOHEADER lpbiInput,
                 LPVOID lpInput,
                 LPBITMAPINFOHEADER lpbiOutput,
                 LPVOID lpOutput);

VOID YUV12ToRGB555(PINSTINFO pinst,
                 LPBITMAPINFOHEADER lpbiInput,
                 LPVOID lpInput,
                 LPBITMAPINFOHEADER lpbiOutput,
                 LPVOID lpOutput);

VOID YUV9ToRGB24(PINSTINFO pinst,
                 LPBITMAPINFOHEADER lpbiInput,
                 LPVOID lpInput,
                 LPBITMAPINFOHEADER lpbiOutput,
                 LPVOID lpOutput);

VOID YUV9ToRGB565(PINSTINFO pinst,
                 LPBITMAPINFOHEADER lpbiInput,
                 LPVOID lpInput,
                 LPBITMAPINFOHEADER lpbiOutput,
                 LPVOID lpOutput);

VOID YUV9ToRGB555(PINSTINFO pinst,
                 LPBITMAPINFOHEADER lpbiInput,
                 LPVOID lpInput,
                 LPBITMAPINFOHEADER lpbiOutput,
                 LPVOID lpOutput);
#else //COLOR_MODIFY
VOID YUV12ToRGB(PINSTINFO pinst,
                 LPBITMAPINFOHEADER lpbiInput,
                 LPVOID lpInput,
                 LPBITMAPINFOHEADER lpbiOutput,
                 LPVOID lpOutput);

VOID YUV9ToRGB(PINSTINFO pinst,
                 LPBITMAPINFOHEADER lpbiInput,
                 LPVOID lpInput,
                 LPBITMAPINFOHEADER lpbiOutput,
                 LPVOID lpOutput);
#endif//COLOR_MODIFY
#endif//TOSHIBA

VOID FreeXlate(PINSTINFO pinst);




=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\codec\msyuv\rgb8lut.h ===
//
// Color Look Up Table (cLUTs) used to convert UYVY to RGB8
//
unsigned char const PalTable[] = {
  0,   0,   0,  PC_NOCOLLAPSE,     //    0
128,   0,   0,  PC_NOCOLLAPSE,     //    1
  0, 128,   0,  PC_NOCOLLAPSE,     //    2
128, 128,   0,  PC_NOCOLLAPSE,     //    3
  0,   0, 128,  PC_NOCOLLAPSE,     //    4
128,   0, 128,  PC_NOCOLLAPSE,     //    5
  0, 128, 128,  PC_NOCOLLAPSE,     //    6
192, 192, 192,  PC_NOCOLLAPSE,     //    7
192, 220, 192,  PC_NOCOLLAPSE,     //    8
166, 202, 240,  PC_NOCOLLAPSE,     //    9

  0,   0,   0,  PC_NOCOLLAPSE,     //   10
  0,   0,   0,  PC_NOCOLLAPSE,     //   11
  0,   0,   0,  PC_NOCOLLAPSE,     //   12
  0,   0,   0,  PC_NOCOLLAPSE,     //   13
  0,   0,   0,  PC_NOCOLLAPSE,     //   14
  0,   0,   0,  PC_NOCOLLAPSE,     //   15
  0,  67,   0,  PC_NOCOLLAPSE,     //   16
  0,  41,   0,  PC_NOCOLLAPSE,     //   17
 35,  15,   0,  PC_NOCOLLAPSE,     //   18
 86,   0,   0,  PC_NOCOLLAPSE,     //   19
  0,  55,   0,  PC_NOCOLLAPSE,     //   20
  0,  29,   0,  PC_NOCOLLAPSE,     //   21
 35,   3,   0,  PC_NOCOLLAPSE,     //   22
 86,   0,   0,  PC_NOCOLLAPSE,     //   23
  0,  42,  42,  PC_NOCOLLAPSE,     //   24
  0,  16,  42,  PC_NOCOLLAPSE,     //   25
 35,   0,  42,  PC_NOCOLLAPSE,     //   26
 86,   0,  42,  PC_NOCOLLAPSE,     //   27
  0,  30, 106,  PC_NOCOLLAPSE,     //   28
  0,   4, 106,  PC_NOCOLLAPSE,     //   29
 35,   0, 106,  PC_NOCOLLAPSE,     //   30
 86,   0, 106,  PC_NOCOLLAPSE,     //   31
  0,  86,   0,  PC_NOCOLLAPSE,     //   32
  2,  60,   0,  PC_NOCOLLAPSE,     //   33
 53,  34,   0,  PC_NOCOLLAPSE,     //   34
105,   8,   0,  PC_NOCOLLAPSE,     //   35
  0,  73,   0,  PC_NOCOLLAPSE,     //   36
  2,  47,   0,  PC_NOCOLLAPSE,     //   37
 53,  21,   0,  PC_NOCOLLAPSE,     //   38
105,   0,   0,  PC_NOCOLLAPSE,     //   39
  0,  61,  60,  PC_NOCOLLAPSE,     //   40
  2,  35,  60,  PC_NOCOLLAPSE,     //   41
 53,   9,  60,  PC_NOCOLLAPSE,     //   42
105,   0,  60,  PC_NOCOLLAPSE,     //   43
  0,  48, 125,  PC_NOCOLLAPSE,     //   44
  2,  22, 125,  PC_NOCOLLAPSE,     //   45
 53,   0, 125,  PC_NOCOLLAPSE,     //   46
105,   0, 125,  PC_NOCOLLAPSE,     //   47
  0, 104,   0,  PC_NOCOLLAPSE,     //   48
 21,  78,   0,  PC_NOCOLLAPSE,     //   49
 72,  52,   0,  PC_NOCOLLAPSE,     //   50
123,  26,   0,  PC_NOCOLLAPSE,     //   51
  0,  92,  14,  PC_NOCOLLAPSE,     //   52
 21,  66,  14,  PC_NOCOLLAPSE,     //   53
 72,  40,  14,  PC_NOCOLLAPSE,     //   54
123,  14,  14,  PC_NOCOLLAPSE,     //   55
  0,  79,  79,  PC_NOCOLLAPSE,     //   56
 21,  53,  79,  PC_NOCOLLAPSE,     //   57
 72,  27,  79,  PC_NOCOLLAPSE,     //   58
123,   1,  79,  PC_NOCOLLAPSE,     //   59
  0,  67, 143,  PC_NOCOLLAPSE,     //   60
 21,  41, 143,  PC_NOCOLLAPSE,     //   61
 72,  15, 143,  PC_NOCOLLAPSE,     //   62
123,   0, 143,  PC_NOCOLLAPSE,     //   63
  0, 123,   0,  PC_NOCOLLAPSE,     //   64
 40,  97,   0,  PC_NOCOLLAPSE,     //   65
 91,  71,   0,  PC_NOCOLLAPSE,     //   66
142,  45,   0,  PC_NOCOLLAPSE,     //   67
  0, 110,  33,  PC_NOCOLLAPSE,     //   68
 40,  84,  33,  PC_NOCOLLAPSE,     //   69
 91,  58,  33,  PC_NOCOLLAPSE,     //   70
142,  32,  33,  PC_NOCOLLAPSE,     //   71
  0,  98,  97,  PC_NOCOLLAPSE,     //   72
 40,  72,  97,  PC_NOCOLLAPSE,     //   73
 91,  46,  97,  PC_NOCOLLAPSE,     //   74
142,  20,  97,  PC_NOCOLLAPSE,     //   75
  0,  85, 162,  PC_NOCOLLAPSE,     //   76
 40,  59, 162,  PC_NOCOLLAPSE,     //   77
 91,  33, 162,  PC_NOCOLLAPSE,     //   78
142,   7, 162,  PC_NOCOLLAPSE,     //   79
  7, 142,   0,  PC_NOCOLLAPSE,     //   80
 58, 116,   0,  PC_NOCOLLAPSE,     //   81
109,  90,   0,  PC_NOCOLLAPSE,     //   82
160,  64,   0,  PC_NOCOLLAPSE,     //   83
  7, 129,  52,  PC_NOCOLLAPSE,     //   84
 58, 103,  52,  PC_NOCOLLAPSE,     //   85
109,  77,  52,  PC_NOCOLLAPSE,     //   86
160,  51,  52,  PC_NOCOLLAPSE,     //   87
  7, 117, 116,  PC_NOCOLLAPSE,     //   88
 58,  91, 116,  PC_NOCOLLAPSE,     //   89
109,  65, 116,  PC_NOCOLLAPSE,     //   90
160,  39, 116,  PC_NOCOLLAPSE,     //   91
  7, 104, 181,  PC_NOCOLLAPSE,     //   92
 58,  78, 181,  PC_NOCOLLAPSE,     //   93
109,  52, 181,  PC_NOCOLLAPSE,     //   94
160,  26, 181,  PC_NOCOLLAPSE,     //   95
 26, 160,   6,  PC_NOCOLLAPSE,     //   96
 77, 134,   6,  PC_NOCOLLAPSE,     //   97
128, 108,   6,  PC_NOCOLLAPSE,     //   98
179,  82,   6,  PC_NOCOLLAPSE,     //   99
 26, 148,  70,  PC_NOCOLLAPSE,     //  100
 77, 122,  70,  PC_NOCOLLAPSE,     //  101
128,  96,  70,  PC_NOCOLLAPSE,     //  102
179,  70,  70,  PC_NOCOLLAPSE,     //  103
 26, 135, 135,  PC_NOCOLLAPSE,     //  104
 77, 109, 135,  PC_NOCOLLAPSE,     //  105
128,  83, 135,  PC_NOCOLLAPSE,     //  106
179,  57, 135,  PC_NOCOLLAPSE,     //  107
 26, 123, 199,  PC_NOCOLLAPSE,     //  108
 77,  97, 199,  PC_NOCOLLAPSE,     //  109
128,  71, 199,  PC_NOCOLLAPSE,     //  110
179,  45, 199,  PC_NOCOLLAPSE,     //  111
 44, 179,  24,  PC_NOCOLLAPSE,     //  112
 96, 153,  24,  PC_NOCOLLAPSE,     //  113
147, 127,  24,  PC_NOCOLLAPSE,     //  114
198, 101,  24,  PC_NOCOLLAPSE,     //  115
 44, 166,  89,  PC_NOCOLLAPSE,     //  116
 96, 140,  89,  PC_NOCOLLAPSE,     //  117
147, 114,  89,  PC_NOCOLLAPSE,     //  118
198,  88,  89,  PC_NOCOLLAPSE,     //  119
 44, 154, 153,  PC_NOCOLLAPSE,     //  120
 96, 128, 153,  PC_NOCOLLAPSE,     //  121
147, 102, 153,  PC_NOCOLLAPSE,     //  122
198,  76, 153,  PC_NOCOLLAPSE,     //  123
 44, 141, 218,  PC_NOCOLLAPSE,     //  124
 96, 115, 218,  PC_NOCOLLAPSE,     //  125
147,  89, 218,  PC_NOCOLLAPSE,     //  126
198,  63, 218,  PC_NOCOLLAPSE,     //  127
 63, 198,  43,  PC_NOCOLLAPSE,     //  128
114, 172,  43,  PC_NOCOLLAPSE,     //  129
165, 146,  43,  PC_NOCOLLAPSE,     //  130
216, 120,  43,  PC_NOCOLLAPSE,     //  131
 63, 185, 107,  PC_NOCOLLAPSE,     //  132
114, 159, 107,  PC_NOCOLLAPSE,     //  133
165, 133, 107,  PC_NOCOLLAPSE,     //  134
216, 107, 107,  PC_NOCOLLAPSE,     //  135
 63, 172, 172,  PC_NOCOLLAPSE,     //  136
114, 146, 172,  PC_NOCOLLAPSE,     //  137
165, 120, 172,  PC_NOCOLLAPSE,     //  138
216,  94, 172,  PC_NOCOLLAPSE,     //  139
 63, 160, 237,  PC_NOCOLLAPSE,     //  140
114, 134, 237,  PC_NOCOLLAPSE,     //  141
165, 108, 237,  PC_NOCOLLAPSE,     //  142
216,  82, 237,  PC_NOCOLLAPSE,     //  143
 82, 216,  62,  PC_NOCOLLAPSE,     //  144
133, 190,  62,  PC_NOCOLLAPSE,     //  145
184, 164,  62,  PC_NOCOLLAPSE,     //  146
235, 138,  62,  PC_NOCOLLAPSE,     //  147
 82, 204, 126,  PC_NOCOLLAPSE,     //  148
133, 178, 126,  PC_NOCOLLAPSE,     //  149
184, 152, 126,  PC_NOCOLLAPSE,     //  150
235, 126, 126,  PC_NOCOLLAPSE,     //  151
 82, 191, 191,  PC_NOCOLLAPSE,     //  152
133, 165, 191,  PC_NOCOLLAPSE,     //  153
184, 139, 191,  PC_NOCOLLAPSE,     //  154
235, 113, 191,  PC_NOCOLLAPSE,     //  155
 82, 179, 255,  PC_NOCOLLAPSE,     //  156
133, 153, 255,  PC_NOCOLLAPSE,     //  157
184, 127, 255,  PC_NOCOLLAPSE,     //  158
235, 101, 255,  PC_NOCOLLAPSE,     //  159
100, 235,  80,  PC_NOCOLLAPSE,     //  160
151, 209,  80,  PC_NOCOLLAPSE,     //  161
203, 183,  80,  PC_NOCOLLAPSE,     //  162
254, 157,  80,  PC_NOCOLLAPSE,     //  163
100, 222, 145,  PC_NOCOLLAPSE,     //  164
151, 196, 145,  PC_NOCOLLAPSE,     //  165
203, 170, 145,  PC_NOCOLLAPSE,     //  166
254, 144, 145,  PC_NOCOLLAPSE,     //  167
100, 210, 209,  PC_NOCOLLAPSE,     //  168
151, 184, 209,  PC_NOCOLLAPSE,     //  169
203, 158, 209,  PC_NOCOLLAPSE,     //  170
254, 132, 209,  PC_NOCOLLAPSE,     //  171
100, 197, 255,  PC_NOCOLLAPSE,     //  172
151, 171, 255,  PC_NOCOLLAPSE,     //  173
203, 145, 255,  PC_NOCOLLAPSE,     //  174
254, 119, 255,  PC_NOCOLLAPSE,     //  175
119, 253,  99,  PC_NOCOLLAPSE,     //  176
170, 227,  99,  PC_NOCOLLAPSE,     //  177
221, 201,  99,  PC_NOCOLLAPSE,     //  178
255, 175,  99,  PC_NOCOLLAPSE,     //  179
119, 241, 163,  PC_NOCOLLAPSE,     //  180
170, 215, 163,  PC_NOCOLLAPSE,     //  181
221, 189, 163,  PC_NOCOLLAPSE,     //  182
255, 163, 163,  PC_NOCOLLAPSE,     //  183
119, 228, 228,  PC_NOCOLLAPSE,     //  184
170, 202, 228,  PC_NOCOLLAPSE,     //  185
221, 176, 228,  PC_NOCOLLAPSE,     //  186
255, 150, 228,  PC_NOCOLLAPSE,     //  187
119, 216, 255,  PC_NOCOLLAPSE,     //  188
170, 190, 255,  PC_NOCOLLAPSE,     //  189
221, 164, 255,  PC_NOCOLLAPSE,     //  190
255, 138, 255,  PC_NOCOLLAPSE,     //  191
138, 255, 117,  PC_NOCOLLAPSE,     //  192
189, 246, 117,  PC_NOCOLLAPSE,     //  193
240, 220, 117,  PC_NOCOLLAPSE,     //  194
255, 194, 117,  PC_NOCOLLAPSE,     //  195
138, 255, 182,  PC_NOCOLLAPSE,     //  196
189, 234, 182,  PC_NOCOLLAPSE,     //  197
240, 208, 182,  PC_NOCOLLAPSE,     //  198
255, 181, 182,  PC_NOCOLLAPSE,     //  199
138, 247, 247,  PC_NOCOLLAPSE,     //  200
189, 221, 247,  PC_NOCOLLAPSE,     //  201
240, 195, 247,  PC_NOCOLLAPSE,     //  202
255, 169, 247,  PC_NOCOLLAPSE,     //  203
138, 234, 255,  PC_NOCOLLAPSE,     //  204
189, 208, 255,  PC_NOCOLLAPSE,     //  205
240, 182, 255,  PC_NOCOLLAPSE,     //  206
255, 156, 255,  PC_NOCOLLAPSE,     //  207
156, 255, 136,  PC_NOCOLLAPSE,     //  208
207, 255, 136,  PC_NOCOLLAPSE,     //  209
255, 239, 136,  PC_NOCOLLAPSE,     //  210
255, 213, 136,  PC_NOCOLLAPSE,     //  211
156, 255, 201,  PC_NOCOLLAPSE,     //  212
207, 252, 201,  PC_NOCOLLAPSE,     //  213
255, 226, 201,  PC_NOCOLLAPSE,     //  214
255, 200, 201,  PC_NOCOLLAPSE,     //  215
156, 255, 255,  PC_NOCOLLAPSE,     //  216
207, 240, 255,  PC_NOCOLLAPSE,     //  217
255, 214, 255,  PC_NOCOLLAPSE,     //  218
255, 188, 255,  PC_NOCOLLAPSE,     //  219
156, 253, 255,  PC_NOCOLLAPSE,     //  220
207, 227, 255,  PC_NOCOLLAPSE,     //  221
255, 201, 255,  PC_NOCOLLAPSE,     //  222
255, 175, 255,  PC_NOCOLLAPSE,     //  223
175, 255, 155,  PC_NOCOLLAPSE,     //  224
226, 255, 155,  PC_NOCOLLAPSE,     //  225
255, 255, 155,  PC_NOCOLLAPSE,     //  226
255, 231, 155,  PC_NOCOLLAPSE,     //  227
175, 255, 219,  PC_NOCOLLAPSE,     //  228
226, 255, 219,  PC_NOCOLLAPSE,     //  229
255, 245, 219,  PC_NOCOLLAPSE,     //  230
255, 219, 219,  PC_NOCOLLAPSE,     //  231
175, 255, 255,  PC_NOCOLLAPSE,     //  232
226, 255, 255,  PC_NOCOLLAPSE,     //  233
255, 232, 255,  PC_NOCOLLAPSE,     //  234
255, 206, 255,  PC_NOCOLLAPSE,     //  235
175, 255, 255,  PC_NOCOLLAPSE,     //  236
226, 246, 255,  PC_NOCOLLAPSE,     //  237
255, 220, 255,  PC_NOCOLLAPSE,     //  238
255, 194, 255,  PC_NOCOLLAPSE,     //  239
  0,   0,   0,  PC_NOCOLLAPSE,     //  240
  0,   0,   0,  PC_NOCOLLAPSE,     //  241
  0,   0,   0,  PC_NOCOLLAPSE,     //  242
  0,   0,   0,  PC_NOCOLLAPSE,     //  243
  0,   0,   0,  PC_NOCOLLAPSE,     //  244
  0,   0,   0,  PC_NOCOLLAPSE,     //  245

255, 251, 240,  PC_NOCOLLAPSE,     //  246
160, 160, 164,  PC_NOCOLLAPSE,     //  247
128, 128, 128,  PC_NOCOLLAPSE,     //  248
255,   0,   0,  PC_NOCOLLAPSE,     //  249
  0, 255,   0,  PC_NOCOLLAPSE,     //  250
255, 255,   0,  PC_NOCOLLAPSE,     //  251
  0,   0, 255,  PC_NOCOLLAPSE,     //  252
255,   0, 255,  PC_NOCOLLAPSE,     //  253
  0, 255, 255,  PC_NOCOLLAPSE,     //  254
255, 255, 255,  PC_NOCOLLAPSE      //  255
};

unsigned long yLUT_0[272] = {
    0x00000010, 0x00000010, 0x00000010, 0x00000010, 0x00000010, 0x00000010, 0x00000010, 0x00000010, //  00
    0x00000010, 0x00000010, 0x00000010, 0x00000010, 0x00000010, 0x00000010, 0x00000010, 0x00000010, //  01
    0x00000010, 0x00000010, 0x00000010, 0x00000010, 0x00000010, 0x00000010, 0x00000010, 0x00000010, //  02
    0x00000010, 0x00000010, 0x00000010, 0x00000010, 0x00000010, 0x00000010, 0x00000010, 0x00000010, //  03
    0x00000010, 0x00000010, 0x00000010, 0x00000010, 0x00000010, 0x00000010, 0x00000010, 0x00000010, //  04
    0x00000020, 0x00000020, 0x00000020, 0x00000020, 0x00000020, 0x00000020, 0x00000020, 0x00000020, //  05
    0x00000020, 0x00000020, 0x00000020, 0x00000020, 0x00000030, 0x00000030, 0x00000030, 0x00000030, //  06
    0x00000030, 0x00000030, 0x00000030, 0x00000030, 0x00000030, 0x00000030, 0x00000030, 0x00000030, //  07
    0x00000030, 0x00000030, 0x00000030, 0x00000030, 0x00000040, 0x00000040, 0x00000040, 0x00000040, //  08
    0x00000040, 0x00000040, 0x00000040, 0x00000040, 0x00000040, 0x00000040, 0x00000040, 0x00000040, //  10
    0x00000040, 0x00000040, 0x00000040, 0x00000040, 0x00000050, 0x00000050, 0x00000050, 0x00000050, //  11
    0x00000050, 0x00000050, 0x00000050, 0x00000050, 0x00000050, 0x00000050, 0x00000050, 0x00000050, //  12
    0x00000050, 0x00000050, 0x00000050, 0x00000050, 0x00000060, 0x00000060, 0x00000060, 0x00000060, //  13
    0x00000060, 0x00000060, 0x00000060, 0x00000060, 0x00000060, 0x00000060, 0x00000060, 0x00000060, //  14
    0x00000060, 0x00000060, 0x00000060, 0x00000060, 0x00000070, 0x00000070, 0x00000070, 0x00000070, //  15
    0x00000070, 0x00000070, 0x00000070, 0x00000070, 0x00000070, 0x00000070, 0x00000070, 0x00000070, //  16
    0x00000070, 0x00000070, 0x00000070, 0x00000070, 0x00000080, 0x00000080, 0x00000080, 0x00000080, //  17
    0x00000080, 0x00000080, 0x00000080, 0x00000080, 0x00000080, 0x00000080, 0x00000080, 0x00000080, //  18
    0x00000080, 0x00000080, 0x00000080, 0x00000080, 0x00000090, 0x00000090, 0x00000090, 0x00000090, //  19
    0x00000090, 0x00000090, 0x00000090, 0x00000090, 0x00000090, 0x00000090, 0x00000090, 0x00000090, //  20
    0x00000090, 0x00000090, 0x00000090, 0x00000090, 0x000000A0, 0x000000A0, 0x000000A0, 0x000000A0, //  21
    0x000000A0, 0x000000A0, 0x000000A0, 0x000000A0, 0x000000A0, 0x000000A0, 0x000000A0, 0x000000A0, //  22
    0x000000A0, 0x000000A0, 0x000000A0, 0x000000A0, 0x000000B0, 0x000000B0, 0x000000B0, 0x000000B0, //  23
    0x000000B0, 0x000000B0, 0x000000B0, 0x000000B0, 0x000000B0, 0x000000B0, 0x000000B0, 0x000000B0, //  24
    0x000000B0, 0x000000B0, 0x000000B0, 0x000000B0, 0x000000C0, 0x000000C0, 0x000000C0, 0x000000C0, //  25
    0x000000C0, 0x000000C0, 0x000000C0, 0x000000C0, 0x000000C0, 0x000000C0, 0x000000C0, 0x000000C0, //  26
    0x000000C0, 0x000000C0, 0x000000C0, 0x000000C0, 0x000000D0, 0x000000D0, 0x000000D0, 0x000000D0, //  27
    0x000000D0, 0x000000D0, 0x000000D0, 0x000000D0, 0x000000D0, 0x000000D0, 0x000000D0, 0x000000D0, //  28
    0x000000D0, 0x000000D0, 0x000000D0, 0x000000D0, 0x000000E0, 0x000000E0, 0x000000E0, 0x000000E0, //  29
    0x000000E0, 0x000000E0, 0x000000E0, 0x000000E0, 0x000000E0, 0x000000E0, 0x000000E0, 0x000000E0, //  30
    0x000000E0, 0x000000E0, 0x000000E0, 0x000000E0, 0x000000E0, 0x000000E0, 0x000000E0, 0x000000E0, //  31
    0x000000E0, 0x000000E0, 0x000000E0, 0x000000E0, 0x000000E0, 0x000000E0, 0x000000E0, 0x000000E0, //  32
    0x000000E0, 0x000000E0, 0x000000E0, 0x000000E0, 0x000000E0, 0x000000E0, 0x000000E0, 0x000000E0, //  33
    0x000000E0, 0x000000E0, 0x000000E0, 0x000000E0, 0x000000E0, 0x000000E0, 0x000000E0, 0x000000E0  //  34
};

unsigned long yLUT_1[272] = {
    0x00001000, 0x00001000, 0x00001000, 0x00001000, 0x00001000, 0x00001000, 0x00001000, 0x00001000, //  00
    0x00001000, 0x00001000, 0x00001000, 0x00001000, 0x00001000, 0x00001000, 0x00001000, 0x00001000, //  01
    0x00001000, 0x00001000, 0x00001000, 0x00001000, 0x00001000, 0x00001000, 0x00001000, 0x00001000, //  02
    0x00001000, 0x00001000, 0x00001000, 0x00001000, 0x00001000, 0x00001000, 0x00001000, 0x00001000, //  03
    0x00001000, 0x00001000, 0x00001000, 0x00001000, 0x00001000, 0x00001000, 0x00001000, 0x00001000, //  04
    0x00002000, 0x00002000, 0x00002000, 0x00002000, 0x00002000, 0x00002000, 0x00002000, 0x00002000, //  05
    0x00002000, 0x00002000, 0x00002000, 0x00002000, 0x00003000, 0x00003000, 0x00003000, 0x00003000, //  06
    0x00003000, 0x00003000, 0x00003000, 0x00003000, 0x00003000, 0x00003000, 0x00003000, 0x00003000, //  07
    0x00003000, 0x00003000, 0x00003000, 0x00003000, 0x00004000, 0x00004000, 0x00004000, 0x00004000, //  08
    0x00004000, 0x00004000, 0x00004000, 0x00004000, 0x00004000, 0x00004000, 0x00004000, 0x00004000, //  10
    0x00004000, 0x00004000, 0x00004000, 0x00004000, 0x00005000, 0x00005000, 0x00005000, 0x00005000, //  11
    0x00005000, 0x00005000, 0x00005000, 0x00005000, 0x00005000, 0x00005000, 0x00005000, 0x00005000, //  12
    0x00005000, 0x00005000, 0x00005000, 0x00005000, 0x00006000, 0x00006000, 0x00006000, 0x00006000, //  13
    0x00006000, 0x00006000, 0x00006000, 0x00006000, 0x00006000, 0x00006000, 0x00006000, 0x00006000, //  14
    0x00006000, 0x00006000, 0x00006000, 0x00006000, 0x00007000, 0x00007000, 0x00007000, 0x00007000, //  15
    0x00007000, 0x00007000, 0x00007000, 0x00007000, 0x00007000, 0x00007000, 0x00007000, 0x00007000, //  16
    0x00007000, 0x00007000, 0x00007000, 0x00007000, 0x00008000, 0x00008000, 0x00008000, 0x00008000, //  17
    0x00008000, 0x00008000, 0x00008000, 0x00008000, 0x00008000, 0x00008000, 0x00008000, 0x00008000, //  18
    0x00008000, 0x00008000, 0x00008000, 0x00008000, 0x00009000, 0x00009000, 0x00009000, 0x00009000, //  19
    0x00009000, 0x00009000, 0x00009000, 0x00009000, 0x00009000, 0x00009000, 0x00009000, 0x00009000, //  20
    0x00009000, 0x00009000, 0x00009000, 0x00009000, 0x0000A000, 0x0000A000, 0x0000A000, 0x0000A000, //  21
    0x0000A000, 0x0000A000, 0x0000A000, 0x0000A000, 0x0000A000, 0x0000A000, 0x0000A000, 0x0000A000, //  22
    0x0000A000, 0x0000A000, 0x0000A000, 0x0000A000, 0x0000B000, 0x0000B000, 0x0000B000, 0x0000B000, //  23
    0x0000B000, 0x0000B000, 0x0000B000, 0x0000B000, 0x0000B000, 0x0000B000, 0x0000B000, 0x0000B000, //  24
    0x0000B000, 0x0000B000, 0x0000B000, 0x0000B000, 0x0000C000, 0x0000C000, 0x0000C000, 0x0000C000, //  25
    0x0000C000, 0x0000C000, 0x0000C000, 0x0000C000, 0x0000C000, 0x0000C000, 0x0000C000, 0x0000C000, //  26
    0x0000C000, 0x0000C000, 0x0000C000, 0x0000C000, 0x0000D000, 0x0000D000, 0x0000D000, 0x0000D000, //  27
    0x0000D000, 0x0000D000, 0x0000D000, 0x0000D000, 0x0000D000, 0x0000D000, 0x0000D000, 0x0000D000, //  28
    0x0000D000, 0x0000D000, 0x0000D000, 0x0000D000, 0x0000E000, 0x0000E000, 0x0000E000, 0x0000E000, //  29
    0x0000E000, 0x0000E000, 0x0000E000, 0x0000E000, 0x0000E000, 0x0000E000, 0x0000E000, 0x0000E000, //  30
    0x0000E000, 0x0000E000, 0x0000E000, 0x0000E000, 0x0000E000, 0x0000E000, 0x0000E000, 0x0000E000, //  31
    0x0000E000, 0x0000E000, 0x0000E000, 0x0000E000, 0x0000E000, 0x0000E000, 0x0000E000, 0x0000E000, //  32
    0x0000E000, 0x0000E000, 0x0000E000, 0x0000E000, 0x0000E000, 0x0000E000, 0x0000E000, 0x0000E000, //  33
    0x0000E000, 0x0000E000, 0x0000E000, 0x0000E000, 0x0000E000, 0x0000E000, 0x0000E000, 0x0000E000  //  34
};



unsigned long cLUT_R0[260] = {
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00010000, 0x00010000, 0x00010000, 0x00010000, 0x00010000, 0x00010000, 0x00010000, 0x00010000,
    0x00010100, 0x00010100, 0x00010100, 0x00010100, 0x00010100, 0x00010100, 0x00010100, 0x00010100,
    0x01010100, 0x01010100, 0x01010100, 0x01010100, 0x01010100, 0x01010100, 0x01010100, 0x01010100,
    0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101,
    0x01020101, 0x01020101, 0x01020101, 0x01020101, 0x01020101, 0x01020101, 0x01020101, 0x01020101,
    0x01020201, 0x01020201, 0x01020201, 0x01020201, 0x01020201, 0x01020201, 0x01020201, 0x01020201,
    0x02020201, 0x02020201, 0x02020201, 0x02020201, 0x02020201, 0x02020201, 0x02020201, 0x02020201,
    0x02020202, 0x02020202, 0x02020202, 0x02020202, 0x02020202, 0x02020202, 0x02020202, 0x02020202,
    0x02030202, 0x02030202, 0x02030202, 0x02030202, 0x02030202, 0x02030202, 0x02030202, 0x02030202,
    0x02030302, 0x02030302, 0x02030302, 0x02030302, 0x02030302, 0x02030302, 0x02030302, 0x02030302,
    0x03030302, 0x03030302, 0x03030302, 0x03030302, 0x03030302, 0x03030302, 0x03030302, 0x03030302,
    0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303,
    0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303,
    0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303,
    0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303,
    0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303,
    0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303,
    0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303,
    0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303,
    0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303,
    0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303,
    0x03030303, 0x03030303, 0x03030303, 0x03030303
};


unsigned long cLUT_B0[260] = {
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00040000, 0x00040000, 0x00040000, 0x00040000, 0x00040000, 0x00040000, 0x00040000, 0x00040000,
    0x00040400, 0x00040400, 0x00040400, 0x00040400, 0x00040400, 0x00040400, 0x00040400, 0x00040400,
    0x04040400, 0x04040400, 0x04040400, 0x04040400, 0x04040400, 0x04040400, 0x04040400, 0x04040400,
    0x04040404, 0x04040404, 0x04040404, 0x04040404, 0x04040404, 0x04040404, 0x04040404, 0x04040404,
    0x04080404, 0x04080404, 0x04080404, 0x04080404, 0x04080404, 0x04080404, 0x04080404, 0x04080404,
    0x04080804, 0x04080804, 0x04080804, 0x04080804, 0x04080804, 0x04080804, 0x04080804, 0x04080804,
    0x08080804, 0x08080804, 0x08080804, 0x08080804, 0x08080804, 0x08080804, 0x08080804, 0x08080804,
    0x08080808, 0x08080808, 0x08080808, 0x08080808, 0x08080808, 0x08080808, 0x08080808, 0x08080808,
    0x080C0808, 0x080C0808, 0x080C0808, 0x080C0808, 0x080C0808, 0x080C0808, 0x080C0808, 0x080C0808,
    0x080C0C08, 0x080C0C08, 0x080C0C08, 0x080C0C08, 0x080C0C08, 0x080C0C08, 0x080C0C08, 0x080C0C08,
    0x0C0C0C08, 0x0C0C0C08, 0x0C0C0C08, 0x0C0C0C08, 0x0C0C0C08, 0x0C0C0C08, 0x0C0C0C08, 0x0C0C0C08,
    0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C,
    0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C,
    0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C,
    0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C,
    0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C,
    0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C,
    0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C,
    0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C,
    0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C,
    0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C,
    0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\codec\msyuv\vcuser.h ===
/*
 * Copyright Microsoft Corporation, 1993 - 1995. All Rights Reserved.
 */

/*
 * vcuser.h
 *
 * 32-bit Video Capture driver
 * User-mode support library
 *
 * define functions providing access to video capture hardware. On NT,
 * these functions will interface to the kernel-mode driver.
 *
 * include vcstruct.h before this.
 *
 * Geraint Davies, Feb 93
 */

#ifndef _VCUSER_H_
#define _VCUSER_H_

/*
 * capture device handle. This structure is opaque to the caller
 */
typedef struct _VCUSER_HANDLE * VCUSER_HANDLE;

/*
 * these are the parameters we need to issue a DriverCallback. A
 * pointer to one of these structs is passed on StreamInit
 * If the pointer is null, we don't need callbacks.
 */
typedef struct _VCCALLBACK {
    DWORD dwCallback;
    DWORD dwFlags;
    HDRVR hDevice;
    DWORD dwUser;
} VCCALLBACK, * PVCCALLBACK;


/*
 * open the device and return a capture device handle that can be used
 * in future calls.
 * The device index is 0 for the first capture device up to N for the
 * Nth installed capture device.
 *
 * If pDriverName is non-null, then we will open the Nth device handled
 * by this driver. (Current implementation supports only one device per
 * drivername.)
 *
 * This function returns NULL if it is not able to open the device.
 */
VCUSER_HANDLE VC_OpenDevice(PTCHAR pDriverName, int DeviceIndex);


/*
 * close a capture device. This will abort any operation in progress and
 * render the device handle invalid.
 */
VOID VC_CloseDevice(VCUSER_HANDLE vh);


/*
 * Configuration.
 *
 * These functions perform device-dependent setup affecting the
 * target format, the source acquisition or the display (overlay).
 *
 * The structures passed are not interpreted by the vcuser and vckernel
 * libraries except that the first ulong of the struct must contain the
 * size in bytes of the entire structure (see vcstruct.h). It is assumed
 * that the structures are defined and agreed between the user-mode
 * hardware-specific code and the kernel-mode hardware specific code
 */
BOOL VC_ConfigFormat(VCUSER_HANDLE, PCONFIG_INFO);
BOOL VC_ConfigSource(VCUSER_HANDLE, PCONFIG_INFO);
BOOL VC_ConfigDisplay(VCUSER_HANDLE, PCONFIG_INFO);


/*
 * overlay and keying
 *
 * Several different methods are used by devices to locate the overlay
 * area on the screen: colour (either rgb or palette index) and/or
 * either a single rectangle, or a series of rectangles defining a complex
 * region. Call GetOverlayMode first to find out which type of overlay
 * keying is available. If this returns 0, this hardware is not capable
 * of overlay.
 */

/*
 * find out the overlay keying method
 */
ULONG VC_GetOverlayMode(VCUSER_HANDLE);

/*
 * set the key colour to a specified RGB colour. This function will only
 * succeed if GetOverlayMode returned  VCO_KEYCOLOUR and VCO_KEYCOLOUR_RGB
 * and not VCO_KEYCOLOUR_FIXED
 */
BOOL VC_SetKeyColourRGB(VCUSER_HANDLE, PRGBQUAD);

/*
 * set the key colour to a specified palette index. This function will only
 * succeed if GetOverlayMode returned VCO_KEYCOLOUR and not either
 * VCO_KEYCOLOUR_RGB or VCO_KEYCOLOUR_FIXED
 */
BOOL VC_SetKeyColourPalIdx(VCUSER_HANDLE, WORD);

/*
 * get the current key colour. This 32-bit value should be interpreted
 * as either a palette index or an RGB value according to the
 * VCO_KEYCOLOUR_RGB flag returned from VC_GetOverlayMode.
 */
DWORD VC_GetKeyColour(VCUSER_HANDLE vh);

/*
 * set the overlay rectangle(s). This rectangle marks the area in device
 * co-ordinates where the overlay video will appear. The video will be
 * panned so that pixel (0,0) will appear at the top-left of this rectangle,
 * and the video will be cropped at the bottom and right.  The video
 * stream will not normally be scaled to fit this window: scaling is normally
 * determined by the destination format set by VC_ConfigFormat.
 *
 * If VCO_KEYCOLOUR was returned, the video
 * will only be shown at those pixels within the rectangle for which the
 * vga display has the key colour (VC_GetKeyColour() for this).
 *
 * Some devices may support complex regions (VCO_COMPLEX_RECT). In that case,
 * the first rectangle in the area must be the bounding rectangle for
 * the overlay area, followed by one rectangle for each region within it in
 * which the overlay should appear.
 */
BOOL VC_SetOverlayRect(VCUSER_HANDLE, POVERLAY_RECTS);


/*
 * set the offset of the overlay. This changes the panning - ie which
 * source co-ordinate appears as the top left pixel in the overlay rectangle.
 * Initially after a call to VC_SetOverlayRect, the source image will be panned
 * so that the top-left of the source image is aligned with the top-left of the
 * overlay rectangle. This call aligns the top-left of the source image
 * with the top-left of this offset rectangle.
 */
BOOL VC_SetOverlayOffset(VCUSER_HANDLE, PRECT);

/* enable or disable overlay. if the BOOL bOverlay is TRUE, and the overlay
 * key colour and rectangle have been set, overlay will be enabled.
 */
BOOL VC_Overlay(VCUSER_HANDLE, BOOL);

/*
 * enable or disable acquisition.
 * If acquisition is disabled, the overlay image will be frozen.
 *
 * this function will have no effect during capture since the acquisition
 * flag is toggled at each frame capture.
 */
BOOL VC_Capture(VCUSER_HANDLE, BOOL);



/*
 * capture a single frame, synchronously. the video header must point
 * to a data buffer large enough to hold one frame of the format set by
 * VC_ConfigFormat.
 */
// BOOL VC_Frame(VCUSER_HANDLE, LPVIDEOHDR);


/*
 * data streaming.
 *
 * Call VC_StreamInit to prepare for streaming.
 * Call VC_StreamStart to initiate capture.
 * Call VC_AddBuffer to add a capture buffer to the list. As each
 * frame capture completes, the callback function specified in
 * VC_StreamInit will be called with the buffer that has completed.
 *
 * If there is no buffer ready when it is time to capture a frame,
 * a callback will occur. In addition, VC_StreamGetError will return
 * a count of the frames missed this session. VC_StreamGetPos will return
 * the position (in millisecs) reached so far.
 *
 * Call VC_StreamStop to terminate streaming. Any buffer currently in
 * progress may still complete. Uncompleted buffers will remain in the
 * queue. Call VC_Reset to release all buffers from the queue.
 *
 * Finally call VC_StreamFini to tidy up.
 */

/*
 * prepare to start capturing frames
 */
BOOL VC_StreamInit(VCUSER_HANDLE,
		PVCCALLBACK,	// pointer to callback function
		ULONG		// desired capture rate: microseconds per frame
);

/*
 * clean up after capturing. You must have stopped capturing first.
 */
BOOL VC_StreamFini(VCUSER_HANDLE);

/*
 * initiate capturing of frames. Must have called VC_StreamInit first.
 */
BOOL VC_StreamStart(VCUSER_HANDLE);

/*
 * stop capturing frames. Current frame may still complete. All other buffers
 * will remain in the queue until capture is re-started, or they are released
 * by VC_StreamReset.
 */
BOOL VC_StreamStop(VCUSER_HANDLE);

/*
 * cancel all buffers that have been 'add-buffered' but have not
 * completed. This will also force VC_StreamStop if it hasn't already been
 * called.
 */
BOOL VC_StreamReset(VCUSER_HANDLE);

/*
 * get the count of frames that have been skipped since the last call
 * to VC_StreamInit.
 */
ULONG VC_GetStreamError(VCUSER_HANDLE);

/*
 * get the current position within the capture stream (ie time
 * in millisecs since capture began)
 */
BOOL VC_GetStreamPos(VCUSER_HANDLE, LPMMTIME);

/*
 * add a buffer to the queue. The buffer should be large enough
 * to hold one frame of the format specified by VC_ConfigFormat.
 */
// BOOL VC_StreamAddBuffer(VCUSER_HANDLE, LPVIDEOHDR);


/*
 * playback
 *
 * Call VC_DrawFrame to draw a frame into the frame buffer. You should
 * call VC_Overlay functions to arrange for the frame buffer to appear
 * on screen.
 */
BOOL VC_DrawFrame(VCUSER_HANDLE, PDRAWBUFFER);



/*
 * installation/configuration
 *
 * on NT, the following functions will start and stop the
 * kernel driver. The callback function can write profile information
 * to the registry between stopping the driver (if already running) and
 * re-starting the driver. The kernel driver DriverEntry routine is responsible
 * for reading these values from the registry before calling VC_Init().
 *
 * The win-16 implementation will (?) call the callback to write
 * values to the profile, and then call the HW_Startup function. This function
 * is responsible for calling VC_Init, initialising the callback table and
 * initialising the hardware.
 */

/*
 * opaque pointer to the information we need to access the registry/profile.
 */
typedef struct _VC_PROFILE_INFO * PVC_PROFILE_INFO;


/*
 * open a handle to whatever functions are needed to access the registry,
 * service controller or profile. Must call this function before
 * calls to the other VC_ configuration routines.
 *
 * The argument is the name of the driver. This should be the name of
 * the kernel driver file (without path or extension). It will also be used
 * as the registry key name or profile section name.
 */
PVC_PROFILE_INFO VC_OpenProfileAccess(PTCHAR DriverName);

/*
 * close a profile access handle
 */
VOID VC_CloseProfileAccess(PVC_PROFILE_INFO);


/*
 * takes a PVC_PROFILE_INFO returned from VC_OpenProfileAccess, and
 * returns TRUE if we currently have sufficient privilege to perform
 * driver configuration operations.
 */
BOOL VC_ConfigAccess(PVC_PROFILE_INFO);


/*
 * This function is called once the driver has definitely been unloaded, and
 * the profile entry created, but before the driver is re-loaded. It can write
 * any configuration information to the registry. It should return TRUE if
 * it is ok to load and start the kernel-mode driver, or false if some
 * error has occured.
 */
typedef BOOL (*PPROFILE_CALLBACK)(PVOID);


/*
 * start the hardware-access portion of the driver. Call the callback
 * function at a moment when it is possible to write configuration information
 * to the profile using VC_WriteProfile.
 * Returns DRVCNF_OK if all is ok, DRVCNF_CANCEL for failure, or DRVCNF_RESTART if
 * all is ok but a system-restart is needed before the driver will load correctly.
 */
LRESULT VC_InstallDriver(
	    PVC_PROFILE_INFO pProfile,		// access info returned by OpenProfileAccess
	    PPROFILE_CALLBACK pCallback,	// callback function
	    PVOID pContext			// context info for callback	
);

/*
 * Write a single string keyword and DWORD value to the registry or profile
 * for this driver.
 * This can be re-read from the h/w driver using VC_ReadProfile (in either
 * the kernel-mode vckernel.lib version or user mode in the vcuser version).
 *
 * return TRUE for success or FALSE for failure.
 */
BOOL VC_WriteProfile(PVC_PROFILE_INFO pProfile, PTCHAR ValueName, DWORD Value);

/*
 * Write a single string keyword and DWORD value to the registry or profile
 * for this driver.
 * This writes to HKEY_CURRENT_USER and is typically used to store user defaults.
 *
 * return TRUE for success or FALSE for failure.
 */
BOOL VC_WriteProfileUser(PVC_PROFILE_INFO pProfile, PTCHAR ValueName, DWORD Value);


/*
 * read back a driver-specific DWORD profile parameter that was written with
 * VC_WriteProfile. If the valuename cannot be found, the default is returned.
 */
DWORD VC_ReadProfile(PVC_PROFILE_INFO pProfile, PTCHAR ValueName, DWORD dwDefault);

/*
 * read back a driver-specific DWORD profile parameter that was written with
 * VC_WriteProfileUser.  If the valuename cannot be found, the default is returned.
 * This reads from HKEY_CURRENT_USER and is typically used to store user defaults.
 */
DWORD VC_ReadProfileUser(PVC_PROFILE_INFO pProfile, PTCHAR ValueName, DWORD dwDefault);

/*
 * read a string parameter from the device's profile. returns FALSE
 * if it fails to read the string.
 */
BOOL VC_ReadProfileString(
    PVC_PROFILE_INFO pProfile,		// access info from OpenProfile
    PTCHAR ValueName,			// name of value to read
    PTCHAR ValueString,			// put value here
    DWORD ValueLength			// size of ValueString in bytes
);


/*
 * unload a driver. On NT, this stops and removes the kernel-mode driver.
 * On win-16, this calls the Cleanup callback.
 *
 * return DRVCNF_OK if the unload was successful, DRVCNF_CANCEL if it failed, and
 * DRVCNF_RESTART if a system-restart is needed before the removal takes effect.
 *
 * note that after this operation, the PVC_PROFILE_INFO information is still held
 * open. A call to VC_CloseProfileAccess is still needed before exiting.
 */
LRESULT VC_RemoveDriver(PVC_PROFILE_INFO pProfile);



#endif //_VCUSER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\codec\msyuv\xlate.c ===
/*
 * Microsoft YUV Codec UyVy -> rgb conversion functions
 *
 * Copyright (c) Microsoft Corporation 1993
 * All Rights Reserved
 *
 */

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>

#include "msyuv.h"


#include "rgb8lut.h"  // can only be included once

/*
 * This module provides translation from YUV into RGB. It translates
 * from 8-bit YUV 4:2:2 (as provided by the Spigot video capture driver)
 * or 7-bit YUV 4:1:1 (as provided by the Bravado driver) into 16-bit RGB555
 * or RGB565. All versions use a look-up table built using YUVToRGB555
 * or YUVToRGB565
 */



#define RANGE(x, lo, hi) max(lo, min(hi, x))

/*
 * Convert a YUV colour into a 15-bit RGB colour.
 *
 * The input Y is in the range 16..235; the input U and V components
 * are in the range -128..+127. The conversion equations for this are
 * (according to CCIR 601):
 *
 * R = Y + 1.371 V
 * G = Y - 0.698 V - 0.336 U
 * B = Y + 1.732 U
 *
 * To avoid floating point, we scale all values by 1024.
 *
 * The resulting RGB values are in the range 16..235: we truncate these to
 * 5 bits each. and return a WORD containing 5-bits each for R, G and B
 * with bit 15 set to 0.
 */
WORD
YUVToRGB555(int y, int u, int v)
{
    int ScaledY = RANGE(y, 16, 235) * 1024;
    int red, green, blue;

    red   = RANGE((ScaledY + (1404 * v))             / 1024, 0, 255);
    green = RANGE((ScaledY - ( 715 * v) - (344 * u)) / 1024, 0, 255);
    blue  = RANGE((ScaledY + (1774 * u))             / 1024, 0, 255);

    return (WORD) (((red & 0xf8) << 7) | ((green & 0xf8) << 2) | ((blue & 0xf8) >>3) );
}


// same as above but converts to RGB565 instead
WORD
YUVToRGB565(int y, int u, int v)
{
    int ScaledY = RANGE(y, 16, 235) * 1024;
    int red, green, blue;

    red   = RANGE((ScaledY + (1404 * v))             / 1024, 0, 255);
    green = RANGE((ScaledY - ( 715 * v) - (344 * u)) / 1024, 0, 255);
    blue  = RANGE((ScaledY + (1774 * u))             / 1024, 0, 255);

    return (WORD) (((red & 0xf8) << 8) | ((green & 0xfc) << 3) | ((blue & 0xf8) >>3) );
}

/* YUV 4:2:2 support ------------------------------------------ */

/*
 * The captured data is in YUV 4:2:2, 8-bits per sample.
 * The data is laid out in alternating Y-U-Y-V-Y-U-Y-V format. Thus
 * every DWORD contains two complete pixels, in the
 * form (msb..lsb) V..Y1..U..Y0
 * All 3 components (y, u and v) are all unsigned 8-bit values in the range
 * 16..235.
 *
 * We have to double scan lines for >= 480 line formats since
 * the hardware only captured one field maximum.
 *
 */

LPVOID BuildUYVYToRGB32( PINSTINFO pinst )
{
    LPVOID pXlate;
    long y, u, v;

    // need 5 lookup tables to do the conversions, each is 256 entries long,
    // and each contains short words.
    //
    short * yip;    // Y impact
    short * vrip;   // red's V impact
    short * vgip;   // green's V impact
    short * ugip;   // green's U impact
    short * ubip;   // blue's U impact

    dprintf2((TEXT("In BuildUYVYToRGB32\n")));

    if (pinst->pXlate != NULL) {
       return(pinst->pXlate);
    }

    dprintf1((TEXT("Allocate memory and building table for BuildUYVYToRGB32\n")));

    /*
     * allocate a table big enough for 5 256-byte arrays
     */
    pXlate = VirtualAlloc (NULL, 5 * 256 * sizeof( short ), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

    if(!pXlate)
       return pXlate;

    // set the table offsets
    //
    yip = pXlate;
    vrip = yip + 256;
    vgip = vrip + 256;
    ugip = vgip + 256;
    ubip = ugip + 256;

    // setup Y impact, etc
    //
    for( y = 0 ; y < 256 ; y++ )
    {
        yip[y] = (short)( ( 1.164 * ( y - 16L ) / 1.0 ) + 0 );
    }
    for( v = 0 ; v < 256 ; v++ )
    {
        vrip[v] = (short)( 1.596 * ( v - 128L ) / 1.0 );
        vgip[v] = (short)( -0.813 * ( v - 128L ) / 1.0 );
    }
    for( u = 0 ; u < 256 ; u++ )
    {
        ugip[u] = (short)( -0.391 * ( u - 128L ) / 1.0 );
        ubip[u] = (short)( 2.018 * ( u - 128L ) / 1.0 );
    }

    return(pXlate);
}

/*
 * build a translation table to translate between YUV and RGB555.
 *
 * This builds a lookup table with 32k 1-word entries: truncate the YUV
 * to 15bits (5-5-5) and look-up in this xlate table to produce the
 * 15-bit rgb value.
 */
LPVOID BuildUYVYToRGB555(PINSTINFO pinst)
{
    LPVOID pXlate;
    LPWORD pRGB555;
    WORD w;

    dprintf2((TEXT("In BuildUYVYToRGB555\n")));

    if (pinst->pXlate != NULL) {
       return(pinst->pXlate);
    }

    dprintf2((TEXT("Allocate memory and building table for BuildUYVYToRGB555\n")));

    /*
     * allocate a table big enough for 32k 2-byte entries
     */
    pXlate = VirtualAlloc (NULL, 2 * 32 * 1024, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

    if(!pXlate)
       return pXlate;

    pRGB555 = (LPWORD)pXlate;

    /*
     * build a 15-bit yuv lookup table by stepping through each entry,
     * converting the yuv index to rgb and storing at that index. The index
     * to this table is a 15-bit value with the y component in bits 14..10,
     * u in bits 9..5 and v in bits 4..0. Note that the y component is unsigned,
     * whereas the u and v components are signed.
     */
    for (w = 0; w < 32*1024; w++) {

 /*
  * the YUVtoRGB55 conversion function takes values 0..255 for y,
  * and -128..+127 for u and v. Pick out the relevant bits of the
  * index for this cell, and shift to get values in this range.
  * Subtract 128 from u and v to shift from 0..255 to -128..+127
  */
       *pRGB555++ = YUVToRGB555(
           (w & 0x7c00) >> 7,
          ((w &  0x3e0) >> 2) - 128,
          ((w &   0x1f) << 3) - 128
           );
    }


    return(pXlate);


}

/*
 * build a translation table to translate between YUV and RGB 5-6-5
 *
 * This builds a lookup table with 32k 1-word entries: truncate the YUV
 * to 15bits (5-5-5) and look-up in this xlate table to produce the
 * 16-bit rgb value.
 */
LPVOID BuildUYVYToRGB565(PINSTINFO pinst)
{
    LPVOID pXlate;
    LPWORD pRGB;
    WORD w;

    dprintf2((TEXT("In BuildUYVYToRGB565\n")));

    if (pinst->pXlate != NULL) {
       return(pinst->pXlate);
    }

    dprintf2((TEXT("Allocate memory and building table for BuildUYVYToRGB565\n")));

    /*
     * allocate a table big enough for 32k 2-byte entries
     */
    pXlate = VirtualAlloc (NULL, 2 * 32 * 1024, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);


    if(!pXlate)
       return pXlate;

    pRGB = (LPWORD)pXlate;

    /*
     * build a 15-bit yuv lookup table by stepping through each entry,
     * converting the yuv index to rgb and storing at that index. The index
     * to this table is a 15-bit value with the y component in bits 14..10,
     * u in bits 9..5 and v in bits 4..0. Note that the y component is unsigned,
     * whereas the u and v components are signed.
     */
    for (w = 0; w < 32*1024; w++) {

    /*
     * the YUVtoRGB conversion function takes values 0..255 for y,
     * and -128..+127 for u and v. Pick out the relevant bits of the
     * index for this cell, and shift to get values in this range.
     * Subtract 128 from u and v to shift from 0..255 to -128..+127
     */
    *pRGB++ = YUVToRGB565(
        (w & 0x7c00) >> 7,
       ((w &  0x3e0) >> 2) - 128,
       ((w &   0x1f) << 3) - 128
        );
    }


    return(pXlate);


}


/*
 * build a translation table to translate between YUV and RGB8
 *
 */
LPVOID BuildUYVYToRGB8(PINSTINFO pinst)
{
    dprintf2((TEXT("In BuildUYVYToRGB8: no dynamically built table. Return NULL;\n")));
    return(0);
}


/*
 * translate YUV 4:2:2 into 16-bit RGB using a lookup table. Flip vertically
 * into DIB format during processing. Double scanlines for formats of
 * 480 lines or greater. Produces 565 or 555 format RGB depending on the
 * xlate table.
 */
VOID
UYVYToRGB16(
    PINSTINFO pinst,
    LPBITMAPINFOHEADER lpbiInput,
    LPVOID lpInput,
    LPBITMAPINFOHEADER lpbiOutput,
    LPVOID lpOutput
)
{
    int RowInc;
    int i, j;
    DWORD uv55, dwPixel;
    int WidthBytes;   // width of one line in BYTES
    BOOL bDuplicate = FALSE;
    PDWORD pSrc, pDst;
    int Height, Width;
    PWORD pXlate;
    int InputHeight;



    Height = abs(lpbiInput->biHeight);
    InputHeight = Height;
    Width  = lpbiInput->biWidth;

    WidthBytes = Width * 2 ; 
    ASSERT(lpbiInput->biBitCount / 8 == 2);

    pXlate = pinst->pXlate;
 
    pSrc = (PDWORD) lpInput;

    dprintf3(("UYVYToRGB: %s %dx%d; %s %dx%dx%d=%d; %s %dx%dx%d=%d\n",
            pinst->bRGB565?"RGB565" : "RGB555",
            Width, Height,
            (PCHAR) &lpbiInput->biCompression,
            lpbiInput->biWidth, lpbiInput->biHeight, lpbiInput->biBitCount, lpbiInput->biSizeImage, 
            lpbiOutput->biCompression == 0 ? "RGB": lpbiOutput->biCompression == BI_BITFIELDS ? "BITF" : (PCHAR) &lpbiOutput->biCompression,
            lpbiOutput->biWidth, lpbiOutput->biHeight, lpbiOutput->biBitCount, lpbiOutput->biSizeImage));


    ASSERT((lpbiOutput->biWidth == lpbiInput->biWidth) && abs(lpbiOutput->biHeight) == abs(lpbiInput->biHeight));

    /*
     * calculate the amount to adjust pDst by at the end of one line
     * of copying. At this point we are at the end of line N. We need
     * to move to the start of line N-1.
     */
    RowInc = WidthBytes * 2;  // two lines!!


    /* remember we are adding to a DWORD pointer */
    RowInc /= sizeof(DWORD);


    if(lpbiOutput->biCompression == FOURCC_UYVY ||
       lpbiOutput->biCompression == FOURCC_YUY2 ||
       lpbiOutput->biCompression == FOURCC_YVYU  ) {

       pDst = (PDWORD) lpOutput;          
       memcpy(pDst, pSrc, Width * Height * lpbiInput->biBitCount / 8);  // Top down

    } else {

        // Output BI_RGB or BI_BITFIELD
        // UVYV->RGB; +RGB->Flip

        if(lpbiOutput->biHeight >= 0) 
           pDst = (PDWORD) ( (LPBYTE)lpOutput + (Height - 1) * WidthBytes );
        else 
           pDst = (PDWORD) lpOutput;


        //
        // UyVy
        //
        if(pinst->dwFormat == FOURCC_UYVY) {

            /* loop copying each scanline */
            for (i = InputHeight; i > 0; i--) {

               /* loop copying two pixels at a time */
               for (j = Width ; j > 0; j -= 2) {

                  /*
                   * get two pixels and convert to 15-bpp YUV
                   */

                  dwPixel = *pSrc++;

                  /* 
                   * Convert UYVY (0x y1 V y0 U) to YUYV (0x V y1 U y0) in which the translation table is built for.
                   */
#if defined(_X86_)

                  _asm {                                                                                          
                                              // FourCC                               
                                              // dwPixel 0x y1  V y0  U          U0 Y0 V0 Y1
                      mov     eax, dwPixel    //         0x y1  V y0  U          U0 Y0 V0 Y1              
                      bswap   eax             //         0x  U y0  V y1          Y1 V0 Y0 U0   
                      rol     eax, 16         //         0x  V y1  U y0          Y0 U0 Y1 V0 
                      mov     dwPixel, eax         
                  }
#else

                  dwPixel = (((dwPixel & 0xff00ff00) >> 8) | ((dwPixel & 0x00ff00ff) << 8));
#endif

                 /*
                  * dwPixel now has two pixels, in this layout (MSB..LSB):
                  *
                  *  V Y1 U Y0
                  *
                  * convert to 2 yuv555 words and lookup in xlate table
                  */

                 /* get common u and v components to lower 10 bits */                          //  9 8  7 6 5  4  3 2 1 0 
                 uv55 = ((dwPixel & 0xf8000000) >> 27) | ((dwPixel & 0x0000f800) >> 6);        // U7U6:U5U4U3 V7:V6V5V4V3   


                 /* build each yuv-655 value by truncating
                  * y to 5 bits and adding the common u and v bits,
                  * look up to convert to rgb, and combine two pixels
                  * into one dword
                  */                                                             //  f e d c  b a  9 8  7 6 5  4  3 2 1 0
                 dwPixel = pXlate[((dwPixel & 0x000000f8) << 7) | uv55 ] |       //  0Y7Y6Y5:Y4Y3 U7U6:U5U4U3 V7:V6V5V4V3
                       (pXlate[((dwPixel & 0x00f80000) >> 9) | uv55 ] << 16);    //  0Y7Y6Y5:Y4Y3 U7U6:U5U4U3 V7:V6V5V4V3

                 /* write two pixels to destination */
                 *pDst++ = dwPixel;

              } // loop per 2 pixels


               /*  
                * bottom up need re-adjust its pointer by 
                * moving dest pointer back to next line
                */

                if(lpbiOutput->biHeight >= 0) {
                    pDst -= RowInc;
                }
            } 
        //
        //  yUyV
        //
        } else if(pinst->dwFormat == FOURCC_YUY2) { 

            /* loop copying each scanline */
            for (i = InputHeight; i > 0; i--) {

               /* loop copying two pixels at a time */
               for (j = Width ; j > 0; j -= 2) {

                  /*
                   * get two pixels and convert to 15-bpp YUV
                   */

                  dwPixel = *pSrc++;

                  // We are already in YUYV (0x V y1 U y0) format.

                 /* get common u and v components to lower 10 bits */                          //  9 8  7 6 5  4  3 2 1 0 
                 uv55 = ((dwPixel & 0xf8000000) >> 27) | ((dwPixel & 0x0000f800) >> 6);        // U7U6:U5U4U3 V7:V6V5V4V3   


                 /* build each yuv-655 value by truncating
                  * y to 5 bits and adding the common u and v bits,
                  * look up to convert to rgb, and combine two pixels
                  * into one dword
                  */                                                             //  f e d c  b a  9 8  7 6 5  4  3 2 1 0
                 dwPixel = pXlate[((dwPixel & 0x000000f8) << 7) | uv55 ] |       //  0Y7Y6Y5:Y4Y3 U7U6:U5U4U3 V7:V6V5V4V3
                       (pXlate[((dwPixel & 0x00f80000) >> 9) | uv55 ] << 16);    //  0Y7Y6Y5:Y4Y3 U7U6:U5U4U3 V7:V6V5V4V3

                 /* write two pixels to destination */
                 *pDst++ = dwPixel;

              } // loop per 2 pixels


               /*  
                * bottom up need re-adjust its pointer by 
                * moving dest pointer back to next line
                */

                if(lpbiOutput->biHeight >= 0) {
                    pDst -= RowInc;
                }
            }

        //
        // yVyU
        //
        } else if(pinst->dwFormat == FOURCC_YVYU) {
            /* loop copying each scanline */
            for (i = InputHeight; i > 0; i--) {

               /* loop copying two pixels at a time */
               for (j = Width ; j > 0; j -= 2) {

                  /*
                   * get two pixels and convert to 15-bpp YUV
                   */

                  dwPixel = *pSrc++;

                  /* 
                   * Convert yVyU (0x U y1 V y0) to YUYV (0x V y1 U y0) in which the translation table is built for.
                   */
#if defined(_X86_)

                  _asm {                                                                                          
                                              // FourCC                               
                                              // dwPixel 0x  U y1  V y0              
                      mov     eax, dwPixel    //         0x  U y1  V y0       
                      bswap   eax             //         0x y0  V y1  U  
                      rol     eax, 8          //         0x  V y1  U y0
                      mov     dwPixel, eax         
                  }
#else
                  // y0 and y1 stay and swap U and V
                  dwPixel = (dwPixel & 0x00ff00ff)  | ((dwPixel & 0x0000ff00) << 16) | ((dwPixel & 0xff000000) >> 16);
#endif

                 /* get common u and v components to lower 10 bits */                          //  9 8  7 6 5  4  3 2 1 0 
                 uv55 = ((dwPixel & 0xf8000000) >> 27) | ((dwPixel & 0x0000f800) >> 6);        // U7U6:U5U4U3 V7:V6V5V4V3   


                 /* build each yuv-655 value by truncating
                  * y to 5 bits and adding the common u and v bits,
                  * look up to convert to rgb, and combine two pixels
                  * into one dword
                  */                                                             //  f e d c  b a  9 8  7 6 5  4  3 2 1 0
                 dwPixel = pXlate[((dwPixel & 0x000000f8) << 7) | uv55 ] |       //  0Y7Y6Y5:Y4Y3 U7U6:U5U4U3 V7:V6V5V4V3
                       (pXlate[((dwPixel & 0x00f80000) >> 9) | uv55 ] << 16);    //  0Y7Y6Y5:Y4Y3 U7U6:U5U4U3 V7:V6V5V4V3

                 /* write two pixels to destination */
                 *pDst++ = dwPixel;

              } // loop per 2 pixels


               /*  
                * bottom up need re-adjust its pointer by 
                * moving dest pointer back to next line
                */

                if(lpbiOutput->biHeight >= 0) {
                    pDst -= RowInc;
                }
            }
        }
    }
}




/*
 * translate YUV 4:2:2 into 8-bit RGB using a lookup table. 
 *   i.e. 0x Y1:V:Y0:U -> ox index1;index0
 */
VOID
UYVYToRGB8(
    PINSTINFO pinst,
     LPBITMAPINFOHEADER lpbiInput,
     LPVOID lpInput,
     LPBITMAPINFOHEADER lpbiOutput,
     LPVOID lpOutput
)
{
    register dwPixel;
    int i, j;
    int SrcRawInc, DstRawInc, Dst3RawInc;
    PDWORD pSrc, pSrc1;        // Every 32bit UYVY
    PWORD pDst, pDst1;         // Convert to two 8bit RGB8
    int Height, Width;
    int InputHeight;
    unsigned char   y0, y1, y2, y3, 
                    u0, u1, 
                    v0, v1;
    unsigned long yuv0, yuv1;   


    Height = abs(lpbiInput->biHeight);
    InputHeight = Height;
    Width  = lpbiInput->biWidth;
 

    dprintf3(("UYVYToRGB8: %dx%d; %s %dx%dx%d=%d; %s %dx%dx%d=%d\n",
             Width, Height,
             (PCHAR) &lpbiInput->biCompression,
             lpbiInput->biWidth, lpbiInput->biHeight, lpbiInput->biBitCount, lpbiInput->biSizeImage, 
             lpbiOutput->biCompression == 0 ? "RGB": lpbiOutput->biCompression == BI_BITFIELDS ? "BITF" : (PCHAR) &lpbiOutput->biCompression,
             lpbiOutput->biWidth, lpbiOutput->biHeight, lpbiOutput->biBitCount, lpbiOutput->biSizeImage));

    ASSERT(lpbiInput->biBitCount == 16 && lpbiOutput->biBitCount == 8);
    ASSERT((lpbiOutput->biWidth == lpbiInput->biWidth) && abs(lpbiOutput->biHeight) == abs(lpbiInput->biHeight));
    ASSERT(( lpbiOutput->biWidth % 8 == 0 ));   // Align with pairs of UYVY:UYVY
    ASSERT(( lpbiOutput->biHeight % 2 == 0 ));  // Even number of lines


    /*
     * calculate the amount to adjust pDst by at the end of one line of copying.
     */

    // 2bytes per pixel; pSrc is PDWORD
    SrcRawInc = Width * 2 / sizeof(DWORD);

    // 1 byte per pixel; pDst is PWORD
    DstRawInc = Width * 1 / sizeof(WORD);
    Dst3RawInc = 3 * DstRawInc;

    pSrc  = (PDWORD) lpInput;
    pSrc1 = pSrc + SrcRawInc; 

    // UVYV->RGB8; same sign:flip.

    if(lpbiOutput->biHeight >= 0) {

       pDst  = (PWORD) ( (LPBYTE)lpOutput + (Height - 1) * Width/sizeof(BYTE) );
       pDst1 = (PWORD) ( (LPBYTE)lpOutput + (Height - 2) * Width/sizeof(BYTE) );
    } else {
       pDst  = (PWORD) lpOutput;
       pDst1 = (PWORD) ((LPBYTE)lpOutput+Width/sizeof(BYTE));
    }

    if(pinst->dwFormat == FOURCC_UYVY) {

        // loop copying two scanline 
        for (i = InputHeight; i > 0; i -= 2) {
            // loop copying four (% 8) pixels at a time 
            for (j = Width ; j > 0; j -= 4) {
            
                //
                // Translate TopLeft, TopRight
                //

                dwPixel = *pSrc++;
                // Pixel is in this format: Y1:V:Y0:U 
                y0 = (dwPixel & 0x0000ff00) >> 8;
                y1 = (dwPixel & 0xff000000) >> 24;
                u0 = (dwPixel & 0x000000ff);
                v0 = (dwPixel & 0x00ff0000) >> 16;

                dwPixel = *pSrc++;
                y2 = (dwPixel & 0x0000ff00) >> 8;
                y3 = (dwPixel & 0xff000000) >> 24;
                u1 = (dwPixel & 0x000000ff);
                v1 = (dwPixel & 0x00ff0000) >> 16;

                yuv0 = yLUT_1[y1+2] | yLUT_0[y0+10] | cLUT_B0[u0]   | cLUT_R0[v0];
                yuv1 = yLUT_1[y3+0] | yLUT_0[y2+8]  | cLUT_B0[u1+4] | cLUT_R0[v1+4];  

                *pDst++ = (WORD) yuv0;
                *pDst++ = (WORD) yuv1;

                //
                // Translate BottomLeft, BottomRight
                //

                dwPixel = *pSrc1++;
                // Pixel is in this format: Y1:V:Y0:U
                y0 = (dwPixel & 0x0000ff00) >> 8;
                y1 = (dwPixel & 0xff000000) >> 24;
                u0 = (dwPixel & 0x000000ff);
                v0 = (dwPixel & 0x00ff0000) >> 16;

                dwPixel = *pSrc1++;
                y2 = (dwPixel & 0x0000ff00) >> 8;
                y3 = (dwPixel & 0xff000000) >> 24;
                u1 = (dwPixel & 0x000000ff);
                v1 = (dwPixel & 0x00ff0000) >> 16;

                yuv0 = yLUT_1[y1+0] | yLUT_0[y0+8]  | cLUT_B0[u0+4] | cLUT_R0[v0+4];
                yuv1 = yLUT_1[y3+2] | yLUT_0[y2+10] | cLUT_B0[u1+0] | cLUT_R0[v1+0];  

                *pDst1++ = (WORD) yuv0;
                *pDst1++ = (WORD) yuv1;

            } // 2 * 4 pixel per loops


           /*  
            * bottom up need re-adjust its pointer by 
            * moving dest pointer back to next line
            */
            if (lpbiOutput->biHeight >= 0) {

               pDst  -= Dst3RawInc;    
               pDst1 -= Dst3RawInc;             

            } else {

                pDst  += DstRawInc; 
                pDst1 += DstRawInc; 
            }

            pSrc  += SrcRawInc; 
            pSrc1 += SrcRawInc; 

        } // 2 lines per loop
    } else if(pinst->dwFormat == FOURCC_YUY2) { // YUY2

        // loop copying two scanline 
        for (i = InputHeight; i > 0; i -= 2) {
            // loop copying four (% 8) pixels at a time 
            for (j = Width ; j > 0; j -= 4) {
            
                //
                // Translate TopLeft, TopRight
                //

                dwPixel = *pSrc++;
                // Pixel is in this format: V:Y1:U:Y0
                u0 = (dwPixel & 0x0000ff00) >> 8;
                v0 = (dwPixel & 0xff000000) >> 24;
                y0 = (dwPixel & 0x000000ff);
                y1 = (dwPixel & 0x00ff0000) >> 16;

                dwPixel = *pSrc++;
                u1 = (dwPixel & 0x0000ff00) >> 8;
                v1 = (dwPixel & 0xff000000) >> 24;
                y2 = (dwPixel & 0x000000ff);
                y3 = (dwPixel & 0x00ff0000) >> 16;

                yuv0 = yLUT_1[y1+2] | yLUT_0[y0+10] | cLUT_B0[u0]   | cLUT_R0[v0];
                yuv1 = yLUT_1[y3+0] | yLUT_0[y2+8]  | cLUT_B0[u1+4] | cLUT_R0[v1+4];  

                *pDst++ = (WORD) yuv0;
                *pDst++ = (WORD) yuv1;

                //
                // Translate BottomLeft, BottomRight
                //

                dwPixel = *pSrc1++;
                // Pixel is in this format: V:Y1:U:Y0
                u0 = (dwPixel & 0x0000ff00) >> 8;
                v0 = (dwPixel & 0xff000000) >> 24;
                y0 = (dwPixel & 0x000000ff);
                y1 = (dwPixel & 0x00ff0000) >> 16;

                dwPixel = *pSrc1++;
                u1 = (dwPixel & 0x0000ff00) >> 8;
                v1 = (dwPixel & 0xff000000) >> 24;
                y2 = (dwPixel & 0x000000ff);
                y3 = (dwPixel & 0x00ff0000) >> 16;

                yuv0 = yLUT_1[y1+0] | yLUT_0[y0+8]  | cLUT_B0[u0+4] | cLUT_R0[v0+4];
                yuv1 = yLUT_1[y3+2] | yLUT_0[y2+10] | cLUT_B0[u1+0] | cLUT_R0[v1+0];  

                *pDst1++ = (WORD) yuv0;
                *pDst1++ = (WORD) yuv1;

            } // 2 * 4 pixel per loops


           /*  
            * bottom up need re-adjust its pointer by 
            * moving dest pointer back to next line
            */
            if (lpbiOutput->biHeight >= 0) {

               pDst  -= Dst3RawInc;    
               pDst1 -= Dst3RawInc;             

            } else {

                pDst  += DstRawInc; 
                pDst1 += DstRawInc; 
            }

            pSrc  += SrcRawInc; 
            pSrc1 += SrcRawInc; 

        } // 2 lines per loop


    } else if(pinst->dwFormat == FOURCC_YVYU) {
        // loop copying two scanline 
        for (i = InputHeight; i > 0; i -= 2) {
            // loop copying four (% 8) pixels at a time 
            for (j = Width ; j > 0; j -= 4) {
            
                //
                // Translate TopLeft, TopRight
                //

                dwPixel = *pSrc++;
                // Pixel is in this format: U:Y1:V:Y0
                v0 = (dwPixel & 0x0000ff00) >> 8;
                u0 = (dwPixel & 0xff000000) >> 24;
                y0 = (dwPixel & 0x000000ff);
                y1 = (dwPixel & 0x00ff0000) >> 16;

                dwPixel = *pSrc++;
                v1 = (dwPixel & 0x0000ff00) >> 8;
                u1 = (dwPixel & 0xff000000) >> 24;
                y2 = (dwPixel & 0x000000ff);
                y3 = (dwPixel & 0x00ff0000) >> 16;

                yuv0 = yLUT_1[y1+2] | yLUT_0[y0+10] | cLUT_B0[u0]   | cLUT_R0[v0];
                yuv1 = yLUT_1[y3+0] | yLUT_0[y2+8]  | cLUT_B0[u1+4] | cLUT_R0[v1+4];  

                *pDst++ = (WORD) yuv0;
                *pDst++ = (WORD) yuv1;

                //
                // Translate BottomLeft, BottomRight
                //

                dwPixel = *pSrc1++;
                // Pixel is in this format: U:Y1:V:Y0
                v0 = (dwPixel & 0x0000ff00) >> 8;
                u0 = (dwPixel & 0xff000000) >> 24;
                y0 = (dwPixel & 0x000000ff);
                y1 = (dwPixel & 0x00ff0000) >> 16;

                dwPixel = *pSrc1++;
                v1 = (dwPixel & 0x0000ff00) >> 8;
                u1 = (dwPixel & 0xff000000) >> 24;
                y2 = (dwPixel & 0x000000ff);
                y3 = (dwPixel & 0x00ff0000) >> 16;

                yuv0 = yLUT_1[y1+0] | yLUT_0[y0+8]  | cLUT_B0[u0+4] | cLUT_R0[v0+4];
                yuv1 = yLUT_1[y3+2] | yLUT_0[y2+10] | cLUT_B0[u1+0] | cLUT_R0[v1+0];  

                *pDst1++ = (WORD) yuv0;
                *pDst1++ = (WORD) yuv1;

            } // 2 * 4 pixel per loops


           /*  
            * bottom up need re-adjust its pointer by 
            * moving dest pointer back to next line
            */
            if (lpbiOutput->biHeight >= 0) {

               pDst  -= Dst3RawInc;    
               pDst1 -= Dst3RawInc;             

            } else {

                pDst  += DstRawInc; 
                pDst1 += DstRawInc; 
            }

            pSrc  += SrcRawInc; 
            pSrc1 += SrcRawInc; 

        } // 2 lines per loop

    }

}

VOID
UYVYToRGB32(
    PINSTINFO pinst,
    LPBITMAPINFOHEADER lpbiInput,
    LPVOID lpInput,
    LPBITMAPINFOHEADER lpbiOutput,
    LPVOID lpOutput
)
{
    int Height = abs( lpbiInput->biHeight );
    int Width = lpbiInput->biWidth;
    short U;
    short V;
    short y0, y1;
    short d;
    DWORD * pSrc = lpInput;
    BYTE * pDst = lpOutput;
    long WidthBytes = Width * 4; // ARGB = 4 bytes
    int i, j;
    DWORD dwYUV;
    long l;

    // set up the lookup table arrays
    //
    short * yip = pinst->pXlate;
    short * vrip = yip + 256;
    short * vgip = vrip + 256;
    short * ugip = vgip + 256;
    short * ubip = ugip + 256;

    // if just a straight copy
    //
    if(lpbiOutput->biCompression == FOURCC_UYVY ||
       lpbiOutput->biCompression == FOURCC_YUY2 ||
       lpbiOutput->biCompression == FOURCC_YVYU  ) 
    {
       memcpy( pDst, pSrc, WidthBytes * Height );  // Top down
       return;

    }

    // flip around if necessary
    //
    if(lpbiOutput->biHeight >= 0) 
    {
       pDst += (Height - 1) * WidthBytes;
    }

    if( pinst->dwFormat == FOURCC_UYVY ) // U0 Y0 V0 Y1 U2 Y2 V2 Y3
    {
        for (i = Height; i > 0; i--) 
        {
           /* loop copying two pixels at a time */
           for (j = Width ; j > 0; j -= 2) 
           {
                // get two YUV pixels at a time
                //
                dwYUV = *pSrc++; // U0 Y0 V0 Y1
                U = (short) ( dwYUV & 0xFF ); 
                    dwYUV = dwYUV >> 8;
                y0 = yip[( dwYUV & 0xFF )];
                    dwYUV = dwYUV >> 8;
                V = (short) ( dwYUV & 0xFF );
                    dwYUV = dwYUV >> 8;
                y1 = yip[( dwYUV & 0xFF )];

                d = y0 + ubip[U]; // blue
                        if( d < 0 ) d = 0;
                        if( d > 255 ) d = 255;
                        *pDst++ = (BYTE) d;
                d = y0 + ugip[U] + vgip[V]; // green
                        if( d < 0 ) d = 0;
                        if( d > 255 ) d = 255;
                        *pDst++ = (BYTE) d;
                d = y0 + vrip[V]; // red
                        if( d < 0 ) d = 0;
                        if( d > 255 ) d = 255;
                        *pDst++ = (BYTE) d;
                        pDst++;

                d = y1 + ubip[U]; // blue
                        if( d < 0 ) d = 0;
                        if( d > 255 ) d = 255;
                        *pDst++ = (BYTE) d;
                d = y1 + ugip[U] + vgip[V]; // green
                        if( d < 0 ) d = 0;
                        if( d > 255 ) d = 255;
                        *pDst++ = (BYTE) d;
                d = y1 + vrip[V]; // red
                        if( d < 0 ) d = 0;
                        if( d > 255 ) d = 255;
                        *pDst++ = (BYTE) d;
                        pDst++;
           } // for j

            // back up two rows to get to the next scanline
            //
            if(lpbiOutput->biHeight >= 0) 
            {
                pDst -= WidthBytes * 2;
            }
        } // for i
    } // UYVY
    else if( pinst->dwFormat == FOURCC_YUY2 ) // Y0 U0 Y1 V0...
    {
        for (i = Height; i > 0; i--) 
        {
           /* loop copying two pixels at a time */
           for (j = Width ; j > 0; j -= 2) 
           {
                // We are already in YUYV (0x V y1 U y0) format.

#if 0 // straight computation
                // get two YUV pixels at a time
                //
                dwYUV = *pSrc++; // Y0 U0 Y1 V0
                y0 = (short) ( dwYUV & 0xFF ) - 16;
                    dwYUV = dwYUV >> 8;
                U = (short) ( dwYUV & 0xFF ) - 128;
                    dwYUV = dwYUV >> 8;
                y1 = (short) ( dwYUV & 0xFF ) - 16;
                    dwYUV = dwYUV >> 8;
                V = (short) ( dwYUV & 0xFF ) - 128;

                l = ( ( y0 * 298L ) + ( 517L * U ) ) / 256; // blue
                if( l < 0 ) l = 0;
                if( l > 255 ) l = 255;
                        *pDst++ = (BYTE) l; // blue
                l = ( ( y0 * 298L ) - ( 100L * U ) - ( 208L * V ) ) / 256; // green
                if( l < 0 ) l = 0;
                if( l > 255 ) l = 255;
                        *pDst++ = (BYTE) l; // green
                l = ( ( y0 * 298L ) + ( 409L * V ) ) / 256; // red
                if( l < 0 ) l = 0;
                if( l > 255 ) l = 255;
                        *pDst++ = (BYTE) l; // red
                        pDst++;

                l = ( ( y1 * 298L ) + ( 517L * U ) ) / 256; // blue
                if( l < 0 ) l = 0;
                if( l > 255 ) l = 255;
                        *pDst++ = (BYTE) l; // blue
                l = ( ( y1 * 298L ) - ( 100L * U ) - ( 208L * V ) ) / 256; // green
                if( l < 0 ) l = 0;
                if( l > 255 ) l = 255;
                        *pDst++ = (BYTE) l; // green
                l = ( ( y1 * 298L ) + ( 409L * V ) ) / 256; // red
                if( l < 0 ) l = 0;
                if( l > 255 ) l = 255;
                        *pDst++ = (BYTE) l; // red
                        pDst++;

#else // table lookup
                // get two YUV pixels at a time
                //
                dwYUV = *pSrc++; // Y0 U0 Y1 V0
                y0 = yip[( dwYUV & 0xFF )];
                    dwYUV = dwYUV >> 8;
                U = (short) ( dwYUV & 0xFF );
                    dwYUV = dwYUV >> 8;
                y1 = yip[( dwYUV & 0xFF )];
                    dwYUV = dwYUV >> 8;
                V = (short) ( dwYUV & 0xFF );


                d = y0 + ubip[U]; // blue
                        if( d < 0 ) d = 0;
                        if( d > 255 ) d = 255;
                        *pDst++ = (BYTE) d;
                d = y0 + ugip[U] + vgip[V]; // green
                        if( d < 0 ) d = 0;
                        if( d > 255 ) d = 255;
                        *pDst++ = (BYTE) d;
                d = y0 + vrip[V]; // red
                        if( d < 0 ) d = 0;
                        if( d > 255 ) d = 255;
                        *pDst++ = (BYTE) d;
                        pDst++;


                d = y1 + ubip[U]; // blue
                        if( d < 0 ) d = 0;
                        if( d > 255 ) d = 255;
                        *pDst++ = (BYTE) d;
                d = y1 + ugip[U] + vgip[V]; // green
                        if( d < 0 ) d = 0;
                        if( d > 255 ) d = 255;
                        *pDst++ = (BYTE) d;
                d = y1 + vrip[V]; // red
                        if( d < 0 ) d = 0;
                        if( d > 255 ) d = 255;
                        *pDst++ = (BYTE) d;
                        pDst++;
#endif
           } // for j

            // back up two rows to get to the next scanline
            //
            if(lpbiOutput->biHeight >= 0) 
            {
                pDst -= WidthBytes * 2;
            }
        } // for i  
    }
    else if( pinst->dwFormat == FOURCC_YVYU ) // Y0 V0 Y1 U0...
    {
        for (i = Height; i > 0; i--) 
        {
           /* loop copying two pixels at a time */
           for (j = Width ; j > 0; j -= 2) 
           {
                // get two YUV pixels at a time
                //
                dwYUV = *pSrc++; // Y0 U0 Y1 V0
                y0 = yip[( dwYUV & 0xFF )];
                    dwYUV = dwYUV >> 8;
                V = (short) ( dwYUV & 0xFF );
                    dwYUV = dwYUV >> 8;
                y1 = yip[( dwYUV & 0xFF )];
                    dwYUV = dwYUV >> 8;
                U = (short) ( dwYUV & 0xFF );

                d = y0 + ubip[U]; // blue
                        if( d < 0 ) d = 0;
                        if( d > 255 ) d = 255;
                        *pDst++ = (BYTE) d;
                d = y0 + ugip[U] + vgip[V]; // green
                        if( d < 0 ) d = 0;
                        if( d > 255 ) d = 255;
                        *pDst++ = (BYTE) d;
                d = y0 + vrip[V]; // red
                        if( d < 0 ) d = 0;
                        if( d > 255 ) d = 255;
                        *pDst++ = (BYTE) d;
                        pDst++;


                d = y1 + ubip[U]; // blue
                        if( d < 0 ) d = 0;
                        if( d > 255 ) d = 255;
                        *pDst++ = (BYTE) d;
                d = y1 + ugip[U] + vgip[V]; // green
                        if( d < 0 ) d = 0;
                        if( d > 255 ) d = 255;
                        *pDst++ = (BYTE) d;
                d = y1 + vrip[V]; // red
                        if( d < 0 ) d = 0;
                        if( d > 255 ) d = 255;
                        *pDst++ = (BYTE) d;
                        pDst++;
           } // for j

            // back up two rows to get to the next scanline
            //
            if(lpbiOutput->biHeight >= 0) 
            {
                pDst -= WidthBytes * 2;
            }
        } // for i
    }

}

VOID
UYVYToRGB24(
    PINSTINFO pinst,
    LPBITMAPINFOHEADER lpbiInput,
    LPVOID lpInput,
    LPBITMAPINFOHEADER lpbiOutput,
    LPVOID lpOutput
)
{
    int Height = abs( lpbiInput->biHeight );
    int Width = lpbiInput->biWidth;
    short U;
    short V;
    short y0, y1;
    short d;
    DWORD * pSrc = lpInput;
    BYTE * pDst = lpOutput;
    long WidthBytes = Width * 3; // RGB = 3 bytes
    int i, j;
    DWORD dwYUV;
    long l;
    short maxd = 0;
    short mind = 255;

    // set up the lookup table arrays
    //
    short * yip = pinst->pXlate;
    short * vrip = yip + 256;
    short * vgip = vrip + 256;
    short * ugip = vgip + 256;
    short * ubip = ugip + 256;

    // if just a straight copy
    //
    if(lpbiOutput->biCompression == FOURCC_UYVY ||
       lpbiOutput->biCompression == FOURCC_YUY2 ||
       lpbiOutput->biCompression == FOURCC_YVYU  ) 
    {
       memcpy( pDst, pSrc, WidthBytes * Height );  // Top down
       return;

    }

    // flip around if necessary
    //
    if(lpbiOutput->biHeight >= 0) 
    {
       pDst += (Height - 1) * WidthBytes;
    }

    if( pinst->dwFormat == FOURCC_UYVY ) // U0 Y0 V0 Y1 U2 Y2 V2 Y3
    {
        for (i = Height; i > 0; i--) 
        {
           /* loop copying two pixels at a time */
           for (j = Width ; j > 0; j -= 2) 
           {
                // get two YUV pixels at a time
                //
                dwYUV = *pSrc++; // U0 Y0 V0 Y1
                U = (short) ( dwYUV & 0xFF ); 
                    dwYUV = dwYUV >> 8;
                y0 = yip[( dwYUV & 0xFF )];
                    dwYUV = dwYUV >> 8;
                V = (short) ( dwYUV & 0xFF );
                    dwYUV = dwYUV >> 8;
                y1 = yip[( dwYUV & 0xFF )];

                d = y0 + ubip[U]; // blue
                        if( d < 0 ) d = 0;
                        if( d > 255 ) d = 255;
                        *pDst++ = (BYTE) d;
                d = y0 + ugip[U] + vgip[V]; // green
                        if( d < 0 ) d = 0;
                        if( d > 255 ) d = 255;
                        *pDst++ = (BYTE) d;
                d = y0 + vrip[V]; // red
                        if( d < 0 ) d = 0;
                        if( d > 255 ) d = 255;
                        *pDst++ = (BYTE) d;


                d = y1 + ubip[U]; // blue
                        if( d < 0 ) d = 0;
                        if( d > 255 ) d = 255;
                        *pDst++ = (BYTE) d;
                d = y1 + ugip[U] + vgip[V]; // green
                        if( d < 0 ) d = 0;
                        if( d > 255 ) d = 255;
                        *pDst++ = (BYTE) d;
                d = y1 + vrip[V]; // red
                        if( d < 0 ) d = 0;
                        if( d > 255 ) d = 255;
                        *pDst++ = (BYTE) d;
           } // for j

            // back up two rows to get to the next scanline
            //
            if(lpbiOutput->biHeight >= 0) 
            {
                pDst -= WidthBytes * 2;
            }
        } // for i
    } // UYVY
    else if( pinst->dwFormat == FOURCC_YUY2 ) // Y0 U0 Y1 V0...
    {
        for (i = Height; i > 0; i--) 
        {
           /* loop copying two pixels at a time */
           for (j = Width ; j > 0; j -= 2) 
           {
                // We are already in YUYV (0x V y1 U y0) format.

#if 0 // straight computation
                // get two YUV pixels at a time
                //
                dwYUV = *pSrc++; // Y0 U0 Y1 V0
                y0 = (short) ( dwYUV & 0xFF ) - 16;
                    dwYUV = dwYUV >> 8;
                U = (short) ( dwYUV & 0xFF ) - 128;
                    dwYUV = dwYUV >> 8;
                y1 = (short) ( dwYUV & 0xFF ) - 16;
                    dwYUV = dwYUV >> 8;
                V = (short) ( dwYUV & 0xFF ) - 128;

                l = ( ( y0 * 298L ) + ( 517L * U ) ) / 256; // blue
                if( l < 0 ) l = 0;
                if( l > 255 ) l = 255;
                        *pDst++ = (BYTE) l; // blue
                l = ( ( y0 * 298L ) - ( 100L * U ) - ( 208L * V ) ) / 256; // green
                if( l < 0 ) l = 0;
                if( l > 255 ) l = 255;
                        *pDst++ = (BYTE) l; // green
                l = ( ( y0 * 298L ) + ( 409L * V ) ) / 256; // red
                if( l < 0 ) l = 0;
                if( l > 255 ) l = 255;
                        *pDst++ = (BYTE) l; // red
                l = ( ( y1 * 298L ) + ( 517L * U ) ) / 256; // blue
                if( l < 0 ) l = 0;
                if( l > 255 ) l = 255;
                        *pDst++ = (BYTE) l; // blue
                l = ( ( y1 * 298L ) - ( 100L * U ) - ( 208L * V ) ) / 256; // green
                if( l < 0 ) l = 0;
                if( l > 255 ) l = 255;
                        *pDst++ = (BYTE) l; // green
                l = ( ( y1 * 298L ) + ( 409L * V ) ) / 256; // red
                if( l < 0 ) l = 0;
                if( l > 255 ) l = 255;
                        *pDst++ = (BYTE) l; // red
#else // table lookup
                // get two YUV pixels at a time
                //
                dwYUV = *pSrc++; // Y0 U0 Y1 V0
                y0 = yip[( dwYUV & 0xFF )];
                    dwYUV = dwYUV >> 8;
                U = (short) ( dwYUV & 0xFF );
                    dwYUV = dwYUV >> 8;
                y1 = yip[( dwYUV & 0xFF )];
                    dwYUV = dwYUV >> 8;
                V = (short) ( dwYUV & 0xFF );


                d = y0 + ubip[U]; // blue
                        if( d < 0 ) d = 0;
                        if( d > 255 ) d = 255;
                        *pDst++ = (BYTE) d;
                d = y0 + ugip[U] + vgip[V]; // green
                        if( d < 0 ) d = 0;
                        if( d > 255 ) d = 255;
                        *pDst++ = (BYTE) d;
                d = y0 + vrip[V]; // red
                        if( d < 0 ) d = 0;
                        if( d > 255 ) d = 255;
                        *pDst++ = (BYTE) d;


                d = y1 + ubip[U]; // blue
                        if( d < 0 ) d = 0;
                        if( d > 255 ) d = 255;
                        *pDst++ = (BYTE) d;
                d = y1 + ugip[U] + vgip[V]; // green
                        if( d < 0 ) d = 0;
                        if( d > 255 ) d = 255;
                        *pDst++ = (BYTE) d;
                d = y1 + vrip[V]; // red
                        if( d < 0 ) d = 0;
                        if( d > 255 ) d = 255;
                        *pDst++ = (BYTE) d;
#endif
           } // for j

            // back up two rows to get to the next scanline
            //
            if(lpbiOutput->biHeight >= 0) 
            {
                pDst -= WidthBytes * 2;
            }
        } // for i  
    }
    else if( pinst->dwFormat == FOURCC_YVYU ) // Y0 V0 Y1 U0...
    {
        for (i = Height; i > 0; i--) 
        {
           /* loop copying two pixels at a time */
           for (j = Width ; j > 0; j -= 2) 
           {
                // get two YUV pixels at a time
                //
                dwYUV = *pSrc++; // Y0 U0 Y1 V0
                y0 = yip[( dwYUV & 0xFF )];
                    dwYUV = dwYUV >> 8;
                V = (short) ( dwYUV & 0xFF );
                    dwYUV = dwYUV >> 8;
                y1 = yip[( dwYUV & 0xFF )];
                    dwYUV = dwYUV >> 8;
                U = (short) ( dwYUV & 0xFF );

                d = y0 + ubip[U]; // blue
                        if( d < 0 ) d = 0;
                        if( d > 255 ) d = 255;
                        *pDst++ = (BYTE) d;
                d = y0 + ugip[U] + vgip[V]; // green
                        if( d < 0 ) d = 0;
                        if( d > 255 ) d = 255;
                        *pDst++ = (BYTE) d;
                d = y0 + vrip[V]; // red
                        if( d < 0 ) d = 0;
                        if( d > 255 ) d = 255;
                        *pDst++ = (BYTE) d;

                d = y1 + ubip[U]; // blue
                        if( d < 0 ) d = 0;
                        if( d > 255 ) d = 255;
                        *pDst++ = (BYTE) d;
                d = y1 + ugip[U] + vgip[V]; // green
                        if( d < 0 ) d = 0;
                        if( d > 255 ) d = 255;
                        *pDst++ = (BYTE) d;
                d = y1 + vrip[V]; // red
                        if( d < 0 ) d = 0;
                        if( d > 255 ) d = 255;
                        *pDst++ = (BYTE) d;
           } // for j

            // back up two rows to get to the next scanline
            //
            if(lpbiOutput->biHeight >= 0) 
            {
                pDst -= WidthBytes * 2;
            }
        } // for i
    }

}


#define OFFSET 10
#define STDPALCOLOURS 256
/*****************************************************************************
 *
 * DecompressGetPalette() implements ICM_GET_PALETTE
 *
 * This function has no Compress...() equivalent
 *
 * It is used to pull the palette from a frame in order to possibly do
 * a palette change.
 *
 ****************************************************************************/
DWORD NEAR PASCAL DecompressGetPalette(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut)
{
    DWORD dw;
    unsigned char * lpPalArea;
    long Index, cntEntries;
    HDC hDC;

    PALETTEENTRY apeSystem[STDPALCOLOURS]; // OFFSET];


    dprintf2((TEXT("DecompressGetPalette()\n")));
    if (dw = DecompressQuery(pinst, lpbiIn, NULL))
     return dw;

    if (lpbiOut->biBitCount != 8) {  /* 8-bit only for palettes */ 
        dprintf1(("DecompressGetPalette: Unsupported lpbiOut->biBitCount=%d\n", lpbiOut->biBitCount)); 
     return (DWORD)ICERR_ERROR;
    }

    // Initialise the palette entries in the header

    dprintf1(("DecompressGetPalette(): in->biSize=%d, out->biSize=%d\n", lpbiIn->biSize, lpbiOut->biSize));


    // Get the standard system colours

    if ( hDC = GetDC(GetDesktopWindow()) )
    {
        cntEntries = GetSystemPaletteEntries(hDC,0,STDPALCOLOURS,apeSystem);
        ReleaseDC(GetDesktopWindow(),hDC);
    }

    if (cntEntries == 0) {
        dprintf2(("DecompressGetPalette:cntEntries is 0; GetSystemPaletteEntries failed.\n"));

        lpbiOut->biClrUsed      = 0;
        lpbiOut->biClrImportant = 0; 
        return (DWORD) ICERR_OK;
    }


    lpbiOut->biClrUsed      = STDPALCOLOURS;
    lpbiOut->biClrImportant = 0;

    // Adding system device colours to be dithered
    lpPalArea = (unsigned char *)lpbiOut + (int)lpbiOut->biSize;
    
    // Copy the first ten VGA system colours

    for (Index = 0;Index < OFFSET;Index++) {
        lpPalArea[Index*4+0] = apeSystem[Index].peRed;
        lpPalArea[Index*4+1] = apeSystem[Index].peGreen;
        lpPalArea[Index*4+2] = apeSystem[Index].peBlue;
        lpPalArea[Index*4+3] = 0;
    }


    // Copy the palette we dither to one colour at a time

    for (Index = OFFSET;Index < STDPALCOLOURS-OFFSET;Index++) {
        lpPalArea[Index*4+0] = PalTable[Index*4+2];
        lpPalArea[Index*4+1] = PalTable[Index*4+1];
        lpPalArea[Index*4+2] = PalTable[Index*4+0];
        lpPalArea[Index*4+3] = 0;
    }

     // Copy the last ten VGA system colours

    for (Index = STDPALCOLOURS-OFFSET;Index < STDPALCOLOURS;Index++) {
        lpPalArea[Index*4+0] = apeSystem[Index].peRed;
        lpPalArea[Index*4+1] = apeSystem[Index].peGreen;
        lpPalArea[Index*4+2] = apeSystem[Index].peBlue;
        lpPalArea[Index*4+3] = 0;
    }

 return (DWORD)ICERR_OK;

}


VOID FreeXlate(PINSTINFO pinst)
{

    ASSERT(pinst != NULL);        
    if (pinst && pinst->pXlate != NULL) {
       VirtualFree(pinst->pXlate, 0, MEM_RELEASE); 
       pinst->pXlate = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\codec\tsbyuv\drvproc.c ===
/*----------------------------------------------------------------------+
|									|
| drvproc.c - driver procedure						|
|									|
| Copyright (c) 1993 Microsoft Corporation.				|
| All Rights Reserved.							|
|									|
+----------------------------------------------------------------------*/

#include <windows.h>

#include "msyuv.h"

HMODULE ghModule;     // Our DLL module handle


/***************************************************************************
 * DriverProc  -  The entry point for an installable driver.
 *
 * PARAMETERS
 * dwDriverId:  For most messages, <dwDriverId> is the DWORD
 *     value that the driver returns in response to a <DRV_OPEN> message.
 *     Each time that the driver is opened, through the <DrvOpen> API,
 *     the driver receives a <DRV_OPEN> message and can return an
 *     arbitrary, non-zero value. The installable driver interface
 *     saves this value and returns a unique driver handle to the
 *     application. Whenever the application sends a message to the
 *     driver using the driver handle, the interface routes the message
 *     to this entry point and passes the corresponding <dwDriverId>.
 *     This mechanism allows the driver to use the same or different
 *     identifiers for multiple opens but ensures that driver handles
 *     are unique at the application interface layer.
 *
 *     The following messages are not related to a particular open
 *     instance of the driver. For these messages, the dwDriverId
 *     will always be zero.
 *
 *         DRV_LOAD, DRV_FREE, DRV_ENABLE, DRV_DISABLE, DRV_OPEN
 *
 * hDriver: This is the handle returned to the application by the
 *    driver interface.
 *
 * uiMessage: The requested action to be performed. Message
 *     values below <DRV_RESERVED> are used for globally defined messages.
 *     Message values from <DRV_RESERVED> to <DRV_USER> are used for
 *     defined driver protocols. Messages above <DRV_USER> are used
 *     for driver specific messages.
 *
 * lParam1: Data for this message.  Defined separately for
 *     each message
 *
 * lParam2: Data for this message.  Defined separately for
 *     each message
 *
 * RETURNS
 *   Defined separately for each message.
 *
 ***************************************************************************/

LRESULT  DriverProc(PINSTINFO pi, HDRVR hDriver, UINT uiMessage, LPARAM lParam1, LPARAM lParam2)
{
    switch (uiMessage)
    {
	case DRV_LOAD:
#ifdef _WIN32
            if (ghModule) {
                // AVI explicitly loads us as well, but does not pass the
                // correct (as known by WINMM) driver handle.
            } else {
                ghModule = (HANDLE) GetDriverModuleHandle(hDriver);
            }
#endif
	    return (LRESULT) 1L;

	case DRV_FREE:
	    return (LRESULT)1L;

        case DRV_OPEN:
	    // if being opened with no open struct, then return a non-zero
	    // value without actually opening
	    if (lParam2 == 0L)
                return 0xFFFF0000;

	    return (LRESULT)(DWORD_PTR) Open((ICOPEN FAR *) lParam2);

	case DRV_CLOSE:
#ifdef _WIN32
	    if (pi != (PINSTINFO)(ULONG_PTR)0xFFFF0000)
#else
	    if (pi)
#endif
		Close(pi);

	    return (LRESULT)1L;

	/*********************************************************************

	    state messages

	*********************************************************************/

        case DRV_QUERYCONFIGURE:    // configuration from drivers applet
            return (LRESULT)0L;

        case DRV_CONFIGURE:
            return DRV_OK;

        case ICM_CONFIGURE:
            //
            //  return ICERR_OK if you will do a configure box, error otherwise
            //
            if (lParam1 == -1)
		return QueryConfigure(pi) ? ICERR_OK : ICERR_UNSUPPORTED;
	    else
		return Configure(pi, (HWND)lParam1);

        case ICM_ABOUT:
            //
            //  return ICERR_OK if you will do a about box, error otherwise
            //
            if (lParam1 == -1)
		return QueryAbout(pi) ? ICERR_OK : ICERR_UNSUPPORTED;
	    else
		return About(pi, (HWND)lParam1);

	case ICM_GETSTATE:
	    return GetState(pi, (LPVOID)lParam1, (DWORD)lParam2);

	case ICM_SETSTATE:
	    return SetState(pi, (LPVOID)lParam1, (DWORD)lParam2);

	case ICM_GETINFO:
            return GetInfo(pi, (ICINFO FAR *)lParam1, (DWORD)lParam2);

        case ICM_GETDEFAULTQUALITY:
            if (lParam1)
            {
                *((LPDWORD)lParam1) = 7500;
                return ICERR_OK;
            }
            break;
	
	/*********************************************************************

	    compression messages

	*********************************************************************/
#ifdef ICM_COMPRESS_SUPPORTED

	case ICM_COMPRESS_QUERY:
	    return CompressQuery(pi,
			 (LPBITMAPINFOHEADER)lParam1,
			 (LPBITMAPINFOHEADER)lParam2);

	case ICM_COMPRESS_BEGIN:
	    return CompressBegin(pi,
			 (LPBITMAPINFOHEADER)lParam1,
			 (LPBITMAPINFOHEADER)lParam2);

	case ICM_COMPRESS_GET_FORMAT:
	    return CompressGetFormat(pi,
			 (LPBITMAPINFOHEADER)lParam1,
			 (LPBITMAPINFOHEADER)lParam2);

	case ICM_COMPRESS_GET_SIZE:
	    return CompressGetSize(pi,
			 (LPBITMAPINFOHEADER)lParam1,
			 (LPBITMAPINFOHEADER)lParam2);
	
	case ICM_COMPRESS:
	    return Compress(pi,
			    (ICCOMPRESS FAR *)lParam1, (DWORD)lParam2);

	case ICM_COMPRESS_END:
	    return CompressEnd(pi);
	
#endif // ICM_DRAW_SUPPORTED

	/*********************************************************************

	    decompress messages

	*********************************************************************/

	case ICM_DECOMPRESS_QUERY:
	    return DecompressQuery(pi,
			 (LPBITMAPINFOHEADER)lParam1,
			 (LPBITMAPINFOHEADER)lParam2);

	case ICM_DECOMPRESS_BEGIN:
	    return DecompressBegin(pi,
			 (LPBITMAPINFOHEADER)lParam1,
			 (LPBITMAPINFOHEADER)lParam2);

	case ICM_DECOMPRESS_GET_FORMAT:
	    return DecompressGetFormat(pi,
			 (LPBITMAPINFOHEADER)lParam1,
                         (LPBITMAPINFOHEADER)lParam2);

        case ICM_DECOMPRESS_GET_PALETTE:
            return DecompressGetPalette(pi,
			 (LPBITMAPINFOHEADER)lParam1,
			 (LPBITMAPINFOHEADER)lParam2);

	case ICM_DECOMPRESS:
	    return Decompress(pi,
			 (ICDECOMPRESS FAR *)lParam1, (DWORD)lParam2);

	case ICM_DECOMPRESS_END:
	    return DecompressEnd(pi);

	/*********************************************************************

	    draw messages

	*********************************************************************/
#ifdef ICM_DRAW_SUPPORTED

	case ICM_DRAW_BEGIN:
	    /*
	     * sent when a sequence of draw calls are about to start -
	     * enable hardware.
	     */
            return DrawBegin(pi,(ICDRAWBEGIN FAR *)lParam1, (DWORD)lParam2);

	case ICM_DRAW:
	    /*
	     * frame ready for decompress. Since we don't have any pre-buffering,
	     * it is ok to render the frame at this time too. If we had
	     * pre-buffer, we would queue now, and start clocking frames out
	     * on the draw-start message.
	     */
            return Draw(pi,(ICDRAW FAR *)lParam1, (DWORD)lParam2);

	case ICM_DRAW_END:
	    /*
	     * this message is sent when the sequence of draw calls has finished -
	     * note that the final frame should remain rendered!! - so we can't
	     * disable the hardware yet.
	     */
	    //return DrawEnd(pi);
	    return((DWORD) ICERR_OK);


	case ICM_DRAW_WINDOW:
	    /*
	     * the window has changed position or z-ordering. re-sync the
	     * hardware rendering.
	     */
	    return(DrawWindow(pi, (PRECT)lParam1));


	case ICM_DRAW_QUERY:
	    /*
	     * can we draw this format ? (lParam2 may (should?) be null)
	     */
	    return DrawQuery(pi,
			 (LPBITMAPINFOHEADER)lParam1,
			 (LPBITMAPINFOHEADER)lParam2);

	case ICM_DRAW_START:
	case ICM_DRAW_STOP:
	    /*
	     * only relevant if you have pre-buffering.
	     */
	    return( (DWORD) ICERR_OK);

#endif // ICM_DRAW_SUPPORTED

	/*********************************************************************

	    standard driver messages

	*********************************************************************/

	case DRV_DISABLE:
	case DRV_ENABLE:
	    return (LRESULT)1L;

	case DRV_INSTALL:
	case DRV_REMOVE:
	    return (LRESULT)DRV_OK;
    }

    if (uiMessage < DRV_USER)
        return DefDriverProc((UINT_PTR)pi, hDriver, uiMessage,lParam1,lParam2);
    else
	return ICERR_UNSUPPORTED;
}


#ifdef _WIN32
#if 0 // done on DRV_LOAD
BOOL DllInstanceInit(PVOID hModule, ULONG Reason, PCONTEXT pContext)
{
    if (Reason == DLL_PROCESS_ATTACH) {
        ghModule = (HANDLE) hModule;
	DisableThreadLibraryCalls(hModule);
    }
    return TRUE;
}
#endif
#else

/****************************************************************************
 * LibMain - Library initialization code.
 *
 * PARAMETERS
 * hModule: Our module handle.
 *
 * wHeapSize: The heap size from the .def file.
 *
 * lpCmdLine: The command line.
 *
 * Returns 1 if the initialization was successful and 0 otherwise.
 ***************************************************************************/
int NEAR PASCAL LibMain(HMODULE hModule, WORD wHeapSize, LPSTR lpCmdLine)
{
    ghModule = hModule;

    return 1;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\codec\tsbyuv\msyuv.c ===
/*----------------------------------------------------------------------+
| msyuv.c - Microsoft YUV Codec                                         |
|                                                                       |
| Copyright (c) 1993 Microsoft Corporation.                             |
| All Rights Reserved.                                                  |
|                                                                       |
+----------------------------------------------------------------------*/

#include <windows.h>
#include <windowsx.h>
//#include <mmsystem.h>

#ifndef _WIN32
#include "stdarg.h"
#endif

#ifdef _WIN32
#include <memory.h>     /* for memcpy */
#endif

#include "msyuv.h"

WCHAR    szDescription[] = L"Toshiba YUV Codec";
WCHAR    szName[]        = L"Toshiba YUV411";
WCHAR    szAbout[]       = L"About";

#define VERSION         0x00010000      // 1.0



/*****************************************************************************
 ****************************************************************************/
INSTINFO * NEAR PASCAL Open(ICOPEN FAR * icinfo)
{
    INSTINFO *  pinst;

    //
    // refuse to open if we are not being opened as a Video compressor
    //
    if (icinfo->fccType != ICTYPE_VIDEO)
        return NULL;

    //
    // dwFlags contain wMode
    //
    if(   icinfo->dwFlags != ICMODE_QUERY            // Open for infomational purpose        
       && icinfo->dwFlags != ICMODE_DECOMPRESS 

       #ifdef ICM_COMPRESS_SUPPORTED
       && icinfo->dwFlags != ICMODE_COMPRESS      
       #endif 

       #ifdef ICM_DRAW_SUPPORTED      
       && icinfo->dwFlags != ICMODE_DRAW          
       #endif 
      ) {
        
        dprintf1((TEXT("Open: unsupported wMode=%d\n"), icinfo->dwFlags));
        return NULL;
    }

    pinst = (INSTINFO *)LocalAlloc(LPTR, sizeof(INSTINFO));

    if (!pinst) {
        icinfo->dwError = (DWORD)ICERR_MEMORY;
        return NULL;
    }

    //
    // init structure
    //
    pinst->dwFlags = icinfo->dwFlags;
    pinst->pXlate = NULL;

    //
    // return success.
    //
    icinfo->dwError = ICERR_OK;

    return pinst;
}

/*****************************************************************************
 ****************************************************************************/
DWORD NEAR PASCAL Close(INSTINFO * pinst)
{

    if (pinst->pXlate) {
        DecompressEnd(pinst);
    }

#if ICM_DRAW_SUPPORTED
    if (pinst->vh) {
        DrawEnd(pinst);
    }
#endif

    LocalFree((HLOCAL)pinst);

    return 1;
}

/*****************************************************************************
 ****************************************************************************/

BOOL NEAR PASCAL QueryAbout(INSTINFO * pinst)
{
    return TRUE;
}

DWORD NEAR PASCAL About(INSTINFO * pinst, HWND hwnd)
{
    MessageBoxW(hwnd,szDescription,szAbout,MB_OK|MB_ICONINFORMATION);
    return ICERR_OK;
}

/*****************************************************************************
 ****************************************************************************/
BOOL NEAR PASCAL QueryConfigure(INSTINFO * pinst)
{
    return FALSE;
}

DWORD NEAR PASCAL Configure(INSTINFO * pinst, HWND hwnd)
{
    return (TRUE);
}

/*****************************************************************************
 ****************************************************************************/
/*
 * lossless translation - hence no need for state adjustments
 */
DWORD NEAR PASCAL GetState(INSTINFO * pinst, LPVOID pv, DWORD dwSize)
{
        return 0;

}

/*****************************************************************************
 ****************************************************************************/
DWORD NEAR PASCAL SetState(INSTINFO * pinst, LPVOID pv, DWORD dwSize)
{
        return(0);
}

/*****************************************************************************
 ****************************************************************************/
DWORD NEAR PASCAL GetInfo(INSTINFO * pinst, ICINFO FAR *icinfo, DWORD dwSize)
{
    if (icinfo == NULL)
        return sizeof(ICINFO);

    if (dwSize < sizeof(ICINFO))
        return 0;

    icinfo->dwSize            = sizeof(ICINFO);
    icinfo->fccType           = ICTYPE_VIDEO;
    icinfo->fccHandler        = FOURCC_YUV411;
    icinfo->dwFlags           = 0;

    icinfo->dwVersion         = VERSION;
    icinfo->dwVersionICM      = ICVERSION;
    wcscpy(icinfo->szDescription, szDescription);
    wcscpy(icinfo->szName, szName);

    return sizeof(ICINFO);
}

/*****************************************************************************
 ****************************************************************************/
DWORD FAR PASCAL CompressQuery(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut)
{
    return ((DWORD) ICERR_BADFORMAT);
}

/*****************************************************************************
 ****************************************************************************/
DWORD FAR PASCAL CompressGetFormat(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut)
{

    return((DWORD) ICERR_BADFORMAT);

}

/*****************************************************************************
 ****************************************************************************/


DWORD FAR PASCAL CompressBegin(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut)
{

    return((DWORD) ICERR_ERROR);

}

/*****************************************************************************
 ****************************************************************************/
DWORD FAR PASCAL CompressGetSize(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut)
{
    return (0);
}

/*****************************************************************************
 ****************************************************************************/
DWORD FAR PASCAL Compress(INSTINFO * pinst, ICCOMPRESS FAR *icinfo, DWORD dwSize)
{
    return((DWORD) ICERR_ERROR);

}

/*****************************************************************************
 ****************************************************************************/
DWORD FAR PASCAL CompressEnd(INSTINFO * pinst)
{
    return (DWORD)ICERR_ERROR;

}

/*****************************************************************************
 ****************************************************************************/
DWORD NEAR PASCAL DecompressQuery(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut)
{
    //
    // determine if the input DIB data is in a format we like.
    //
#ifdef  TOSHIBA
#if DBG
//  DbgBreakPoint();
#endif
    if (lpbiIn == NULL ||
        ( (lpbiIn->biCompression != FOURCC_YUV411)  &&
          (lpbiIn->biCompression != FOURCC_YUV422)  &&
          (lpbiIn->biCompression != FOURCC_YUV9)    &&   // add YUV9
          (lpbiIn->biCompression != FOURCC_YUV12 ))) {   // add YUV12
#else //TOSHIBA
    if (lpbiIn == NULL ||
        (lpbiIn->biBitCount != 16) ||
        ( (lpbiIn->biCompression != FOURCC_YUV411)  &&
          (lpbiIn->biCompression != FOURCC_YUV422))) {
#endif//TOSHIBA
        dprintf((TEXT("bad input format")));
        return (DWORD)ICERR_BADFORMAT;
    }

    //
    //  are we being asked to query just the input format?