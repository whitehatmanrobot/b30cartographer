RUE;

    m_BagStatus = bagStatus;    
    m_BagId = bagId;
    m_BirthDate = birthDate;
    m_Len = len;
    m_Type = type;
    m_VolId = volId;
    m_DeletedBagAmount = deletedBagAmount;
    m_RemoteDataSet = remoteDataSet;

    WsbTraceOut(OLESTR("CBagInfo::SetBagInfo"), OLESTR("hr = <%ls>"),WsbHrAsString(S_OK));
    return(S_OK);
}


HRESULT 
CBagInfo::Test
(
    OUT USHORT *pTestsPassed, 
    OUT USHORT *pTestsFailed 
    ) 
/*++

Routine Description:

  See IWsbTestable::Test().

Arguments:

  See IWsbTestable::Test().

Return Value:

  See IWsbTestable::Test().

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IBagInfo>       pBagInfo1;
    CComPtr<IBagInfo>       pBagInfo2;

    WsbTraceIn(OLESTR("CBagInfo::Test"), OLESTR(""));

    *pTestsPassed = *pTestsFailed = 0;
    
    hr  = E_NOTIMPL;
    
    WsbTraceOut(OLESTR("CBagInfo::Test"),   OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(S_OK);
}


HRESULT CBagInfo::Print
(
    IN IStream* pStream
    ) 
/*++

Implements:

  IWsbDbEntity::Print

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CBagInfo::Print"), OLESTR(""));

    try {
        WsbAssert(0 != pStream, E_POINTER);
        CWsbStringPtr strGuid;

        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(", Status = %d"), 
                (USHORT)m_BagStatus));
        WsbAffirmHr(WsbSafeGuidAsString(m_BagId, strGuid));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(", BagId = %ls"), 
                (WCHAR *)strGuid));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(", BirthDate = %ls"), 
                WsbFiletimeAsString(FALSE, m_BirthDate)));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(", Len = %ls"), 
                WsbLonglongAsString(m_Len)));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(", Type = %d"), 
                m_Type));
        WsbAffirmHr(WsbSafeGuidAsString(m_VolId, strGuid));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(", VolId = %ls"), 
                (WCHAR *)strGuid));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(", DeletedAmount = %ls"), 
                WsbLonglongAsString(m_DeletedBagAmount)));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(", RemoteDataSet = %d"), 
                m_RemoteDataSet));
        WsbAffirmHr(CWsbDbEntity::Print(pStream));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CBagInfo::Print"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT 
CBagInfo::UpdateKey(
    IWsbDbKey *pKey
    ) 
/*++

Implements:

  IWsbDbEntity::UpdateKey

--*/
{ 
    HRESULT  hr = S_OK; 

    try {
        WsbAffirmHr(pKey->SetToGuid(m_BagId));
    } WsbCatch(hr);

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\engine\task\hsmrecli.h ===
#ifndef _HSMRECLI_
#define _HSMRECLI_

/*++


Module Name:

    HSMRECLI.H

Abstract:

    This class represents an HSM work item - a unit of work
    that is performed by the HSM engine

Author:

    Ravisankar Pudipeddi [ravisp]

Revision History:

--*/

#include "resource.h"       // main symbols

#include "job.h"
#include "task.h"

/*++

Class Name:
    
    CHsmRecallItem

Class Description:


--*/


class CHsmRecallItem : 
    public CWsbObject,
    public IHsmRecallItem,
    public CComCoClass<CHsmRecallItem,&CLSID_CHsmRecallItem>
{
public:
    CHsmRecallItem() {}
BEGIN_COM_MAP(CHsmRecallItem)
    COM_INTERFACE_ENTRY(IHsmRecallItem)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID( IDR_CHsmRecallItem )

// CWsbCollectable
public:
    STDMETHOD(FinalConstruct)(void);
    void FinalRelease(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IUnknown* pUnknown, SHORT* pResult);

// IWsbTestable
public:
    STDMETHOD(Test)(USHORT *pTestsPassed, USHORT* pTestsFailed);
    
// IHsmRecallItem
public:
    STDMETHOD(CompareToIHsmRecallItem)(IHsmRecallItem* pWorkItem, SHORT* pResult);

    STDMETHOD(GetFsaPostIt)(IFsaPostIt  **ppFsaPostIt);
    STDMETHOD(GetFsaResource)(IFsaResource **ppFsaResource);
    STDMETHOD(GetId)(GUID *pId);
    STDMETHOD(GetMediaInfo)(GUID *pMediaId, FILETIME *pMediaLastUpdate,
                            HRESULT *pMediaLastError, BOOL *pMediaRecallOnly,
                            LONGLONG *pMediaFreeBytes, short *pMediaRemoteDataSet);
    STDMETHOD(GetResult)(HRESULT  *pHr);
    STDMETHOD(GetWorkType)(HSM_WORK_ITEM_TYPE *pWorkType);

    STDMETHOD(GetEventCookie)(OUT DWORD *pEventCookie);
    STDMETHOD(GetStateCookie)(OUT DWORD *pStateCookie);
    STDMETHOD(GetJobState)(OUT HSM_JOB_STATE *pJobState);
    STDMETHOD(GetJobPhase)(OUT HSM_JOB_PHASE *pJobPhase);
    STDMETHOD(GetSeekOffset)(OUT LONGLONG *pSeekOffset);
    STDMETHOD(GetBagId)(OUT GUID *bagId);
    STDMETHOD(GetDataSetStart)(OUT LONGLONG *dataSetStart);

    STDMETHOD(SetFsaPostIt)(IFsaPostIt  *pFsaPostIt);
    STDMETHOD(SetFsaResource)(IFsaResource *pFsaResource);
    STDMETHOD(SetMediaInfo)(GUID mediaId, FILETIME mediaLastUpdate,
                            HRESULT mediaLastError, BOOL mediaRecallOnly,
                            LONGLONG mediaFreeBytes, short mediaRemoteDataSet);
    STDMETHOD(SetResult)(HRESULT  hr);
    STDMETHOD(SetWorkType)(HSM_WORK_ITEM_TYPE workType);

    STDMETHOD(SetEventCookie)(IN DWORD eventCookie);
    STDMETHOD(SetStateCookie)(IN DWORD stateCookie);
    STDMETHOD(SetJobState)(IN HSM_JOB_STATE jobState);
    STDMETHOD(SetJobPhase)(IN HSM_JOB_PHASE jobPhase);
    STDMETHOD(SetSeekOffset)(IN LONGLONG seekOffset);
    STDMETHOD(SetBagId)(IN GUID *bagId);
    STDMETHOD(SetDataSetStart)(IN LONGLONG dataSetStart);

protected:
    HSM_WORK_ITEM_TYPE      m_WorkType;         // Type of work to do
    CComPtr<IFsaPostIt>     m_pFsaPostIt;       // FSA work to do
    HRESULT                 m_WorkResult;       // Result of premigrate
    CComPtr<IFsaResource>   m_pFsaResource;     // Resource that had work

// Information about media containing the data - premigrates only
    GUID                    m_MyId;                 // Identifier for database searches
    GUID                    m_MediaId;              // HSM Engine Media ID
    FILETIME                m_MediaLastUpdate;      // Last update of copy
    HRESULT                 m_MediaLastError;       // S_OK or the last exception 
                                                    // ..encountered when accessing
                                                    // ..the media
    BOOL                    m_MediaRecallOnly;      // True if no more data is to
                                                    // ..be premigrated to the media
                                                    // ..Set by internal operations, 
                                                    // ..may not be changed externally
    LONGLONG                m_MediaFreeBytes;       // Real free space on media
    SHORT                   m_MediaRemoteDataSet;   // Next remote data set
    DWORD                   m_EventCookie;
    DWORD                   m_StateCookie;
    HSM_JOB_STATE           m_JobState;
    HSM_JOB_PHASE           m_JobPhase;
    LONGLONG                m_SeekOffset;       //parameter used to order the work-item in the queue           

    GUID                    m_BagId;
    LONGLONG                m_DataSetStart;
};

#endif  // _HSMRECLI_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\engine\task\hsmreclq.cpp ===
/*++


Module Name:

     hsmreclq.cpp

Abstract:

     This class represents the HSM Demand Recall Queue manager
     It handles recalls initiated by users accessing HSM managed
     files. Based on the regular HSM queue manager (CHsmWorkQueue)

Author:

     Ravisankar Pudipeddi [ravisp] 1 Oct. 1999


Revision History:

--*/

#include "stdafx.h"

#define WSB_TRACE_IS        WSB_TRACE_BIT_HSMTSKMGR
static USHORT iCount = 0;

#include "fsa.h"
#include "rms.h"
#include "metadef.h"
#include "jobint.h"
#include "hsmconn.h"
#include "wsb.h"
#include "hsmeng.h"
#include "mover.h"
#include "hsmreclq.h"

#include "engine.h"
#include "task.h"
#include "tskmgr.h"
#include "segdb.h"

#define STRINGIZE(_str) (OLESTR( #_str ))
#define RETURN_STRINGIZED_CASE(_case) \
case _case:                           \
    return ( STRINGIZE( _case ) );

// Local prototypes
DWORD HsmRecallQueueThread(void *pVoid);
static const OLECHAR * JobStateAsString (HSM_JOB_STATE state);

static const OLECHAR *
JobStateAsString (
                 IN  HSM_JOB_STATE  state
                 )
/*++

Routine Description:

     Gives back a static string representing the connection state.

Arguments:

     state - the state to return a string for.

Return Value:

     NULL - invalid state passed in.

     Otherwise, a valid char *.

--*/
{
    //
    // Do the Switch
    //

    switch (state) {

    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_ACTIVE );
    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_CANCELLED );
    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_CANCELLING );
    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_DONE );
    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_FAILED );
    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_IDLE );
    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_PAUSED );
    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_PAUSING );
    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_RESUMING );
    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_SKIPPED );
    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_STARTING );
    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_SUSPENDED );
    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_SUSPENDING );

    default:

        return( OLESTR("Invalid Value") );

    }
}



HRESULT
CHsmRecallQueue::FinalConstruct(
                               void
                               )
/*++

Routine Description:

  This method does some initialization of the object that is necessary
  after construction.

Arguments:

  None.

Return Value:

  S_OK
  Anything returned by CWsbCollectable::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallQueue::FinalConstruct"),OLESTR(""));
    try {

        WsbAssertHr(CComObjectRoot::FinalConstruct());

        //
        // Initialize the member data
        //
        m_pServer           = 0;
        m_pHsmServerCreate  = 0;
        m_pTskMgr             = 0;

        m_pRmsServer        = 0;
        m_pRmsCartridge     = 0;
        m_pDataMover        = 0;

        m_pWorkToDo         = 0;

        UnsetMediaInfo();

        m_HsmId          = GUID_NULL;
        m_RmsMediaSetId  = GUID_NULL;
        m_RmsMediaSetName = OLESTR("");
        m_QueueType      = HSM_WORK_TYPE_FSA_DEMAND_RECALL;


        m_JobPriority = HSM_JOB_PRIORITY_NORMAL;

        m_WorkerThread = 0;
        m_TerminateQueue = FALSE;
        m_CurrentPath    = OLESTR("");

        // Job abort on errors parameters
        m_JobAbortMaxConsecutiveErrors = 5;
        m_JobAbortMaxTotalErrors = 25;
        m_JobConsecutiveErrors = 0;
        m_JobTotalErrors = 0;
        m_JobAbortSysDiskSpace = 2 * 1024 * 1024;

        m_CurrentSeekOffset = 0;

        WSB_OBJECT_ADD(CLSID_CHsmRecallQueue, this);

    }WsbCatch(hr);

    iCount++;
    WsbTraceOut(OLESTR("CHsmRecallQueue::FinalConstruct"),OLESTR("hr = <%ls>, Count is <%d>"),
                WsbHrAsString(hr), iCount);
    return(hr);
}


HRESULT
CHsmRecallQueue::FinalRelease(
                             void
                             )
/*++

Routine Description:

  This method does some initialization of the object that is necessary
  before destruction.

Arguments:

  None.

Return Value:

  S_OK
  Anything returned by CWsbCollection::FinalDestruct().

--*/
{
    HRESULT     hr = S_OK;
    HSM_SYSTEM_STATE SysState;

    WsbTraceIn(OLESTR("CHsmRecallQueue::FinalRelease"),OLESTR(""));

    SysState.State = HSM_STATE_SHUTDOWN;
    ChangeSysState(&SysState);

    WSB_OBJECT_SUB(CLSID_CHsmRecallQueue, this);
    CComObjectRoot::FinalRelease();

    // Free String members
    // Note: Member objects held in smart-pointers are freed when the
    // smart-pointer destructor is being called (as part of this object destruction)
    m_MediaName.Free();
    m_MediaBarCode.Free();
    m_RmsMediaSetName.Free();
    m_CurrentPath.Free();

    iCount--;
    WsbTraceOut(OLESTR("CHsmRecallQueue::FinalRelease"),OLESTR("hr = <%ls>, Count is <%d>"),
                WsbHrAsString(hr), iCount);
    return(hr);
}


HRESULT
CHsmRecallQueue::Init(
                     IUnknown                *pServer,
                     IHsmFsaTskMgr           *pTskMgr
                     )
/*++
Routine Description:

  This method does some initialization of the object that is necessary
  after construction.

Arguments:


Return Value:


--*/
{
    HRESULT     hr = S_OK;
    LONG                    rmsCartridgeType;
    CComPtr<IRmsCartridge>  pMedia;

    WsbTraceIn(OLESTR("CHsmRecallQueue::Init"),OLESTR(""));
    try {
        //
        // Establish contact with the server and get the
        // databases
        //
        WsbAffirmHr(pServer->QueryInterface(IID_IHsmServer, (void **)&m_pServer));
        //We want a weak link to the server so decrement the reference count
        m_pServer->Release();

        m_pTskMgr = pTskMgr;
        m_pTskMgr->AddRef();
        m_QueueType = HSM_WORK_TYPE_FSA_DEMAND_RECALL;

        WsbAffirmHr(m_pServer->QueryInterface(IID_IWsbCreateLocalObject, (void **)&m_pHsmServerCreate));
        // We want a weak link to the server so decrement the reference count
        m_pHsmServerCreate->Release();
        WsbAffirmHr(m_pServer->GetID(&m_HsmId));
        //
        // Make sure our connection to RMS is current
        //
        WsbAffirmHr(CheckRms());

        //
        // Get the media type. We assume mediaId is set before this
        // is called. Imperative!
        //
        WsbAffirmHr(m_pRmsServer->FindCartridgeById(m_MediaId, &pMedia));
        WsbAffirmHr(pMedia->GetType( &rmsCartridgeType ));
        WsbAffirmHr(ConvertRmsCartridgeType(rmsCartridgeType, &m_MediaType));

        //
        // Make a collection for the work items
        //
        WsbAffirmHr(m_pHsmServerCreate->CreateInstance(CLSID_CWsbOrderedCollection,
                                                       IID_IWsbIndexedCollection,
                                                       (void **)&m_pWorkToDo ));


        // Check the registry to see if there are changes to default settings
        CheckRegistry();
    }WsbCatch( hr );

    WsbTraceOut(OLESTR("CHsmRecallQueue::Init"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return( hr );
}


HRESULT
CHsmRecallQueue::ContactOk(
                          void
                          )
/*++
Routine Description:

  This allows the caller to see if the RPC connection
  to the task manager is OK

Arguments:

  None.

Return Value:

  S_OK
--*/ {

    return( S_OK );

}

HRESULT
CHsmRecallQueue::ProcessSessionEvent( IHsmSession *pSession,
                                      HSM_JOB_PHASE phase,
                                      HSM_JOB_EVENT event
                                    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    HRESULT     hr = S_OK;
    WsbTraceIn(OLESTR("CHsmRecallQueue::ProcessSessionEvent"),OLESTR(""));
    try {

        WsbAssert(0 != pSession, E_POINTER);

        // If the phase applies to us (MOVER or ALL), then do any work required by the
        // event.
        if ((HSM_JOB_PHASE_ALL == phase) || (HSM_JOB_PHASE_MOVE_ACTION == phase)) {

            switch (event) {
            
            case HSM_JOB_EVENT_SUSPEND:
            case HSM_JOB_EVENT_CANCEL:
            case HSM_JOB_EVENT_FAIL:
                WsbAffirmHr(Cancel(phase, pSession));
                break;

            case HSM_JOB_EVENT_RAISE_PRIORITY:
                WsbAffirmHr(RaisePriority(phase, pSession));
                break;

            case HSM_JOB_EVENT_LOWER_PRIORITY:
                WsbAffirmHr(LowerPriority(phase, pSession));
                break;

            default:
            case HSM_JOB_EVENT_START:
                WsbAssert(FALSE, E_UNEXPECTED);
                break;
            }
        }
    }WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRecallQueue::ProcessSessionEvent"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return( S_OK );
}


HRESULT
CHsmRecallQueue::ProcessSessionState(
                                    IHsmSession* /*pSession*/,
                                    IHsmPhase*   pPhase,
                                    OLECHAR*         /*currentPath*/
                                    )
/*++

Routine Description:

Arguments:

Return Value:


--*/ {
    HRESULT         hr = S_OK;
    HSM_JOB_PHASE   phase;
    HSM_JOB_STATE   state;

    WsbTraceIn(OLESTR("CHsmRecallQueue::ProcessSessionState"),OLESTR(""));
    try {

        WsbAffirmHr(pPhase->GetState(&state));
        WsbAffirmHr(pPhase->GetPhase(&phase));
        WsbTrace( OLESTR("CHsmRecallQueue::ProcessSessionState - State = <%d>, phase = <%d>\n"), state, phase );

        if (HSM_JOB_PHASE_SCAN == phase) {

            // If the session has finished, then we have some cleanup to do so that it can go
            // away.
            if ((state == HSM_JOB_STATE_DONE) || (state == HSM_JOB_STATE_FAILED) || (state == HSM_JOB_STATE_SUSPENDED)) {
                WsbTrace( OLESTR("Job is done, failed, or suspended\n") );
                //
                // Do nothing: when one recall item is done, we don't need to wait
                // for the FSA in order to perform cleanup code
                //
/***				WsbAffirmHr(MarkWorkItemAsDone(pSession, phase));   ***/
            }
        }

    }WsbCatch( hr );

    WsbTraceOut(OLESTR("CHsmRecallQueue::ProcessSessionState"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return( S_OK );

}


HRESULT
CHsmRecallQueue::Add(
                    IFsaPostIt *pFsaWorkItem,
                    GUID       *pBagId,
                    LONGLONG   dataSetStart
                    )
/*++

Implements:

  IHsmFsaTskMgr::Add

--*/ {
    HRESULT                     hr = S_OK;
    CComPtr<IHsmSession>        pSession;
    CComPtr<IWsbEnum>           pEnum;
    CComPtr<IHsmRecallItem>     pWorkItem, pWorkItem2;
    LONGLONG                    seekOffset, currentSeekOffset, prevSeekOffset;
    LARGE_INTEGER               remoteFileStart, remoteDataStart;
    LONGLONG                    readOffset;
    FSA_PLACEHOLDER             placeholder;
    HSM_WORK_ITEM_TYPE          workType;
    BOOL                        workItemAllocated=FALSE, insert;
    CComPtr<IFsaFilterRecall>   pRecall;
    DWORD                       index = 0;
    BOOL                        qLocked = FALSE;

    WsbTraceIn(OLESTR("CHsmRecallQueue::Add"),OLESTR(""));
    try {
        //
        // Make sure there is a work allocater for this session
        //
        WsbAffirmHr(pFsaWorkItem->GetSession(&pSession));
        //
        // Create a work item, load it up and add it to this
        // Queue's collection
        //
        CComPtr<IHsmRecallItem>   pWorkItem;
        WsbAffirmHr(m_pHsmServerCreate->CreateInstance(CLSID_CHsmRecallItem, IID_IHsmRecallItem,
                                                       (void **)&pWorkItem));
        workItemAllocated = TRUE;
        WsbAffirmHr(pWorkItem->SetWorkType(HSM_WORK_ITEM_FSA_WORK));
        WsbAffirmHr(pWorkItem->SetFsaPostIt(pFsaWorkItem));
        WsbAffirmHr(CheckSession(pSession, pWorkItem));

        WsbAffirmHr(pWorkItem->SetBagId(pBagId));
        WsbAffirmHr(pWorkItem->SetDataSetStart(dataSetStart));

        if (m_MediaType == HSM_JOB_MEDIA_TYPE_TAPE) {
            //
            // For sequential media we order the requests to achieve
            // optimal perf.
            //
            WsbAffirmHr(pFsaWorkItem->GetPlaceholder(&placeholder));
            remoteFileStart.QuadPart = placeholder.fileStart;
            remoteDataStart.QuadPart = placeholder.dataStart;
            WsbAffirmHr(pFsaWorkItem->GetFilterRecall(&pRecall));
            WsbAffirmHr(pRecall->GetOffset( &readOffset ));

            //
            // Calculate the offset in the media that needs to be seeked to
            // for the recall. This will be only used for ordering the queue
            // performance reasons. 
            //
            seekOffset = dataSetStart + remoteFileStart.QuadPart + remoteDataStart.QuadPart +  readOffset;


            WsbAffirmHr(pWorkItem->SetSeekOffset(seekOffset));
            index = 0;
            //
            // Find a position in the queue to insert it
            // First, we lock the queue while we search for the position
            // & insert the item into the queue. We make the assumption
            // the lock protecting the queue is recursively acquirable.
            // If this is not true, the code that adds to the queue will
            // deadlock because it tries to lock the queue too!
            //
            m_pWorkToDo->Lock();
            qLocked = TRUE;

            WsbAffirmHr(m_pWorkToDo->Enum(&pEnum));
            //
            // If the seek offset of the item we wish to insert is
            // > the current seek offset of the item that is in progress,
            // we just insert it in the first monotonic ascending sequence.
            // If not, we insert in the *second* monotonic ascending sequence,
            // to prevent the head from seeking back prematurely
            //
            hr = pEnum->First(IID_IHsmRecallItem, (void **)&pWorkItem2);
            if (seekOffset > m_CurrentSeekOffset) {
                //
                // Insert in the first ascending sequence
                //
                insert = TRUE;
            } else {
                //
                // Skip the first ascending sequence
                //
                insert = FALSE;
            }

            prevSeekOffset = 0;
            while (hr != WSB_E_NOTFOUND) {
                WsbAffirmHr(pWorkItem2->GetWorkType(&workType));

                if (workType != HSM_WORK_ITEM_FSA_WORK) {
                    //
                    // Not interested in this. Release it before getting the next
                    //
                    pWorkItem2 = 0;
                    hr = pEnum->Next(IID_IHsmRecallItem, (void **)&pWorkItem2);
                    index++;
                    continue;
                }

                WsbAffirmHr(pWorkItem2->GetSeekOffset(&currentSeekOffset));

                if (insert && (currentSeekOffset > seekOffset)) {
                    //
                    // place to insert the item..
                    // 
                    break;
                }

                if (!insert && (currentSeekOffset < prevSeekOffset)) {
                    //
                    // Start of second monotone sequence. We wish to insert 
                    // the item in this sequence
                    //
                    insert = TRUE;
                    //
                    // Check if pWorkItem is eligible to be inserted at this
                    // index position
                    //
                    if (currentSeekOffset > seekOffset) {
                      //
                      // place to insert the item..
                      // 
                      break;
                    }
                }  else {
                    prevSeekOffset = currentSeekOffset;
                }
                //
                // Move on to the next. Release the current item first
                //
                pWorkItem2 = 0;
                hr = pEnum->Next(IID_IHsmRecallItem, (void **)&pWorkItem2);
                index++;

            } 
            if (hr == WSB_E_NOTFOUND) {
                WsbAffirmHr(m_pWorkToDo->Append(pWorkItem));
            } else {
                WsbAffirmHr(m_pWorkToDo->AddAt(pWorkItem, index));
            }
            //
            // Safe to unlock the queue
            //
            m_pWorkToDo->Unlock();
            qLocked = FALSE;

        } else  {
            //
            // For non-sequential media, we just add it to the queue ...
            // No ordering is done, we let the file system do the optimizations
            //
            WsbAffirmHr(m_pWorkToDo->Append(pWorkItem));
        } 
        hr = S_OK;
    }WsbCatchAndDo(hr,
                  //
                  // Add code to release queue lock if acquired
                  //
                  if (qLocked) {
                     m_pWorkToDo->Unlock();
                  }
                  );

    WsbTraceOut(OLESTR("CHsmRecallQueue::Add"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);
}


HRESULT
CHsmRecallQueue::Start( void )
/*++

Implements:

  IHsmRecallQueue::Start

--*/
{
    HRESULT                     hr = S_OK;
    DWORD                       tid;

    WsbTraceIn(OLESTR("CHsmRecallQueue::Start"),OLESTR(""));
    try {
        //
        // If the worker thread is already started, just return
        //
        WsbAffirm(m_WorkerThread == 0, S_OK);
        // Launch a thread to do work that is queued
        WsbAffirm((m_WorkerThread = CreateThread(0, 0, HsmRecallQueueThread, (void*) this, 0, &tid)) != 0, HRESULT_FROM_WIN32(GetLastError()));

        if (m_WorkerThread == NULL) {
            WsbAssertHr(E_FAIL);     // TBD What error to return here??
        }

    }WsbCatch (hr);

    WsbTraceOut(OLESTR("CHsmRecallQueue::Start"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);
}


HRESULT
CHsmRecallQueue::Stop( void )
/*++

Implements:

  IHsmRecallQueue::Stop

--*/ {
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallQueue::Stop"),OLESTR(""));

    //  Stop the thread (signal, wait, terminate if it still running)
    m_TerminateQueue = TRUE;

    if (m_WorkerThread) {
        switch (WaitForSingleObject(m_WorkerThread, 20000)) {
            case WAIT_FAILED: {
                WsbTrace(OLESTR("CHsmRecallQueue::Stop: WaitForSingleObject returned error %lu\n"), GetLastError());
            }
            // fall through...

            case WAIT_TIMEOUT: {
                WsbTrace(OLESTR("CHsmRecallQueue::Stop: force terminating of working thread.\n"));

                DWORD dwExitCode;
                if (GetExitCodeThread( m_WorkerThread, &dwExitCode)) {
                    if (dwExitCode == STILL_ACTIVE) {   // thread still active
                        if (!TerminateThread (m_WorkerThread, 0)) {
                            WsbTrace(OLESTR("CHsmRecallQueue::Stop: TerminateThread returned error %lu\n"), GetLastError());
                        }
                    }
                } else {
                    WsbTrace(OLESTR("CHsmRecallQueue::Stop: GetExitCodeThread returned error %lu\n"), GetLastError());
                }

                break;
            }

            default:
                // Thread terminated gracefully
                WsbTrace(OLESTR("CHsmRecallQueue::Stop: working thread terminated gracefully\n"));
                break;
        }
    }    

    WsbTraceOut(OLESTR("CHsmRecallQueue::Stop"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);
}



HRESULT
CHsmRecallQueue::RecallIt(
                         IHsmRecallItem * pWorkItem
                         )
{
    HRESULT                         hr = S_OK;
    CComPtr<IFsaScanItem>           pScanItem;
    CComPtr<IFsaPostIt>             pFsaWorkItem;
    LONGLONG                        readOffset;
    FSA_REQUEST_ACTION              requestAction;
    ULARGE_INTEGER                  remoteDataSetStart;
    GUID                            bagId;

    CComPtr<IWsbIndexedCollection>  pMountingCollection;
    CComPtr<IMountingMedia>         pMountingMedia;
    CComPtr<IMountingMedia>         pMediaToFind;
    BOOL                            bMediaMounting = FALSE;
    BOOL                            bMediaMountingAdded = FALSE;

    WsbTraceIn(OLESTR("CHsmRecallQueue::RecallIt"),OLESTR(""));
    try {

        WsbAffirmHr(pWorkItem->GetFsaPostIt(&pFsaWorkItem));

        WsbAffirmHr(pFsaWorkItem->GetRequestAction(&requestAction));
        GetScanItem(pFsaWorkItem, &pScanItem);

        WsbAffirmHr(pWorkItem->GetBagId(&bagId));
        WsbAffirmHr(pWorkItem->GetDataSetStart((LONGLONG *) &remoteDataSetStart.QuadPart));

        //
        // Check if we are mounting a new media: recall-queue is created on a per-media basis, therefore,
        //  media cannot change. The only test is whether the media for this queue is already mounted
        //
        if (m_MountedMedia == GUID_NULL) {

            // Check if the media is already in the process of mounting
            WsbAffirmHr(m_pServer->LockMountingMedias());

            try {
                // Check if the media to mount is already mounting
                WsbAffirmHr(m_pServer->GetMountingMedias(&pMountingCollection));
                WsbAffirmHr(CoCreateInstance(CLSID_CMountingMedia, 0, CLSCTX_SERVER, IID_IMountingMedia, (void**)&pMediaToFind));
                WsbAffirmHr(pMediaToFind->SetMediaId(m_MediaId));
                hr = pMountingCollection->Find(pMediaToFind, IID_IMountingMedia, (void **)&pMountingMedia);

                if (hr == S_OK) {
                    // Media is already mounting...
                    bMediaMounting = TRUE;

                } else if (hr == WSB_E_NOTFOUND) {
                    // New media to mount - add to the mounting list
                    hr = S_OK;
                    WsbAffirmHr(pMediaToFind->Init(m_MediaId, TRUE));
                    WsbAffirmHr(pMountingCollection->Add(pMediaToFind));
                    bMediaMountingAdded = TRUE;

                } else {
                    WsbAffirmHr(hr);
                }
            } WsbCatchAndDo(hr,
                // Unlock mounting media
                m_pServer->UnlockMountingMedias();

                WsbTraceAlways(OLESTR("CHsmRecallQueue::RecallIt: error while trying to find/add mounting media. hr=<%ls>\n"),
                                WsbHrAsString(hr));                                

                // Bale out
                WsbThrow(hr);
            );

            // Release the lock
            WsbAffirmHr(m_pServer->UnlockMountingMedias());
        }

        //
        // If the media is already mounting - wait for the mount event
        //
        if (bMediaMounting) {
            WsbAffirmHr(pMountingMedia->WaitForMount(INFINITE));
            pMountingMedia = 0;
        }

        //
        // Get the media mounted (hr is checked only after removing from the mounting-media list)
        //
        hr = MountMedia(pWorkItem, m_MediaId);

        //
        // If added to the mounting list - remove
        //
        if (bMediaMountingAdded) {
            HRESULT hrRemove = S_OK;

            // No matter how the Mount finished - free waiting clients and remove from the list
            hrRemove = m_pServer->LockMountingMedias();
            WsbAffirmHr(hrRemove);

            try {
                WsbAffirmHr(pMediaToFind->MountDone());
                WsbAffirmHr(pMountingCollection->RemoveAndRelease(pMediaToFind));
                pMediaToFind = 0;

            } WsbCatch(hrRemove);

            m_pServer->UnlockMountingMedias();

            // We don't expect any errors while removing the mounting media -
            // The thread that added to the collection is always the one that removes
            if (! SUCCEEDED(hrRemove)) {
                WsbTraceAlways(OLESTR("CHsmRecallQueue::RecallIt: error while trying to remove a mounting media. hr=<%ls>\n"),
                                WsbHrAsString(hrRemove));                                

                WsbThrow(hrRemove);
            }
        }

        //
        // Check the Mount result
        //
        WsbAffirmHr(hr);

        //
        // Copy the data
        //
        // Build the source path
        CWsbStringPtr tmpString;
        WsbAffirmHr(GetSource(pFsaWorkItem, &tmpString));
        CWsbBstrPtr localName = tmpString;
        // Ask the Data mover to store the data
        LONGLONG       requestSize;
        LONGLONG       requestStart;
        ULARGE_INTEGER localDataStart;
        ULARGE_INTEGER localDataSize;
        ULARGE_INTEGER remoteFileStart;
        ULARGE_INTEGER remoteFileSize;
        ULARGE_INTEGER remoteDataStart;
        ULARGE_INTEGER remoteDataSize;
        ULARGE_INTEGER remoteVerificationData;
        ULONG          remoteVerificationType;

        FSA_PLACEHOLDER             placeholder;
        WsbAffirmHr(pFsaWorkItem->GetPlaceholder(&placeholder));
        WsbAffirmHr(pFsaWorkItem->GetRequestSize(&requestSize));
        WsbAffirmHr(pFsaWorkItem->GetRequestOffset(&requestStart));

        //
        // Build strings
        //
        CWsbStringPtr strGuid;

        CWsbBstrPtr sessionName = HSM_BAG_NAME;
        WsbAffirmHr(WsbSafeGuidAsString(bagId, strGuid));
        sessionName.Append(strGuid);

        CWsbBstrPtr sessionDescription = HSM_ENGINE_ID;
        WsbAffirmHr(WsbSafeGuidAsString(m_HsmId, strGuid));
        sessionDescription.Append(strGuid);

        localDataStart.QuadPart = requestStart;
        localDataSize.QuadPart = requestSize;
        remoteFileStart.QuadPart = placeholder.fileStart;
        remoteFileSize.QuadPart = placeholder.fileSize;
        remoteDataStart.QuadPart = placeholder.dataStart;
        remoteDataSize.QuadPart = placeholder.dataSize;
        remoteVerificationData.QuadPart = placeholder.verificationData;
        remoteVerificationType = placeholder.verificationType;


        ReportMediaProgress(HSM_JOB_MEDIA_STATE_TRANSFERRING, hr);

        CComPtr<IStream> pLocalStream;
        CComPtr<IStream> pRemoteStream;
        ULARGE_INTEGER offset, read, written;
        DWORD   verifyType;

        //
        // We are doing a demand recall, so get the
        // recall object's data mover
        //
        CComPtr<IFsaFilterRecall> pRecall;
        WsbAffirmHr(pFsaWorkItem->GetFilterRecall(&pRecall));
        WsbAffirmHr(pRecall->CreateLocalStream( &pLocalStream));
        WsbAffirmHr(pRecall->GetSize( (LONGLONG *) &remoteDataSize.QuadPart ));
        WsbAffirmHr(pRecall->GetOffset( &readOffset ));
        if (readOffset == 0) {
            verifyType = MVR_VERIFICATION_TYPE_HEADER_CRC;
        } else {
            verifyType = MVR_VERIFICATION_TYPE_NONE;
        }

        //
        // Set the current seek offset used for ordering items in the queue
        //
        m_CurrentSeekOffset = remoteDataSetStart.QuadPart + remoteFileStart.QuadPart+remoteDataStart.QuadPart+requestStart;

        //
        // Create remote data mover stream
        // TEMPORARY: Consider removing the NO_CACHING flag for a NO_RECALL recall
        //

        WsbAssert(0 != remoteDataSetStart.QuadPart, HSM_E_BAD_SEGMENT_INFORMATION);
        WsbAffirmHr( m_pDataMover->CreateRemoteStream(
                                                     CWsbBstrPtr(L""),
                                                     MVR_MODE_READ | MVR_FLAG_HSM_SEMANTICS | MVR_FLAG_NO_CACHING,
                                                     sessionName,
                                                     sessionDescription,
                                                     remoteDataSetStart,
                                                     remoteFileStart,
                                                     remoteFileSize,
                                                     remoteDataStart,
                                                     remoteDataSize,
                                                     verifyType,
                                                     remoteVerificationData,
                                                     &pRemoteStream ) );

        //
        // The offset given here is the offset into the stream itself (readOffset).  
        // The actual position on remote media will be the bag start plus the file start
        // plus the file-data start (all given in CreateRemoteStream) plus this offset.
        //
        WsbTrace(OLESTR("Setting offset to %I64d reading %I64u\n"), readOffset, remoteDataSize.QuadPart);

        offset.QuadPart = readOffset;
        WsbAffirmHr( m_pDataMover->SetInitialOffset( offset ) );

        //
        // Once the remote stream has been created we must make sure we detach it
        //

        try {

            WsbAffirmHr( pRemoteStream->CopyTo( pLocalStream, remoteDataSize, &read, &written ) );
            WsbAffirmHr( pLocalStream->Commit( STGC_DEFAULT ) );

            //
            // The CopyTo succeeded... make sure we got all the bytes
            // we asked for.
            //
            // If we attempt to read from a incomplete Master that
            // does not contain the migrated data we'll fail here with
            // MVR_S_NO_DATA_DETECTED.
            //
            WsbAffirm( written.QuadPart == remoteDataSize.QuadPart, HSM_E_VALIDATE_DATA_NOT_ON_MEDIA );

            WsbAffirmHr( m_pDataMover->CloseStream() );
        }WsbCatchAndDo(hr,
                       WsbAffirmHr( m_pDataMover->CloseStream() );
                      );

        ReportMediaProgress(HSM_JOB_MEDIA_STATE_TRANSFERRED, hr);
        WsbTrace(OLESTR("RecallData returned hr = <%ls>\n"),WsbHrAsString(hr));

    }WsbCatch( hr );

    // Tell the session whether or not the work was done.
    // We don't really care about the return code, there is nothing
    // we can do if it fails.
    WsbTrace(OLESTR("Tried HSM work, calling Session to Process Item\n"));
    if (pScanItem) {
        CComPtr<IHsmSession> pSession;
        HSM_JOB_PHASE  jobPhase;

        WsbAffirmHr(pFsaWorkItem->GetSession(&pSession));

        WsbAffirmHr(pWorkItem->GetJobPhase(&jobPhase));

        pSession->ProcessItem(jobPhase, HSM_JOB_ACTION_RECALL , pScanItem, hr);
    }

    WsbTraceOut(OLESTR("CHsmRecallQueue::RecallIt"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return( hr );
}


HRESULT
CHsmRecallQueue::RaisePriority(
                              IN HSM_JOB_PHASE jobPhase,
                              IN IHsmSession *pSession
                              )

/*++


--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallQueue::RaisePriority"),OLESTR(""));
    try {

        WsbAssert(0 != m_WorkerThread, E_UNEXPECTED);
        WsbAssert(pSession != 0, E_UNEXPECTED);

        switch (m_JobPriority) {
        
        case HSM_JOB_PRIORITY_IDLE:
            WsbAffirmStatus(SetThreadPriority(m_WorkerThread, THREAD_PRIORITY_LOWEST));
            m_JobPriority = HSM_JOB_PRIORITY_LOWEST;
            break;

        case HSM_JOB_PRIORITY_LOWEST:
            WsbAffirmStatus(SetThreadPriority(m_WorkerThread, THREAD_PRIORITY_BELOW_NORMAL));
            m_JobPriority = HSM_JOB_PRIORITY_LOW;
            break;

        case HSM_JOB_PRIORITY_LOW:
            WsbAffirmStatus(SetThreadPriority(m_WorkerThread, THREAD_PRIORITY_NORMAL));
            m_JobPriority = HSM_JOB_PRIORITY_NORMAL;
            break;

        case HSM_JOB_PRIORITY_NORMAL:
            WsbAffirmStatus(SetThreadPriority(m_WorkerThread, THREAD_PRIORITY_ABOVE_NORMAL));
            m_JobPriority = HSM_JOB_PRIORITY_HIGH;
            break;

        case HSM_JOB_PRIORITY_HIGH:
            WsbAffirmStatus(SetThreadPriority(m_WorkerThread, THREAD_PRIORITY_HIGHEST));
            m_JobPriority = HSM_JOB_PRIORITY_HIGHEST;
            break;

        case HSM_JOB_PRIORITY_HIGHEST:
            WsbAffirmStatus(SetThreadPriority(m_WorkerThread, THREAD_PRIORITY_TIME_CRITICAL));
            m_JobPriority = HSM_JOB_PRIORITY_CRITICAL;
            break;

        default:
        case HSM_JOB_PRIORITY_CRITICAL:
            WsbAffirm(FALSE, E_UNEXPECTED);
            break;
        }

        WsbAffirmHr(pSession->ProcessPriority(jobPhase, m_JobPriority));

    }WsbCatch(hr);
    WsbTraceOut(OLESTR("CHsmRecallQueue::RaisePriority"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);
}


HRESULT
CHsmRecallQueue::LowerPriority(
                              IN HSM_JOB_PHASE jobPhase,
                              IN IHsmSession *pSession
                              )

/*++


--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallQueue::LowerPriority"),OLESTR(""));
    try {

        WsbAssert(0 != m_WorkerThread, E_UNEXPECTED);
        WsbAssert(pSession != 0, E_UNEXPECTED);

        switch (m_JobPriority) {
        case HSM_JOB_PRIORITY_IDLE:
            WsbAffirm(FALSE, E_UNEXPECTED);
            break;

        case HSM_JOB_PRIORITY_LOWEST:
            WsbAffirmStatus(SetThreadPriority(m_WorkerThread, THREAD_PRIORITY_IDLE));
            m_JobPriority = HSM_JOB_PRIORITY_IDLE;
            break;

        case HSM_JOB_PRIORITY_LOW:
            WsbAffirmStatus(SetThreadPriority(m_WorkerThread, THREAD_PRIORITY_LOWEST));
            m_JobPriority = HSM_JOB_PRIORITY_LOWEST;
            break;

        case HSM_JOB_PRIORITY_NORMAL:
            WsbAffirmStatus(SetThreadPriority(m_WorkerThread, THREAD_PRIORITY_BELOW_NORMAL));
            m_JobPriority = HSM_JOB_PRIORITY_LOW;
            break;

        case HSM_JOB_PRIORITY_HIGH:
            WsbAffirmStatus(SetThreadPriority(m_WorkerThread, THREAD_PRIORITY_NORMAL));
            m_JobPriority = HSM_JOB_PRIORITY_NORMAL;
            break;

        case HSM_JOB_PRIORITY_HIGHEST:
            WsbAffirmStatus(SetThreadPriority(m_WorkerThread, THREAD_PRIORITY_ABOVE_NORMAL));
            m_JobPriority = HSM_JOB_PRIORITY_HIGH;
            break;

        default:
        case HSM_JOB_PRIORITY_CRITICAL:
            WsbAffirmStatus(SetThreadPriority(m_WorkerThread, THREAD_PRIORITY_HIGHEST));
            m_JobPriority = HSM_JOB_PRIORITY_HIGHEST;
            break;
        }

        WsbAffirmHr(pSession->ProcessPriority(jobPhase, m_JobPriority));

    }WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRecallQueue::LowerPriority"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);
}




HRESULT
CHsmRecallQueue::CheckRms(
                         void
                         )

/*++


--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallQueue::CheckRms"),OLESTR(""));
    try {
        //
        // Make sure we can still talk to the RMS
        //
        if (m_pRmsServer != 0) {
            CWsbBstrPtr name;
            hr = m_pRmsServer->GetServerName( &name );
            if (hr != S_OK) {
                m_pRmsServer = 0;
                hr = S_OK;
            }
        }
        //
        // Get RMS that runs on this machine
        //
        if (m_pRmsServer == 0) {
            WsbAffirmHr(m_pServer->GetHsmMediaMgr(&m_pRmsServer));

            // wait for RMS to come ready
            // (this may not be needed anymore - if Rms initialization is
            //  synced with Engine initialization)
            CComObject<CRmsSink> *pSink = new CComObject<CRmsSink>;
            CComPtr<IUnknown> pSinkUnk = pSink; // holds refcount for use here
            WsbAffirmHr( pSink->Construct( m_pRmsServer ) );
            WsbAffirmHr( pSink->WaitForReady( ) );
            WsbAffirmHr( pSink->DoUnadvise( ) );
        }
    }WsbCatch( hr );

    WsbTraceOut(OLESTR("CHsmRecallQueue::CheckRms"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);

}


HRESULT
CHsmRecallQueue::CheckSession(
                             IHsmSession *pSession,
                             IHsmRecallItem *pWorkItem
                             )

/*++


--*/ {
    HRESULT                 hr = S_OK;
    BOOL                    bLog = TRUE;

    WsbTraceIn(OLESTR("CHsmRecallQueue::CheckSession"),OLESTR(""));
    try {

        //
        // Check to see if we have dealt with this or any other session before.
        WsbTrace(OLESTR("New session.\n"));

        //
        // We have no on going session so we need to establish communication
        // with this session.
        //
        CComPtr<IHsmSessionSinkEveryState>  pSinkState;
        CComPtr<IHsmSessionSinkEveryEvent>  pSinkEvent;
        CComPtr<IConnectionPointContainer>  pCPC;
        CComPtr<IConnectionPoint>           pCP;
        CComPtr<IFsaResource>               pFsaResource;
        HSM_JOB_PHASE                       jobPhase;
        DWORD                               stateCookie, eventCookie;
        ULONG                                           refCount;

        // Tell the session we are starting up.
        pWorkItem->SetJobState(HSM_JOB_STATE_STARTING);
        pWorkItem->GetJobPhase(&jobPhase);
        WsbTrace(OLESTR("Before Process State.\n"));
        refCount = (((IUnknown *) (IHsmFsaTskMgr *) this)->AddRef()) - 1;
        ((IUnknown *) (IHsmFsaTskMgr *)this)->Release();
        WsbTrace(OLESTR("REFCOUNT for CHsmRecallQueue before 1st process state: %ls \n"), WsbLongAsString((LONG) refCount));
        WsbAffirmHr(pSession->ProcessState(jobPhase, HSM_JOB_STATE_STARTING, m_CurrentPath, bLog));
        refCount = (((IUnknown *) (IHsmFsaTskMgr *) this)->AddRef()) - 1;
        ((IUnknown *) (IHsmFsaTskMgr *)this)->Release();
        WsbTrace(OLESTR("REFCOUNT for CHsmRecallQueue after 1st process state: %ls \n"), WsbLongAsString((LONG) refCount));
        WsbTrace(OLESTR("After Process State.\n"));

        // Get the interface to the callback that the sessions should use.
        WsbTrace(OLESTR("Before QI's for sinks.\n"));
        WsbAffirmHr(((IUnknown*) (IHsmFsaTskMgr*) this)->QueryInterface(IID_IHsmSessionSinkEveryState, (void**) &pSinkState));
        WsbAffirmHr(((IUnknown*) (IHsmFsaTskMgr*) this)->QueryInterface(IID_IHsmSessionSinkEveryEvent, (void**) &pSinkEvent));
        WsbTrace(OLESTR("After QI's for sinks.\n"));
        // Ask the session to advise of every state changes.
        WsbTrace(OLESTR("Before QI for connection point containers.\n"));

        WsbAffirmHr(pSession->QueryInterface(IID_IConnectionPointContainer, (void**) &pCPC));
        WsbAffirmHr(pCPC->FindConnectionPoint(IID_IHsmSessionSinkEveryState, &pCP));
        WsbAffirmHr(pCP->Advise(pSinkState, &stateCookie));

        pWorkItem->SetStateCookie(stateCookie);
        pCP = 0;

        WsbAffirmHr(pCPC->FindConnectionPoint(IID_IHsmSessionSinkEveryEvent, &pCP));
        WsbAffirmHr(pCP->Advise(pSinkEvent, &eventCookie));
        pWorkItem->SetEventCookie(eventCookie);

        pCP = 0;
        WsbTrace(OLESTR("After Advises.\n"));
        //
        // Get the resource for this work from the session
        //
        WsbAffirmHr(pSession->GetResource(&pFsaResource));
        pWorkItem->SetJobState(HSM_JOB_STATE_ACTIVE);

        WsbTrace(OLESTR("Before Process State.\n"));

        refCount = (((IUnknown *) (IHsmFsaTskMgr *) this)->AddRef()) - 1;
        ((IUnknown *) (IHsmFsaTskMgr *)this)->Release();
        WsbTrace(OLESTR("REFCOUNT for CHsmRecallQueue before 2nd process state: %ls \n"), WsbLongAsString((LONG) refCount));

        WsbAffirmHr(pSession->ProcessState(jobPhase, HSM_JOB_STATE_ACTIVE, m_CurrentPath, bLog));

        refCount = (((IUnknown *) (IHsmFsaTskMgr *) this)->AddRef()) - 1;
        ((IUnknown *) (IHsmFsaTskMgr *)this)->Release();
        WsbTrace(OLESTR("REFCOUNT for CHsmRecallQueue after 2nd process state: %ls \n"), WsbLongAsString((LONG) refCount));

        WsbTrace(OLESTR("After Process State.\n"));

    }WsbCatch( hr );

    WsbTraceOut(OLESTR("CHsmRecallQueue::CheckSession"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);

}


HRESULT
CHsmRecallQueue::DoWork( void )
/*++


--*/ 
{
    HRESULT                 hr = S_OK;
    CWsbStringPtr           path;
    CComPtr<IHsmRecallItem> pWorkItem;
    HSM_WORK_ITEM_TYPE      workType;
    BOOLEAN                 done = FALSE;
    HRESULT                 skipWork = S_FALSE;

    WsbTraceIn(OLESTR("CHsmRecallQueue::DoWork"),OLESTR(""));

    //  Make sure this object isn't released (and our thread killed
    //  before finishing up in this routine
    ((IUnknown*)(IHsmRecallQueue*)this)->AddRef();

    try {
        while (!done) {
            if (m_TerminateQueue) {
                // signaled to terminate the working thread (should be trigerred only in shutdown cases)
                done = TRUE;
                break;
            }

            //
            // Get the next work to do from the queue
            //
            hr = m_pWorkToDo->First(IID_IHsmRecallItem, (void **)&pWorkItem);

            if (WSB_E_NOTFOUND == hr) {
                //
                //  We might be done with this queue.
                //  Attempt to destroy it: if we cannot it means there are more items
                //  that were being added so we continue looping
                //
                hr = m_pTskMgr->WorkQueueDone(NULL, HSM_WORK_TYPE_FSA_DEMAND_RECALL, &m_MediaId);
                if (hr == S_OK) {
                    //
                    // Queue is really done - break out of the while loop
                    //
                    done = TRUE;
                    break;
                } else if (hr == S_FALSE) {
                    //
                    // More items in the queue
                    //
                    continue;
                } else {
                    //
                    // Some sort of error happened, bale out
                    //
                    WsbTraceAlways(OLESTR("CHsmRecallQueue::DoWork: WorkQueueDone failed with <%ls> - terminating queue thread\n"),
                                WsbHrAsString(hr));
                    WsbAffirmHr(hr);
                }
            } else {
                WsbAffirmHr(hr);
                //
                // Remove it from the queue
                //           
                Remove(pWorkItem);

            }

            WsbAffirmHr(pWorkItem->GetWorkType(&workType));

             switch (workType) {
                
                case HSM_WORK_ITEM_FSA_DONE: {
                        //
                        // TBD:Code path should not be reached
                        //
                        WsbTraceAlways(OLESTR("Unexpected: CHsmRecallQueue::DoWork - FSA WORK DONE item\n"));

                        break;
                    }

                case HSM_WORK_ITEM_FSA_WORK: {
                        if (S_FALSE == skipWork) {
                            //
                            // Get the FSA Work Item and do the work
                            //
                            hr = DoFsaWork(pWorkItem);
                        } else {
                            //
                            // Skip the work
                            //
                            try {
                                CComPtr<IFsaPostIt>      pFsaWorkItem;
                                CComPtr<IFsaScanItem>    pScanItem;
                                CComPtr<IFsaResource>    pFsaResource;
                                CComPtr<IHsmSession>     pSession;
                                HSM_JOB_PHASE            jobPhase;

                                WsbAffirmHr(pWorkItem->GetFsaPostIt(&pFsaWorkItem));
                                WsbAffirmHr(pWorkItem->GetJobPhase(&jobPhase));
                                WsbAffirmHr(pFsaWorkItem->GetSession(&pSession));
                                WsbAffirmHr(pSession->GetResource(&pFsaResource));
                                WsbAffirmHr(GetScanItem(pFsaWorkItem, &pScanItem));

                                hr = pFsaWorkItem->SetResult(skipWork);

                                if (S_OK == hr) {
                                    WsbTrace(OLESTR("HSM recall (filter, read or recall) complete, calling FSA\n"));
                                    hr = pFsaResource->ProcessResult(pFsaWorkItem);
                                    WsbTrace(OLESTR("FSA ProcessResult returned <%ls>\n"), WsbHrAsString(hr));
                                }
                                (void)pSession->ProcessHr(jobPhase, 0, 0, hr);
                                WsbAffirmHr(pSession->ProcessItem(jobPhase,
                                                                  HSM_JOB_ACTION_RECALL,
                                                                  pScanItem,
                                                                  skipWork));
                            }WsbCatch( hr );
                        }
                        EndRecallSession(pWorkItem, FALSE);

                        break;
                    }

                case HSM_WORK_ITEM_MOVER_CANCELLED: {
                        CComPtr<IHsmRecallItem> pWorkItemToCancel;

                        WsbTrace(OLESTR("CHsmRecallQueue::DoWork - Mover Cancelled\n"));
                        try {
                            //
                            // Get hold of the work item that needs to be cancelled.
                            // This is indicated by the session pointer in the cancel work item
                            //
                            hr = FindRecallItemToCancel(pWorkItem, &pWorkItemToCancel);
                            if (hr == S_OK) {
                                EndRecallSession(pWorkItemToCancel, TRUE);
                                //
                                // Remove the *cancelled* work item
                                //
                                Remove(pWorkItemToCancel);
                            }

                            //
                            // Remove the cancel work item
                            //
                            hr = S_OK;
                        }WsbCatch( hr );
                        //
                        // We are done completely with one more work item
                        //
                        break;
                    }

                default: {
                        hr = E_UNEXPECTED;
                        break;
                    }
                }
               pWorkItem = 0;
           }
    }WsbCatch( hr );

    //
    // Dismount the media..
    //
    DismountMedia(FALSE);

    // Pretend everything is OK
    hr = S_OK;

    //  Release the thread (the thread should terminate on exit
    //  from the routine that called this routine)
    //  In case of termination, the terminating thread will close the handle
    if (! m_TerminateQueue) {
        CloseHandle(m_WorkerThread);
        m_WorkerThread = 0;
    }

    //  Allow this object to be released
    ((IUnknown*)(IHsmRecallQueue*)this)->Release();

    WsbTraceOut(OLESTR("CHsmRecallQueue::DoWork"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);
}



HRESULT
CHsmRecallQueue::DoFsaWork(
                          IHsmRecallItem *pWorkItem
                          )
/*++


--*/ 
{
    HRESULT                 hr = S_OK;
    HRESULT                 hr2 = S_OK;
    HRESULT                 workHr = S_OK;
    HSM_JOB_PHASE           jobPhase;

    CWsbStringPtr           path;
    CComPtr<IFsaPostIt>     pFsaWorkItem;
    CComPtr<IHsmSession>    pSession;
    CComPtr<IFsaResource>   pFsaResource;

    WsbTraceIn(OLESTR("CHsmRecallQueue::DoFsaWork"),OLESTR(""));
    try {
        //
        // Do the work.
        //
        WsbAffirmHr(pWorkItem->GetFsaPostIt(&pFsaWorkItem));
        WsbAffirmHr(pWorkItem->GetJobPhase(&jobPhase));
        WsbAffirmHr(pFsaWorkItem->GetPath(&path, 0));
        WsbAffirmHr(pFsaWorkItem->GetSession(&pSession));
        WsbAffirmHr(pSession->GetResource(&pFsaResource));

        WsbTrace(OLESTR("Handling file <%s>.\n"), WsbAbbreviatePath(path, 120));
        workHr = RecallIt(pWorkItem);
        //
        // Tell the recaller right away about the success or failure
        // of the recall, we do this here so the recall filter can
        // release the open as soon as possible
        //
        hr = pFsaWorkItem->SetResult(workHr);
        if (S_OK == hr) {
            WsbTrace(OLESTR("HSM recall (filter, read or recall) complete, calling FSA\n"));
            hr = pFsaResource->ProcessResult(pFsaWorkItem);
            WsbTrace(OLESTR("FSA ProcessResult returned <%ls>\n"), WsbHrAsString(hr));
        }

        // Note: In case that the recall item is/was canceling at any time, we don't want
        //  to report on errors. If the cancel occurred  while the recall item was queued, 
        //  we won't get here at all, but if it was cancelled while being executed, we 
        //  might end up here with some bad workHr returned by the Mover code
        if ((S_OK != workHr) && (S_OK != pSession->IsCanceling())) {
            // Tell the session how things went if they didn't go well.
            (void) pSession->ProcessHr(jobPhase, 0, 0, workHr);
        }
    }WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRecallQueue::DoFsaWork"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);

}


HRESULT
CHsmRecallQueue::MountMedia(
                           IHsmRecallItem *pWorkItem,
                           GUID           mediaToMount,
                           BOOL           bShortWait
                           )

/*++


--*/
{
    HRESULT                 hr = S_OK;
    GUID                    l_MediaToMount = mediaToMount;
    CComPtr<IRmsDrive>      pDrive;
    CWsbBstrPtr             pMediaName;
    DWORD                   dwOptions = RMS_NONE;
    DWORD                   threadId;
    CComPtr<IFsaPostIt>     pFsaWorkItem;

    WsbTraceIn(OLESTR("CHsmRecallQueue::MountMedia"),OLESTR("Display Name = <%ls>"), (WCHAR *)m_MediaName);
    try {
        WsbAffirmHr(pWorkItem->GetFsaPostIt(&pFsaWorkItem));
        WsbAffirmHr(pFsaWorkItem->GetThreadId(&threadId));

        // If we're switching tapes, dismount the current one
        if ((m_MountedMedia != l_MediaToMount) && (m_MountedMedia != GUID_NULL)) {
            WsbAffirmHr(DismountMedia());
        }
        // Ask RMS for short timeout, both for Mount and Allocate
        if (bShortWait) {
            dwOptions |= RMS_SHORT_TIMEOUT;
        }
        dwOptions |= RMS_USE_MOUNT_NO_DEADLOCK;

        if (m_MountedMedia != l_MediaToMount) {
            ReportMediaProgress(HSM_JOB_MEDIA_STATE_MOUNTING, hr);
            hr = m_pRmsServer->MountCartridge( l_MediaToMount, &pDrive, &m_pRmsCartridge, &m_pDataMover, dwOptions, threadId);
            hr = TranslateRmsMountHr(hr);
            //
            //  If failure is because cartridge is disabled, need to get media label to put in error.
            //
            if (hr == RMS_E_CARTRIDGE_DISABLED) {

                // Since this is just to get label, if any of these functions fail,
                // don't throw, error will simply have blank label.
                //
                CComPtr<IRmsCartridge>  pMedia;
                HRESULT                 hrName;

                hrName = m_pRmsServer->FindCartridgeById(l_MediaToMount , &pMedia);
                if (hrName == S_OK) {
                    pMedia->GetName(&pMediaName);
                }
                if ((hrName != S_OK) || ((WCHAR *)pMediaName == NULL)) {
                    // Cannot get media name - set to blanks
                    pMediaName = L"";
                }

                WsbThrow(hr);
            }

            WsbAffirmHr(hr);
            m_MountedMedia = l_MediaToMount;
            WsbTrace( OLESTR("Mount completed.\n") );

            WsbAffirmHr(GetMediaParameters());

        }
    }WsbCatchAndDo(hr,
                   switch (hr){case HSM_E_STG_PL_NOT_CFGD:case HSM_E_STG_PL_INVALID:
                   FailJob(pWorkItem);
                  break;case RMS_E_CARTRIDGE_DISABLED:
                  WsbLogEvent(HSM_MESSAGE_MEDIA_DISABLED, 0, NULL, pMediaName, NULL);
                  break;
                  default:
                  break;}
                  );

    WsbTraceOut(OLESTR("CHsmRecallQueue::MountMedia"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);
}


HRESULT
CHsmRecallQueue::GetSource(
                          IFsaPostIt                  *pFsaWorkItem,
                          OLECHAR                     **pSourceString
                          )
/*++

Routine Description:

  This function builds the Source file name

Arguments:

  pFsaWorkItem - the item to be migrated
  pSourceString - the Source file name.

Return Value:

  S_OK

--*/ {
    HRESULT             hr = S_OK;

    CComPtr<IFsaResource>   pResource;
    CWsbStringPtr           tmpString;
    CComPtr<IHsmSession>    pSession;
    CWsbStringPtr           path;

    WsbTraceIn(OLESTR("CHsmRecallQueue::GetSource"),OLESTR(""));
    try {
        //
        // Get the real session pointer from the IUnknown
        //
        WsbAffirmHr(pFsaWorkItem->GetSession(&pSession));
        WsbAffirm(pSession != 0, E_POINTER);

        // First get the name of the resource from the session
        WsbAffirmHr(pSession->GetResource(&pResource));
        WsbAffirmHr(pFsaWorkItem->GetPath(&path, 0));

        tmpString.Alloc(1000);
        WsbAffirmHr(pResource->GetPath(&tmpString, 0));
        tmpString.Append(&(path[1]));
        // tmpString.Prepend(OLESTR("\\\\?\\"));
        WsbAffirmHr(tmpString.GiveTo(pSourceString));

    }WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRecallQueue::GetSource"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);
}


HRESULT
CHsmRecallQueue::GetScanItem(
                            IFsaPostIt *pFsaWorkItem,
                            IFsaScanItem ** ppIFsaScanItem
                            )
{
    HRESULT                     hr = S_OK;
    CWsbStringPtr               path;
    CComPtr<IHsmSession>        pSession;
    CComPtr<IFsaResource>       pFsaResource;


    WsbTraceIn(OLESTR("CHsmRecallQueue::GetScanItem"),OLESTR(""));

    try {
        WsbAffirmPointer(ppIFsaScanItem);
        WsbAffirm(!*ppIFsaScanItem, E_INVALIDARG);
        WsbAffirmHr(pFsaWorkItem->GetSession(&pSession));
        WsbAffirmHr(pSession->GetResource(&pFsaResource));
        WsbAffirmHr(pFsaWorkItem->GetPath(&path, 0));
        WsbAffirmHr(pFsaResource->FindFirst(path, pSession, ppIFsaScanItem));

    }WsbCatch (hr)

    WsbTraceOut(OLESTR("CHsmRecallQueue::GetScanItem"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return( hr );
}


DWORD HsmRecallQueueThread(
                          void *pVoid
                          )

/*++


--*/ {
    HRESULT     hr;

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    hr = ((CHsmRecallQueue*) pVoid)->DoWork();

    CoUninitialize();
    return(hr);
}


HRESULT
CHsmRecallQueue::SetState(
                         IN HSM_JOB_STATE state,
                         IN HSM_JOB_PHASE phase,
                         IN IHsmSession * pSession
                         )

/*++

--*/
{
    HRESULT         hr = S_OK;
    BOOL            bLog = TRUE;

    WsbTraceIn(OLESTR("CHsmRecallQueue:SetState"), OLESTR("state = <%ls>"), JobStateAsString( state ) );

    try {
        //
        // Change the state and report the change to the session.  Unless the current state is
        // failed then leave it failed.  Is is necessary because when this guy fails, it will
        // cancel all sessions so that no more work is sent in and so we will skip any queued work.
        // If the current state is failed, we don't need to spit out the failed message every time,
        // so we send ProcessState a false fullmessage unless the state is cancelled.
        //
        WsbAffirmHr(pSession->ProcessState(phase, state, m_CurrentPath, TRUE));

    }WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRecallQueue::SetState"), OLESTR("hr = <%ls> "), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmRecallQueue::Cancel(
                       IN HSM_JOB_PHASE jobPhase,
                       IN IHsmSession *pSession
                       )

/*++

Implements:

  CHsmRecallQueue::Cancel().

--*/
{
    HRESULT                 hr = S_OK;

    UNREFERENCED_PARAMETER(pSession);

    WsbTraceIn(OLESTR("CHsmRecallQueue::Cancel"), OLESTR(""));

    (void)SetState(HSM_JOB_STATE_CANCELLING, jobPhase, pSession);

    try {
        //
        // This needs to be prepended and the queue emptied out!
        //
        CComPtr<IHsmRecallItem>  pWorkItem;
        CComPtr<IFsaPostIt>      pFsaWorkItem;
        WsbAffirmHr(m_pHsmServerCreate->CreateInstance(CLSID_CHsmRecallItem, IID_IHsmRecallItem,
                                                       (void **)&pWorkItem));
        //
        // Create the minimal postit needed to contain the session so that DoWork
        // can retrieve it from the work item.
        // TBD: make pSession a member of CHsmRecallItem, so that we don't need
        // to keep obtaining it via the IFsaPostIt. Also it saves us the trouble
        // of creating a dummy FsaPostIt here.
        //
        WsbAffirmHr(m_pHsmServerCreate->CreateInstance(CLSID_CFsaPostIt, IID_IFsaPostIt,
                                                       (void **)&pFsaWorkItem));

        WsbAffirmHr(pWorkItem->SetWorkType(HSM_WORK_ITEM_MOVER_CANCELLED));
        WsbAffirmHr(pWorkItem->SetJobPhase(jobPhase));
        WsbAffirmHr(pWorkItem->SetFsaPostIt(pFsaWorkItem));
        WsbAffirmHr(pFsaWorkItem->SetSession(pSession));
        //
        // Our work item is ready now, ship it
        //
        WsbAffirmHr(m_pWorkToDo->Prepend(pWorkItem));
    }WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRecallQueue::Cancel"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT
CHsmRecallQueue::FailJob(
                        IHsmRecallItem *pWorkItem
                        )

/*++

Implements:

  CHsmRecallQueue::FailJob().

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IHsmSession>    pSession;
    CComPtr<IFsaPostIt>     pFsaWorkItem;
    HSM_JOB_PHASE           jobPhase;

    WsbTraceIn(OLESTR("CHsmRecallQueue::FailJob"), OLESTR(""));
    try {
        //
        // Set our state to failed and then cancel all work
        //
        WsbAffirmHr(pWorkItem->GetFsaPostIt(&pFsaWorkItem));
        WsbAffirmHr(pFsaWorkItem->GetSession(&pSession));
        WsbAffirmHr(pWorkItem->GetJobPhase(&jobPhase));

        WsbAffirmHr(SetState(HSM_JOB_STATE_FAILED, jobPhase, pSession));
        if (pSession != 0) {
            WsbAffirmHr(pSession->Cancel( HSM_JOB_PHASE_ALL ));
        }

    }WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRecallQueue::FailJob"), OLESTR("hr = <%ls>"), WsbHrAsString(hr) );
    return(hr);
}


void
CHsmRecallQueue::ReportMediaProgress(
                                    HSM_JOB_MEDIA_STATE state,
                                    HRESULT               /*status*/
                                    )

/*++

Implements:

  CHsmRecallQueue::ReportMediaProgress().

--*/
{
    HRESULT                 hr = S_OK;
    CWsbStringPtr           mediaName;
    HSM_JOB_MEDIA_TYPE      mediaType = HSM_JOB_MEDIA_TYPE_UNKNOWN;

    UNREFERENCED_PARAMETER(state);

    WsbTraceIn(OLESTR("CHsmRecallQueue::ReportMediaProgress"), OLESTR(""));

//
// TBD : we have to figure out a way to report media progress!
// Without the session pointer this is tough..
//
    // Report Progress but we don't really care if it succeeds.
//		hr = m_pSession->ProcessMediaState(m_JobPhase, state, m_MediaName, m_MediaType, 0);
    WsbTraceOut(OLESTR("CHsmRecallQueue::ReportMediaProgress"), OLESTR("hr = <%ls>"), WsbHrAsString(hr) );
}


HRESULT
CHsmRecallQueue::GetMediaParameters( void )

/*++

Implements:

  CHsmRecallQueue::GetMediaParameters

--*/ {
    HRESULT                 hr = S_OK;
    LONG                    rmsCartridgeType;
    CWsbBstrPtr             barCode;


    WsbTraceIn(OLESTR("CHsmRecallQueue::GetMediaParameters"), OLESTR(""));
    try {
        //
        // Get some information about the media
        //
        WsbAffirmHr(m_pDataMover->GetLargestFreeSpace( &m_MediaFreeSpace, &m_MediaCapacity ));
        WsbAffirmHr(m_pRmsCartridge->GetType( &rmsCartridgeType ));
        WsbAffirmHr(ConvertRmsCartridgeType(rmsCartridgeType, &m_MediaType));
        WsbAffirmHr(m_pRmsCartridge->GetName(&barCode));
        WsbAffirmHr(CoFileTimeNow(&m_MediaUpdate));
        m_MediaBarCode = barCode;
    }WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRecallQueue::GetMediaParameters"), OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);
}


HRESULT
CHsmRecallQueue::DismountMedia( BOOL bNoDelay)

/*++

Implements:

  CHsmRecallQueue::DismountMedia

--*/ {
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallQueue::DismountMedia"), OLESTR(""));
    try {
        if ((m_pRmsCartridge != 0) && (m_MountedMedia != GUID_NULL)) {
            //
            // End the session with the data mover.  If this doesn't work, report
            // the problem but continue with the dismount.
            //

            //
            // Tell the session that we are dismounting media. Ignore any problems
            // with the reporting
            //
            (void )ReportMediaProgress(HSM_JOB_MEDIA_STATE_DISMOUNTING, S_OK);

            //
            // Dismount the cartridge and report progress
            //

            // !!! IMPORTANT NOTE !!!
            //
            // Must free Rms resources used before dismounting...
            //
            m_pRmsCartridge = 0;
            m_pDataMover    = 0;

            DWORD dwOptions = RMS_NONE;
            if (bNoDelay) {
                dwOptions |= RMS_DISMOUNT_DEFERRED_ONLY;
            }
            hr = m_pRmsServer->DismountCartridge(m_MountedMedia, dwOptions);
            (void) ReportMediaProgress(HSM_JOB_MEDIA_STATE_DISMOUNTED, hr);

            //
            // Clear out the knowledge of media that was just dismounted
            //
            WsbAffirmHr(UnsetMediaInfo());

            WsbAffirmHr(hr);
            WsbTrace( OLESTR("Dismount completed OK.\n") );
        } else {
            WsbTrace( OLESTR("There is no media to dismount.\n") );
        }
    }WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRecallQueue::DismountMedia"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT
CHsmRecallQueue::ConvertRmsCartridgeType(
                                        LONG                rmsCartridgeType,
                                        HSM_JOB_MEDIA_TYPE  *pMediaType
                                        )

/*++

Implements:

  CHsmRecallQueue::ConvertRmsCartridgeType

--*/ {
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallQueue::ConvertRmsCartridgeType"), OLESTR(""));
    try {

        WsbAssert(0 != pMediaType, E_POINTER);

        switch (rmsCartridgeType) {
        case RmsMedia8mm:
        case RmsMedia4mm:
        case RmsMediaDLT:
        case RmsMediaTape:
            *pMediaType = HSM_JOB_MEDIA_TYPE_TAPE;
            break;
        case RmsMediaOptical:
        case RmsMediaMO35:
        case RmsMediaWORM:
        case RmsMediaCDR:
        case RmsMediaDVD:
            *pMediaType = HSM_JOB_MEDIA_TYPE_OPTICAL;
            break;
        case RmsMediaDisk:
            *pMediaType = HSM_JOB_MEDIA_TYPE_REMOVABLE_MAG;
            break;
        case RmsMediaFixed:
            *pMediaType = HSM_JOB_MEDIA_TYPE_FIXED_MAG;
            break;
        case RmsMediaUnknown:default:
            *pMediaType = HSM_JOB_MEDIA_TYPE_UNKNOWN;
            break;
        }
    }WsbCatch( hr );

    WsbTraceOut(OLESTR("CHsmRecallQueue::ConvertRmsCartridgeType"), OLESTR("hr = <%ls>"),
                WsbHrAsString(hr));
    return(hr);
}

HRESULT
CHsmRecallQueue::MarkWorkItemAsDone(IN IHsmSession *pSession,
                                    IN HSM_JOB_PHASE jobPhase)

/*++

Implements:

  CHsmRecallQueue::MarkWorkItemAsDone

--*/
{
    HRESULT                 hr = S_OK;


    WsbTraceIn(OLESTR("CHsmRecallQueue::MarkWorkItemAsDone"), OLESTR(""));
    try {
        // Create a work item and append it to the work queue to
        // indicate that the job is done
        CComPtr<IHsmRecallItem>  pWorkItem;
        CComPtr<IFsaPostIt>      pFsaWorkItem;
        WsbAffirmHr(m_pHsmServerCreate->CreateInstance(CLSID_CHsmRecallItem, IID_IHsmRecallItem,
                                                       (void **)&pWorkItem));

        //
        // Create the minimal postit needed to contain the session so that DoWork
        // can retrieve it from the work item.
        // TBD: make pSession a member of CHsmRecallItem, so that we don't need
        // to keep obtaining it via the IFsaPostIt. Also it saves us the trouble
        // of creating a dummy FsaPostIt here.
        //
        WsbAffirmHr(m_pHsmServerCreate->CreateInstance(CLSID_CFsaPostIt, IID_IFsaPostIt,
                                                       (void **)&pFsaWorkItem));

        WsbAffirmHr(pWorkItem->SetWorkType(HSM_WORK_ITEM_FSA_DONE));
        WsbAffirmHr(pWorkItem->SetJobPhase(jobPhase));
        WsbAffirmHr(pWorkItem->SetFsaPostIt(pFsaWorkItem));
        WsbAffirmHr(pFsaWorkItem->SetSession(pSession));
        //
        // Our work item is ready now, ship it
        //
        WsbAffirmHr(m_pWorkToDo->Append(pWorkItem));

    }WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRecallQueue::MarkWorkItemAsDone"), OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);
}


HRESULT
CHsmRecallQueue::CheckRegistry(void)
{
    HRESULT      hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallQueue::CheckRegistry"), OLESTR(""));

    try {
        //  Check for change to number of errors to allow before cancelling
        //  a job
        WsbAffirmHr(WsbRegistryValueUlongAsString(NULL, HSM_ENGINE_REGISTRY_STRING, HSM_JOB_ABORT_CONSECUTIVE_ERRORS,
                                                  &m_JobAbortMaxConsecutiveErrors));
        WsbTrace(OLESTR("CHsmRecallQueue::CheckRegistry: m_JobAbortMaxConsecutiveErrors = %lu\n"),
                 m_JobAbortMaxConsecutiveErrors);
        WsbAffirmHr(WsbRegistryValueUlongAsString(NULL, HSM_ENGINE_REGISTRY_STRING, HSM_JOB_ABORT_TOTAL_ERRORS,
                                                  &m_JobAbortMaxTotalErrors));
        WsbTrace(OLESTR("CHsmRecallQueue::CheckRegistry: m_JobAbortMaxTotalErrors = %lu\n"),
                 m_JobAbortMaxTotalErrors);


    }WsbCatch( hr );

    WsbTraceOut(OLESTR("CHsmRecallQueue::CheckRegistry"), OLESTR("hr = <%ls>"),
                WsbHrAsString(hr));

    return( hr );
}



HRESULT
CHsmRecallQueue::TranslateRmsMountHr(
                                    HRESULT     rmsMountHr
                                    )

/*++


--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallQueue::TranslateRmsMountHr"),OLESTR("rms hr = <%ls>"), WsbHrAsString(rmsMountHr));
    try {
        switch (rmsMountHr) {
        case S_OK:
            hr = S_OK;
            ReportMediaProgress(HSM_JOB_MEDIA_STATE_MOUNTED, hr);
            break;
        case RMS_E_MEDIASET_NOT_FOUND:
            if (m_RmsMediaSetId == GUID_NULL) {
                hr = HSM_E_STG_PL_NOT_CFGD;
            } else {
                hr = HSM_E_STG_PL_INVALID;
            }
            ReportMediaProgress(HSM_JOB_MEDIA_STATE_UNAVAILABLE, hr);
            break;
        case RMS_E_SCRATCH_NOT_FOUND:
            hr = HSM_E_NO_MORE_MEDIA;
            ReportMediaProgress(HSM_JOB_MEDIA_STATE_UNAVAILABLE, hr);
            break;
        case RMS_E_CARTRIDGE_UNAVAILABLE:
        case RMS_E_RESOURCE_UNAVAILABLE:
        case RMS_E_DRIVE_UNAVAILABLE:
        case RMS_E_LIBRARY_UNAVAILABLE:
            hr = HSM_E_MEDIA_NOT_AVAILABLE;
            ReportMediaProgress(HSM_JOB_MEDIA_STATE_UNAVAILABLE, hr);
            break;
        case RMS_E_CARTRIDGE_BUSY:
        case RMS_E_RESOURCE_BUSY:
        case RMS_E_DRIVE_BUSY:
            hr = HSM_E_MEDIA_BUSY;
            ReportMediaProgress(HSM_JOB_MEDIA_STATE_BUSY, hr);
            break;
        case RMS_E_CARTRIDGE_NOT_FOUND:
        case RMS_E_CARTRIDGE_DISABLED:
        case RMS_E_TIMEOUT:
            hr = rmsMountHr;
            ReportMediaProgress(HSM_JOB_MEDIA_STATE_UNAVAILABLE, hr);
            break;
        default:
            hr = rmsMountHr;
            ReportMediaProgress(HSM_JOB_MEDIA_STATE_UNAVAILABLE, hr);
            break;
        }
    }WsbCatch( hr );

    WsbTraceOut(OLESTR("CHsmRecallQueue::TranslateRmsMountHr"),
                OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);

}


HRESULT
CHsmRecallQueue::Remove(
                       IHsmRecallItem *pWorkItem
                       )
/*++

Implements:

  IHsmFsaTskMgr::Remove

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallQueue::Remove"),OLESTR(""));
    try {
        //
        // Remove the item from the queue
        //
        (void)m_pWorkToDo->RemoveAndRelease(pWorkItem);
    }WsbCatch (hr);

    WsbTraceOut(OLESTR("CHsmRecallQueue::Remove"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);
}


HRESULT
CHsmRecallQueue::ChangeSysState(
                               IN OUT HSM_SYSTEM_STATE* pSysState
                               )

/*++

Implements:

  IHsmSystemState::ChangeSysState().

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallQueue::ChangeSysState"), OLESTR(""));

    try {

        if (pSysState->State & HSM_STATE_SHUTDOWN) {

            //  Release the thread (we assume it has been stopped already)
            if (m_WorkerThread) {
                CloseHandle(m_WorkerThread);
                m_WorkerThread = 0;
            }

            if (m_pDataMover) {
                //
                // Cancel any active I/O
                //
                (void) m_pDataMover->Cancel();
            }
/* TBD
          // If Session is valid - unadvise and free session, otherwise, just try to
          // dismount media if it is mounted (which we don't know at this point)
          // Best effort dismount, no error checking so following resources will get released.
          if (m_pSession != 0) {
              EndSessions(FALSE, TRUE);
          } else {
              (void) DismountMedia(TRUE);
          }
*/
            (void) DismountMedia(TRUE);
        }

    }WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRecallQueue::ChangeSysState"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmRecallQueue::EndRecallSession(
                                 IN IHsmRecallItem   *pWorkItem,
                                 IN BOOL               cancelled
                                 )
{
    HRESULT             hr = S_OK;
    CComPtr<IFsaPostIt> pFsaWorkItem;
    DWORD               stateCookie;
    DWORD               eventCookie;

    ULONG                     refCount;

    WsbTraceIn(OLESTR("CHsmRecallQueue::EndRecallSession"),OLESTR(""));
    try {
        HRESULT dismountHr = S_OK;

        CComPtr<IConnectionPointContainer>  pCPC;
        CComPtr<IConnectionPoint>           pCP;
        CComPtr<IHsmSession>                pSession;
        HSM_JOB_PHASE                       jobPhase;
        //
        // Get the session
        //
        WsbAffirmHr(pWorkItem->GetFsaPostIt(&pFsaWorkItem));
        WsbAffirmHr(pFsaWorkItem->GetSession(&pSession));
        WsbAffirmHr(pWorkItem->GetStateCookie(&stateCookie));
        WsbAffirmHr(pWorkItem->GetEventCookie(&eventCookie));
        WsbAffirmHr(pWorkItem->GetJobPhase(&jobPhase));
        //
        // Tell the session that we don't want to be advised anymore.
        //
        try {
            WsbAffirmHr(pSession->QueryInterface(IID_IConnectionPointContainer, (void**) &pCPC));
            WsbAffirmHr(pCPC->FindConnectionPoint(IID_IHsmSessionSinkEveryState, &pCP));

            refCount = (((IUnknown *) (IHsmFsaTskMgr *) this)->AddRef()) - 1;
            ((IUnknown *) (IHsmFsaTskMgr *)this)->Release();
            WsbTrace(OLESTR("REFCOUNT for CHsmRecallQueue before stateCookie UnAdvise: %ls \n"), WsbLongAsString((LONG) refCount));

            WsbAffirmHr(pCP->Unadvise(stateCookie));
        }WsbCatch( hr );

        refCount = (((IUnknown *) (IHsmFsaTskMgr *) this)->AddRef()) - 1;
        ((IUnknown *) (IHsmFsaTskMgr *)this)->Release();
        WsbTrace(OLESTR("REFCOUNT for CHsmRecallQueue after stateCookie UnAdvise: %ls \n"), WsbLongAsString((LONG) refCount));

        pCPC = 0;
        pCP = 0;

        refCount = (((IUnknown *) (IHsmFsaTskMgr *) this)->AddRef()) - 1;
        ((IUnknown *) (IHsmFsaTskMgr *)this)->Release();
        WsbTrace(OLESTR("REFCOUNT for CHsmRecallQueue before eventCookie UnAdvise: %ls \n"), WsbLongAsString((LONG) refCount));

        try {
            WsbAffirmHr(pSession->QueryInterface(IID_IConnectionPointContainer, (void**) &pCPC));
            WsbAffirmHr(pCPC->FindConnectionPoint(IID_IHsmSessionSinkEveryEvent, &pCP));
            WsbAffirmHr(pCP->Unadvise(eventCookie));
        }WsbCatch( hr );

        refCount = (((IUnknown *) (IHsmFsaTskMgr *) this)->AddRef()) - 1;
        ((IUnknown *) (IHsmFsaTskMgr *)this)->Release();
        WsbTrace(OLESTR("REFCOUNT for CHsmRecallQueue after eventCookie UnAdvise: %ls \n"), WsbLongAsString((LONG) refCount));

        pCPC = 0;
        pCP = 0;

        WsbTrace( OLESTR("Telling Session Data mover is done\n") );
        if (cancelled) {
            (void)SetState(HSM_JOB_STATE_DONE, jobPhase, pSession);
        } else {
            (void)SetState(HSM_JOB_STATE_CANCELLED, jobPhase, pSession);
        }
        pSession = 0;
        WsbAffirmHr(hr);
    }WsbCatch (hr);

    WsbTraceOut(OLESTR("CHsmRecallQueue::EndRecallSession"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);
}


HRESULT
CHsmRecallQueue::UnsetMediaInfo( void )

/*++

Routine Description:

     Sets the media data members back to their default (unset) values.

Arguments:

     None.

Return Value:

     S_OK:  Ok.

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallQueue::UnsetMediaInfo"), OLESTR(""));

    m_MediaId        = GUID_NULL;
    m_MountedMedia   = GUID_NULL;
    m_MediaType      = HSM_JOB_MEDIA_TYPE_UNKNOWN;
    m_MediaName      = OLESTR("");
    m_MediaBarCode   = OLESTR("");
    m_MediaFreeSpace = 0;
    m_MediaCapacity = 0;
    m_MediaReadOnly = FALSE;
    m_MediaUpdate = WsbLLtoFT(0);

    WsbTraceOut(OLESTR("CHsmRecallQueue::UnsetMediaInfo"), OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);
}


HRESULT
CHsmRecallQueue::GetMediaId (OUT GUID *mediaId)
/*++

Routine Description:

     Gets the media id for the queue

Arguments:

     None.

Return Value:

     S_OK:  Ok.

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallQueue::GetMediaId"), OLESTR(""));
    *mediaId = m_MediaId;
    WsbTraceOut(OLESTR("CHsmRecallQueue::GetMediaId"),OLESTR("hr = <%ls>, Id = <%ls>"),
                WsbHrAsString(hr), WsbPtrToGuidAsString(mediaId));
    return(hr);
}


HRESULT
CHsmRecallQueue::SetMediaId (IN GUID *mediaId)
/*++

Routine Description:

     Sets the media id for the queue

Arguments:

     None.

Return Value:

     S_OK:  Ok.

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallQueue::SetMediaId"), OLESTR(""));
    m_MediaId = *mediaId;
    WsbTraceOut(OLESTR("CHsmRecallQueue::SetMediaId"),OLESTR("hr = <%ls>, Id = <%ls>"),
                WsbHrAsString(hr), WsbPtrToGuidAsString(mediaId));
    return(hr);
}


HRESULT
CHsmRecallQueue::IsEmpty ( void )
/*++

Routine Description:

    Checks if the queue is empty

Arguments:

     None.

Return Value:

     S_OK:    Queue is empty
     S_FALSE: Queue is non-empty

--*/
{
    HRESULT hr;
    hr = m_pWorkToDo->IsEmpty();
    return(hr);
}


HRESULT
CHsmRecallQueue::FindRecallItemToCancel(
                                       IHsmRecallItem *pWorkItem,
                                       IHsmRecallItem **pWorkItemToCancel
                                       )
/*++

Routine Description:

     Pulls the work item that needs to be cancelled
     indicated by pWorkItem and returns it
     (by matching the pSession pointer)

Arguments:

     None.

Return Value:


--*/
{
    CComPtr<IFsaPostIt>   pFsaWorkItem;
    CComPtr<IHsmSession>  pSession;
    CComPtr<IHsmSession>  pWorkSession;
    HRESULT                  hr;
    ULONG index = 0;

    WsbTraceIn(OLESTR("CHsmRecallQueue::FindRecallItemToCancel"), OLESTR(""));

    pWorkItem->GetFsaPostIt(&pFsaWorkItem);
    pFsaWorkItem->GetSession(&pSession);
    pFsaWorkItem = 0;
    do {
        hr = m_pWorkToDo->At(index, IID_IHsmRecallItem, (void **)pWorkItemToCancel);
        if (S_OK == hr) {
            (*pWorkItemToCancel)->GetFsaPostIt(&pFsaWorkItem);
            pFsaWorkItem->GetSession(&pWorkSession);
            if ((pWorkItem != (*pWorkItemToCancel)) && (pSession == pWorkSession)) {
                WsbTrace(OLESTR("CHsmRecallQueue::FindRecallItemToCancel: Found item to cancel, pSession = %p\n"), pSession);
                break;
            }
            (*pWorkItemToCancel)->Release();
            (*pWorkItemToCancel) = 0;
            pWorkSession = 0;
            pFsaWorkItem = 0;
        }
        index++;
    } while (S_OK == hr);

    WsbTraceOut(OLESTR("CHsmRecallQueue::FindRecallItemToCancel"), OLESTR("hr = <%ls>"),WsbHrAsString(hr));

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\engine\task\hsmworki.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    hsmworki.cpp

Abstract:

    This class represents an HSM work item - a unit of work
    that is performed by the HSM engine

Author:

    Cat Brant   [cbrant]   5-May-1997

Revision History:

--*/

#include "stdafx.h"

#define WSB_TRACE_IS        WSB_TRACE_BIT_HSMTSKMGR
#include "wsb.h"
#include "fsa.h"
#include "task.h"
#include "hsmworki.h"

static USHORT iCount = 0;

HRESULT
CHsmWorkItem::CompareTo(
    IN IUnknown* pUnknown,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbCollectable::CompareTo().

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IHsmWorkItem>   pWorkItem;

    WsbTraceIn(OLESTR("CHsmWorkItem::CompareTo"), OLESTR(""));
    
    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pUnknown, E_POINTER);

        // We need the IHsmWorkItem interface to get the value of the object.
        WsbAffirmHr(pUnknown->QueryInterface(IID_IHsmWorkItem, (void**) &pWorkItem));

        // Compare the items
        hr = CompareToIHsmWorkItem(pWorkItem, pResult);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkItem::CompareTo"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CHsmWorkItem::CompareToIHsmWorkItem(
    IN IHsmWorkItem* pWorkItem,
    OUT SHORT* pResult
    )

/*++

Implements:

  IHsmWorkItem::CompareToIHsmWorkItem().

--*/
{
    HRESULT                 hr = S_OK;
    GUID                    l_Id;           // Type of work to do

    WsbTraceIn(OLESTR("CHsmWorkItem::CompareToIHsmWorkItem"), OLESTR(""));

    try {
        //
        // Did they give us a valid item to compare to?
        //
        WsbAssert(0 != pWorkItem, E_POINTER);
        
        //
        // Get the ID
        //
        WsbAffirmHr(pWorkItem->GetId(&l_Id));

        if (l_Id != m_MyId){
            hr = S_FALSE;
        } 
        // If they asked for the relative value back, then return it to them.
        if (pResult != NULL) {
            if (S_OK == hr)  {
                *pResult = 0;
            } else {
                *pResult = 1;
            }
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkItem::CompareToIHsmWorkItem"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CHsmWorkItem::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    WsbTraceIn(OLESTR("CHsmWorkItem::FinalConstruct"), OLESTR(""));
    try {

        WsbAffirmHr(CWsbObject::FinalConstruct());
        //
        // The comparison for database searches is based on the
        // ID of this object (m_MyId). 
        //
        WsbAffirmHr(CoCreateGuid(&m_MyId));
        m_WorkType = HSM_WORK_ITEM_NONE;
        m_MediaId = GUID_NULL;
        m_MediaLastUpdate =  WsbLLtoFT(0);
        m_MediaLastError = S_OK;
        m_MediaRecallOnly = FALSE;
        m_MediaFreeBytes = 0;

    } WsbCatch(hr);

    iCount++;
    WsbTraceOut(OLESTR("CHsmWorkItem::FinalConstruct"), OLESTR("hr = <%ls>, Count is <%d>"),
        WsbHrAsString(hr), iCount);
    return(hr);
}


void
CHsmWorkItem::FinalRelease(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalRelease().

--*/
{

    WsbTraceIn(OLESTR("CHsmWorkItem::FinalRelease"), OLESTR(""));
    // Let the parent class do his thing.   
    CWsbObject::FinalRelease();
    
    iCount--;
    WsbTraceOut(OLESTR("CHsmWorkItem::FinalRelease"), OLESTR("Count is <%d>"), iCount);
    
}


HRESULT
CHsmWorkItem::GetFsaPostIt (
    OUT IFsaPostIt  **ppFsaPostIt
    )

/*++

Implements:

  IHsmWorkItem::GetFsaPostIt

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkItem::GetFsaPostIt"), OLESTR(""));

    try {

        // Did they give us a valid pointer?
        WsbAssert(0 != ppFsaPostIt, E_POINTER);
        *ppFsaPostIt = m_pFsaPostIt;
        if (0 != *ppFsaPostIt)  {
            (*ppFsaPostIt)->AddRef();
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkItem::GetFsaPostIt"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CHsmWorkItem::GetFsaResource (
    OUT IFsaResource  **ppFsaResource
    )

/*++

Implements:

  IHsmWorkItem::GetFsaResource

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkItem::GetFsaResource"), OLESTR(""));

    try {

        // Did they give us a valid pointer?
        WsbAssert(0 != ppFsaResource, E_POINTER);
        *ppFsaResource = m_pFsaResource;
        if (0 != *ppFsaResource)  {
            (*ppFsaResource)->AddRef();
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkItem::GetFsaResource"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CHsmWorkItem::GetId(
    OUT GUID *pId
    )

/*++

Implements:

  IHsmWorkItem::GetId().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkItem::GetId"), OLESTR(""));

    try {

        // Did they give us a valid pointer?
        WsbAssert(0 != pId, E_POINTER);
        *pId = m_MyId;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkItem::GetId"), OLESTR("hr = <%ls>, Id = <%ls>"), 
            WsbHrAsString(hr), WsbPtrToGuidAsString(pId));

    return(hr);
}

HRESULT
CHsmWorkItem::GetMediaInfo (
    OUT GUID *pMediaId, 
    OUT FILETIME *pMediaLastUpdate,
    OUT HRESULT *pMediaLastError, 
    OUT BOOL *pMediaRecallOnly,
    OUT LONGLONG *pMediaFreeBytes,
    OUT short *pMediaRemoteDataSet
    )

/*++

Implements:

  IHsmWorkItem::GetMediaInfo

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkItem::GetMediaInfo"), OLESTR(""));

    try {

        // Did they give us  valid pointers?
        WsbAssert(0 != pMediaId, E_POINTER);
        WsbAssert(0 != pMediaLastUpdate, E_POINTER);
        WsbAssert(0 != pMediaLastError, E_POINTER);
        WsbAssert(0 != pMediaRecallOnly, E_POINTER);
        WsbAssert(0 != pMediaFreeBytes, E_POINTER);
        WsbAssert(0 != pMediaRemoteDataSet, E_POINTER);
        
        *pMediaId = m_MediaId;
        *pMediaLastUpdate = m_MediaLastUpdate;
        *pMediaLastError = m_MediaLastError;
        *pMediaRecallOnly = m_MediaRecallOnly;
        *pMediaFreeBytes = m_MediaFreeBytes;
        *pMediaRemoteDataSet = m_MediaRemoteDataSet;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkItem::GetMediaInfo"), 
        OLESTR("hr = <%ls>, Id = <%ls>, LastUpdate = <%ls>, LastError = <%ls>, Recall Only = <%ls>, Free Bytes = <%ls>, RemoteDataSet = <%ls>"), 
        WsbHrAsString(hr), WsbPtrToGuidAsString(pMediaId), WsbPtrToFiletimeAsString(FALSE, pMediaLastUpdate),
        WsbPtrToHrAsString(pMediaLastError), WsbPtrToBoolAsString(pMediaRecallOnly),
        WsbPtrToLonglongAsString(pMediaFreeBytes), WsbPtrToShortAsString(pMediaRemoteDataSet));

    return(hr);
}


HRESULT
CHsmWorkItem::GetResult(
    OUT HRESULT *pHr
    )

/*++

Implements:

  IHsmWorkItem::GetResult().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkItem::GetResult"), OLESTR(""));

    try {

        // Did they give us a valid pointer?
        WsbAssert(0 != pHr, E_POINTER);
        *pHr = m_WorkResult;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkItem::GetResult"), OLESTR("hr = <%ls>, Result = <%ls>"), 
            WsbHrAsString(hr), WsbPtrToHrAsString(pHr));

    return(hr);
}

HRESULT
CHsmWorkItem::GetWorkType(
    OUT HSM_WORK_ITEM_TYPE *pWorkType   
    )

/*++

Implements:

  IHsmWorkItem::GetWorkType().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkItem::GetWorkType"), OLESTR(""));

    try {

        // Did they give us a valid pointer?
        WsbAssert(0 != pWorkType, E_POINTER);
        *pWorkType = m_WorkType;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkItem::GetWorkType"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CHsmWorkItem::SetFsaPostIt (
    IN IFsaPostIt  *pFsaPostIt
    )

/*++

Implements:

  IHsmWorkItem::SetFsaPostIt

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkItem::SetFsaPostIt"), OLESTR(""));

    try {

        // Did they give us a valid pointer?
        WsbAssert(0 != pFsaPostIt, E_POINTER);
        m_pFsaPostIt = pFsaPostIt;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkItem::SetFsaPostIt"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CHsmWorkItem::SetFsaResource (
    IN IFsaResource  *pFsaResource
    )

/*++

Implements:

  IHsmWorkItem::SetFsaResource

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkItem::SetFsaResource"), OLESTR(""));

    try {

        // Did they give us a valid pointer?
        WsbAssert(0 != pFsaResource, E_POINTER);
        m_pFsaResource = pFsaResource;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkItem::SetFsaResource"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmWorkItem::SetMediaInfo (
    IN GUID mediaId, 
    IN FILETIME mediaLastUpdate,
    IN HRESULT mediaLastError, 
    IN BOOL mediaRecallOnly,
    IN LONGLONG mediaFreeBytes,
    IN short mediaRemoteDataSet
    )

/*++

Implements:

  IHsmWorkItem::SetMediaInfo

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkItem::SetMediaInfo"), 
        OLESTR("Id = <%ls>, LastUpdate = <%ls>, LastError = <%ls>, Recall Only = <%ls>, Free Bytes = <%ls>, RemoteDataSet = <%d>"), 
        WsbGuidAsString(mediaId), WsbFiletimeAsString(FALSE, mediaLastUpdate),
        WsbHrAsString(mediaLastError), WsbBoolAsString(mediaRecallOnly),
        WsbLonglongAsString(mediaFreeBytes), mediaRemoteDataSet);

    try {
        m_MediaId          = mediaId;
        m_MediaLastUpdate  = mediaLastUpdate;
        m_MediaLastError   = mediaLastError;
        m_MediaRecallOnly  = mediaRecallOnly;
        m_MediaFreeBytes   = mediaFreeBytes;
        m_MediaRemoteDataSet = mediaRemoteDataSet;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkItem::GetMediaInfo"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CHsmWorkItem::SetResult(
    IN HRESULT workResult
    )

/*++

Implements:

  IHsmWorkItem::GetResult().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkItem::SetResult"), OLESTR("Result is <%ls>"), WsbHrAsString(workResult));

    try {
    
        m_WorkResult = workResult;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkItem::GetResult"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CHsmWorkItem::SetWorkType(
    IN HSM_WORK_ITEM_TYPE workType  
    )

/*++

Implements:

  IHsmWorkItem::SetWorkType().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkItem::SetWorkType"), OLESTR(""));

    m_WorkType = workType;

    WsbTraceOut(OLESTR("CHsmWorkItem::SetWorkType"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT CHsmWorkItem::GetClassID
(
    OUT LPCLSID pclsid
    ) 
/*++

Routine Description:

  See IPerist::GetClassID()

Arguments:

  See IPerist::GetClassID()

Return Value:

    See IPerist::GetClassID()

--*/

{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkItem::GetClassID"), OLESTR(""));


    try {
        WsbAssert(0 != pclsid, E_POINTER);

        *pclsid = CLSID_CHsmWorkItem;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkItem::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pclsid));
    return(hr);
}

HRESULT CHsmWorkItem::GetSizeMax
(
    OUT ULARGE_INTEGER* pcbSize
    ) 
/*++

Routine Description:

  See IPersistStream::GetSizeMax().

Arguments:

  See IPersistStream::GetSizeMax().

Return Value:

  See IPersistStream::GetSizeMax().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkItem::GetSizeMax"), OLESTR(""));

    try {
        
        WsbAssert(0 != pcbSize, E_POINTER);

        pcbSize->QuadPart = 0;
        hr = E_NOTIMPL;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkItem::GetSizeMax"), 
        OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), 
        WsbPtrToUliAsString(pcbSize));

    return(hr);
}

HRESULT CHsmWorkItem::Load
(
    IN IStream* /*pStream*/
    ) 
/*++

Routine Description:

  See IPersistStream::Load().

Arguments:

  See IPersistStream::Load().

Return Value:

  See IPersistStream::Load().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkItem::Load"), OLESTR(""));

    try {
        hr = E_NOTIMPL;

    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CHsmWorkItem::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT CHsmWorkItem::Save
(
    IN IStream* pStream, 
    IN BOOL clearDirty
    ) 
/*++

Routine Description:

  See IPersistStream::Save().

Arguments:

  See IPersistStream::Save().

Return Value:

  See IPersistStream::Save().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkItem::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));

    try {
        WsbAssert(0 != pStream, E_POINTER);
        hr = E_NOTIMPL;

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkItem::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CHsmWorkItem::Test
(
    OUT USHORT *pTestsPassed, 
    OUT USHORT *pTestsFailed 
    ) 
/*++

Routine Description:

  See IWsbTestable::Test().

Arguments:

  See IWsbTestable::Test().

Return Value:

  See IWsbTestable::Test().

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkItem::Test"), OLESTR(""));

    *pTestsPassed = *pTestsFailed = 0;
    try {
    
        hr = E_NOTIMPL;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkItem::Test"),   OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\engine\task\hsmreclq.h ===
/*++


Module Name:

    hsmreclq.h

Abstract:

    This header file defines the CHsmRecallQueue object, which is used by the HSM
    Engine to direct work to be performed by the Remote Storage system.

Author:

    Ravisankar Pudipeddi       [ravisp]

Revision History:

--*/


#include "resource.h"       // main symbols
#include "wsb.h"            // Wsb structure definitions
#include "rms.h"            // RMS structure definitions
#include "job.h"            // RMS structure definitions
#include "metalib.h"        // metadata library structure definitions
#include "fsalib.h"         // FSA structure definitions
#include "tsklib.h"         // FSA structure definitions
#include "mvrint.h"         // Datamover interface


#ifndef __HSMRECALLQUEUE__
#define __HSMRECALLQUEUE__
/////////////////////////////////////////////////////////////////////////////
// task

class CHsmRecallQueue :
    public CComObjectRoot,
    public IHsmRecallQueue,
    public IHsmSessionSinkEveryEvent,
    public IHsmSessionSinkEveryState,
    public CComCoClass<CHsmRecallQueue,&CLSID_CHsmRecallQueue>
{
public:
    CHsmRecallQueue() {}
BEGIN_COM_MAP(CHsmRecallQueue)
    COM_INTERFACE_ENTRY(IHsmRecallQueue)
    COM_INTERFACE_ENTRY(IHsmSessionSinkEveryEvent)
    COM_INTERFACE_ENTRY(IHsmSessionSinkEveryState)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID( IDR_CHsmRecallQueue )

// IHsmRecallQueue
public:
    STDMETHOD(FinalConstruct)(void);
    STDMETHOD(FinalRelease)(void);
    STDMETHOD(Add)(IFsaPostIt *pFsaWorkItem, IN GUID *pBagId, IN LONGLONG dataSetStart);
    STDMETHOD(Init)(IUnknown *pServer, IHsmFsaTskMgr *pTskMgr);
    STDMETHOD(Start)( void );
    STDMETHOD(Stop)( void );
    STDMETHOD(ContactOk)( void );

    STDMETHOD(ProcessSessionEvent)(IHsmSession *pSession, HSM_JOB_PHASE phase,
                                    HSM_JOB_EVENT event);
    STDMETHOD(ProcessSessionState)(IHsmSession* pSession, IHsmPhase* pPhase,
                                    OLECHAR* currentPath);
    STDMETHOD(RaisePriority)(HSM_JOB_PHASE jobPhase, IHsmSession *pSession);
    STDMETHOD(Remove)(IHsmRecallItem *pWorkItem);
    STDMETHOD(LowerPriority)(HSM_JOB_PHASE jobPhase, IHsmSession *pSession);
    STDMETHOD(GetMediaId) (OUT GUID *mediaId);
    STDMETHOD(SetMediaId) (IN GUID  *mediaId);
    STDMETHOD(IsEmpty) (	void	);

// IHsmSystemState
    STDMETHOD( ChangeSysState )( HSM_SYSTEM_STATE* pSysState );


// Internal Helper functions
    STDMETHOD(RecallIt)( IHsmRecallItem *pWorkItem );
    STDMETHOD(CheckRms)(void);
    STDMETHOD(CheckSession)(IHsmSession* pSession, IHsmRecallItem *pWorkItem);
    STDMETHOD(MountMedia)(IHsmRecallItem *pWorkItem, GUID mediaToMount, BOOL bShortWait=FALSE );
    STDMETHOD(GetSource)(IFsaPostIt *pFsaWorkItem, OLECHAR **pSourceString);
    STDMETHOD(EndRecallSession)(IHsmRecallItem *pWorkItem, BOOL cancelled);
    STDMETHOD(GetScanItem)(IFsaPostIt *fsaWorkItem, IFsaScanItem** ppIFsaScanItem);
    STDMETHOD(DoWork)(void);
    STDMETHOD(DoFsaWork)(IHsmRecallItem *pWorkItem);
    STDMETHOD(SetState)(HSM_JOB_STATE state, HSM_JOB_PHASE phase, IHsmSession *pSession);
    STDMETHOD(Cancel)(HSM_JOB_PHASE jobPhase, IHsmSession *pSession);
    STDMETHOD(FailJob)(IHsmRecallItem *pWorkItem);
    STDMETHOD(GetMediaParameters)(void);
    STDMETHOD(DismountMedia)( BOOL bNoDelay = FALSE);
    STDMETHOD(ConvertRmsCartridgeType)(LONG rmsCartridgeType,
                                        HSM_JOB_MEDIA_TYPE *pMediaType);
    void (ReportMediaProgress)(HSM_JOB_MEDIA_STATE state, HRESULT status);
    STDMETHOD(MarkWorkItemAsDone)(IHsmSession *pSession, HSM_JOB_PHASE jobPhase);
    STDMETHOD(CheckRegistry)(void);
    STDMETHOD(TranslateRmsMountHr)(HRESULT rmsHr);
    STDMETHOD(UnsetMediaInfo)(void);
    STDMETHOD(FindRecallItemToCancel(IHsmRecallItem *pWorkItem, IHsmRecallItem **pWorkItemToCancel));

    // Data
    // We want the next pointers (to the Hsm Server) to be weak
    // references and **not** add ref the object.  This is so shutting
    // down the server really works.
    IHsmServer                          *m_pServer;
    IWsbCreateLocalObject               *m_pHsmServerCreate;
    IHsmFsaTskMgr                       *m_pTskMgr;

    CComPtr<IRmsServer>                 m_pRmsServer;
    CComPtr<IRmsCartridge>              m_pRmsCartridge;
    CComPtr<IDataMover>                 m_pDataMover;

    //
    // The recall queue..
    //
    CComPtr<IWsbIndexedCollection>      m_pWorkToDo;
    BOOL                                m_TerminateQueue;     // True only if the queue should terminate while
                                                              // there is still work in progress

    // Data mover info
    GUID                                m_MediaId;
    GUID                                m_MountedMedia;
    HSM_JOB_MEDIA_TYPE                  m_MediaType;
    CWsbStringPtr                       m_MediaName;
    CWsbStringPtr                       m_MediaBarCode;
    LONGLONG                            m_MediaFreeSpace;
    LONGLONG                            m_MediaCapacity;
    BOOL                                m_MediaReadOnly;
    GUID                                m_HsmId;
    GUID                                m_RmsMediaSetId;
    CWsbBstrPtr                         m_RmsMediaSetName;
    HSM_WORK_QUEUE_TYPE                 m_QueueType;
    FILETIME                            m_MediaUpdate;

    // Session reporting information
    HSM_JOB_PRIORITY                    m_JobPriority;

    HANDLE                              m_WorkerThread;
    CWsbStringPtr                       m_CurrentPath;
    CWsbStringPtr                       m_MediaBaseName;


    // Job abort on errors parameters
    ULONG                               m_JobAbortMaxConsecutiveErrors;
    ULONG                               m_JobAbortMaxTotalErrors;
    ULONG                               m_JobConsecutiveErrors;
    ULONG                               m_JobTotalErrors;
    ULONG                               m_JobAbortSysDiskSpace;
    LONGLONG                            m_CurrentSeekOffset;
};

#endif // __HSMRECALLQUEUE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\engine\task\hsmrecli.cpp ===
/*++


Module Name:

    hsmrecli.cpp

Abstract:

    This class represents an HSM recall queue work item - a unit of work
    that is performed by the HSM engine for recalls

Author:

    Ravisankar Pudipeddi [ravisp]

Revision History:

--*/

#include "stdafx.h"

#define WSB_TRACE_IS        WSB_TRACE_BIT_HSMTSKMGR
#include "wsb.h"
#include "fsa.h"
#include "task.h"
#include "hsmrecli.h"

static USHORT iCount = 0;

HRESULT
CHsmRecallItem::CompareTo(
    IN IUnknown* pUnknown,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbCollectable::CompareTo().

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IHsmRecallItem>   pWorkItem;

    WsbTraceIn(OLESTR("CHsmRecallItem::CompareTo"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pUnknown, E_POINTER);

        // We need the IHsmRecallItem interface to get the value of the object.
        WsbAffirmHr(pUnknown->QueryInterface(IID_IHsmRecallItem, (void**) &pWorkItem));

        // Compare the items
        hr = CompareToIHsmRecallItem(pWorkItem, pResult);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRecallItem::CompareTo"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CHsmRecallItem::CompareToIHsmRecallItem(
    IN IHsmRecallItem* pWorkItem,
    OUT SHORT* pResult
    )

/*++

Implements:

  IHsmRecallItem::CompareToIHsmRecallItem().

--*/
{
    HRESULT                 hr = S_OK;
    GUID                    l_Id;           // Type of work to do

    WsbTraceIn(OLESTR("CHsmRecallItem::CompareToIHsmRecallItem"), OLESTR(""));

    try {
        //
        // Did they give us a valid item to compare to?
        //
        WsbAssert(0 != pWorkItem, E_POINTER);

        //
        // Get the ID
        //
        WsbAffirmHr(pWorkItem->GetId(&l_Id));

        if (l_Id != m_MyId){
            hr = S_FALSE;
        }
        // If they asked for the relative value back, then return it to them.
        if (pResult != NULL) {
            if (S_OK == hr)  {
                *pResult = 0;
            } else {
                *pResult = 1;
            }
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRecallItem::CompareToIHsmRecallItem"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CHsmRecallItem::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallItem::FinalConstruct"), OLESTR(""));
    try {

        WsbAffirmHr(CWsbObject::FinalConstruct());
        //
        // The comparison for database searches is based on the
        // ID of this object (m_MyId).
        //
        WsbAffirmHr(CoCreateGuid(&m_MyId));
        m_WorkType = HSM_WORK_ITEM_NONE;
        m_MediaId = GUID_NULL;
        m_MediaLastUpdate =  WsbLLtoFT(0);
        m_MediaLastError = S_OK;
        m_MediaRecallOnly = FALSE;
        m_MediaFreeBytes = 0;
        m_JobState    = HSM_JOB_STATE_IDLE;
        m_JobPhase    = HSM_JOB_PHASE_MOVE_ACTION;
        m_StateCookie = 0;
        m_EventCookie = 0;

    } WsbCatch(hr);

    iCount++;
    WsbTraceOut(OLESTR("CHsmRecallItem::FinalConstruct"), OLESTR("hr = <%ls>, Count is <%d>"),
        WsbHrAsString(hr), iCount);
    return(hr);
}


void
CHsmRecallItem::FinalRelease(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalRelease().

--*/
{

    WsbTraceIn(OLESTR("CHsmRecallItem::FinalRelease"), OLESTR(""));
    // Let the parent class do his thing.
    CWsbObject::FinalRelease();

    iCount--;
    WsbTraceOut(OLESTR("CHsmRecallItem::FinalRelease"), OLESTR("Count is <%d>"), iCount);

}


HRESULT
CHsmRecallItem::GetFsaPostIt (
    OUT IFsaPostIt  **ppFsaPostIt
    )

/*++

Implements:

  IHsmRecallItem::GetFsaPostIt

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallItem::GetFsaPostIt"), OLESTR(""));

    try {

        // Did they give us a valid pointer?
        WsbAssert(0 != ppFsaPostIt, E_POINTER);
        *ppFsaPostIt = m_pFsaPostIt;
        if (0 != *ppFsaPostIt)  {
            (*ppFsaPostIt)->AddRef();
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRecallItem::GetFsaPostIt"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CHsmRecallItem::GetFsaResource (
    OUT IFsaResource  **ppFsaResource
    )

/*++

Implements:

  IHsmRecallItem::GetFsaResource

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallItem::GetFsaResource"), OLESTR(""));

    try {

        // Did they give us a valid pointer?
        WsbAssert(0 != ppFsaResource, E_POINTER);
        *ppFsaResource = m_pFsaResource;
        if (0 != *ppFsaResource)  {
            (*ppFsaResource)->AddRef();
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRecallItem::GetFsaResource"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CHsmRecallItem::GetId(
    OUT GUID *pId
    )

/*++

Implements:

  IHsmRecallItem::GetId().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallItem::GetId"), OLESTR(""));

    try {

        // Did they give us a valid pointer?
        WsbAssert(0 != pId, E_POINTER);
        *pId = m_MyId;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRecallItem::GetId"), OLESTR("hr = <%ls>, Id = <%ls>"),
            WsbHrAsString(hr), WsbPtrToGuidAsString(pId));

    return(hr);
}

HRESULT
CHsmRecallItem::GetMediaInfo (
    OUT GUID *pMediaId,
    OUT FILETIME *pMediaLastUpdate,
    OUT HRESULT *pMediaLastError,
    OUT BOOL *pMediaRecallOnly,
    OUT LONGLONG *pMediaFreeBytes,
    OUT short *pMediaRemoteDataSet
    )

/*++

Implements:

  IHsmRecallItem::GetMediaInfo

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallItem::GetMediaInfo"), OLESTR(""));

    try {

        // Did they give us  valid pointers?
        WsbAssert(0 != pMediaId, E_POINTER);
        WsbAssert(0 != pMediaLastUpdate, E_POINTER);
        WsbAssert(0 != pMediaLastError, E_POINTER);
        WsbAssert(0 != pMediaRecallOnly, E_POINTER);
        WsbAssert(0 != pMediaFreeBytes, E_POINTER);
        WsbAssert(0 != pMediaRemoteDataSet, E_POINTER);

        *pMediaId = m_MediaId;
        *pMediaLastUpdate = m_MediaLastUpdate;
        *pMediaLastError = m_MediaLastError;
        *pMediaRecallOnly = m_MediaRecallOnly;
        *pMediaFreeBytes = m_MediaFreeBytes;
        *pMediaRemoteDataSet = m_MediaRemoteDataSet;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRecallItem::GetMediaInfo"),
        OLESTR("hr = <%ls>, Id = <%ls>, LastUpdate = <%ls>, LastError = <%ls>, Recall Only = <%ls>, Free Bytes = <%ls>, RemoteDataSet = <%ls>"),
        WsbHrAsString(hr), WsbPtrToGuidAsString(pMediaId), WsbPtrToFiletimeAsString(FALSE, pMediaLastUpdate),
        WsbPtrToHrAsString(pMediaLastError), WsbPtrToBoolAsString(pMediaRecallOnly),
        WsbPtrToLonglongAsString(pMediaFreeBytes), WsbPtrToShortAsString(pMediaRemoteDataSet));

    return(hr);
}


HRESULT
CHsmRecallItem::GetResult(
    OUT HRESULT *pHr
    )

/*++

Implements:

  IHsmRecallItem::GetResult().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallItem::GetResult"), OLESTR(""));

    try {

        // Did they give us a valid pointer?
        WsbAssert(0 != pHr, E_POINTER);
        *pHr = m_WorkResult;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRecallItem::GetResult"), OLESTR("hr = <%ls>, Result = <%ls>"),
            WsbHrAsString(hr), WsbPtrToHrAsString(pHr));

    return(hr);
}

HRESULT
CHsmRecallItem::GetWorkType(
    OUT HSM_WORK_ITEM_TYPE *pWorkType
    )

/*++

Implements:

  IHsmRecallItem::GetWorkType().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallItem::GetWorkType"), OLESTR(""));

    try {

        // Did they give us a valid pointer?
        WsbAssert(0 != pWorkType, E_POINTER);
        *pWorkType = m_WorkType;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRecallItem::GetWorkType"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmRecallItem::GetEventCookie(
    OUT DWORD *pEventCookie
    )

/*++

Implements:

  IHsmRecallItem::GetEventCookie().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallItem::GetEventCookie"), OLESTR(""));

    try {

        // Did they give us a valid pointer?
        WsbAssert(0 != pEventCookie, E_POINTER);
        *pEventCookie = m_EventCookie;

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CHsmRecallItem::GetEventCookie"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmRecallItem::GetStateCookie(
    OUT DWORD *pStateCookie
    )

/*++

Implements:

  IHsmRecallItem::GetStateCookie().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallItem::GetStateCookie"), OLESTR(""));
    try {

        // Did they give us a valid pointer?
        WsbAssert(0 != pStateCookie, E_POINTER);
        *pStateCookie = m_StateCookie;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRecallItem::GetStateCookie"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmRecallItem::GetJobState(
    OUT HSM_JOB_STATE *pJobState
    )

/*++

Implements:

  IHsmRecallItem::GetJobState()

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallItem::GetJobState"), OLESTR(""));


    try {

        // Did they give us a valid pointer?
        WsbAssert(0 != pJobState, E_POINTER);
        *pJobState = m_JobState;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRecallItem::GetJobState"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmRecallItem::GetJobPhase(
    OUT HSM_JOB_PHASE *pJobPhase
    )

/*++

Implements:

  IHsmRecallItem::GetJobPhase

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallItem::GetJobPhase"), OLESTR(""));

    try {

        // Did they give us a valid pointer?
        WsbAssert(0 != pJobPhase, E_POINTER);
        *pJobPhase = m_JobPhase;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRecallItem::GetJobPhase"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmRecallItem::GetSeekOffset(
    OUT LONGLONG *pSeekOffset
    )

/*++

Implements:

  IHsmRecallItem::GetSeekOffset

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallItem::GetSeekOffset"), OLESTR(""));

    try {

        // Did they give us a valid pointer?
        WsbAssert(0 != pSeekOffset, E_POINTER);
        *pSeekOffset = m_SeekOffset;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRecallItem::GetSeekOffset"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmRecallItem::GetBagId(
    OUT GUID *pBagId
    )

/*++

Implements:

  IHsmRecallItem::GetBagId

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallItem::GetBagId"), OLESTR(""));

    try {

        // Did they give us a valid pointer?
        WsbAssert(0 != pBagId, E_POINTER);
        *pBagId = m_BagId;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRecallItem::GetBagId"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmRecallItem::GetDataSetStart(
    OUT LONGLONG *pDataSetStart
    )

/*++

Implements:

  IHsmRecallItem::GetDataSetStart

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallItem::GetDataSetStart"), OLESTR(""));

    try {

        // Did they give us a valid pointer?
        WsbAssert(0 != pDataSetStart,E_POINTER);
        *pDataSetStart =  m_DataSetStart;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRecallItem::GetDataSetStart"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmRecallItem::SetFsaPostIt (
    IN IFsaPostIt  *pFsaPostIt
    )

/*++

Implements:

  IHsmRecallItem::SetFsaPostIt

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallItem::SetFsaPostIt"), OLESTR(""));

    try {

        // Did they give us a valid pointer?
        WsbAssert(0 != pFsaPostIt, E_POINTER);
        m_pFsaPostIt = pFsaPostIt;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRecallItem::SetFsaPostIt"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CHsmRecallItem::SetFsaResource (
    IN IFsaResource  *pFsaResource
    )

/*++

Implements:

  IHsmRecallItem::SetFsaResource

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallItem::SetFsaResource"), OLESTR(""));

    try {

        // Did they give us a valid pointer?
        WsbAssert(0 != pFsaResource, E_POINTER);
        m_pFsaResource = pFsaResource;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRecallItem::SetFsaResource"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmRecallItem::SetMediaInfo (
    IN GUID mediaId,
    IN FILETIME mediaLastUpdate,
    IN HRESULT mediaLastError,
    IN BOOL mediaRecallOnly,
    IN LONGLONG mediaFreeBytes,
    IN short mediaRemoteDataSet
    )

/*++

Implements:

  IHsmRecallItem::SetMediaInfo

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallItem::SetMediaInfo"),
        OLESTR("Id = <%ls>, LastUpdate = <%ls>, LastError = <%ls>, Recall Only = <%ls>, Free Bytes = <%ls>, RemoteDataSet = <%d>"),
        WsbGuidAsString(mediaId), WsbFiletimeAsString(FALSE, mediaLastUpdate),
        WsbHrAsString(mediaLastError), WsbBoolAsString(mediaRecallOnly),
        WsbLonglongAsString(mediaFreeBytes), mediaRemoteDataSet);

    try {
        m_MediaId          = mediaId;
        m_MediaLastUpdate  = mediaLastUpdate;
        m_MediaLastError   = mediaLastError;
        m_MediaRecallOnly  = mediaRecallOnly;
        m_MediaFreeBytes   = mediaFreeBytes;
        m_MediaRemoteDataSet = mediaRemoteDataSet;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRecallItem::GetMediaInfo"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CHsmRecallItem::SetResult(
    IN HRESULT workResult
    )

/*++

Implements:

  IHsmRecallItem::GetResult().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallItem::SetResult"), OLESTR("Result is <%ls>"), WsbHrAsString(workResult));

    try {

        m_WorkResult = workResult;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRecallItem::GetResult"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmRecallItem::SetWorkType(
    IN HSM_WORK_ITEM_TYPE workType
    )

/*++

Implements:

  IHsmRecallItem::SetWorkType().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallItem::SetWorkType"), OLESTR(""));

    m_WorkType = workType;

    WsbTraceOut(OLESTR("CHsmRecallItem::SetWorkType"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmRecallItem::SetEventCookie(
    IN DWORD eventCookie
    )

/*++

Implements:

  IHsmRecallItem::SetEventCookie().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallItem::SetEventCookie"), OLESTR(""));

    m_EventCookie = eventCookie;

    WsbTraceOut(OLESTR("CHsmRecallItem::SetEventCookie"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmRecallItem::SetStateCookie(
    IN DWORD stateCookie
    )

/*++

Implements:

  IHsmRecallItem::SetStateCookie().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallItem::SetStateCookie"), OLESTR(""));

    m_StateCookie = stateCookie;

    WsbTraceOut(OLESTR("CHsmRecallItem::SetStateCookie"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmRecallItem::SetJobState(
    IN HSM_JOB_STATE jobState
    )

/*++

Implements:

  IHsmRecallItem::SetJobState()

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallItem::SetJobState"), OLESTR(""));

    m_JobState = jobState;

    WsbTraceOut(OLESTR("CHsmRecallItem::SetJobState"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmRecallItem::SetJobPhase(
    IN HSM_JOB_PHASE jobPhase
    )

/*++

Implements:

  IHsmRecallItem::SetJobPhase

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallItem::SetJobPhase"), OLESTR(""));

    m_JobPhase = jobPhase;

    WsbTraceOut(OLESTR("CHsmRecallItem::SetJobPhase"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmRecallItem::SetSeekOffset(
    IN LONGLONG seekOffset
    )

/*++

Implements:

  IHsmRecallItem::SetSeekOffset

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallItem::SetSeekOffset"), OLESTR(""));

    m_SeekOffset = seekOffset;

    WsbTraceOut(OLESTR("CHsmRecallItem::SetSeekOffset"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmRecallItem::SetBagId(
    IN GUID * pBagId
    )

/*++

Implements:

  IHsmRecallItem::SetBagId

--*/
{
    HRESULT         hr = S_OK;


    WsbTraceIn(OLESTR("CHsmRecallItem::SetBagId"), OLESTR(""));

    m_BagId = *pBagId;

    WsbTraceOut(OLESTR("CHsmRecallItem::SetBagId"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmRecallItem::SetDataSetStart(
    IN LONGLONG dataSetStart
    )

/*++

Implements:

  IHsmRecallItem::SetDataSetStart

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallItem::SetDataSetStart"), OLESTR(""));

    m_DataSetStart = dataSetStart;

    WsbTraceOut(OLESTR("CHsmRecallItem::SetDataSetStart"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT CHsmRecallItem::GetClassID(
    OUT LPCLSID pclsid
    )
/*++

Routine Description:

  See IPerist::GetClassID()

Arguments:

  See IPerist::GetClassID()

Return Value:

    See IPerist::GetClassID()

--*/

{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallItem::GetClassID"), OLESTR(""));


    try {
        WsbAssert(0 != pclsid, E_POINTER);

        *pclsid = CLSID_CHsmRecallItem;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRecallItem::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pclsid));
    return(hr);
}

HRESULT CHsmRecallItem::GetSizeMax
(
    OUT ULARGE_INTEGER* pcbSize
    )
/*++

Routine Description:

  See IPersistStream::GetSizeMax().

Arguments:

  See IPersistStream::GetSizeMax().

Return Value:

  See IPersistStream::GetSizeMax().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallItem::GetSizeMax"), OLESTR(""));

    try {

        WsbAssert(0 != pcbSize, E_POINTER);

        pcbSize->QuadPart = 0;
        hr = E_NOTIMPL;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRecallItem::GetSizeMax"),
        OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr),
        WsbPtrToUliAsString(pcbSize));

    return(hr);
}

HRESULT CHsmRecallItem::Load
(
    IN IStream* /*pStream*/
    )
/*++

Routine Description:

  See IPersistStream::Load().

Arguments:

  See IPersistStream::Load().

Return Value:

  See IPersistStream::Load().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallItem::Load"), OLESTR(""));

    try {
        hr = E_NOTIMPL;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRecallItem::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT CHsmRecallItem::Save
(
    IN IStream* pStream,
    IN BOOL clearDirty
    )
/*++

Routine Description:

  See IPersistStream::Save().

Arguments:

  See IPersistStream::Save().

Return Value:

  See IPersistStream::Save().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallItem::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));

    try {
        WsbAssert(0 != pStream, E_POINTER);
        hr = E_NOTIMPL;

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRecallItem::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmRecallItem::Test
(
    OUT USHORT *pTestsPassed,
    OUT USHORT *pTestsFailed
    )
/*++

Routine Description:

  See IWsbTestable::Test().

Arguments:

  See IWsbTestable::Test().

Return Value:

  See IWsbTestable::Test().

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRecallItem::Test"), OLESTR(""));

    *pTestsPassed = *pTestsFailed = 0;
    try {

        hr = E_NOTIMPL;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRecallItem::Test"),   OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\engine\task\hsmworkq.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    hsmWorkQ.h

Abstract:

    This header file defines the CHsmWorkQueue object, which is used by the HSM
    Engine to direct work to be performed by the Remote Storage system.

Author:

    Cat Brant       [cbrant]    24-Jan-1997

Revision History:

--*/


#include "resource.h"       // main symbols
#include "wsb.h"            // Wsb structure definitions
#include "rms.h"            // RMS structure definitions
#include "job.h"            // RMS structure definitions
#include "metalib.h"        // metadata library structure definitions
#include "fsalib.h"         // FSA structure definitions
#include "tsklib.h"         // FSA structure definitions
#include "mvrint.h"         // Datamover interface

 
#ifndef __HSMWORKQUEUE__
#define __HSMWORKQUEUE__
/////////////////////////////////////////////////////////////////////////////
// task

// Error reporting flags
#define     QUEUE_REPORT_PASS_QUOTA_LIMIT_FLAG       0x00000001

class CHsmWorkQueue : 
    public CComObjectRoot,
    public IHsmWorkQueue,
    public IHsmSessionSinkEveryEvent,
    public IHsmSessionSinkEveryState,
    public CComCoClass<CHsmWorkQueue,&CLSID_CHsmWorkQueue>
{
public:
    CHsmWorkQueue() {}
BEGIN_COM_MAP(CHsmWorkQueue)
    COM_INTERFACE_ENTRY(IHsmWorkQueue)
    COM_INTERFACE_ENTRY(IHsmSessionSinkEveryEvent)
    COM_INTERFACE_ENTRY(IHsmSessionSinkEveryState)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID( IDR_CHsmWorkQueue )

// IHsmWorkQueue
public:
    STDMETHOD(FinalConstruct)(void);
    STDMETHOD(FinalRelease)(void);
    STDMETHOD(Add)(IFsaPostIt *pFsaWorkItem);
    STDMETHOD(Init)(IUnknown *pServer, IHsmSession *pSession, IHsmFsaTskMgr *pTskMgr, 
                    HSM_WORK_QUEUE_TYPE type);
    STDMETHOD(Start)( void );
    STDMETHOD(Stop)( void );
    STDMETHOD(ContactOk)( void );
    STDMETHOD(GetCurrentSessionId)(GUID *pSessionId);
    STDMETHOD(GetNumWorkItems)(ULONG *pNumWorkItems);

    STDMETHOD(ProcessSessionEvent)(IHsmSession *pSession, HSM_JOB_PHASE phase, 
                                    HSM_JOB_EVENT event);
    STDMETHOD(ProcessSessionState)(IHsmSession* pSession, IHsmPhase* pPhase, 
                                    OLECHAR* currentPath);
    STDMETHOD(RaisePriority)(void);
    STDMETHOD(Remove)(IHsmWorkItem *pWorkItem);
    STDMETHOD(LowerPriority)(void);

// IHsmSystemState
    STDMETHOD( ChangeSysState )( HSM_SYSTEM_STATE* pSysState );

// Internal Helper functions
    STDMETHOD(PremigrateIt)( IFsaPostIt *pFsaWorkItem );
    STDMETHOD(RecallIt)( IFsaPostIt *pFsaWorkItem );
    STDMETHOD(validateIt)(IFsaPostIt *pFsaWorkItem );
    STDMETHOD(CheckForChanges)(IFsaPostIt *pFsaWorkItem);
    STDMETHOD(CheckForDiskSpace)(void);

    STDMETHOD(CheckRms)(void);
    STDMETHOD(CheckSession)(IHsmSession* pSessionUnknown);
    STDMETHOD(StartNewBag)(void);
    STDMETHOD(StartNewMedia)(IFsaPostIt *pFsaWorkItem);
    STDMETHOD(StartNewSession)(void);
    STDMETHOD(UpdateBagInfo)(IHsmWorkItem *pWorkItem );
    STDMETHOD(CompleteBag)( void );
    STDMETHOD(UpdateSegmentInfo)(IHsmWorkItem *pWorkItem );
    STDMETHOD(UpdateMediaInfo)(IHsmWorkItem *pWorkItem );
    STDMETHOD(UpdateMetaData)(IHsmWorkItem *pWorkItem );
    STDMETHOD(GetMediaSet)(IFsaPostIt *pFsaWorkItem );
    STDMETHOD(FindMigrateMediaToUse)(IFsaPostIt *pFsaWorkItem, GUID *pMediaToUse, GUID *pFirstSideToUse, BOOL *pMediaChanged, LONGLONG *pRequiredSize);
    STDMETHOD(FindRecallMediaToUse)(IFsaPostIt *pFsaWorkItem, GUID *pMediaToUse, BOOL *pMediaChanged);
    STDMETHOD(MountMedia)(IFsaPostIt *pFsaWorkItem, GUID mediaToMount, GUID firstSide = GUID_NULL, 
                            BOOL bShortWait = FALSE, BOOL bSerialize = FALSE, LONGLONG llFreeSpace = 0);
    STDMETHOD(MarkMediaFull)(IFsaPostIt *pFsaWorkItem, GUID mediaToMark );
    STDMETHOD(MarkMediaBad)(IFsaPostIt *pFsaWorkItem, GUID mediaToMark, HRESULT lastError);
    STDMETHOD(GetSource)(IFsaPostIt *pFsaWorkItem, OLECHAR **pSourceString);
    STDMETHOD(EndSessions)(BOOL done, BOOL bNoDelay);
    STDMETHOD(GetScanItem)(IFsaPostIt *fsaWorkItem, IFsaScanItem** ppIFsaScanItem);
    STDMETHOD(DoWork)(void);
    STDMETHOD(DoFsaWork)(IHsmWorkItem *pWorkItem);
    STDMETHOD(SetState)(HSM_JOB_STATE state);
    STDMETHOD(Pause)(void);
    STDMETHOD(Resume)(void);
    STDMETHOD(Cancel)(void);
    STDMETHOD(FailJob)(void);
    STDMETHOD(PauseScanner)(void);
    STDMETHOD(ResumeScanner)(void);
    STDMETHOD(BuildMediaName)(OLECHAR **pMediaName);
    STDMETHOD(GetMediaParameters)(LONGLONG defaultFreeSpace = -1);
    STDMETHOD(DismountMedia)(BOOL bNoDelay = FALSE);
    STDMETHOD(ConvertRmsCartridgeType)(LONG rmsCartridgeType, 
                                        HSM_JOB_MEDIA_TYPE *pMediaType);
    void (ReportMediaProgress)(HSM_JOB_MEDIA_STATE state, HRESULT status);
    STDMETHOD(MarkQueueAsDone)( void );
    STDMETHOD(CopyToWaitingQueue)( IHsmWorkItem *pWorkItem );
    STDMETHOD(CompleteWorkItem)( IHsmWorkItem *pWorkItem );
    STDMETHOD(TimeToCommit)( void );
    STDMETHOD(TimeToCommit)( LONGLONG numFiles, LONGLONG amountOfData );
    STDMETHOD(CommitWork)(void);
    STDMETHOD(CheckMigrateMinimums)(void);
    STDMETHOD(CheckRegistry)(void);
    STDMETHOD(TranslateRmsMountHr)(HRESULT rmsHr);
    STDMETHOD(StoreDatabasesOnMedia)( void );
    STDMETHOD(StoreDataWithRetry)(BSTR localName, ULARGE_INTEGER localDataStart,
        ULARGE_INTEGER localDataSize, DWORD flags, ULARGE_INTEGER *pRemoteDataSetStart,
        ULARGE_INTEGER *pRemoteFileStart, ULARGE_INTEGER *pRemoteFileSize,
        ULARGE_INTEGER *pRemoteDataStart, ULARGE_INTEGER *pRemoteDataSize,
        DWORD *pRemoteVerificationType, ULARGE_INTEGER *pRemoteVerificationData,
        DWORD *pDatastreamCRCType, ULARGE_INTEGER *pDatastreamCRC, ULARGE_INTEGER *pUsn,
        BOOL *bFullMessage);
    STDMETHOD(ShouldJobContinue)(HRESULT problemHr);
    STDMETHOD(UnsetMediaInfo)(void);
    STDMETHOD(UpdateMediaFreeSpace)(void);
    STDMETHOD(GetMediaFreeSpace)(LONGLONG *pFreeSpace);

// Data
    // We want the next pointers (to the Hsm Server) to be weak
    // references and **not** add ref the object.  This is so shutting
    // down the server really works.
    IHsmServer                          *m_pServer;
    IWsbCreateLocalObject               *m_pHsmServerCreate;
    IHsmFsaTskMgr                       *m_pTskMgr;
    
    CComPtr<IFsaResource>               m_pFsaResource;
    CComPtr<IHsmSession>                m_pSession;
    CComPtr<IRmsServer>                 m_pRmsServer;
    CComPtr<IRmsCartridge>              m_pRmsCartridge;
    CComPtr<IDataMover>                 m_pDataMover;

    // Databases 
    CComPtr<IWsbDb>                     m_pSegmentDb;
    CComPtr<IWsbDbSession>              m_pDbWorkSession;
    CComPtr<IWsbIndexedCollection>      m_pStoragePools;
    CComPtr<IWsbIndexedCollection>      m_pWorkToDo;
    CComPtr<IWsbIndexedCollection>      m_pWorkToCommit;

    // Data mover info
    GUID                                m_BagId;
    GUID                                m_MediaId;
    GUID                                m_MountedMedia;
    HSM_JOB_MEDIA_TYPE                  m_MediaType;
    CWsbStringPtr                       m_MediaName;
    CWsbStringPtr                       m_MediaBarCode;
    LONGLONG                            m_MediaFreeSpace;
    LONGLONG                            m_MediaCapacity;
    BOOL                                m_MediaReadOnly;
    GUID                                m_HsmId;
    ULARGE_INTEGER                      m_RemoteDataSetStart;
    GUID                                m_RmsMediaSetId;
    CWsbBstrPtr                         m_RmsMediaSetName;
    SHORT                               m_RemoteDataSet;
    FSA_REQUEST_ACTION                  m_RequestAction;
    HSM_WORK_QUEUE_TYPE                 m_QueueType;
    HRESULT                             m_BadMedia;
    FILETIME                            m_MediaUpdate;
    HRESULT                             m_BeginSessionHr;

    // Session reporting information
    DWORD                               m_StateCookie;
    DWORD                               m_EventCookie;
    
    HSM_JOB_PRIORITY                    m_JobPriority;
    HSM_JOB_ACTION                      m_JobAction;
    HSM_JOB_STATE                       m_JobState;
    HSM_JOB_PHASE                       m_JobPhase;

    HANDLE                              m_WorkerThread;
    BOOL                                m_TerminateQueue;     // True only if the queue should terminate while
                                                              // there is still work in progress
    CWsbStringPtr                       m_CurrentPath;
    CWsbStringPtr                       m_MediaBaseName;

    // Minimum migrate parameters
    ULONG                               m_MinBytesToMigrate;
    ULONG                               m_MinFilesToMigrate;

    // Commit parameters
    //  Force a commit after writing this many bytes:
    ULONG                               m_MaxBytesBeforeCommit;
    //  Don't commit unless we've written at least this many bytes:
    ULONG                               m_MinBytesBeforeCommit;
    //  Force a commit after writing this many files IF also m_MinBytesBeforeCommit:
    ULONG                               m_FilesBeforeCommit;
    //  Force a commit if free bytes on media is less than this IF also m_MinBytesBeforeCommit:
    ULONG                               m_FreeMediaBytesAtEndOfMedia;

    LONGLONG                            m_DataCountBeforeCommit;
    LONGLONG                            m_FilesCountBeforeCommit;

    BOOL                                m_StoreDatabasesInBags;

    // Pause/Resume parameters  
    ULONG                               m_QueueItemsToPause;
    ULONG                               m_QueueItemsToResume;
    BOOL                                m_ScannerPaused;

    // Job abort on errors parameters
    ULONG                               m_JobAbortMaxConsecutiveErrors;
    ULONG                               m_JobAbortMaxTotalErrors;
    ULONG                               m_JobConsecutiveErrors;
    ULONG                               m_JobTotalErrors;
    ULONG                               m_JobAbortSysDiskSpace;

    // Media id parameters
    LONG                                m_mediaCount;
    BOOL                                m_ScratchFailed;

    // Full media watermark parameters:
    //  Stop storing data after reaching this percent of free space
    ULONG                               m_MinFreeSpaceInFullMedia;
    //  Mark media as full after reaching this percent of free space
    ULONG                               m_MaxFreeSpaceInFullMedia;

    // Job reporting flags
    ULONG                               m_uErrorReportFlags;
};

#endif // __HSMWORKQUEUE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\engine\task\hsmworki.h ===
#ifndef _HSMWORKI_
#define _HSMWORKI_

/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    HSMWORKI.H

Abstract:

    This class represents an HSM work item - a unit of work
    that is performed by the HSM engine

Author:

    Cat Brant   [cbrant]   5-May-1997

Revision History:

--*/

#include "resource.h"       // main symbols

#include "job.h"
#include "task.h"

/*++

Class Name:
    
    CHsmWorkItem

Class Description:


--*/


class CHsmWorkItem : 
    public CWsbObject,
    public IHsmWorkItem,
    public CComCoClass<CHsmWorkItem,&CLSID_CHsmWorkItem>
{
public:
    CHsmWorkItem() {}
BEGIN_COM_MAP(CHsmWorkItem)
    COM_INTERFACE_ENTRY(IHsmWorkItem)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID( IDR_CHsmWorkItem )

// CWsbCollectable
public:
    STDMETHOD(FinalConstruct)(void);
    void FinalRelease(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IUnknown* pUnknown, SHORT* pResult);

// IWsbTestable
public:
    STDMETHOD(Test)(USHORT *pTestsPassed, USHORT* pTestsFailed);
    
// IHsmWorkItem
public:
    STDMETHOD(CompareToIHsmWorkItem)(IHsmWorkItem* pWorkItem, SHORT* pResult);

    STDMETHOD(GetFsaPostIt)(IFsaPostIt  **ppFsaPostIt);
    STDMETHOD(GetFsaResource)(IFsaResource **ppFsaResource);
    STDMETHOD(GetId)(GUID *pId);
    STDMETHOD(GetMediaInfo)(GUID *pMediaId, FILETIME *pMediaLastUpdate,
                            HRESULT *pMediaLastError, BOOL *pMediaRecallOnly,
                            LONGLONG *pMediaFreeBytes, short *pMediaRemoteDataSet);
    STDMETHOD(GetResult)(HRESULT  *pHr);
    STDMETHOD(GetWorkType)(HSM_WORK_ITEM_TYPE *pWorkType);

    STDMETHOD(SetFsaPostIt)(IFsaPostIt  *pFsaPostIt);
    STDMETHOD(SetFsaResource)(IFsaResource *pFsaResource);
    STDMETHOD(SetMediaInfo)(GUID mediaId, FILETIME mediaLastUpdate,
                            HRESULT mediaLastError, BOOL mediaRecallOnly,
                            LONGLONG mediaFreeBytes, short mediaRemoteDataSet);
    STDMETHOD(SetResult)(HRESULT  hr);
    STDMETHOD(SetWorkType)(HSM_WORK_ITEM_TYPE workType);

protected:
    HSM_WORK_ITEM_TYPE      m_WorkType;         // Type of work to do
    CComPtr<IFsaPostIt>     m_pFsaPostIt;       // FSA work to do
    HRESULT                 m_WorkResult;       // Result of premigrate
    CComPtr<IFsaResource>   m_pFsaResource;     // Resource that had work

// Information about media containing the data - premigrates only
    GUID                    m_MyId;                 // Identifier for database searches
    GUID                    m_MediaId;              // HSM Engine Media ID
    FILETIME                m_MediaLastUpdate;      // Last update of copy
    HRESULT                 m_MediaLastError;       // S_OK or the last exception 
                                                    // ..encountered when accessing
                                                    // ..the media
    BOOL                    m_MediaRecallOnly;      // True if no more data is to
                                                    // ..be premigrated to the media
                                                    // ..Set by internal operations, 
                                                    // ..may not be changed externally
    LONGLONG                m_MediaFreeBytes;       // Real free space on media
    SHORT                   m_MediaRemoteDataSet;   // Next remote data set
};

#endif  // _HSMWORKI_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\engine\task\hsmworkq.cpp ===
/*++

Copyright (c) 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    hsmWorkQ.cpp

Abstract:

    This class represents the HSM task manager

Author:

    Cat Brant   [cbrant]   6-Dec-1996

Revision History:

--*/

#include "stdafx.h"

#define WSB_TRACE_IS        WSB_TRACE_BIT_HSMTSKMGR
static USHORT icountWorkq = 0;

#include "fsa.h"
#include "rms.h"
#include "metadef.h"
#include "jobint.h"
#include "hsmconn.h"
#include "wsb.h"
#include "hsmeng.h"
#include "mover.h"
#include "hsmWorkQ.h"

#include "engine.h"
#include "task.h"
#include "tskmgr.h"
#include "segdb.h"

#define HSM_STORAGE_OVERHEAD        5000

#define MIN_FREE_SPACE_IN_FULL_MEDIA_DEFAULT    4
#define MAX_FREE_SPACE_IN_FULL_MEDIA_DEFAULT    5

#define STRINGIZE(_str) (OLESTR( #_str ))
#define RETURN_STRINGIZED_CASE(_case) \
case _case:                           \
    return ( STRINGIZE( _case ) );

// Local prototypes
DWORD HsmWorkQueueThread(void *pVoid);
static const OLECHAR * JobStateAsString (HSM_JOB_STATE state);




static const OLECHAR *
JobStateAsString (
    IN  HSM_JOB_STATE  state
    )
/*++

Routine Description:

    Gives back a static string representing the connection state.

Arguments:

    state - the state to return a string for.

Return Value:

    NULL - invalid state passed in.

    Otherwise, a valid char *.

--*/

{
    //
    // Do the Switch
    //

    switch ( state ) {

    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_ACTIVE );
    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_CANCELLED );
    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_CANCELLING );
    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_DONE );
    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_FAILED );
    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_IDLE );
    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_PAUSED );
    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_PAUSING );
    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_RESUMING );
    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_SKIPPED );
    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_STARTING );
    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_SUSPENDED );
    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_SUSPENDING );

    default:

        return ( OLESTR("Invalid Value") );

    }
}



HRESULT
CHsmWorkQueue::FinalConstruct(
    void
    )
/*++

Routine Description:

  This method does some initialization of the object that is necessary
  after construction.

Arguments:

  None.

Return Value:

  S_OK
  Anything returned by CWsbCollectable::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkQueue::FinalConstruct"),OLESTR(""));
    try {

        WsbAssertHr(CComObjectRoot::FinalConstruct());

        //
        // Initialize the member data
        //
        m_pServer           = 0;
        m_pHsmServerCreate  = 0;
        m_pTskMgr;

        m_pFsaResource      = 0;
        m_pSession          = 0;
        m_pRmsServer        = 0;
        m_pRmsCartridge     = 0;
        m_pDataMover        = 0;

        m_pSegmentDb        = 0;
        m_pDbWorkSession    = 0;
        m_pStoragePools     = 0;
        m_pWorkToDo         = 0;
        m_pWorkToCommit     = 0;

        UnsetMediaInfo();

        m_BagId          = GUID_NULL;
        m_HsmId          = GUID_NULL;
        m_RemoteDataSetStart.QuadPart   = 0;
        m_RmsMediaSetId  = GUID_NULL;
        m_RmsMediaSetName = OLESTR("");
        m_RequestAction  = FSA_REQUEST_ACTION_NONE;
        m_QueueType      = HSM_WORK_TYPE_NONE;
        m_BeginSessionHr = S_FALSE;

        m_StateCookie = 0;
        m_EventCookie = 0;

        m_JobPriority = HSM_JOB_PRIORITY_NORMAL;
        m_JobAction   = HSM_JOB_ACTION_UNKNOWN;
        m_JobState    = HSM_JOB_STATE_IDLE;
        m_JobPhase    = HSM_JOB_PHASE_MOVE_ACTION;

        m_WorkerThread = 0;

        m_TerminateQueue = FALSE;
        m_CurrentPath    = OLESTR("");

        // Set threshold defaults
        m_MinFilesToMigrate          =       100;
        m_MinBytesToMigrate          =  10000000;
        m_FilesBeforeCommit          =      2000;
        m_MaxBytesBeforeCommit       = 750000000;
        m_MinBytesBeforeCommit       =  10000000;
        m_FreeMediaBytesAtEndOfMedia =  10000000;
        m_MinFreeSpaceInFullMedia    = MIN_FREE_SPACE_IN_FULL_MEDIA_DEFAULT;
        m_MaxFreeSpaceInFullMedia    = MAX_FREE_SPACE_IN_FULL_MEDIA_DEFAULT;

        m_DataCountBeforeCommit  = 0;
        m_FilesCountBeforeCommit = 0;
        m_StoreDatabasesInBags = TRUE;

        m_QueueItemsToPause = 500;
        m_QueueItemsToResume = 450;
        m_ScannerPaused = FALSE;

        // Job abort on errors parameters
        m_JobAbortMaxConsecutiveErrors = 5;
        m_JobAbortMaxTotalErrors = 25;
        m_JobConsecutiveErrors = 0;
        m_JobTotalErrors = 0;
        m_JobAbortSysDiskSpace = 2 * 1024 * 1024;

        m_mediaCount = 0;
        m_ScratchFailed = FALSE;
        m_uErrorReportFlags = 0;
        WSB_OBJECT_ADD(CLSID_CHsmWorkQueue, this);

    } WsbCatch(hr);

    icountWorkq++;
    WsbTraceOut(OLESTR("CHsmWorkQueue::FinalConstruct"),OLESTR("hr = <%ls>, Count is <%d>"),
                WsbHrAsString(hr), icountWorkq);
    return(hr);
}

HRESULT
CHsmWorkQueue::FinalRelease(
    void
    )
/*++

Routine Description:

  This method does some initialization of the object that is necessary
  before destruction.

Arguments:

  None.

Return Value:

  S_OK
  Anything returned by CWsbCollection::FinalDestruct().

--*/
{
    HRESULT     hr = S_OK;
    HSM_SYSTEM_STATE SysState;

    WsbTraceIn(OLESTR("CHsmWorkQueue::FinalRelease"),OLESTR(""));

    SysState.State = HSM_STATE_SHUTDOWN;
    ChangeSysState(&SysState);

    WSB_OBJECT_SUB(CLSID_CHsmWorkQueue, this);
    CComObjectRoot::FinalRelease();

    // Free String members
    // Note: Member objects held in smart-pointers are freed when the
    // smart-pointer destructor is being called (as part of this object destruction)
    m_MediaName.Free();
    m_MediaBarCode.Free();
    m_RmsMediaSetName.Free();
    m_CurrentPath.Free();

    icountWorkq--;
    WsbTraceOut(OLESTR("CHsmWorkQueue::FinalRelease"),OLESTR("hr = <%ls>, Count is <%d>"),
                WsbHrAsString(hr), icountWorkq);
    return(hr);
}

HRESULT
CHsmWorkQueue::Init(
    IUnknown                *pServer,
    IHsmSession             *pSession,
    IHsmFsaTskMgr           *pTskMgr,
    HSM_WORK_QUEUE_TYPE     queueType
    )
/*++
Routine Description:

  This method does some initialization of the object that is necessary
  after construction.

Arguments:

  None.

Return Value:

  S_OK
--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkQueue::Init"),OLESTR(""));
    try  {
        //
        // Establish contact with the server and get the
        // databases
        //
        WsbAffirmHr(pServer->QueryInterface(IID_IHsmServer, (void **)&m_pServer));
        //We want a weak link to the server so decrement the reference count
        m_pServer->Release();

        m_pTskMgr = pTskMgr;
        m_pTskMgr->AddRef();
        m_QueueType = queueType;

        WsbAffirmHr(m_pServer->GetSegmentDb(&m_pSegmentDb));
        WsbAffirmHr(m_pServer->GetStoragePools(&m_pStoragePools));
        WsbAffirmHr(m_pServer->QueryInterface(IID_IWsbCreateLocalObject, (void **)&m_pHsmServerCreate));
        // We want a weak link to the server so decrement the reference count
        m_pHsmServerCreate->Release();
        WsbAffirmHr(m_pServer->GetID(&m_HsmId));

        WsbAffirmHr(CheckSession(pSession));

        //
        // Make a collection for the work items
        //
        WsbAffirmHr(m_pHsmServerCreate->CreateInstance(CLSID_CWsbOrderedCollection,
                                                       IID_IWsbIndexedCollection,
                                                       (void **)&m_pWorkToDo ));

        WsbAffirmHr(m_pHsmServerCreate->CreateInstance(CLSID_CWsbOrderedCollection,
                                                       IID_IWsbIndexedCollection,
                                                       (void **)&m_pWorkToCommit ));

        //
        // Make sure our connection to RMS is current
        //
        WsbAffirmHr(CheckRms());

        // Check the registry to see if there are changes to default settings
        CheckRegistry();

    } WsbCatch( hr );

    WsbTraceOut(OLESTR("CHsmWorkQueue::Init"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return( hr );

}

HRESULT
CHsmWorkQueue::ContactOk(
    void
    )
/*++
Routine Description:

  This allows the caller to see if the RPC connection
  to the task manager is OK

Arguments:

  None.

Return Value:

  S_OK
--*/
{

    return( S_OK );

}

HRESULT
CHsmWorkQueue::ProcessSessionEvent(
    IHsmSession *pSession,
    HSM_JOB_PHASE phase,
    HSM_JOB_EVENT event
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    HRESULT     hr = S_OK;
    WsbTraceIn(OLESTR("CHsmWorkQueue::ProcessSessionEvent"),OLESTR(""));
    try {

        WsbAssert(0 != pSession, E_POINTER);

        // If the phase applies to us (MOVER or ALL), then do any work required by the
        // event.
        if ((HSM_JOB_PHASE_ALL == phase) || (HSM_JOB_PHASE_MOVE_ACTION == phase)) {

            switch(event) {

                case HSM_JOB_EVENT_SUSPEND:
                case HSM_JOB_EVENT_CANCEL:
                case HSM_JOB_EVENT_FAIL:
                    WsbAffirmHr(Cancel());
                    break;

                case HSM_JOB_EVENT_PAUSE:
                    WsbAffirmHr(Pause());
                    break;

                case HSM_JOB_EVENT_RESUME:
                    WsbAffirmHr(Resume());
                    break;

                case HSM_JOB_EVENT_RAISE_PRIORITY:
                    WsbAffirmHr(RaisePriority());
                    break;

                case HSM_JOB_EVENT_LOWER_PRIORITY:
                    WsbAffirmHr(LowerPriority());
                    break;

                default:
                case HSM_JOB_EVENT_START:
                    WsbAssert(FALSE, E_UNEXPECTED);
                    break;
            }
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkQueue::ProcessSessionEvent"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return( S_OK );

}


HRESULT
CHsmWorkQueue::ProcessSessionState(
    IHsmSession* /*pSession*/,
    IHsmPhase* pPhase,
    OLECHAR* /*currentPath*/
    )
/*++

Routine Description:

Arguments:

Return Value:


--*/
{
    HRESULT         hr = S_OK;
    HSM_JOB_PHASE   phase;
    HSM_JOB_STATE   state;

    WsbTraceIn(OLESTR("CHsmWorkQueue::ProcessSessionState"),OLESTR(""));
    try  {

        WsbAffirmHr(pPhase->GetState(&state));
        WsbAffirmHr(pPhase->GetPhase(&phase));
        WsbTrace( OLESTR("CHsmWorkQueue::ProcessSessionState - State = <%d>, phase = <%d>\n"), state, phase );

        if ( HSM_JOB_PHASE_SCAN == phase ) {

            // If the session has finished, then we have some cleanup to do so that it can go
            // away.
            if ((state == HSM_JOB_STATE_DONE) || (state == HSM_JOB_STATE_FAILED) || (state == HSM_JOB_STATE_SUSPENDED) ) {
                WsbTrace( OLESTR("Job is done, failed, or suspended\n") );
                // Create a work item and append it to the work queue to
                // indicate that the job is done
                WsbAffirmHr(MarkQueueAsDone());
            }
        }

    } WsbCatch( hr );

    WsbTraceOut(OLESTR("CHsmWorkQueue::ProcessSessionState"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return( S_OK );

}


HRESULT
CHsmWorkQueue::Add(
    IFsaPostIt *pFsaWorkItem
    )
/*++

Implements:

  IHsmFsaTskMgr::Add

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IHsmSession>        pSession;

    WsbTraceIn(OLESTR("CHsmWorkQueue::Add"),OLESTR(""));
    try  {
        //
        // Make sure there is a work allocater for this session
        //
        WsbAffirmHr(pFsaWorkItem->GetSession(&pSession));
        WsbAffirmHr(CheckSession(pSession));

        //
        // Create a work item, load it up and add it to this
        // Queue's collection
        //
        CComPtr<IHsmWorkItem>   pWorkItem;
        WsbAffirmHr(m_pHsmServerCreate->CreateInstance(CLSID_CHsmWorkItem, IID_IHsmWorkItem,
                                                        (void **)&pWorkItem));
        WsbAffirmHr(pWorkItem->SetWorkType(HSM_WORK_ITEM_FSA_WORK));
        WsbAffirmHr(pWorkItem->SetFsaPostIt(pFsaWorkItem));
        WsbAffirmHr(m_pWorkToDo->Append(pWorkItem));

        //
        // If adding this item to the queue meets or exceeds the count for pausing
        // pause the scanner so there is no more work submitted.
        //
        ULONG numItems;
        WsbAffirmHr(m_pWorkToDo->GetEntries(&numItems));
        WsbTrace(OLESTR("CHsmWorkQueue::Add - num items in queue = <%lu>\n"),numItems);
        if (numItems >= m_QueueItemsToPause)  {
            WsbAffirmHr(PauseScanner());
        }

    } WsbCatch (hr);

    WsbTraceOut(OLESTR("CHsmWorkQueue::Add"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return (hr);
}


HRESULT
CHsmWorkQueue::Start( void )
/*++

Implements:

  IHsmWorkQueue::Start

--*/
{
    HRESULT                     hr = S_OK;
    DWORD                       tid;

    WsbTraceIn(OLESTR("CHsmWorkQueue::Start"),OLESTR(""));
    try  {
        //
        // If the worker thread is already started, just return
        //
        WsbAffirm(m_WorkerThread == 0, S_OK);
        // Launch a thread to do work that is queued
        WsbAffirm((m_WorkerThread = CreateThread(0, 0, HsmWorkQueueThread, (void*) this, 0, &tid)) != 0, HRESULT_FROM_WIN32(GetLastError()));

        if (m_WorkerThread == NULL) {
            WsbAssertHr(E_FAIL);  // TBD What error to return here??
        }

    } WsbCatch (hr);

    WsbTraceOut(OLESTR("CHsmWorkQueue::Start"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return (hr);
}


HRESULT
CHsmWorkQueue::Stop( void )
/*++

Implements:

  IHsmWorkQueue::Stop

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkQueue::Stop"),OLESTR(""));

    //  Stop the thread (signal, wait, terminate if it still running)
    m_TerminateQueue = TRUE;

    if (m_WorkerThread) {
        switch (WaitForSingleObject(m_WorkerThread, 20000)) {
            case WAIT_FAILED: {
                WsbTrace(OLESTR("CHsmWorkQueue::Stop: WaitForSingleObject returned error %lu\n"), GetLastError());
            }
            // fall through...

            case WAIT_TIMEOUT: {
                WsbTrace(OLESTR("CHsmWorkQueue::Stop: force terminating of working thread.\n"));

                DWORD dwExitCode;
                if (GetExitCodeThread( m_WorkerThread, &dwExitCode)) {
                    if (dwExitCode == STILL_ACTIVE) {   // thread still active
                        if (!TerminateThread (m_WorkerThread, 0)) {
                            WsbTrace(OLESTR("CHsmWorkQueue::Stop: TerminateThread returned error %lu\n"), GetLastError());
                        }
                    }
                } else {
                    WsbTrace(OLESTR("CHsmWorkQueue::Stop: GetExitCodeThread returned error %lu\n"), GetLastError());
                }

                break;
            }

            default:
                // Thread terminated gracefully
                WsbTrace(OLESTR("CHsmWorkQueue::Stop: working thread terminated gracefully\n"));
                break;
        }
    }

    WsbTraceOut(OLESTR("CHsmWorkQueue::Stop"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return (hr);
}



HRESULT
CHsmWorkQueue::PremigrateIt(
    IFsaPostIt *pFsaWorkItem
    )
{
    HRESULT                     hr = S_OK;
    GUID                        mediaToUse;
    GUID                        firstSide;
    BOOLEAN                     done = FALSE;
    FSA_PLACEHOLDER             placeholder;
    LONGLONG                    requestSize;
    LONGLONG                    requestStart;
    LONGLONG                    fileVersionId;

    WsbTraceIn(OLESTR("CHsmWorkQueue::PremigrateIt"),OLESTR(""));
    try  {
        //
        // Check to see if anything has changed since the request
        //
        WsbAffirmHr(CheckForChanges(pFsaWorkItem));

        // Check for sufficient space on system volume
        WsbAffirmHr(CheckForDiskSpace());

        //
        // Go to the Storage Pool and get the media set associated
        // with this data
        //
        WsbAffirmHr(GetMediaSet(pFsaWorkItem));

        //
        // Loop here to try to recover from certain types of errors
        //
        while (done == FALSE){
            CComPtr<IWsbIndexedCollection>  pMountingCollection;
            CComPtr<IMountingMedia>         pMountingMedia;
            CComPtr<IMountingMedia>         pMediaToFind;
            BOOL                            bMediaMounting = FALSE;
            BOOL                            bMediaMountingAdded = FALSE;
            BOOL                            bMediaChanged = FALSE;
            LONGLONG                        llRequiredSize = 0;

            // Lock mounting media while searching for a media to use
            WsbAffirmHr(m_pServer->LockMountingMedias());

            // Find a media to use and set up interfaces to RMS
            try {
                WsbAffirmHr(FindMigrateMediaToUse(pFsaWorkItem, &mediaToUse, &firstSide, &bMediaChanged, &llRequiredSize));

                // Check if the media-to-use have changed and is a non-scratch media
                if ((GUID_NULL != mediaToUse) && bMediaChanged) {

                    // Check if the media to mount is already mounting
                    WsbAffirmHr(m_pServer->GetMountingMedias(&pMountingCollection));
                    WsbAffirmHr(CoCreateInstance(CLSID_CMountingMedia, 0, CLSCTX_SERVER, IID_IMountingMedia, (void**)&pMediaToFind));
                    WsbAffirmHr(pMediaToFind->SetMediaId(mediaToUse));
                    hr = pMountingCollection->Find(pMediaToFind, IID_IMountingMedia, (void **)&pMountingMedia);

                    if (hr == S_OK) {
                        // Media is already mounting...
                        bMediaMounting = TRUE;
                        WsbAffirmHr(pMediaToFind->SetIsReadOnly(FALSE));

                    } else if (hr == WSB_E_NOTFOUND) {
                        // New media to mount - add to the mounting list
                        hr = S_OK;
                        WsbAffirmHr(pMediaToFind->Init(mediaToUse, FALSE));
                        WsbAffirmHr(pMountingCollection->Add(pMediaToFind));
                        bMediaMountingAdded = TRUE;

                    } else {
                        WsbAffirmHr(hr);
                    }
                }

            } WsbCatchAndDo(hr,
                    // Unlock mounting media
                    m_pServer->UnlockMountingMedias();

                    WsbTraceAlways(OLESTR("CHsmWorkQueue::PremigrateIt: error while trying to find/add mounting media. hr=<%ls>\n"),
                                    WsbHrAsString(hr));                                

                    // Bale out
                    WsbThrow(hr);
                );

            // Release the lock
            WsbAffirmHr(m_pServer->UnlockMountingMedias());

            // If the media is mounting - wait for the mount event
            if (bMediaMounting) {
                WsbAffirmHr(pMountingMedia->WaitForMount(INFINITE));
                pMountingMedia = 0;
            }

            // Mount the media. Ask for short timeout.
            hr = MountMedia(pFsaWorkItem, mediaToUse, firstSide, TRUE, TRUE, llRequiredSize);

            // If we added a mounting media to the list - remove it once the mount is done
            if (bMediaMountingAdded) {
                HRESULT hrRemove = S_OK;

                // No matter how the Mount finished - free waiting clients and remove from the list
                hrRemove = m_pServer->LockMountingMedias();
                WsbAffirmHr(hrRemove);

                try {
                    WsbAffirmHr(pMediaToFind->MountDone());
                    WsbAffirmHr(pMountingCollection->RemoveAndRelease(pMediaToFind));
                    pMediaToFind = 0;

                } WsbCatch(hrRemove);

                m_pServer->UnlockMountingMedias();

                // We don't expect any errors while removing the mounting media -
                // The thread that added to the collection is always the one that removes
                if (! SUCCEEDED(hrRemove)) {
                    WsbTraceAlways(OLESTR("CHsmWorkQueue::PremigrateIt: error while trying to remove a mounting media. hr=<%ls>\n"),
                                    WsbHrAsString(hrRemove));                                

                    WsbThrow(hrRemove);
                }
            }

            //   Check for job cancellation
            if (HSM_JOB_STATE_CANCELLING == m_JobState) {
                WsbThrow(HSM_E_WORK_SKIPPED_CANCELLED);
            }

            //
            // Process RMS errors
            //
            switch (hr) {
                case RMS_E_CARTRIDGE_NOT_FOUND: {
                    // If this media wasn't found, mark it as bad and try a different one
                    WsbAffirmHr(MarkMediaBad(pFsaWorkItem, m_MediaId, hr));
                    hr = S_OK;
                    continue;
                }

                case RMS_E_TIMEOUT:
                case HSM_E_NO_MORE_MEDIA:
                case RMS_E_CARTRIDGE_DISABLED:
                case HSM_E_MEDIA_NOT_AVAILABLE: {
                    // In all these cases, let FindMigrateMediaToUse try to find a different media
    				hr = S_OK;
	    			continue;
                }

                default: {
                    WsbAffirmHr(hr);
                }
            }

            //
            // Make sure the data has not been modified since the
            // FSA determined the migration request
            //
            hr = CheckForChanges(pFsaWorkItem);
            if (S_OK == hr)  {
                //
                // Build the source path
                //
                CWsbStringPtr tmpString;
                WsbAffirmHr(GetSource(pFsaWorkItem, &tmpString));
                CWsbBstrPtr localName = tmpString;
                //
                // Ask the Data mover to store the data
                //
                ULARGE_INTEGER localDataStart;
                ULARGE_INTEGER localDataSize;
                ULARGE_INTEGER remoteFileStart;
                ULARGE_INTEGER remoteFileSize;
                ULARGE_INTEGER remoteDataSetStart;
                ULARGE_INTEGER remoteDataStart;
                ULARGE_INTEGER remoteDataSize;
                ULARGE_INTEGER remoteVerificationData;
                ULONG          remoteVerificationType;
                ULARGE_INTEGER dataStreamCRC;
                ULONG          dataStreamCRCType;
                ULARGE_INTEGER usn;


                WsbAffirmHr(pFsaWorkItem->GetPlaceholder(&placeholder));
                WsbAffirmHr(pFsaWorkItem->GetRequestSize(&requestSize));
                WsbAffirmHr(pFsaWorkItem->GetRequestOffset(&requestStart));
                WsbAffirmHr(pFsaWorkItem->GetFileVersionId(&fileVersionId));
                localDataStart.QuadPart = requestStart;
                localDataSize.QuadPart = requestSize;
                ReportMediaProgress(HSM_JOB_MEDIA_STATE_TRANSFERRING, hr);
                // Make sure data mover is ready for work.
                WsbAffirmPointer(m_pDataMover);

                hr =  m_pDataMover->StoreData(  localName,
                                                localDataStart,
                                                localDataSize,
                                                MVR_FLAG_BACKUP_SEMANTICS | MVR_FLAG_POSIX_SEMANTICS,
                                                &remoteDataSetStart,
                                                &remoteFileStart,
                                                &remoteFileSize,
                                                &remoteDataStart,
                                                &remoteDataSize,
                                                &remoteVerificationType,
                                                &remoteVerificationData,
                                                &dataStreamCRCType,
                                                &dataStreamCRC,
                                                &usn);
                WsbTrace(OLESTR("StoreData returned hr = <%ls>\n"),WsbHrAsString(hr));
                ReportMediaProgress(HSM_JOB_MEDIA_STATE_TRANSFERRED, hr);

                if (S_OK == hr)  {

                    //  Save the offset on the tape of the data set if we
                    //  don't have it; confirm it if we do
                    if (0 == m_RemoteDataSetStart.QuadPart) {
                        m_RemoteDataSetStart = remoteDataSetStart;
                    } else {
                        WsbAssert(m_RemoteDataSetStart.QuadPart ==
                                remoteDataSetStart.QuadPart,
                                WSB_E_INVALID_DATA);
                    }

                    //
                    // Fill in the placeholder data
                    //
                    placeholder.bagId = m_BagId;
                    placeholder.hsmId = m_HsmId;
                    placeholder.fileStart = remoteFileStart.QuadPart;
                    placeholder.fileSize = remoteFileSize.QuadPart;
                    placeholder.dataStart = remoteDataStart.QuadPart;
                    placeholder.dataSize = remoteDataSize.QuadPart;
                    placeholder.verificationData = remoteVerificationData.QuadPart;
                    placeholder.verificationType = remoteVerificationType;
                    placeholder.fileVersionId = fileVersionId;
                    placeholder.dataStreamCRCType = dataStreamCRCType;
                    placeholder.dataStreamCRC = dataStreamCRC.QuadPart;
                    WsbAffirmHr(pFsaWorkItem->SetPlaceholder(&placeholder));
                    WsbAffirmHr(pFsaWorkItem->SetUSN(usn.QuadPart));

                    //
                    // Update media information
                    WsbAffirmHr(GetMediaParameters());

                    done = TRUE;
                } else {
                    switch (hr) {

                    case MVR_E_END_OF_MEDIA:
                    case MVR_E_DISK_FULL:
                        //
                        // We have run out of disk space so mark the media full
                        // and try again
                        //
                        // To really cleanup, we should remove the portion
                        // written  TBD
                        //
                        WsbAffirmHr(MarkMediaFull(pFsaWorkItem, m_MediaId));
                        mediaToUse = GUID_NULL;
                        break;

                    case MVR_E_MEDIA_ABORT:
                        //
                        // Media is most likely bad - mark it as such, then abort
                        //
                        WsbAffirmHr(MarkMediaBad(pFsaWorkItem, m_MediaId, hr));
                        done = TRUE;
                        break;

                    default:
                        // We failed the copy somehow.  Report this error.
                        done = TRUE;
                        break;
                    }
                }
            } else {
                done = TRUE;
            }
        }
    } WsbCatch( hr );

    WsbTraceOut(OLESTR("CHsmWorkQueue::PremigrateIt"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return( hr );
}


HRESULT
CHsmWorkQueue::RecallIt(
    IFsaPostIt *pFsaWorkItem
    )
{
    HRESULT                     hr = S_OK;
    GUID                        mediaToUse = GUID_NULL;
    CComPtr<IFsaScanItem>       pScanItem;
    LONGLONG                    readOffset;

    WsbTraceIn(OLESTR("CHsmWorkQueue::RecallIt"),OLESTR(""));
    try  {

        GetScanItem(pFsaWorkItem, &pScanItem);

        if ((m_RequestAction != FSA_REQUEST_ACTION_FILTER_READ) &&
            (m_RequestAction != FSA_REQUEST_ACTION_FILTER_RECALL))  {
            //
            // Non-demand recall - make sure the file has not changed
            //
            hr = CheckForChanges(pFsaWorkItem);
        } else {
            //
            // For demand recalls we have to assume the file has not changed since we
            // recall on the first read or write.
            //
            hr = S_OK; //CheckForChanges(pFsaWorkItem);
        }
        if ( S_OK == hr ) {
            CComPtr<IWsbIndexedCollection>  pMountingCollection;
            CComPtr<IMountingMedia>         pMountingMedia;
            CComPtr<IMountingMedia>         pMediaToFind;
            BOOL                            bMediaMounting = FALSE;
            BOOL                            bMediaMountingAdded = FALSE;
            BOOL                            bMediaChanged = FALSE;

            // Find the media that contains the file
            WsbAffirmHr(FindRecallMediaToUse(pFsaWorkItem, &mediaToUse, &bMediaChanged));

            if (bMediaChanged) {
                // Check if the media is already in the process of mounting
                WsbAffirmHr(m_pServer->LockMountingMedias());

                try {
                    // Check if the media to mount is already mounting
                    WsbAffirmHr(m_pServer->GetMountingMedias(&pMountingCollection));
                    WsbAffirmHr(CoCreateInstance(CLSID_CMountingMedia, 0, CLSCTX_SERVER, IID_IMountingMedia, (void**)&pMediaToFind));
                    WsbAffirmHr(pMediaToFind->SetMediaId(mediaToUse));
                    hr = pMountingCollection->Find(pMediaToFind, IID_IMountingMedia, (void **)&pMountingMedia);

                    if (hr == S_OK) {
                        // Media is already mounting...
                        bMediaMounting = TRUE;

                    } else if (hr == WSB_E_NOTFOUND) {
                        // New media to mount - add to the mounting list
                        hr = S_OK;
                        WsbAffirmHr(pMediaToFind->Init(mediaToUse, TRUE));
                        WsbAffirmHr(pMountingCollection->Add(pMediaToFind));
                        bMediaMountingAdded = TRUE;

                    } else {
                        WsbAffirmHr(hr);
                    }
                } WsbCatchAndDo(hr,
                    // Unlock mounting media
                    m_pServer->UnlockMountingMedias();

                    WsbTraceAlways(OLESTR("CHsmWorkQueue::RecallIt: error while trying to find/add mounting media. hr=<%ls>\n"),
                                    WsbHrAsString(hr));                                

                    // Bale out
                    WsbThrow(hr);
                );

                // Release the lock
                WsbAffirmHr(m_pServer->UnlockMountingMedias());
            }

            // If the media is mounting - wait for the mount event
            if (bMediaMounting) {
                WsbAffirmHr(pMountingMedia->WaitForMount(INFINITE));
                pMountingMedia = 0;
            }

            //
            // Get the media mounted (hr is checked only after removing from the mounting-media list)
            //
            hr = MountMedia(pFsaWorkItem, mediaToUse);

            // If added to the mounting list - remove
            if (bMediaMountingAdded) {
                HRESULT hrRemove = S_OK;

                // No matter how the Mount finished - free waiting clients and remove from the list
                hrRemove = m_pServer->LockMountingMedias();
                WsbAffirmHr(hrRemove);

                try {
                    WsbAffirmHr(pMediaToFind->MountDone());
                    WsbAffirmHr(pMountingCollection->RemoveAndRelease(pMediaToFind));
                    pMediaToFind = 0;

                } WsbCatch(hrRemove);

                m_pServer->UnlockMountingMedias();

                // We don't expect any errors while removing the mounting media -
                // The thread that added to the collection is always the one that removes
                if (! SUCCEEDED(hrRemove)) {
                    WsbTraceAlways(OLESTR("CHsmWorkQueue::RecallIt: error while trying to remove a mounting media. hr=<%ls>\n"),
                                    WsbHrAsString(hrRemove));                                

                    WsbThrow(hrRemove);
                }
            }

            //
            // Check the Mount result
            //
            WsbAffirmHr(hr);

            //
            // Copy the data
            //
            // Build the source path
            CWsbStringPtr tmpString;
            WsbAffirmHr(GetSource(pFsaWorkItem, &tmpString));
            CWsbBstrPtr localName = tmpString;
            // Ask the Data mover to store the data
            LONGLONG       requestSize;
            LONGLONG       requestStart;
            ULARGE_INTEGER localDataStart;
            ULARGE_INTEGER localDataSize;
            ULARGE_INTEGER remoteFileStart;
            ULARGE_INTEGER remoteFileSize;
            ULARGE_INTEGER remoteDataStart;
            ULARGE_INTEGER remoteDataSize;
            ULARGE_INTEGER remoteVerificationData;
            ULONG          remoteVerificationType;

            FSA_PLACEHOLDER             placeholder;
            WsbAffirmHr(pFsaWorkItem->GetPlaceholder(&placeholder));
            WsbAffirmHr(pFsaWorkItem->GetRequestSize(&requestSize));
            WsbAffirmHr(pFsaWorkItem->GetRequestOffset(&requestStart));

            //
            // Build strings
            //
            CWsbStringPtr strGuid;

            CWsbBstrPtr sessionName = HSM_BAG_NAME;
            WsbAffirmHr(WsbSafeGuidAsString(m_BagId, strGuid));
            sessionName.Append(strGuid);

            CWsbBstrPtr sessionDescription = HSM_ENGINE_ID;
            WsbAffirmHr(WsbSafeGuidAsString(m_HsmId, strGuid));
            sessionDescription.Append(strGuid);

            localDataStart.QuadPart = requestStart;
            localDataSize.QuadPart = requestSize;
            remoteFileStart.QuadPart = placeholder.fileStart;
            remoteFileSize.QuadPart = placeholder.fileSize;
            remoteDataStart.QuadPart = placeholder.dataStart;
            remoteDataSize.QuadPart = placeholder.dataSize;
            remoteVerificationData.QuadPart = placeholder.verificationData;
            remoteVerificationType = placeholder.verificationType;


            ReportMediaProgress(HSM_JOB_MEDIA_STATE_TRANSFERRING, hr);

            CComPtr<IStream> pLocalStream;
            CComPtr<IStream> pRemoteStream;
            ULARGE_INTEGER offset, read, written;
            DWORD   verifyType;


            if ((m_RequestAction == FSA_REQUEST_ACTION_FILTER_READ) ||
                (m_RequestAction == FSA_REQUEST_ACTION_FILTER_RECALL))  {
                //
                // We are doing a read without recall, so get the
                // recall object's data mover
                //
                CComPtr<IFsaFilterRecall> pRecall;
                WsbAffirmHr(pFsaWorkItem->GetFilterRecall(&pRecall));
                WsbAffirmHr(pRecall->CreateLocalStream( &pLocalStream));
                WsbAffirmHr(pRecall->GetSize( (LONGLONG *) &remoteDataSize.QuadPart ));
                WsbAffirmHr(pRecall->GetOffset( &readOffset ));
                if (readOffset == 0) {
                    verifyType = MVR_VERIFICATION_TYPE_HEADER_CRC;
                } else {
                    verifyType = MVR_VERIFICATION_TYPE_NONE;
                }
            } else  {
                //
                // We are doing a file recall (not a demand recall) so get the FSA data mover
                //
                verifyType = MVR_VERIFICATION_TYPE_HEADER_CRC;
                readOffset = 0;
                WsbAffirmPointer(pScanItem);
                WsbAffirmHr(pScanItem->CreateLocalStream( &pLocalStream ) );
            }

            //
            // Create remote data mover stream
            // TEMPORARY: Consider removing the NO_CACHING flag for a NO_RECALL recall
            //

            WsbAssert(0 != m_RemoteDataSetStart.QuadPart, HSM_E_BAD_SEGMENT_INFORMATION);
            WsbAffirmHr( m_pDataMover->CreateRemoteStream(
                CWsbBstrPtr(L""),
                MVR_MODE_READ | MVR_FLAG_HSM_SEMANTICS | MVR_FLAG_NO_CACHING,
                sessionName,
                sessionDescription,
                m_RemoteDataSetStart,
                remoteFileStart,
                remoteFileSize,
                remoteDataStart,
                remoteDataSize,
                verifyType,
                remoteVerificationData,
                &pRemoteStream ) );

            //
            // The offset given here is the offset into the stream itself (readOffset).  
            // The actual position on remote media will be the bag start plus the file start
            // plus the file-data start (all given in CreateRemoteStream) plus this offset.
            //
            WsbTrace(OLESTR("Setting offset to %I64d reading %I64u\n"), readOffset, remoteDataSize.QuadPart);

            offset.QuadPart = readOffset;
            WsbAffirmHr( m_pDataMover->SetInitialOffset( offset ) );

            //
            // Once the remote stream has been created we must make sure we detach it
            //

            try {

                WsbAffirmHr( pRemoteStream->CopyTo( pLocalStream, remoteDataSize, &read, &written ) );
                WsbAffirmHr( pLocalStream->Commit( STGC_DEFAULT ) );

                //
                // The CopyTo succeeded... make sure we got all the bytes
                // we asked for.
                //
                // If we attempt to read from a incomplete Master that
                // does not contain the migrated data we'll fail here with
                // MVR_S_NO_DATA_DETECTED.
                //
                WsbAffirm( written.QuadPart == remoteDataSize.QuadPart, HSM_E_VALIDATE_DATA_NOT_ON_MEDIA );

                WsbAffirmHr( m_pDataMover->CloseStream() );
            } WsbCatchAndDo(hr,
                WsbAffirmHr( m_pDataMover->CloseStream() );
                );

            ReportMediaProgress(HSM_JOB_MEDIA_STATE_TRANSFERRED, hr);
            WsbTrace(OLESTR("RecallData returned hr = <%ls>\n"),WsbHrAsString(hr));
        } else {
            //
            // The file has changed or is not in the correct state
            //
            WsbTrace(OLESTR("The file has changed between asking for the recall and the actual recall\n"));
            WsbAffirmHr( hr );
        }

    } WsbCatch( hr );

    // Tell the session whether or not the work was done.
    // We don't really care about the return code, there is nothing
    // we can do if it fails.
    WsbTrace(OLESTR("Tried HSM work, calling Session to Process Item\n"));
    if (pScanItem) {
        m_pSession->ProcessItem(m_JobPhase, m_JobAction, pScanItem, hr);
    }

    WsbTraceOut(OLESTR("CHsmWorkQueue::RecallIt"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return( hr );
}



HRESULT
CHsmWorkQueue::validateIt(
    IFsaPostIt *pFsaWorkItem
    )
/*

Routine Description:

    This Engine internal helper method is used to validate a scan item which has a
    reparse point (found by the FSA during a resource scan).

    When this method gets control it already knows the resource (e.g., volume) it is
    operating against by virtue of the work queue being tied to a volume.  The PostIt
    object whose interface pointer has been passed into this method is tied to a
    specific scan item (e.g.,file).  So on call this method knows both the resource
    and scan item it is validating.

    Validating a file with a reparse point on it means verifying that this file's info
    is properly contained in the HSM databases and that the file's bag is contained on
    its master secondary storage media.

    After getting basic info (the resource id and the file's placeholder info), the method
    first verifies that the placeholder's bag is contained in the Bag Info Table.  If so,
    the file's segment is then verified as being contained in the Segment Table.  Providing
    it is, the master media id contained in the Segment Table record is verified as
    being contained in the Media Info Table.  Finally the Remote Data Set (bag) the file
    belongs to is verified as being contained on the master media.

    If any of the above verifications fail the PostIt object is marked to request a
    Result Action of 'Validate Bad' from the FSA, and the PostIt is sent back to the
    FSA to perform that action.  (Validate Bad action means that a file in a Premigrated
    state will have its placeholder removed, changing it to a normal (unmanaged) file,
    and a Truncated file will be deleted.)

    If the file validates up to this point, then the PostIt is marked accordingly (which
    will cause the FSA to update the Premigrated/Truncated stats as appropriate) and a
    couple of final checks are made.  First, if the resource the file is presently on
    does not agree with the resource stored in the Bag Info Table record (meaning
    the reparsed file was moved without being recalled, e.g., backing up the file and
    restoring it to another volume), an entry is added to the Volume Assignment Table.
    Secondly, if the file is present in the Bag Hole Table (meaning it has been deleted)
    it is removed from there.

Arguments:

    pFsaWorkItem - Interface pointer to the PostIt object initiated by the FSA.  The
            PostIt object correlates to a specific scan item.

Return Value:

    S_OK - The call succeeded (the specified scan item was validated, and the appropriate
            result action was filled into the PostIt, which will be sent back to the
            FSA for action).

    Any other value - The call failed in one of the embedded Remote Storage API calls.
            The result will be specific to the call that failed.

*/

{
    HRESULT                         hr = S_OK;
    GUID                            l_BagVolId;
    GUID                            resourceId;
    LONGLONG                        l_FileStart = 0;
    FSA_PLACEHOLDER                 placeholder;
    CWsbStringPtr                   path;
    CComQIPtr<ISegDb, &IID_ISegDb>  pSegDb = m_pSegmentDb;
    CComPtr<IRmsServer>             pRmsServer;
    CComPtr<IRmsCartridge>          pMedia;
    GUID                            mediaSubsystemId;


    WsbTraceIn(OLESTR("CHsmWorkQueue::validateIt"),OLESTR(""));

    try  {

        memset(&placeholder, 0, sizeof(FSA_PLACEHOLDER));

        //
        // Get starting info and set hsm work queue object's bag id to that contained
        // in the scan item's placeholder
        //
        WsbAffirmHr( m_pFsaResource->GetIdentifier( &resourceId ));
        WsbAffirmHr( pFsaWorkItem->GetPlaceholder( &placeholder ));
        m_BagId = placeholder.bagId;
        l_FileStart = placeholder.fileStart;

        WsbAffirmHr( pFsaWorkItem->GetPath( &path, 0 ));
        WsbTrace( OLESTR("Beginning to validate <%s>.\n"), path );

        //
        // Make sure the segment is in the Segment Table (seek the segment record
        // whose keys (bag id, file start and file size) match what is in the placeholder).
        // Note: We need to start with this table since the real BAG is different for indirect segments.
        //
        CComPtr<ISegRec>            pSegRec;
        GUID                        l_BagId;
        LONGLONG                    l_FileSize;
        USHORT                      l_SegFlags;
        GUID                        l_PrimPos;
        LONGLONG                    l_SecPos;

        hr =  pSegDb->SegFind( m_pDbWorkSession, m_BagId, placeholder.fileStart,
                        placeholder.fileSize, &pSegRec );
        if (S_OK != hr )  {
            hr = HSM_E_VALIDATE_SEGMENT_NOT_FOUND;
            WsbAffirmHr(pFsaWorkItem->SetResult(hr));
            WsbThrow(hr);
        }


        // Segment is in the table.  Get segment record since we use l_PrimPos in next step
        WsbTrace( OLESTR("(validateIt) <%s> found in Segment table, continuing...\n"),
                                                path );
        WsbAffirmHr( pSegRec->GetSegmentRecord( &l_BagId, &l_FileStart, &l_FileSize,
                                                &l_SegFlags, &l_PrimPos, &l_SecPos ));

        //
        // In case of an indirect record, go to the dirtect record to get real location info
        //
        if (l_SegFlags & SEG_REC_INDIRECT_RECORD) {
            pSegRec = 0;

            hr = pSegDb->SegFind(m_pDbWorkSession, l_PrimPos, l_SecPos,
                                 placeholder.fileSize, &pSegRec);
            if (S_OK != hr )  {
                // We couldn't find the direct segment record for this segment!
                hr = HSM_E_VALIDATE_SEGMENT_NOT_FOUND;
                WsbAffirmHr(pFsaWorkItem->SetResult(hr));
                WsbThrow(hr);
            }

            WsbTrace( OLESTR("(validateIt) direct segment for <%s> found in Segment table, continuing...\n"), 
                       path );
            WsbAffirmHr(pSegRec->GetSegmentRecord(&l_BagId, &l_FileStart, &l_FileSize, 
                                                  &l_SegFlags, &l_PrimPos, &l_SecPos));

            // Don't support a second indirection for now !!
            if (l_SegFlags & SEG_REC_INDIRECT_RECORD) {
                hr = HSM_E_BAD_SEGMENT_INFORMATION;
                WsbAffirmHr(pFsaWorkItem->SetResult(hr));
                WsbThrow(hr);
            }

            // Change Bag id to the real one
            m_BagId = l_BagId;
        }

        //
        // Make sure the BAG ID is in the Bag Info Table (get the Bag Info Table
        // (entity) in the Segment database, set the key value (bag id) to that
        // contained in the placeholder and get that record.  If found, the Bag
        // is in the Bag Info Table).
        //
        CComPtr<IBagInfo>           pBagInfo;
        FILETIME                    l_BirthDate;
        HSM_BAG_STATUS              l_BagStatus;
        LONGLONG                    l_BagLen;
        USHORT                      l_BagType;
        LONGLONG                    l_DeletedBagAmount;
        SHORT                       l_RemoteDataSet;

        WsbAffirmHr( m_pSegmentDb->GetEntity( m_pDbWorkSession, HSM_BAG_INFO_REC_TYPE,
                                            IID_IBagInfo, (void**)&pBagInfo ));

        GetSystemTimeAsFileTime(&l_BirthDate);
        WsbAffirmHr( pBagInfo->SetBagInfo( HSM_BAG_STATUS_IN_PROGRESS, m_BagId,
                                            l_BirthDate, 0, 0, GUID_NULL, 0, 0 ));
        hr = pBagInfo->FindEQ();
        if (S_OK != hr )  {
            hr = HSM_E_VALIDATE_BAG_NOT_FOUND;
            WsbAffirmHr(pFsaWorkItem->SetResult(hr));
            WsbThrow(hr);
        }

        // Bag is in the table.  Trace, then get bag record since we will use some
        // info later (l_RemoteDataSet, l_BagVolId).
        WsbTrace( OLESTR("(validateIt) <%s> found in Bag Info table, continuing...\n"),
                                        path );
        WsbAffirmHr( pBagInfo->GetBagInfo( &l_BagStatus, &l_BagId, &l_BirthDate,
                                        &l_BagLen, &l_BagType, &l_BagVolId,
                                        &l_DeletedBagAmount, &l_RemoteDataSet ));

        //
        // Make sure the media is in the Media Info table (get Media Info Table, set
        // the key (media id) to what is in the Segment record and get the record).
        // Note that for Sakkara the Primary Position field in the Segment record
        // (l_PrimPos) contains the id (GUID) of the media where the bag/segment is stored.
        //
        CComPtr<IMediaInfo>         pMediaInfo;

        WsbAffirmHr( m_pSegmentDb->GetEntity( m_pDbWorkSession, HSM_MEDIA_INFO_REC_TYPE,
                                            IID_IMediaInfo, (void**)&pMediaInfo ));
        WsbAffirmHr( pMediaInfo->SetId( l_PrimPos ));
        hr =  pMediaInfo->FindEQ();
        if (S_OK != hr )  {
            hr = HSM_E_VALIDATE_MEDIA_NOT_FOUND;
            WsbAffirmHr(pFsaWorkItem->SetResult(hr));
            WsbThrow(hr);
        }

        WsbTrace( OLESTR("(validateIt) <%s> found in Media Info table, continuing...\n"),
                                            path );

        //
        // Media is in the Media Info Table.  Next step is to verify that the Remote Data
        // Set (in concept equal to a bag) containing this scan item (e.g., file) is
        // actually on the media.
        //
        SHORT                       l_MediaNextRemoteDataSet;

        WsbAffirmHr( pMediaInfo->GetNextRemoteDataSet( &l_MediaNextRemoteDataSet ));
        WsbTrace(
         OLESTR("(validateIt) <%ls>: Bag remote dataset <%hd> Media remote dataset <%hd>\n"),
                      (OLECHAR*)path, l_RemoteDataSet, l_MediaNextRemoteDataSet );
        if ( l_RemoteDataSet >= l_MediaNextRemoteDataSet ) {
            // Remote data set containing the item is not on the media; we have a validate
            // error, so set up to have FSA delete it
            hr = HSM_E_VALIDATE_DATA_NOT_ON_MEDIA;
            WsbAffirmHr(pFsaWorkItem->SetResult(hr));
            WsbTrace( OLESTR("(validateIt) <%s>: remote data set not on media.\n"),
                      path );
            WsbThrow(hr);
        }

        //
        // Now verify that the media manager still knows about the media
        //
        WsbAffirmHr( pMediaInfo->GetMediaSubsystemId( &mediaSubsystemId ));

        if (m_pRmsServer->FindCartridgeById(mediaSubsystemId , &pMedia) != S_OK) {
             hr = HSM_E_VALIDATE_MEDIA_NOT_FOUND;
            WsbAffirmHr(pFsaWorkItem->SetResult(hr));
            WsbThrow(hr);
        }

    } WsbCatch( hr );

    //
    // If item failed to validate it has an invalid reparse point, tell FSA to remove it.
    //

    if (FAILED(hr)) {
        WsbAffirmHr( pFsaWorkItem->SetResultAction( FSA_RESULT_ACTION_VALIDATE_BAD ));
        WsbTrace(OLESTR("<%s> failed validation, result action = Validate Bad.\n"), path);
        // No logging done here.  Logging needs to be added to FSA (ProcessResult()).
        // Clean up hr for return (tell caller this method completed).
        hr = S_OK;

    // Item validated, tell the FSA and do final clean-up checks
    } else try {
        WsbAffirmHr( pFsaWorkItem->SetResultAction( FSA_RESULT_ACTION_VALIDATE_OK ));
        WsbTrace(OLESTR("<%s> passed validation, result action = Validate Ok.\n"), path);

        //
        // If the resource (volume) this item is on doesn't match that stored in the Bag
        // Info Table, add an entry to the Volume Assignment Table
        //
//
// Note: This code is commented out since nobody uses the Volume Assignment table.
//       See bug 159449 in "Windows Bugs" database for more details.
//        
//        if ( !IsEqualGUID( resourceId, l_BagVolId )) {
//            WsbAffirmHr( pSegDb->VolAssignAdd( m_pDbWorkSession, m_BagId, l_FileStart,
//                                               placeholder.fileSize, resourceId));
//            WsbTrace(OLESTR("(validateIt) <%s> volume mismatch. Entered in Vol Asgmnt Table\n"),
//                         path);
//        }

    } WsbCatch( hr );

    WsbTraceOut(OLESTR("CHsmWorkQueue::validateIt"), OLESTR("hr = <%ls>"),
                                                        WsbHrAsString(hr));
    return( hr );
}



HRESULT
CHsmWorkQueue::CheckForChanges(
    IFsaPostIt *pFsaWorkItem
    )
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkQueue::CheckForChanges"),OLESTR(""));

    //
    // Validate that the file is still migratable.  Ask FSA
    // for the latest USN of the file.  If they match, then
    // file is migratable, otherwise it is not.  If it is
    // not change the FSA_RESULT_ACTION to FSA_RESULT_ACTION_NONE.
    // and quit.
    //

    try  {
        CComPtr<IFsaScanItem>      pScanItem;

        // Get a current scan item from the FSA for this work item
        hr = GetScanItem(pFsaWorkItem, &pScanItem);
        if (WSB_E_NOTFOUND == hr)  {
            //
            // We cannot find the file, so just return not OK
            //
            WsbThrow(S_FALSE);
        }

        //
        // Make sure we did not get some other kind of error.
        //
        WsbAffirmHr(hr);


        // Check to see that the file is in the correct
        // state to do the requested action
        //
        FSA_REQUEST_ACTION          workAction;
        WsbAffirmHr(pFsaWorkItem->GetRequestAction(&workAction));
        switch (workAction)  {
            case FSA_REQUEST_ACTION_VALIDATE:
                //
                // No Checks required here
                //
                hr = S_OK;
                break;
            case FSA_REQUEST_ACTION_DELETE:
                //
                // Make it is still OK to delete the file
                //
                WsbAffirmHr(pScanItem->IsDeleteOK(pFsaWorkItem) );
                break;
            case FSA_REQUEST_ACTION_PREMIGRATE:
                //
                // Make sure the file is still manageable by asking the FSA
                //
                WsbAffirmHr(pScanItem->IsMigrateOK(pFsaWorkItem));
                break;
            case FSA_REQUEST_ACTION_FILTER_RECALL:
            case FSA_REQUEST_ACTION_RECALL:
                //
                // Make sure the file is recallable by asking the FSA
                //
                WsbAffirmHr(pScanItem->IsRecallOK(pFsaWorkItem));
                break;
            case FSA_REQUEST_ACTION_FILTER_READ:
                //
                // Cannot check for truncated because the file is open
                //
                hr = S_OK;
                break;
            default:
                hr = E_NOTIMPL;
                break;
        }
    } WsbCatch (hr)

    if (FSA_E_FILE_CHANGED == hr )  {
        hr = HSM_E_FILE_CHANGED;
    } else if (FSA_E_FILE_ALREADY_MANAGED == hr ) {
        hr = HSM_E_FILE_ALREADY_MANAGED;
    } else if (FSA_E_FILE_NOT_TRUNCATED == hr ) {
        hr = HSM_E_FILE_NOT_TRUNCATED;
    }

    WsbTraceOut(OLESTR("CHsmWorkQueue::CheckForChanges"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return( hr );
}




HRESULT
CHsmWorkQueue::RaisePriority(
    void
    )

/*++


--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkQueue::RaisePriority"),OLESTR(""));
    try {

        WsbAssert(0 != m_WorkerThread, E_UNEXPECTED);
        WsbAssert(m_pSession != 0, E_UNEXPECTED);

        switch(m_JobPriority) {

            case HSM_JOB_PRIORITY_IDLE:
                WsbAffirmStatus(SetThreadPriority(m_WorkerThread, THREAD_PRIORITY_LOWEST));
                m_JobPriority = HSM_JOB_PRIORITY_LOWEST;
                break;

            case HSM_JOB_PRIORITY_LOWEST:
                WsbAffirmStatus(SetThreadPriority(m_WorkerThread, THREAD_PRIORITY_BELOW_NORMAL));
                m_JobPriority = HSM_JOB_PRIORITY_LOW;
                break;

            case HSM_JOB_PRIORITY_LOW:
                WsbAffirmStatus(SetThreadPriority(m_WorkerThread, THREAD_PRIORITY_NORMAL));
                m_JobPriority = HSM_JOB_PRIORITY_NORMAL;
                break;

            case HSM_JOB_PRIORITY_NORMAL:
                WsbAffirmStatus(SetThreadPriority(m_WorkerThread, THREAD_PRIORITY_ABOVE_NORMAL));
                m_JobPriority = HSM_JOB_PRIORITY_HIGH;
                break;

            case HSM_JOB_PRIORITY_HIGH:
                WsbAffirmStatus(SetThreadPriority(m_WorkerThread, THREAD_PRIORITY_HIGHEST));
                m_JobPriority = HSM_JOB_PRIORITY_HIGHEST;
                break;

            case HSM_JOB_PRIORITY_HIGHEST:
                WsbAffirmStatus(SetThreadPriority(m_WorkerThread, THREAD_PRIORITY_TIME_CRITICAL));
                m_JobPriority = HSM_JOB_PRIORITY_CRITICAL;
                break;

            default:
            case HSM_JOB_PRIORITY_CRITICAL:
                WsbAffirm(FALSE, E_UNEXPECTED);
                break;
        }

        WsbAffirmHr(m_pSession->ProcessPriority(m_JobPhase, m_JobPriority));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkQueue::RaisePriority"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);
}

HRESULT
CHsmWorkQueue::LowerPriority(
    void
    )

/*++


--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkQueue::LowerPriority"),OLESTR(""));
    try {

        WsbAssert(0 != m_WorkerThread, E_UNEXPECTED);
        WsbAssert(m_pSession != 0, E_UNEXPECTED);

        switch(m_JobPriority) {
            case HSM_JOB_PRIORITY_IDLE:
                WsbAffirm(FALSE, E_UNEXPECTED);
                break;

            case HSM_JOB_PRIORITY_LOWEST:
                WsbAffirmStatus(SetThreadPriority(m_WorkerThread, THREAD_PRIORITY_IDLE));
                m_JobPriority = HSM_JOB_PRIORITY_IDLE;
                break;

            case HSM_JOB_PRIORITY_LOW:
                WsbAffirmStatus(SetThreadPriority(m_WorkerThread, THREAD_PRIORITY_LOWEST));
                m_JobPriority = HSM_JOB_PRIORITY_LOWEST;
                break;

            case HSM_JOB_PRIORITY_NORMAL:
                WsbAffirmStatus(SetThreadPriority(m_WorkerThread, THREAD_PRIORITY_BELOW_NORMAL));
                m_JobPriority = HSM_JOB_PRIORITY_LOW;
                break;

            case HSM_JOB_PRIORITY_HIGH:
                WsbAffirmStatus(SetThreadPriority(m_WorkerThread, THREAD_PRIORITY_NORMAL));
                m_JobPriority = HSM_JOB_PRIORITY_NORMAL;
                break;

            case HSM_JOB_PRIORITY_HIGHEST:
                WsbAffirmStatus(SetThreadPriority(m_WorkerThread, THREAD_PRIORITY_ABOVE_NORMAL));
                m_JobPriority = HSM_JOB_PRIORITY_HIGH;
                break;

            default:
            case HSM_JOB_PRIORITY_CRITICAL:
                WsbAffirmStatus(SetThreadPriority(m_WorkerThread, THREAD_PRIORITY_HIGHEST));
                m_JobPriority = HSM_JOB_PRIORITY_HIGHEST;
                break;
        }

        WsbAffirmHr(m_pSession->ProcessPriority(m_JobPhase, m_JobPriority));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkQueue::LowerPriority"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);
}




HRESULT
CHsmWorkQueue::CheckRms(
    void
    )

/*++


--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkQueue::CheckRms"),OLESTR(""));
    try {
        //
        // Make sure we can still talk to the RMS
        //
        if (m_pRmsServer != 0) {
            CWsbBstrPtr name;
            hr = m_pRmsServer->GetServerName( &name );
            if (hr != S_OK) {
                m_pRmsServer = 0;
                hr = S_OK;
            }
        }
        //
        // Get RMS that runs on this machine
        //
        if (m_pRmsServer == 0)  {
            WsbAffirmHr(m_pServer->GetHsmMediaMgr(&m_pRmsServer));

            // wait for RMS to come ready
            // (this may not be needed anymore - if Rms initialization is
            //  synced with Engine initialization)
            CComObject<CRmsSink> *pSink = new CComObject<CRmsSink>;
            WsbAffirm(0 != pSink, E_OUTOFMEMORY);
            CComPtr<IUnknown> pSinkUnk = pSink; // holds refcount for use here
            WsbAffirmHr( pSink->Construct( m_pRmsServer ) );
            WsbAffirmHr( pSink->WaitForReady( ) );
            WsbAffirmHr( pSink->DoUnadvise( ) );
        }
    } WsbCatch( hr );

    WsbTraceOut(OLESTR("CHsmWorkQueue::CheckRms"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);

}


HRESULT
CHsmWorkQueue::CheckSession(
    IHsmSession *pSession
    )

/*++


--*/
{
    HRESULT                 hr = S_OK;
    BOOL                    bLog = TRUE;

    WsbTraceIn(OLESTR("CHsmWorkQueue::CheckSession"),OLESTR(""));
    try {

        if ((m_pSession != 0) && (m_pSession != pSession))  {
            //Don't expect this queue guy to switch sessions
            WsbTrace(OLESTR("Not Switching sessions at this time so we are failing.\n"));
            WsbThrow( E_UNEXPECTED );
        }

        //
        // Check to see if we have dealt with this or any other session before.
        if (m_pSession == 0)  {
            WsbTrace(OLESTR("New session.\n"));
            //
            // We have no on going session so we need to establish communication
            // with this session.
            //
            CComPtr<IHsmSessionSinkEveryState>  pSinkState;
            CComPtr<IHsmSessionSinkEveryEvent>  pSinkEvent;
            CComPtr<IConnectionPointContainer>  pCPC;
            CComPtr<IConnectionPoint>           pCP;

            // Tell the session we are starting up.
            m_JobState = HSM_JOB_STATE_STARTING;
            WsbTrace(OLESTR("Before Process State.\n"));
            WsbAffirmHr(pSession->ProcessState(m_JobPhase, m_JobState, m_CurrentPath, bLog));
            WsbTrace(OLESTR("After Process State.\n"));

            // Get the interface to the callback that the sessions should use.
            WsbTrace(OLESTR("Before QI's for sinks.\n"));
            WsbAffirmHr(((IUnknown*) (IHsmFsaTskMgr*) this)->QueryInterface(IID_IHsmSessionSinkEveryState, (void**) &pSinkState));
            WsbAffirmHr(((IUnknown*) (IHsmFsaTskMgr*) this)->QueryInterface(IID_IHsmSessionSinkEveryEvent, (void**) &pSinkEvent));
            WsbTrace(OLESTR("After QI's for sinks.\n"));
            // Ask the session to advise of every state changes.
            WsbTrace(OLESTR("Before QI for connection point containers.\n"));
            WsbAffirmHr(pSession->QueryInterface(IID_IConnectionPointContainer, (void**) &pCPC));
            WsbAffirmHr(pCPC->FindConnectionPoint(IID_IHsmSessionSinkEveryState, &pCP));
            WsbAffirmHr(pCP->Advise(pSinkState, &m_StateCookie));
            pCP = 0;
            WsbAffirmHr(pCPC->FindConnectionPoint(IID_IHsmSessionSinkEveryEvent, &pCP));
            WsbAffirmHr(pCP->Advise(pSinkEvent, &m_EventCookie));
            pCP = 0;
            WsbTrace(OLESTR("After Advises.\n"));

            //
            // Get the resource for this work from the session
            //
            WsbAffirmHr(pSession->GetResource(&m_pFsaResource));

            // Since this is a new session, reset the counter that has become our bag start
            // location
            m_RemoteDataSetStart.QuadPart = 0;

            m_JobState = HSM_JOB_STATE_ACTIVE;
            WsbTrace(OLESTR("Before Process State.\n"));
            WsbAffirmHr(pSession->ProcessState(m_JobPhase, m_JobState, m_CurrentPath, bLog));
            WsbTrace(OLESTR("After Process State.\n"));
            m_pSession = pSession;

        }

    } WsbCatch( hr );

    WsbTraceOut(OLESTR("CHsmWorkQueue::CheckSession"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);

}

HRESULT
CHsmWorkQueue::StartNewBag(
    void
    )

/*++


--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IBagInfo>           pBagInfo;

    WsbTraceIn(OLESTR("CHsmWorkQueue::StartNewBag"),OLESTR(""));
    try {
        if (0 == m_RemoteDataSetStart.QuadPart)  {
            //
            // Get a new ID
            //
            WsbAffirmHr(CoCreateGuid(&m_BagId));

            // Add an entry into the Bag Info Table
            FILETIME                birthDate;
            GUID                    resourceId;

            WsbAffirmHr(m_pFsaResource->GetIdentifier(&resourceId));

            WsbAffirmHr(m_pSegmentDb->GetEntity(m_pDbWorkSession, HSM_BAG_INFO_REC_TYPE, IID_IBagInfo,
                    (void**)&pBagInfo));
            GetSystemTimeAsFileTime(&birthDate);

//??? what is the type for this bag? Need a define for Primary bag and Reorg bag
            WsbAffirmHr(pBagInfo->SetBagInfo(HSM_BAG_STATUS_IN_PROGRESS, m_BagId, birthDate, 0, 0, resourceId, 0, 0));
            WsbAffirmHr(pBagInfo->MarkAsNew());
            WsbAffirmHr(pBagInfo->Write());
        }
    } WsbCatch( hr );

    WsbTraceOut(OLESTR("CHsmWorkQueue::StartNewBag"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);

}



HRESULT
CHsmWorkQueue::UpdateBagInfo(
    IHsmWorkItem *pWorkItem
    )

/*++


--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IBagInfo>       pBagInfo;
    CComPtr<IFsaPostIt>     pFsaWorkItem;
    FSA_PLACEHOLDER         placeholder;

    WsbTraceIn(OLESTR("CHsmWorkQueue::UpdateBagInfo"),OLESTR(""));
    try {
        //
        // Get the Bag id from the work item.  It is in the placeholder
        // information in the postit
        //
        WsbAffirmHr(pWorkItem->GetFsaPostIt(&pFsaWorkItem));
        WsbAffirmHr(pFsaWorkItem->GetPlaceholder(&placeholder));

        //
        // Go to the Bag Info database and get the bag for this work
        //
        FILETIME                pDummyFileTime;

        GetSystemTimeAsFileTime(&pDummyFileTime);

        WsbAffirmHr(m_pSegmentDb->GetEntity(m_pDbWorkSession, HSM_BAG_INFO_REC_TYPE, IID_IBagInfo,
                (void**)&pBagInfo));
        WsbAffirmHr(pBagInfo->SetBagInfo(HSM_BAG_STATUS_IN_PROGRESS, placeholder.bagId, pDummyFileTime, 0, 0, GUID_NULL, 0, 0 ));
        WsbAffirmHr(pBagInfo->FindEQ());

        // Update the bag Info table - mostly just change the size of the bag
        FILETIME                birthDate;
        USHORT                  bagType;
        GUID                    bagVolId;
        LONGLONG                bagLength;
        LONGLONG                requestSize;
        LONGLONG                deletedBagAmount;
        SHORT                   remoteDataSet;
        HSM_BAG_STATUS          bagStatus;
        GUID                    bagId;

        WsbAffirmHr(pBagInfo->GetBagInfo(&bagStatus, &bagId, &birthDate,  &bagLength, &bagType, &bagVolId, &deletedBagAmount, &remoteDataSet));
        WsbAffirmHr(pFsaWorkItem->GetRequestSize(&requestSize));
        bagLength += requestSize;
        WsbAffirmHr(pBagInfo->SetBagInfo(bagStatus, bagId, birthDate, bagLength, bagType, bagVolId, deletedBagAmount, remoteDataSet));
        WsbAffirmHr(pBagInfo->Write());

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkQueue::UpdateBagInfo"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);


}

HRESULT
CHsmWorkQueue::CompleteBag( void )
/*++


--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IBagInfo>           pBagInfo;

    WsbTraceIn(OLESTR("CHsmWorkQueue::CompleteBag"),OLESTR(""));
    try {
        //
        // Go to the Bag Info database and get the bag for this work
        //
        FILETIME                pDummyFileTime;

        GetSystemTimeAsFileTime(&pDummyFileTime);

        WsbAffirmHr(m_pSegmentDb->GetEntity(m_pDbWorkSession, HSM_BAG_INFO_REC_TYPE, IID_IBagInfo,
                (void**)&pBagInfo));
        WsbAffirmHr(pBagInfo->SetBagInfo(HSM_BAG_STATUS_IN_PROGRESS, m_BagId, pDummyFileTime, 0, 0, GUID_NULL, 0, 0 ));
        WsbAffirmHr(pBagInfo->FindEQ());

        // Update the bag Info table - mostly just change the size of the bag
        FILETIME                birthDate;
        USHORT                  bagType;
        GUID                    bagVolId;
        LONGLONG                bagLength;
        LONGLONG                deletedBagAmount;
        SHORT                   remoteDataSet;
        HSM_BAG_STATUS          bagStatus;
        GUID                    bagId;

        WsbAffirmHr(pBagInfo->GetBagInfo(&bagStatus, &bagId, &birthDate,  &bagLength, &bagType, &bagVolId, &deletedBagAmount, &remoteDataSet));
        WsbAffirmHr(pBagInfo->SetBagInfo(HSM_BAG_STATUS_COMPLETED, bagId, birthDate, bagLength, bagType, bagVolId, deletedBagAmount, remoteDataSet));
        WsbAffirmHr(pBagInfo->Write());

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkQueue::CompleteBag"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);


}

HRESULT
CHsmWorkQueue::DoWork( void )
/*++


--*/
{
    HRESULT                 hr = S_OK;
    CWsbStringPtr           path;
    CComPtr<IHsmWorkItem>   pWorkItem;
    CComPtr<IFsaPostIt>     pFsaWorkItem;
    CComPtr<IHsmSession>    pSaveSessionPtr;
    HSM_WORK_ITEM_TYPE      workType;
    BOOLEAN                 done = FALSE;
    BOOLEAN                 OpenedDb = FALSE;
    HRESULT                 skipWork = S_FALSE;

    WsbTraceIn(OLESTR("CHsmWorkQueue::DoWork"),OLESTR(""));

    //  Make sure this object isn't released (and our thread killed
    //  before finishing up in this routine
    ((IUnknown*)(IHsmWorkQueue*)this)->AddRef();

    try {
        while (!done) {
            BOOL WaitForMore = FALSE;

            //
            // Get the next work to do from the queue
            //
            hr = m_pWorkToDo->First(IID_IHsmWorkItem, (void **)&pWorkItem);
            if (WSB_E_NOTFOUND == hr)  {
                // There are no entries in the queue so sleep and check
                // again later
                WaitForMore = TRUE;
                hr = S_OK;
            } else if (hr == S_OK)  {
                hr = CheckMigrateMinimums();
                if (S_FALSE == hr) {
                    WaitForMore = TRUE;
                    hr = S_OK;
                }
            }
            WsbAffirmHr(hr);

            if (WaitForMore) {
                if (OpenedDb) {
                    //
                    // Close the db before we wait for more work
                    //
                    hr = m_pSegmentDb->Close(m_pDbWorkSession);
                    OpenedDb = FALSE;
                    m_pDbWorkSession = 0;
                }
                Sleep(1000);
            } else {
                if (!OpenedDb)  {
                    //
                    // Open DB for this thread
                    //
                    hr = m_pSegmentDb->Open(&m_pDbWorkSession);
                    if (S_OK == hr)  {
                        WsbTrace(OLESTR("CHsmWorkQueue::DoWork - Database Opened OK\n"));
                        OpenedDb = TRUE;
                    } else  {
                        //
                        // We cannot open the database - this is a catastrophic
                        // problem.  So skip all work in the queue
                        //
                        WsbTrace(OLESTR("CHsmWorkQueue::DoWork - Database Opened failed with hr = <%ls>\n"), WsbHrAsString(hr));
                        skipWork = HSM_E_WORK_SKIPPED_DATABASE_ACCESS;
                        hr = S_OK;
                    }
                }

                WsbAffirmHr(pWorkItem->GetWorkType(&workType));
                switch (workType) {
                    case HSM_WORK_ITEM_FSA_DONE: {
                        BOOL    bNoDelay = FALSE;   // whether to dismount immediately

                        //
                        // There is no more work to do for this queue
                        //
                        WsbTrace(OLESTR("CHsmWorkQueue::DoWork - FSA WORK DONE\n"));

                        //
                        // Finish any work that needs to be committed
                        // Mark the bag as complete if we are premigrating
                        //
                        if (HSM_JOB_ACTION_PREMIGRATE == m_JobAction)  {
                            try  {
                                WsbAffirmHr(CommitWork());
                                WsbAffirmHr(CompleteBag());
                                //
                                // Now save the databases at the end of the bag
                                // But make sure the begin session was OK.
                                // Note: even if there were errors while storing the data, we still want to try 
                                // keeping the databases on the media, because some files were migrated
                                //
                                if (m_StoreDatabasesInBags && (S_OK == m_BeginSessionHr)) {
                                    WsbAffirmHr(StoreDatabasesOnMedia());
                                }
                            } WsbCatch( hr );

                            // In case of premigrate - dismount immediately
                            bNoDelay = TRUE;
                        }

                        if (HSM_E_WORK_SKIPPED_CANCELLED == skipWork)  {
                            //
                            // Let them know we are cancelled
                            //
                            (void)SetState(HSM_JOB_STATE_CANCELLED);
                        } else  {
                            (void)SetState(HSM_JOB_STATE_DONE);
                        }
                        pSaveSessionPtr = m_pSession;
                        Remove(pWorkItem);

                        EndSessions(FALSE, bNoDelay);

                        // Close the DB
                        if (OpenedDb) {
                            WsbTrace(OLESTR("CHsmWorkQueue::DoWork - Closing the database\n"));
                            m_pSegmentDb->Close(m_pDbWorkSession);
                            OpenedDb = FALSE;
                            m_pDbWorkSession = 0;
                        }
                        m_pTskMgr->WorkQueueDone(pSaveSessionPtr, m_QueueType, NULL);
                        done = TRUE;
                        break;
                    }

                    case HSM_WORK_ITEM_FSA_WORK: {
                        if (S_FALSE == skipWork)  {
                            //
                            // Get the FSA Work Item and do the work
                            //
                            hr = DoFsaWork(pWorkItem);
                            if (hr == RPC_E_DISCONNECTED) {
                              //
                              // This is a problem case. This means the FSA has done away with 
                              // the recall. We would not be able process this recall any more.
                              // Just bail out.
                              //
                              WsbLogEvent(HSM_MESSAGE_ABORTING_RECALL_QUEUE,
                                            0, NULL,NULL);
                              //
                              // Indicate we're done
                              //
                              (void)SetState(HSM_JOB_STATE_DONE);
                              pSaveSessionPtr = m_pSession;
                              Remove(pWorkItem);
                             // Clear out any remaining items in the queue.
                              do {
                                  hr = m_pWorkToDo->First(IID_IHsmWorkItem, (void **)&pWorkItem)  ;
                                  if (hr == S_OK) {
                                      Remove(pWorkItem);
                                  }
                              } while (hr == S_OK);

                              EndSessions(FALSE, FALSE);

                              //
                              // Close the DB
                              //
                              if (OpenedDb) {
                                  WsbTrace(OLESTR("CHsmWorkQueue::DoWork - Closing the database\n"))  ;
                                  m_pSegmentDb->Close(m_pDbWorkSession);
                                  OpenedDb = FALSE;
                                  m_pDbWorkSession = 0;
                              }

                              //
                              // Finish with the queue & get out
                              //
                              m_pTskMgr->WorkQueueDone(pSaveSessionPtr, m_QueueType, NULL);
                              done = TRUE;
                          } else {
                              (void)Remove(pWorkItem);
                          }
                        } else  {
                            //
                            // Skip the work
                            //
                            try  {
                                CComPtr<IFsaScanItem>    pScanItem;

                                WsbAffirmHr(pWorkItem->GetFsaPostIt(&pFsaWorkItem));
                                WsbAffirmHr(GetScanItem(pFsaWorkItem, &pScanItem));

                                WsbAffirmHr(pFsaWorkItem->GetRequestAction(&m_RequestAction));
                                if ((m_RequestAction == FSA_REQUEST_ACTION_FILTER_RECALL) ||
                                    (m_RequestAction ==  FSA_REQUEST_ACTION_FILTER_READ) ||
                                    (m_RequestAction ==  FSA_REQUEST_ACTION_RECALL))  {
                                        hr = pFsaWorkItem->SetResult(skipWork);
                                        if (S_OK == hr)  {
                                            WsbTrace(OLESTR("HSM recall (filter, read or recall) complete, calling FSA\n"));
                                            hr = m_pFsaResource->ProcessResult(pFsaWorkItem);
                                            WsbTrace(OLESTR("FSA ProcessResult returned <%ls>\n"), WsbHrAsString(hr));
                                        }
                                    }

                                // Avoid logging errors if job is just cancelled
                                if (HSM_E_WORK_SKIPPED_CANCELLED != skipWork) {
                                    (void)m_pSession->ProcessHr(m_JobPhase, 0, 0, hr);
                                }

                                WsbAffirmHr(m_pSession->ProcessItem(m_JobPhase,
                                        m_JobAction, pScanItem, skipWork));

                            } WsbCatch( hr );

                            (void)Remove(pWorkItem);
                        }
                        break;
                    }

                    case HSM_WORK_ITEM_MOVER_CANCELLED: {
                        WsbTrace(OLESTR("CHsmWorkQueue::DoWork - Mover Cancelled\n"));
                        try  {
                            //
                            // We are cancelled, so skip all of the rest of the
                            // work in the queue
                            //
                            WsbAffirmHr(MarkQueueAsDone());
                            //
                            // Remove the cancelled work item
                            //
                            Remove(pWorkItem);
                            //
                            // Skip any other work to do
                            //
                            skipWork = HSM_E_WORK_SKIPPED_CANCELLED;

                        } WsbCatch( hr );
                        break;
                    }

                    default: {
                        hr = E_UNEXPECTED;
                        break;
                    }

                }
            }

            pSaveSessionPtr = 0;
            pWorkItem = 0;
            pFsaWorkItem = 0;

            if (m_TerminateQueue) {
                // signaled to terminate the working thread (should be trigerred only in shutdown cases)
                done = TRUE;
            }
        }

    } WsbCatch( hr );

    if (OpenedDb) {
        WsbTrace(OLESTR("CHsmWorkQueue::DoWork - Closing the database\n"));
        m_pSegmentDb->Close(m_pDbWorkSession);
        OpenedDb = FALSE;
        m_pDbWorkSession = 0;
    }

    // Pretend everything is OK
    hr = S_OK;

    //  Release the thread (the thread should terminate on exit
    //  from the routine that called this routine)
    //  In case of termination, the terminating thread will close the handle
    if (! m_TerminateQueue) {
        CloseHandle(m_WorkerThread);
        m_WorkerThread = 0;
    }

    //  Allow this object to be released
    ((IUnknown*)(IHsmWorkQueue*)this)->Release();

    WsbTraceOut(OLESTR("CHsmWorkQueue::DoWork"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);

}

HRESULT
CHsmWorkQueue::DoFsaWork(
    IHsmWorkItem *pWorkItem
)
/*++


--*/
{
    HRESULT                 hr = S_OK;
    HRESULT                 workHr = S_OK;
    HRESULT                 originalHr = S_OK;

    CWsbStringPtr           path;
    FSA_RESULT_ACTION       resultAction;
    CComPtr<IFsaPostIt>     pFsaWorkItem;
    LONGLONG                requestSize;

    WsbTraceIn(OLESTR("CHsmWorkQueue::DoFsaWork"),OLESTR(""));
    try {
        CComPtr<IFsaScanItem>   pScanItem;

        //
        // Do the work.
        //
        WsbAffirmHr(pWorkItem->GetFsaPostIt(&pFsaWorkItem));
        try {
            WsbAffirmHr(pFsaWorkItem->GetRequestAction(&m_RequestAction));
            WsbAffirmHr(pFsaWorkItem->GetPath(&path, 0));
            WsbAffirmHr(GetScanItem(pFsaWorkItem, &pScanItem));
        } WsbCatchAndDo (hr,
                originalHr = hr;

                // Not-found error is expected if the file was renamed or deleted after 
                // the FSA scanning. There is no need to log an error.
                if (hr != WSB_E_NOTFOUND) {
                    if (path == NULL){
                        WsbLogEvent(HSM_MESSAGE_PROCESS_WORK_ITEM_ERROR,
                            sizeof(m_RequestAction), &m_RequestAction, OLESTR("Path is NULL"),
                            WsbHrAsString(hr), NULL);
                    } else {
                        WsbLogEvent(HSM_MESSAGE_PROCESS_WORK_ITEM_ERROR,
                            sizeof(m_RequestAction), &m_RequestAction, (WCHAR *)path,
                            WsbHrAsString(hr), NULL);
                    }
                }

                // Report back to FSA on the error unless the error indiactes 
                // lost of connection with FSA.
                if (hr != RPC_E_DISCONNECTED) {
                    hr = pFsaWorkItem->SetResult(hr);
                    if (hr != RPC_E_DISCONNECTED) {
                        hr = m_pFsaResource->ProcessResult(pFsaWorkItem);
                    }
                }
            );

        if (originalHr != S_OK) {
            goto my_try_exit;
        }

        WsbTrace(OLESTR("Handling file <%s>.\n"), WsbAbbreviatePath(path, 120));
        switch (m_RequestAction) {
            case FSA_REQUEST_ACTION_DELETE:
                m_JobAction = HSM_JOB_ACTION_DELETE;
                hr = E_NOTIMPL;
                break;
            case FSA_REQUEST_ACTION_PREMIGRATE:
                m_JobAction = HSM_JOB_ACTION_PREMIGRATE;
                WsbAffirmHr(pFsaWorkItem->GetRequestSize(&requestSize));
                workHr = PremigrateIt(pFsaWorkItem);
                //
                // Fill in the work item, placeholder information in
                // postit is set by premigrate code.
                //
                WsbAffirmHr(pWorkItem->SetResult(workHr));
                if (S_OK == workHr)  {
                    WsbAffirmHr(pWorkItem->SetMediaInfo(m_MediaId, m_MediaUpdate, m_BadMedia,
                                                        m_MediaReadOnly, m_MediaFreeSpace, m_RemoteDataSet));
                    WsbAffirmHr(pWorkItem->SetFsaResource(m_pFsaResource));
                    //
                    // Copy the work item to the work in waiting queue
                    //
                    WsbAffirmHr(CopyToWaitingQueue(pWorkItem));
                    if (S_OK == TimeToCommit())  {
                        workHr = CommitWork();
                    }
                } else  {
                    WsbTrace(OLESTR("Failed premigrate work.\n"));
                    if (pScanItem)   {
                        WsbAffirmHr(m_pSession->ProcessItem(m_JobPhase,
                                m_JobAction, pScanItem, workHr));
                    }

                    //
                    // An item that was changed while waiting to be migrated is not really an error -
                    // the item is just skipped. Change hr here to avoid unnecessary error message 
                    // and unnecessary count as error in ShouldJobContinue                    
                    // Same is true for file-too-big error
                    //
                    if ((HSM_E_FILE_CHANGED == workHr) || (HSM_E_WORK_SKIPPED_FILE_TOO_BIG == workHr)) {
                        workHr = S_OK;
                    }
                }
                break;
            case FSA_REQUEST_ACTION_FILTER_RECALL:
            case FSA_REQUEST_ACTION_FILTER_READ:
            case FSA_REQUEST_ACTION_RECALL:
                m_JobAction = HSM_JOB_ACTION_RECALL;
                workHr = RecallIt(pFsaWorkItem);
                //
                // Tell the recaller right away about the success or failure
                // of the recall, we do this here so the recall filter can
                // release the open as soon as possible
                //
                hr = pFsaWorkItem->SetResult(workHr);
                if (S_OK == hr)  {
                    WsbTrace(OLESTR("HSM recall (filter, read or recall) complete, calling FSA\n"));
                    hr = m_pFsaResource->ProcessResult(pFsaWorkItem);
                    WsbTrace(OLESTR("FSA ProcessResult returned <%ls>\n"), WsbHrAsString(hr));
                }
                break;
            case FSA_REQUEST_ACTION_VALIDATE:
                m_JobAction = HSM_JOB_ACTION_VALIDATE;
                workHr = validateIt(pFsaWorkItem);
                if (S_OK == workHr)  {
                    WsbAffirmHr(pFsaWorkItem->GetResultAction(&resultAction));
                    if (FSA_RESULT_ACTION_NONE != resultAction)  {
                        WsbTrace(OLESTR("HSM validate complete, calling FSA\n"));
                        hr = m_pFsaResource->ProcessResult(pFsaWorkItem);
                        WsbTrace(OLESTR("FSA ProcessResult returned <%ls>\n"), WsbHrAsString(hr));
                    }
                }
                //
                // Tell the session whether or not the work was done.
                //
                // For validate, we may not have a scan item
                //
                if (pScanItem)     {
                    WsbTrace(OLESTR("Tried HSM work, calling Session to Process Item\n"));
                    m_pSession->ProcessItem(m_JobPhase, m_JobAction, pScanItem, workHr);
                } else {
                    WsbTrace(OLESTR("Couldn't get scan item for validation.\n"));
                }
                break;
            case FSA_REQUEST_ACTION_VALIDATE_FOR_TRUNCATE: {
                HRESULT truncateHr = S_OK;

                m_JobAction = HSM_JOB_ACTION_VALIDATE;
                workHr = validateIt(pFsaWorkItem);
                if (S_OK == workHr)  {
                    WsbAffirmHr(pFsaWorkItem->GetResultAction(&resultAction));
                    if (resultAction == FSA_RESULT_ACTION_VALIDATE_BAD) {
                        WsbAffirmHr( pFsaWorkItem->SetResultAction( FSA_RESULT_ACTION_VALIDATE_FOR_TRUNCATE_BAD ));
                        resultAction = FSA_RESULT_ACTION_VALIDATE_FOR_TRUNCATE_BAD;
                    }
                    if (resultAction == FSA_RESULT_ACTION_VALIDATE_OK) {
                        WsbAffirmHr( pFsaWorkItem->SetResultAction( FSA_RESULT_ACTION_VALIDATE_FOR_TRUNCATE_OK ));
                        resultAction = FSA_RESULT_ACTION_VALIDATE_FOR_TRUNCATE_OK;
                    }

                    if (FSA_RESULT_ACTION_NONE != resultAction)  {
                        WsbTrace(OLESTR("HSM validate for truncate complete, calling FSA\n"));
                        hr = m_pFsaResource->ProcessResult(pFsaWorkItem);
                        WsbTrace(OLESTR("FSA ProcessResult returned <%ls>\n"), WsbHrAsString(hr));

                        if (resultAction == FSA_RESULT_ACTION_VALIDATE_FOR_TRUNCATE_OK) {
                            // Analyze result of truncation: for expected errors, such as file-changed, set to S_FALSE
                            // in order to signal skipping, otherwize leave original error/success code
                            switch (hr) {
                                case FSA_E_ITEMCHANGED:
                                case FSA_E_ITEMINUSE:
                                case FSA_E_NOTMANAGED:
                                case FSA_E_FILE_ALREADY_MANAGED:
                                    truncateHr = S_FALSE;
                                    break;
                                default:
                                    truncateHr = hr;
                                    break;
                            }
                        } else if (resultAction == FSA_RESULT_ACTION_VALIDATE_FOR_TRUNCATE_BAD) {
                            // Set truncateHr to S_FALSE to signal for skipping this file in regards to truncation
                            truncateHr = S_FALSE;
                        }
                    }
                }
                //
                // Tell the session whether or not the work was done.
                //
                // For validate, we may not have a scan item
                //
                if (pScanItem)     {
                    WsbTrace(OLESTR("Tried HSM work, calling Session to Process Item\n"));
                    //
                    // For validate, the work-hr is always set to OK, therefore report on the truncate-hr instead
                    //
                    m_pSession->ProcessItem(m_JobPhase, m_JobAction, pScanItem, truncateHr);
                } else {
                    WsbTrace(OLESTR("Couldn't get scan item for validation.\n"));
                }
                break;
                }

            default:
                m_JobAction = HSM_JOB_ACTION_UNKNOWN;
                hr = E_NOTIMPL;
                break;
            }

        if (S_OK != workHr)  {

            // Replace to a specific RSS error codes for some errors
            switch (HRESULT_CODE(workHr)) {
            case ERROR_LOCK_VIOLATION:
                workHr = HSM_E_FILE_LOCK_VIOLATION;
                break;
            case ERROR_SHARING_VIOLATION:
                workHr = HSM_E_FILE_SHARING_VIOLATION;
                break;
            }

            // Tell the session how things went if they didn't go well.
            (void) m_pSession->ProcessHr(m_JobPhase, 0, 0, workHr);
        }

        //
        // Now, evaluate the work result to see if we should fail the job.
        //
        (void)ShouldJobContinue(workHr);

        my_try_exit:
        ;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkQueue::DoFsaWork"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);

}


HRESULT
CHsmWorkQueue::UpdateMetaData(
    IHsmWorkItem *pWorkItem
    )

/*++


--*/
{
    HRESULT                 hr = S_OK;
    BOOL                    transactionBegun = FALSE;

    WsbTraceIn(OLESTR("CHsmWorkQueue::UpdateMetaData"),OLESTR(""));
    try {
        //
        // Start transaction
        //
        WsbAffirmHr(m_pDbWorkSession->TransactionBegin());
        transactionBegun = TRUE;

        //
        // Update the various metadata records
        //
        WsbAffirmHr(UpdateBagInfo(pWorkItem));
        WsbAffirmHr(UpdateSegmentInfo(pWorkItem));
        WsbAffirmHr(UpdateMediaInfo(pWorkItem));

        //
        // End transaction
        //
        WsbAffirmHr(m_pDbWorkSession->TransactionEnd());
        transactionBegun = FALSE;

    } WsbCatchAndDo( hr, if (transactionBegun == TRUE)  {m_pDbWorkSession->TransactionCancel();});

    WsbTraceOut(OLESTR("CHsmWorkQueue::UpdateMetaData"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);
}



HRESULT
CHsmWorkQueue::UpdateSegmentInfo(
    IHsmWorkItem *pWorkItem
    )

/*++


--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkQueue::UpdateSegmentInfo"),OLESTR(""));
    try {
        // Add a record to the segment database or extend an existing one
        CComQIPtr<ISegDb, &IID_ISegDb> pSegDb = m_pSegmentDb;
        BOOLEAN                 done = FALSE;
        FSA_PLACEHOLDER         placeholder;
        CComPtr<IFsaPostIt>     pFsaWorkItem;

        //
        // Get the placeholder information from the postit in the work item
        //
        WsbAffirmHr(pWorkItem->GetFsaPostIt(&pFsaWorkItem));
        WsbAffirmHr(pFsaWorkItem->GetPlaceholder(&placeholder));
        WsbAssert(0 != m_RemoteDataSetStart.QuadPart, WSB_E_INVALID_DATA);

        WsbTrace(OLESTR("Adding SegmentRecord: <%ls>, <%ls>, <%ls>\n"),
                    WsbGuidAsString(placeholder.bagId),
                    WsbStringCopy(WsbLonglongAsString(placeholder.fileStart)),
                    WsbStringCopy(WsbLonglongAsString(placeholder.fileSize)));
        WsbAffirmHr(pSegDb->SegAdd(m_pDbWorkSession, placeholder.bagId, placeholder.fileStart,
                placeholder.fileSize, m_MediaId, m_RemoteDataSetStart.QuadPart));

    } WsbCatch( hr );

    WsbTraceOut(OLESTR("CHsmWorkQueue::UpdateSegmentInfo"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);
}



HRESULT
CHsmWorkQueue::UpdateMediaInfo(
    IHsmWorkItem *pWorkItem
    )

/*++


--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkQueue::UpdateMediaInfo"),OLESTR(""));
    try
    {
        LONGLONG                mediaCapacity;
        CComPtr<IFsaPostIt>     pFsaWorkItem;
        CComPtr<IMediaInfo>     pMediaInfo;
        GUID                    l_MediaId;          // HSM Engine Media ID
        FILETIME                l_MediaLastUpdate;  // Last update of copy
        HRESULT                 l_MediaLastError;   // S_OK or the last exception
                                                    // ..encountered when accessing
                                                    // ..the media
        BOOL                    l_MediaRecallOnly;  // True if no more data is to
                                                    // ..be premigrated to the media
                                                    // ..Set by internal operations,
                                                    // ..may not be changed externally
        LONGLONG                l_MediaFreeBytes;   // Real free space on media
        short                   l_MediaRemoteDataSet;
        HRESULT                 currentMediaLastError;

        //
        // Get the PostIt and the media information for the work item
        //
        WsbAffirmHr(pWorkItem->GetFsaPostIt(&pFsaWorkItem));
        WsbAffirmHr(pWorkItem->GetMediaInfo(&l_MediaId, &l_MediaLastUpdate,
                            &l_MediaLastError, &l_MediaRecallOnly,
                            &l_MediaFreeBytes, &l_MediaRemoteDataSet));
        //
        // Update the media information with the name, used space, and free space of
        // the media.
        //
        WsbAffirmHr(m_pSegmentDb->GetEntity(m_pDbWorkSession, HSM_MEDIA_INFO_REC_TYPE, IID_IMediaInfo,
                (void**)&pMediaInfo));

        WsbAffirmHr(pMediaInfo->SetId(l_MediaId));
        WsbAffirmHr(pMediaInfo->FindEQ());
        WsbAffirmHr(pMediaInfo->SetUpdate(l_MediaLastUpdate));
        WsbAffirmHr(pMediaInfo->SetFreeBytes(l_MediaFreeBytes));
        WsbAffirmHr(pMediaInfo->SetNextRemoteDataSet(l_MediaRemoteDataSet));

        // Avoid setting last error if the existing one already indicates an error
        WsbAffirmHr(pMediaInfo->GetLastError(&currentMediaLastError));
        if (SUCCEEDED(currentMediaLastError)) {
            WsbAffirmHr(pMediaInfo->SetLastError(l_MediaLastError));
        }

        // Mark the media as RecallOnly if it's mostly full (passed the high watermark level)
        WsbAffirmHr(pMediaInfo->GetCapacity(&mediaCapacity));
        if (l_MediaRecallOnly || (l_MediaFreeBytes < ((mediaCapacity * m_MaxFreeSpaceInFullMedia) / 100) )) {
            WsbAffirmHr(pMediaInfo->SetRecallOnlyStatus(TRUE));

            WsbTrace(OLESTR("CHsmWorkQueue::UpdateMediaInfo: Marking media as Recall Only - Capacity = %I64d, Free Bytes = %I64d\n"), 
                mediaCapacity, l_MediaFreeBytes);

/*** If we like to allocate immediately a second side of a full meida, than the code below should be completed...
            if (S_OK == m_pRmsServer->IsMultipleSidedMedia(m_RmsMediaSetId)) {

                // Check if second size is avalaible for allocation

                // Allocate (non-blocking) the second side

            }   ***/

        }
        WsbAffirmHr(pMediaInfo->UpdateLastKnownGoodMaster());
        WsbAffirmHr(pMediaInfo->Write());

    } WsbCatch( hr );

    WsbTraceOut(OLESTR("CHsmWorkQueue::UpdateMediaInfo"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);
}



HRESULT
CHsmWorkQueue::GetMediaSet(
    IFsaPostIt *pFsaWorkItem
    )

/*++


--*/
{
    HRESULT                 hr = S_OK;
    GUID                    storagePoolId;

    WsbTraceIn(OLESTR("CHsmWorkQueue::GetMediaSet"),OLESTR(""));
    try {
        CComPtr<IHsmStoragePool>    pStoragePool1;
        CComPtr<IHsmStoragePool>    pStoragePool2;
        WsbAffirmHr(m_pHsmServerCreate->CreateInstance(CLSID_CHsmStoragePool, IID_IHsmStoragePool,
                                                        (void **)&pStoragePool1));
        WsbAffirmHr(pFsaWorkItem->GetStoragePoolId(&storagePoolId));
        WsbAffirmHr(pStoragePool1->SetId(storagePoolId));
        WsbAffirmHr(m_pStoragePools->Find(pStoragePool1, IID_IHsmStoragePool, (void **) &pStoragePool2));
        //
        // If the storage pool cannot be found, make it a meaningful message
        //
        m_RmsMediaSetName.Free();
        hr = pStoragePool2->GetMediaSet(&m_RmsMediaSetId, &m_RmsMediaSetName);
        if (S_OK != hr)  {
            hr = HSM_E_STG_PL_NOT_FOUND;
        }

    } WsbCatch( hr );

    WsbTraceOut(OLESTR("CHsmWorkQueue::GetMediaSet"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);
}


HRESULT
CHsmWorkQueue::FindMigrateMediaToUse(
    IFsaPostIt *pFsaWorkItem,
    GUID       *pMediaToUse,
    GUID       *pFirstSideToUse,
    BOOL       *pMediaChanged,
    LONGLONG   *pRequiredSize
    )

/*++


--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkQueue::FindMigrateMediaToUse"),OLESTR(""));
    try {
        BOOLEAN                 found = FALSE;
        GUID                    mediaId;
        GUID                    storageId;
        GUID                    storagePoolId;
        CComPtr<IMediaInfo>     pMediaInfo;
        LONGLONG                requestSize;

        DWORD                   dwMediaCount= 0;

        // data of alternative (offline or busy) media to use
        GUID                    alternativeMediaId = GUID_NULL;
        GUID                    alternativeMediaToUse = GUID_NULL;
        CWsbStringPtr           alternativeMediaName;
        HSM_JOB_MEDIA_TYPE      alternativeMediaType = HSM_JOB_MEDIA_TYPE_UNKNOWN;
        SHORT                   alternativeRemoteDataSet= 0;

        // data of meida candidates for second-side allocation
        BOOL                    bTwoSidedMedias = FALSE;
        CComPtr<IWsbCollection> pFirstSideCollection;
        CComPtr<IWsbGuid>       pFirstSideGuid;
        GUID                    firstSideGuid;


        WsbAssert(pMediaToUse != 0, E_POINTER);
        *pMediaToUse = GUID_NULL;
        WsbAssert(pFirstSideToUse != 0, E_POINTER);
        *pFirstSideToUse = GUID_NULL;
        WsbAssert(pMediaChanged != 0, E_POINTER);
        *pMediaChanged = FALSE;
        WsbAssert(pRequiredSize != 0, E_POINTER);
        *pRequiredSize = 0;

        // Determine how much space we need on the media for this file
        // (we add some for overhead)
        WsbAffirmHr(pFsaWorkItem->GetRequestSize(&requestSize));
        requestSize += HSM_STORAGE_OVERHEAD;
        *pRequiredSize = (requestSize * 100) / (100 - m_MinFreeSpaceInFullMedia);    // relevant for new media
        WsbTrace(OLESTR("CHsmWorkQueue::FindMigrateMediaToUse: size needed (with overhead) =%ls, free space on media = %ls\n"),
                WsbQuickString(WsbLonglongAsString(requestSize)),
                WsbQuickString(WsbLonglongAsString(m_MediaFreeSpace)));

        // Set up for search
        WsbAffirmHr(m_pSegmentDb->GetEntity(m_pDbWorkSession, HSM_MEDIA_INFO_REC_TYPE, IID_IMediaInfo,
                (void**)&pMediaInfo));
        WsbAffirmHr(pFsaWorkItem->GetStoragePoolId(&storagePoolId));

        // If we already have media mounted, use it if possible
        if (GUID_NULL != m_MountedMedia && !m_MediaReadOnly && 
            (m_MediaFreeSpace > requestSize) && 
            ((m_MediaFreeSpace - requestSize) > ((m_MediaCapacity * m_MinFreeSpaceInFullMedia) / 100)) ) {

            // Make sure the storage pool is correct
            WsbAffirmHr(pMediaInfo->SetId(m_MediaId));
            WsbAffirmHr(pMediaInfo->FindEQ());
            WsbAffirmHr(pMediaInfo->GetStoragePoolId(&storageId));
            if ((storageId == storagePoolId)) {
                found = TRUE;
            }
        }

        if (!found) {
            // Not found ==> going to use a new media
            *pMediaChanged = TRUE;

            // If there's currently a mounted media and we aren't going to use it, 
            // make sure work is committed and media is dismounted
            if (GUID_NULL != m_MountedMedia) {
                WsbTrace(OLESTR("CHsmWorkQueue::FindMigrateMediaToUse: Dismounting current media - Capacity = %I64d, Free Bytes = %I64d\n"), 
                    m_MediaCapacity, m_MediaFreeSpace);

                WsbAffirmHr(CommitWork());
                WsbAffirmHr(DismountMedia(TRUE));
            }
        }

        // Search for a media
        if (!found) {
            LONGLONG            freeSpace;
            LONGLONG            mediaCapacity;
            BOOL                readOnly;
            HRESULT             hrLastError;
            BOOL                bDataForOffline = FALSE;

            // Check if we deal with two-sided medias
            if (S_OK == m_pRmsServer->IsMultipleSidedMedia(m_RmsMediaSetId)) {
                bTwoSidedMedias = TRUE;
                WsbAffirmHr(m_pHsmServerCreate->CreateInstance(CLSID_CWsbOrderedCollection,
                                                    IID_IWsbCollection, (void **)&pFirstSideCollection));
            }

            // Search media table through all previously used media
            for (hr = pMediaInfo->First(); S_OK == hr;
                     hr = pMediaInfo->Next()) {

                // TEMPORARY - Just for debugging
                {
                    CWsbStringPtr   debugMediaName;
                    GUID            debugSubsystemId;
                    CHAR            *buff = NULL;
                    WsbAffirmHr(pMediaInfo->GetMediaSubsystemId(&debugSubsystemId));
                    debugMediaName.Free();
                    WsbAffirmHr(pMediaInfo->GetDescription(&debugMediaName,0));
                    WsbTraceAlways(OLESTR("RANK: Checking media <%ls> <%ls>\n"),
                        WsbGuidAsString(debugSubsystemId), (WCHAR *)debugMediaName);
                    debugMediaName.CopyTo (&buff);
                    if (buff)
                        WsbFree(buff);
                }

                WsbAffirmHr(pMediaInfo->GetStoragePoolId(&storageId));
                WsbAffirmHr(pMediaInfo->GetFreeBytes(&freeSpace));
                WsbAffirmHr(pMediaInfo->GetRecallOnlyStatus(&readOnly));
                WsbAffirmHr(pMediaInfo->GetCapacity(&mediaCapacity));
                WsbAffirmHr(pMediaInfo->GetLastError(&hrLastError));
                WsbTrace( OLESTR("Looking for storagePool <%ls> and freeSpace <%ls>.\n"),
                        WsbGuidAsString(storagePoolId),
                        WsbLonglongAsString(requestSize));
                WsbTrace( OLESTR("Found media with storagePool <%ls>, freeSpace <%ls> and read only <%ls>.\n"),
                        WsbGuidAsString(storageId),
                        WsbLonglongAsString(freeSpace),
                        WsbBoolAsString(readOnly));

                // Reject media if it's ReadOnly or not from the right pool
                if ((readOnly && (hrLastError != S_OK)) || (storageId != storagePoolId)) {
                    continue;
                }

                // Check full & mostly full condition & free space 
                // Note: a medias which is read-only because  it's bad, is rejected in the previous if
                if (readOnly || (freeSpace <= requestSize) ||
                    ((freeSpace - requestSize) < ((mediaCapacity * m_MinFreeSpaceInFullMedia) / 100)) ) {

                    // In case of two-sided medias, such a media is candidate for second side allocation
                    //  (but only if capacity of first side is large enough...)
                    if (bTwoSidedMedias && (*pRequiredSize < mediaCapacity)) {
        			    WsbAffirmHr(pMediaInfo->GetMediaSubsystemId(&firstSideGuid));
                        WsbAffirmHr(m_pHsmServerCreate->CreateInstance(CLSID_CWsbGuid, IID_IWsbGuid, (void**) &pFirstSideGuid));
                        WsbAffirmHr(pFirstSideGuid->SetGuid(firstSideGuid));
                        WsbAffirmHr(pFirstSideCollection->Add(pFirstSideGuid));
                        pFirstSideGuid = 0;
                    }

                    continue;
                }

                // get media status data
                DWORD dwStatus;
                GUID mediaSubsystemId;
				HRESULT hrStat;
			    WsbAffirmHr(pMediaInfo->GetMediaSubsystemId(&mediaSubsystemId));
				hrStat = m_pRmsServer->FindCartridgeStatusById(mediaSubsystemId ,&dwStatus);
				if (hrStat != S_OK) {
                    WsbTraceAlways(OLESTR("FindMigrateMediaToUse: Skipping media <%ls> (failed to retrieve its status)\n"),
                        WsbGuidAsString(mediaSubsystemId));
					continue;
				}

                // If media disabled - skip it
                if (!(dwStatus & RMS_MEDIA_ENABLED)) {
                    continue;
                }

                // From this point, the media is considered as a valid R/W media and should
                //  be counted as such
                dwMediaCount++;

                if ((dwStatus & RMS_MEDIA_ONLINE) && (dwStatus & RMS_MEDIA_AVAILABLE)) {
                    // Check if media is in the process of mounting: 
                    //  if so, it is also considered a busy media
                    CComPtr<IWsbIndexedCollection>  pMountingCollection;
                    CComPtr<IMountingMedia>         pMountingMedia;
                    CComPtr<IMountingMedia>         pMediaToFind;

                    // Lock mounting media while searching the collection
                    WsbAffirmHr(m_pServer->LockMountingMedias());

                    try {
                        WsbAffirmHr(m_pServer->GetMountingMedias(&pMountingCollection));
                        WsbAffirmHr(CoCreateInstance(CLSID_CMountingMedia, 0, CLSCTX_SERVER, IID_IMountingMedia, (void**)&pMediaToFind));
                        WsbAffirmHr(pMediaToFind->SetMediaId(mediaSubsystemId));
                        hr = pMountingCollection->Find(pMediaToFind, IID_IMountingMedia, (void **)&pMountingMedia);

                        if (hr == S_OK) {
                            // Media is mounting...

                            // Consider adding here a check for media type and reason for mounting:
                            //  If it's direct-access and mounting for read, it's not really busy
                            //
                            //  Problem: for already mounted media, we don't track the mount reason (read or write)
                            //  
                            // Also, one could argue that if we are below the concurrency limit, for better performance,
                            //  we better use a different media, even if it's a direct-access media mounted for read

                            dwStatus &= ~ RMS_MEDIA_AVAILABLE;
                            pMountingMedia = 0;

                        } else if (hr == WSB_E_NOTFOUND) {
                            hr = S_OK;
                        }

                    } WsbCatch(hr);

                    m_pServer->UnlockMountingMedias();

                    if (! SUCCEEDED(hr)) {
                        WsbTraceAlways(OLESTR("CHsmWorkQueue::FindMigrateMediaToUse: Failed to check mounting media, hr= <%ls>\n"),
                                        WsbHrAsString(hr));
                    }
                }

                if ((dwStatus & RMS_MEDIA_ONLINE) && (dwStatus & RMS_MEDIA_AVAILABLE)) {
                    // found a media to use
                    found = TRUE;
                    break;
                } else {
                    // Save up to one offline or one busy media, because we may have to use it...
                    //  Priority is given to offline medias over busy medias.
                    if ((alternativeMediaId != GUID_NULL) && bDataForOffline) {
                        // Already Have best alternative media
                        continue;
                    }
                    if ((alternativeMediaId != GUID_NULL) && (dwStatus & RMS_MEDIA_ONLINE)) {
                        // Media is busy, can't improve the alternative
                        continue;
                    }
                    // Determine which kind of alternative media are we saving
                    if (dwStatus & RMS_MEDIA_ONLINE) {
                        bDataForOffline = FALSE;
                    } else {
                        bDataForOffline = TRUE;
                    }

                    // Save data for alternative media
                    WsbAffirmHr(pMediaInfo->GetId(&alternativeMediaId));
                    WsbAffirmHr(pMediaInfo->GetMediaSubsystemId(&alternativeMediaToUse));
                    alternativeMediaName.Free();
                    WsbAffirmHr(pMediaInfo->GetDescription(&alternativeMediaName,0));
                    WsbAffirmHr(pMediaInfo->GetType(&alternativeMediaType));
                    WsbAffirmHr(pMediaInfo->GetNextRemoteDataSet(&alternativeRemoteDataSet));
                }

            }

            // If we fell out of the loop because we ran out of media
            // in our list, reset the HRESULT
            if (hr == WSB_E_NOTFOUND) {
                hr = S_OK;
            } else {
                WsbAffirmHr(hr);
            }
        }

        // If we found a media to use, save information
        if (found) {
            WsbAffirmHr(pMediaInfo->GetId(&mediaId));
            WsbAffirmHr(pMediaInfo->GetMediaSubsystemId(pMediaToUse));
            if (mediaId != m_MediaId) {
                m_MediaId = mediaId;
                m_MediaName.Free();
                WsbAffirmHr(pMediaInfo->GetDescription(&m_MediaName,0));
                WsbAffirmHr(pMediaInfo->GetType(&m_MediaType));
                WsbAffirmHr(pMediaInfo->GetNextRemoteDataSet(&m_RemoteDataSet));
            }
        //
        // If we didn't find a media to use, check whether we should
        //  1. Choose to allocate a second side of a full media (only for 2-sided medias)
        //  2. Clear the information so we'll get a new piece of media
        //  2. Return the id of an offline or busy R/W meida
        } else {
            
            if (bTwoSidedMedias) {
                try {
                    // Go over the candidates, look for one with valid and non-allocated second side
                    CComPtr<IWsbEnum>   pEnumIds;
                    GUID                secondSideGuid;
                    BOOL                bValid;

                    WsbAffirmHr(pFirstSideCollection->Enum(&pEnumIds));
                    for (hr = pEnumIds->First(IID_IWsbGuid, (void**) &pFirstSideGuid);
                         (hr == S_OK);
                         hr = pEnumIds->Next(IID_IWsbGuid, (void**) &pFirstSideGuid)) {

                        WsbAffirmHr(pFirstSideGuid->GetGuid(&firstSideGuid));
                        WsbAffirmHr(m_pRmsServer->CheckSecondSide(firstSideGuid, &bValid, &secondSideGuid));
                        if (bValid && (GUID_NULL == secondSideGuid)) {
                            // Found a valid & non-allocated second side - verify fisrt side status
                            DWORD status;
            				WsbAffirmHr(m_pRmsServer->FindCartridgeStatusById(firstSideGuid ,&status));
                            if ((status & RMS_MEDIA_ENABLED) && (status & RMS_MEDIA_ONLINE)) {
                                *pFirstSideToUse = firstSideGuid;
                                break;
                            }
                        }

                        pFirstSideGuid = 0;
                    }

                    if (hr == WSB_E_NOTFOUND) {
                        hr = S_OK;
                    }

                } WsbCatchAndDo(hr,
                        WsbTraceAlways(OLESTR("FindMigrateMediaToUse: Skipping search for second side allocation, hr=<%ls>\n"),
                                    WsbHrAsString(hr));
                        hr = S_OK;
                    );

            }  // if two sides

            // Get max number for R/W medias
            DWORD           dwMaxMedia;
            WsbAffirmHr(m_pServer->GetCopyFilesLimit(&dwMaxMedia));

            if ((*pFirstSideToUse != GUID_NULL) || (dwMediaCount < dwMaxMedia) || (alternativeMediaId == GUID_NULL)) {
                // Allowed to allocate a new piece of media OR no alternative media found OR second side found
                m_MediaType = HSM_JOB_MEDIA_TYPE_UNKNOWN;
                WsbAffirmHr(BuildMediaName(&m_MediaName));
                m_MediaReadOnly = FALSE;
            } else {
                // Use the alternative (which is offline or busy) R/W media
                *pMediaToUse = alternativeMediaToUse;
                if (alternativeMediaId != m_MediaId) {
                    m_MediaId = alternativeMediaId;
                    m_MediaName.Free();
                    alternativeMediaName.CopyTo(&m_MediaName);
                    m_MediaType = alternativeMediaType;
                    m_RemoteDataSet = alternativeRemoteDataSet;
                }
            }
        }

        alternativeMediaName.Free();
        if (pFirstSideCollection) {
            WsbAffirmHr(pFirstSideCollection->RemoveAllAndRelease());
        }

    } WsbCatch( hr );

    WsbTraceOut(OLESTR("CHsmWorkQueue::FindMigrateMediaToUse"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);
}



HRESULT
CHsmWorkQueue::MountMedia(
    IFsaPostIt *pFsaWorkItem,
    GUID       mediaToMount,
    GUID       firstSide,
    BOOL       bShortWait,
    BOOL       bSerialize,
    LONGLONG   llFreeSpace
    )

/*++


--*/
{
    HRESULT                 hr = S_OK;
    GUID                    l_MediaToMount = mediaToMount;
    CComPtr<IRmsDrive>      pDrive;
    CWsbBstrPtr             pMediaName;
    DWORD                   dwOptions = RMS_NONE;

    WsbTraceIn(OLESTR("CHsmWorkQueue::MountMedia"),OLESTR("Display Name = <%ls>"), (WCHAR *)m_MediaName);
    try {
        // If we're switching tapes, dismount the current one
        if ((m_MountedMedia != l_MediaToMount) && (m_MountedMedia != GUID_NULL)) {
            WsbAffirmHr(DismountMedia());
        }

        // Ask RMS for short timeout, both for Mount and Allocate
        if (bShortWait) {
            dwOptions |= RMS_SHORT_TIMEOUT;
        }

        // Ask RMS to serialize mounts if required
        if (bSerialize) {
            dwOptions |= RMS_SERIALIZE_MOUNT;
        }

        // Ask RMS to fail scratch media alocation if all free media aren't big enough
        //  (In that case, MountScratchCartridge should fail with RMS_E_SCRATCH_NOT_FOUND_TOO_SMALL error)
        dwOptions |= RMS_FAIL_ALLOCATE_ON_SIZE;

        if (l_MediaToMount == GUID_NULL) {
            CComPtr<IRmsCartridge>      pCartridge;
            CComPtr<IMediaInfo>         pMediaInfo;
            CWsbBstrPtr                 displayName;

            //
            // We are mounting scratch media so we provide the name and then need to find
            // out the type of what got mounted
            //
            WsbTrace( OLESTR("Mounting Scratch Media <%ls>.\n"), (WCHAR *)m_MediaName );
            displayName = m_MediaName;
            ReportMediaProgress(HSM_JOB_MEDIA_STATE_MOUNTING, hr);
            LONGLONG freeSpace = llFreeSpace;  // Get input free space from caller (default is 0)
            hr = m_pRmsServer->MountScratchCartridge( &l_MediaToMount, m_RmsMediaSetId, firstSide, &freeSpace, 0, displayName, &pDrive, &m_pRmsCartridge, &m_pDataMover, dwOptions );
            hr = TranslateRmsMountHr(hr);
            if (FAILED(hr)) {
                m_ScratchFailed = TRUE;
            } else {
                m_ScratchFailed = FALSE;
            }

            // Update max media capacity for future migration jobs (ignore errors)
            DWORD dummy;
            m_pServer->UpdateMediaSizeLimit(&dummy);

            // Check mount-scratch hr
            WsbAffirmHr(hr);
            WsbTrace( OLESTR("Mount Scratch completed.\n") );
            m_MountedMedia = l_MediaToMount;

            //
            // Add a new Media
            //
            WsbAffirmHr(StartNewMedia(pFsaWorkItem));

            if (m_RequestAction == FSA_REQUEST_ACTION_PREMIGRATE)  {
                //
                // Start a new Bag to receive data
                //
                WsbAffirmHr(StartNewBag());

                //
                // Start a new session for the bag
                //
                WsbAffirmHr(StartNewSession());

                // Getting media parameters after we start a new session ensures updated data
                //  (No need to supply default free-space - if driver doesn't support this info,
                //   mover will set free space to capacity. This is what we want for new media).
                WsbAffirmHr(GetMediaParameters());
            }

            //
            // Now check the capacity of the media and the size of the
            // file to see if the file can even fit on this scratch
            // media.  If not, return the error.
            //
            LONGLONG                requestSize;
            WsbAffirmHr(pFsaWorkItem->GetRequestSize(&requestSize));

            if ((requestSize  + HSM_STORAGE_OVERHEAD) > m_MediaCapacity) {
               WsbThrow( HSM_E_WORK_SKIPPED_FILE_BIGGER_MEDIA );
            }

        } else {
            if (m_MountedMedia != l_MediaToMount) {
                ReportMediaProgress(HSM_JOB_MEDIA_STATE_MOUNTING, hr);
                hr = m_pRmsServer->MountCartridge( l_MediaToMount, &pDrive, &m_pRmsCartridge, &m_pDataMover, dwOptions );
                hr = TranslateRmsMountHr(hr);
                //
                //  If failure is because cartridge is disabled, need to get media label to put in error.
                //
                if (hr == RMS_E_CARTRIDGE_DISABLED) {

                    // Since this is just to get label, if any of these functions fail,
                    // don't throw, error will simply have blank label.
                    //
                    CComPtr<IRmsCartridge>  pMedia;
                    HRESULT                 hrName;

                    hrName = m_pRmsServer->FindCartridgeById(l_MediaToMount , &pMedia);
                    if (hrName == S_OK) {
                        hrName = pMedia->GetName(&pMediaName);
                    }
                    if ((hrName != S_OK) || ((WCHAR *)pMediaName == NULL)) {
                        // Cannot get media name - set to blanks
                        pMediaName = L"";
                    }

                    WsbThrow(hr);
                }

                WsbAffirmHr(hr);
                m_MountedMedia = l_MediaToMount;
                WsbTrace( OLESTR("Mount completed.\n") );

                if (m_RequestAction == FSA_REQUEST_ACTION_PREMIGRATE)  {
                    //
                    // Start a new Bag since bags can't yet span media.
                    //
                    WsbAffirmHr(StartNewBag());

                    //
                    // Start a session
                    WsbAffirmHr(StartNewSession());
                }

                // Getting media parameters after we start a new session ensures updated data
                LONGLONG internalFreeSpace;
                WsbAffirmHr(GetMediaFreeSpace(&internalFreeSpace));
                WsbAffirmHr(GetMediaParameters(internalFreeSpace));
            }
        }
    } WsbCatchAndDo(hr,
            switch (hr) {
            case HSM_E_STG_PL_NOT_CFGD:
            case HSM_E_STG_PL_INVALID:
                FailJob();
                break;

            case RMS_E_CARTRIDGE_DISABLED:
                if ((WCHAR *)pMediaName == NULL) {
                    pMediaName = L"";
                }
                WsbLogEvent(HSM_MESSAGE_MEDIA_DISABLED, 0, NULL, pMediaName, NULL);
                break;

            default:
                break;
            }
        );

    WsbTraceOut(OLESTR("CHsmWorkQueue::MountMedia"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);
}



HRESULT
CHsmWorkQueue::MarkMediaFull(
    IFsaPostIt* /*pFsaWorkItem*/,
    GUID        mediaId
    )

/*++


--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkQueue::MarkMediaFull"),OLESTR(""));
    try {
        //
        // Update the media database
        //

        CComPtr<IMediaInfo>     pMediaInfo;

        WsbAffirmHr(m_pSegmentDb->GetEntity(m_pDbWorkSession, HSM_MEDIA_INFO_REC_TYPE, IID_IMediaInfo,
                (void**)&pMediaInfo));
        WsbAffirmHr(pMediaInfo->SetId(mediaId));
        WsbAffirmHr(pMediaInfo->FindEQ());
        m_MediaReadOnly = TRUE;
        WsbAffirmHr(pMediaInfo->SetRecallOnlyStatus(m_MediaReadOnly));
        WsbAffirmHr(pMediaInfo->UpdateLastKnownGoodMaster());
        WsbAffirmHr(pMediaInfo->Write());

/*** If we like to allocate immediately a second side of a full meida, than the code below should be completed...

        if (S_OK == m_pRmsServer->IsMultipleSidedMedia(m_RmsMediaSetId)) {

            // Check if second size is avalaible for allocation

            // Allocate (non-blocking) the second side

        }   ***/

    } WsbCatch( hr );

    WsbTraceOut(OLESTR("CHsmWorkQueue::MarkMediaFull"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);
}

HRESULT
CHsmWorkQueue::MarkMediaBad(
    IFsaPostIt * /*pFsaWorkItem */,
    GUID        mediaId,
    HRESULT     lastError
    )

/*++


--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkQueue::MarkMediaBad"),OLESTR(""));
    try {
        //
        // Update the media database
        //

        CComPtr<IMediaInfo>     pMediaInfo;

        WsbAffirmHr(m_pSegmentDb->GetEntity(m_pDbWorkSession, HSM_MEDIA_INFO_REC_TYPE, IID_IMediaInfo,
                (void**)&pMediaInfo));
        WsbAffirmHr(pMediaInfo->SetId(mediaId));
        WsbAffirmHr(pMediaInfo->FindEQ());
        WsbAffirmHr(pMediaInfo->SetLastError(lastError));
        m_MediaReadOnly = TRUE;
        WsbAffirmHr(pMediaInfo->SetRecallOnlyStatus(m_MediaReadOnly));
        WsbAffirmHr(pMediaInfo->Write());

    } WsbCatch( hr );

    WsbTraceOut(OLESTR("CHsmWorkQueue::MarkMediaBad"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);
}

HRESULT
CHsmWorkQueue::FindRecallMediaToUse(
    IFsaPostIt *pFsaWorkItem,
    GUID       *pMediaToUse,
    BOOL       *pMediaChanged
    )

/*++


--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkQueue::FindRecallMediaToUse"),OLESTR(""));
    try {
        WsbAssert(pMediaToUse != 0, E_POINTER);
        *pMediaToUse = GUID_NULL;
        WsbAssert(pMediaChanged != 0, E_POINTER);
        *pMediaChanged = FALSE;

        CComQIPtr<ISegDb, &IID_ISegDb> pSegDb = m_pSegmentDb;
        CComPtr<ISegRec>        pSegRec;
        GUID                    l_BagId;
        LONGLONG                l_FileStart;
        LONGLONG                l_FileSize;
        USHORT                  l_SegFlags;
        GUID                    l_PrimPos;
        LONGLONG                l_SecPos;
        GUID                    storagePoolId;
        FSA_PLACEHOLDER         placeholder;

        //
        // Go to the segment database to find out where the data
        // is located.
        //
        WsbAffirmHr(pFsaWorkItem->GetPlaceholder(&placeholder));
        m_BagId = placeholder.bagId;
        WsbAffirmHr(pFsaWorkItem->GetStoragePoolId(&storagePoolId));

        WsbTrace(OLESTR("Finding SegmentRecord: <%ls>, <%ls>, <%ls>\n"),
                            WsbGuidAsString(placeholder.bagId),
                            WsbStringCopy(WsbLonglongAsString(placeholder.fileStart)),
                            WsbStringCopy(WsbLonglongAsString(placeholder.fileSize)));

        hr = pSegDb->SegFind(m_pDbWorkSession, placeholder.bagId, placeholder.fileStart,
                             placeholder.fileSize, &pSegRec);
        if (S_OK != hr)  {
            //
            // We couldn't find the segment record for this information!
            //
            hr = HSM_E_SEGMENT_INFO_NOT_FOUND;
            WsbAffirmHr(hr);
        }
        WsbAffirmHr(pSegRec->GetSegmentRecord(&l_BagId, &l_FileStart, &l_FileSize, &l_SegFlags,
                            &l_PrimPos, &l_SecPos));
        WsbAssert(0 != l_SecPos, HSM_E_BAD_SEGMENT_INFORMATION);

        //
        // In case of an indirect record, go to the dirtect record to get real location info
        //
        if (l_SegFlags & SEG_REC_INDIRECT_RECORD) {
            pSegRec = 0;

            WsbTrace(OLESTR("Finding indirect SegmentRecord: <%ls>, <%ls>, <%ls>\n"),
                    WsbGuidAsString(l_PrimPos), WsbStringCopy(WsbLonglongAsString(l_SecPos)),
                    WsbStringCopy(WsbLonglongAsString(placeholder.fileSize)));

            hr = pSegDb->SegFind(m_pDbWorkSession, l_PrimPos, l_SecPos,
                                 placeholder.fileSize, &pSegRec);
            if (S_OK != hr)  {
                //
                // We couldn't find the direct segment record for this segment!
                //
                hr = HSM_E_SEGMENT_INFO_NOT_FOUND;
                WsbAffirmHr(hr);
            }

            WsbAffirmHr(pSegRec->GetSegmentRecord(&l_BagId, &l_FileStart, &l_FileSize, &l_SegFlags,
                                &l_PrimPos, &l_SecPos));
            WsbAssert(0 != l_SecPos, HSM_E_BAD_SEGMENT_INFORMATION);

            // Don't support a second indirection for now !!
            WsbAssert(0 == (l_SegFlags & SEG_REC_INDIRECT_RECORD), HSM_E_BAD_SEGMENT_INFORMATION);
        }

        //
        // Go to the media database to get the media ID
        //
        CComPtr<IMediaInfo>     pMediaInfo;
        GUID                    l_RmsMediaId;

        WsbAffirmHr(m_pSegmentDb->GetEntity(m_pDbWorkSession, HSM_MEDIA_INFO_REC_TYPE, IID_IMediaInfo,
                (void**)&pMediaInfo));
        WsbAffirmHr(pMediaInfo->SetId(l_PrimPos));
        hr = pMediaInfo->FindEQ();
        if (S_OK != hr)  {
            hr = HSM_E_MEDIA_INFO_NOT_FOUND;
            WsbAffirmHr(hr);
        }
        WsbAffirmHr(pMediaInfo->GetMediaSubsystemId(&l_RmsMediaId));

        //  If the current tape isn't the one ==> media changed
        if (m_MountedMedia != l_RmsMediaId) {
            *pMediaChanged = TRUE;
            //  If there is a current tape and it isn't the one, dismount it
            if (m_MountedMedia != GUID_NULL) {
                WsbAffirmHr(DismountMedia());
            }
        }

        m_RemoteDataSetStart.QuadPart = l_SecPos;
        *pMediaToUse = l_RmsMediaId;

        // Keep HSM id of mounted media
        m_MediaId = l_PrimPos;

    } WsbCatch( hr );

    WsbTraceOut(OLESTR("CHsmWorkQueue::FindRecallMediaToUse"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);
}




HRESULT
CHsmWorkQueue::GetSource(
    IFsaPostIt                  *pFsaWorkItem,
    OLECHAR                     **pSourceString
    )
/*++

Routine Description:

  This function builds the Source file name

Arguments:

  pFsaWorkItem - the item to be migrated
  pSourceString - the Source file name.

Return Value:

  S_OK

--*/
{
    HRESULT             hr = S_OK;

    CComPtr<IFsaResource>   pResource;
    CWsbStringPtr           tmpString;
    CComPtr<IHsmSession>    pSession;
    CWsbStringPtr           path;

    WsbTraceIn(OLESTR("CHsmWorkQueue::GetSource"),OLESTR(""));
    try  {
        //
        // Get the real session pointer from the IUnknown
        //
        WsbAffirmHr(pFsaWorkItem->GetSession(&pSession));
        WsbAffirm(pSession != 0, E_POINTER);

        // First get the name of the resource from the session
        WsbAffirmHr(pSession->GetResource(&pResource));
        WsbAffirmHr(pFsaWorkItem->GetPath(&path, 0));

        tmpString.Alloc(1000);
        WsbAffirmHr(pResource->GetPath(&tmpString, 0));
        tmpString.Append(&(path[1]));
        // tmpString.Prepend(OLESTR("\\\\?\\"));
        WsbAffirmHr(tmpString.GiveTo(pSourceString));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkQueue::GetSource"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return (hr);
}


HRESULT
CHsmWorkQueue::EndSessions(
    BOOL            done,
    BOOL            bNoDelay
)
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkQueue::EndSessions"),OLESTR(""));
    try  {
        HRESULT dismountHr = S_OK;

        CComPtr<IConnectionPointContainer>  pCPC;
        CComPtr<IConnectionPoint>           pCP;

        //
        // Release resources: should be earlier in completion
        //
        dismountHr = DismountMedia(bNoDelay);

        // Tell the session that we don't want to be advised anymore.
        try {
            WsbAffirmHr(m_pSession->QueryInterface(IID_IConnectionPointContainer, (void**) &pCPC));
            WsbAffirmHr(pCPC->FindConnectionPoint(IID_IHsmSessionSinkEveryState, &pCP));
            WsbAffirmHr(pCP->Unadvise(m_StateCookie));
        } WsbCatch( hr );
        pCPC = 0;
        pCP = 0;
        m_StateCookie = 0;

        try {
            WsbAffirmHr(m_pSession->QueryInterface(IID_IConnectionPointContainer, (void**) &pCPC));
            WsbAffirmHr(pCPC->FindConnectionPoint(IID_IHsmSessionSinkEveryEvent, &pCP));
            WsbAffirmHr(pCP->Unadvise(m_EventCookie));
        } WsbCatch( hr );
        pCPC = 0;
        pCP = 0;
        m_EventCookie = 0;

        if (done)  {
            try {
                WsbTrace( OLESTR("Telling Session Data mover is done\n") );
                WsbAffirmHr(SetState(HSM_JOB_STATE_DONE));
            } WsbCatch( hr );
        }

        m_pSession = 0;
        m_pFsaResource = 0;

        WsbAffirmHr(dismountHr);
        WsbAffirmHr(hr);

    } WsbCatch (hr);

    WsbTraceOut(OLESTR("CHsmWorkQueue::EndSessions"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return (hr);
}



HRESULT
CHsmWorkQueue::GetScanItem(
    IFsaPostIt *    pFsaWorkItem,
    IFsaScanItem ** ppIFsaScanItem
    )
{
    HRESULT                     hr = S_OK;
    CWsbStringPtr               path;

    WsbTraceIn(OLESTR("CHsmWorkQueue::GetScanItem"),OLESTR(""));

    try  {
        WsbAffirmPointer(ppIFsaScanItem);
        WsbAffirm(!*ppIFsaScanItem, E_INVALIDARG);
        WsbAffirmHr(pFsaWorkItem->GetPath(&path, 0));
        WsbAffirmHr(m_pFsaResource->FindFirst(path, m_pSession, ppIFsaScanItem));

    } WsbCatch (hr)

    WsbTraceOut(OLESTR("CHsmWorkQueue::GetScanItem"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return( hr );
}

HRESULT
CHsmWorkQueue::GetNumWorkItems (
    ULONG *pNumWorkItems
    )
{
    HRESULT                     hr = S_OK;
    CWsbStringPtr               path;

    WsbTraceIn(OLESTR("CHsmWorkQueue::GetNumWorkItems"),OLESTR(""));


    try  {
        WsbAffirm(0 != pNumWorkItems, E_POINTER);
        *pNumWorkItems = 0;
        WsbAffirmHr(m_pWorkToDo->GetEntries(pNumWorkItems));
    } WsbCatch (hr)

    WsbTraceOut(OLESTR("CHsmWorkQueue::GetNumWorkItems"),OLESTR("hr = <%ls>, NumItems = <%ls>"),
                WsbHrAsString(hr), WsbPtrToUlongAsString(pNumWorkItems));
    return( hr );
}

HRESULT
CHsmWorkQueue::GetCurrentSessionId (
    GUID *pSessionId
    )
{
    HRESULT                     hr = S_OK;
    CWsbStringPtr               path;

    WsbTraceIn(OLESTR("CsmWorkQueue::GetCurrentSessionId"),OLESTR(""));
    try  {
        WsbAffirm(0 != pSessionId, E_POINTER);
        WsbAffirmHr(m_pSession->GetIdentifier(pSessionId));
    } WsbCatch (hr)

    WsbTraceOut(OLESTR("CHsmWorkQueue::GetCurrentSessionId"),OLESTR("hr = <%ls>, Id = <%ls>"),
                WsbHrAsString(hr), WsbPtrToGuidAsString(pSessionId));
    return( hr );
}

DWORD HsmWorkQueueThread(
    void *pVoid
)

/*++


--*/
{
HRESULT     hr;

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    hr = ((CHsmWorkQueue*) pVoid)->DoWork();

    CoUninitialize();
    return(hr);
}

HRESULT
CHsmWorkQueue::Pause(
    void
    )

/*++

Implements:

  CHsmWorkQueue::Pause().

--*/
{
    HRESULT                 hr = S_OK;
    HSM_JOB_STATE           oldState;

    WsbTraceIn(OLESTR("CHsmWorkQueue::Pause"), OLESTR(""));

    try {

        // If we are running, then suspend the thread.
        WsbAffirm((HSM_JOB_STATE_STARTING == m_JobState) ||
                (HSM_JOB_STATE_ACTIVE == m_JobState) ||
                (HSM_JOB_STATE_RESUMING == m_JobState), E_UNEXPECTED);
        oldState = m_JobState;
        WsbAffirmHr(SetState(HSM_JOB_STATE_PAUSING));

        // if we are unable to suspend, then return to the former state.
        try {
            WsbAffirm(0xffffffff != SuspendThread(m_WorkerThread), HRESULT_FROM_WIN32(GetLastError()));
            WsbAffirmHr(SetState(HSM_JOB_STATE_PAUSED));
        } WsbCatchAndDo(hr, SetState(oldState););

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkQueue::Pause"), OLESTR("hr = <%ls>"), WsbHrAsString(hr) );

    return(hr);
}


HRESULT
CHsmWorkQueue::Resume(
    void
    )

/*++

Implements:

  CHsmWorkQueue::Resume().

--*/
{
    HRESULT                 hr = S_OK;
    HSM_JOB_STATE           oldState;

    WsbTraceIn(OLESTR("CHsmWorkQueue::Resume"), OLESTR(""));
    try {

        // If we are paused, then suspend the thread.
        WsbAffirm((HSM_JOB_STATE_PAUSING == m_JobState) || (HSM_JOB_STATE_PAUSED == m_JobState), E_UNEXPECTED);

        // If we are running, then suspend the thread.

        oldState = m_JobState;
        WsbAffirmHr(SetState(HSM_JOB_STATE_RESUMING));

        // If we are unable to resume, then return to the former state.
        try {
            WsbAffirm(0xffffffff != ResumeThread(m_WorkerThread), HRESULT_FROM_WIN32(GetLastError()));
            WsbAffirmHr(SetState(HSM_JOB_STATE_ACTIVE));
        } WsbCatchAndDo(hr, SetState(oldState););

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkQueue::Resume"), OLESTR("hr = <%ls>"), WsbHrAsString(hr) );
    return(hr);
}

HRESULT
CHsmWorkQueue::SetState(
    IN HSM_JOB_STATE state
    )

/*++

--*/
{
    HRESULT         hr = S_OK;
    BOOL            bLog = TRUE;

    WsbTraceIn(OLESTR("CHsmWorkQueue:SetState"), OLESTR("state = <%ls>"), JobStateAsString( state ) );

    try {
        //
        // Change the state and report the change to the session.  Unless the current state is
        // failed then leave it failed.  Is is necessary because when this guy fails, it will
        // cancel all sessions so that no more work is sent in and so we will skip any queued work.
        // If the current state is failed, we don't need to spit out the failed message every time,
        // so we send ProcessState a false fullmessage unless the state is cancelled.
        //
        if (HSM_JOB_STATE_FAILED != m_JobState)  {
            m_JobState = state;
        }
		
		if ((HSM_JOB_STATE_FAILED == m_JobState) && (HSM_JOB_STATE_CANCELLED != state)) {
            bLog = FALSE;
        }

        WsbAffirmHr(m_pSession->ProcessState(m_JobPhase, m_JobState, m_CurrentPath, bLog));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkQueue::SetState"), OLESTR("hr = <%ls> m_JobState = <%ls>"), WsbHrAsString(hr), JobStateAsString( m_JobState ) );

    return(hr);
}

HRESULT
CHsmWorkQueue::Cancel(
    void
    )

/*++

Implements:

  CHsmWorkQueue::Cancel().

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkQueue::Cancel"), OLESTR(""));
    try {

        WsbAffirmHr(SetState(HSM_JOB_STATE_CANCELLING));
        //
        // This needs to be prepended and the queue emptied out!
        //
        CComPtr<IHsmWorkItem>  pWorkItem;
        WsbAffirmHr(m_pHsmServerCreate->CreateInstance(CLSID_CHsmWorkItem, IID_IHsmWorkItem,
                                                (void **)&pWorkItem));
        WsbAffirmHr(pWorkItem->SetWorkType(HSM_WORK_ITEM_MOVER_CANCELLED));
        WsbAffirmHr(m_pWorkToDo->Prepend(pWorkItem));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkQueue::Cancel"), OLESTR("hr = <%ls>"), WsbHrAsString(hr) );
    return(hr);
}

HRESULT
CHsmWorkQueue::FailJob(
    void
    )

/*++

Implements:

  CHsmWorkQueue::FailJob().

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkQueue::FailJob"), OLESTR(""));
    try {
        //
        // Set our state to failed and then cancel all work
        //
        WsbAffirmHr(SetState(HSM_JOB_STATE_FAILED));
        if (m_pSession != 0)  {
            WsbAffirmHr(m_pSession->Cancel( HSM_JOB_PHASE_ALL ));
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkQueue::FailJob"), OLESTR("hr = <%ls>"), WsbHrAsString(hr) );
    return(hr);
}

HRESULT
CHsmWorkQueue::PauseScanner(
    void
    )

/*++

Implements:

  CHsmWorkQueue::PauseScanner().

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkQueue::PauseScanner"), OLESTR(""));
    try {
        //
        // Set our state to failed and then cancel all work
        //
        if (m_pSession != 0)  {
            WsbAffirmHr(m_pSession->Pause( HSM_JOB_PHASE_SCAN ));
            m_ScannerPaused = TRUE;
        } else  {
            //
            // We should never get here - this means we have been processing work but we
            // have no session established
            //
            WsbThrow(E_POINTER);
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkQueue::PauseScanner"), OLESTR("hr = <%ls>"), WsbHrAsString(hr) );
    return(hr);
}

HRESULT
CHsmWorkQueue::ResumeScanner(
    void
    )

/*++

Implements:

  CHsmWorkQueue::ResumeScanner().

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkQueue::ResumeScanner"), OLESTR(""));
    try {
        //
        // Set our state to failed and then cancel all work
        //
        if (m_pSession != 0)  {
            if (TRUE == m_ScannerPaused && HSM_JOB_STATE_ACTIVE == m_JobState)  {
                WsbAffirmHr(m_pSession->Resume( HSM_JOB_PHASE_SCAN ));
                m_ScannerPaused = FALSE;
            }
        } else  {
            //
            // We should never get here - this means we have been processing work but we
            // have no session established
            //
            WsbThrow(E_POINTER);
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkQueue::ResumeScanner"), OLESTR("hr = <%ls>"), WsbHrAsString(hr) );
    return(hr);
}

void
CHsmWorkQueue::ReportMediaProgress(
    HSM_JOB_MEDIA_STATE state,
    HRESULT             /*status*/
    )

/*++

Implements:

  CHsmWorkQueue::ReportMediaProgress().

--*/
{
    HRESULT                 hr = S_OK;
    CWsbStringPtr           mediaName;
    HSM_JOB_MEDIA_TYPE      mediaType = HSM_JOB_MEDIA_TYPE_UNKNOWN;

    WsbTraceIn(OLESTR("CHsmWorkQueue::ReportMediaProgress"), OLESTR(""));
    try {

        // Report Progress but we don't really care if it succeeds.
        hr = m_pSession->ProcessMediaState(m_JobPhase, state, m_MediaName, m_MediaType, 0);
        hr = S_OK;
//      if (status != S_OK)  {
//              (void) m_pSession->ProcessHr(m_JobPhase, __FILE__, __LINE__, status);
//      }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkQueue::ReportMediaProgress"), OLESTR("hr = <%ls>"), WsbHrAsString(hr) );
}

HRESULT
CHsmWorkQueue::BuildMediaName(
    OLECHAR **pMediaName
    )

/*++

Implements:

  CHsmWorkQueue::BuildMediaName

--*/
{
    HRESULT                 hr = S_OK;
    CWsbStringPtr           tmpName;

    WsbTraceIn(OLESTR("CHsmWorkQueue::BuildMediaName"), OLESTR(""));
    try {
        ULONG len = 0;


        // Get the next media number only when last scratch mount succeeded
        //  (which means, either first time or we need a second media for the same queue)
        if (! m_ScratchFailed) {
            WsbAffirmHr(m_pServer->GetNextMedia(&m_mediaCount));
        }
        WsbAssert(0 != m_mediaCount, E_UNEXPECTED);

        // Use the base name from the registry if available
        WsbAffirmHr(m_MediaBaseName.GetLen(&len));
        if (len) {
            tmpName = m_MediaBaseName;
        } else {
            // Otherwise use the name of the HSM
            tmpName.Realloc(512);
            WsbAffirmHr(m_pServer->GetName(&tmpName));
            tmpName.Prepend("RS-");
        }
        tmpName.Append("-");
        tmpName.Append(WsbLongAsString(m_mediaCount));

        tmpName.GiveTo(pMediaName);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkQueue::BuildMediaName"), OLESTR("hr = <%ls>, name = <%ls>"), WsbHrAsString(hr),
                    WsbPtrToStringAsString(pMediaName));
    return(hr);
}



HRESULT
CHsmWorkQueue::GetMediaParameters( LONGLONG defaultFreeSpace )

/*++

Implements:

  CHsmWorkQueue::GetMediaParameters

Note:
  The defaultFreeSpace parameter is passed to the mover to maintain internally 
  media free space in case that the device doesn't provide this information.
  If the device supports reporting on free space, then this parameter has no affect.

--*/
{
    HRESULT                 hr = S_OK;
    LONG                    rmsCartridgeType;
    CWsbBstrPtr             barCode;


    WsbTraceIn(OLESTR("CHsmWorkQueue::GetMediaParameters"), OLESTR(""));
    try {
        //
        // Get some information about the media
        //
        LARGE_INTEGER tempFreeSpace;
        tempFreeSpace.QuadPart = defaultFreeSpace;
        WsbAffirmHr(m_pDataMover->GetLargestFreeSpace(&m_MediaFreeSpace, &m_MediaCapacity, 
                                        tempFreeSpace.LowPart, tempFreeSpace.HighPart));

        WsbAffirmHr(m_pRmsCartridge->GetType(&rmsCartridgeType));
        WsbAffirmHr(ConvertRmsCartridgeType(rmsCartridgeType, &m_MediaType));
        WsbAffirmHr(m_pRmsCartridge->GetName(&barCode));
        WsbAffirmHr(CoFileTimeNow(&m_MediaUpdate));
        m_MediaBarCode = barCode;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkQueue::GetMediaParameters"), OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);
}


HRESULT
CHsmWorkQueue::DismountMedia(BOOL bNoDelay)

/*++

Implements:

  CHsmWorkQueue::DismountMedia

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkQueue::DismountMedia"), OLESTR(""));
    try {
        if ((m_pRmsCartridge != 0) && (m_MountedMedia != GUID_NULL)) {
            //
            // End the session with the data mover.  If this doesn't work, report
            // the problem but continue with the dismount.
            //
            try  {
                if ((m_RequestAction == FSA_REQUEST_ACTION_PREMIGRATE) && (m_pDataMover != 0)) {
                    if (S_OK == m_BeginSessionHr)  {
                        //
                        // Don't do an end session if the Begin didn't work OK
                        //
                        m_BeginSessionHr = S_FALSE;
                        WsbAffirmHr(m_pDataMover->EndSession());

                        // Update media free space after all data has been written to the media
                        WsbAffirmHr(UpdateMediaFreeSpace());
                    }
                }
            } WsbCatchAndDo( hr,
                    WsbTraceAlways(OLESTR("CHsmWorkQueue::DismountMedia: End session or DB update failed, hr = <%ls>\n"), 
                            WsbHrAsString(hr));
                );

            //
            // Tell the session that we are dismounting media. Ignore any problems
            // with the reporting
            //
            (void )ReportMediaProgress(HSM_JOB_MEDIA_STATE_DISMOUNTING, S_OK);

            //
            // Dismount the cartridge and report progress
            //

            // !!! IMPORTANT NOTE !!!
            //
            // Must free Rms resources used before dismounting...
            //
            m_pRmsCartridge = 0;
            m_pDataMover    = 0;

            DWORD dwOptions = RMS_NONE;
            if (bNoDelay) {
                dwOptions |= RMS_DISMOUNT_DEFERRED_ONLY;
            }
            hr = m_pRmsServer->DismountCartridge(m_MountedMedia, dwOptions);
            (void) ReportMediaProgress(HSM_JOB_MEDIA_STATE_DISMOUNTED, hr);

            //
            // Clear out the knowledge of media that was just dismounted
            //
            WsbAffirmHr(UnsetMediaInfo());

            WsbAffirmHr(hr);
            WsbTrace( OLESTR("Dismount completed OK.\n") );
        } else  {
            WsbTrace( OLESTR("There is no media to dismount.\n") );
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkQueue::DismountMedia"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT
CHsmWorkQueue::ConvertRmsCartridgeType(
    LONG                rmsCartridgeType,
    HSM_JOB_MEDIA_TYPE  *pMediaType
    )

/*++

Implements:

  CHsmWorkQueue::ConvertRmsCartridgeType

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkQueue::ConvertRmsCartridgeType"), OLESTR(""));
    try  {

        WsbAssert(0 != pMediaType, E_POINTER);

        switch (rmsCartridgeType)  {
            case RmsMedia8mm:
            case RmsMedia4mm:
            case RmsMediaDLT:
            case RmsMediaTape:
                *pMediaType = HSM_JOB_MEDIA_TYPE_TAPE;
                break;
            case RmsMediaOptical:
            case RmsMediaMO35:
            case RmsMediaWORM:
            case RmsMediaCDR:
            case RmsMediaDVD:
                *pMediaType = HSM_JOB_MEDIA_TYPE_OPTICAL;
                break;
            case RmsMediaDisk:
                *pMediaType = HSM_JOB_MEDIA_TYPE_REMOVABLE_MAG;
                break;
            case RmsMediaFixed:
                *pMediaType = HSM_JOB_MEDIA_TYPE_FIXED_MAG;
                break;
            case RmsMediaUnknown:
            default:
                *pMediaType = HSM_JOB_MEDIA_TYPE_UNKNOWN;
                break;
        }
    } WsbCatch( hr );

    WsbTraceOut(OLESTR("CHsmWorkQueue::ConvertRmsCartridgeType"), OLESTR("hr = <%ls>"),
                WsbHrAsString(hr));
    return(hr);
}

HRESULT
CHsmWorkQueue::MarkQueueAsDone( void )

/*++

Implements:

  CHsmWorkQueue::MarkQueueAsDone

--*/
{
    HRESULT                 hr = S_OK;


    WsbTraceIn(OLESTR("CHsmWorkQueue::MarkQueueAsDone"), OLESTR(""));
    try {
        // Create a work item and append it to the work queue to
        // indicate that the job is done
        CComPtr<IHsmWorkItem>  pWorkItem;
        WsbAffirmHr(m_pHsmServerCreate->CreateInstance(CLSID_CHsmWorkItem, IID_IHsmWorkItem,
                                                    (void **)&pWorkItem));
        WsbAffirmHr(pWorkItem->SetWorkType(HSM_WORK_ITEM_FSA_DONE));
        WsbAffirmHr(m_pWorkToDo->Append(pWorkItem));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkQueue::MarkQueueAsDone"), OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);
}

HRESULT
CHsmWorkQueue::CopyToWaitingQueue(
    IHsmWorkItem *pWorkItem
    )

/*++

Implements:

  CHsmWorkQueue::CopyToWaitingQueue

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IFsaPostIt>     pFsaWorkItem;
    FSA_PLACEHOLDER         placeholder;


    WsbTraceIn(OLESTR("CHsmWorkQueue::CopyToWaitingQueue"), OLESTR(""));
    try {
        //
        // Append the work item to the end of the waiting queue
        //
        WsbAffirmHr(m_pWorkToCommit->Append(pWorkItem));

        //
        // If adding this item to the waiting queue triggers
        // then cause the commit
        //
        WsbAffirmHr(pWorkItem->GetFsaPostIt(&pFsaWorkItem));
        WsbAffirmHr(pFsaWorkItem->GetPlaceholder(&placeholder));

        m_DataCountBeforeCommit += placeholder.fileSize;
        m_FilesCountBeforeCommit++;


    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkQueue::CopyToWaitingQueue"), OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);
}

HRESULT
CHsmWorkQueue::CompleteWorkItem(
    IHsmWorkItem *pWorkItem
    )
{
    HRESULT                 hr = S_OK;

    CWsbStringPtr           path;
    FSA_RESULT_ACTION       resultAction;
    CComPtr<IFsaPostIt>     pFsaWorkItem;
    CComPtr<IFsaResource>   pFsaResource;
    FSA_REQUEST_ACTION      requestAction;

    WsbTraceIn(OLESTR("CHsmWorkQueue::CompleteWorkItem"), OLESTR(""));
    try {
        //
        // Get the stuff
        //
        WsbAffirmHr(pWorkItem->GetFsaPostIt(&pFsaWorkItem));
        WsbAffirmHr(pWorkItem->GetFsaResource(&pFsaResource));
        WsbAffirmHr(pFsaWorkItem->GetPath(&path, 0));
        WsbAffirmHr(pFsaWorkItem->GetRequestAction(&requestAction));
        WsbTrace(OLESTR("Completing work for <%s>.\n"), (OLECHAR *)path);

        //
        // Update the metadata - If this fails don't process
        // results.
        //
        WsbAffirmHr(UpdateMetaData(pWorkItem));

        //
        // Complete the work
        //
        WsbAffirmHr(pFsaWorkItem->GetResultAction(&resultAction));
        if ((resultAction != FSA_RESULT_ACTION_NONE)  &&
            (requestAction != FSA_REQUEST_ACTION_FILTER_RECALL) &&
            (requestAction != FSA_REQUEST_ACTION_FILTER_READ) &&
            (requestAction != FSA_REQUEST_ACTION_RECALL) ) {
            WsbTrace(OLESTR("HSM work item complete, calling FSA\n"));
            hr = pFsaResource->ProcessResult(pFsaWorkItem);
            WsbTrace(OLESTR("FSA ProcessResult returned <%ls>\n"), WsbHrAsString(hr));

            //
            // If the process results fails, find out if the reparse point has been written,
            // if not, put the file in the bag hole table.
            //
            if ( FSA_E_REPARSE_NOT_WRITTEN_FILE_CHANGED == hr )  {
                //
                // Put the file in the bag hole table
                //
            }
            WsbAffirmHr(hr);
        }

    } WsbCatch( hr );

    WsbTraceOut(OLESTR("CHsmWorkQueue::CompleteWorkItem"), OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return( hr );
}

HRESULT
CHsmWorkQueue::TimeToCommit( void )
{
    HRESULT                 hr = S_OK;

    //  Call the other version since it has the trace in it
    hr = TimeToCommit(0, 0);
    return( hr );
}

HRESULT
CHsmWorkQueue::TimeToCommit(
    LONGLONG    numFiles,
    LONGLONG    amountOfData
    )
{
    HRESULT                 hr = S_FALSE;

    WsbTraceIn(OLESTR("CHsmWorkQueue::TimeToCommit"), OLESTR("numFiles = <%ls>, amountOfData = <%ls>"),
            WsbQuickString(WsbLonglongAsString(numFiles)), WsbQuickString(WsbLonglongAsString(amountOfData)));
    WsbTrace(OLESTR("CHsmWorkQueue::TimeToCommit: m_DataCountBeforeCommit = %ls, ")
            OLESTR("m_FilesCountBeforeCommit = %ls, m_MediaFreeSpace = %ls\n"),
            WsbQuickString(WsbLonglongAsString(m_DataCountBeforeCommit)),
            WsbQuickString(WsbLonglongAsString(m_FilesCountBeforeCommit)),
            WsbQuickString(WsbLonglongAsString(m_MediaFreeSpace)));
    WsbTrace(OLESTR("CHsmWorkQueue::TimeToCommit: m_MaxBytesBeforeCommit = %lu, m_MinBytesBeforeCommit = %lu\n"),
            m_MaxBytesBeforeCommit, m_MinBytesBeforeCommit);
    WsbTrace(OLESTR("CHsmWorkQueue::TimeToCommit: m_FilesBeforeCommit = %lu, m_FreeMediaBytesAtEndOfMedia = %lu\n"),
            m_FilesBeforeCommit, m_FreeMediaBytesAtEndOfMedia);
    try {
        //
        // If we have enough data or enough files then say it is time

        // Check for lots of data written to media:
        if ((m_DataCountBeforeCommit + amountOfData) >= m_MaxBytesBeforeCommit) {
            WsbTrace(OLESTR("CHsmWorkQueue::TimeToCommit: commit because enough data was written\n"));
            hr = S_OK;

        // Check for lots of files written
        } else if (((m_FilesCountBeforeCommit + numFiles) >= m_FilesBeforeCommit) &&
                ((m_DataCountBeforeCommit + amountOfData) >= m_MinBytesBeforeCommit)) {
            WsbTrace(OLESTR("CHsmWorkQueue::TimeToCommit: commit because enough files were written\n"));
            hr = S_OK;

        // Check for shortage of space on the media
        } else if (((m_MediaFreeSpace - amountOfData) <= m_FreeMediaBytesAtEndOfMedia) &&
                ((m_DataCountBeforeCommit + amountOfData) >= m_MinBytesBeforeCommit))  {
            WsbTrace(OLESTR("CHsmWorkQueue::TimeToCommit: commit because end of media is near\n"));
            hr = S_OK;
        }

    } WsbCatch( hr );

    WsbTraceOut(OLESTR("CHsmWorkQueue::TimeToCommit"), OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return( hr );
}


HRESULT
CHsmWorkQueue::CheckMigrateMinimums(void)

/*++

Routine Description:

  Check that there is enough work in the queue to start a migrate session.

Arguments:

  None.

Return Value:

  S_OK                         - There is enough to start a session,
           we hit the end of the queue, or this isn't a migrate queue.
  S_FALSE                      - There isn't enough yet.
  E_*                          - An error was encountered.

--*/
{
    HRESULT      hr = S_FALSE;

    WsbTraceIn(OLESTR("CHsmWorkQueue::CheckMigrateMinimums"), OLESTR(""));

    // Only check if the session has not already started (or been attempted).
    if (S_FALSE != m_BeginSessionHr) {
        WsbTrace(OLESTR("CHsmWorkQueue::CheckMigrateMinimums: session already started\n"));
        hr = S_OK;
    } else {
        try {
            ULONG                   BytesOfData = 0;
            ULONG                   NumEntries;

            // Get the number of items in the queue
            WsbAffirmHr(m_pWorkToDo->GetEntries(&NumEntries));
            WsbTrace(OLESTR("CHsmWorkQueue::CheckMigrateMinimums: size of queue = %lu, Min = %lu\n"),
                    NumEntries, m_MinFilesToMigrate);

            // If the queue is already large enough, don't check individual
            // items.
            if (NumEntries >= m_MinFilesToMigrate)  {
                WsbTrace(OLESTR("CHsmWorkQueue::CheckMigrateMinimums: enough queue items\n"));
                hr = S_OK;
            } else {

                // Loop over the items in the queue
                for (ULONG i = 0; i < NumEntries; i++) {
                    CComPtr<IFsaPostIt>     pFsaWorkItem;
                    CComPtr<IHsmWorkItem>   pWorkItem;
                    FSA_REQUEST_ACTION      RequestAction;
                    LONGLONG                RequestSize;
                    HSM_WORK_ITEM_TYPE      workType;

                    WsbAffirmHr(m_pWorkToDo->At(i, IID_IHsmWorkItem,
                            (void **)&pWorkItem));
                    WsbAffirmHr(pWorkItem->GetWorkType(&workType));

                    // Check the type of work item
                    if (HSM_WORK_ITEM_FSA_WORK != workType) {
                        // Hit the end of the queue or some other unusual
                        // condition.  Allow processing of the queue.
                        WsbTrace(OLESTR("CHsmWorkQueue::CheckMigrateMinimums: non-standard work type\n"));
                        hr = S_OK;
                        break;
                    }

                    // Make sure this is a migrate queue.  (This assumes a queue
                    // doesn't contain different types of FSA requests.)
                    WsbAffirmHr(pWorkItem->GetFsaPostIt(&pFsaWorkItem));
                    WsbAffirmHr(pFsaWorkItem->GetRequestAction(&RequestAction));
                    WsbTrace(OLESTR("CHsmWorkQueue::CheckMigrateMinimums: RequestAction = %d\n"),
                            static_cast<int>(RequestAction));
                    if (FSA_REQUEST_ACTION_PREMIGRATE != RequestAction) {
                        WsbTrace(OLESTR("CHsmWorkQueue::CheckMigrateMinimums: item is not migrate\n"));
                        hr = S_OK;
                        break;
                    }

                    // Check for minimum amount of data
                    WsbAffirmHr(pFsaWorkItem->GetRequestSize(&RequestSize));
                    WsbTrace(OLESTR("CHsmWorkQueue::CheckMigrateMinimums: RequestSize = %ls, Min = %lu\n"),
                            WsbLonglongAsString(RequestSize), m_MinBytesToMigrate);
                    if ((static_cast<LONGLONG>(BytesOfData) + RequestSize) >=
                            static_cast<LONGLONG>(m_MinBytesToMigrate)) {
                        WsbTrace(OLESTR("CHsmWorkQueue::CheckMigrateMinimums: enough data\n"));
                        hr = S_OK;
                        break;
                    } else {
                        BytesOfData += static_cast<ULONG>(RequestSize);
                        WsbTrace(OLESTR("CHsmWorkQueue::CheckMigrateMinimums: new BytesOfData = %lu\n"),
                                BytesOfData);
                    }
                }
            }
        } WsbCatch( hr );
    }

    WsbTraceOut(OLESTR("CHsmWorkQueue::CheckMigrateMinimums"), OLESTR("hr = <%ls>"),
            WsbHrAsString(hr));

    return( hr );
}


HRESULT
CHsmWorkQueue::CheckRegistry(void)
{
    OLECHAR      dataString[100];
    HRESULT      hr = S_OK;
    ULONG        l_value;
    DWORD        sizeGot;

    WsbTraceIn(OLESTR("CHsmWorkQueue::CheckRegistry"), OLESTR(""));

    try {
        // Minimum files to migrate
        WsbAffirmHr(WsbRegistryValueUlongAsString(NULL, HSM_ENGINE_REGISTRY_STRING, HSM_MIN_FILES_TO_MIGRATE,
                &m_MinFilesToMigrate));
        WsbTrace(OLESTR("CHsmWorkQueue::CheckRegistry: m_MinFilesToMigrate = %lu\n"),
                m_MinFilesToMigrate);

        // Minimum bytes to migrate
        WsbAffirmHr(WsbRegistryValueUlongAsString(NULL, HSM_ENGINE_REGISTRY_STRING, HSM_MIN_BYTES_TO_MIGRATE,
                &m_MinBytesToMigrate));
        WsbTrace(OLESTR("CHsmWorkQueue::CheckRegistry: m_MinBytesToMigrate = %lu\n"),
                m_MinBytesToMigrate);

        // Minimum files before commit
        WsbAffirmHr(WsbRegistryValueUlongAsString(NULL, HSM_ENGINE_REGISTRY_STRING, HSM_FILES_BEFORE_COMMIT,
                &m_FilesBeforeCommit));
        WsbTrace(OLESTR("CHsmWorkQueue::CheckRegistry: m_FilesBeforeCommit = %lu\n"),
                m_FilesBeforeCommit);

        // Maximum bytes before commit
        WsbAffirmHr(WsbRegistryValueUlongAsString(NULL, HSM_ENGINE_REGISTRY_STRING, HSM_MAX_BYTES_BEFORE_COMMIT,
                &m_MaxBytesBeforeCommit));
        WsbTrace(OLESTR("CHsmWorkQueue::CheckRegistry: m_MaxBytesBeforeCommit = %lu\n"),
                m_MaxBytesBeforeCommit);

        // Minimum bytes before commit
        WsbAffirmHr(WsbRegistryValueUlongAsString(NULL, HSM_ENGINE_REGISTRY_STRING, HSM_MIN_BYTES_BEFORE_COMMIT,
                &m_MinBytesBeforeCommit));
        WsbTrace(OLESTR("CHsmWorkQueue::CheckRegistry: m_MinBytesBeforeCommit = %lu\n"),
                m_MinBytesBeforeCommit);

        // Bytes to perserve at end of tape (This is really just for security, we shouldn't reach this threshold at all)
        WsbAffirmHr(WsbRegistryValueUlongAsString(NULL, HSM_ENGINE_REGISTRY_STRING, HSM_MIN_BYTES_AT_END_OF_MEDIA,
                &m_FreeMediaBytesAtEndOfMedia));
        WsbTrace(OLESTR("CHsmWorkQueue::CheckRegistry: m_FreeMediaBytesAtEndOfMedia = %lu\n"),
                m_FreeMediaBytesAtEndOfMedia);

        // Minimum percent to preserve as free space in end of meida
        WsbAffirmHr(WsbRegistryValueUlongAsString(NULL, HSM_ENGINE_REGISTRY_STRING, HSM_MIN_FREE_SPACE_IN_FULL_MEDIA,
                &m_MinFreeSpaceInFullMedia));
        if (m_MinFreeSpaceInFullMedia >= 100) {
            m_MinFreeSpaceInFullMedia = MIN_FREE_SPACE_IN_FULL_MEDIA_DEFAULT;
        }
        WsbTrace(OLESTR("CHsmWorkQueue::CheckRegistry: m_MinFreeSpaceInFullMedia = %lu\n"),
                m_MinFreeSpaceInFullMedia);

        // Maximum percent to preserve as free space in end of meida
        WsbAffirmHr(WsbRegistryValueUlongAsString(NULL, HSM_ENGINE_REGISTRY_STRING, HSM_MAX_FREE_SPACE_IN_FULL_MEDIA,
                &m_MaxFreeSpaceInFullMedia));
        if (m_MaxFreeSpaceInFullMedia >= 100) {
            m_MaxFreeSpaceInFullMedia = MAX_FREE_SPACE_IN_FULL_MEDIA_DEFAULT;
        }
        WsbTrace(OLESTR("CHsmWorkQueue::CheckRegistry: m_MaxFreeSpaceInFullMedia = %lu\n"),
                m_MaxFreeSpaceInFullMedia);

        // Save DBs in dataset? (Note: registry value has opposite meaning!)
        l_value = m_StoreDatabasesInBags ? 0 : 1;
        WsbAffirmHr(WsbRegistryValueUlongAsString(NULL, HSM_ENGINE_REGISTRY_STRING, HSM_DONT_SAVE_DATABASES,
                &l_value));
        m_StoreDatabasesInBags  = !l_value;
        WsbTrace(OLESTR("CHsmWorkQueue::CheckRegistry: m_StoreDatabasesInBags = <%ls>\n"),
            WsbBoolAsString(m_StoreDatabasesInBags));

        // Queue length to pause scan
        WsbAffirmHr(WsbRegistryValueUlongAsString(NULL, HSM_ENGINE_REGISTRY_STRING, HSM_QUEUE_ITEMS_TO_PAUSE,
                &m_QueueItemsToPause));
        WsbTrace(OLESTR("CHsmWorkQueue::CheckRegistry: m_QueueItemsToPause = %lu\n"),
                m_QueueItemsToPause);

        // Queue length to resume scan
        WsbAffirmHr(WsbRegistryValueUlongAsString(NULL, HSM_ENGINE_REGISTRY_STRING, HSM_QUEUE_ITEMS_TO_RESUME,
                &m_QueueItemsToResume));
        WsbTrace(OLESTR("CHsmWorkQueue::CheckRegistry: m_QueueItemsToResume = %lu\n"),
                m_QueueItemsToResume);

        //  See if the user defined a media base name to use
        if (S_OK == WsbGetRegistryValueString(NULL, HSM_ENGINE_REGISTRY_STRING, HSM_MEDIA_BASE_NAME,
                dataString, 100, &sizeGot)) {
            m_MediaBaseName  = dataString;
            WsbTrace(OLESTR("CHsmWorkQueue::CheckRegistry: m_MediaBaseName = <%ls>\n"),
                    static_cast<OLECHAR *>(m_MediaBaseName));
        }

        //  Check for change to number of errors to allow before cancelling
        //  a job
        WsbAffirmHr(WsbRegistryValueUlongAsString(NULL, HSM_ENGINE_REGISTRY_STRING, HSM_JOB_ABORT_CONSECUTIVE_ERRORS,
                &m_JobAbortMaxConsecutiveErrors));
        WsbTrace(OLESTR("CHsmWorkQueue::CheckRegistry: m_JobAbortMaxConsecutiveErrors = %lu\n"),
                m_JobAbortMaxConsecutiveErrors);
        WsbAffirmHr(WsbRegistryValueUlongAsString(NULL, HSM_ENGINE_REGISTRY_STRING, HSM_JOB_ABORT_TOTAL_ERRORS,
                &m_JobAbortMaxTotalErrors));
        WsbTrace(OLESTR("CHsmWorkQueue::CheckRegistry: m_JobAbortMaxTotalErrors = %lu\n"),
                m_JobAbortMaxTotalErrors);

        //  Check for amount of system disk space required for a manage job
        WsbAffirmHr(WsbRegistryValueUlongAsString(NULL, HSM_ENGINE_REGISTRY_STRING, HSM_JOB_ABORT_SYS_DISK_SPACE,
                &m_JobAbortSysDiskSpace));
        WsbTrace(OLESTR("CHsmWorkQueue::CheckRegistry: m_JobAbortSysDiskSpace = %lu\n"),
                m_JobAbortSysDiskSpace);

    } WsbCatch( hr );

    WsbTraceOut(OLESTR("CHsmWorkQueue::CheckRegistry"), OLESTR("hr = <%ls>"),
            WsbHrAsString(hr));

    return( hr );
}


HRESULT
CHsmWorkQueue::CheckForDiskSpace(void)

/*++

Routine Description:

    Check system volume for sufficient space to complete a manage job.

Arguments:

    None

Return Value:

    S_OK                   - There is enough space
    WSB_E_SYSTEM_DISK_FULL - There isn't enough space
    E_*                    - Some error occurred

--*/
{
    HRESULT        hr = S_OK;
    ULARGE_INTEGER FreeBytesAvailableToCaller;
    ULARGE_INTEGER TotalNumberOfBytes;
    ULARGE_INTEGER TotalNumberOfFreeBytes;

    WsbTraceIn(OLESTR("CHsmWorkQueue::CheckForDiskSpace"), OLESTR(""));

    if (GetDiskFreeSpaceEx(NULL, &FreeBytesAvailableToCaller,
            &TotalNumberOfBytes, &TotalNumberOfFreeBytes)) {
        if (FreeBytesAvailableToCaller.QuadPart < m_JobAbortSysDiskSpace) {
            hr = WSB_E_SYSTEM_DISK_FULL;
        }
    } else {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    WsbTraceOut(OLESTR("CHsmWorkQueue::CheckForDiskSpace"), OLESTR("hr = <%ls>"),
            WsbHrAsString(hr));

    return( hr );
}


HRESULT
CHsmWorkQueue::CommitWork(void)
{
    HRESULT                 hr = S_OK;
    HRESULT                 hrComplete = S_OK;
    HRESULT                 hrFlush = E_FAIL;

    WsbTraceIn(OLESTR("CHsmWorkQueue::CommitWork"),OLESTR(""));
    try {
        LONGLONG                lastByteWritten = -1;
        ULONG                   numItems;
        CWsbStringPtr           path;
        CComPtr<IHsmWorkItem>   pWorkItem;
        CComPtr<IFsaPostIt>     pFsaWorkItem;
        HSM_WORK_ITEM_TYPE      workType;
        BOOLEAN                 done = FALSE;
        BOOL                    skipWork = FALSE;

        // Do we actually have work to commit?
        WsbAffirmHr(m_pWorkToCommit->GetEntries(&numItems));
        if (0 == numItems) {
            return(S_OK);
        }

        //
        // We expect the data mover to be ready for work
        //
        WsbAffirm(m_pDataMover != 0, E_UNEXPECTED);

        //
        // If we never got a valid session going, we cannot
        // commit the work.  So check here to make sure the
        // session is really established OK
        if (S_OK == m_BeginSessionHr)  {
            CComPtr<IStream> pIStream;
            ULARGE_INTEGER   position;
            LARGE_INTEGER    zero = {0, 0};

            // Force a flush of the buffers
            //
            hrFlush = m_pDataMover->FlushBuffers();

            // Determine where we are on the tape
            WsbAffirmHr(m_pDataMover->QueryInterface(IID_IStream,
                    (void **)&pIStream));
            if (S_OK != pIStream->Seek(zero, STREAM_SEEK_END, &position)) {
                // If we didn't get useful information
                // about the amount of data written to media, we'll have
                // to skip everything in the queue
                skipWork = TRUE;
            } else {
                lastByteWritten = position.QuadPart;
            }
        } else  {
            // Skip all of the work -  none of it gets committed
            skipWork = TRUE;
        }
        WsbTrace(OLESTR("CHsmWorkQueue::CommitWork: hrFlush = <%ls>, lastByteWritten = %ls\n"),
                WsbHrAsString(hrFlush), WsbLonglongAsString(lastByteWritten));


        while ( (!done) && (S_OK == hr) ) {
            //
            // Get the next work item from the queue
            //
            hr = m_pWorkToCommit->First(IID_IHsmWorkItem, (void **)&pWorkItem);
            if (hr == S_OK)  {
                //
                // Find out about the work, should be FSA work
                //
                WsbAffirmHr(pWorkItem->GetWorkType(&workType));

                if (HSM_WORK_ITEM_FSA_WORK == workType)  {

                    try  {
                        CComPtr<IFsaScanItem>     pScanItem;

                        WsbAffirmHr(pWorkItem->GetFsaPostIt(&pFsaWorkItem));
                        WsbAffirmHr(GetScanItem(pFsaWorkItem, &pScanItem));
                        WsbAffirmHr(pFsaWorkItem->GetRequestAction(&m_RequestAction));

                        // If FlushBuffers failed, some items may not have
                        // gotten written to tape.  This code assumes the items
                        // in the queue are in the same order they were written
                        // onto the media
                        if (!skipWork && S_OK != hrFlush) {
                            FSA_PLACEHOLDER       placeholder;

                            WsbAffirmHr(pFsaWorkItem->GetPlaceholder(&placeholder));
                            if (((LONGLONG)m_RemoteDataSetStart.QuadPart + placeholder.fileStart +
                                    placeholder.fileSize) > lastByteWritten) {
                                skipWork = TRUE;
                            }
                        }

                        (void) pFsaWorkItem->GetPath(&path, 0);
                        if (!skipWork)  {
                            //
                            // Get the FSA Work Item and complete the work
                            //
                            hr = CompleteWorkItem(pWorkItem);
                            //
                            // Do the stats counts
                            //
                            (void)m_pSession->ProcessItem(m_JobPhase, m_JobAction,
                                    pScanItem, hr);

                            //
                            // This is not a failure - change to OK 
                            //
                            if ( FSA_E_REPARSE_NOT_WRITTEN_FILE_CHANGED == hr )  {
                                hr = S_OK;
                            }

                            //
                            // Quota error should be handled differently - we want to log only once 
                            // and avoid abortint the job no matter how many such errors we got
                            //
                            if ( FSA_E_REPARSE_OWNER_PASS_QUOTA == hr )  {
                                if (! (m_uErrorReportFlags & QUEUE_REPORT_PASS_QUOTA_LIMIT_FLAG)) {
                                    WsbLogEvent(HSM_MESSAGE_MANAGE_FAILED_USER_QUOTA,
                                            0, NULL, WsbAbbreviatePath(path, 120), NULL);
                                    m_uErrorReportFlags |= QUEUE_REPORT_PASS_QUOTA_LIMIT_FLAG;
                                }
                                hr = S_OK;
                            }

                            //
                            // Replace to HSM specific error for some error codes
                            //
                            switch (HRESULT_CODE(hr)) {
                            case ERROR_LOCK_VIOLATION:
                                hr = HSM_E_FILE_LOCK_VIOLATION;
                                break;
                            case ERROR_SHARING_VIOLATION:
                                hr = HSM_E_FILE_SHARING_VIOLATION;
                                break;
                            }

                            if (S_OK != hr)  {
                                // Tell the session how things went if they didn't go well.
                                (void) m_pSession->ProcessHr(m_JobPhase, 0, 0, hr);
                            }   

                            // Check if the job needs to be canceled
                            if (S_OK != ShouldJobContinue(hr)) {
                                // Log a message if the disk is full
                                if (FSA_E_REPARSE_NOT_CREATED_DISK_FULL == hr) {
                                    WsbLogEvent(HSM_MESSAGE_MANAGE_FAILED_DISK_FULL,
                                            0, NULL, WsbAbbreviatePath(path, 120), NULL);
                                }
                                hrComplete = hr;
                                skipWork = TRUE;
                            }
                            WsbAffirmHr(hr);
                        } else  {
                            //
                            // Skip the work
                            //
                            WsbLogEvent(HSM_MESSAGE_WORK_SKIPPED_COMMIT_FAILED,
                                    0, NULL, WsbAbbreviatePath(path, 120),
                                    WsbHrAsString(hr), NULL);
                            (void)m_pSession->ProcessItem(m_JobPhase,
                                    m_JobAction, pScanItem,
                                    HSM_E_WORK_SKIPPED_COMMIT_FAILED);
                        }
                    } WsbCatchAndDo(hr, hr = S_OK;);
                    (void)m_pWorkToCommit->RemoveAndRelease(pWorkItem);
                } else  {
                    //
                    // Found non fsa work - don't expect that!
                    //
                    ULONG tmp;
                    tmp = (ULONG)workType;
                    WsbTrace(OLESTR("Expecting FSA work, found <%lu>\n"), tmp);
                    hr = E_UNEXPECTED;
                }
            } else if (WSB_E_NOTFOUND == hr)  {
                // There are no more entries in the queue so we are done
                done = TRUE;
                hr = S_OK;
                m_DataCountBeforeCommit  = 0;
                m_FilesCountBeforeCommit = 0;
            }

            pWorkItem = 0;
            pFsaWorkItem = 0;
        }
    } WsbCatch(hr);

    if (S_OK != hrFlush) {
        FailJob();
    }

    if (S_OK != hrComplete) {
        hr = hrComplete;
    }

    WsbTraceOut(OLESTR("CHsmWorkQueue::CommitWork"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);
}

HRESULT
CHsmWorkQueue::StartNewMedia(
    IFsaPostIt *pFsaWorkItem
    )

/*++


--*/
{
    HRESULT                 hr = S_OK;
    BOOL                    dummyBool;
    CComPtr<IMediaInfo>     pMediaInfo;
    GUID                    storagePoolId;

    WsbTraceIn(OLESTR("CHsmWorkQueue::StartNewMedia"),OLESTR(""));
    try {
        WsbAffirmHr(pFsaWorkItem->GetStoragePoolId(&storagePoolId));
        WsbAffirmHr(GetMediaParameters());

        WsbAffirmHr(m_pSegmentDb->GetEntity(m_pDbWorkSession, HSM_MEDIA_INFO_REC_TYPE, IID_IMediaInfo,
                (void**)&pMediaInfo));
        WsbAffirmHr(CoCreateGuid(&m_MediaId));
        WsbAffirmHr(CoFileTimeNow(&m_MediaUpdate));
        WsbAffirmHr(pMediaInfo->GetRecreate(&dummyBool));
        WsbAffirmHr(pMediaInfo->SetMediaInfo(m_MediaId, m_MountedMedia, storagePoolId,
                                            m_MediaFreeSpace, m_MediaCapacity, m_BadMedia,
                                            1, m_MediaName, m_MediaType,
                                            m_MediaBarCode, m_MediaReadOnly, m_MediaUpdate,
                                            0, dummyBool));
        WsbAffirmHr(pMediaInfo->MarkAsNew());

        WsbAffirmHr(pMediaInfo->UpdateLastKnownGoodMaster());
        WsbAffirmHr(pMediaInfo->Write());
    } WsbCatch( hr );

    WsbTraceOut(OLESTR("CHsmWorkQueue::StartNewMedia"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);

}

HRESULT
CHsmWorkQueue::StartNewSession( void )

/*++


--*/
{
    HRESULT                 hr = S_OK;
    HRESULT                 hrSession = S_OK;
    CComPtr<IMediaInfo>     pMediaInfo;

    WsbTraceIn(OLESTR("CHsmWorkQueue::StartNewSession"),OLESTR(""));
    try {

        CWsbStringPtr strGuid;

        CWsbBstrPtr sessionName = HSM_BAG_NAME;
        WsbAffirmHr(WsbSafeGuidAsString(m_BagId, strGuid));
        sessionName.Append(strGuid);

        CWsbBstrPtr sessionDescription = HSM_ENGINE_ID;
        WsbAffirmHr(WsbSafeGuidAsString(m_HsmId, strGuid));
        sessionDescription.Append(strGuid);

        //
        // Find the media record to know the next remote data set
        //
        WsbAffirmHr(m_pSegmentDb->GetEntity(m_pDbWorkSession, HSM_MEDIA_INFO_REC_TYPE, IID_IMediaInfo,
                (void**)&pMediaInfo));
        WsbAffirmHr(pMediaInfo->SetId(m_MediaId));
        WsbAffirmHr(pMediaInfo->FindEQ());
        WsbAffirmHr(pMediaInfo->GetNextRemoteDataSet(&m_RemoteDataSet));

        //
        // Now call the data mover to begin a session.  If this doesn't work then
        // we want to mark the media as read only so that we will not overwrite
        // data.
        //
        m_BeginSessionHr = m_pDataMover->BeginSession(sessionName, sessionDescription, m_RemoteDataSet, MVR_SESSION_AS_LAST_DATA_SET);
        if (S_OK != m_BeginSessionHr)  {
            try  {
                //
                // Check the reason for the failure of the begin session.  If it is
                // MVR_E_DATA_SET_MISSING then the last begin session actually failed when
                // it was committed.  So, let's decrement the remote data set count and
                // redo the begin session that failed.
                //
                if (MVR_E_DATA_SET_MISSING == m_BeginSessionHr)  {
                    m_RemoteDataSet--;

                    //
                    // Try again...
                    m_BeginSessionHr = m_pDataMover->BeginSession(sessionName, sessionDescription, m_RemoteDataSet, MVR_SESSION_OVERWRITE_DATA_SET);

                    //
                    // !!! IMPORTANT NOTE !!!
                    //
                    // Update the media info to reflect new RemoteDataSet count.
                    // This will also correct any out of sync copies.
                    WsbAffirmHr(pMediaInfo->SetNextRemoteDataSet(m_RemoteDataSet));
                }
                switch (m_BeginSessionHr) {
                case S_OK:
                case MVR_E_BUS_RESET:
                case MVR_E_MEDIA_CHANGED:
                case MVR_E_NO_MEDIA_IN_DRIVE:
                case MVR_E_DEVICE_REQUIRES_CLEANING:
                case MVR_E_SHARING_VIOLATION:
                case MVR_E_ERROR_IO_DEVICE:
                case MVR_E_ERROR_DEVICE_NOT_CONNECTED:
                case MVR_E_ERROR_NOT_READY:
                    break;

                case MVR_E_INVALID_BLOCK_LENGTH:
                case MVR_E_WRITE_PROTECT:
                case MVR_E_CRC:
                default:
                    // Note the error
                    WsbAffirmHr(pMediaInfo->SetLastError(m_BeginSessionHr));
                    // Mark media as read only
                    m_MediaReadOnly = TRUE;
                    WsbAffirmHr(pMediaInfo->SetRecallOnlyStatus(m_MediaReadOnly));
                    // Write this out
                    WsbAffirmHr(pMediaInfo->Write());
                    break;
                }
            } WsbCatch( hrSession );
        }

        // If the BeginSession() failed, skip everything else.
        WsbAffirmHr(m_BeginSessionHr);

        //
        // Up the count of the remote data set and write it out
        m_RemoteDataSet++;
        WsbAffirmHr(pMediaInfo->SetNextRemoteDataSet(m_RemoteDataSet));

        // Write all of this out
        WsbAffirmHr(pMediaInfo->Write());

        //
        // Now set the Bag remote data set value
        //
        HSM_BAG_STATUS          l_BagStatus;
        LONGLONG                l_BagLen;
        USHORT                  l_BagType;
        FILETIME                l_BirthDate;
        LONGLONG                l_DeletedBagAmount;
        SHORT                   l_RemoteDataSet;
        GUID                    l_BagVolId;
        GUID                    l_BagId;
        CComPtr<IBagInfo>       pBagInfo;

        WsbAffirmHr(m_pSegmentDb->GetEntity(m_pDbWorkSession, HSM_BAG_INFO_REC_TYPE, IID_IBagInfo,
                         (void**)&pBagInfo));

        GetSystemTimeAsFileTime(&l_BirthDate);

        WsbAffirmHr(pBagInfo->SetBagInfo(HSM_BAG_STATUS_IN_PROGRESS, m_BagId, l_BirthDate,
                0, 0, GUID_NULL, 0, 0 ));
        WsbAffirmHr(pBagInfo->FindEQ());
        WsbAffirmHr(pBagInfo->GetBagInfo(&l_BagStatus, &l_BagId, &l_BirthDate,
                &l_BagLen, &l_BagType, &l_BagVolId, &l_DeletedBagAmount, &l_RemoteDataSet ));
        WsbAffirmHr(pBagInfo->SetBagInfo(l_BagStatus, l_BagId, l_BirthDate,
                l_BagLen, l_BagType, l_BagVolId, l_DeletedBagAmount, (SHORT)(m_RemoteDataSet - 1)));
        WsbAffirmHr(pBagInfo->Write());

        // Reset error counts
        m_JobConsecutiveErrors = 0;
        m_JobTotalErrors = 0;

    } WsbCatchAndDo(hr,
            FailJob();
        );

    WsbTraceOut(OLESTR("CHsmWorkQueue::StartNewSession"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);

}


HRESULT
CHsmWorkQueue::TranslateRmsMountHr(
    HRESULT     rmsMountHr
    )

/*++


--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkQueue::TranslateRmsMountHr"),OLESTR("rms hr = <%ls>"), WsbHrAsString(rmsMountHr));
    try {
        switch (rmsMountHr)  {
            case S_OK:
                hr = S_OK;
                ReportMediaProgress(HSM_JOB_MEDIA_STATE_MOUNTED, hr);
                break;
            case RMS_E_MEDIASET_NOT_FOUND:
                if (m_RmsMediaSetId == GUID_NULL)  {
                    hr = HSM_E_STG_PL_NOT_CFGD;
                } else {
                    hr = HSM_E_STG_PL_INVALID;
                }
                ReportMediaProgress(HSM_JOB_MEDIA_STATE_UNAVAILABLE, hr);
                break;
            case RMS_E_SCRATCH_NOT_FOUND:
                hr = HSM_E_NO_MORE_MEDIA;
                ReportMediaProgress(HSM_JOB_MEDIA_STATE_UNAVAILABLE, hr);
                break;
            case RMS_E_SCRATCH_NOT_FOUND_FINAL:
                hr = HSM_E_NO_MORE_MEDIA_FINAL;
                ReportMediaProgress(HSM_JOB_MEDIA_STATE_UNAVAILABLE, hr);
                break;
            case RMS_E_SCRATCH_NOT_FOUND_TOO_SMALL:
                hr = HSM_E_WORK_SKIPPED_FILE_TOO_BIG;
                ReportMediaProgress(HSM_JOB_MEDIA_STATE_UNAVAILABLE, hr);
                break;
            case RMS_E_CARTRIDGE_UNAVAILABLE:
            case RMS_E_RESOURCE_UNAVAILABLE:
            case RMS_E_DRIVE_UNAVAILABLE:
            case RMS_E_LIBRARY_UNAVAILABLE:
                hr = HSM_E_MEDIA_NOT_AVAILABLE;
                ReportMediaProgress(HSM_JOB_MEDIA_STATE_UNAVAILABLE, hr);
                break;
            case RMS_E_CARTRIDGE_BUSY:
            case RMS_E_RESOURCE_BUSY:
            case RMS_E_DRIVE_BUSY:
                hr = HSM_E_MEDIA_BUSY;
                ReportMediaProgress(HSM_JOB_MEDIA_STATE_BUSY, hr);
                break;
			case RMS_E_CARTRIDGE_NOT_FOUND:
			case RMS_E_CARTRIDGE_DISABLED:
            case RMS_E_TIMEOUT:
            case RMS_E_CANCELLED:
            case ERROR_REQUEST_REFUSED:
                hr = rmsMountHr;
                ReportMediaProgress(HSM_JOB_MEDIA_STATE_UNAVAILABLE, hr);
                break;
            case WSB_E_BAD_MEDIA:
            case WSB_E_WRITE_PROTECTED:
            case WSB_E_CANT_LOCK:
            case WSB_E_BAD_LABEL:
            case WSB_E_CANT_QUICK_FORMAT:
            case WSB_E_IO_ERROR:
            case WSB_E_VOLUME_TOO_SMALL:
            case WSB_E_VOLUME_TOO_BIG:
            case WSB_E_FORMAT_FAILED:
                hr = rmsMountHr;
                ReportMediaProgress(HSM_JOB_MEDIA_STATE_FAILED, hr);
                break;
            default:
                hr = rmsMountHr;
                (void) m_pSession->ProcessHr(m_JobPhase, __FILE__, __LINE__, rmsMountHr);
                ReportMediaProgress(HSM_JOB_MEDIA_STATE_UNAVAILABLE, hr);
                break;
        }
    } WsbCatch( hr );

    WsbTraceOut(OLESTR("CHsmWorkQueue::TranslateRmsMountHr"),
                OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);

}

HRESULT
CHsmWorkQueue::StoreDatabasesOnMedia( void )
/*++


--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkQueue::StoreDatabasesOnMedia"),OLESTR(""));
    try {
        //
        // For ultimate disaster recovery, write some files to media.  We want
        // to save the engine metadata and collection, the rms colleciton, NTMS
        // data and the fsa collection if it exists.
        //
        ULARGE_INTEGER  remoteDataSetStart;
        ULARGE_INTEGER  remoteFileStart;
        ULARGE_INTEGER  remoteFileSize;
        ULARGE_INTEGER  remoteDataStart;
        ULARGE_INTEGER  remoteDataSize;
        ULARGE_INTEGER  remoteVerificationData;
        ULONG           remoteVerificationType;
        ULARGE_INTEGER  dataStreamCRC;
        ULONG           dataStreamCRCType;
        ULARGE_INTEGER  usn;
        ULARGE_INTEGER  localDataSize;
        ULARGE_INTEGER  localDataStart;
        HANDLE          handle = INVALID_HANDLE_VALUE;
        WIN32_FIND_DATA findData;
        CWsbStringPtr   localName;
        CWsbBstrPtr     bStrLocalName;
        CWsbStringPtr   rootName;
        BOOL            foundFile = TRUE;
        BOOL            bFullMessage = TRUE;
        LONG            mediaType;
        BOOL            bNewSession = FALSE;

        //
        // Force a save of the persistent databases
        // We are not doing FSA here
        //
        try  {
            hr = m_pRmsServer->SaveAll();
            hr = m_pServer->SavePersistData();
        } WsbCatch( hr );


        //
        // In case of direct-access media, we terminate the Mover Session and open
        //  an additional special metadata session
        WsbAssert(m_pRmsCartridge != 0, E_UNEXPECTED);
        WsbAffirmHr(m_pRmsCartridge->GetType(&mediaType));
        switch (mediaType) {
            case RmsMediaOptical:
            case RmsMediaFixed:
            case RmsMediaDVD:
                bNewSession = TRUE;
                break;

            default:
                bNewSession = FALSE;
                break;
        }

        if (bNewSession) {
            // End current session
            m_BeginSessionHr = S_FALSE;
            WsbAffirmHr(m_pDataMover->EndSession());

            // Start a new one
            CWsbBstrPtr sessionName = HSM_METADATA_NAME;

            CWsbStringPtr strGuid;
            CWsbBstrPtr sessionDescription = HSM_ENGINE_ID;
            WsbAffirmHr(WsbSafeGuidAsString(m_HsmId, strGuid));
            sessionDescription.Append(strGuid);

            m_BeginSessionHr = m_pDataMover->BeginSession(
                    sessionName, 
                    sessionDescription, 
                    0, 
                    MVR_SESSION_METADATA | MVR_SESSION_AS_LAST_DATA_SET);

            if (S_OK != m_BeginSessionHr)  {
                HRESULT             hrSession = S_OK;
                CComPtr<IMediaInfo> pMediaInfo;

                try  {
                    // Check the error (some errors requires marking the media is Read Only
                    switch (m_BeginSessionHr) {
                    case S_OK:
                    case MVR_E_BUS_RESET:
                    case MVR_E_MEDIA_CHANGED:
                    case MVR_E_NO_MEDIA_IN_DRIVE:
                    case MVR_E_DEVICE_REQUIRES_CLEANING:
                    case MVR_E_SHARING_VIOLATION:
                    case MVR_E_ERROR_IO_DEVICE:
                    case MVR_E_ERROR_DEVICE_NOT_CONNECTED:
                    case MVR_E_ERROR_NOT_READY:
                        break;

                    case MVR_E_INVALID_BLOCK_LENGTH:
                    case MVR_E_WRITE_PROTECT:
                    case MVR_E_CRC:
                    default:
                        // Get the media record
                        WsbAffirmHr(m_pSegmentDb->GetEntity(m_pDbWorkSession, HSM_MEDIA_INFO_REC_TYPE, 
                             IID_IMediaInfo, (void**)&pMediaInfo));
                        WsbAffirmHr(pMediaInfo->SetId(m_MediaId));
                        WsbAffirmHr(pMediaInfo->FindEQ());
                        // Note the error
                        WsbAffirmHr(pMediaInfo->SetLastError(m_BeginSessionHr));
                        // Mark media as read only
                        m_MediaReadOnly = TRUE;
                        WsbAffirmHr(pMediaInfo->SetRecallOnlyStatus(m_MediaReadOnly));
                        // Write this out
                        WsbAffirmHr(pMediaInfo->Write());
                        break;
                    }
                } WsbCatch( hrSession );
            } // end if BeginSession error

            WsbAffirmHr(m_BeginSessionHr);
        } // end if new mover session

        //
        // Start at the beginning of all files
        //
        localDataStart.LowPart = 0;
        localDataStart.HighPart = 0;

        //
        // First go the the remote storage and save the collections
        //
        try  {
            // Get the name of the file
            WsbAffirmHr(m_pServer->GetDbPath(&rootName, 0));
            WsbAffirmHr(rootName.Append(OLESTR("\\")));
            localName = rootName;
            WsbAffirmHr(localName.Append(OLESTR("Rs*.bak")));


            // Find out the file(s)
            handle = FindFirstFile(localName, &findData);
            localName = rootName;
            WsbAffirmHr(localName.Append((OLECHAR *)(findData.cFileName)));

            // Copy each file to tape
            while ((INVALID_HANDLE_VALUE != handle) && (foundFile == TRUE))  {
                if ((FILE_ATTRIBUTE_DIRECTORY & findData.dwFileAttributes) != FILE_ATTRIBUTE_DIRECTORY) {
                    localDataSize.LowPart = findData.nFileSizeLow;
                    localDataSize.HighPart = findData.nFileSizeHigh;
                    bStrLocalName = localName;
                    hr =  StoreDataWithRetry(  bStrLocalName,
                                                    localDataStart,
                                                    localDataSize,
                                                    MVR_FLAG_BACKUP_SEMANTICS,
                                                    &remoteDataSetStart,
                                                    &remoteFileStart,
                                                    &remoteFileSize,
                                                    &remoteDataStart,
                                                    &remoteDataSize,
                                                    &remoteVerificationType,
                                                    &remoteVerificationData,
                                                    &dataStreamCRCType,
                                                    &dataStreamCRC,
                                                    &usn,
                                                    &bFullMessage);
                }

                foundFile = FindNextFile(handle, &findData);
                localName = rootName;
                WsbAffirmHr(localName.Append((OLECHAR *)(findData.cFileName)));
            }

        } WsbCatch(hr);
        if ( INVALID_HANDLE_VALUE != handle ) {
            FindClose(handle);
            handle = INVALID_HANDLE_VALUE;
        }

        //
        // Next save the hsm metadata
        //
        try  {
            //
            // First backup the databases since the backup files
            // are the ones that are saved.
            //
            WsbAffirmHr(m_pServer->BackupSegmentDb());

            // Create the search path
            localName = "";
            WsbAffirmHr(m_pServer->GetIDbPath(&rootName, 0));
            WsbAffirmHr(rootName.Append(OLESTR(".bak\\")));
            localName = rootName;
            WsbAffirmHr(localName.Append(OLESTR("*.*")));

            // Find the first file
            handle = FindFirstFile(localName, &findData);
            localName = rootName;
            WsbAffirmHr(localName.Append((OLECHAR *)(findData.cFileName)));

            // Copy each file to tape
            foundFile = TRUE;
            while ((INVALID_HANDLE_VALUE != handle) && (foundFile == TRUE))  {
                if ((FILE_ATTRIBUTE_DIRECTORY & findData.dwFileAttributes) != FILE_ATTRIBUTE_DIRECTORY) {
                    localDataSize.LowPart = findData.nFileSizeLow;
                    localDataSize.HighPart = findData.nFileSizeHigh;
                    bStrLocalName = localName;
                    hr =  StoreDataWithRetry(  bStrLocalName,
                                                    localDataStart,
                                                    localDataSize,
                                                    MVR_FLAG_BACKUP_SEMANTICS,
                                                    &remoteDataSetStart,
                                                    &remoteFileStart,
                                                    &remoteFileSize,
                                                    &remoteDataStart,
                                                    &remoteDataSize,
                                                    &remoteVerificationType,
                                                    &remoteVerificationData,
                                                    &dataStreamCRCType,
                                                    &dataStreamCRC,
                                                    &usn,
                                                    &bFullMessage);
                }
                foundFile = FindNextFile(handle, &findData);
                localName = rootName;
                WsbAffirmHr(localName.Append((OLECHAR *)(findData.cFileName)));
            }
        } WsbCatch(hr);
        if ( INVALID_HANDLE_VALUE != handle ) {
            FindClose(handle);
            handle = INVALID_HANDLE_VALUE;
        }

        //
        // Next go the the NTMS databases and save them
        //
        try  {
            DWORD               sizeGot;
            //
            // NTMS saves databases in a subdirectory parallel to the
            // RemoteStorage subdirectory.  So go there and just take
            // the necessary files.
            //
            localName = "";
            WsbAffirmHr(localName.Realloc(1024));
            //
            // Use the relocatable meta-data path if it's available,
            // otherwise default to the %SystemRoot%\System32\RemoteStorage
            //
            hr = WsbGetRegistryValueString(NULL, WSB_RSM_CONTROL_REGISTRY_KEY, WSB_RSM_METADATA_REGISTRY_VALUE, localName, 256, &sizeGot);
            if (hr == S_OK) {
                WsbAffirmHr(localName.Append(OLESTR("NtmsData\\NTMSDATA.BAK")));
            } else {
                WsbAffirmHr(WsbEnsureRegistryKeyExists(NULL, WSB_CURRENT_VERSION_REGISTRY_KEY));
                WsbAffirmHr(WsbGetRegistryValueString(NULL, WSB_CURRENT_VERSION_REGISTRY_KEY, WSB_SYSTEM_ROOT_REGISTRY_VALUE, localName, 256, &sizeGot));
                WsbAffirmHr(localName.Append(OLESTR("\\system32\\NtmsData\\NTMSDATA.BAK")));
            }

            // Find the first one
            handle = FindFirstFile(localName, &findData);

            // Copy each file to tape
            if (INVALID_HANDLE_VALUE != handle)  {
                localDataSize.LowPart = findData.nFileSizeLow;
                localDataSize.HighPart = findData.nFileSizeHigh;
                bStrLocalName = localName;
                hr =  StoreDataWithRetry(  bStrLocalName,
                                           localDataStart,
                                           localDataSize,
                                           MVR_FLAG_BACKUP_SEMANTICS,
                                           &remoteDataSetStart,
                                           &remoteFileStart,
                                           &remoteFileSize,
                                           &remoteDataStart,
                                           &remoteDataSize,
                                           &remoteVerificationType,
                                           &remoteVerificationData,
                                           &dataStreamCRCType,
                                           &dataStreamCRC,
                                           &usn,
                                           &bFullMessage);
            }


        } WsbCatch(hr);
        if ( INVALID_HANDLE_VALUE != handle ) {
            FindClose(handle);
            handle = INVALID_HANDLE_VALUE;
        }

        //
        // Next save the NTMS Export files.
        //
        try  {
            DWORD               sizeGot;
            //
            // NTMS saves Export files in the EXPORT directory.  We take
            // all the files in this dir.  StoreData does the findFirst for us.
            //
            localName = "";
            WsbAffirmHr(localName.Realloc(256));
            WsbAffirmHr(WsbEnsureRegistryKeyExists(NULL, WSB_CURRENT_VERSION_REGISTRY_KEY));
            WsbAffirmHr(WsbGetRegistryValueString(NULL, WSB_CURRENT_VERSION_REGISTRY_KEY, WSB_SYSTEM_ROOT_REGISTRY_VALUE, localName, 256, &sizeGot));
            WsbAffirmHr(localName.Append(OLESTR("\\system32\\NtmsData\\Export\\*.*")));

            bStrLocalName = localName;
            localDataStart.QuadPart = 0;
            localDataSize.QuadPart = 0;
            hr =  StoreDataWithRetry(  bStrLocalName,
                                            localDataStart,
                                            localDataSize,
                                            MVR_FLAG_BACKUP_SEMANTICS,
                                            &remoteDataSetStart,
                                            &remoteFileStart,
                                            &remoteFileSize,
                                            &remoteDataStart,
                                            &remoteDataSize,
                                            &remoteVerificationType,
                                            &remoteVerificationData,
                                            &dataStreamCRCType,
                                            &dataStreamCRC,
                                            &usn,
                                            &bFullMessage);


        } WsbCatch(hr);

    } WsbCatch(hr);

    //
    // Whatever happens, return OK
    //
    hr = S_OK;


    WsbTraceOut(OLESTR("CHsmWorkQueue::StoreDatabasesOnMedia"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);
}


HRESULT
CHsmWorkQueue::StoreDataWithRetry(
        IN BSTR localName,
        IN ULARGE_INTEGER localDataStart,
        IN ULARGE_INTEGER localDataSize,
        IN DWORD flags,
        OUT ULARGE_INTEGER *pRemoteDataSetStart,
        OUT ULARGE_INTEGER *pRemoteFileStart,
        OUT ULARGE_INTEGER *pRemoteFileSize,
        OUT ULARGE_INTEGER *pRemoteDataStart,
        OUT ULARGE_INTEGER *pRemoteDataSize,
        OUT DWORD *pRemoteVerificationType,
        OUT ULARGE_INTEGER *pRemoteVerificationData,
        OUT DWORD *pDatastreamCRCType,
        OUT ULARGE_INTEGER *pDatastreamCRC,
        OUT ULARGE_INTEGER *pUsn,
        OUT BOOL *bFullMessage
        )

/*++

Routine Description:

    Calls StoreData with retries in case the file to write from is in use.

Arguments:

    Same as StoreData

Return Value:

    From StoreData

--*/
{
#define MAX_STOREDATA_RETRIES  3

    HRESULT hr = S_OK;
    LONG    RetryCount = 0;

    WsbTraceIn(OLESTR("CHsmWorkQueue::StoreDataWithRetry"), OLESTR("file <%ls>"),
            static_cast<OLECHAR *>(localName));

    for (RetryCount = 0; (RetryCount < MAX_STOREDATA_RETRIES) && (hr != E_ABORT) && (hr != MVR_E_MEDIA_ABORT);  RetryCount++) {
        if (RetryCount > 0) {
            WsbLogEvent(HSM_MESSAGE_DATABASE_FILE_COPY_RETRY, 0, NULL,
                WsbAbbreviatePath((WCHAR *) localName, 120), NULL);
        }
        // Make sure data mover is ready for work.
        WsbAffirmPointer(m_pDataMover);
        hr =  m_pDataMover->StoreData(localName, localDataStart, localDataSize,
            flags, pRemoteDataSetStart, pRemoteFileStart, pRemoteFileSize,
            pRemoteDataStart, pRemoteDataSize, pRemoteVerificationType,
            pRemoteVerificationData, pDatastreamCRCType, pDatastreamCRC,
            pUsn);
        WsbTrace(OLESTR("CHsmWorkQueue::StoreDataWithRetry: StoreData hr = <%ls>\n"),
                WsbHrAsString(hr) );
        if (S_OK == hr) break;
        Sleep(1000);
    }

    if (hr != S_OK) {
        if (*bFullMessage) {
            WsbLogEvent(HSM_MESSAGE_GENERAL_DATABASE_FILE_NOT_COPIED, 0, NULL, WsbHrAsString(hr), NULL);
			*bFullMessage = FALSE;
        }
        WsbLogEvent(HSM_MESSAGE_DATABASE_FILE_NOT_COPIED, 0, NULL,
            WsbAbbreviatePath((WCHAR *) localName, 120), WsbHrAsString(hr), NULL);
    }

    WsbTraceOut(OLESTR("CHsmWorkQueue::StoreDataWithRetry"), OLESTR("hr = <%ls>"),
            WsbHrAsString(hr) );
    return(hr);
}


HRESULT
CHsmWorkQueue::ShouldJobContinue(
    HRESULT problemHr
    )

/*++

Implements:

  CHsmWorkQueue::ShouldJobContinue().

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkQueue::ShouldJobContinue"), OLESTR("<%ls>"), WsbHrAsString(problemHr));
    try {
        // Collect some error counts and check if we've had too many
        if (S_OK == problemHr) {
            // Reset consecutive error count
            m_JobConsecutiveErrors = 0;
        } else {
            m_JobConsecutiveErrors++;
            m_JobTotalErrors++;
            if (m_JobConsecutiveErrors >= m_JobAbortMaxConsecutiveErrors) {
                WsbLogEvent(HSM_MESSAGE_TOO_MANY_CONSECUTIVE_JOB_ERRORS,
                        0, NULL, WsbLongAsString(m_JobConsecutiveErrors), NULL);
                hr = S_FALSE;
            } else if (m_JobTotalErrors >= m_JobAbortMaxTotalErrors) {
                WsbLogEvent(HSM_MESSAGE_TOO_MANY_TOTAL_JOB_ERRORS,
                        0, NULL, WsbLongAsString(m_JobTotalErrors), NULL);
                hr = S_FALSE;
            }
        }

        //
        // Evaluate the input HR to decide if we should try to continue with the job or if
        // we should abandon the job because the problem is not recoverable.
        //
        if (S_OK == hr) {
            switch (problemHr)  {
                case E_ABORT:
                case MVR_E_MEDIA_ABORT:
                case FSA_E_REPARSE_NOT_CREATED_DISK_FULL:
                case WSB_E_SYSTEM_DISK_FULL:
                    //
                    // we want to cancel the job
                    //
                    hr = S_FALSE;
                    break;

                default:
                    // Be optimistic and try to keep going
                    hr = S_OK;
                    break;
            }
        }

        // Abort the job if necessary
        if (S_FALSE == hr) {
            WsbAffirmHr(FailJob());
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkQueue::ShouldJobContinue"), OLESTR("hr = <%ls>"), WsbHrAsString(hr) );
    return(hr);
}

HRESULT
CHsmWorkQueue::Remove(
    IHsmWorkItem *pWorkItem
    )
/*++

Implements:

  IHsmFsaTskMgr::Remove

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkQueue::Remove"),OLESTR(""));
    try  {
        //
        // Remove the item from the queue and see if we need to
        // resume the scanner (if it is paused)
        //
        (void)m_pWorkToDo->RemoveAndRelease(pWorkItem);
        ULONG numItems;
        WsbAffirmHr(m_pWorkToDo->GetEntries(&numItems));
        WsbTrace(OLESTR("CHsmWorkQueue::Remove - num items in queue = <%lu>\n"),numItems);
        if (numItems <= m_QueueItemsToResume)  {
            WsbAffirmHr(ResumeScanner());
        }
    } WsbCatch (hr);

    WsbTraceOut(OLESTR("CHsmWorkQueue::Remove"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return (hr);
}


HRESULT
CHsmWorkQueue::ChangeSysState(
    IN OUT HSM_SYSTEM_STATE* pSysState
    )

/*++

Implements:

  IHsmSystemState::ChangeSysState().

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkQueue::ChangeSysState"), OLESTR(""));

    try {

        if (pSysState->State & HSM_STATE_SUSPEND) {
            // Should have already been paused via the job
        } else if (pSysState->State & HSM_STATE_RESUME) {
            // Should have already been resumed via the job
        } else if (pSysState->State & HSM_STATE_SHUTDOWN) {

            //  Release the thread (we assume it has been stopped already)
            if (m_WorkerThread) {
                CloseHandle(m_WorkerThread);
                m_WorkerThread = 0;
            }

            if (m_pDataMover) {
                //
                // Cancel any active I/O
                //
                (void) m_pDataMover->Cancel();
            }

            // If Session is valid - unadvise and free session, otherwise, just try to
            // dismount media if it is mounted (which we don't know at this point)
            // Best effort dismount, no error checking so following resources will get released.
            if (m_pSession != 0) {
                EndSessions(FALSE, TRUE);
            } else {
                (void) DismountMedia(TRUE);
            }
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmWorkQueue::ChangeSysState"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmWorkQueue::UnsetMediaInfo( void )

/*++

Routine Description:

    Sets the media data members back to their default (unset) values.

Arguments:

    None.

Return Value:

    S_OK:  Ok.

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkQueue::UnsetMediaInfo"), OLESTR(""));

    m_MediaId        = GUID_NULL;
    m_MountedMedia   = GUID_NULL;
    m_MediaType      = HSM_JOB_MEDIA_TYPE_UNKNOWN;
    m_MediaName      = OLESTR("");
    m_MediaBarCode   = OLESTR("");
    m_MediaFreeSpace = 0;
    m_MediaCapacity = 0;
    m_MediaReadOnly = FALSE;
    m_MediaUpdate = WsbLLtoFT(0);
    m_BadMedia       = S_OK;
    m_RemoteDataSetStart.QuadPart   = 0;
    m_RemoteDataSet  = 0;

    WsbTraceOut(OLESTR("CHsmWorkQueue::UnsetMediaInfo"), OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);
}

HRESULT
CHsmWorkQueue::UpdateMediaFreeSpace( void )

/*++
Routine Description:
    Updates media free space in the database based on Mover current information.
    This method should be called only while the current media is still mounted.

Arguments:
    None.

Return Value:
    S_OK:  Ok.
--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkQueue::UpdateMediaFreeSpace"), OLESTR(""));

    try
    {
        CComPtr<IMediaInfo>     pMediaInfo;
        LONGLONG                currentFreeSpace;

        WsbAssert(GUID_NULL != m_MediaId, E_UNEXPECTED);
        WsbAffirm(m_pDbWorkSession != 0, E_FAIL);

        // Find media record
        WsbAffirmHr(m_pSegmentDb->GetEntity(m_pDbWorkSession, HSM_MEDIA_INFO_REC_TYPE, 
                IID_IMediaInfo, (void**)&pMediaInfo));

        WsbAffirmHr(pMediaInfo->SetId(m_MediaId));
        WsbAffirmHr(pMediaInfo->FindEQ());

        // Get updated free space
        WsbAffirmHr(pMediaInfo->GetFreeBytes(&currentFreeSpace));
        WsbAffirmHr(GetMediaParameters(currentFreeSpace));

        // Update in the media table
        WsbAffirmHr(pMediaInfo->SetFreeBytes(m_MediaFreeSpace));

        WsbAffirmHr(pMediaInfo->UpdateLastKnownGoodMaster());
        WsbAffirmHr(pMediaInfo->Write());

    } WsbCatch( hr );

    WsbTraceOut(OLESTR("CHsmWorkQueue::UpdateMediaFreeSpace"), OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);
}

HRESULT
CHsmWorkQueue::GetMediaFreeSpace( LONGLONG *pFreeSpace )

/*++
Routine Description:
    Retrieves internal free space from HSM DB (media table)

Arguments:
    None.

Return Value:
    S_OK:  Ok.
--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmWorkQueue::GetMediaFreeSpace"), OLESTR(""));

    try
    {
        CComPtr<IMediaInfo>     pMediaInfo;

        WsbAssert(GUID_NULL != m_MediaId, E_UNEXPECTED);
        WsbAssert(m_pDbWorkSession != 0, E_UNEXPECTED);
        WsbAssertPointer(pFreeSpace);

        *pFreeSpace = 0;

        // Update in the media table
        WsbAffirmHr(m_pSegmentDb->GetEntity(m_pDbWorkSession, HSM_MEDIA_INFO_REC_TYPE, 
                IID_IMediaInfo, (void**)&pMediaInfo));

        WsbAffirmHr(pMediaInfo->SetId(m_MediaId));
        WsbAffirmHr(pMediaInfo->FindEQ());
        WsbAffirmHr(pMediaInfo->GetFreeBytes(pFreeSpace));

    } WsbCatch( hr );

    WsbTraceOut(OLESTR("CHsmWorkQueue::GetMediaFreeSpace"), OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\engine\task\medinfo.cpp ===
/*++

Copyright (c) 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    MedInfo.cpp

Abstract:

    This component is an object representation of the HSM Metadata media information
    record.

Author:

    Cat Brant   [cbrant]   27-Feb-1997

Revision History:

--*/


#include "stdafx.h"

#include "wsbgen.h"
#include "engine.h"
#include "metaint.h"
#include "metalib.h"
#include "MedInfo.h"
#include "segdb.h"

#undef  WSB_TRACE_IS     
#define WSB_TRACE_IS        WSB_TRACE_BIT_META
static USHORT iCountMedinfo = 0;


HRESULT 
CMediaInfo::FinalConstruct(
    void
    ) 
/*++

Routine Description:

  This method does some initialization of the object that is necessary
  after construction.

Arguments:

  None.

Return Value:

  S_OK
  Anything returned by CWsbDbEntity::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CMediaInfo::FinalConstruct"),OLESTR(""));
    try {

        WsbAssertHr(CWsbDbEntity::FinalConstruct());

        //
        // Initialize the master media record
        //
        m_Master.id = GUID_NULL;
        m_Master.ntmsId = GUID_NULL;
        m_Master.storagePoolId = GUID_NULL;
        m_Master.description = OLESTR("");
        m_Master.name = OLESTR("");
        m_Master.type = HSM_JOB_MEDIA_TYPE_UNKNOWN;
        m_Master.lastUpdate = WsbLLtoFT(0);
        m_Master.lastError = S_OK;
        m_Master.recallOnly = FALSE;
        m_Master.freeBytes = 0;
        m_Master.capacity = 0;
        m_Master.nextRemoteDataSet = 0;
        
        m_Recreate = FALSE;
        m_LogicalValidBytes = 0;
        
        //
        // Now initialize the last known good master
        //
        m_LastKnownGoodMaster.id = GUID_NULL;
        m_LastKnownGoodMaster.ntmsId = GUID_NULL;
        m_LastKnownGoodMaster.storagePoolId = GUID_NULL;
        m_LastKnownGoodMaster.description = OLESTR("");
        m_LastKnownGoodMaster.name = OLESTR("");
        m_LastKnownGoodMaster.type = HSM_JOB_MEDIA_TYPE_UNKNOWN;
        m_LastKnownGoodMaster.lastUpdate = WsbLLtoFT(0);
        m_LastKnownGoodMaster.lastError = S_OK;
        m_LastKnownGoodMaster.recallOnly = FALSE;
        m_LastKnownGoodMaster.freeBytes = 0;
        m_LastKnownGoodMaster.capacity = 0;
        m_LastKnownGoodMaster.nextRemoteDataSet = 0;
            
        //
        // Initialize the master's copy media records
        //
        for (int i = 0; i < HSM_MAX_NUMBER_MEDIA_COPIES; i++)  {
            m_Copy[i].id = GUID_NULL;
            m_Copy[i].description = OLESTR("");
            m_Copy[i].name = OLESTR("");
            m_Copy[i].lastUpdate = WsbLLtoFT(0);
            m_Copy[i].lastError = S_OK;
            m_Copy[i].nextRemoteDataSet = 0;
        }            
        
    } WsbCatch(hr);
    iCountMedinfo++;
    WsbTraceOut(OLESTR("CMediaInfo::FinalConstruct"), OLESTR("hr = <%ls>, Count is <%d>"), 
            WsbHrAsString(hr), iCountMedinfo);
    return(hr);
}



void
CMediaInfo::FinalRelease(
    void
    )

/*++

Implements:

  CMediaInfo::FinalRelease().

--*/
{
    
    WsbTraceIn(OLESTR("CMediaInfo::FinalRelease"), OLESTR(""));
    
    CWsbDbEntity::FinalRelease();
    iCountMedinfo--;
    
    WsbTraceOut(OLESTR("CMediaInfo::FinalRelease"), OLESTR("Count is <%d>"), iCountMedinfo);
}



HRESULT
CMediaInfo::GetName(
    OLECHAR **pName,
    ULONG   bufferSize
    )
/*++

Implements:

  IMediaInfo::GetName

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::GetName"),OLESTR("buffer size = <%lu>"), bufferSize);
    try {
        WsbAssertPointer(pName);
        CWsbStringPtr tmpName;
        tmpName = m_Master.name;
        WsbAffirmHr(tmpName.CopyTo(pName, bufferSize));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::GetName"), OLESTR("hr = <%ls>, Name = <%ls>"), WsbHrAsString(hr), WsbPtrToStringAsString(pName));
    return(hr);
}


HRESULT
CMediaInfo::GetCapacity( 
    LONGLONG *pCapacity 
    )
/*++

Implements:

  IMediaInfo::GetCapacity

--*/

{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::GetCapacity"),OLESTR(""));
    try {
        WsbAssertPointer(pCapacity);
        *pCapacity = m_Master.capacity;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::GetCapacity"), OLESTR("hr = <%ls>, Capacity = <%ls>"), WsbHrAsString(hr), WsbPtrToLonglongAsString(pCapacity));
    return(hr);
}

HRESULT CMediaInfo::GetClassID
(
    OUT LPCLSID pclsid
    ) 
/*++

Implements:

  IPerist::GetClassID()

--*/

{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CMediaInfo::GetClassID"), OLESTR(""));
    try {
        WsbAssert(0 != pclsid, E_POINTER);

        *pclsid = CLSID_CMediaInfo;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pclsid));
    return(hr);
}

HRESULT
CMediaInfo:: GetCopyName( 
    USHORT copyNumber, 
    OLECHAR **pName,
    ULONG   bufferSize
    )
/*++

Implements:

  IMediaInfo::GetCopyName

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::GetCopyName"),OLESTR(""));
    try {
        WsbAffirm(((0 < copyNumber) && (copyNumber <= HSM_MAX_NUMBER_MEDIA_COPIES)),
                E_INVALIDARG);
        WsbAssertPointer(pName);
        CWsbStringPtr tmpString;
        tmpString = m_Copy[copyNumber - 1].name;
        WsbAffirmHr(tmpString.CopyTo(pName, bufferSize));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::GetCopyName"), OLESTR("hr = <%ls>, Name = <%ls>"), WsbHrAsString(hr), WsbPtrToStringAsString(pName));
    return(hr);
}

HRESULT
CMediaInfo:: GetCopyNextRemoteDataSet( 
    USHORT copyNumber, 
    SHORT  *pNextRemoteDataSet
    )
/*++

Implements:

  IMediaInfo::GetCopyNextRemoteDataSet

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::GetCopyNextRemoteDataSet"),OLESTR(""));
    try {
        WsbAffirm(((0 < copyNumber) && (copyNumber <= HSM_MAX_NUMBER_MEDIA_COPIES)),
                E_INVALIDARG);
        WsbAssertPointer(pNextRemoteDataSet);
        *pNextRemoteDataSet = m_Copy[copyNumber - 1].nextRemoteDataSet;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::GetCopyNextRemoteDataSet"), OLESTR("hr = <%ls>, NextRemoteDataSet = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pNextRemoteDataSet));
    return(hr);
}

HRESULT
CMediaInfo::GetCopyDescription( 
    USHORT copyNumber, 
    OLECHAR **pDescription,
    ULONG   bufferSize
    )       
/*++

Implements:

  IMediaInfo::GetCopyDescription

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::GetCopyDescription"),OLESTR("Copy = <%u>"), copyNumber);
    try {
        WsbAffirm(((0 < copyNumber) && (copyNumber <= HSM_MAX_NUMBER_MEDIA_COPIES)),
                E_INVALIDARG);
        WsbAssertPointer(pDescription);
        CWsbStringPtr tmpDescription;
        tmpDescription = m_Copy[copyNumber - 1].description;
        WsbAffirmHr(tmpDescription.CopyTo(pDescription, bufferSize));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::GetCopyDescription"), OLESTR("hr = <%ls>, CopyDescription = <%ls>"), WsbHrAsString(hr), WsbPtrToStringAsString(pDescription));
    return(hr);
}


HRESULT
CMediaInfo::GetCopyInfo( 
    USHORT copyNumber, 
    GUID *pMediaSubsystemId, 
    OLECHAR **pDescription, 
    ULONG   descriptionBufferSize,
    OLECHAR **pName, 
    ULONG   nameBufferSize,
    FILETIME *pUpdate, 
    HRESULT *pLastError,
    SHORT  *pNextRemoteDataSet
    )
/*++

Implements:

  IMediaInfo::GetCopyInfo

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::GetCopyInfo"),OLESTR("Copy is <%u>"), copyNumber);
    try {
        WsbAffirm(((0 < copyNumber) && (copyNumber <= HSM_MAX_NUMBER_MEDIA_COPIES)),
                E_INVALIDARG);
        if (pMediaSubsystemId != 0)  {
            *pMediaSubsystemId = m_Copy[copyNumber - 1].id;
        }
        if (pDescription != 0)  {
            CWsbStringPtr tmpDescription;
            tmpDescription = m_Copy[copyNumber - 1].description;
            tmpDescription.CopyTo(pDescription, descriptionBufferSize);
        }
        if (pName != 0)  {
            CWsbStringPtr tmpString;
            tmpString = m_Copy[copyNumber - 1].name;
            tmpString.CopyTo(pName, nameBufferSize);
        }
        if (pUpdate != 0)  {
            *pUpdate = m_Copy[copyNumber - 1].lastUpdate;
        }
        if (pLastError != 0 )  {
            *pLastError = m_Copy[copyNumber - 1].lastError;
        }
    
        if (pNextRemoteDataSet != 0 )  {
            *pNextRemoteDataSet = m_Copy[copyNumber - 1].nextRemoteDataSet;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::GetCopyInfo"), 
            OLESTR("hr = <%ls>, SubSystemID = <%ls>, Description = <%ls>, Name = <%ls>, Update = <%ls>, LastError = <%ls>, NextRemoteDataSet = <%ls>"), 
            WsbHrAsString(hr), WsbPtrToGuidAsString(pMediaSubsystemId), 
            WsbQuickString(WsbPtrToStringAsString(pDescription)), WsbQuickString(WsbPtrToStringAsString(pName)),
            WsbPtrToFiletimeAsString(FALSE, pUpdate), WsbPtrToHrAsString(pLastError),
            WsbPtrToShortAsString(pNextRemoteDataSet));
    return(hr);
}

HRESULT
CMediaInfo::GetCopyLastError( 
    USHORT copyNumber, 
    HRESULT *pLastError 
    )
/*++

Implements:

  IMediaInfo::GetCopyLastError

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::GetCopyLastError"),OLESTR("Copy is <%u>"), copyNumber);
    try {
        WsbAffirm(((0 < copyNumber) && (copyNumber <= HSM_MAX_NUMBER_MEDIA_COPIES)),
                E_INVALIDARG);
        WsbAssertPointer(pLastError); 
        *pLastError = m_Copy[copyNumber - 1].lastError;                               
    
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::GetCopyLastError"), OLESTR("hr = <%ls>, Last Error = <%ls>"), WsbHrAsString(hr), WsbPtrToHrAsString(pLastError));
    return(hr);
}

HRESULT
CMediaInfo::GetCopyMediaSubsystemId( 
    USHORT copyNumber, 
    GUID *pMediaSubsystemId 
    )
/*++

Implements:

  IMediaInfo::GetCopyMediaSubsystemId

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::GetCopyMediaSubsystemId"),OLESTR("Copy is <%u>"), copyNumber);
    try {
        WsbAffirm(((0 < copyNumber) && (copyNumber <= HSM_MAX_NUMBER_MEDIA_COPIES)),
                E_INVALIDARG);
        WsbAssertPointer(pMediaSubsystemId); 
        *pMediaSubsystemId = m_Copy[copyNumber - 1].id;
    
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::GetCopyMediaSubsystemId"), OLESTR("hr = <%ls>, ID = <%ls>"), WsbHrAsString(hr), WsbPtrToGuidAsString(pMediaSubsystemId));
    return(hr);
}

HRESULT
CMediaInfo::GetCopyUpdate(
    USHORT copyNumber, 
    FILETIME *pUpdate 
    )
/*++

Implements:

  IMediaInfo::GetCopyUpdate

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::GetCopyUpdate"),OLESTR("Copy is <%u>"), copyNumber);
    try {
        WsbAffirm(((0 < copyNumber) && (copyNumber <= HSM_MAX_NUMBER_MEDIA_COPIES)),
                E_INVALIDARG);
        WsbAssertPointer(pUpdate);
        *pUpdate = m_Copy[copyNumber - 1].lastUpdate;
    
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::GetCopyUpdate"), OLESTR("hr = <%ls>, Update = <%ls>"), WsbHrAsString(hr), WsbPtrToFiletimeAsString(FALSE,pUpdate));
    return(hr);
}

HRESULT
CMediaInfo::GetDescription(
    OLECHAR **pDescription,
    ULONG bufferSize
    )
/*++

Implements:

  IMediaInfo::GetDescription

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::GetDescription"),OLESTR(""));
    try {
        WsbAssertPointer(pDescription);
        CWsbStringPtr tmpDescription;
        tmpDescription = m_Master.description;
        WsbAffirmHr(tmpDescription.CopyTo(pDescription, bufferSize));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::GetDescription"), OLESTR("hr = <%ls>, Description = <%ls>"), WsbHrAsString(hr), WsbPtrToStringAsString(pDescription));
    return(hr);
}

HRESULT
CMediaInfo::GetFreeBytes( 
    LONGLONG *pFreeBytes
    )
/*++

Implements:

  IMediaInfo::GetFreeBytes

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::GetFreeBytes"),OLESTR(""));
    try {
        WsbAssertPointer(pFreeBytes);
        *pFreeBytes = m_Master.freeBytes;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::GetFreeBytes"), OLESTR("hr = <%ls>, Free Space = <%ls>"), WsbHrAsString(hr), WsbPtrToLonglongAsString(pFreeBytes));
    return(hr);
}

HRESULT
CMediaInfo::GetId(
    GUID *pId
    )
/*++

Implements:

  IMediaInfo::GetId

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::GetId"),OLESTR(""));
    try {
        WsbAssertPointer(pId);
        *pId = m_Master.id;
    
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::GetId"), OLESTR("hr = <%ls>, Id = <%ls>"), WsbHrAsString(hr), WsbPtrToGuidAsString(pId));
    return(hr);
}

HRESULT
CMediaInfo::GetLastError(
    HRESULT *pLastError
    )
/*++

Implements:

  IMediaInfo::GetLastError

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::GetLastError"),OLESTR(""));
    try {
        WsbAssertPointer(pLastError);
        *pLastError = m_Master.lastError;
    
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::GetLastError"), OLESTR("hr = <%ls>, LastError = <%ls>"), WsbHrAsString(hr), WsbPtrToHrAsString(pLastError));
    return(hr);
}

HRESULT
CMediaInfo::GetLogicalValidBytes(
    LONGLONG *pLogicalValidBytes
    )
/*++

Implements:

  IMediaInfo::GetLogicalValidBytes

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::GetLogicalValidBytes"),OLESTR(""));
    try {
        WsbAssertPointer(pLogicalValidBytes);
        *pLogicalValidBytes = m_LogicalValidBytes;
    
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::GetLogicalValidBytes"), OLESTR("hr = <%ls>, LogicalValidBytes = <%ls>"), WsbHrAsString(hr), WsbPtrToLonglongAsString(pLogicalValidBytes));
    return(hr);
}

HRESULT
CMediaInfo::GetMediaInfo( 
    GUID* pMediaId, 
    GUID *pMediaSubsystemId, 
    GUID *pStoragePoolId, 
    LONGLONG *pFreeBytes, 
    LONGLONG *pCapacity, 
    HRESULT *pLastError, 
    SHORT *pNextRemoteDataSet, 
    OLECHAR **pDescription,
    ULONG descriptionBufferSize,
    HSM_JOB_MEDIA_TYPE *pType,
    OLECHAR **pName,
    ULONG nameBufferSize,
    BOOL *pRecallOnly,
    FILETIME *pUpdate,
    LONGLONG *pLogicalValidBytes,
    BOOL *pRecreate
    )
/*++

Implements:

  IMediaInfo::GetMediaInfo

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::GetMediaInfo"),OLESTR(""));
    try {
        //Make sure we can provide data memebers
        if (0 != pMediaId)  {
            *pMediaId = m_Master.id;
        }
        
        if (0 != pMediaSubsystemId)  {
            *pMediaSubsystemId = m_Master.ntmsId;
        }
        if (0 != pStoragePoolId)  {
            *pStoragePoolId = m_Master.storagePoolId;
        }
        if (0 != pDescription)  {
            CWsbStringPtr tmpString;
            tmpString = m_Master.description;
            WsbAffirmHr(tmpString.CopyTo(pDescription, descriptionBufferSize));
        }
        if (0 != pName)  {
            CWsbStringPtr tmpString;
            tmpString = m_Master.name;
            tmpString.CopyTo(pName, nameBufferSize);
        }
        if (0 != pType)  {
            *pType = m_Master.type;
        }
        if (0 != pUpdate)  {
            *pUpdate = m_Master.lastUpdate;
        }
        if (0 != pLastError)  {
            *pLastError = m_Master.lastError;
        }
        if (0 != pRecallOnly)  {
            *pRecallOnly = m_Master.recallOnly;
        }
        if (0 != pFreeBytes)  {
            *pFreeBytes = m_Master.freeBytes;
        }
        if (0 != pCapacity)  {
            *pCapacity = m_Master.capacity;
        }
        if (0 != pNextRemoteDataSet)  {
            *pNextRemoteDataSet = m_Master.nextRemoteDataSet;
        }
        if (0 != pLogicalValidBytes)  {
            *pLogicalValidBytes = m_LogicalValidBytes;
        }
        if (0 != pRecreate)  {
            *pRecreate = m_Recreate;
        }


    } WsbCatch(hr);

    WsbTrace(OLESTR("CMediaInfo::GetMediaInfo id = <%ls>, ntmsId = <%ls>, StgPoolId = <%ls>\n"),
        WsbPtrToGuidAsString(pMediaId), WsbQuickString(WsbPtrToGuidAsString(pMediaSubsystemId)),
        WsbQuickString(WsbPtrToGuidAsString(pStoragePoolId)));
    WsbTrace(OLESTR("CMediaInfo::GetMediaInfo Free = <%ls>, Cap = <%ls>, Last Error = <%ls>\n"), 
        WsbPtrToLonglongAsString(pFreeBytes),WsbQuickString(WsbPtrToLonglongAsString(pCapacity)),
        WsbPtrToHrAsString(pLastError));
    WsbTrace(OLESTR("CMediaInfo::GetMediaInfo NextRemoteDataSet = <%ls>, Description = <%ls>, Type = <%ls>\n"), 
        WsbPtrToShortAsString(pNextRemoteDataSet),
        WsbPtrToStringAsString(pDescription),
        WsbQuickString(WsbPtrToShortAsString((SHORT *)pType)));
    WsbTrace(OLESTR("CMediaInfo::GetMediaInfo Name = <%ls>, RecallOnly = <%ls>, Update = <%ls>\n"),
        WsbQuickString(WsbPtrToStringAsString(pName)),
        WsbQuickString(WsbPtrToBoolAsString(pRecallOnly)),
        WsbPtrToFiletimeAsString(FALSE, pUpdate));
    WsbTrace(OLESTR("CMediaInfo::GetMediaInfo LogicalValid = <%ls>, Recreate = <%ls>\n"),
        WsbQuickString(WsbPtrToLonglongAsString(pLogicalValidBytes)),
        WsbQuickString(WsbPtrToBoolAsString(pRecreate)));
        
    WsbTraceOut(OLESTR("CMediaInfo::GetMediaInfo"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT
CMediaInfo::GetMediaSubsystemId( 
    GUID *pMediaSubsystemId 
    )
/*++

Implements:

  IMediaInfo::GetMediaSubsystemId

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::GetMediaSubsystemId"),OLESTR(""));
    try {
        WsbAssertPointer(pMediaSubsystemId);
        *pMediaSubsystemId = m_Master.ntmsId;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::GetMediaSubsystemId"), OLESTR("hr = <%ls>, SubsystemID = <%ls>"), WsbHrAsString(hr), WsbPtrToGuidAsString(pMediaSubsystemId));
    return(hr);
}

HRESULT
CMediaInfo::GetNextRemoteDataSet( 
    short *pNextRemoteDataSet 
    )
/*++

Implements:

  IMediaInfo::GetNextRemoteDataSet

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::GetNextRemoteDataSet"),OLESTR(""));
    try {                              
        WsbAssertPointer(pNextRemoteDataSet);
        *pNextRemoteDataSet = m_Master.nextRemoteDataSet;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::GetNextRemoteDataSet"), OLESTR("hr = <%ls>, Next Remote Data Set = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pNextRemoteDataSet));
    return(hr);
}

HRESULT
CMediaInfo::GetRecallOnlyStatus( 
    BOOL *pRecallOnlyStatus 
    )
/*++

Implements:

  IMediaInfo::GetRecallOnlyStatus

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::GetRecallOnlyStatus"),OLESTR(""));
    try {
        WsbAssertPointer(pRecallOnlyStatus);
        *pRecallOnlyStatus = m_Master.recallOnly;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::GetRecallOnlyStatus"), OLESTR("hr = <%ls>, Read only Status = <%ls>"), WsbHrAsString(hr), WsbPtrToBoolAsString(pRecallOnlyStatus));
    return(hr);
}

HRESULT CMediaInfo::GetSizeMax
(
    OUT ULARGE_INTEGER* pcbSize
    ) 
/*++

Implements:

  IPersistStream::GetSizeMax().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CMediaInfo::GetSizeMax"), OLESTR(""));
    try {
        hr = E_NOTIMPL;
        pcbSize = 0;        
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::GetSizeMax"), 
        OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), 
        WsbPtrToUliAsString(pcbSize));
    return(hr);
}

HRESULT
CMediaInfo::GetStoragePoolId( 
    GUID *pStoragePoolId 
    )
/*++

Implements:

  IMediaInfo::GetStoragePoolId

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::GetStoragePoolId"),OLESTR(""));
    try {
        WsbAssertPointer(pStoragePoolId);
        *pStoragePoolId = m_Master.storagePoolId;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::GetStoragePoolId"), OLESTR("hr = <%ls>, Storage Pool Id = <%ls>"), WsbHrAsString(hr), WsbPtrToGuidAsString(pStoragePoolId));
    return(hr);
}

HRESULT
CMediaInfo::GetType( 
    HSM_JOB_MEDIA_TYPE *pType 
    )
/*++

Implements:

  IMediaInfo::GetType

--*/

{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::GetType"),OLESTR(""));
    try {
        WsbAssertPointer(pType);
        *pType = m_Master.type;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::GetType"), OLESTR("hr = <%ls>, type = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString((SHORT *)pType));
    return(hr);
}

HRESULT
CMediaInfo::GetUpdate( 
    FILETIME *pUpdate 
    )
/*++

Implements:

  IMediaInfo::GetUpdate

--*/

{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::GetUpdate"),OLESTR(""));
    try {
        WsbAssertPointer(pUpdate);
        *pUpdate = m_Master.lastUpdate;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::GetUpdate"), OLESTR("hr = <%ls>, Update = <%ls>"), WsbHrAsString(hr), WsbPtrToFiletimeAsString(FALSE, pUpdate));
    return(hr);
}

HRESULT CMediaInfo::Load
(
    IN IStream* pStream
    ) 
/*++

Implements:

  IPersistStream::Load().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CMediaInfo::Load"), OLESTR(""));

    try {
        WsbAssert(0 != pStream, E_POINTER);
        ULONG descriptionLen = (ULONG)SEG_DB_MAX_MEDIA_NAME_LEN;
        ULONG nameLen = (ULONG)SEG_DB_MAX_MEDIA_BAR_CODE_LEN;

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_Master.id));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_Master.ntmsId));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_Master.storagePoolId));
        
        m_Master.description.Realloc(SEG_DB_MAX_MEDIA_NAME_LEN);
        WsbAffirmHr(WsbLoadFromStream(pStream, (OLECHAR **)&m_Master.description, descriptionLen));
        m_Master.name.Realloc(SEG_DB_MAX_MEDIA_BAR_CODE_LEN);
        WsbAffirmHr(WsbLoadFromStream(pStream, (OLECHAR **)&m_Master.name, nameLen));
        LONG tmpLong;
        WsbAffirmHr(WsbLoadFromStream(pStream, &tmpLong));
        m_Master.type = (HSM_JOB_MEDIA_TYPE)tmpLong;
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_Master.freeBytes));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_Master.capacity));
        WsbAffirmHr(WsbLoadFromStream(pStream, (LONG *)&m_Master.lastError));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_Master.recallOnly));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_Master.lastUpdate));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_Master.nextRemoteDataSet));
        
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_LogicalValidBytes));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_Recreate));
        
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_LastKnownGoodMaster.id));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_LastKnownGoodMaster.ntmsId));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_LastKnownGoodMaster.storagePoolId));
        
        m_LastKnownGoodMaster.description.Realloc(SEG_DB_MAX_MEDIA_NAME_LEN);
        WsbAffirmHr(WsbLoadFromStream(pStream, (OLECHAR **)&m_LastKnownGoodMaster.description, descriptionLen));
        m_LastKnownGoodMaster.name.Realloc(SEG_DB_MAX_MEDIA_BAR_CODE_LEN);
        WsbAffirmHr(WsbLoadFromStream(pStream, (OLECHAR **)&m_LastKnownGoodMaster.name, nameLen));
        WsbAffirmHr(WsbLoadFromStream(pStream, &tmpLong));
        m_LastKnownGoodMaster.type = (HSM_JOB_MEDIA_TYPE)tmpLong;
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_LastKnownGoodMaster.freeBytes));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_LastKnownGoodMaster.capacity));
        WsbAffirmHr(WsbLoadFromStream(pStream, (LONG *)&m_LastKnownGoodMaster.lastError));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_LastKnownGoodMaster.recallOnly));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_LastKnownGoodMaster.lastUpdate));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_LastKnownGoodMaster.nextRemoteDataSet));
        
        for (int i = 0; i < HSM_MAX_NUMBER_MEDIA_COPIES; i++ )  {
            WsbAffirmHr(WsbLoadFromStream(pStream, &(m_Copy[i].id)));
            m_Copy[i].description.Realloc(SEG_DB_MAX_MEDIA_NAME_LEN);
            WsbAffirmHr(WsbLoadFromStream(pStream, (OLECHAR **)&(m_Copy[i].description), descriptionLen));
            m_Copy[i].name.Realloc(SEG_DB_MAX_MEDIA_BAR_CODE_LEN);
            WsbAffirmHr(WsbLoadFromStream(pStream, (OLECHAR **)&(m_Copy[i].name), nameLen));
            WsbAffirmHr(WsbLoadFromStream(pStream, &(m_Copy[i].lastUpdate)));
            WsbAffirmHr(WsbLoadFromStream(pStream, (LONG *)&(m_Copy[i].lastError)));
            WsbAffirmHr(WsbLoadFromStream(pStream, &(m_Copy[i].nextRemoteDataSet)));
        }

    } WsbCatch(hr);
    
    WsbTrace(OLESTR("ID = <%ls>, rmsId = <%ls>, stgPoolId = <%ls>\n"),  
        WsbQuickString(WsbGuidAsString(m_Master.id)), 
        WsbQuickString(WsbGuidAsString(m_Master.ntmsId)),
        WsbQuickString(WsbGuidAsString(m_Master.storagePoolId)));
    WsbTrace(OLESTR("Description = <%ls>, name = <%ls>, type = <%u>\n"), 
        (OLECHAR *)m_Master.description,
        (OLECHAR *)m_Master.name,
        m_Master.type);
    WsbTrace(OLESTR("FreeBytes = <%ls>, capacity = <%ls>, lastError = <%ls>\n"),
        WsbQuickString(WsbLonglongAsString(m_Master.freeBytes)),
        WsbQuickString(WsbLonglongAsString(m_Master.capacity)),
        WsbQuickString(WsbHrAsString(m_Master.lastError)));
    WsbTrace(OLESTR("RecallOnly = <%ls>, NextRemotDataSet = <%u>\n"),   
        WsbBoolAsString(m_Master.recallOnly),
        m_Master.nextRemoteDataSet);
    WsbTrace(OLESTR("LastUpdate = <%ls>, logicalValidBytes = <%ls>, Recreate = <%ls>\n"),    
        WsbFiletimeAsString(FALSE, m_Master.lastUpdate),
        WsbLonglongAsString(m_LogicalValidBytes),
        WsbBoolAsString(m_Recreate));
    
    
    WsbTraceOut(OLESTR("CMediaInfo::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT CMediaInfo::Print
(
    IN IStream* pStream
    ) 
/*++

Implements:

  IWsbDbEntity::Print

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CMediaInfo::Print"), OLESTR(""));

    try {
        WsbAssert(0 != pStream, E_POINTER);
        CWsbStringPtr strGuid;
        WsbAffirmHr(WsbSafeGuidAsString(m_Master.id, strGuid));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" id = %ls,"), 
                (WCHAR *)strGuid));
        WsbAffirmHr(WsbSafeGuidAsString(m_Master.ntmsId, strGuid));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" ntmsId = %ls,"), 
                (WCHAR *)strGuid));
        WsbAffirmHr(WsbSafeGuidAsString(m_Master.storagePoolId, strGuid));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" StoragePoolId = %ls,"), 
                (WCHAR *)strGuid));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" RS Media Name = %ls,"), (OLECHAR *)m_Master.description));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" RMS Media Name = %ls,"), (OLECHAR *)m_Master.name));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" Media Type = %u,"), m_Master.type));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" Last Update = %ls,"), 
                WsbFiletimeAsString(FALSE, m_Master.lastUpdate)));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" Last Error = %ls,"), WsbHrAsString(m_Master.lastError)));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" Is Recall Only = %ls,"), WsbBoolAsString(m_Master.recallOnly)));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" Free Bytes = %ls,"), 
                WsbQuickString(WsbLonglongAsString(m_Master.freeBytes))));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" Capacity = %ls,"),
                WsbQuickString(WsbLonglongAsString(m_Master.capacity))));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" Logical Valid Bytes = %ls,"),
                WsbQuickString(WsbLonglongAsString(m_LogicalValidBytes))));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" NextRemoteDataSet = %u,"), m_Master.nextRemoteDataSet));
        
        WsbAffirmHr(CWsbDbEntity::Print(pStream));
        //
        // Last Known Good Master
        //
        WsbAffirmHr(WsbSafeGuidAsString(m_LastKnownGoodMaster.id, strGuid));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR("\n   Last Known Good id = %ls,"), 
            (WCHAR *)strGuid));
        WsbAffirmHr(WsbSafeGuidAsString(m_LastKnownGoodMaster.ntmsId, strGuid));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" ntmsId = %ls,"), 
                (WCHAR *)strGuid));
        WsbAffirmHr(WsbSafeGuidAsString(m_LastKnownGoodMaster.storagePoolId, strGuid));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" StoragePoolId = %ls,"), 
                (WCHAR *)strGuid));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" RS Media Name = %ls,"), (OLECHAR *)m_LastKnownGoodMaster.description));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" RMS Media Name = %ls,"), (OLECHAR *)m_LastKnownGoodMaster.name));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" Media Type = %u,"), m_LastKnownGoodMaster.type));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" Last Update = %ls,"), 
                WsbFiletimeAsString(FALSE, m_LastKnownGoodMaster.lastUpdate)));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" Last Error = %ls,"), WsbHrAsString(m_LastKnownGoodMaster.lastError)));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" Is Recall Only = %ls,"), WsbBoolAsString(m_LastKnownGoodMaster.recallOnly)));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" Free Bytes = %ls,"), 
                WsbQuickString(WsbLonglongAsString(m_LastKnownGoodMaster.freeBytes))));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" Capacity = %ls,"),
                WsbQuickString(WsbLonglongAsString(m_LastKnownGoodMaster.capacity))));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" NextRemoteDataSet = %u,"), m_LastKnownGoodMaster.nextRemoteDataSet));
        //
        // Media Copies
        //
        for (int i = 0; i < HSM_MAX_NUMBER_MEDIA_COPIES; i++ )  {
            WsbAffirmHr(WsbSafeGuidAsString(m_Copy[i].id, strGuid));
            WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR("\n   RS Media Copy %d RMS ID = %ls,") ,(i+1), (WCHAR *)strGuid));
            WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" RS Media Name = %ls,") , (OLECHAR *)m_Copy[i].description));
            WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" RMS Media Name = %ls,") , (OLECHAR *)m_Copy[i].name));
            WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" Last Update = %ls,") , WsbFiletimeAsString(FALSE,m_Copy[i].lastUpdate)));
            WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" Last Error = %ls,") , WsbHrAsString(m_Copy[i].lastError)));
            WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" NextRemoteDataSet = %u,") , m_Copy[i].nextRemoteDataSet));
        }

        

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::Print"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT CMediaInfo::Save
(
    IN IStream* pStream, 
    IN BOOL clearDirty
    ) 
/*++

Implements:

  IPersistStream::Save().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CMediaInfo::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));
    
    WsbTrace(OLESTR("ID = <%ls>, rmsId = <%ls>, stgPoolId = <%ls>\n"),
        WsbQuickString(WsbGuidAsString(m_Master.id)), 
        WsbQuickString(WsbGuidAsString(m_Master.ntmsId)),
        WsbQuickString(WsbGuidAsString(m_Master.storagePoolId)));
    WsbTrace(OLESTR("Description = <%ls>, name = <%ls>, type = <%u>\n"),
        (OLECHAR *)m_Master.description,
        (OLECHAR *)m_Master.name,
        m_Master.type);
    WsbTrace(OLESTR("FreeBytes = <%ls>, capacity = <%ls>, lastError = <%ls>\n"), 
        WsbQuickString(WsbLonglongAsString(m_Master.freeBytes)),
        WsbQuickString(WsbLonglongAsString(m_Master.capacity)),
        WsbHrAsString(m_Master.lastError));
    WsbTrace(OLESTR("RecallOnly = <%ls>, NextRemotDataSet = <%u>\n"),
        WsbBoolAsString(m_Master.recallOnly),
        m_Master.nextRemoteDataSet);
    WsbTrace(OLESTR("LastUpdate = <%ls>, logicalValidBytes = <%ls>, Recreate = <%ls>\n"),    
        WsbFiletimeAsString(FALSE, m_Master.lastUpdate),
        WsbLonglongAsString(m_LogicalValidBytes),
        WsbBoolAsString(m_Recreate));

    try {
        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(WsbSaveToStream(pStream, m_Master.id));
        WsbAffirmHr(WsbSaveToStream(pStream, m_Master.ntmsId));
        WsbAffirmHr(WsbSaveToStream(pStream, m_Master.storagePoolId));
        
        WsbAffirmHr(WsbSaveToStream(pStream, (OLECHAR *)m_Master.description));
        WsbAffirmHr(WsbSaveToStream(pStream, (OLECHAR *)m_Master.name));
        WsbAffirmHr(WsbSaveToStream(pStream, (LONG)m_Master.type));
        WsbAffirmHr(WsbSaveToStream(pStream, m_Master.freeBytes));
        WsbAffirmHr(WsbSaveToStream(pStream, m_Master.capacity));
        WsbAffirmHr(WsbSaveToStream(pStream, (LONG)m_Master.lastError));
        WsbAffirmHr(WsbSaveToStream(pStream, m_Master.recallOnly));
        WsbAffirmHr(WsbSaveToStream(pStream, m_Master.lastUpdate));
        WsbAffirmHr(WsbSaveToStream(pStream, m_Master.nextRemoteDataSet));
        
        WsbAffirmHr(WsbSaveToStream(pStream, m_LogicalValidBytes));
        WsbAffirmHr(WsbSaveToStream(pStream, m_Recreate));
        
        WsbAffirmHr(WsbSaveToStream(pStream, m_LastKnownGoodMaster.id));
        WsbAffirmHr(WsbSaveToStream(pStream, m_LastKnownGoodMaster.ntmsId));
        WsbAffirmHr(WsbSaveToStream(pStream, m_LastKnownGoodMaster.storagePoolId));
        
        WsbAffirmHr(WsbSaveToStream(pStream, (OLECHAR *)m_LastKnownGoodMaster.description));
        WsbAffirmHr(WsbSaveToStream(pStream, (OLECHAR *)m_LastKnownGoodMaster.name));
        WsbAffirmHr(WsbSaveToStream(pStream, (LONG)m_LastKnownGoodMaster.type));
        WsbAffirmHr(WsbSaveToStream(pStream, m_LastKnownGoodMaster.freeBytes));
        WsbAffirmHr(WsbSaveToStream(pStream, m_LastKnownGoodMaster.capacity));
        WsbAffirmHr(WsbSaveToStream(pStream, (LONG)m_LastKnownGoodMaster.lastError));
        WsbAffirmHr(WsbSaveToStream(pStream, m_LastKnownGoodMaster.recallOnly));
        WsbAffirmHr(WsbSaveToStream(pStream, m_LastKnownGoodMaster.lastUpdate));
        WsbAffirmHr(WsbSaveToStream(pStream, m_LastKnownGoodMaster.nextRemoteDataSet));
        
        for (int i = 0; i < HSM_MAX_NUMBER_MEDIA_COPIES; i++ )  {
            WsbAffirmHr(WsbSaveToStream(pStream, m_Copy[i].id));
            WsbAffirmHr(WsbSaveToStream(pStream, m_Copy[i].description));
            WsbAffirmHr(WsbSaveToStream(pStream, m_Copy[i].name));
            WsbAffirmHr(WsbSaveToStream(pStream, m_Copy[i].lastUpdate));
            WsbAffirmHr(WsbSaveToStream(pStream, (LONG)(m_Copy[i].lastError)));
            WsbAffirmHr(WsbSaveToStream(pStream, m_Copy[i].nextRemoteDataSet));
        }

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CMediaInfo::SetName(
    OLECHAR *name
    )
/*++

Implements:

  IMediaInfo::SetName

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::SetName"),OLESTR("Name = <%ls>"), name);
    try {
        WsbAssertPointer(name);
        m_Master.name = name;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::SetName"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT
CMediaInfo::SetCapacity( 
    LONGLONG capacity
    )
/*++

Implements:

  IMediaInfo::SetCapacity

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::SetCapacity"),OLESTR("Capacity = <%ls>"), WsbLonglongAsString(capacity));
    try {
        m_Master.capacity = capacity;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::SetCapacity"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT
CMediaInfo::SetCopyName( 
    USHORT copyNumber, 
    OLECHAR *name
    ) 
/*++

Implements:

  IMediaInfo::SetCopyName

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::SetCopyName"),OLESTR("copy = <%u>, Name = <%ls>"), copyNumber, name);
    try {

        // This method is not being used and currently we don't save the copy name in RSS database
        //  due to Windows Bugs 407340

        WsbThrow(E_NOTIMPL);

/***        WsbAffirm(((0 < copyNumber) && (copyNumber <= HSM_MAX_NUMBER_MEDIA_COPIES)),
                E_INVALIDARG);
        m_Copy[copyNumber - 1].name = name;         ***/
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::SetCopyName"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT
CMediaInfo::SetCopyNextRemoteDataSet( 
    USHORT copyNumber, 
    SHORT nextRemoteDataSet
    ) 
/*++

Implements:

  IMediaInfo::SetCopyNextRemoteDataSet

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::SetCopyNextRemoteDataSet"),OLESTR("copy = <%u>, NextRemoteDataSet = <%d>"), copyNumber, nextRemoteDataSet);
    try {
        WsbAffirm(((0 < copyNumber) && (copyNumber <= HSM_MAX_NUMBER_MEDIA_COPIES)),
                E_INVALIDARG);
        m_Copy[copyNumber - 1].nextRemoteDataSet = nextRemoteDataSet;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::SetCopyNextRemoteDataSet"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT
CMediaInfo::SetCopyDescription( 
    USHORT copyNumber, 
    OLECHAR *description
    ) 
/*++

Implements:

  IMediaInfo::SetCopyDescription

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::SetCopyDescription"),OLESTR("copy = <%u>, description = <%ls>"), copyNumber, description);
    try {

        // This method is not being used and currently we don't save the copy description in RSS database
        //  due to Windows Bugs 407340

        WsbThrow(E_NOTIMPL);

/***        WsbAffirm(((0 < copyNumber) && (copyNumber <= HSM_MAX_NUMBER_MEDIA_COPIES)),
                E_INVALIDARG);
        m_Copy[copyNumber - 1].description = description;           ***/
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::SetCopyDescription"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT
CMediaInfo::SetCopyInfo( 
    USHORT copyNumber, 
    GUID mediaSubsystemId, 
    OLECHAR *description, 
    OLECHAR *name, 
    FILETIME update, 
    HRESULT lastError,
    SHORT  nextRemoteDataSet
    )
/*++

Implements:

  IMediaInfo::SetCopyInfo

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::SetCopyInfo"),OLESTR("copy = <%u>, SubsystemId = <%ls>, Description = <%ls>, Name = <%ls>, update = <%ls>, lastError = <%ls>, NextRemoteDataSet = <%d> "),
    copyNumber, WsbGuidAsString(mediaSubsystemId), description, name, WsbFiletimeAsString(FALSE, update),WsbHrAsString(lastError));
    try {
        WsbAffirm(((0 < copyNumber) && (copyNumber <= HSM_MAX_NUMBER_MEDIA_COPIES)),
                E_INVALIDARG);
        m_Copy[copyNumber - 1].id = mediaSubsystemId;

        // We don't save the copy name & description in RSS database anymore due to Windows Bugs 407340
        //  The strings in the structure are already initialize to a null string so there's no need to set them again

/***        m_Copy[copyNumber - 1].description = description;
        m_Copy[copyNumber - 1].name = name;                     ***/

        m_Copy[copyNumber - 1].lastUpdate = update;
        m_Copy[copyNumber - 1].lastError = lastError;
        m_Copy[copyNumber - 1].nextRemoteDataSet = nextRemoteDataSet;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::SetCopyInfo"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT
CMediaInfo::SetCopyLastError( 
    USHORT copyNumber, 
    HRESULT lastError 
    )
/*++

Implements:

  IMediaInfo::SetCopyLastError

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::SetCopyLastError"),OLESTR("Last Error = <%ls>"), WsbHrAsString(lastError));
    try {
        WsbAffirm(((0 < copyNumber) && (copyNumber <= HSM_MAX_NUMBER_MEDIA_COPIES)),
                E_INVALIDARG);
        m_Copy[copyNumber - 1].lastError = lastError;        
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::SetCopyLastError"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT
CMediaInfo::SetCopyMediaSubsystemId( 
    USHORT copyNumber, 
    GUID mediaSubsystemId 
    ) 
/*++

Implements:

  IMediaInfo::SetCopyMediaSubsystemId

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::SetCopyMediaSubsystemId"),OLESTR("SubsystemId = <%ls>"), WsbGuidAsString(mediaSubsystemId));
    try {
        WsbAffirm(((0 < copyNumber) && (copyNumber <= HSM_MAX_NUMBER_MEDIA_COPIES)),
                E_INVALIDARG);
        m_Copy[copyNumber - 1].id = mediaSubsystemId;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::SetCopyMediaSubsystemId"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT
CMediaInfo::SetCopyUpdate( 
    USHORT copyNumber, 
    FILETIME update 
    ) 
/*++

Implements:

  IMediaInfo::SetCopyUpdate

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::SetCopyUpdate"),OLESTR("update = <%ls>"), WsbFiletimeAsString(FALSE, update));
    try {
        WsbAffirm(((0 < copyNumber) && (copyNumber <= HSM_MAX_NUMBER_MEDIA_COPIES)),
                E_INVALIDARG);
        m_Copy[copyNumber - 1].lastUpdate = update;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::SetCopyUpdate"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT
CMediaInfo::SetDescription(
    OLECHAR *description 
    )
/*++

Implements:

  IMediaInfo::SetDescription

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::SetDescription"),OLESTR("description = <%ls>"), description);
    try {
        WsbAssertPointer(description);
        m_Master.description = description;    
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::SetDescription"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT
CMediaInfo::SetFreeBytes( 
    LONGLONG FreeBytes 
    )
/*++

Implements:

  IMediaInfo::SetFreeBytes

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::SetFreeBytes"),OLESTR("Free Space = <%ls>"), WsbLonglongAsString(FreeBytes));
    try {
        m_Master.freeBytes = FreeBytes;    
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::SetFreeBytes"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT
CMediaInfo::SetId( 
    GUID id
    )
/*++

Implements:

  IMediaInfo::SetId

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::SetId"),OLESTR("ID = <%ls>"), WsbGuidAsString(id));
    try {
        m_Master.id = id;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::SetId"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT
CMediaInfo::SetLastError( 
    HRESULT lastError
    )
/*++

Implements:

  IMediaInfo::SetLastError

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::SetLastError"),OLESTR("last error = <%ls>"), WsbHrAsString(lastError));
    try {
        m_Master.lastError = lastError;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::SetLastError"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT
CMediaInfo::SetLogicalValidBytes(
    LONGLONG logicalValidBytes
    )
/*++

Implements:

  IMediaInfo::SetLogicalValidBytes

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::SetLogicalValidBytes"),OLESTR("LogicalValidBytes = <%ls>"), WsbLonglongAsString(logicalValidBytes));
    try {
        m_LogicalValidBytes = logicalValidBytes;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::SetLogicalValidBytes"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT 
CMediaInfo::SetMediaInfo
(
    GUID mediaId, 
    GUID mediaSubsystemId,
    GUID storagePoolId,
    LONGLONG FreeBytes,
    LONGLONG Capacity,
    HRESULT lastError,
    short nextRemoteDataSet,
    OLECHAR *description,
    HSM_JOB_MEDIA_TYPE type,
    OLECHAR *name,
    BOOL RecallOnly,
    FILETIME update,
    LONGLONG logicalValidBytes,
    BOOL recreate
    )
 /*++

Implements:

  IMediaInfo::SetMediaInfo().

--*/
{
    WsbTraceIn(OLESTR("CMediaInfo::SetMediaInfo"), OLESTR(""));
    
    WsbTrace(OLESTR("CMediaInfo::SetMediaInfo id = <%ls>, SubsystemId = <%ls>, StoragePoolId = <%ls>\n"), 
        WsbGuidAsString(mediaId), 
        WsbQuickString(WsbGuidAsString(mediaSubsystemId)), 
        WsbQuickString(WsbGuidAsString(storagePoolId)));
    WsbTrace(OLESTR("CMediaInfo::SetMediaInfo FreeBytes = <%ls>, Capacity = <%ls>, lastError = <%ls>\n"),
        WsbLonglongAsString(FreeBytes), 
        WsbQuickString(WsbLonglongAsString(Capacity)), 
        WsbHrAsString(lastError));
    WsbTrace(OLESTR("CMediaInfo::SetMediaInfo NextRemoteDataSet = <%d>, Description = <%ls>, Type = <%d>\n"), 
        nextRemoteDataSet, 
        (OLECHAR *)description, 
        type);
    WsbTrace(OLESTR("CMediaInfo::SetMediaInfo Name = <%ls>, RecallOnly = <%ls>, update = <%ls>\n"), 
        (OLECHAR *)name,
        WsbBoolAsString(RecallOnly),
        WsbFiletimeAsString(FALSE, update));
    WsbTrace(OLESTR("CMediaInfo::SetMediaInfo logicalValidBytes = <%ls>, recreate = <%ls>\n)"), 
        WsbLonglongAsString(logicalValidBytes), WsbBoolAsString(m_Recreate));

    m_isDirty = TRUE;
    
    m_Master.id = mediaId;
    m_Master.ntmsId = mediaSubsystemId;
    m_Master.storagePoolId = storagePoolId;
    m_Master.freeBytes = FreeBytes;
    m_Master.capacity = Capacity;
    m_Master.lastError = lastError;
    m_Master.description = description;
    m_Master.type = type;
    m_Master.name = name;
    m_Master.recallOnly = RecallOnly;
    m_Master.lastUpdate = update;
    m_Master.nextRemoteDataSet = nextRemoteDataSet;
    
    m_LogicalValidBytes = logicalValidBytes;
    m_Recreate = recreate;
    
    WsbTraceOut(OLESTR("CMediaInfo::SetMediaInfo"), OLESTR("hr = <%ls>"),WsbHrAsString(S_OK));
    return(S_OK);
}

HRESULT
CMediaInfo::SetMediaSubsystemId( 
    GUID mediaSubsystemId 
    )
/*++

Implements:

  IMediaInfo::SetMediaSubsystemId 

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::SetMediaSubsystemId "),OLESTR("Subsystem Id = <%ls>"),
            WsbGuidAsString(mediaSubsystemId));
    try {
        m_Master.ntmsId = mediaSubsystemId;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::SetMediaSubsystemId "), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT
CMediaInfo::SetNextRemoteDataSet( 
    short nextRemoteDataSet 
    )
/*++

Implements:

  IMediaInfo::SetNextRemoteDataSet 

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::SetNextRemoteDataSet"),OLESTR("Data Set = <%u>"), nextRemoteDataSet);
    try {
        m_Master.nextRemoteDataSet = nextRemoteDataSet;
        m_LastKnownGoodMaster.nextRemoteDataSet = nextRemoteDataSet;

        //
        // Handle exception case where a copy reports more data sets than the
        // master.  This occurs when we increment the data set count, but
        // never write to the media, then create a media copy, then write
        // to the master which decrements the data set count to handle the
        // missing data set, then finally increment the data set count.
        for (int i=0; i< HSM_MAX_NUMBER_MEDIA_COPIES; i++) {
            if (m_Copy[i].nextRemoteDataSet > 0) {
                if (nextRemoteDataSet < m_Copy[i].nextRemoteDataSet) {
                    WsbAssert(nextRemoteDataSet+1 == m_Copy[i].nextRemoteDataSet, E_UNEXPECTED);
                    m_Copy[i].nextRemoteDataSet--;
                }
            }
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::SetNextRemoteDataSet"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT
CMediaInfo::SetRecallOnlyStatus( 
    BOOL RecallOnlyStatus 
    )
/*++

Implements:

  IMediaInfo::SetRecallOnlyStatus

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::SetRecallOnlyStatus"),OLESTR("Read Only Status = <%ls>"), 
        WsbBoolAsString(RecallOnlyStatus));
    try {
        m_Master.recallOnly = RecallOnlyStatus;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::SetRecallOnlyStatus"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT
CMediaInfo::SetStoragePoolId( 
    GUID storagePoolId 
    )
/*++

Implements:

  IMediaInfo::SetStoragePoolId

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::SetStoragePoolId"),OLESTR("Storage Pool Id = <%ls>"),
        WsbGuidAsString(storagePoolId));
    try {
        m_Master.storagePoolId = storagePoolId;    
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::SetStoragePoolId"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT
CMediaInfo::SetType( 
    HSM_JOB_MEDIA_TYPE type 
    )
/*++

Implements:

  IMediaInfo::SetType

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::SetType"),OLESTR("type = <%u>"), (USHORT)type);
    try {
        m_Master.type = type;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::SetType"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT
CMediaInfo::SetUpdate( 
    FILETIME update 
    )
/*++

Implements:

  IMediaInfo::SetUpdate

--*/

{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::SetUpdate"),OLESTR("Update = <%ls>"),
        WsbFiletimeAsString(FALSE, update));
    try {
        m_Master.lastUpdate = update;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::SetUpdate"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT 
CMediaInfo::Test
(
    OUT USHORT *pTestsPassed, 
    OUT USHORT *pTestsFailed 
    ) 
/*++

Implements:

  IWsbTestable::Test().

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IMediaInfo>     pMediaInfo1;
    CComPtr<IMediaInfo>     pMediaInfo2;

    WsbTraceIn(OLESTR("CMediaInfo::Test"), OLESTR(""));

    *pTestsPassed = *pTestsFailed = 0;
    try {
    
        hr = E_NOTIMPL;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::Test"), OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return( hr );
}



HRESULT 
CMediaInfo::UpdateKey(
    IWsbDbKey *pKey
    ) 
/*++

Implements:

  IWsbDbEntity::UpdateKey

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::UpdateKey"),OLESTR(""));
    try {
        WsbAffirmHr(pKey->SetToGuid(m_Master.id));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::UpdateKey"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
    return(hr);
}

HRESULT
CMediaInfo::SetRecreate( 
    BOOL recreate
    )
/*++

Implements:

  IMediaInfo::SetRecreate

--*/

{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::SetRecreate"),OLESTR("Recreate = <%ls>"), WsbBoolAsString(recreate));
    try {
        m_Recreate = recreate;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::SetRecreate"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT
CMediaInfo::GetRecreate( 
    BOOL *pRecreate
    )
/*++

Implements:

  IMediaInfo::GetRecreate

--*/

{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::GetRecreate"),OLESTR(""));
    try {
    
        WsbAssertPointer(pRecreate);
        *pRecreate = m_Recreate;
        
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::GetRecreate"), OLESTR("hr = <%ls>, recreate = <%ls>"), 
        WsbHrAsString(hr), WsbPtrToBoolAsString(pRecreate));
    return(hr);
}


HRESULT
CMediaInfo::GetLastKnownGoodMasterInfo( 
    GUID* pId, 
    GUID *pNtmsId, 
    GUID *pStoragePoolId, 
    LONGLONG *pFreeBytes, 
    LONGLONG *pCapacity, 
    HRESULT *pLastError, 
    OLECHAR **pDescription, 
    ULONG descriptionBufferSize,
    HSM_JOB_MEDIA_TYPE *pType,
    OLECHAR **pName,
    ULONG nameBufferSize,
    BOOL *pRecallOnly,
    FILETIME *pUpdate,
    SHORT *pNextRemoteDataSet
    )
/*++

Implements:

  IMediaInfo::GetLastKnownGoodMasterInfo

--*/

{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::GetLastKnownGoodMasterInfo"),OLESTR(""));
    try {
        //Make sure we can provide data memebers
        if (0 != pId)  {
            *pId = m_LastKnownGoodMaster.id;
        }
        
        if (0 != pNtmsId)  {
            *pNtmsId = m_LastKnownGoodMaster.ntmsId;
        }
        if (0 != pStoragePoolId)  {
            *pStoragePoolId = m_LastKnownGoodMaster.storagePoolId;
        }
        if (0 != pDescription)  {
            CWsbStringPtr tmpString;
            tmpString = m_LastKnownGoodMaster.description;
            tmpString.CopyTo(pDescription, descriptionBufferSize);
        }
        if (0 != pName)  {
            CWsbStringPtr tmpString;
            tmpString = m_LastKnownGoodMaster.name;
            tmpString.CopyTo(pName, nameBufferSize);
        }
        if (0 != pType)  {
            *pType = m_LastKnownGoodMaster.type;
        }
        if (0 != pUpdate)  {
            *pUpdate = m_LastKnownGoodMaster.lastUpdate;
        }
        if (0 != pLastError)  {
            *pLastError = m_LastKnownGoodMaster.lastError;
        }
        if (0 != pRecallOnly)  {
            *pRecallOnly = m_LastKnownGoodMaster.recallOnly;
        }
        if (0 != pFreeBytes)  {
            *pFreeBytes = m_LastKnownGoodMaster.freeBytes;
        }
        if (0 != pCapacity)  {
            *pCapacity = m_LastKnownGoodMaster.capacity;
        }
        if (0 != pNextRemoteDataSet)  {
            *pNextRemoteDataSet = m_LastKnownGoodMaster.nextRemoteDataSet;
        }


    } WsbCatch(hr);

    WsbTrace(OLESTR("CMediaInfo::GetLastKnownGoodMasterInfo Id = <%ls>, ntmsId = <%ls>, StgPoolId = <%ls>\n"),
        WsbPtrToGuidAsString(pId), WsbQuickString(WsbPtrToGuidAsString(pNtmsId)),
        WsbQuickString(WsbPtrToGuidAsString(pStoragePoolId)));
    WsbTrace(OLESTR("CMediaInfo::GetLastKnownGoodMasterInfo Free = <%ls>, Cap = <%ls>, Last Error = <%ls>\n"), 
        WsbPtrToLonglongAsString(pFreeBytes),WsbQuickString(WsbPtrToLonglongAsString(pCapacity)),
        WsbPtrToHrAsString(pLastError));
    WsbTrace(OLESTR("CMediaInfo::GetLastKnownGoodMasterInfo Description = <%ls>, Type = <%d)\n"), 
        WsbPtrToStringAsString(pDescription),
        WsbQuickString(WsbPtrToShortAsString((SHORT *)pType)));
    WsbTrace(OLESTR("CMediaInfo::GetLastKnownGoodMasterInfo Name = <%ls>, RecallOnly = <%ls>, Update = <%ls>, NextRemoteDataSet = <%ls>\n"),
        WsbQuickString(WsbPtrToStringAsString(pName)),
        WsbQuickString(WsbPtrToBoolAsString(pRecallOnly)),
        WsbPtrToFiletimeAsString(FALSE, pUpdate),
        WsbPtrToShortAsString(pNextRemoteDataSet));
        
    WsbTraceOut(OLESTR("CMediaInfo::GetLastKnownGoodMasterInfo"),   OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT
CMediaInfo::GetLKGMasterNextRemoteDataSet( 
    short *pNextRemoteDataSet 
    )
/*++

Implements:

  IMediaInfo::GetLKGMasterNextRemoteDataSet

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::GetLKGMasterNextRemoteDataSet"),OLESTR(""));
    try {                              
        WsbAssertPointer(pNextRemoteDataSet);
        *pNextRemoteDataSet = m_LastKnownGoodMaster.nextRemoteDataSet;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::GetLKGMasterNextRemoteDataSet"), OLESTR("hr = <%ls>, Next Last-Known-Good-Master Remote-Data-Set = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pNextRemoteDataSet));
    return(hr);
}


HRESULT 
CMediaInfo::SetLastKnownGoodMasterInfo
(
    GUID mediaId, 
    GUID mediaSubsystemId,
    GUID storagePoolId,
    LONGLONG FreeBytes,
    LONGLONG Capacity,
    HRESULT lastError,
    OLECHAR *description,
    HSM_JOB_MEDIA_TYPE type,
    OLECHAR *name,
    BOOL RecallOnly,
    FILETIME update,
    SHORT nextRemoteDataSet
    )
 /*++

Implements:

  IMediaInfo::SetLastKnownGoodMasterInfo().

--*/
{
    WsbTraceIn(OLESTR("CMediaInfo::SetLastKnownGoodMasterInfo"), OLESTR(""));
    
    WsbTrace(OLESTR("CMediaInfo::SetLastKnownGoodMasterInfo"), OLESTR("id = <%ls>, SubsystemId = <%ls>, StoragePoolId = <%ls>\n"), 
        WsbGuidAsString(mediaId), 
        WsbQuickString(WsbGuidAsString(mediaSubsystemId)), 
        WsbQuickString(WsbGuidAsString(storagePoolId)));
    WsbTrace(OLESTR("CMediaInfo::SetLastKnownGoodMasterInfo"), OLESTR("FreeBytes = <%ls>, Capacity = <%ls>, lastError = <%ls>\n"),
        WsbLonglongAsString(FreeBytes), 
        WsbQuickString(WsbLonglongAsString(Capacity)), 
        WsbHrAsString(lastError));
    WsbTrace(OLESTR("CMediaInfo::SetLastKnownGoodMasterInfo"), OLESTR("Description = <%ls>, Type = <%d>\n"), 
        (OLECHAR *)description, 
        type);
    WsbTrace(OLESTR("CMediaInfo::SetLastKnownGoodMasterInfo"), OLESTR("Name = <%ls>, RecallOnly = <%ls>, update = <%ls>, nextRemoteDataSet = <%d>\n"), 
        (OLECHAR *)name,
        WsbBoolAsString(RecallOnly),
        WsbFiletimeAsString(FALSE, update),
        nextRemoteDataSet);

    m_isDirty = TRUE;
    
    m_LastKnownGoodMaster.id = mediaId;
    m_LastKnownGoodMaster.ntmsId = mediaSubsystemId;
    m_LastKnownGoodMaster.storagePoolId = storagePoolId;
    m_LastKnownGoodMaster.freeBytes = FreeBytes;
    m_LastKnownGoodMaster.capacity = Capacity;
    m_LastKnownGoodMaster.lastError = lastError;
    m_LastKnownGoodMaster.type = type;

/***  These strings are not being used for anything and we need to save space in the media record - see Windows Bugs 407340

    m_LastKnownGoodMaster.description = description;
    m_LastKnownGoodMaster.name = name;                      ***/
                                        
    m_LastKnownGoodMaster.recallOnly = RecallOnly;
    m_LastKnownGoodMaster.lastUpdate = update;
    m_LastKnownGoodMaster.nextRemoteDataSet = nextRemoteDataSet;

    WsbTraceOut(OLESTR("CMediaInfo::SetLastKnownGoodMasterInfo"), OLESTR("hr = <%ls>"),WsbHrAsString(S_OK));
    return(S_OK);
}



HRESULT
CMediaInfo::DeleteCopy( 
    USHORT copyNumber
    ) 
/*++

Implements:

  IMediaInfo::DeleteCopy

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::DeleteCopy"),OLESTR("copy = <%u>"), copyNumber);
    try {
        //
        // Make sure we have a valid copy number
        //
        WsbAffirm(((0 < copyNumber) && (copyNumber <= HSM_MAX_NUMBER_MEDIA_COPIES)),
                E_INVALIDARG);
        
        //
        // Null out the existing copy information
        //
        m_Copy[copyNumber - 1].id = GUID_NULL;
        m_Copy[copyNumber - 1].description = OLESTR("");
        m_Copy[copyNumber - 1].name = OLESTR("");
        m_Copy[copyNumber - 1].lastUpdate = WsbLLtoFT(0);
        m_Copy[copyNumber - 1].lastError = S_OK;
        m_Copy[copyNumber - 1].nextRemoteDataSet = 0;
        
        
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::DeleteCopy"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}



HRESULT
CMediaInfo::RecreateMaster( void )
/*++

Implements:

  IMediaInfo::RecreateMaster

--*/
{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::RecreateMaster"),OLESTR(""));
    try {
        //
        // Mark the master as one that needs to be recreated
        //
        m_Recreate = TRUE;
        
        //
        // Also, make sure we don't add data to this master
        //
        m_Master.recallOnly = TRUE;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMediaInfo::RecreateMaster"), OLESTR("hr = <%ls>"), 
                                                        WsbHrAsString(hr));
    return(hr);
}


//
// Internal (non COM) Helper functions
//


HRESULT
CMediaInfo::UpdateLastKnownGoodMaster( void )
/*++

Implements:

  IMediaInfo::UpdateLastKnownGoodMaster

--*/

{ 
    HRESULT  hr = S_OK; 

    WsbTraceIn(OLESTR("CMediaInfo::UpdateLastKnownGoodMaster"),OLESTR(""));

    m_LastKnownGoodMaster.id = m_Master.id;
    m_LastKnownGoodMaster.ntmsId = m_Master.ntmsId;
    m_LastKnownGoodMaster.storagePoolId = m_Master.storagePoolId;
    m_LastKnownGoodMaster.freeBytes = m_Master.freeBytes;
    m_LastKnownGoodMaster.capacity = m_Master.capacity;
    m_LastKnownGoodMaster.lastError = m_Master.lastError;
    m_LastKnownGoodMaster.type = m_Master.type;

    // These strings are not being used for anything and we need to save space in the media record - see Windows Bugs 407340
    m_LastKnownGoodMaster.description = OLESTR("");
    m_LastKnownGoodMaster.name = OLESTR("");

/***    m_LastKnownGoodMaster.description = m_Master.description;
    m_LastKnownGoodMaster.name = m_Master.name;         ***/

    m_LastKnownGoodMaster.recallOnly = m_Master.recallOnly;
    m_LastKnownGoodMaster.lastUpdate = m_Master.lastUpdate;
    m_LastKnownGoodMaster.nextRemoteDataSet = m_Master.nextRemoteDataSet;

    WsbTraceOut(OLESTR("CMediaInfo::UpdateLastKnownGoodMaster"), OLESTR("hr = <%ls>"), 
        WsbHrAsString(hr));
    return(hr);
}



HRESULT
CMediaInfo::WriteToDatabase( void )
/*++

Routine Description:

  This function writes the information to the metadata
  database.  Note all other set functions require the
  caller to call the Write() funtion for the entity.

Arguments:

  None

Return Value:
  
  S_OK: If the LastKnownGoodMaster is to be updated
  

--*/

{ 
    HRESULT                     hr = S_OK; 
    BOOLEAN                     openedDb = FALSE;
    CComPtr<IWsbDb>             pSegmentDb;
    CComPtr<IMediaInfo>         pMediaInfo;
    CComPtr<IHsmServer>         pServer;
    CComPtr<IWsbDbSession>      pDbSession;

    WsbTraceIn(OLESTR("CMediaInfo::WriteToDatabase"),OLESTR(""));
    try {
        //
        // Find the database containing the record that matches this 
        // collectable.  
        //
        WsbAffirmHr(CoCreateInstance( CLSID_HsmServer, 0, CLSCTX_SERVER, IID_IHsmServer, (void **)&pServer ));
        WsbAffirmHr(pServer->GetSegmentDb(&pSegmentDb));
        
        //
        // Find the database entity
        //
        WsbAffirmHr(pSegmentDb->Open(&pDbSession));
        openedDb = TRUE;
        WsbTrace(OLESTR("CMediaInfo::WriteToDatabase - Opened the database\n"));
        WsbAffirmHr(pSegmentDb->GetEntity(pDbSession, HSM_MEDIA_INFO_REC_TYPE, IID_IMediaInfo,
                       (void**)&pMediaInfo));
        WsbAffirmHr(pMediaInfo->SetId(m_Master.id));
        WsbAffirmHr(pMediaInfo->FindEQ());
        
        // 
        // Write the changes to the database.  To be sure that the "outside" world
        // doesn't change anything but the allowed fields, just set the fields that are
        // allowed to be changed.
        //
        WsbAffirmHr(pMediaInfo->SetRecreate(m_Recreate));
        WsbAffirmHr(SetRecallOnlyStatus(m_Master.recallOnly));
        for (int i = 1; i <= HSM_MAX_NUMBER_MEDIA_COPIES; i++)  {
            WsbAffirmHr(pMediaInfo->SetCopyInfo( (SHORT)i, 
                                                m_Copy[i-1].id,
                                                (OLECHAR *)m_Copy[i-1].description, 
                                                (OLECHAR *)m_Copy[i-1].name, 
                                                m_Copy[i-1].lastUpdate,
                                                m_Copy[i-1].lastError,
                                                m_Copy[i-1].nextRemoteDataSet));
        }            
        WsbAffirmHr(pMediaInfo->Write());
        
    } WsbCatch(hr);

    if (openedDb) {
        WsbTrace(OLESTR("CMediaInfo::WriteToDatabase - Closing the database\n"));
        pSegmentDb->Close(pDbSession);
        pDbSession = 0;
        openedDb = FALSE;
    }
    
    WsbTraceOut(OLESTR("CMediaInfo::WriteToDatabase"), OLESTR("hr = <%ls>"), 
        WsbHrAsString(hr));
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\engine\task\medinfo.h ===
/*++

Copyright (c) 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    medinfo.h

Abstract:

    Declaration of class CMedInfo

Author:


Revision History:

--*/


#include "resource.h"       // main symbols
#include "engine.h"         // main symbols
#include "Wsb.h"            // Wsb Collectable Class
#include "wsbdb.h"
#include "metalib.h"        // Meta database

typedef struct _HSM_MEDIA_MASTER {
    GUID                id;                      //HSM Engine Media ID
    GUID                ntmsId;                  //HSM RMS/NTMS Media ID
    GUID                storagePoolId;           //Storage Pool ID
    CWsbStringPtr       description;             //Display name - RS generated
    CWsbStringPtr       name;                    //Barcode on media or NTMS generated
                                                 //name
    HSM_JOB_MEDIA_TYPE  type;                    //Type of media (HSM)
    FILETIME            lastUpdate;              //Last update of copy
    HRESULT             lastError;               //S_OK or the last exception 
                                                 //..encountered when accessing
                                                 //..the media
    BOOL                recallOnly;              //True if no more data is to
                                                 //..be premigrated to the media
                                                 //..Set by internal operations, 
                                                 //..may not be changed externally
    LONGLONG            freeBytes;               //Real free space on media
    LONGLONG            capacity;                //Total capacity of media
    SHORT               nextRemoteDataSet;       //Next remote data set
} HSM_MEDIA_MASTER, *PHSM_MEDIA_MASTER;

typedef struct _HSM_MEDIA_COPY {
    GUID                id;                    //HSM RMS/NTMS Media ID of copy
    CWsbStringPtr       description;           //RS generated name of copy (display name)
    CWsbStringPtr       name;                  //Barcode or NTMS generated name of copy
    FILETIME            lastUpdate;            //Last update of copy
    HRESULT             lastError;             //S_OK or the last exception 
                                               //..encountered when accessing
                                               //..the media
    SHORT               nextRemoteDataSet;     //The next remote data set of the media
                                               //..master that was copied
} HSM_MEDIA_COPY, *PHSM_MEDIA_COPY;


/////////////////////////////////////////////////////////////////////////////
// Task

class CMediaInfo : 
    public CWsbDbEntity,
    public IMediaInfo,
    public CComCoClass<CMediaInfo,&CLSID_CMediaInfo>
{
public:
    CMediaInfo() {}
BEGIN_COM_MAP(CMediaInfo)
    COM_INTERFACE_ENTRY(IMediaInfo)
    COM_INTERFACE_ENTRY2(IWsbDbEntity, CWsbDbEntity)
    COM_INTERFACE_ENTRY(IWsbDbEntityPriv)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
//    COM_INTERFACE_ENTRY(IWsbPersistable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY(CMediaInfo, _T("Task.MediaInfo.1"), _T("Task.MediaInfo"), IDS_MEDIAINFO_DESC, THREADFLAGS_BOTH)

// IMediaInfo
public:
    STDMETHOD(FinalConstruct)(void);
    void FinalRelease(void);

// IWsbDbEntity
public:
    STDMETHOD(Print)(IStream* pStream);
    STDMETHOD(UpdateKey)(IWsbDbKey *pKey);
    WSB_FROM_CWSBDBENTITY;

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbTestable
public:
    STDMETHOD(Test)(USHORT *pTestsPassed, USHORT* pTestsFailed);
//*/
// IMediaInfo
public:
    STDMETHOD( GetCapacity )( LONGLONG *pCapacity );
    STDMETHOD( GetCopyDescription ) ( USHORT copyNumber, OLECHAR **pDescription, 
                                                         ULONG bufferSize);
    STDMETHOD( GetCopyInfo )( USHORT copyNumber, 
                              GUID *pMediaSubsystemId, 
                              OLECHAR **pDescription, 
                              ULONG descriptionBufferSize,
                              OLECHAR **pName, 
                              ULONG nameBufferSize,
                              FILETIME *pUpdate, 
                              HRESULT *pLastError,
                              SHORT  *pNextRemoteDataSet );
    STDMETHOD( GetCopyLastError )( USHORT copyNumber, HRESULT *pLastError );
    STDMETHOD( GetCopyMediaSubsystemId )( USHORT copyNumber, GUID *pMediaSubsystemId );
    STDMETHOD( GetCopyName )( USHORT copyNumber, OLECHAR **pName, ULONG bufferSize); 
    STDMETHOD( GetCopyNextRemoteDataSet )( USHORT copyNumber, SHORT *pNextRemoteDataSet); 
    STDMETHOD( GetCopyUpdate )(  USHORT copyNumber, FILETIME *pUpdate ); 
    STDMETHOD( GetDescription )(OLECHAR **pDescription, ULONG buffsize );
    STDMETHOD( GetFreeBytes )( LONGLONG *pFreeBytes);
    STDMETHOD( GetId )( GUID *pId);
    STDMETHOD( GetLastError    )( HRESULT *pLastError);
    STDMETHOD( GetLastKnownGoodMasterInfo    )( GUID* pMediaId, 
                               GUID *pMediaSubsystemId, 
                               GUID *pStoragePoolId, 
                               LONGLONG *pFreeBytes, 
                               LONGLONG *pCapacity, 
                               HRESULT *pLastError, 
                               OLECHAR **pDescription, 
                               ULONG descriptionBufferSize,
                               HSM_JOB_MEDIA_TYPE *pType,
                               OLECHAR **pName,
                               ULONG nameBufferSize,
                               BOOL *pReadOnly,
                               FILETIME *pUpdate,
                               SHORT *pNextRemoteDataSet);
    STDMETHOD( GetLKGMasterNextRemoteDataSet )( SHORT *pNextRemoteDataSet );
    STDMETHOD( GetLogicalValidBytes )( LONGLONG *pLogicalValidBytes);
    STDMETHOD( GetMediaInfo    )( GUID* pMediaId, 
                               GUID *pMediaSubsystemId, 
                               GUID *pStoragePoolId, 
                               LONGLONG *pFreeBytes, 
                               LONGLONG *pCapacity, 
                               HRESULT *pLastError, 
                               SHORT *pNextRemoteDataSet, 
                               OLECHAR **pDescription, 
                               ULONG descriptionBufferSize,
                               HSM_JOB_MEDIA_TYPE *pType,
                               OLECHAR **pName,
                               ULONG nameBufferSize,
                               BOOL *pReadOnly,
                               FILETIME *pUpdate,
                               LONGLONG *pLogicalValidBytes,
                               BOOL *pRecreate);
    STDMETHOD( GetMediaSubsystemId )( GUID *pRmsMediaId );
    STDMETHOD( GetName )( OLECHAR **pName, ULONG bufferSize); 
    STDMETHOD( GetNextRemoteDataSet )( SHORT *pNextRemoteDataSet );
    STDMETHOD( GetRecallOnlyStatus )( BOOL *pRecallOnlyStatus );
    STDMETHOD( GetRecreate )( BOOL *pRecreate );
    STDMETHOD( GetStoragePoolId )( GUID *pStoragePoolId );
    STDMETHOD( GetType     )( HSM_JOB_MEDIA_TYPE *pType );
    STDMETHOD( GetUpdate)( FILETIME *pUpdate );

    STDMETHOD( SetCapacity )( LONGLONG capacity);
    STDMETHOD( SetCopyDescription )    ( USHORT copyNumber, OLECHAR *name); 
    STDMETHOD( SetCopyInfo )( USHORT copyNumber, 
                              GUID mediaSubsystemId, 
                              OLECHAR *description, 
                              OLECHAR *name, 
                              FILETIME update, 
                              HRESULT lastError,
                              SHORT nextRemoteDataSet );
    STDMETHOD( SetCopyLastError )( USHORT copyNumber, HRESULT lastError );
    STDMETHOD( SetCopyMediaSubsystemId )( USHORT copyNumber, GUID mediaSybsystemMediaId ); 
    STDMETHOD( SetCopyName )( USHORT copyNumber, OLECHAR *barCode); 
    STDMETHOD( SetCopyNextRemoteDataSet )( USHORT copyNumber, SHORT nextRemoteDataSet); 
    STDMETHOD( SetCopyUpdate )( USHORT copyNumber, FILETIME update ); 
    STDMETHOD( SetDescription )(OLECHAR *description);
    STDMETHOD( SetFreeBytes )( LONGLONG FreeBytes );
    STDMETHOD( SetId )( GUID id);
    STDMETHOD( SetLastError )( HRESULT lastError);
    STDMETHOD( SetLastKnownGoodMasterInfo )( GUID mediaId, 
                               GUID mediaSubsystemMediaId, 
                               GUID storagePoolId, 
                               LONGLONG FreeBytes, 
                               LONGLONG Capacity, 
                               HRESULT lastError, 
                               OLECHAR *description, 
                               HSM_JOB_MEDIA_TYPE type,
                               OLECHAR *name,
                               BOOL     ReadOnly,
                               FILETIME update,
                               SHORT nextRemoteDataSet);
    STDMETHOD( SetLogicalValidBytes )( LONGLONG logicalValidBytes);
    STDMETHOD( SetMediaInfo )( GUID mediaId, 
                               GUID mediaSubsystemMediaId, 
                               GUID storagePoolId, 
                               LONGLONG FreeBytes, 
                               LONGLONG Capacity, 
                               HRESULT lastError, 
                               SHORT nextRemoteDataSet, 
                               OLECHAR *description, 
                               HSM_JOB_MEDIA_TYPE type,
                               OLECHAR *name,
                               BOOL     ReadOnly,
                               FILETIME update,
                               LONGLONG logicalValidBytes,
                               BOOL     recreate);
    STDMETHOD( SetMediaSubsystemId )( GUID rmsMediaId );
    STDMETHOD( SetName )( OLECHAR *barCode); 
    STDMETHOD( SetNextRemoteDataSet )( SHORT nextRemoteDataSet );
    STDMETHOD( SetRecallOnlyStatus )( BOOL readOnlyStatus );
    STDMETHOD( SetRecreate )( BOOL recreate );
    STDMETHOD( SetStoragePoolId )( GUID storagePoolId );
    STDMETHOD( SetType )( HSM_JOB_MEDIA_TYPE type );
    STDMETHOD( SetUpdate)( FILETIME update );
    STDMETHOD( DeleteCopy)( USHORT copyNumber );
    STDMETHOD( RecreateMaster )( void );
    STDMETHOD( UpdateLastKnownGoodMaster )( void  );

private:
    //
    // Helper functions
    //
    STDMETHOD( WriteToDatabase )( void  );

    HSM_MEDIA_MASTER    m_Master;                               //Media master information
    BOOL                m_Recreate;                             //True if the master is to 
                                                                //..be recreated - no more 
                                                                //..data is migrated to 
                                                                //..media in this state.
                                                                //..May be set through the 
                                                                //..UI and changed when 
                                                                //..master is recreated.
    LONGLONG            m_LogicalValidBytes;                     //Amount of valid data if 
                                                                //..space reclamation were 
                                                                //..to occur.
    HSM_MEDIA_MASTER    m_LastKnownGoodMaster;                  //Last known good media 
                                                                //..master information
    HSM_MEDIA_COPY      m_Copy[HSM_MAX_NUMBER_MEDIA_COPIES];    //Media copy information
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\engine\task\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\engine\task\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by task.rc
//
#define IDS_TSKMGR_DESC                 1
#define IDS_HSMTSKMGR_DESC             10
#define IDS_SEGREC_DESC                20
#define IDS_BAGHOLE_DESC               30
#define IDS_MEDIAINFO_DESC             40
#define IDS_BAGINFO_DESC               50
#define IDS_SEGDB_DESC                 60
#define IDS_HSMWORKQUEUE_DESC          70
#define IDS_HSMWORKITEM_DESC           80
#define IDS_VOLASSIGN_DESC             90

#define IDR_CHsmTskMgr                      1
#define IDR_CHsmWorkQueue                   101
#define IDR_CHsmWorkItem                    201
#define IDR_CHsmRecallQueue                 301
#define IDR_CHsmRecallItem                  401

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\engine\task\segdb.h ===
// SegDb.h : Declaration of the CSegDb


#include "resource.h"       // main symbols
#include "Wsb.h"            // Wsb Collectable Class
#include "wsbdb.h"


#define SEG_KEY_TYPE          1
#define MEDIA_INFO_KEY_TYPE   1
#define BAG_INFO_KEY_TYPE     1
#define BAG_HOLE_KEY_TYPE     1
#define VOL_ASSIGN_KEY_TYPE   1

// NOTE:
//
//  The macro SEG_DB_MAX_MEDIA_NAME_LEN and SEG_DB_MAX_MEDIA_BAR_CODE_LEN below were defined without parenthesis 
//  As a result, the max size of the media record is only 711 bytes instead of 1751 as it should be !!
//  See Windows Bugs 407340.
//  It is NOT fixed since there are too many existing installations with the wrong record size...
//  This bug has implications around the code - look for "Windows Bugs 407340" comments throughout the HSM code
//
#define SEG_DB_MAX_MEDIA_NAME_LEN        MAX_COMPUTERNAME_LENGTH + 128 + 2
#define SEG_DB_MAX_MEDIA_BAR_CODE_LEN    MAX_COMPUTERNAME_LENGTH + 128 + 2

/////////////////////////////////////////////////////////////////////////////
// seg

class CSegDb : 
    public CWsbDb,
    public ISegDb,
    public CComCoClass<CSegDb,&CLSID_CSegDb>
{
public:
    CSegDb() {}
BEGIN_COM_MAP(CSegDb)
    COM_INTERFACE_ENTRY(ISegDb)
    COM_INTERFACE_ENTRY2(IWsbDb, ISegDb)
    COM_INTERFACE_ENTRY(IWsbDbPriv)
    COM_INTERFACE_ENTRY(IPersistStream)
//  COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY(CSegDb, _T("Seg.SegDb.1"), _T("Seg.SegDb"), IDS_SEGDB_DESC, THREADFLAGS_BOTH)

DECLARE_PROTECT_FINAL_CONSTRUCT();

    STDMETHOD(FinalConstruct)(void);
    STDMETHOD(FinalRelease)(void);

// IWsbTestable
public:
    STDMETHOD(Test)(USHORT *pTestsPassed, USHORT* pTestsFailed);

// IWsbDb
    WSB_FROM_CWSBDB;

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pclsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize) {
            return(CWsbDb::GetSizeMax(pSize)); }
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// ISegDb
public:
    STDMETHOD(Erase)( void );
    STDMETHOD(Initialize)(OLECHAR* root, IWsbDbSys* pDbSys, BOOL* pCreateFlag);
    STDMETHOD(BagHoleAdd)(IWsbDbSession* pDbSession, GUID bagId, LONGLONG segStartLoc, 
            LONGLONG segLen);
    STDMETHOD(BagHoleFind)(IWsbDbSession* pDbSession, GUID bagId, LONGLONG segStartLoc, 
            LONGLONG segLen, IBagHole** ppIBagHole );
    STDMETHOD(BagHoleSubtract)(IWsbDbSession* pDbSession, GUID bagId, LONGLONG segStartLoc, 
            LONGLONG segLen);
    STDMETHOD(SegAdd)(IWsbDbSession* pDbSession, GUID bagId, LONGLONG segStartLoc, 
            LONGLONG segLen, GUID MediaId, LONGLONG mediaStart, BOOL indirectRecord = FALSE );
    STDMETHOD(SegFind)(IWsbDbSession* pDbSession, GUID bagId, LONGLONG segStartLoc, 
            LONGLONG segLen, ISegRec** ppISegRec );
    STDMETHOD(SegSubtract)(IWsbDbSession* pDbSession, GUID bagId, LONGLONG segStartLoc, 
            LONGLONG SegLen);
    STDMETHOD(VolAssignAdd)(IWsbDbSession* pDbSession, GUID bagId, LONGLONG segStartLoc, 
            LONGLONG segLen, GUID VolId);
    STDMETHOD(VolAssignFind)(IWsbDbSession* pDbSession, GUID bagId, LONGLONG segStartLoc, 
            LONGLONG segLen, IVolAssign** ppIVolAssign );
    STDMETHOD(VolAssignSubtract)(IWsbDbSession* pDbSession, GUID bagId, LONGLONG segStartLoc, 
            LONGLONG segLen);

private:
    LONG                                m_value;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\engine\task\segrec.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    SegmentRecord.cpp

Abstract:

    This component is an object representation of the HSM Metadata segment record. It
    is both a persistable and collectable.

Author:

    Cat Brant   [cbrant]   12-Nov-1996

Revision History:

--*/


#include "stdafx.h"

#include "metaint.h"
#include "metalib.h"
#include "SegRec.h"

#undef  WSB_TRACE_IS     
#define WSB_TRACE_IS        WSB_TRACE_BIT_META

#define SEG_KEY_TYPE 1

static USHORT iCountSegrec = 0;

HRESULT 
CSegRec::GetSegmentRecord(
    OUT GUID *pBagId, 
    OUT LONGLONG *pSegStartLoc, 
    OUT LONGLONG *pSegLen, 
    OUT USHORT *pSegFlags, 
    OUT GUID  *pPrimPos, 
    OUT LONGLONG *pSecPos
    ) 
/*++

Routine Description:

  See ISegRec::GetSegmentRecord

Arguments:

  See ISegRec::GetSegmentRecord

Return Value:
  
    See ISegRec::GetSegmentRecord

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CSegRec::GetSegmentRecord"),OLESTR(""));

    try {
        //Make sure we can provide data memebers
        WsbAssert(0 != pBagId, E_POINTER);
        WsbAssert(0 != pSegStartLoc, E_POINTER);
        WsbAssert(0 != pSegLen, E_POINTER);
        WsbAssert(0 != pSegFlags, E_POINTER);
        WsbAssert(0 != pPrimPos, E_POINTER);
        WsbAssert(0 != pSecPos, E_POINTER);

        //Provide the data members
        *pBagId = m_BagId;
        *pSegStartLoc = m_SegStartLoc;
        *pSegLen = m_SegLen;
        *pSegFlags = m_SegFlags;
        *pPrimPos = m_PrimPos;
        *pSecPos = m_SecPos;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CSegRec::GetSegmentRecord"),
        OLESTR("hr = <%ls>, BagId = <%ls>, SegStartLoc = <%ls>, SegLen = <%ls>, SegFlags = <%ls>, PrimPos = <%ls>, SecPos = <%ls>"),
        WsbHrAsString(hr), WsbPtrToGuidAsString(pBagId), 
        WsbStringCopy(WsbPtrToLonglongAsString(pSegStartLoc)),
        WsbStringCopy(WsbPtrToLonglongAsString(pSegLen)),
        WsbStringCopy(WsbPtrToUshortAsString(pSegFlags)),
        WsbStringCopy(WsbPtrToGuidAsString(pPrimPos)),
        WsbStringCopy(WsbPtrToLonglongAsString(pSecPos)));

    return(hr);
}


HRESULT 
CSegRec::FinalConstruct(
    void
    ) 
/*++

Routine Description:

  This method does some initialization of the object that is necessary
  after construction.

Arguments:

  None.

Return Value:

  S_OK
  Anything returned by CWsbCollectable::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CSegRec::FinalConstruct"), OLESTR(""));
    try {

        WsbAssertHr(CWsbDbEntity::FinalConstruct());

        m_BagId = GUID_NULL;
        m_SegStartLoc = 0;
        m_SegLen = 0;
        m_SegFlags = 0;
        m_PrimPos = GUID_NULL;
        m_SecPos = 0;
    } WsbCatch(hr);

    iCountSegrec++;
    WsbTraceOut(OLESTR("CSegRec::FinalConstruct"), OLESTR("hr = <%ls>, Count is <%d>"),
        WsbHrAsString(hr), iCountSegrec);
    return(hr);
}

void
CSegRec::FinalRelease(
    void
    )

/*++

Implements:

  CSegRec::FinalRelease().

--*/
{
    
    WsbTraceIn(OLESTR("CSegRec::FinalRelease"), OLESTR(""));
    
    CWsbDbEntity::FinalRelease();
    iCountSegrec--;
    
    WsbTraceOut(OLESTR("CSegRec::FinalRelease"), OLESTR("Count is <%d>"), iCountSegrec);
}

HRESULT CSegRec::GetClassID
(
    OUT LPCLSID pclsid
    ) 
/*++

Routine Description:

  See IPerist::GetClassID()

Arguments:

  See IPerist::GetClassID()

Return Value:

    See IPerist::GetClassID()

--*/

{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CSegRec::GetClassID"), OLESTR(""));


    try {
        WsbAssert(0 != pclsid, E_POINTER);
        *pclsid = CLSID_CSegRec;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CSecRec::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pclsid));
    return(hr);
}

HRESULT CSegRec::GetSizeMax
(
    OUT ULARGE_INTEGER* pcbSize
    ) 
/*++

Routine Description:

  See IPersistStream::GetSizeMax().

Arguments:

  See IPersistStream::GetSizeMax().

Return Value:

  See IPersistStream::GetSizeMax().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CSegRec::GetSizeMax"), OLESTR(""));

    try {
        
        WsbAssert(0 != pcbSize, E_POINTER);

        pcbSize->QuadPart = WsbPersistSizeOf(GUID) + WsbPersistSizeOf(LONGLONG) + 
                            WsbPersistSizeOf(LONGLONG)  + WsbPersistSizeOf(USHORT) +
                            WsbPersistSizeOf(GUID)  + WsbPersistSizeOf(LONGLONG);

//      pcbSize->QuadPart = WsbPersistSizeOf(CSegRec); //???????
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CSegRec::GetSizeMax"), 
        OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), 
        WsbPtrToUliAsString(pcbSize));

    return(hr);
}

HRESULT CSegRec::Load
(
    IN IStream* pStream
    ) 
/*++

Routine Description:

  See IPersistStream::Load().

Arguments:

  See IPersistStream::Load().

Return Value:

  See IPersistStream::Load().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CSegRec::Load"), OLESTR(""));

    try {
        WsbAssert(0 != pStream, E_POINTER);
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_BagId));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_SegStartLoc));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_SegLen));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_SegFlags));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_PrimPos));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_SecPos));
    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CSegRec::Load"), 
        OLESTR("hr = <%ls>,  GUID = <%ls>, SegStartLoc = <%I64u>, SegLen = <%I64u>, SegFlags = <%u>, PrimPos <%ls>, SecPos = <%I64u>"), 
        WsbStringCopy(WsbHrAsString(hr)), 
        WsbGuidAsString(m_BagId),
        m_SegStartLoc, m_SegLen, m_SegFlags, WsbStringCopy(WsbGuidAsString(m_PrimPos)), m_SecPos);

    return(hr);
}

HRESULT CSegRec::Save
(
    IN IStream* pStream, 
    IN BOOL clearDirty
    ) 
/*++

Routine Description:

  See IPersistStream::Save().

Arguments:

  See IPersistStream::Save().

Return Value:

  See IPersistStream::Save().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CSegRec::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));

    try {
        WsbAssert(0 != pStream, E_POINTER);
        WsbAffirmHr(WsbSaveToStream(pStream, m_BagId));
        WsbAffirmHr(WsbSaveToStream(pStream, m_SegStartLoc));
        WsbAffirmHr(WsbSaveToStream(pStream, m_SegLen));
        WsbAffirmHr(WsbSaveToStream(pStream, m_SegFlags));
        WsbAffirmHr(WsbSaveToStream(pStream, m_PrimPos));
        WsbAffirmHr(WsbSaveToStream(pStream, m_SecPos));

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CSegRec::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT 
CSegRec::SetSegmentRecord
(
    IN GUID BagId, 
    IN LONGLONG SegStartLoc, 
    IN LONGLONG SegLen, 
    IN USHORT SegFlags, 
    IN GUID PrimPos, 
    IN LONGLONG SecPos 
    )
 /*++

Routine Description:

  See ISegRec::Set().

Arguments:

  See ISegRec::Set().

Return Value:

    S_OK        - Success.

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CSegRec::SetSegmentRecord"), 
        OLESTR("GUID = <%ls>, SegStartLoc = <%I64u>, SegLen = <%I64u>, SegFlags = <%X>, PrimPos = <%ls>, SecPos = <%I64u>"), 
        WsbStringCopy(WsbGuidAsString(BagId)), SegStartLoc, SegLen, SegFlags, 
        WsbStringCopy(WsbGuidAsString(PrimPos)), SecPos);

    m_isDirty = TRUE;
    m_BagId = BagId;
    m_SegStartLoc = SegStartLoc;
    m_SegLen = SegLen;
    m_SegFlags = SegFlags;
    m_PrimPos = PrimPos;
    m_SecPos = SecPos;

    WsbTraceOut(OLESTR("CSegRec::SetSegmentRecord"), OLESTR("hr = <%ls>"),
        WsbHrAsString(S_OK));
    return(hr);
}

HRESULT
CSegRec::GetSegmentFlags(
    USHORT *pSegFlags
    )
/*++

Implements:

  ISegRec::GetSegmentFlags().

--*/
{
    
    HRESULT     hr = S_OK;

    try {
        WsbAssert(0 != pSegFlags, E_POINTER);

        *pSegFlags = m_SegFlags;

    } WsbCatch(hr);

    return(hr);
}

HRESULT
CSegRec::SetSegmentFlags(
    USHORT SegFlags
    )
/*++

Implements:

  ISegRec::SetSegmentFlags().

--*/
{
    
    HRESULT     hr = S_OK;

    m_SegFlags = SegFlags;

    return(hr);
}

HRESULT
CSegRec::GetPrimPos(
    GUID *pPrimPos
    )
/*++

Implements:

  ISegRec::GetPrimPos().

--*/
{
    
    HRESULT     hr = S_OK;

    try {
        WsbAssert(0 != pPrimPos, E_POINTER);

        *pPrimPos = m_PrimPos;

    } WsbCatch(hr);

    return(hr);
}

HRESULT
CSegRec::SetPrimPos(
    GUID PrimPos
    )
/*++

Implements:

  ISegRec::SetPrimPos().

--*/
{
    
    HRESULT     hr = S_OK;

    m_PrimPos = PrimPos;

    return(hr);
}

HRESULT
CSegRec::GetSecPos(
    LONGLONG *pSecPos
    )
/*++

Implements:

  ISegRec::GetSecPos().

--*/
{
    
    HRESULT     hr = S_OK;

    try {
        WsbAssert(0 != pSecPos, E_POINTER);

        *pSecPos = m_SecPos;

    } WsbCatch(hr);

    return(hr);
}

HRESULT
CSegRec::SetSecPos(
    LONGLONG SecPos
    )
/*++

Implements:

  ISegRec::SetSecPos().

--*/
{
    
    HRESULT     hr = S_OK;

    m_SecPos = SecPos;

    return(hr);
}


HRESULT 
CSegRec::Test
(
    OUT USHORT *pTestsPassed, 
    OUT USHORT *pTestsFailed 
    ) 
/*++

Routine Description:

  See IWsbTestable::Test().

Arguments:

  See IWsbTestable::Test().

Return Value:

  See IWsbTestable::Test().

--*/
{
#if 0
    HRESULT                 hr = S_OK;
    CComPtr<ISegRec>        pSegment1;
    CComPtr<ISegRec>        pSegment2;
    GUID                    l_BagId;
    LONGLONG                    l_SegStartLoc;
    LONGLONG                    l_SegLen;
    USHORT                  l_SegFlags;
    GUID                    l_PrimPos;
    LONGLONG                    l_SecPos;

    WsbTraceIn(OLESTR("CSegRec::Test"), OLESTR(""));

    *pTestsPassed = *pTestsFailed = 0;
    try {
        // Get the pSegment interface.
        WsbAssertHr(((IUnknown*)(ISegRec*) this)->QueryInterface(IID_ISegRec,
                    (void**) &pSegment1));


        try {
            // Set the Segment to a value, and see if it is returned.
            WsbAssertHr(pSegment1->SetSegmentRecord(CLSID_CSegRec, 0, 6, 0, CLSID_CSegRec,0 ));

            WsbAssertHr(pSegment1->GetSegmentRecord(&l_BagId, &l_SegStartLoc, &l_SegLen, &l_SegFlags, &l_PrimPos, &l_SecPos));

            WsbAssert((l_BagId == CLSID_CSegRec) && (l_SegStartLoc == 0) &&
                      (l_SegLen == 6) && (l_SegFlags == 0) && (l_PrimPos == CLSID_CSegRec) && 
                      (l_SecPos == 0), E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        hr = S_OK;
        try {
            //Create another instance and test the comparisson methods:
            WsbAssertHr(CoCreateInstance(CLSID_CSegRec, NULL, CLSCTX_ALL, IID_ISegRec, (void**) &pSegment2));

            // Check the default values.
            WsbAssertHr(pSegment2->GetSegmentRecord(&l_BagId, &l_SegStartLoc, &l_SegLen, &l_SegFlags, &l_PrimPos, &l_SecPos));
            WsbAssert(((l_BagId == GUID_NULL) && (l_SegStartLoc == 0) && (l_SegLen == 0) &&
                      (l_SegFlags == 0) && (l_PrimPos == GUID_NULL) && (l_SecPos == 0)), E_FAIL);
        }  WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

#ifdef OLD_CODE
        hr = S_OK;
        try {
            // Equal
            WsbAssertHr(pSegment1->SetSegmentRecord(CLSID_CWsbBool, 1, 100, 0, CLSID_CWsbBool,0 ));
            WsbAssertHr(pSegment2->SetSegmentRecord(CLSID_CWsbBool, 1, 100, 0, CLSID_CWsbBool,0 ));

            WsbAssertHr(pSegment1->CompareToISegmentRecord(pSegment2, &result));
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        hr = S_OK;
        try {
            WsbAssertHr(pSegment1->SetSegmentRecord(CLSID_CWsbBool, 5, 6, 3, CLSID_CWsbBool,1 ));
            WsbAssertHr(pSegment2->SetSegmentRecord(CLSID_CWsbLong, 0, 6, 0, CLSID_CWsbBool,0 ));

            WsbAssert((pSegment1->CompareToISegmentRecord(pSegment2, &result) == S_FALSE), E_FAIL);
        }  WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        hr = S_OK;
        try {
             // CompareTo()
             WsbAssertHr(pSegment1->SetSegmentRecord(CLSID_CWsbBool, 1, 100, 0, CLSID_CWsbBool,0 ));
             WsbAssertHr(pSegment2->SetSegmentRecord(CLSID_CWsbBool, 10, 6, 0, CLSID_CWsbBool,0 ));

             WsbAssert((pSegment1->CompareToISegmentRecord(pSegment2, &result) == S_FALSE), E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        hr = S_OK;
        try {
            WsbAssertHr(pSegment1->SetSegmentRecord(CLSID_CWsbBool, 0, 6, 0, CLSID_CWsbBool,0 ));
            WsbAssertHr(pSegment2->SetSegmentRecord(CLSID_CWsbLong, 0, 6, 0, CLSID_CWsbBool,0 ));

            WsbAssert(((pSegment1->CompareToISegmentRecord(pSegment2, &result) == S_FALSE) && (result > 0)), E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        hr = S_OK;
        try {
             WsbAssertHr(pSegment1->SetSegmentRecord(CLSID_CWsbBool, 0, 6, 0, CLSID_CWsbBool,0 ));
             WsbAssertHr(pSegment2->SetSegmentRecord(CLSID_CWsbBool, 0, 6, 0, CLSID_CWsbBool,0 ));

             WsbAssert((pSegment1->CompareToISegmentRecord(pSegment2, &result) == S_OK), E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        try {
        // Try out the persistence stuff.
            CComPtr<IPersistFile>       pFile1;
            CComPtr<IPersistFile>       pFile2;

            WsbAssertHr(pSegment1->QueryInterface(IID_IPersistFile, (void**) &pFile1));
            WsbAssertHr(pSegment2->QueryInterface(IID_IPersistFile, (void**) &pFile2));

            LPOLESTR    szTmp = NULL;
            // The item should be dirty.
            try {
                WsbAssertHr(pSegment2->SetSegmentRecord(CLSID_CWsbLong, 0, 6, 0, CLSID_CWsbBool,0 ));
                WsbAssertHr(pFile2->IsDirty());
            } WsbCatch(hr);

            if (hr == S_OK) {
                (*pTestsPassed)++;
            } else {
                (*pTestsFailed)++;
            }

            hr = S_OK;
            try {
                // Save the item, and remember.
                WsbAssertHr(pFile2->Save(OLESTR("c:\\WsbTests\\WsbSegment.tst"), TRUE));
            } WsbCatch(hr);

            if (hr == S_OK) {
                (*pTestsPassed)++;
            } else {
                (*pTestsFailed)++;
            }

            hr = S_OK;
            try {
                // It shouldn't be dirty.
                WsbAssert((pFile2->IsDirty() == S_FALSE), E_FAIL);

            } WsbCatch(hr);

            if (hr == S_OK) {
                (*pTestsPassed)++;
            } else {
                (*pTestsFailed)++;
            }

            hr = S_OK;
            try {
                // Try reading it in to another object.
                WsbAssertHr(pSegment1->SetSegmentRecord(CLSID_CWsbLong, 0, 6, 0, CLSID_CWsbBool,0 ));
                WsbAssertHr(pFile1->Load(OLESTR("c:\\WsbTests\\WsbSegment.tst"), 0));

                WsbAssertHr(pSegment1->CompareToISegmentRecord(pSegment2, &result));
            }WsbCatch(hr);

            if (hr == S_OK) {
                (*pTestsPassed)++;
            } else {
                (*pTestsFailed)++;
            }
        } WsbCatch(hr);
#endif
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CSegRec::Test"),    OLESTR("hr = <%ls>"),WsbHrAsString(hr));
#else
    UNREFERENCED_PARAMETER(pTestsPassed);
    UNREFERENCED_PARAMETER(pTestsFailed);
#endif
    return(S_OK);
}


HRESULT CSegRec::Print
(
    IN IStream* pStream
    ) 
/*++

Implements:

  IWsbDbEntity::Print

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CSegRec::Print"), OLESTR(""));

    try {
        WsbAssert(0 != pStream, E_POINTER);
        CWsbStringPtr strGuid;
        WsbAffirmHr(WsbSafeGuidAsString(m_BagId, strGuid));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" BagId = %ls"), 
                (WCHAR *)strGuid));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(", StartLoc = %ls"), 
                WsbLonglongAsString(m_SegStartLoc)));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(", SegLen = %ls"), 
                WsbLonglongAsString(m_SegLen)));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(", SegFlags = %X"), 
                m_SegFlags));
        WsbAffirmHr(WsbSafeGuidAsString(m_PrimPos, strGuid));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(", PrimPos = %ls"), 
                (WCHAR *)strGuid));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(", SecPos = %ls "), 
                WsbLonglongAsString(m_SecPos)));
        WsbAffirmHr(CWsbDbEntity::Print(pStream));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CSegRec::Print"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT 
CSegRec::Split
(
    IN GUID BagId, 
    IN LONGLONG SegStartLoc, 
    IN LONGLONG SegLen, 
    IN ISegRec* /*pSegRec1*/,
    IN ISegRec* /*pSegRec2*/
    )
 /*++

Routine Description:

  See ISegRec::Split().

Arguments:

  See ISegRec::Split().

Return Value:

    S_OK        - Success.

--*/
{
    WsbTraceIn(OLESTR("CSegRec::Split"), 
        OLESTR("GUID = <%ls>, SegStartLoc = <%I64u>, SegLen = <%I64u>"), 
        WsbGuidAsString(BagId), SegStartLoc, SegLen);

    //Fill in the two segment records splitting the current record around the hole
    //Note that there may not always be two segments generated by the split e.g., if
    //the hole is at the beginning or end of the segment record or if the hole is the
    //entire record.


    WsbTraceOut(OLESTR("CSegRec::Split"), OLESTR("hr = <%ls>"),
        WsbHrAsString(S_OK));
    return(S_OK);
}


HRESULT 
CSegRec::UpdateKey(
    IWsbDbKey *pKey
    ) 
/*++

Implements:

  IWsbDbEntity::UpdateKey

--*/
{ 
    HRESULT  hr = S_OK; 

    try {
        WsbAffirmHr(pKey->SetToGuid(m_BagId));
        WsbAffirmHr(pKey->AppendLonglong(m_SegStartLoc));
    } WsbCatch(hr);

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\engine\task\segdb.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    SegDb.cpp

Abstract:

    This component is an provides the collection that contains the HSM segment records.

Author:

    Cat Brant   [cbrant]   12-Nov-1996

Revision History:

--*/


#include "stdafx.h"

#include "metaint.h"
#include "metaLib.h"
#include "engine.h"
#include "segdb.h"

#undef  WSB_TRACE_IS     
#define WSB_TRACE_IS        WSB_TRACE_BIT_SEG

//  SEG_APPEND_OK returns TRUE if bag segment 2 can be appended to
//  segment 1
#define SEG_APPEND_OK(b1, s1, l1, b2, s2, l2) \
        (IsEqualGUID(b1, b2) && (s1 + l1 == s2))

//  SEG_EXPAND_OK returns TRUE if bag segment 2 can be added to
//  segment 1
#define SEG_EXPAND_OK(b1, s1, l1, b2, s2, l2) \
        (IsEqualGUID(b1, b2) && (s1 + l1 <= s2))

//  SEG_CONTAINS returns TRUE if bag segment 1 contains (the first
//    part of) segment 2
#define SEG_CONTAINS(b1, s1, l1, b2, s2, l2) \
        (IsEqualGUID(b1, b2) && (s1 <= s2) && ((s1 + l1) > s2))


HRESULT 
CSegDb::BagHoleAdd
(
    IN IWsbDbSession* pDbSession,
    IN GUID BagId, 
    IN LONGLONG SegStartLoc, 
    IN LONGLONG SegLen
    )
 /*++

Implements:

  ISegDb::BagHoleAdd

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CSegDb::BagHoleAdd"), 
        OLESTR("GUID = <%ls>, SegStartLoc = <%I64u>, SegLen = <%I64u>"), 
        WsbGuidAsString(BagId), SegStartLoc, 
        SegLen);

    try {
        BOOL                    found = FALSE;
        CComPtr<IBagHole>       pBagHole;    
        GUID                    l_BagId = GUID_NULL;
        LONGLONG                l_SegStartLoc = 0;
        LONGLONG                l_SegLen = 0;

        WsbAffirmHr(GetEntity(pDbSession, HSM_BAG_HOLE_REC_TYPE, IID_IBagHole,
                (void **)&pBagHole));
        WsbAffirmHr(pBagHole->SetBagHole(BagId, SegStartLoc, 0));

        //  Look for a segment to which to append this one
        WsbTrace(OLESTR("Finding BagHole Record: <%ls>, <%I64u>, <%I64u>\n"),
                WsbGuidAsString(BagId), 
                SegStartLoc,
                SegLen);
        hr = pBagHole->FindLTE();
        if (WSB_E_NOTFOUND == hr) {
            hr = S_OK;
        } else {
            WsbAffirmHr(pBagHole->GetBagHole(&l_BagId, &l_SegStartLoc, &l_SegLen));
            if (SEG_APPEND_OK(l_BagId, l_SegStartLoc,  l_SegLen,
                    BagId, SegStartLoc, SegLen)) {
                found = TRUE;
            }
        }

        if (found) {
            //  Append this segment to the existing record
            l_SegLen += SegLen;
        } else {
            //  Create a new record
            l_SegStartLoc = SegStartLoc;
            l_SegLen = SegLen;
            WsbAffirmHr(pBagHole->MarkAsNew());
        }
        WsbAffirmHr(pBagHole->SetBagHole(BagId, l_SegStartLoc, l_SegLen));

        WsbTrace(OLESTR("Writing BagHole Record: <%ls>, <%I64u>, <%I64u>\n"),
                    WsbGuidAsString(BagId), 
                    l_SegStartLoc,
                    l_SegLen);
        WsbAffirmHr(pBagHole->Write());

    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CSegDb::BagHoleAdd"), OLESTR("hr = <%ls>"),WsbHrAsString(S_OK));
    return(hr);
}


HRESULT 
CSegDb::BagHoleFind
(
    IN IWsbDbSession* pDbSession,
    IN GUID BagId, 
    IN LONGLONG SegStartLoc, 
    IN LONGLONG SegLen,
    OUT IBagHole** ppIBagHole
    )
 /*++

Implements:

  ISegDb::BagHoleFind

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CSegDb::BagHoleFind"), 
        OLESTR("GUID = <%ls>, SegStartLoc = <%I64u>, SegLen = <%I64u>"), 
        WsbGuidAsString(BagId), SegStartLoc, 
        SegLen);

    try {
        CComPtr<IBagHole>       pBagHole;    
        GUID                    l_BagId;
        LONGLONG                l_SegStartLoc;
        LONGLONG                l_SegLen;

        WsbAffirm(ppIBagHole != NULL, E_POINTER);
        WsbAffirmHr(GetEntity(pDbSession, HSM_BAG_HOLE_REC_TYPE, IID_IBagHole,
                (void **)&pBagHole));
        WsbAffirmHr(pBagHole->SetBagHole(BagId, SegStartLoc, 0));

        //  Look for a segment that contains this one
        WsbTrace(OLESTR("Finding BagHole Record: <%ls>, <%I64u>, <%I64u>\n"),
                WsbGuidAsString(BagId), 
                SegStartLoc,
                SegLen);
        WsbAffirmHr(pBagHole->FindLTE());

        //  We found a record, see if it's the right one
        WsbAffirmHr(pBagHole->GetBagHole(&l_BagId, &l_SegStartLoc, &l_SegLen));
        if (SEG_CONTAINS(l_BagId, l_SegStartLoc, l_SegLen,
                BagId, SegStartLoc, SegLen)) {
            *ppIBagHole = pBagHole;
            pBagHole.p->AddRef();
        } else {
            hr = WSB_E_NOTFOUND;
        }

    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CSegDb::BagHoleFind"), OLESTR("hr = <%ls>"),WsbHrAsString(S_OK));
    return(hr);
}


HRESULT 
CSegDb::BagHoleSubtract
(
    IN IWsbDbSession* pDbSession,
    IN GUID BagId, 
    IN LONGLONG SegStartLoc, 
    IN LONGLONG SegLen
    )
 /*++

Implements:

  ISegDb::BagHoleSubtract

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CSegDb::BagHoleSubtract"), 
        OLESTR("GUID = <%ls>, SegStartLoc = <%I64u>, SegLen = <%I64u>"), 
        WsbGuidAsString(BagId), 
        SegStartLoc, 
        SegLen);

    try {
        GUID                    l_BagId;
        LONGLONG                l_SegStartLoc;
        LONGLONG                l_SegLen;
        CComPtr<IBagHole>       pBagHole;    

        //  Find the segment record
        WsbAffirmHr(BagHoleFind(pDbSession, BagId, SegStartLoc, SegLen, &pBagHole));

        //  Get the current data
        WsbAffirmHr(pBagHole->GetBagHole(&l_BagId, &l_SegStartLoc, &l_SegLen));

        //  Determine where the hole is
        if (l_SegStartLoc == SegStartLoc && l_SegLen == SegLen) {
            //  Hole is the entire segment -- delete it
            WsbAffirmHr(pBagHole->Remove());

        } else if (l_SegStartLoc == SegStartLoc) {
            //  Hole is at the beginning of the segment.  Just update the
            //  existing segment
            l_SegStartLoc += SegLen;
            WsbAffirmHr(pBagHole->SetBagHole(BagId, l_SegStartLoc, l_SegLen));
            WsbAffirmHr(pBagHole->Write());

        } else if ((l_SegStartLoc + l_SegLen) == (SegStartLoc + SegLen)) {
            //  Hole is at the end of the segment.  Just update the
            //  existing segment
            l_SegLen -= SegLen;
            WsbAffirmHr(pBagHole->SetBagHole(BagId, l_SegStartLoc, l_SegLen));
            WsbAffirmHr(pBagHole->Write());

        } else {
            //  Hole is in the middle of the segment.  Update the
            //  existing record to be the first part.
            LONGLONG    oldLen = l_SegLen;
            LONGLONG    offset = (SegStartLoc + SegLen) - l_SegStartLoc;

            l_SegLen = SegStartLoc - l_SegStartLoc;
            WsbAffirmHr(pBagHole->SetBagHole(BagId, l_SegStartLoc, l_SegLen));
            WsbAffirmHr(pBagHole->Write());

            //  Create a new record for the second part.
            l_SegLen -= offset;
            l_SegStartLoc += offset;
            WsbAffirmHr(BagHoleAdd(pDbSession, BagId, l_SegStartLoc, l_SegLen));
        }

    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CSegDb::BagHoleSubtract"), OLESTR("hr = <%ls>"),WsbHrAsString(S_OK));
    return(hr);
}


HRESULT 
CSegDb::FinalConstruct(
    void
    ) 
/*++

Routine Description:

  This method does some initialization of the object that is necessary
  after construction.

Arguments:

  None.

Return Value:

  S_OK

--*/
{
    HRESULT     hr = S_OK;

    m_value = 0;
    try {

        WsbAssertHr(CWsbDb::FinalConstruct());
        m_version = 1;

    } WsbCatch(hr);

    return(hr);
}


HRESULT 
CSegDb::FinalRelease(
    void
    ) 
/*++

Routine Description:

  This method does some termination of the object that is necessary
  before destruction. 

Arguments:

  None.

Return Value:

  S_OK
  Anything returned by CWsbCollection::FinalDestruct().

--*/
{
    HRESULT     hr = S_OK;

    CWsbDb::FinalRelease();
    return(hr);
}

HRESULT 
CSegDb::Test
(
    OUT USHORT * pTestsPassed,
    OUT USHORT* pTestsFailed
    ) 
/*++

Routine Description:

  See IWsbTestable::Test().

Arguments:

  See IWsbTestable::Test().

Return Value:

  See IWsbTestable::Test().

--*/
{
    HRESULT             hr = S_OK;

#ifdef THIS_CODE_IS_WRONG
//  This is mostly wrong now
    ULONG               entries;
    GUID                    lastBagId;
    LONGLONG                lastStartLoc;
    GUID                    startBagId;
    LONGLONG                startSegStartLoc;
    LONGLONG                startSegLen;
    USHORT                  startSegType;
    GUID                    startPrimLoc;
    LONGLONG                    startSecLoc;
    USHORT              testsRun = 0;
    CComPtr<IWsbCollection> pColl;
    CComPtr<ISegRec>    pSegRec1;
    CComPtr<ISegRec>    pSegRec2;
    CComPtr<ISegRec>    pSegRec3;
    CComPtr<ISegRec>    pSegRec4;
    CComPtr<ISegRec>    pSegRec5;
    CComPtr<ISegRec>    pSegRec6;
    CComPtr<ISegRec>    pSegRec7;
    CComPtr<ISegRec>    pSegRec8;
    CComPtr<ISegRec>    pSegRec9;
    CComPtr<ISegRec>    pSegRec10;
    CComPtr<ISegRec>    pSegRec11;

    WsbTraceIn(OLESTR("CSegDb::Test"), OLESTR(""));

    *pTestsPassed = *pTestsFailed = 0;
    try {
        // Clear out any entries that might be present.
        hr = S_OK;
        try {
            WsbAssertHr(Erase());
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        // There shouldn't be any entries.
        hr = S_OK;
        try {
            WsbAssertHr(GetSegments(&pColl));
            WsbAssertHr(pColl->GetEntries(&entries));
            WsbAssert(0 == entries, E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        // It should be empty.
        hr = S_OK;
        try {
            WsbAssert(pColl->IsEmpty() == S_OK, E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        // We need some collectable items to exercise the collection.
        WsbAssertHr(GetEntity(pDbSession, HSM_SEG_REC_TYPE, IID_ISegRec, (void**) &pSegRec1));
        WsbAssertHr(pSegRec1->SetSegmentRecord(CLSID_CWsbBool, 0, 6, 0, CLSID_CSegRec,0 ));
        

        // Add the item to the collection.
        hr = S_OK;
        try {
            WsbAssertHr(pSegRec1->Write());
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        // There should be 1 entry.
        hr = S_OK;
        try {
            WsbAssertHr(pColl->GetEntries(&entries));
            WsbAssert(1 == entries, E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        // It should not be empty.
        hr = S_OK;
        try {
            WsbAssert(pColl->IsEmpty() == S_FALSE, E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        // Does it think it has the item?
        hr = S_OK;
        try {
            WsbAssertHr(GetEntity(pDbSession, HSM_SEG_REC_TYPE, IID_ISegRec, (void**) &pSegRec2));
            WsbAssertHr(pSegRec2->SetSegmentRecord(CLSID_CWsbBool, 0, 6, 0, CLSID_CSegRec,0 ));
            WsbAssertHr(pSegRec2->FindEQ());
            WsbAssert(pSegRec1->CompareToISegmentRecord(pSegRec2, NULL) == S_OK, E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        // Add some more items
        WsbAssertHr(pSegRec2->SetSegmentRecord(CLSID_CWsbGuid, 0, 5, 0, CLSID_CSegRec,0 ));

        WsbAssertHr(GetEntity(pDbSession, HSM_SEG_REC_TYPE, IID_ISegRec, (void**) &pSegRec3));
        WsbAssertHr(pSegRec3->SetSegmentRecord(CLSID_CWsbGuid, 0, 5, 0, CLSID_CSegRec,0 ));

        // Add the items to the collection.
        hr = S_OK;
        try {
            WsbAssertHr(pSegRec2->Write());
            WsbAssertHr(pSegRec3->Write());
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        // There should be 3 entries.
        hr = S_OK;
        try {
            WsbAssertHr(pColl->GetEntries(&entries));
            WsbAssert(3 == entries, E_FAIL);
            WsbAssertHr(pColl->OccurencesOf(pSegRec3, &entries));
            WsbAssert(2 == entries, E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        // Remove one of the two identical items.
        hr = S_OK;
        try {
            WsbAssertHr(pSegRec3->FindEQ());
            WsbAssertHr(pSegRec3->Remove());
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        // There should be 2 entries.
        hr = S_OK;
        try {
            WsbAssertHr(pColl->GetEntries(&entries));
            WsbAssert(2 == entries, E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        // How many copies does it have?
        hr = S_OK;
        try {
            WsbAssertHr(pColl->OccurencesOf(pSegRec1, &entries));
            WsbAssert(1 == entries, E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        hr = S_OK;
        try {
            WsbAssertHr(pColl->OccurencesOf(pSegRec3, &entries));
            WsbAssert(1 == entries, E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        // Can we find an entry?
        hr = S_OK;
        try {
            WsbAssertHr(pSegRec3->FindEQ());
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        // Does the collection still contain it?
        hr = S_OK;
        try {
            WsbAssert(pColl->Contains(pSegRec1) == S_OK, E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        // Remove the last of the record, and verify
        // that it can't be found. Then puit it back.
        hr = S_OK;
        try {
            WsbAssertHr(pSegRec1->FindEQ());
            WsbAssertHr(pSegRec1->Remove());
            WsbAssert(pColl->Contains(pSegRec1) == S_FALSE, E_FAIL);
            WsbAssertHr(pSegRec1->MarkAsNew());
            WsbAssertHr(pSegRec1->Write());
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        try {
            WsbAssertHr(pColl->RemoveAllAndRelease());
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        // It should be empty.
        hr = S_OK;
        try {
            WsbAssert(pColl->IsEmpty() == S_OK, E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        hr = S_OK;
        try {
            WsbAssertHr(Erase());
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }


        try {
            WsbAssertHr(pSegRec1->SetSegmentRecord(CLSID_CWsbBool, 0, 6, 0, CLSID_CSegRec,0 ));
            WsbAssertHr(pSegRec2->SetSegmentRecord(CLSID_CWsbGuid, 0, 5, 0, CLSID_CSegRec,0 ));
            WsbAssertHr(pSegRec3->SetSegmentRecord(CLSID_CWsbGuid, 5, 5, 0, CLSID_CSegRec,0 ));

            WsbAssertHr(GetEntity(HSM_SEG_REC_TYPE, IID_ISegRec, (void**) &pSegRec4));
            WsbAssertHr(pSegRec4->SetSegmentRecord(CLSID_CWsbGuid, 10, 5, 0, CLSID_CSegRec,0 ));

            WsbAssertHr(GetEntity(HSM_SEG_REC_TYPE, IID_ISegRec, (void**) &pSegRec5));
            WsbAssertHr(pSegRec5->SetSegmentRecord(CLSID_CWsbGuid, 15, 5, 0, CLSID_CSegRec,0 ));

            WsbAssertHr(GetEntity(HSM_SEG_REC_TYPE, IID_ISegRec, (void**) &pSegRec6));
            WsbAssertHr(pSegRec6->SetSegmentRecord(CLSID_CWsbGuid, 20, 5, 0, CLSID_CSegRec,0 ));

            WsbAssertHr(GetEntity(HSM_SEG_REC_TYPE, IID_ISegRec, (void**) &pSegRec7));
            WsbAssertHr(pSegRec7->SetSegmentRecord(CLSID_CWsbGuid, 25, 5, 0, CLSID_CSegRec,0 ));

            WsbAssertHr(GetEntity(HSM_SEG_REC_TYPE, IID_ISegRec, (void**) &pSegRec8));
            WsbAssertHr(pSegRec8->SetSegmentRecord(CLSID_CWsbGuid, 30, 5, 0, CLSID_CSegRec,0 ));

            WsbAssertHr(GetEntity(HSM_SEG_REC_TYPE, IID_ISegRec, (void**) &pSegRec9));
            WsbAssertHr(pSegRec9->SetSegmentRecord(CLSID_CWsbGuid, 35, 5, 0, CLSID_CSegRec,0 ));

            WsbAssertHr(GetEntity(HSM_SEG_REC_TYPE, IID_ISegRec, (void**) &pSegRec10));
            WsbAssertHr(pSegRec10->SetSegmentRecord(CLSID_CWsbGuid, 40, 5, 0, CLSID_CSegRec,0 ));

            //  Add them in random order
            WsbAssertHr(pColl->Add(pSegRec5));
            WsbAssertHr(pColl->Add(pSegRec4));
            WsbAssertHr(pColl->Add(pSegRec1));
            WsbAssertHr(pColl->Add(pSegRec6));
            WsbAssertHr(pColl->Add(pSegRec7));
            WsbAssertHr(pColl->Add(pSegRec8));
            WsbAssertHr(pColl->Add(pSegRec1));
            WsbAssertHr(pColl->Add(pSegRec2));
            WsbAssertHr(pColl->Add(pSegRec3));
            WsbAssertHr(pColl->Add(pSegRec9));
            WsbAssertHr(pColl->Add(pSegRec3));
            WsbAssertHr(pColl->Add(pSegRec4));
            WsbAssertHr(pColl->Add(pSegRec10));
            WsbAssertHr(pColl->Add(pSegRec5));
            WsbAssertHr(pColl->Add(pSegRec8));
            WsbAssertHr(pColl->Add(pSegRec1));
            WsbAssertHr(pColl->Add(pSegRec5));
            WsbAssertHr(pColl->Add(pSegRec6));
            WsbAssertHr(pColl->Add(pSegRec7));
            WsbAssertHr(pColl->Add(pSegRec1));
            WsbAssertHr(pColl->Add(pSegRec7));
            WsbAssertHr(pColl->Add(pSegRec2));
            WsbAssertHr(pColl->Add(pSegRec7));
            WsbAssertHr(pColl->Add(pSegRec8));
            WsbAssertHr(pColl->Add(pSegRec2));
            WsbAssertHr(pColl->Add(pSegRec8));
            WsbAssertHr(pColl->Add(pSegRec3));
            WsbAssertHr(pColl->Add(pSegRec6));
            WsbAssertHr(pColl->Add(pSegRec3));
            WsbAssertHr(pColl->Add(pSegRec9));
            WsbAssertHr(pColl->Add(pSegRec4));
            WsbAssertHr(pColl->Add(pSegRec6));
            WsbAssertHr(pColl->Add(pSegRec9));
            WsbAssertHr(pColl->Add(pSegRec9));
            WsbAssertHr(pColl->Add(pSegRec10));
            WsbAssertHr(pColl->Add(pSegRec4));
            WsbAssertHr(pColl->Add(pSegRec10));
            WsbAssertHr(pColl->Add(pSegRec5));
            WsbAssertHr(pColl->Add(pSegRec10));
            WsbAssertHr(pColl->Add(pSegRec2));
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        try {
            //  Check that they're sorted
            WsbAssertHr(GetEntity(HSM_SEG_REC_TYPE, IID_ISegRec, (void**) &pSegRec11));
            WsbAssertHr(pSegRec11->First());
            WsbAssertHr(pSegRec11->GetSegmentRecord(&startBagId, &startSegStartLoc, &startSegLen, &startSegType, &startPrimLoc, &startSecLoc));
            lastBagId = startBagId;
            lastStartLoc = startSegStartLoc;
            hr = S_OK;
            for ( ; ; ) {
                hr = pSegRec11->Next();
                if (hr != S_OK) break;
                WsbAssertHr(pSegRec11->GetSegmentRecord(&startBagId, &startSegStartLoc, &startSegLen, &startSegType, &startPrimLoc, &startSecLoc));
                WsbAssert(!IsEqualGUID(lastBagId, startBagId) || 
                        lastStartLoc <= startSegStartLoc, E_FAIL);
                lastBagId = startBagId;
                lastStartLoc = startSegStartLoc;
            }
            WsbAssert(hr == WSB_E_NOTFOUND, E_FAIL);
            hr = S_OK;
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        try {
            // Check that the last one is what we expect
            WsbAssertHr(pSegRec11->Last());
            WsbAssertHr(pSegRec11->CompareToISegmentRecord(pSegRec10, NULL));

            //  Look for a specific record
            WsbAssertHr(pSegRec5->FindEQ());

            //  Check for near misses
            WsbAssertHr(pSegRec11->SetSegmentRecord(CLSID_CWsbGuid, 23, 5, 0, CLSID_CSegRec,0 ));
            WsbAssertHr(pSegRec11->FindGT());
            WsbAssertHr(pSegRec11->CompareToISegmentRecord(pSegRec7, NULL));

            WsbAssertHr(pSegRec11->SetSegmentRecord(CLSID_CWsbGuid, 21, 5, 0, CLSID_CSegRec,0 ));
            WsbAssertHr(pSegRec11->FindLTE());
            WsbAssertHr(pSegRec11->CompareToISegmentRecord(pSegRec6, NULL));
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

        //  Clear the DB so we can shut it down
        hr = S_OK;
        try {
            WsbAssertHr(Erase());
            WsbAssertHr(Close());
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*pTestsPassed)++;
        } else {
            (*pTestsFailed)++;
        }

    } WsbCatch(hr);
#else
    *pTestsPassed = *pTestsFailed = 0;
#endif
    WsbTraceOut(OLESTR("CSegDb::Test"), OLESTR("hr = <%ls>"),WsbHrAsString(hr));

    return(S_OK);
}


HRESULT 
CSegDb::Erase (
    void
    ) 
/*++

Routine Description:

  See ISegDb::Erase

Arguments:

  See ISegDb::Erase

Return Value:
  
    See ISegDb::Erase

--*/
{
    
    HRESULT     hr = E_NOTIMPL;

    WsbTraceIn(OLESTR("CSegDb::Erase"),OLESTR(""));

    try {
        //  To be done?
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CSegDb::Erase"),    OLESTR("hr = <%ls>"),WsbHrAsString(hr));

    return(hr);
}


HRESULT
CSegDb::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    try {
        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CSegDb;
    } WsbCatch(hr);
    
    return(hr);
}


HRESULT
CSegDb::Initialize(
    IN     OLECHAR* root,
    IN     IWsbDbSys* pDbSys, 
    IN OUT BOOL*    pCreateFlag
    )

/*++

Implements:

  ISegDb::Initialize().

--*/
{
    BOOL                CreateFlag = FALSE;
    HRESULT             hr = S_OK;
    CWsbStringPtr       path;

    WsbTraceIn(OLESTR("CSegDb::Initialize"), 
        OLESTR("root = <%ls>, CreateFlag = <%ls>"), 
        WsbAbbreviatePath(root, 120), WsbPtrToBoolAsString(pCreateFlag));

    if (pCreateFlag) {
        CreateFlag = *pCreateFlag;
    }

    try {
        path = root;
        WsbAffirmHr(path.Append(OLESTR("\\SegDb")));

        m_pWsbDbSys = pDbSys;
        WsbAffirmPointer(m_pWsbDbSys);

        hr = Locate(path);

        if (hr == STG_E_FILENOTFOUND && CreateFlag){
            ULONG memSize;

            hr = S_OK;
            m_nRecTypes = 5;

            memSize = m_nRecTypes * sizeof(IDB_REC_INFO);
            m_RecInfo = (IDB_REC_INFO*)WsbAlloc(memSize);
            WsbAffirm(0 != m_RecInfo, E_FAIL);
            ZeroMemory(m_RecInfo, memSize);

            //  Segment records
            m_RecInfo[0].Type = HSM_SEG_REC_TYPE;
            m_RecInfo[0].EntityClassId = CLSID_CSegRec;
            m_RecInfo[0].Flags = 0;
            m_RecInfo[0].MinSize = 2 * WSB_BYTE_SIZE_GUID +
                    3 * WSB_BYTE_SIZE_LONGLONG + WSB_BYTE_SIZE_USHORT;
            m_RecInfo[0].MaxSize = m_RecInfo[0].MinSize;
            m_RecInfo[0].nKeys = 1;

            memSize = m_RecInfo[0].nKeys * sizeof(IDB_KEY_INFO);
            m_RecInfo[0].Key = (IDB_KEY_INFO*)WsbAlloc(memSize);
            WsbAffirm(0 != m_RecInfo[0].Key, E_FAIL);
            ZeroMemory(m_RecInfo[0].Key, memSize);

            m_RecInfo[0].Key[0].Type = SEG_KEY_TYPE;
            m_RecInfo[0].Key[0].Size = WSB_BYTE_SIZE_GUID +
                    WSB_BYTE_SIZE_LONGLONG;
            m_RecInfo[0].Key[0].Flags = IDB_KEY_FLAG_DUP_ALLOWED;

            //  Media information
            m_RecInfo[1].Type = HSM_MEDIA_INFO_REC_TYPE;
            m_RecInfo[1].EntityClassId = CLSID_CMediaInfo;
            m_RecInfo[1].Flags = 0;
            m_RecInfo[1].MinSize = 2 *  (WSB_BYTE_SIZE_GUID +             //Id
                                         WSB_BYTE_SIZE_GUID +             //ntmsId
                                         WSB_BYTE_SIZE_GUID +             //soragePoolId
                                         4                  +             //nme
                                         4                  +             //brCode
                                         WSB_BYTE_SIZE_SHORT+             //tpe
                                         WSB_BYTE_SIZE_FILETIME   +       //lastUpdate
                                         WSB_BYTE_SIZE_LONG       +       //lastError
                                         WSB_BYTE_SIZE_BOOL       +       //m_RecallOnly
                                         WSB_BYTE_SIZE_LONGLONG   +       //m_freeBytes
                                         WSB_BYTE_SIZE_LONGLONG   +       //m_Capacity
                                         WSB_BYTE_SIZE_SHORT)     +       //nextRemoteDataSet
                                   
                                   WSB_BYTE_SIZE_BOOL       +       //m_Recreate
                                   WSB_BYTE_SIZE_LONGLONG   +       //m_LocicalFreeSpace
                                   
                                   3 * (WSB_BYTE_SIZE_GUID  +       //m_RmsMediaId
                                        4                   +       //m_Name
                                        4                   +       //m_BarCode
                                        WSB_BYTE_SIZE_FILETIME +    //m_Update
                                        WSB_BYTE_SIZE_LONG  +       //m_LastError
                                        WSB_BYTE_SIZE_SHORT );      //nextRemoteDataSet

            // NOTE:
            //
            //  The next line that calculates the max record size for media info has a BAD bug in it - Windows Bugs 407340.
            //  The macro SEG_DB_MAX_MEDIA_NAME_LEN and SEG_DB_MAX_MEDIA_BAR_CODE_LEN are defined without parenthesis - see in segdb.h
            //  As a result, the max size is only 711 bytes instead of 1751 as it should be !!
            //
            //  It is NOT fixed since there are too many existing installations with the wrong record size...
            //  This bug has implications around the code - look for "Windows Bugs 407340" comments throughout the HSM code
            //
            m_RecInfo[1].MaxSize = m_RecInfo[1].MinSize + 5 * SEG_DB_MAX_MEDIA_NAME_LEN + 5 * SEG_DB_MAX_MEDIA_BAR_CODE_LEN;
            m_RecInfo[1].nKeys = 1;

            memSize = m_RecInfo[1].nKeys * sizeof(IDB_KEY_INFO);
            m_RecInfo[1].Key = (IDB_KEY_INFO*)WsbAlloc(memSize);
            WsbAffirm(0 != m_RecInfo[1].Key, E_FAIL);
            ZeroMemory(m_RecInfo[1].Key, memSize);

            m_RecInfo[1].Key[0].Type = MEDIA_INFO_KEY_TYPE;
            m_RecInfo[1].Key[0].Size = WSB_BYTE_SIZE_GUID;
            m_RecInfo[1].Key[0].Flags = IDB_KEY_FLAG_PRIMARY;

            //  Bag information
            m_RecInfo[2].Type = HSM_BAG_INFO_REC_TYPE;
            m_RecInfo[2].EntityClassId = CLSID_CBagInfo;
            m_RecInfo[2].Flags = 0;
            m_RecInfo[2].MinSize = (2 * WSB_BYTE_SIZE_GUID) +
                    (2 * WSB_BYTE_SIZE_LONGLONG) + (2 * WSB_BYTE_SIZE_USHORT) +
                    WSB_BYTE_SIZE_FILETIME + WSB_BYTE_SIZE_SHORT;
            m_RecInfo[2].MaxSize = m_RecInfo[2].MinSize;
            m_RecInfo[2].nKeys = 1;

            memSize = m_RecInfo[2].nKeys * sizeof(IDB_KEY_INFO);
            m_RecInfo[2].Key = (IDB_KEY_INFO*)WsbAlloc(memSize);
            WsbAffirm(0 != m_RecInfo[2].Key, E_FAIL);
            ZeroMemory(m_RecInfo[2].Key, memSize);

            m_RecInfo[2].Key[0].Type = BAG_INFO_KEY_TYPE;
            m_RecInfo[2].Key[0].Size = WSB_BYTE_SIZE_GUID;
            m_RecInfo[2].Key[0].Flags = IDB_KEY_FLAG_PRIMARY;

            //  Bag holes
            m_RecInfo[3].Type = HSM_BAG_HOLE_REC_TYPE;
            m_RecInfo[3].EntityClassId = CLSID_CBagHole;
            m_RecInfo[3].Flags = 0;
            m_RecInfo[3].MinSize = WSB_BYTE_SIZE_GUID +
                    2 * WSB_BYTE_SIZE_LONGLONG;
            m_RecInfo[3].MaxSize = m_RecInfo[3].MinSize;
            m_RecInfo[3].nKeys = 1;

            memSize = m_RecInfo[3].nKeys * sizeof(IDB_KEY_INFO);
            m_RecInfo[3].Key = (IDB_KEY_INFO*)WsbAlloc(memSize);
            WsbAffirm(0 != m_RecInfo[3].Key, E_FAIL);
            ZeroMemory(m_RecInfo[3].Key, memSize);

            m_RecInfo[3].Key[0].Type = BAG_HOLE_KEY_TYPE;
            m_RecInfo[3].Key[0].Size = WSB_BYTE_SIZE_GUID +
                    WSB_BYTE_SIZE_LONGLONG;
            m_RecInfo[3].Key[0].Flags = IDB_KEY_FLAG_DUP_ALLOWED;

            //  Volume assignment
            m_RecInfo[4].Type = HSM_VOL_ASSIGN_REC_TYPE;
            m_RecInfo[4].EntityClassId = CLSID_CVolAssign;
            m_RecInfo[4].Flags = 0;
            m_RecInfo[4].MinSize = 2 * WSB_BYTE_SIZE_GUID +
                    2 * WSB_BYTE_SIZE_LONGLONG;
            m_RecInfo[4].MaxSize = m_RecInfo[4].MinSize;
            m_RecInfo[4].nKeys = 1;

            memSize = m_RecInfo[4].nKeys * sizeof(IDB_KEY_INFO);
            m_RecInfo[4].Key = (IDB_KEY_INFO*)WsbAlloc(memSize);
            WsbAffirm(0 != m_RecInfo[4].Key, E_FAIL);
            ZeroMemory(m_RecInfo[4].Key, memSize);

            m_RecInfo[4].Key[0].Type = VOL_ASSIGN_KEY_TYPE;
            m_RecInfo[4].Key[0].Size = WSB_BYTE_SIZE_GUID +
                    WSB_BYTE_SIZE_LONGLONG;
            m_RecInfo[4].Key[0].Flags = IDB_KEY_FLAG_DUP_ALLOWED;

            //  Create the new DB
            WsbAssertHr(Create(path));
            CreateFlag = TRUE;

        } else if (hr == STG_E_FILENOTFOUND) {

            // DB doesn't exist, but we're not suppose to create it
            WsbLogEvent(WSB_MESSAGE_IDB_OPEN_FAILED, 0, NULL, 
                    WsbQuickString(WsbAbbreviatePath(path, 120)), NULL );
            hr = WSB_E_IDB_FILE_NOT_FOUND;
        }
    } WsbCatch(hr);

    if (pCreateFlag) {
        *pCreateFlag = CreateFlag;
    }

    WsbTraceOut(OLESTR("CSegDb::Initialize"), 
        OLESTR("hr = %ls, path = <%ls>, CreateFlag = <%ls>"), 
        WsbHrAsString(hr), WsbAbbreviatePath(path, 120), 
        WsbPtrToBoolAsString(pCreateFlag));

    return(hr);
}


HRESULT
CSegDb::Load(
    IN IStream* pStream
    )

/*++

Implements:

  IPersistStream::Load().

--*/
{
    HRESULT             hr = S_OK;

    try {
        WsbAffirmHr(CWsbDb::Load(pStream));
    } WsbCatch(hr);

    return(hr);
}


HRESULT
CSegDb::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )

/*++

Implements:

  IPersistStream::Save().

--*/
{
    HRESULT             hr = S_OK;

    try {
        WsbAffirmHr(CWsbDb::Save(pStream, clearDirty));
    } WsbCatch(hr);

    return(hr);
}


HRESULT 
CSegDb::SegAdd
(
    IN IWsbDbSession* pDbSession,
    IN GUID BagId, 
    IN LONGLONG SegStartLoc, 
    IN LONGLONG SegLen,
    IN GUID MediaId,
    IN LONGLONG mediaStart,
    IN BOOL indirectRecord
    )
 /*++

Implements:

  ISegDb::SegAdd

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CSegDb::SegAdd"), 
        OLESTR("GUID = %ls, SegStartLoc = %I64u, SegLen = %I64u"), 
        WsbGuidAsString(BagId), SegStartLoc, SegLen);

    try {
        BOOL                    found = FALSE;
        CComPtr<ISegRec>        pSegRec;    
        GUID                    l_BagId = GUID_NULL;
        LONGLONG                l_SegStartLoc = 0;
        LONGLONG                l_SegLen = 0;
        USHORT                  l_SegFlags = SEG_REC_NONE;
        GUID                    l_MediaId = GUID_NULL;
        LONGLONG                l_MediaStart = 0;

        WsbAffirmHr(GetEntity(pDbSession, HSM_SEG_REC_TYPE, IID_ISegRec,
                                                    (void **)&pSegRec));
        WsbAffirmHr(pSegRec->SetSegmentRecord(BagId, SegStartLoc, 
                            0, 0, GUID_NULL, 0 ));

        //  Look for a segment to which to append this one
        hr = pSegRec->FindLTE();
        if (WSB_E_NOTFOUND == hr) {
            hr = S_OK;
        } else {
            WsbAffirmHr(pSegRec->GetSegmentRecord(&l_BagId, &l_SegStartLoc, &l_SegLen, &l_SegFlags, 
                            &l_MediaId, &l_MediaStart));
            if (SEG_EXPAND_OK(l_BagId, l_SegStartLoc,  l_SegLen,
                    BagId, SegStartLoc, SegLen) &&
                    IsEqualGUID(MediaId, l_MediaId)) {
                WsbTrace(OLESTR("CSegDb::SegAdd: Found SegmentRecord: StartLoc = %I64u, Len = %I64u\n"),
                        l_SegStartLoc, l_SegLen);
                found = TRUE;
            }
        }

        if (found) {
            //  Append this segment to the existing record
            l_SegLen = (SegStartLoc - l_SegStartLoc) + SegLen;
            WsbTrace(OLESTR("CSegDb::SegAdd: new SegLen = %I64u\n"), l_SegLen);
        } else {
            //  Create a new segment record
            l_SegStartLoc = SegStartLoc;
            l_SegLen = SegLen;
            if (indirectRecord) {
                l_SegFlags = SEG_REC_INDIRECT_RECORD;
            } else {
                l_SegFlags = SEG_REC_NONE;
            }
            l_MediaId = MediaId;
            l_MediaStart = mediaStart;
            WsbAffirmHr(pSegRec->MarkAsNew());
            WsbTrace(OLESTR("CSegDb::SegAdd: add new segment\n"));
        }
        WsbAffirmHr(pSegRec->SetSegmentRecord(BagId, l_SegStartLoc, 
                l_SegLen, l_SegFlags, l_MediaId, l_MediaStart ));

        WsbAffirmHr(pSegRec->Write());

    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CSegDb::SegAdd"), OLESTR("hr = <%ls>"),WsbHrAsString(S_OK));
    return(hr);
}


HRESULT 
CSegDb::SegFind
(
    IN IWsbDbSession* pDbSession,
    IN GUID BagId, 
    IN LONGLONG SegStartLoc, 
    IN LONGLONG SegLen,
    OUT ISegRec** ppISegRec
    )
 /*++

Implements:

  ISegDb::SegFind

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CSegDb::SegFind"), 
        OLESTR("GUID = <%ls>, SegStartLoc = <%I64u>, SegLen = <%I64u>"), 
        WsbGuidAsString(BagId), 
        SegStartLoc, 
        SegLen);

    try {
        CComPtr<ISegRec>        pSegRec;    
        GUID                    l_BagId;
        LONGLONG                l_SegStartLoc;
        LONGLONG                l_SegLen;
        USHORT                  l_SegFlags;
        GUID                    l_MediaId;
        LONGLONG                l_MediaStart;

        WsbAffirm(ppISegRec != NULL, E_POINTER);
        WsbAffirmHr(GetEntity(pDbSession, HSM_SEG_REC_TYPE, IID_ISegRec,
                (void **)&pSegRec));
        WsbAffirmHr(pSegRec->SetSegmentRecord(BagId, SegStartLoc, 
                0, 0, GUID_NULL, 0 ));

        //  Look for a segment that contains this one
        WsbTrace(OLESTR("Finding SegmentRecord: <%ls>, <%I64u>, <%I64u>\n"),
                WsbGuidAsString(BagId), 
                SegStartLoc,
                SegLen);
        WsbAffirmHr(pSegRec->FindLTE());

        //  We found a record, see if it's the right one
        WsbAffirmHr(pSegRec->GetSegmentRecord(&l_BagId, &l_SegStartLoc, 
                &l_SegLen, &l_SegFlags, &l_MediaId, &l_MediaStart));
        if (SEG_CONTAINS(l_BagId, l_SegStartLoc, l_SegLen,
                BagId, SegStartLoc, SegLen)) {
            *ppISegRec = pSegRec;
            pSegRec.p->AddRef();
        } else {
            hr = WSB_E_NOTFOUND;
        }

    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CSegDb::SegFind"), OLESTR("hr = <%ls>"),WsbHrAsString(S_OK));
    return(hr);
}


HRESULT 
CSegDb::SegSubtract
(
    IN IWsbDbSession* pDbSession,
    IN GUID BagId, 
    IN LONGLONG SegStartLoc, 
    IN LONGLONG SegLen
    )
 /*++

Implements:

  ISegDb::SegSubtract

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CSegDb::SegSubtract"), 
        OLESTR("GUID = <%ls>, SegStartLoc = <%I64u>, SegLen = <%I64u>"), 
        WsbGuidAsString(BagId), 
        SegStartLoc, 
        SegLen);

    try {
        GUID                    l_BagId;
        LONGLONG                l_SegStartLoc;
        LONGLONG                l_SegLen;
        USHORT                  l_SegFlags;
        GUID                    l_MediaId;
        LONGLONG                l_MediaStart;
        CComPtr<ISegRec>        pSegRec;    

        //  Find the segment record
        WsbAffirmHr(SegFind(pDbSession, BagId, SegStartLoc, SegLen, &pSegRec));

        //  Get the current data
        WsbAffirmHr(pSegRec->GetSegmentRecord(&l_BagId, &l_SegStartLoc, 
                &l_SegLen, &l_SegFlags, &l_MediaId, &l_MediaStart));

        //  Determine where the hole is
        if (l_SegStartLoc == SegStartLoc && l_SegLen == SegLen) {
            //  Hole is the entire segment -- delete it
            WsbAffirmHr(pSegRec->Remove());

        } else if (l_SegStartLoc == SegStartLoc) {
            //  Hole is at the beginning of the segment.  Just update the
            //  existing segment
            l_SegStartLoc += SegLen;
            l_MediaStart += SegLen;
            WsbAffirmHr(pSegRec->SetSegmentRecord(BagId, l_SegStartLoc, 
                    l_SegLen, l_SegFlags, l_MediaId, l_MediaStart ));
            WsbAffirmHr(pSegRec->Write());

        } else if ((l_SegStartLoc + l_SegLen) == (SegStartLoc + SegLen)) {
            //  Hole is at the end of the segment.  Just update the
            //  existing segment
            l_SegLen -= SegLen;
            WsbAffirmHr(pSegRec->SetSegmentRecord(BagId, l_SegStartLoc, 
                    l_SegLen, l_SegFlags, l_MediaId, l_MediaStart ));
            WsbAffirmHr(pSegRec->Write());

        } else {
            //  Hole is in the middle of the segment.  Update the
            //  existing record to be the first part.
            LONGLONG    oldLen = l_SegLen;
            LONGLONG    offset = (SegStartLoc + SegLen) - l_SegStartLoc;
            BOOL        bIndirect = FALSE;

            l_SegLen = SegStartLoc - l_SegStartLoc;
            WsbAffirmHr(pSegRec->SetSegmentRecord(BagId, l_SegStartLoc, 
                    l_SegLen, l_SegFlags, l_MediaId, l_MediaStart ));
            WsbAffirmHr(pSegRec->Write());

            //  Create a new record for the second part.
            l_SegLen -= offset;
            l_SegStartLoc += offset;
            l_MediaStart += offset;
            if (l_SegFlags & SEG_REC_INDIRECT_RECORD) {
                bIndirect = TRUE;
            }
            WsbAffirmHr(SegAdd(pDbSession, BagId, l_SegStartLoc, l_SegLen, l_MediaId,
                    l_MediaStart, bIndirect));
        }

    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CSegDb::SegSubtract"), OLESTR("hr = <%ls>"),WsbHrAsString(S_OK));
    return(hr);
}


HRESULT 
CSegDb::VolAssignAdd
(
    IN IWsbDbSession* pDbSession,
    IN GUID BagId, 
    IN LONGLONG SegStartLoc, 
    IN LONGLONG SegLen,
    IN GUID VolId
    )
 /*++

Implements:

  ISegDb::VolAssignAdd

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CSegDb::VolAssignAdd"), 
        OLESTR("GUID = <%ls>, SegStartLoc = <%I64u>, SegLen = <%I64u>"), 
        WsbGuidAsString(BagId), 
        SegStartLoc, 
        SegLen);

    try {
        BOOL                    found = FALSE;
        CComPtr<IVolAssign>     pVolAssign;    
        GUID                    l_BagId = GUID_NULL;
        LONGLONG                l_SegStartLoc = 0;
        LONGLONG                l_SegLen = 0;
        GUID                    l_VolId = GUID_NULL;

        WsbAffirmHr(GetEntity(pDbSession, HSM_VOL_ASSIGN_REC_TYPE, IID_IVolAssign,
                (void **)&pVolAssign));
        WsbAffirmHr(pVolAssign->SetVolAssign(BagId, SegStartLoc, 
                0, GUID_NULL));

        //  Look for a segment to which to append this one
        WsbTrace(OLESTR("Finding VolAssign Record: <%ls>, <%I64u>, <%I64u>\n"),
                WsbGuidAsString(BagId), 
                SegStartLoc,
                SegLen);
        hr = pVolAssign->FindLTE();
        if (WSB_E_NOTFOUND == hr) {
            hr = S_OK;
        } else {
            WsbAffirmHr(pVolAssign->GetVolAssign(&l_BagId, &l_SegStartLoc, 
                    &l_SegLen, &l_VolId));
            if (SEG_APPEND_OK(l_BagId, l_SegStartLoc,  l_SegLen,
                    BagId, SegStartLoc, SegLen) && IsEqualGUID(l_VolId, VolId)) {
                found = TRUE;
            }
        }

        if (found) {
            //  Append this segment to the existing record
            l_SegLen += SegLen;
        } else {
            //  Create a new record
            l_SegStartLoc = SegStartLoc;
            l_SegLen = SegLen;
            l_VolId = VolId;
            WsbAffirmHr(pVolAssign->MarkAsNew());
        }
        WsbAffirmHr(pVolAssign->SetVolAssign(BagId, l_SegStartLoc, 
                l_SegLen, l_VolId));

        WsbTrace(OLESTR("Writing VolAssign Record: <%ls>, <%I64u>, <%I64u>\n"),
                    WsbGuidAsString(BagId), 
                    l_SegStartLoc,
                    l_SegLen);
        WsbAffirmHr(pVolAssign->Write());

    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CSegDb::VolAssignAdd"), OLESTR("hr = <%ls>"),WsbHrAsString(S_OK));
    return(hr);
}


HRESULT 
CSegDb::VolAssignFind
(
    IN IWsbDbSession* pDbSession,
    IN GUID BagId, 
    IN LONGLONG SegStartLoc, 
    IN LONGLONG SegLen,
    OUT IVolAssign** ppIVolAssign
    )
 /*++

Implements:

  ISegDb::VolAssignFind

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CSegDb::VolAssignFind"), 
        OLESTR("GUID = <%ls>, SegStartLoc = <%I64u>, SegLen = <%I64u>"), 
        WsbGuidAsString(BagId), 
        SegStartLoc, 
        SegLen);

    try {
        CComPtr<IVolAssign>     pVolAssign;    
        GUID                    l_BagId;
        LONGLONG                l_SegStartLoc;
        LONGLONG                l_SegLen;
        GUID                    l_VolId;

        WsbAffirm(ppIVolAssign != NULL, E_POINTER);
        WsbAffirmHr(GetEntity(pDbSession, HSM_VOL_ASSIGN_REC_TYPE, IID_IVolAssign,
                (void **)&pVolAssign));
        WsbAffirmHr(pVolAssign->SetVolAssign(BagId, SegStartLoc, 0, GUID_NULL));

        //  Look for a segment that contains this one
        WsbTrace(OLESTR("Finding VolAssign Record: <%ls>, <%I64u>, <%I64u>\n"),
                WsbGuidAsString(BagId), 
                SegStartLoc,
                SegLen);
        WsbAffirmHr(pVolAssign->FindLTE());

        //  We found a record, see if it's the right one
        WsbAffirmHr(pVolAssign->GetVolAssign(&l_BagId, &l_SegStartLoc, 
                &l_SegLen, &l_VolId));
        if (SEG_CONTAINS(l_BagId, l_SegStartLoc, l_SegLen,
                BagId, SegStartLoc, SegLen)) {
            *ppIVolAssign = pVolAssign;
            pVolAssign.p->AddRef();
        } else {
            hr = WSB_E_NOTFOUND;
        }

    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CSegDb::VolAssignFind"), OLESTR("hr = <%ls>"),WsbHrAsString(S_OK));
    return(hr);
}


HRESULT 
CSegDb::VolAssignSubtract
(
    IN IWsbDbSession* pDbSession,
    IN GUID BagId, 
    IN LONGLONG SegStartLoc, 
    IN LONGLONG SegLen
    )
 /*++

Implements:

  ISegDb::VolAssignSubtract

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CSegDb::VolAssignSubtract"), 
        OLESTR("GUID = <%ls>, SegStartLoc = <%I64u>, SegLen = <%I64u>"), 
        WsbGuidAsString(BagId), 
        SegStartLoc, 
        SegLen);

    try {
        GUID                    l_BagId;
        LONGLONG                l_SegStartLoc;
        LONGLONG                l_SegLen;
        GUID                    l_VolId;
        CComPtr<IVolAssign>     pVolAssign;    

        //  Find the segment record
        WsbAffirmHr(VolAssignFind(pDbSession, BagId, SegStartLoc, SegLen, &pVolAssign));

        //  Get the current data
        WsbAffirmHr(pVolAssign->GetVolAssign(&l_BagId, &l_SegStartLoc, 
                &l_SegLen, &l_VolId));

        //  Determine where the hole is
        if (l_SegStartLoc == SegStartLoc && l_SegLen == SegLen) {
            //  Hole is the entire segment -- delete it
            WsbAffirmHr(pVolAssign->Remove());

        } else if (l_SegStartLoc == SegStartLoc) {
            //  Hole is at the beginning of the segment.  Just update the
            //  existing segment
            l_SegStartLoc += SegLen;
            WsbAffirmHr(pVolAssign->SetVolAssign(BagId, l_SegStartLoc, 
                    l_SegLen, l_VolId));
            WsbAffirmHr(pVolAssign->Write());

        } else if ((l_SegStartLoc + l_SegLen) == (SegStartLoc + SegLen)) {
            //  Hole is at the end of the segment.  Just update the
            //  existing segment
            l_SegLen -= SegLen;
            WsbAffirmHr(pVolAssign->SetVolAssign(BagId, l_SegStartLoc, 
                    l_SegLen, l_VolId));
            WsbAffirmHr(pVolAssign->Write());

        } else {
            //  Hole is in the middle of the segment.  Update the
            //  existing record to be the first part.
            LONGLONG    oldLen = l_SegLen;
            LONGLONG    offset = (SegStartLoc + SegLen) - l_SegStartLoc;

            l_SegLen = SegStartLoc - l_SegStartLoc;
            WsbAffirmHr(pVolAssign->SetVolAssign(BagId, l_SegStartLoc, 
                    l_SegLen, l_VolId));
            WsbAffirmHr(pVolAssign->Write());

            //  Create a new record for the second part.
            l_SegLen -= offset;
            l_SegStartLoc += offset;
            WsbAffirmHr(VolAssignAdd(pDbSession, BagId, l_SegStartLoc, l_SegLen,
                    l_VolId));
        }

    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CSegDb::VolAssignSubtract"), OLESTR("hr = <%ls>"),WsbHrAsString(S_OK));
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\engine\task\segrec.h ===
// SegRec.h : Declaration of the CSegRec


#include "resource.h"       // main symbols
#include "Wsb.h"            // Wsb Collectable Class
#include "wsbdb.h"


/////////////////////////////////////////////////////////////////////////////
// seg

class CSegRec : 
    public CWsbDbEntity,
    public ISegRec,
    public CComCoClass<CSegRec,&CLSID_CSegRec>
{
public:
    CSegRec() {}
BEGIN_COM_MAP(CSegRec)
    COM_INTERFACE_ENTRY(ISegRec)
    COM_INTERFACE_ENTRY2(IWsbDbEntity, CWsbDbEntity)
    COM_INTERFACE_ENTRY(IWsbDbEntityPriv)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY(CSegRec, _T("Seg.SegRec.1"), _T("Seg.SegRec"), IDS_SEGREC_DESC, THREADFLAGS_BOTH)

// ISegRec
public:
    STDMETHOD(FinalConstruct)(void);
    void FinalRelease(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbTestable
public:
    STDMETHOD(Test)(USHORT *pTestsPassed, USHORT* pTestsFailed);

// IWsbDbEntity
public:
    STDMETHOD(Print)(IStream* pStream);
    STDMETHOD(UpdateKey)(IWsbDbKey *pKey);
    WSB_FROM_CWSBDBENTITY;

// ISegmentRecord
public:
    STDMETHOD(GetSegmentRecord)(GUID* pBagId, LONGLONG *pSegStartLoc, LONGLONG *pSegLen, USHORT *pSegFlags, GUID *pPrimPos, LONGLONG *pSecPos );
    STDMETHOD(SetSegmentRecord)(GUID bagId, LONGLONG segStartLoc, LONGLONG SegLen, USHORT SegFlags, GUID PrimPos, LONGLONG SecPos );
    STDMETHOD(Split)(GUID bagId, LONGLONG segStartLoc, LONGLONG segLen, ISegRec* pSegRec1, ISegRec* pSegRec2);
    STDMETHOD(GetSegmentFlags)(USHORT *pSegFlags);
    STDMETHOD(SetSegmentFlags)(USHORT SegFlags);
    STDMETHOD(GetPrimPos)(GUID* pPrimPos);
    STDMETHOD(SetPrimPos)(GUID PrimPos);
    STDMETHOD(GetSecPos)(LONGLONG *pSecPos);
    STDMETHOD(SetSecPos)(LONGLONG SecPos);

private:
    GUID            m_BagId;
    LONGLONG        m_SegStartLoc;
    LONGLONG        m_SegLen;
    USHORT          m_SegFlags;
    GUID            m_PrimPos;
    LONGLONG        m_SecPos;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\engine\task\task.cpp ===
// task.cpp : Implementation of DLL Exports.

// You will need the NT SUR Beta 2 SDK or VC 4.2 in order to build this 
// project.  This is because you will need MIDL 3.00.15 or higher and new
// headers and libs.  If you have VC 4.2 installed, then everything should
// already be configured correctly.

// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f taskps.mak in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"

#include "wsb.h"
#include "engine.h"
#include "Task.h"
#include "TskMgr.h"
#include "metaint.h"
#include "metalib.h"
#include "segrec.h"
#include "segdb.h"
#include "baghole.h"
#include "bagInfo.h"
#include "medInfo.h"
#include "VolAsgn.h"
#include "hsmworkq.h"
#include "hsmworki.h"
#include "hsmreclq.h"
#include "hsmrecli.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_CHsmTskMgr, CHsmTskMgr)
    OBJECT_ENTRY(CLSID_CHsmWorkQueue, CHsmWorkQueue)
    OBJECT_ENTRY(CLSID_CHsmWorkItem, CHsmWorkItem)
    OBJECT_ENTRY(CLSID_CHsmRecallQueue, CHsmRecallQueue)
    OBJECT_ENTRY(CLSID_CHsmRecallItem, CHsmRecallItem)
    OBJECT_ENTRY(CLSID_CSegRec, CSegRec)
    OBJECT_ENTRY(CLSID_CBagHole, CBagHole)
    OBJECT_ENTRY(CLSID_CBagInfo, CBagInfo)
    OBJECT_ENTRY(CLSID_CMediaInfo, CMediaInfo)
    OBJECT_ENTRY(CLSID_CVolAssign, CVolAssign)
    OBJECT_ENTRY(CLSID_CSegDb, CSegDb)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    HRESULT hr;
    // registers object
    hr = CoInitialize( 0 );
    if (SUCCEEDED(hr)) { 
      hr = _Module.RegisterServer( FALSE );
      CoUninitialize( );
    }
    return( hr );
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    HRESULT hr;

    hr = CoInitialize(0);

    if (SUCCEEDED(hr)) {
        _Module.UnregisterServer();
        CoUninitialize( );
        hr = S_OK;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\engine\task\tskmgr.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

	 tskmgr.cpp

Abstract:

	 This class represents the HSM task manager

Author:

	 Cat Brant   [cbrant]   6-Dec-1996

Revision History:

     Incorporate demand recall queue support
     - Ravisankar Pudipeddi [ravisp]  1-Oct-199
    

--*/

#include "stdafx.h"

#define WSB_TRACE_IS        WSB_TRACE_BIT_HSMTSKMGR

#include "wsb.h"
#include "hsmconn.h"
#include "hsmeng.h"

#include "fsa.h"
#include "task.h"
#include "tskmgr.h"
#include "hsmWorkQ.h"
#include "engine.h"

#define MAX_WORK_QUEUE_TYPES       7


HRESULT
CHsmTskMgr::FinalConstruct(
								  void
								  )
/*++

Routine Description:

  This method does some initialization of the object that is necessary
  after construction.

Arguments:

  None.

Return Value:

  S_OK
  Anything returned by CWsbCollectable::FinalConstruct().

--*/
{
	HRESULT     hr = S_OK;

	WsbTraceIn(OLESTR("CHsmTskMgr::FinalConstruct"),OLESTR(""));
	try {
        m_bCritSecCreated = FALSE;

		int index = 0;

		WsbAssertHr(CComObjectRoot::FinalConstruct());
		m_pWorkQueues = 0;
		m_NumWorkQueues = 0;

		// Set up queue type info and set limits
		m_nWorkQueueTypes = 0;
		m_pWorkQueueTypeInfo = static_cast<PHSM_WORK_QUEUE_TYPE_INFO>
									  (WsbAlloc(MAX_WORK_QUEUE_TYPES *
													sizeof(HSM_WORK_QUEUE_TYPE_INFO)));
		WsbAffirmPointer(m_pWorkQueueTypeInfo);

		// Migrate queues
		WsbAffirm(index < MAX_WORK_QUEUE_TYPES, WSB_E_INVALID_DATA);
		m_pWorkQueueTypeInfo[index].Type = HSM_WORK_TYPE_FSA_MIGRATE;
		m_pWorkQueueTypeInfo[index].MaxActiveAllowed = 1;	 // For Migrate, this is useless now
																			 // - the limit is dynamically set
		m_pWorkQueueTypeInfo[index].NumActive = 0;
		index++;

		// Recall queues
		WsbAffirm(index < MAX_WORK_QUEUE_TYPES, WSB_E_INVALID_DATA);
		m_pWorkQueueTypeInfo[index].Type = HSM_WORK_TYPE_FSA_RECALL;
		m_pWorkQueueTypeInfo[index].MaxActiveAllowed = 1;
		m_pWorkQueueTypeInfo[index].NumActive = 0;
		index++;

		// Demand Recall queues
		WsbAffirm(index < MAX_WORK_QUEUE_TYPES, WSB_E_INVALID_DATA);
		m_pWorkQueueTypeInfo[index].Type = HSM_WORK_TYPE_FSA_DEMAND_RECALL;
		//
		// MaxActiveAllowed is irrelevant for demand recall queues
		// as it is computed afresh
		//
		m_pWorkQueueTypeInfo[index].MaxActiveAllowed = 1;
		m_pWorkQueueTypeInfo[index].NumActive = 0;
		index++;

		// Validate queues
		WsbAffirm(index < MAX_WORK_QUEUE_TYPES, WSB_E_INVALID_DATA);
		m_pWorkQueueTypeInfo[index].Type = HSM_WORK_TYPE_FSA_VALIDATE;
		m_pWorkQueueTypeInfo[index].MaxActiveAllowed = 2;
		m_pWorkQueueTypeInfo[index].NumActive = 0;
		index++;


		// Validate_for_truncate queues.  MaxActiveAllowed is essentially
		// unlimited because this is the type of queue that the FSA's
		// auto-truncator creates. Because there is one queue for each managed
		// volume and these queues never go away, we can't limit the number
		// or we will create problems.  The Truncate job also
		// creates this type of queue which means that type of job is not
		// limited by this mechanism, but that's the way it goes.
		WsbAffirm(index < MAX_WORK_QUEUE_TYPES, WSB_E_INVALID_DATA);
		m_pWorkQueueTypeInfo[index].Type = HSM_WORK_TYPE_FSA_VALIDATE_FOR_TRUNCATE;
		m_pWorkQueueTypeInfo[index].MaxActiveAllowed = 99999;
		m_pWorkQueueTypeInfo[index].NumActive = 0;
		index++;

		m_nWorkQueueTypes = index;

	}WsbCatch(hr);

	WsbTraceOut(OLESTR("CHsmTskMgr::FinalConstruct"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
	return(hr);
}


HRESULT
CHsmTskMgr::FinalRelease(
								void
								)
/*++

Routine Description:

  This method does some clean up of the object that is necessary
  before destruction.

Arguments:

  None.

Return Value:

  S_OK
  Anything returned by CWsbCollection::FinalRelease().

--*/
{
	HRESULT     hr = S_OK;
	HSM_SYSTEM_STATE SysState;

	WsbTraceIn(OLESTR("CHsmTskMgr::FinalRelease"),OLESTR(""));

	SysState.State = HSM_STATE_SHUTDOWN;
	ChangeSysState(&SysState);

	CComObjectRoot::FinalRelease();

	// Free member resources
	if (0 != m_pWorkQueues) {
		WsbFree(m_pWorkQueues);
		m_pWorkQueues = NULL;
	}
	if (m_pWorkQueueTypeInfo) {
		WsbFree(m_pWorkQueueTypeInfo);
		m_pWorkQueueTypeInfo = NULL;
	}
	m_nWorkQueueTypes = 0;

    if (m_bCritSecCreated) {
	    DeleteCriticalSection(&m_WorkQueueLock);
	    DeleteCriticalSection(&m_CurrentRunningLock);
	    DeleteCriticalSection(&m_CreateWorkQueueLock);
    }

	WsbTraceOut(OLESTR("CHsmTskMgr::FinalRelease"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
	return(hr);
}

HRESULT
CHsmTskMgr::Init(
					 IUnknown *pServer
					 )
/*++
Routine Description:

  This method does some initialization of the object that is necessary
  after construction.

Arguments:

  None.

Return Value:

  S_OK
--*/
{
	HRESULT     hr = S_OK;

	WsbTraceIn(OLESTR("CHsmTskMgr::Init"),OLESTR(""));
	try {
		// Initialize critical sections
		WsbAffirmStatus(InitializeCriticalSectionAndSpinCount (&m_WorkQueueLock, 1000));
        if (! InitializeCriticalSectionAndSpinCount (&m_CurrentRunningLock, 1000)) {
            DWORD dwErr = GetLastError();               
            hr = HRESULT_FROM_WIN32(dwErr);    
            DeleteCriticalSection(&m_WorkQueueLock);
            WsbAffirmHr(hr);             
        }
        if (! InitializeCriticalSectionAndSpinCount (&m_CreateWorkQueueLock, 1000)) {
            DWORD dwErr = GetLastError();               
            hr = HRESULT_FROM_WIN32(dwErr);    
            DeleteCriticalSection(&m_WorkQueueLock);
            DeleteCriticalSection(&m_CurrentRunningLock);
            WsbAffirmHr(hr);             
        }
        m_bCritSecCreated = TRUE;

		//
		// Get the server interface
		//
		WsbAffirmHr(pServer->QueryInterface(IID_IHsmServer, (void **)&m_pServer));
		//We want a weak link to the server so decrement the reference count
		m_pServer->Release();
		WsbAffirmHr(m_pServer->QueryInterface(IID_IWsbCreateLocalObject, (void **)&m_pHsmServerCreate));
		// We want a weak link to the server so decrement the reference count
		m_pHsmServerCreate->Release();

		// Go ahead and preallocate some space for the work queues
		WsbAffirmHr(IncreaseWorkQueueArraySize(HsmWorkQueueArrayBumpSize));

	}WsbCatch( hr );

	WsbTraceOut(OLESTR("CHsmTskMgr::Init"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
	return( hr );

}

HRESULT
CHsmTskMgr::ContactOk(
							void
							)
/*++
Routine Description:

  This allows the caller to see if the RPC connection
  to the task manager is OK

Arguments:

  None.

Return Value:

  S_OK
--*/
{

	return( S_OK );

}

HRESULT
CHsmTskMgr::DoFsaWork(
							IFsaPostIt *pFsaWorkItem
							)
/*++

Implements:

  IHsmFsaTskMgr::DoFsaWork

--*/
{
	HRESULT                     hr = S_OK;
	CComPtr<IHsmSession>        pSession;
	CComPtr<IHsmWorkQueue>      pWorkQueue;
	CComPtr<IHsmRecallQueue>    pRecallQueue;
	FSA_REQUEST_ACTION          workAction;
	GUID                        mediaId;
    LONGLONG                    dataSetStart;


	WsbTraceIn(OLESTR("CHsmTskMgr::DoFsaWork"),OLESTR(""));
	try {
		CWsbStringPtr       path;
		LONGLONG            fileVersionId;
		FSA_PLACEHOLDER     placeholder;
		GUID                hsmId, bagId;
		BOOL                bCreated;

		// Get the version Id from the work Item.
		WsbAffirmHr(pFsaWorkItem->GetFileVersionId(&fileVersionId));

		// Get the placeholder from the work item
		WsbAffirmHr(pFsaWorkItem->GetPlaceholder(&placeholder));

		// Get the HSM ID from the server
		WsbAffirmHr(m_pServer->GetID(&hsmId));

		//
		// Make sure this instance of the engine managed the file
		//
		if ((GUID_NULL != placeholder.hsmId) && (hsmId != placeholder.hsmId)) {
			CWsbStringPtr           path;

			(void)pFsaWorkItem->GetPath(&path, 0);
			hr = HSM_E_FILE_MANAGED_BY_DIFFERENT_HSM;
			WsbLogEvent(HSM_MESSAGE_FILE_MANAGED_BY_DIFFERENT_HSM, 0, NULL, WsbAbbreviatePath(path, 120), WsbHrAsString(hr), NULL);
			WsbThrow(hr);
		}

		//
		// Make sure there is a work allocater for this session
		//
		WsbAffirmHr(pFsaWorkItem->GetPath(&path, 0));
		WsbAffirmHr(pFsaWorkItem->GetSession(&pSession));
		WsbAffirmHr(pFsaWorkItem->GetRequestAction(&workAction));
		WsbTrace(OLESTR("CHsmTskMgr::DoFsaWork for <%ls> for <%lu>.\n"), (WCHAR *)path, workAction);

		if ((workAction == FSA_REQUEST_ACTION_FILTER_RECALL) ||
   		    (workAction == FSA_REQUEST_ACTION_FILTER_READ)) {
            WsbAffirmHr(FindRecallMediaToUse(pFsaWorkItem, &mediaId, &bagId, &dataSetStart));
			WsbAffirmHr(AddToRecallQueueForFsaSession(pSession,&pRecallQueue, &bCreated, &mediaId, &bagId, dataSetStart, pFsaWorkItem));

		} else {
			WsbAffirmHr(EnsureQueueForFsaSession(pSession, workAction, &pWorkQueue, &bCreated));
			//
			// Give the work to a queue
			//
			WsbAffirmHr(pWorkQueue->Add(pFsaWorkItem));
		}
		//
		// Start any queues that qualify (performance: only when a new queue is created)
		//
		if (bCreated) {
			WsbAffirmHr(StartQueues());
		}

	}WsbCatch (hr);


	WsbTraceOut(OLESTR("CHsmTskMgr::DoFsaWork"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
	return(hr);
}


HRESULT
CHsmTskMgr::EnsureQueueForFsaSession(
												IN  IHsmSession     *pSession,
												IN  FSA_REQUEST_ACTION fsaAction,
												OUT IHsmWorkQueue   **ppWorkQueue,
												OUT BOOL            *bCreated
												)

/*++



--*/
{
	HRESULT                 hr = S_OK;
	HSM_WORK_QUEUE_STATE    state;
	ULONG                   index;
	CComPtr<IHsmSession>    l_pSession;
	HSM_WORK_QUEUE_TYPE     type1=HSM_WORK_TYPE_NONE;
	HSM_WORK_QUEUE_TYPE     type2;
	FILETIME                birthDate;
	SYSTEMTIME              systemTime;
	GUID                    sessionGuid;


	WsbTraceIn(OLESTR("CHsmTskMgr::EnsureQueueForFsaSession"),OLESTR("FsaRequestAction = <%lu>, Waiting on CreateWorkQueueLock"), fsaAction);
	EnterCriticalSection(&m_CreateWorkQueueLock);
	try {
		WsbAffirm(0 != ppWorkQueue, E_POINTER);
		// Convert FSA action to work queue type
		switch (fsaAction) {
		case FSA_REQUEST_ACTION_FILTER_READ:
		case FSA_REQUEST_ACTION_FILTER_RECALL:
			//
			// Should not happen!! AddToRecallQueueForFsaSession is the
			// right interface for recall items
			//
			WsbThrow(E_INVALIDARG);
			break;
		case FSA_REQUEST_ACTION_RECALL:
			type1 = HSM_WORK_TYPE_FSA_RECALL;
			break;
		case FSA_REQUEST_ACTION_PREMIGRATE:
			type1 = HSM_WORK_TYPE_FSA_MIGRATE;
			break;
		case FSA_REQUEST_ACTION_VALIDATE:
			type1 = HSM_WORK_TYPE_FSA_VALIDATE;
			break;
		case FSA_REQUEST_ACTION_VALIDATE_FOR_TRUNCATE:
			type1 = HSM_WORK_TYPE_FSA_VALIDATE_FOR_TRUNCATE;
			break;
		default:
			hr = E_NOTIMPL;
			type1 = HSM_WORK_TYPE_NONE;
			break;
		}
		WsbTrace(OLESTR("CHsmTskMgr::EnsureQueueForFsaSession: type1 = %d\n"),
					static_cast<int>(type1));

		// Check the array of work queues and see if there is one for
		// this session.
		*bCreated = FALSE;
		hr = FindWorkQueueElement(pSession, type1, &index, NULL);
		if (hr == S_OK) {
			WsbAffirmHr(GetWorkQueueElement(index, &l_pSession, ppWorkQueue, &type2, &state, &birthDate));
			if ((l_pSession != pSession) || (type1 != type2)) {
				*ppWorkQueue = 0;
				WsbAssertHr(E_UNEXPECTED);
			}
			if (HSM_WORK_QUEUE_NONE == state) {
				WsbTrace(OLESTR("CHsmTskMgr::EnsureQueueForFsaSession: Creating new queue (state is NONE)\n"));
				WsbAffirmHr(m_pHsmServerCreate->CreateInstance(CLSID_CHsmWorkQueue, IID_IHsmWorkQueue,
																			  (void **)ppWorkQueue));
				WsbAffirmHr((*ppWorkQueue)->Init(m_pServer, pSession, (IHsmFsaTskMgr *)this, type1));
				GetSystemTime(&systemTime);
				WsbAffirmStatus(SystemTimeToFileTime(&systemTime, &birthDate));
				WsbAffirmHr(pSession->GetIdentifier(&sessionGuid));
				m_pWorkQueues[index].sessionId = sessionGuid;
				WsbAffirmHr(SetWorkQueueElement(index, pSession, *ppWorkQueue, type1, HSM_WORK_QUEUE_IDLE, birthDate));
				*bCreated = TRUE;
			}
		} else {
			if (hr == WSB_E_NOTFOUND) {
				hr = S_OK;
				WsbTrace(OLESTR("CHsmTskMgr::EnsureQueueForFsaSession: Creating new queue (queue not found)\n"));
				WsbAffirmHr(AddWorkQueueElement(pSession, type1, &index));
				// The work queue has not been created so create it
				WsbAffirmHr(m_pHsmServerCreate->CreateInstance(CLSID_CHsmWorkQueue, IID_IHsmWorkQueue,
																			  (void **)ppWorkQueue));
				WsbAffirmHr((*ppWorkQueue)->Init(m_pServer, pSession, (IHsmFsaTskMgr *)this, type1));
				GetSystemTime(&systemTime);
				WsbAffirmStatus(SystemTimeToFileTime(&systemTime, &birthDate));
				WsbAffirmHr(pSession->GetIdentifier(&sessionGuid));
				m_pWorkQueues[index].sessionId = sessionGuid;
				WsbAffirmHr(SetWorkQueueElement(index, pSession, *ppWorkQueue, type1, HSM_WORK_QUEUE_IDLE, birthDate));
				*bCreated = TRUE;
			}
		}

	}WsbCatch( hr );

	LeaveCriticalSection(&m_CreateWorkQueueLock);
	WsbTraceOut(OLESTR("CHsmTskMgr::EnsureQueueForFsaSession"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
	return(hr);
}


HRESULT
CHsmTskMgr::AddToRecallQueueForFsaSession(
														IN  IHsmSession     *pSession,
														OUT IHsmRecallQueue **ppWorkQueue,
														OUT BOOL            *bCreated,
														IN GUID             *pMediaId,
                                                        IN GUID             *pBagId,
                                                        IN LONGLONG          dataSetStart,
														IN IFsaPostIt 		  *pFsaWorkItem
														)

/*++



--*/
{
	HRESULT                 hr = S_OK;


	WsbTraceIn(OLESTR("CHsmTskMgr::AddToRecallQueueForFsaSession"),OLESTR("Waiting on CreateWorkQueueLock"));

	EnterCriticalSection(&m_WorkQueueLock);
	try {
		WsbAffirm(0 != ppWorkQueue, E_POINTER);
		//
		// This call will find the queue if it's already present -
		// and if not it will create a new queue and set it to the required media id
		//
		WsbAffirmHr(FindRecallQueueElement(pSession, pMediaId, ppWorkQueue, bCreated));
		hr = (*ppWorkQueue)->Add(pFsaWorkItem,
                                 pBagId,
                                 dataSetStart);

	}WsbCatch( hr );

	LeaveCriticalSection(&m_WorkQueueLock);
	WsbTraceOut(OLESTR("CHsmTskMgr::AddToRecallQueueForFsaSession"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
	return(hr);
}


HRESULT
CHsmTskMgr::IncreaseWorkQueueArraySize(
												  ULONG numToAdd
												  )
{
	HRESULT             hr = S_OK;
	ULONG               memSize;
	LPVOID              pTemp;

	//Begin Critical Section
	WsbTraceIn(OLESTR("CHsmTskMgr::IncreaseWorkQueueArraySize"),OLESTR("NumToAdd = %lu - Waiting for WorkQueueLock"), numToAdd);
	EnterCriticalSection(&m_WorkQueueLock);
	try {
		memSize = (m_NumWorkQueues + numToAdd) * sizeof(HSM_WORK_QUEUES);
		pTemp = WsbRealloc(m_pWorkQueues, memSize);
		WsbAffirm(0 != pTemp, E_FAIL);
		m_pWorkQueues = (HSM_WORK_QUEUES *) pTemp;
		ZeroMemory( (m_pWorkQueues + m_NumWorkQueues), (numToAdd * sizeof(HSM_WORK_QUEUES))
					 );
		m_NumWorkQueues += numToAdd;
	}WsbCatch (hr);

	//End Critical Section
	LeaveCriticalSection(&m_WorkQueueLock);
	WsbTraceOut(OLESTR("CHsmTskMgr::IncreaseWorkQueueArraySize"),OLESTR("hr = <%ls>, QueuesInArray = <%lu>"),
					WsbHrAsString(hr), m_NumWorkQueues);
	return(hr);
}


HRESULT
CHsmTskMgr::WorkQueueDone(
								 IHsmSession *pSession,
								 HSM_WORK_QUEUE_TYPE type,
								 GUID             *pMediaId
								 )
{
	HRESULT             hr = S_OK;
	ULONG               index;
	FILETIME            dummyTime;
	IHsmRecallQueue	 *pRecallQueue;
	BOOL					  locked = FALSE;

	WsbTraceIn(OLESTR("CHsmTskMgr::WorkQueueDone"),OLESTR("type = %d"),
				  static_cast<int>(type));
	try {
		EnterCriticalSection(&m_WorkQueueLock);
		locked = TRUE;
		//
		// Get the work queue index
		//
		hr = FindWorkQueueElement(pSession, type, &index, pMediaId);
		if (hr == S_OK) {
			WsbTrace(OLESTR("CHsmTskMgr::WorkQueueDone - ending queue # %lu\n"),
						index);
			ZeroMemory(&dummyTime, sizeof(FILETIME));
		   if (type == HSM_WORK_TYPE_FSA_DEMAND_RECALL) {
				//
				// It is possible for recall queues that an element was added
				// just before we entered the critical section above
				//
				pRecallQueue = m_pWorkQueues[index].pRecallQueue;
				if (pRecallQueue->IsEmpty() == S_OK) {
					//
					// Ok to destroy the queue
					//
					WsbAffirmHr(SetRecallQueueElement(index, 0, HSM_WORK_TYPE_NONE, HSM_WORK_QUEUE_NONE, dummyTime));
				} else {
					//
					// We are not going to destroy the queue, since an element seems to have been added
					// before we locked the work queues
					//
					hr = S_FALSE;
				}
			} else {
				WsbAffirmHr(SetWorkQueueElement(index, 0, 0, HSM_WORK_TYPE_NONE, HSM_WORK_QUEUE_NONE, dummyTime));
			}
			LeaveCriticalSection(&m_WorkQueueLock);
			locked = FALSE;

			if (hr == S_OK) {
				// Reduce active count for this work queue type
				// It must protected from starting (activating) queues
				EnterCriticalSection(&m_CurrentRunningLock);
				for (ULONG i = 0; i < m_nWorkQueueTypes; i++) {
					if (type == m_pWorkQueueTypeInfo[i].Type) {
						if (m_pWorkQueueTypeInfo[i].NumActive > 0) {
							m_pWorkQueueTypeInfo[i].NumActive--;
						}
						break;
					}
				}
    			LeaveCriticalSection(&m_CurrentRunningLock);
			}
		} else {
			LeaveCriticalSection(&m_WorkQueueLock);
			locked = FALSE;
			WsbAffirmHr(hr);
		}

		if (hr == S_OK) {
			//
			// If there are any queues waiting to start, start them
			//
			WsbAffirmHr(StartQueues());
		}
	}WsbCatchAndDo (hr,
						 if (locked) {
							 LeaveCriticalSection(&m_WorkQueueLock);
							 locked = FALSE;
						 }
						);


	WsbTraceOut(OLESTR("CHsmTskMgr::WorkQueueDone"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
	return(hr);
}


HRESULT
CHsmTskMgr::AddWorkQueueElement(
										 IHsmSession *pSession,
										 HSM_WORK_QUEUE_TYPE type,
										 ULONG *pIndex
										 )
{
	HRESULT             hr = S_OK;
	BOOLEAN             foundOne = FALSE;

	WsbTraceIn(OLESTR("CHsmTskMgr::AddWorkQueueElement"),
				  OLESTR("type = %d, Waiting on WorkQueueLock"),
				  static_cast<int>(type));

	//Begin Critical Section
	EnterCriticalSection(&m_WorkQueueLock);

	try {
		WsbAssert(0 != pIndex, E_POINTER);
		// Scan the array looking for an empty element
		for (ULONG i = 0; ((i < m_NumWorkQueues) && (foundOne == FALSE)); i++) {
			if (m_pWorkQueues[i].queueType == HSM_WORK_TYPE_NONE) {
				foundOne = TRUE;
				*pIndex = i;
				if (type != HSM_WORK_TYPE_FSA_DEMAND_RECALL) {
					//
					// Stow away the session. For recall queues, the session
					// is stored in the work item
					//
					m_pWorkQueues[i].pSession = pSession;
				}
				m_pWorkQueues[i].queueType = type;
			}
		}

		if (foundOne == FALSE) {
			// There are no empty elements so we need to add more
			*pIndex = m_NumWorkQueues;
			WsbAffirmHr(IncreaseWorkQueueArraySize(HsmWorkQueueArrayBumpSize));
			if (type != HSM_WORK_TYPE_FSA_DEMAND_RECALL) {
				//
				// We store the session in the work-queue element itself..
				// Just indicate this slot is taken..
				//
				m_pWorkQueues[*pIndex].pSession = pSession;
			}
			m_pWorkQueues[*pIndex].queueType = type;
		}

	}WsbCatch (hr);

	//End Critical Section
	LeaveCriticalSection(&m_WorkQueueLock);

	WsbTraceOut(OLESTR("CHsmTskMgr::AddWorkQueueElement"),
					OLESTR("hr = <%ls>, index = %lu"),WsbHrAsString(hr), *pIndex);
	return(hr);
}

HRESULT
CHsmTskMgr::FindWorkQueueElement(
										  IHsmSession *pSession,
										  HSM_WORK_QUEUE_TYPE type,
										  ULONG *pIndex,
										  GUID *pMediaId
										  )
{
	HRESULT             hr = S_OK;
	BOOLEAN             foundOne = FALSE;
	GUID					  id;

	WsbTraceIn(OLESTR("CHsmTskMgr::FindWorkQueueElement"),
				  OLESTR("type = %d, Waiting on WorkQueueLock"),
				  static_cast<int>(type));

	//Begin Critical Section
	EnterCriticalSection(&m_WorkQueueLock);

	try {

		WsbAssert(0 != pIndex, E_POINTER);

		// Scan the array looking for an empty element
		for (ULONG i = 0; ((i < m_NumWorkQueues) && (foundOne == FALSE)); i++) {
			if (m_pWorkQueues[i].queueType == type) {
				if (type == HSM_WORK_TYPE_FSA_DEMAND_RECALL) {
					m_pWorkQueues[i].pRecallQueue->GetMediaId(&id);
					if (WsbCompareGuid(id, *pMediaId) != 0)  {
						continue;
					}
				} else if (pSession != m_pWorkQueues[i].pSession) {
					continue;
				}
				foundOne = TRUE;
				*pIndex = i;
			}
		}

		if (FALSE == foundOne) {
			hr = WSB_E_NOTFOUND;
		}
	}WsbCatch (hr);
	//End Critical Section
	LeaveCriticalSection(&m_WorkQueueLock);
	WsbTraceOut(OLESTR("CHsmTskMgr::FindWorkQueueElement"),OLESTR("hr = <%ls>, index = <%ls>"),
					WsbHrAsString(hr), WsbPtrToUlongAsString(pIndex));
	return(hr);
}


HRESULT
CHsmTskMgr::FindRecallQueueElement(
											 IN IHsmSession *pSession,
											 IN GUID   *pMediaId,
											 OUT IHsmRecallQueue **ppWorkQueue,
											 OUT BOOL         *bCreated
											 )
{
	HRESULT             hr = S_OK;
	BOOLEAN             foundOne = FALSE;
	GUID                id;
	FILETIME            birthDate;
	SYSTEMTIME          systemTime;
	ULONG            index=0;

	UNREFERENCED_PARAMETER(pSession);

	//
	// Important assumption: m_WorkQueueLock is held before calling this function
	//
	WsbTraceIn(OLESTR("CHsmTskMgr::FindRecallQueueElement"),
				  OLESTR("Waiting on WorkQueueLock"));

	*bCreated =  FALSE;

	try {
		for (ULONG i=0;  (i < m_NumWorkQueues) && (foundOne == FALSE); i++) {
			//
			// Get the media id for the work queue
			//
			if (m_pWorkQueues[i].queueType == HSM_WORK_TYPE_FSA_DEMAND_RECALL) {
				if (m_pWorkQueues[i].pRecallQueue != NULL) {
					WsbAffirmHr(m_pWorkQueues[i].pRecallQueue->GetMediaId(&id));
					if ((WsbCompareGuid(id, *pMediaId) == 0)) {
						foundOne = TRUE;
						index = i;
					}
				}
			}
		}

		if (FALSE == foundOne) {
			//
			// No exisiting media queue was found. Make a new one
			//
			for (ULONG i = 0; ((i < m_NumWorkQueues) && (foundOne == FALSE)); i++) {
				if (m_pWorkQueues[i].queueType == HSM_WORK_TYPE_NONE) {
					foundOne = TRUE;
					index = i;
				}
			}

			if (foundOne == FALSE) {
				// There are no empty elements so we need to add more
				index = m_NumWorkQueues;
				WsbAffirmHr(IncreaseWorkQueueArraySize(HsmWorkQueueArrayBumpSize));
			}
			//
			// At this point we have the free slot index in index
			// The work queue has not been created so create it
			//
			WsbAffirmHr(m_pHsmServerCreate->CreateInstance(CLSID_CHsmRecallQueue, IID_IHsmRecallQueue,
																		  (void **)ppWorkQueue));
			WsbAffirmHr((*ppWorkQueue)->SetMediaId(pMediaId));
			WsbAffirmHr((*ppWorkQueue)->Init(m_pServer,  (IHsmFsaTskMgr *)this));
			GetSystemTime(&systemTime);
			WsbAffirmStatus(SystemTimeToFileTime(&systemTime, &birthDate));
			m_pWorkQueues[index].queueType = HSM_WORK_TYPE_FSA_DEMAND_RECALL;
			m_pWorkQueues[index].pSession = NULL;
			m_pWorkQueues[index].pRecallQueue = *ppWorkQueue;
			m_pWorkQueues[index].queueState = HSM_WORK_QUEUE_IDLE;
			m_pWorkQueues[index].birthDate = birthDate;
			//
			// Indicate a new queue was created
			//
			*bCreated = TRUE;
		} else {
			//
			// Queue is already present, index points to it
			//
			*ppWorkQueue = m_pWorkQueues[index].pRecallQueue;
			if (0 != *ppWorkQueue) {
				//
				// We need to AddRef it..
				//
				(*ppWorkQueue)->AddRef();
			}
		}
	}WsbCatch (hr);

	WsbTraceOut(OLESTR("CHsmTskMgr::FindRecallQueueElement"),OLESTR("hr = <%ls>, index = <%ls>"),
					WsbHrAsString(hr), WsbLongAsString((LONG)index));
	return(hr);
}


HRESULT
CHsmTskMgr::GetWorkQueueElement(
										 ULONG index,
										 IHsmSession **ppSession,
										 IHsmWorkQueue **ppWorkQueue,
										 HSM_WORK_QUEUE_TYPE *pType,
										 HSM_WORK_QUEUE_STATE *pState,
										 FILETIME *pBirthDate
										 )
{
	HRESULT             hr = S_OK;

	WsbTraceIn(OLESTR("CHsmTskMgr::GetWorkQueueElement"),
				  OLESTR("index = %lu, Waiting on WorkQueueLock"), index);
	//Begin Critical Section
	EnterCriticalSection(&m_WorkQueueLock);
	try {
		*pType = m_pWorkQueues[index].queueType;

		*ppSession = m_pWorkQueues[index].pSession;
		if (0 != *ppSession) {
			(*ppSession)->AddRef();
		}

		*ppWorkQueue = m_pWorkQueues[index].pWorkQueue;
		if (0 != *ppWorkQueue) {
			(*ppWorkQueue)->AddRef();
		}
		*pState = m_pWorkQueues[index].queueState;
		*pBirthDate = m_pWorkQueues[index].birthDate;

	}WsbCatch (hr);

	//End Critical Section
	LeaveCriticalSection(&m_WorkQueueLock);
	WsbTraceOut(OLESTR("CHsmTskMgr::GetWorkQueueElement"),
					OLESTR("hr = <%ls>, type = %d"),WsbHrAsString(hr),
					static_cast<int>(*pType));
	return(hr);
}


HRESULT
CHsmTskMgr::GetRecallQueueElement(
											ULONG index,
											IHsmRecallQueue **ppWorkQueue,
											HSM_WORK_QUEUE_STATE *pState,
											FILETIME *pBirthDate
											)
{
	HRESULT             hr = S_OK;

	WsbTraceIn(OLESTR("CHsmTskMgr::GetRecallQueueElement"),
				  OLESTR("index = %lu, Waiting on WorkQueueLock"), index);
	//Begin Critical Section
	EnterCriticalSection(&m_WorkQueueLock);
	try {
		WsbAffirm(m_pWorkQueues[index].queueType == HSM_WORK_TYPE_FSA_DEMAND_RECALL, E_INVALIDARG);

		*ppWorkQueue = m_pWorkQueues[index].pRecallQueue;
		if (0 != *ppWorkQueue) {
			(*ppWorkQueue)->AddRef();
		}
		*pState = m_pWorkQueues[index].queueState;
		*pBirthDate = m_pWorkQueues[index].birthDate;

	}WsbCatch (hr);

	//End Critical Section
	LeaveCriticalSection(&m_WorkQueueLock);
	WsbTraceOut(OLESTR("CHsmTskMgr::GetRecallQueueElement"),
					OLESTR("hr = <%ls>"),WsbHrAsString(hr));
	return(hr);
}


HRESULT
CHsmTskMgr::SetWorkQueueElement(
										 ULONG index,
										 IHsmSession *pSession,
										 IHsmWorkQueue *pWorkQueue,
										 HSM_WORK_QUEUE_TYPE type,
										 HSM_WORK_QUEUE_STATE state,
										 FILETIME birthDate
										 )
{
	HRESULT             hr = S_OK;

	WsbTraceIn(OLESTR("CHsmTskMgr::SetWorkQueueElement"),OLESTR("Waiting on WorkQueueLock"));
	//Begin Critical Section
	EnterCriticalSection(&m_WorkQueueLock);
	try {
		m_pWorkQueues[index].pSession = pSession;
		m_pWorkQueues[index].pWorkQueue = pWorkQueue;
		m_pWorkQueues[index].queueType = type;
		m_pWorkQueues[index].queueState = state;
		m_pWorkQueues[index].birthDate = birthDate;

	}WsbCatch (hr);

	//End Critical Section
	LeaveCriticalSection(&m_WorkQueueLock);
	WsbTraceOut(OLESTR("CHsmTskMgr::SetWorkQueueElement"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
	return(hr);
}


HRESULT
CHsmTskMgr::SetRecallQueueElement(
											ULONG index,
											IHsmRecallQueue *pWorkQueue,
											HSM_WORK_QUEUE_TYPE queueType,
											HSM_WORK_QUEUE_STATE state,
											FILETIME birthDate
											)
{
	HRESULT             hr = S_OK;

	WsbTraceIn(OLESTR("CHsmTskMgr::SetWorkQueueElement"),OLESTR("Waiting on WorkQueueLock"));
	//Begin Critical Section
	EnterCriticalSection(&m_WorkQueueLock);
	try {
		WsbAffirm(m_pWorkQueues[index].queueType == HSM_WORK_TYPE_FSA_DEMAND_RECALL, E_INVALIDARG);
		//
		// Ensure the session pointer is empty, this is unused for recall queues
		//
		m_pWorkQueues[index].pSession = NULL;
		m_pWorkQueues[index].queueType = queueType;
		m_pWorkQueues[index].pRecallQueue = pWorkQueue;
		m_pWorkQueues[index].queueState = state;
		m_pWorkQueues[index].birthDate = birthDate;
	}WsbCatch (hr);

	//End Critical Section
	LeaveCriticalSection(&m_WorkQueueLock);
	WsbTraceOut(OLESTR("CHsmTskMgr::SetWorkQueueElement"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
	return(hr);
}


HRESULT
CHsmTskMgr::RemoveWorkQueueElement(
											 ULONG index
											 )
{
	HRESULT             hr = S_OK;

	WsbTraceIn(OLESTR("CHsmTskMgr::RemoveWorkQueueElement"),OLESTR("Waiting on WorkQueueLock"));
	//Begin Critical Section
	EnterCriticalSection(&m_WorkQueueLock);
	try {
		m_pWorkQueues[index].pSession = 0;
		m_pWorkQueues[index].pWorkQueue = 0;
		m_pWorkQueues[index].queueType = HSM_WORK_TYPE_NONE;
		m_pWorkQueues[index].queueState = HSM_WORK_QUEUE_NONE;
		ZeroMemory(&(m_pWorkQueues[index].birthDate), sizeof(FILETIME));

	}WsbCatch (hr);

	//End Critical Section
	LeaveCriticalSection(&m_WorkQueueLock);
	WsbTraceOut(OLESTR("CHsmTskMgr::RemoveWorkQueueElement"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
	return(hr);
}


HRESULT
CHsmTskMgr::StartQueues( void )
{
	HRESULT             hr = S_OK;
	ULONG               uActive;

	WsbTraceIn(OLESTR("CHsmTskMgr::StartQueues"),OLESTR("Waiting on CurrentRunningLock"));
	//Begin Critical Section
	EnterCriticalSection(&m_CurrentRunningLock);
	try {
		// Go over work types, and start (activate) queues until the threshold
		// for the work type is reached
		for (ULONG i = 0; i < m_nWorkQueueTypes; i++) {
			// For Migrate queues, get the (dynamically set) Allowed limit
			if ((HSM_WORK_TYPE_FSA_MIGRATE == m_pWorkQueueTypeInfo[i].Type) ||
				 (HSM_WORK_TYPE_FSA_DEMAND_RECALL == m_pWorkQueueTypeInfo[i].Type)) {
				WsbAffirmHr(m_pServer->GetCopyFilesLimit( &(m_pWorkQueueTypeInfo[i].MaxActiveAllowed) ));
			}

			WsbTrace(OLESTR("CHsmTskMgr::StartQueues: QueueType[%lu].NumActive = %lu, Allowed = %lu\n"),
						i, m_pWorkQueueTypeInfo[i].NumActive,
						m_pWorkQueueTypeInfo[i].MaxActiveAllowed);
			while ((uActive = m_pWorkQueueTypeInfo[i].NumActive) <
					 m_pWorkQueueTypeInfo[i].MaxActiveAllowed) {
				WsbAffirmHr(StartFsaQueueType(m_pWorkQueueTypeInfo[i].Type));
				if (uActive == m_pWorkQueueTypeInfo[i].NumActive) {
					// no more work queues to activate - get out...
					break;
				}
			}
		}
	}WsbCatch (hr);

	//End Critical Section
	LeaveCriticalSection(&m_CurrentRunningLock);
	WsbTraceOut(OLESTR("CHsmTskMgr::StartQueues"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
	return(hr);
}


HRESULT
CHsmTskMgr::StartFsaQueueType(HSM_WORK_QUEUE_TYPE type)
{
	HRESULT                   hr = S_OK;
	CComPtr<IHsmWorkQueue>    pWorkQueue;
	CComPtr<IHsmRecallQueue>  pRecallQueue;
	ULONG                     index;

	WsbTraceIn(OLESTR("CHsmTskMgr::StartFsaQueueType"),OLESTR("type = %d"),
				  static_cast<int>(type));
	try {
		// Find the oldest queue of this type
		hr = FindOldestQueue(type, &index);
		if (S_OK == hr) {
			HSM_WORK_QUEUE_STATE    state;
			CComPtr<IHsmSession>    l_pSession;
			HSM_WORK_QUEUE_TYPE     l_type;
			FILETIME                birthDate;

			// Make sure that the queue is idle
			if (type == HSM_WORK_TYPE_FSA_DEMAND_RECALL) {
				WsbAffirmHr(GetRecallQueueElement(index, &pRecallQueue, &state, &birthDate));
			} else {
				WsbAffirmHr(GetWorkQueueElement(index, &l_pSession, &pWorkQueue,
														  &l_type, &state, &birthDate));
			}
			if (HSM_WORK_QUEUE_IDLE == state) {
				if (type == HSM_WORK_TYPE_FSA_DEMAND_RECALL) {
					WsbAffirmHr(SetRecallQueueElement(index, pRecallQueue,
																 HSM_WORK_TYPE_FSA_DEMAND_RECALL,
																 HSM_WORK_QUEUE_STARTING, birthDate));
					WsbAffirmHr(pRecallQueue->Start());
					WsbAffirmHr(SetRecallQueueElement(index, pRecallQueue,
																 HSM_WORK_TYPE_FSA_DEMAND_RECALL,
																 HSM_WORK_QUEUE_STARTED, birthDate));
				} else {
					WsbAffirmHr(SetWorkQueueElement(index, l_pSession, pWorkQueue,
															  type, HSM_WORK_QUEUE_STARTING, birthDate));
					WsbAffirmHr(pWorkQueue->Start());
					WsbAffirmHr(SetWorkQueueElement(index, l_pSession, pWorkQueue,
															  type, HSM_WORK_QUEUE_STARTED, birthDate));
				}
				WsbTrace(OLESTR("CHsmTskMgr::StartFsaQueueType - started work queue %lu\n"),
							index);


				// Increment active count for this work queue type
				for (ULONG i = 0; i < m_nWorkQueueTypes; i++) {
					if (type == m_pWorkQueueTypeInfo[i].Type) {
						m_pWorkQueueTypeInfo[i].NumActive++;
						break;
					}
				}
			}
		} else {
			if (WSB_E_NOTFOUND == hr) {
				hr = S_OK;
			}
		}
		WsbAffirmHr( hr );

	}WsbCatch (hr);

	WsbTraceOut(OLESTR("CHsmTskMgr::StartFsaQueueType"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
	return(hr);
}


HRESULT
CHsmTskMgr::FindOldestQueue(
									HSM_WORK_QUEUE_TYPE type,
									ULONG               *pIndex
									)
{
	HRESULT                 hr = S_OK;
	FILETIME                oldestOne;
	LONG                    compare;
	ULONG                   oldestIndex = 0xFFFFFFFF;
	BOOLEAN                 firstOne;

	WsbTraceIn(OLESTR("CHsmTskMgr::FindOldestQueue"),OLESTR("type = %d"),
				  static_cast<int>(type));
	try {
		WsbAffirmPointer(pIndex);

		// Start out with the first time flag equal to TRUE so we select the first one with the right state and type
		firstOne = TRUE;

		for (ULONG i = 0; (i < m_NumWorkQueues); i++) {
			if ((type == m_pWorkQueues[i].queueType) && (HSM_WORK_QUEUE_IDLE == m_pWorkQueues[i].queueState)) {
				if (!firstOne)
					compare = CompareFileTime(&(m_pWorkQueues[i].birthDate), &(oldestOne));
				else
					compare = -1;
				if (compare < 0) {
					// found an older one
					firstOne = FALSE;
					oldestOne.dwLowDateTime = m_pWorkQueues[i].birthDate.dwLowDateTime;
					oldestOne.dwHighDateTime = m_pWorkQueues[i].birthDate.dwHighDateTime;
					oldestIndex = i;
				}
			}
		}

		if (0xFFFFFFFF == oldestIndex) {
			// Didn't find a match
			hr = WSB_E_NOTFOUND;
		} else {
			HSM_WORK_QUEUE_STATE    state;
			CComPtr<IHsmSession>    l_pSession;
			CComPtr<IHsmWorkQueue>  l_pWorkQueue;
			CComPtr<IHsmRecallQueue>  l_pRecallQueue;
			HSM_WORK_QUEUE_TYPE     type2;
			FILETIME                birthDate;

			// Make sure that the queue is idle
			if (type == HSM_WORK_TYPE_FSA_DEMAND_RECALL) {
				WsbAffirmHr(GetRecallQueueElement(oldestIndex, &l_pRecallQueue, &state, &birthDate));
			} else {
				WsbAffirmHr(GetWorkQueueElement(oldestIndex, &l_pSession, &l_pWorkQueue, &type2, &state, &birthDate));
			}
			if (HSM_WORK_QUEUE_IDLE == state) {
				*pIndex = oldestIndex;
				WsbTrace(OLESTR("CHsmTskMgr::FindOldestQueue: found index = %lu\n"),
							oldestIndex);
			} else {
				WsbTrace(OLESTR("CHsmTskMgr::FindOldestQueue - found NULL queue\n"));
				hr = WSB_E_NOTFOUND;
			}
		}

	}WsbCatch (hr);

	WsbTraceOut(OLESTR("CHsmTskMgr::FindOldestQueue"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
	return(hr);
}


HRESULT
CHsmTskMgr::ChangeSysState(
								  IN OUT HSM_SYSTEM_STATE* pSysState
								  )

/*++

Implements:

  IHsmSystemState::ChangeSysState().

--*/
{
	HRESULT                 hr = S_OK;

	WsbTraceIn(OLESTR("CHsmTskMgr::ChangeSysState"), OLESTR(""));

	try {

		//  Loop over work queues
		if (0 != m_pWorkQueues) {
			FILETIME            dummyTime;
			ZeroMemory(&dummyTime, sizeof(FILETIME));
			for (ULONG i = 0; i < m_NumWorkQueues; i++) {
				if (m_pWorkQueues[i].pWorkQueue) {

					if (m_pWorkQueues[i].queueType == HSM_WORK_TYPE_FSA_DEMAND_RECALL) {
						if (pSysState->State & HSM_STATE_SHUTDOWN) {
							m_pWorkQueues[i].pRecallQueue->Stop();
						}
						m_pWorkQueues[i].pRecallQueue->ChangeSysState(pSysState);
					} else {
						if (pSysState->State & HSM_STATE_SHUTDOWN) {
							m_pWorkQueues[i].pWorkQueue->Stop();
						}
						m_pWorkQueues[i].pWorkQueue->ChangeSysState(pSysState);
					}
				}

				if (pSysState->State & HSM_STATE_SHUTDOWN) {
					hr = SetWorkQueueElement(i, 0, 0, HSM_WORK_TYPE_NONE, HSM_WORK_QUEUE_NONE, dummyTime);
				}
			}
		}

	}WsbCatch(hr);

	WsbTraceOut(OLESTR("CHsmTskMgr::ChangeSysState"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

	return(hr);
}


HRESULT
CHsmTskMgr::FindRecallMediaToUse(
							  IN  IFsaPostIt *pFsaWorkItem,
							  OUT GUID       *pMediaToUse,
                              OUT GUID       *pBagId,
                              OUT LONGLONG   *pDataSetStart
						  )
/*++


--*/
{
	HRESULT                 hr = S_OK;
	CComQIPtr<ISegDb, &IID_ISegDb> pSegDb;
	CComPtr<IWsbDb>                 pWsbDb;
	CComPtr<IWsbDbSession>  pDbWorkSession;
	BOOL                    openedDb = FALSE;

	WsbTraceIn(OLESTR("CHsmTskMgr::FindRecallMediaToUse"),OLESTR(""));
	try {
		WsbAssert(pMediaToUse != 0, E_POINTER);
		*pMediaToUse = GUID_NULL;

		CComPtr<ISegRec>        pSegRec;
		GUID                    l_BagId;
		LONGLONG                l_FileStart;
		LONGLONG                l_FileSize;
		USHORT                  l_SegFlags;
		GUID                    l_PrimPos;
		LONGLONG                l_SecPos;
		GUID                    storagePoolId;
		FSA_PLACEHOLDER         placeholder;

		//
		// Get the segment database
		//
		WsbAffirmHr(m_pServer->GetSegmentDb(&pWsbDb));
		pSegDb = pWsbDb;
		//
		// Go to the segment database to find out where the data
		// is located.
		//
		WsbAffirmHr(pFsaWorkItem->GetPlaceholder(&placeholder));
		WsbAffirmHr(pFsaWorkItem->GetStoragePoolId(&storagePoolId));

		WsbTrace(OLESTR("Finding SegmentRecord: <%ls>, <%ls>, <%ls>\n"),
					WsbGuidAsString(placeholder.bagId),
					WsbStringCopy(WsbLonglongAsString(placeholder.fileStart)),
					WsbStringCopy(WsbLonglongAsString(placeholder.fileSize)));

		WsbAffirmHr(pSegDb->Open(&pDbWorkSession));
		openedDb = TRUE;
		hr = pSegDb->SegFind(pDbWorkSession, placeholder.bagId, placeholder.fileStart,
									placeholder.fileSize, &pSegRec);
		if (S_OK != hr) {
			//
			// We couldn't find the segment record for this information!
			//
			hr = HSM_E_SEGMENT_INFO_NOT_FOUND;
			WsbAffirmHr(hr);
		}
		WsbAffirmHr(pSegRec->GetSegmentRecord(&l_BagId, &l_FileStart, &l_FileSize, &l_SegFlags,
														  &l_PrimPos, &l_SecPos));
		WsbAssert(0 != l_SecPos, HSM_E_BAD_SEGMENT_INFORMATION);

        //
        // In case of an indirect record, go to the dirtect record to get real location info
        //
        if (l_SegFlags & SEG_REC_INDIRECT_RECORD) {
            pSegRec = 0;

            WsbTrace(OLESTR("Finding indirect SegmentRecord: <%ls>, <%ls>, <%ls>\n"),
                    WsbGuidAsString(l_PrimPos), WsbStringCopy(WsbLonglongAsString(l_SecPos)),
                    WsbStringCopy(WsbLonglongAsString(placeholder.fileSize)));

            hr = pSegDb->SegFind(pDbWorkSession, l_PrimPos, l_SecPos,
                                 placeholder.fileSize, &pSegRec);
            if (S_OK != hr)  {
                //
                // We couldn't find the direct segment record for this segment!
                //
                hr = HSM_E_SEGMENT_INFO_NOT_FOUND;
                WsbAffirmHr(hr);
            }

            WsbAffirmHr(pSegRec->GetSegmentRecord(&l_BagId, &l_FileStart, &l_FileSize, &l_SegFlags,
                                &l_PrimPos, &l_SecPos));
            WsbAssert(0 != l_SecPos, HSM_E_BAD_SEGMENT_INFORMATION);

            // Don't support a second indirection for now !!
            WsbAssert(0 == (l_SegFlags & SEG_REC_INDIRECT_RECORD), HSM_E_BAD_SEGMENT_INFORMATION);
        }

		//
		// Go to the media database to get the media ID
		//
		CComPtr<IMediaInfo>     pMediaInfo;
		GUID                    l_RmsMediaId;

		WsbAffirmHr(pSegDb->GetEntity(pDbWorkSession, HSM_MEDIA_INFO_REC_TYPE, IID_IMediaInfo,
												(void**)&pMediaInfo));
		WsbAffirmHr(pMediaInfo->SetId(l_PrimPos));
		hr = pMediaInfo->FindEQ();
		if (S_OK != hr) {
			hr = HSM_E_MEDIA_INFO_NOT_FOUND;
			WsbAffirmHr(hr);
		}
		WsbAffirmHr(pMediaInfo->GetMediaSubsystemId(&l_RmsMediaId));
		*pMediaToUse = l_RmsMediaId;
        *pDataSetStart = l_SecPos;
        *pBagId = l_BagId;
		if (openedDb) {
			pSegDb->Close(pDbWorkSession);
			openedDb = FALSE;
		}

	}WsbCatchAndDo( hr,
					 if (openedDb){
						 pSegDb->Close(pDbWorkSession);}
					  ) ;

	WsbTraceOut(OLESTR("CHsmTskMgr::FindRecallMediaToUse"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));
	return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\engine\task\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently
#ifndef _STDAFX_H
#define _STDAFX_H

#define WSB_TRACE_IS        WSB_TRACE_BIT_HSMTSKMGR
#include "wsb.h"
#include "engcommn.h"
#include "esent.h"

#endif // _STDAFX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\engine\task\volasgn.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    VolAssign.cpp

Abstract:

    This component is an object representation of the HSM Metadata 
    Volume Assignement record.

Author:

    Ron White [ronw]        3-Jun-1997

Revision History:

--*/


#include "stdafx.h"

#include "metaint.h"
#include "metalib.h"
#include "VolAsgn.h"

#undef  WSB_TRACE_IS        
#define WSB_TRACE_IS        WSB_TRACE_BIT_META

HRESULT 
CVolAssign::GetVolAssign(
    OUT GUID *pBagId, 
    OUT LONGLONG *pSegStartLoc, 
    OUT LONGLONG *pSegLen,
    OUT GUID *pVolId
    ) 
/*++

Implements:

  IVolAssign::GetVolAssign

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CVolAssign::GetVolAssign"),OLESTR(""));

    try {
        //Make sure we can provide data memebers
        WsbAssert(0 != pBagId, E_POINTER);
        WsbAssert(0 != pSegStartLoc, E_POINTER);
        WsbAssert(0 != pSegLen, E_POINTER);
        WsbAssert(0 != pVolId, E_POINTER);

        //Provide the data members
        *pBagId = m_BagId;
        *pSegStartLoc = m_SegStartLoc;
        *pSegLen = m_SegLen;
        *pVolId = m_VolId;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CVolAssign::GetVolAssign"), 
        OLESTR("BagId = <%ls>, SegStartLoc = <%ls>, SegLen = <%ls>, VolId = <%ls>"),
        WsbPtrToGuidAsString(pBagId), 
        WsbStringCopy(WsbPtrToLonglongAsString(pSegStartLoc)),
        WsbStringCopy(WsbPtrToLonglongAsString(pSegLen)),
        WsbStringCopy(WsbPtrToGuidAsString(pVolId)));
    return(hr);

}


HRESULT 
CVolAssign::FinalConstruct(
    void
    ) 
/*++

Routine Description:

  This method does some initialization of the object that is necessary
  after construction.

Arguments:

  None.

Return Value:

  S_OK
  Anything returned by CWsbDbEntity::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssertHr(CWsbDbEntity::FinalConstruct());

        m_BagId = GUID_NULL;
        m_SegStartLoc = 0;
        m_SegLen = 0;
        m_VolId = GUID_NULL;

    } WsbCatch(hr);

    return(hr);
}

HRESULT CVolAssign::GetClassID
(
    OUT LPCLSID pclsid
    ) 
/*++

Implements:

  IPerist::GetClassID()

--*/

{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CVolAssign::GetClassID"), OLESTR(""));


    try {
        WsbAssert(0 != pclsid, E_POINTER);

        *pclsid = CLSID_CVolAssign;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CVolAssign::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pclsid));
    return(hr);
}


HRESULT CVolAssign::Load
(
    IN IStream* pStream
    ) 
/*++

Implements:

  IPersistStream::Load().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CVolAssign::Load"), OLESTR(""));

    try {
        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_BagId));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_SegStartLoc));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_SegLen));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_VolId));
    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CVolAssign::Load"), 
        OLESTR("hr = <%ls>,  GUID = <%ls>, SegStartLoc = <%ls>, SegLen = <%ls>, VolId = <%ls>"), 
        WsbHrAsString(hr), WsbGuidAsString(m_BagId),
        WsbStringCopy(WsbLonglongAsString(m_SegStartLoc)),
        WsbStringCopy(WsbLonglongAsString(m_SegLen)),
        WsbStringCopy(WsbGuidAsString(m_VolId)));

    return(hr);
}


HRESULT CVolAssign::Print
(
    IN IStream* pStream
    ) 
/*++

Implements:

  IWsbDbEntity::Print

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CVolAssign::Print"), OLESTR(""));

    try {
        WsbAssert(0 != pStream, E_POINTER);
        CWsbStringPtr strGuid;
        WsbAffirmHr(WsbSafeGuidAsString(m_BagId, strGuid));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" BagId = %ls"), 
                (WCHAR *)strGuid));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(", StartLoc = %ls"), 
                WsbLonglongAsString(m_SegStartLoc)));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(", SegLen = %ls"), 
                WsbLonglongAsString(m_SegLen)));
        WsbAffirmHr(WsbSafeGuidAsString(m_VolId, strGuid));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" new VolId = %ls"), 
                (WCHAR *)strGuid));
        WsbAffirmHr(CWsbDbEntity::Print(pStream));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CVolAssign::Print"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT CVolAssign::Save
(
    IN IStream* pStream, 
    IN BOOL clearDirty
    ) 
/*++

Implements:

  IPersistStream::Save().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CVolAssign::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));

    try {
        WsbAssert(0 != pStream, E_POINTER);
        WsbAffirmHr(WsbSaveToStream(pStream, m_BagId));
        WsbAffirmHr(WsbSaveToStream(pStream, m_SegStartLoc));
        WsbAffirmHr(WsbSaveToStream(pStream, m_SegLen));
        WsbAffirmHr(WsbSaveToStream(pStream, m_VolId));

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CVolAssign::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CVolAssign::SetVolAssign
(
    IN GUID BagId, 
    IN LONGLONG SegStartLoc, 
    IN LONGLONG SegLen,
    IN GUID VolId
    )
 /*++

Implements:

  IVolAssign::SetVolAssign().

--*/
{
    WsbTraceIn(OLESTR("CVolAssign::SetVolAssign"), 
        OLESTR("BagId = <%ls>, SegStartLoc = <%ls>, SegLen = <%ls>, VolId = <%ls>"), 
        WsbGuidAsString(BagId), 
        WsbStringCopy(WsbLonglongAsString(SegStartLoc)), 
        WsbStringCopy(WsbLonglongAsString(SegLen)),
        WsbStringCopy(WsbGuidAsString(VolId)));

    m_isDirty = TRUE;
    m_BagId = BagId;
    m_SegStartLoc = SegStartLoc;
    m_SegLen = SegLen;
    m_VolId = VolId;

    WsbTraceOut(OLESTR("CVolAssign::SetVolAssign"), OLESTR("hr = <%ls>"),WsbHrAsString(S_OK));
    return(S_OK);
}


HRESULT 
CVolAssign::UpdateKey(
    IWsbDbKey *pKey
    ) 
/*++

Implements:

  IWsbDbEntity::UpdateKey

--*/
{ 
    HRESULT  hr = S_OK; 

    try {
        WsbAffirmHr(pKey->SetToGuid(m_BagId));
        WsbAffirmHr(pKey->AppendLonglong(m_SegStartLoc));
    } WsbCatch(hr);

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\engine\task\volasgn.h ===
// VolAsgn.h : Declaration of the CVolAssign


#include "resource.h"       // main symbols
#include "Wsb.h"            // Wsb Collectable Class
#include "wsbdb.h"


/////////////////////////////////////////////////////////////////////////////
// Task

class CVolAssign : 
    public CWsbDbEntity,
    public IVolAssign,
    public CComCoClass<CVolAssign,&CLSID_CVolAssign>
{
public:
    CVolAssign() {}
BEGIN_COM_MAP(CVolAssign)
    COM_INTERFACE_ENTRY(IVolAssign)
    COM_INTERFACE_ENTRY2(IWsbDbEntity, CWsbDbEntity)
    COM_INTERFACE_ENTRY(IWsbDbEntityPriv)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
//  COM_INTERFACE_ENTRY(IWsbPersistable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY(CVolAssign, _T("Task.VolAssign.1"), _T("Task.VolAssign"), IDS_VOLASSIGN_DESC, THREADFLAGS_BOTH)

// IVolAssign
public:
    STDMETHOD(FinalConstruct)(void);

// IWsbDbEntity
public:
    STDMETHOD(Print)(IStream* pStream);
    STDMETHOD(UpdateKey)(IWsbDbKey *pKey);
    WSB_FROM_CWSBDBENTITY;

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* /*pSize*/)
        { return(E_NOTIMPL); }
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbTestable
public:
    STDMETHOD(Test)(USHORT* /*pTestsPassed*/, USHORT* /*pTestsFailed*/)
        { return(E_NOTIMPL); }

// IVolAssign
public:
    STDMETHOD(GetVolAssign)(GUID* pBagId, LONGLONG *pSegStartLoc, 
            LONGLONG *pSegLen, GUID* VolId );
    STDMETHOD(SetVolAssign)(GUID bagId, LONGLONG segStartLoc, 
            LONGLONG SegLen, GUID VolId );

private:
    GUID            m_BagId;
    LONGLONG        m_SegStartLoc;
    LONGLONG        m_SegLen;
    GUID            m_VolId;    // New volume assignment
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\filter\pch.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    PCH.H

Abstract:

    This module includes all  the headers which need
    to be precompiled & are included by all the source
    files in the RSFILTER project.

Author(s):

    Ravisankar Pudipeddi (ravisp) 

Environment:

    Kernel mode only

Notes:

Revision History:

--*/

#ifndef _RSFILTER_PCH_H_
#define _RSFILTER_PCH_H_

#include "ntifs.h"

//#define _NTIFS_
//#include "ntos.h"
//#include "ntseapi.h"
//#include "ntrtl.h"
//#include "nturtl.h"
//#include "fsrtl.h"
//#include "zwapi.h"

#include "stddef.h"

#define _WINDOWS_

#include <stdio.h>
#include "rpdata.h"
#include "rpio.h"
#include "rpfsa.h"
#include "rpfilter.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\engine\task\tsktrace.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    TskTrace.cpp

Abstract:

    These functions are used to provide an ability to trace the flow
    of the application for task manager debugging purposes.

Author:

    Cat Brant   [cbrant]   7-Dec-1996

Revision History:

--*/

#include "stdafx.h"
#include "stdio.h"

#include "fsa.h"


const OLECHAR*
TmFsaRequestActionAsString(
    FSA_REQUEST_ACTION  requestAction
    )

/*++

Routine Description:

    This routine provides a string repesentation (e.g. FSA_REQUSEST_ACTION_MIGRATE) for
    the value of the request action supplied.
    
    NOTE: This method does not support localization of the strings.

Arguments:

    requestAction       - An FSA_REQUEST_ACTION value.

Return Value:

    A string representation of the value of the request action.

--*/
{
    static OLECHAR  returnString[60];

    switch (requestAction) {
    case FSA_REQUEST_ACTION_DELETE:
        swprintf(returnString, OLESTR("FSA_REQUEST_ACTION_DELETE"));
            break;
    case FSA_REQUEST_ACTION_FILTER_RECALL:
        swprintf(returnString, OLESTR("FSA_REQUEST_ACTION_FIILTER_RECALL"));
            break;
    case FSA_REQUEST_ACTION_PREMIGRATE:
        swprintf(returnString, OLESTR("FSA_REQUEST_ACTION_PREMIGRATE"));
            break;
    case FSA_REQUEST_ACTION_RECALL:
        swprintf(returnString, OLESTR("FSA_REQUEST_ACTION_RECALL"));
            break;
    case FSA_REQUEST_ACTION_VALIDATE:
        swprintf(returnString, OLESTR("FSA_REQUEST_ACTION_VALIDATE"));
            break;
    default:
        swprintf(returnString, OLESTR("UNKNOWN FSA_REQUEST_ACTION_?????"));
            break;
    }

    return(returnString);
}


const OLECHAR*
TmFsaResultActionAsString(
    FSA_RESULT_ACTION  resultAction
    )

/*++

Routine Description:

    This routine provides a string repesentation (e.g. FSA_RESULT_ACTION_TRUNCATE) for
    the value of the result action supplied.
    
    NOTE: This method does not support localization of the strings.

Arguments:

    resultAction        - An FSA_RESULT_ACTION value.

Return Value:

    A string representation of the value of the result action.

--*/
{
    static OLECHAR  returnString[60];

    switch (resultAction) {
    case FSA_RESULT_ACTION_NONE:
        swprintf(returnString, OLESTR("FSA_RESULT_ACTION_NONE"));
            break;
    case FSA_RESULT_ACTION_DELETE:
        swprintf(returnString, OLESTR("FSA_RESULT_ACTION_DELETE"));
            break;
    case FSA_RESULT_ACTION_DELETEPLACEHOLDER:
        swprintf(returnString, OLESTR("FSA_RESULT_ACTION_DELETEPLACEHOLDER"));
            break;
    case FSA_RESULT_ACTION_LIST:
        swprintf(returnString, OLESTR("FSA_RESULT_ACTION_LIST"));
            break;
    case FSA_RESULT_ACTION_OPEN:
        swprintf(returnString, OLESTR("FSA_RESULT_ACTION_OPEN"));
            break;
    case FSA_RESULT_ACTION_PEEK:
        swprintf(returnString, OLESTR("FSA_RESULT_ACTION_PEEK"));
            break;
    case FSA_RESULT_ACTION_REPARSE:
        swprintf(returnString, OLESTR("FSA_RESULT_ACTION_REPARSE"));
            break;
    case FSA_RESULT_ACTION_TRUNCATE:
        swprintf(returnString, OLESTR("FSA_RESULT_ACTION_TRUNCATE"));
            break;
    case FSA_RESULT_ACTION_REWRITEPLACEHOLDER:
        swprintf(returnString, OLESTR("FSA_RESULT_ACTION_REWRITEPLACEHOLDER"));
            break;
    case FSA_RESULT_ACTION_RECALLEDDATA:
        swprintf(returnString, OLESTR("FSA_RESULT_ACTION_RECALLEDDATA"));
            break;
    default:
        swprintf(returnString, OLESTR("UNKNOWN FSA_RESULT_ACTION_?????"));
            break;
    }

    return(returnString);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\filter\rpcache.c ===
/*++
Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    RpCache.c

Abstract:

    This module contains the routines for caching no-recall
    data from a file

Author:

    Ravisankar Pudipeddi (ravisp) 8/15/98

Environment:

    Kernel Mode

--*/

#include "pch.h"

#ifdef POOL_TAGGING
   #undef  ExAllocatePool
   #define ExAllocatePool(a, b) ExAllocatePoolWithTag(a, b, RP_CC_TAG)
#endif

//
// Spinlock used to protect assoc. irps list for the IRP
// We choose to use the low contention lock used to protect
// the queue of pending FSA requests
//
extern  KSPIN_LOCK     RsIoQueueLock;

#define RP_CACHE_PARAMETERS_KEY       L"RsFilter\\Parameters"

#define RP_CACHE_DEFAULT_BLOCK_SIZE   65536L
#define RP_CACHE_BLOCK_SIZE_KEY       L"CacheBlockSize"
ULONG   RspCacheBlockSize = RP_CACHE_DEFAULT_BLOCK_SIZE;

#define RP_CACHE_MAX_BUFFERS_SMALL  32L
#define RP_CACHE_MAX_BUFFERS_MEDIUM 48L
#define RP_CACHE_MAX_BUFFERS_LARGE  60L

#define RP_CACHE_MAX_BUFFERS_KEY      L"CacheMaxBuffers"
ULONG   RspCacheMaxBuffers = RP_CACHE_MAX_BUFFERS_SMALL;

#define RP_CACHE_DEFAULT_MAX_BUCKETS  11
#define RP_CACHE_MAX_BUCKETS_KEY      L"CacheMaxBuckets"
ULONG   RspCacheMaxBuckets = RP_CACHE_DEFAULT_MAX_BUCKETS;

#define RP_CACHE_DEFAULT_PREALLOCATE  0
#define RP_CACHE_PREALLOCATE_KEY      L"CachePreallocate"
ULONG   RspCachePreAllocate = RP_CACHE_DEFAULT_PREALLOCATE;

#define RP_NO_RECALL_DEFAULT_KEY      L"NoRecallDefault"
#define RP_NO_RECALL_DEFAULT          0
ULONG   RsNoRecallDefault = RP_NO_RECALL_DEFAULT;


PRP_CACHE_BUCKET RspCacheBuckets;
RP_CACHE_LRU     RspCacheLru;

BOOLEAN          RspCacheInitialized = FALSE;

//
//
// Counters go here
//

//
// Function prototypes go here
//

PRP_FILE_BUF
RsfRemoveHeadLru(
                IN BOOLEAN LruLockAcquired
                );


NTSTATUS
RsGetFileBuffer(
               IN PIRP      Irp,
               IN USN       Usn,
               IN ULONG     VolumeSerial,
               IN ULONGLONG FileId,
               IN ULONGLONG Block,
               IN BOOLEAN   LockPages,
               OUT PRP_FILE_BUF *FileBuf
               );

NTSTATUS
RsReadBlock(
           IN PFILE_OBJECT FileObject,
           IN PIRP         Irp,
           IN USN          Usn,
           IN ULONG        VolumeSerial,
           IN ULONGLONG    FileId,
           IN ULONGLONG    Block,
           IN BOOLEAN      LockPages,
           IN ULONG        Offset,
           IN ULONG        Length
           );

NTSTATUS
RsCacheReadCompletion(
                     IN PDEVICE_OBJECT DeviceObject,
                     IN PIRP  Irp,
                     IN PVOID MasterIrp
                     );

NTSTATUS
RsCacheGetParameters(
                    VOID
                    );


PRP_FILE_BUF
RsCacheAllocateBuffer(
                     VOID
                     );

VOID
RsMoveFileBufferToTailLru(
                         IN PRP_FILE_BUF FileBuf
                         );


NTSTATUS
RsCancelNoRecall(
                IN PDEVICE_OBJECT DeviceObject,
                IN PIRP Irp
                );

NTSTATUS
RsNoRecallMasterIrpCompletion(
                             IN PDEVICE_OBJECT DeviceObject,
                             IN PIRP  Irp,
                             IN PVOID Context
                             );

NTSTATUS
RsCacheSetMasterIrpCancelRoutine(
                                IN PIRP Irp,
                                IN PDRIVER_CANCEL CancelRoutine
                                );


NTSTATUS
RsCacheQueueRequestWithBuffer(
                             IN PRP_FILE_BUF FileBuf,
                             IN PIRP Irp,
                             IN BOOLEAN LockPages
                             );

PIRP
RsCacheGetNextQueuedRequest(
                           IN PRP_FILE_BUF FileBuf
                           );

NTSTATUS
RsCacheCancelQueuedRequest(
                          IN PDEVICE_OBJECT DeviceObject,
                          IN PIRP Irp
                          );
VOID
RsInsertHeadLru(
               IN PRP_FILE_BUF FileBuf
               );
VOID
RsInsertTailLru(
               IN PRP_FILE_BUF FileBuf
               );

VOID
RsRemoveFromLru(
               IN PRP_FILE_BUF FileBuf
               );

#ifdef ALLOC_PRAGMA
   #pragma alloc_text(INIT, RsCacheInitialize)
   #pragma alloc_text(INIT, RsCacheGetParameters)
   #pragma alloc_text(PAGE, RsGetNoRecallData)
   #pragma alloc_text(PAGE, RsReadBlock)
   #pragma alloc_text(PAGE, RsGetFileBuffer)
   #pragma alloc_text(PAGE, RsCacheAllocateBuffer)
   #pragma alloc_text(PAGE, RsCacheFsaIoComplete)
   #pragma alloc_text(PAGE, RsCacheFsaPartialData)
   #pragma alloc_text(PAGE, RsInsertHeadLru)
   #pragma alloc_text(PAGE, RsInsertTailLru)
   #pragma alloc_text(PAGE, RsMoveFileBufferToTailLru)
   #pragma alloc_text(PAGE, RsRemoveFromLru)
   #pragma alloc_text(PAGE, RsfRemoveHeadLru)
#endif


//
// VOID
// RsInitializeFileBuf(
//   IN PRP_FILE_BUF FileBuf,
//   IN PUCHAR       Data
// );
//
#define RsInitializeFileBuf(FileBuf, BufData) {                       \
    RtlZeroMemory((FileBuf), sizeof(RP_FILE_BUF));                    \
       InitializeListHead(&(FileBuf)->WaitQueue);                     \
    InitializeListHead(&(FileBuf)->LruLinks);                         \
    InitializeListHead(&(FileBuf)->BucketLinks);                      \
    ExInitializeResourceLite(&(FileBuf)->Lock);                           \
    (FileBuf)->State = RP_FILE_BUF_INVALID;                           \
    (FileBuf)->Data = BufData;                                        \
}

//
// VOID
// RsReinitializeFileBuf(
//   IN PRP_FILE_BUF FileBuf,
//   IN ULONG        VolumeSerial,
//   IN ULONGLONG    FileId,
//   IN USN          Usn,
//   IN ULONGLONG    Block
// );
//
#define RsReinitializeFileBuf(FileBuf, VolumeSerial, FileId, Usn, Block) { \
    (FileBuf)->VolumeSerial = VolumeSerial;                                \
    (FileBuf)->FileId = FileId;                                            \
    (FileBuf)->Block = Block;                                              \
    (FileBuf)->Usn = Usn;                                                  \
}

//
// VOID
// RsAcquireLru(
//   VOID
// );
//
#define RsAcquireLru()      {                                          \
    ExAcquireFastMutex(&RspCacheLru.Lock);                             \
}

//
// VOID
// RsReleaseLru(
//   VOID
// );
//
#define RsReleaseLru()     {                                            \
    ExReleaseFastMutex(&RspCacheLru.Lock);                              \
}

//
// VOID
// RsAcquireFileBufferExclusive(
//   IN PRP_FILE_BUF FileBuf
// );
//
#define RsAcquireFileBufferExclusive(FileBuf)                      {   \
    FsRtlEnterFileSystem();                                            \
    ExAcquireResourceExclusiveLite(&((FileBuf)->Lock), TRUE);              \
}

//
// VOID
// RsAcquireFileBufferShared(
//   IN PRP_FILE_BUF FileBuf
// );
//
#define RsAcquireFileBufferShared(FileBuf)                         { \
    FsRtlEnterFileSystem();                                          \
    ExAcquireResourceSharedLite(&((FileBuf)->Lock), TRUE);               \
}

//
// VOID
// RsReleaseFileBuffer(
//   IN PRP_FILE_BUF FileBuf
// );
//
#define RsReleaseFileBuffer(FileBuf)                               { \
    ExReleaseResourceLite(&((FileBuf)->Lock));                           \
    FsRtlExitFileSystem();                                           \
}


//
// PRP_FILE_BUF
// RsRemoveHeadLru(
//   IN BOOLEAN LruLockAcquired
// );
//
#define RsRemoveHeadLru(LruLockAcquired)    RsfRemoveHeadLru(LruLockAcquired)

//
// VOID
// RsInsertTailCacheBucket(
//   IN PRP_CACHE_BUCKET Bucket,
//   IN PRP_FILE_BUF     Block
// );
//
#define RsInsertTailCacheBucket(Bucket, Block)                       \
    InsertTailList(&((Bucket)->FileBufHead), &((Block)->BucketLinks))
//
// VOID
// RsRemoveFromCacheBucket(
//   IN PRP_FILE_BUF Block
// );
//
#define RsRemoveFromCacheBucket(Block)                               \
    RemoveEntryList(&((Block)->BucketLinks))

//
// VOID
// RsCacheIrpSetLockPages(
//  IN PIRP Irp,
//  IN BOOLEAN LockPages
// );
// /*++
//
//  Routine Description
//
//  Sets driver context state in the supplied IRP to indicate
//  whether the user buffer pages need to be locked before transferring
//  data or not
//
// --*/
//
#define RsCacheIrpSetLockPages(Irp, LockPages)                     { \
    if (LockPages) {                                                 \
       (Irp)->Tail.Overlay.DriverContext[1] = (PVOID) 1;             \
    } else {                                                         \
       (Irp)->Tail.Overlay.DriverContext[1] = (PVOID) 0;             \
    }                                                                \
}

//
// BOOLEAN
// RsCacheIrpGetLockPages(
//  IN PIRP  Irp
// );
// /*++
//
//  Routine Description
//
//  Retreives the driver context state from the IRP indicating whether
//  user buffer pages need to be locked before transferrring data or not
//
// --*/
//
#define RsCacheIrpGetLockPages(Irp)                                  \
      ((Irp)->Tail.Overlay.DriverContext[1] == (PVOID) 1)

//
// PLIST_ENTRY
// RsCacheIrpWaitQueueEntry(
//   IN PIRP Irp
// );
//
// /*++
//
// Routine Description
//
//   Returns the LIST_ENTRY in the IRP which is used to queue the
//   IRPs in the wait queue for a cache block
//
// --*/
//
#define RsCacheIrpWaitQueueEntry(Irp)                                \
    ((PLIST_ENTRY) &((Irp)->Tail.Overlay.DriverContext[2]))

//
// PIRP
// RsCacheIrpWaitQueueContainingIrp(
//   IN PLIST_ENTRY Entry
// );
//
// /*++
//
// Routine Description
//
//   Returns the containing IRP for the passed in LIST_ENTRY structure
//   which is used to queue the IRP in the wait queue for a cache-block
//
// --*/
//
#define RsCacheIrpWaitQueueContainingIrp(Entry)                      \
    CONTAINING_RECORD(Entry,                                         \
                      IRP,                                           \
                      Tail.Overlay.DriverContext[2])

VOID
RsInsertHeadLru(
               IN PRP_FILE_BUF FileBuf
               )
/*++

Routine Description

    Inserts the specified block at the head of the LRU

Arguments

    FileBuf - Pointer to cache block

Return value

    None
--*/
{
   PAGED_CODE();

   InsertHeadList(&RspCacheLru.FileBufHead,
                  &((FileBuf)->LruLinks));
   RspCacheLru.LruCount++;
   ASSERT (RspCacheLru.LruCount <= RspCacheLru.TotalCount);
   //
   // One more buffer added to LRU. Bump the semaphore count
   //
   KeReleaseSemaphore(&RspCacheLru.AvailableSemaphore,
                      IO_NO_INCREMENT,
                      1L,
                      FALSE);
}


VOID
RsInsertTailLru(
               IN PRP_FILE_BUF FileBuf
               )
/*++

Routine Description

    Inserts the specified block at the tail of the LRU

Arguments

    FileBuf - Pointer to cache block

Return value

    None
--*/
{

   PAGED_CODE();

   InsertTailList(&RspCacheLru.FileBufHead,
                  &((FileBuf)->LruLinks));
   RspCacheLru.LruCount++;

   ASSERT (RspCacheLru.LruCount <= RspCacheLru.TotalCount);
   //
   // One more buffer added to LRU. Bump the semaphore count
   //
   KeReleaseSemaphore(&RspCacheLru.AvailableSemaphore,
                      IO_NO_INCREMENT,
                      1L,
                      FALSE);
}


VOID
RsMoveFileBufferToTailLru(
                         IN PRP_FILE_BUF FileBuf
                         )
/*++

Routine Description

    Moves the specified block to end of the LRU,
    *if* it is on the LRU currently.

Arguments

    FileBuf - Pointer to the cache block


Return value

    None
--*/
{
   PAGED_CODE();

   if ((FileBuf)->LruLinks.Flink != &((FileBuf)->LruLinks)) {
      RemoveEntryList(&((FileBuf)->LruLinks));
      InsertTailList(&RspCacheLru.FileBufHead,
                     &((FileBuf)->LruLinks));
   }
}


VOID
RsRemoveFromLru(
               IN PRP_FILE_BUF FileBuf
               )
/*++

Routine Description

    Removes the specified block from th LRU,
    *if* it is on the LRU currently.

Arguments

    FileBuf - Pointer to the cache block


Return value

    None
--*/
{
   PAGED_CODE();

   if (FileBuf->LruLinks.Flink != &FileBuf->LruLinks) {
      LARGE_INTEGER timeout;
      NTSTATUS      status;

      //
      // This is getting bumped off the LRU
      //
      RspCacheLru.LruCount--;
      //
      // Adjust the semaphore count
      //
      timeout.QuadPart = 0;
      status =  KeWaitForSingleObject(&RspCacheLru.AvailableSemaphore,
                                      UserRequest,
                                      KernelMode,
                                      FALSE,
                                      &timeout);

      ASSERT (status == STATUS_SUCCESS);
   }
   RemoveEntryList(&(FileBuf->LruLinks));
}


PRP_FILE_BUF
RsfRemoveHeadLru(IN BOOLEAN LruLockAcquired)

/*++

Routine Description

    Returns the buffer at the  head of the LRU list,
    Also resets the links of the buffer to point to itself
    - this is done so that this buffer would not be
    found later on a bucket and moved to the end of the
    list, before it gets added to the LRU


Arguments

    LruLockAcquired  - TRUE if LRU lock was acquired - in which case
                       we do not acquire/release the lock

                       FALSE if it was not in which we acquire and release
                       before returning as appropriate
Return Value

   Pointer to buffer at the head of LRU if LRU is not empty
   NULL if LRU is empty

--*/
{
   PLIST_ENTRY  entry;
   PRP_FILE_BUF fileBuf;

   PAGED_CODE();

   if (!LruLockAcquired) {
      RsAcquireLru();
   }

   entry = NULL;

   if (RspCacheLru.TotalCount < RspCacheMaxBuffers) {
      //
      // We can afford to allocate another
      //
      PRP_FILE_BUF buffer;

      buffer = RsCacheAllocateBuffer();

      if (buffer) {
         //
         // Got a buffer ..
         //
         entry = &buffer->LruLinks;
         RspCacheLru.TotalCount++;
      }
   }

   if (entry != NULL) {
      //
      // Release LRU if necessary
      //
      if (!LruLockAcquired) {
         RsReleaseLru();
      }
      return CONTAINING_RECORD(entry,
                               RP_FILE_BUF,
                               LruLinks);
   }

   if (IsListEmpty(&RspCacheLru.FileBufHead)) {
      //
      // No more free buffers..
      //
      if (!LruLockAcquired) {
         RsReleaseLru();
      }
      return NULL;
   }

   entry = RemoveHeadList(&RspCacheLru.FileBufHead);
   //
   // Important: reset entry's links
   //
   entry->Flink = entry->Blink = entry;

   fileBuf = CONTAINING_RECORD(entry,
                               RP_FILE_BUF,
                               LruLinks);

   //
   // If somebody is using the buffer right now (copying contents),
   // this will block till they are done with it
   //
   RsAcquireFileBufferExclusive(fileBuf);

   fileBuf->State = RP_FILE_BUF_INVALID;

   RsReleaseFileBuffer(fileBuf);
   //
   // Adjust count of buffers in LRU
   //
   ASSERT(RspCacheLru.LruCount > 0);
   RspCacheLru.LruCount--;

   if (!LruLockAcquired) {
      RsReleaseLru();
   }
   return fileBuf;
}


/*++
ULONG
RsHashFileBuffer(
                IN ULONG     VolumeSerial,
                IN ULONGLONG FileId,
                IN ULONGLONG Block
                )

Routine Description

    Hashes the supplied values and returns
    a value in the range 0 - (RspCacheMaxBuffers - 1)

Arguments

   VolumeSerial   - Volume serial number of the volume the file resides on
   FileId         - file id no. of the file
   Block          - Number of the block being hashed

Return Value

   Value in the range of 0 - (RspCacheMaxBuckets - 1)


--*/

#define RsHashFileBuffer(VolumeSerial, FileId, Block)   \
                       ((ULONG) ((Block) % RspCacheMaxBuckets))


NTSTATUS
RsGetNoRecallData(
                 IN PFILE_OBJECT FileObject,
                 IN PIRP         Irp,
                 IN USN          Usn,
                 IN LONGLONG     FileOffset,
                 IN LONGLONG     Length,
                 IN PUCHAR       UserBuffer)

/*++

Routine Description

   This is the entry point for the IRP_MJ_READ dispatch, which
   is called when it is concluded that user is requesting a no-recall read.
   This would dispatch the appropriate requests to read the requested data
   from cache (or from tape if it's not cached yet)

Arguments

   FileObject     -     Pointer to the file object for the file
   Irp            -     Original IRP requesting read
   Usn            -     Usn number of the file
   FileOffset     -     Offset in the file from which to read
   Length         -     Length of data to read
   UserBuffer     -     Buffer into which read data needs to be copied

Return value

   STATUS_PENDING       - If i/o is under progress to satisfy the read
   STATUS_SUCCESS       - If read was satisfied entirely from the cache
   Any other status     - Some error occurred

--*/
{

   PRP_FILTER_CONTEXT       filterContext;
   PRP_FILE_OBJ             entry;
   PRP_FILE_CONTEXT         context;
   ULONGLONG                startBlock, endBlock, blockNo;
   LONGLONG                 offset, length, userBufferOffset, userBufferLength;
   LONGLONG                 transferredLength;
   ULONG                    associatedIrpCount;
   PIRP                     irp;
   PIO_STACK_LOCATION       irpSp;
   ULONG                    volumeSerial;
   ULONGLONG                fileId;
   LONGLONG                 fileSize;
   PRP_NO_RECALL_MASTER_IRP readIo;
   PLIST_ENTRY              listEntry;
   NTSTATUS  status;

   PAGED_CODE();

   filterContext = (PRP_FILTER_CONTEXT) FsRtlLookupPerStreamContext(FsRtlGetPerStreamContextPointer(FileObject), FsDeviceObject, FileObject);

   if (filterContext == NULL) {
      //
      // Not found
      return STATUS_NOT_FOUND;
   }

   entry = (PRP_FILE_OBJ) filterContext->myFileObjEntry;
   context = entry->fsContext;

   RsAcquireFileContextEntryLockShared(context);

   fileSize = (LONGLONG) context->rpData.data.dataStreamSize.QuadPart;

   RsReleaseFileContextEntryLock(context);

   //
   // Check if  read is  beyond end of file
   //
   if (FileOffset >= fileSize) {
      return STATUS_END_OF_FILE;
   }

   //
   // Negative offsets are not allowed
   //
   if (FileOffset < 0) {
      return STATUS_INVALID_PARAMETER;
   }

   if ((FileOffset + Length) > fileSize) {
      //
      // Adjust the length so we don't go past the end of the file
      //
      Length = fileSize - FileOffset;
   }

   //
   // If it's  zero length read, complete immediately
   //
   if (Length == 0) {
      Irp->IoStatus.Information = 0;
      return STATUS_SUCCESS;
   }

   volumeSerial = context->serial;
   fileId       = context->fileId;


   startBlock = FileOffset / RspCacheBlockSize;
   endBlock = (FileOffset + Length - 1) / RspCacheBlockSize;

   //
   // We satisfy the user request by breaking it up into
   // blocks of RspCacheBlockSize each.
   // An associated irp is created for each of these sub-transfers
   // and posted.
   // The master IRP will complete when all the associated ones do
   //

   readIo = ExAllocatePoolWithTag(NonPagedPool,
                                  sizeof(RP_NO_RECALL_MASTER_IRP),
                                  RP_RQ_TAG);

   if (readIo == NULL) {
       return  STATUS_INSUFFICIENT_RESOURCES;
   }

   readIo->MasterIrp = Irp;

   InitializeListHead(&readIo->AssocIrps);

   Irp->Tail.Overlay.DriverContext[0] = readIo;

   try {

      associatedIrpCount = 0;
      userBufferOffset = 0;
      userBufferLength = 0;
      transferredLength = 0;

      for (blockNo = startBlock; blockNo <= endBlock; blockNo++) {
         //
         // Create an associated irp  for this read block request
         // We only need 2 stack locations, for this irp.
         // this IRP is never going to go down the stack
         // However we simulate one IoCallDriver
         // (to let IoCompletion take its normal course)
         // so we need one stack location for us & one for the
         // 'logically next device'
         //
         irp = IoMakeAssociatedIrp(Irp,
                                   2);

         if (irp == NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            return status;
         }

         associatedIrpCount++;
         InsertTailList(&readIo->AssocIrps, &irp->Tail.Overlay.ListEntry);
         //
         // Set the IRP to the first valid stack location
         //
         IoSetNextIrpStackLocation(irp);

         //
         // Fill the current stack loc. with the relevant paramters
         //
         irpSp = IoGetCurrentIrpStackLocation(irp);
         irpSp->MajorFunction = IRP_MJ_READ;
         irpSp->FileObject = FileObject;
         irpSp->DeviceObject = FsDeviceObject;


         irp->RequestorMode = Irp->RequestorMode;

         if (Irp->Flags & IRP_PAGING_IO) {
            //
            // Propogate the paging io flag to the associated irps so
            // completion in RsCompleteRead will be handled properly
            //
            irp->Flags |= IRP_PAGING_IO;
         }

         //
         // Compute the offset and lengths witin the user buffer chunk
         // that we will do the transfer to for this block
         // These will be stored in userBufferOffset and userBufferLength respectively
         // We also compute the actual transfer parameters to the user buffer from
         // the read tape block (the real transfer is from offset blockNo*RspCacheBlockSize
         // of length RspCacheBlockSize). By actual we mean the portion of the real transfer
         // that we actually copy to the user buffer. These are stored in the
         // irp read parameter block.
         //
         if (blockNo == startBlock) {
            userBufferOffset = 0;
            //
            // Length of transfer is the rest of the block or the original length, whichever is lesser
            //
            userBufferLength = MIN(Length, (RspCacheBlockSize - (FileOffset % RspCacheBlockSize)));

            irpSp->Parameters.Read.ByteOffset.QuadPart = FileOffset;
            irpSp->Parameters.Read.Length = (ULONG) userBufferLength;
         } else if (blockNo == endBlock) {
            //
            // add previous length to the offset to get new offset
            //
            userBufferOffset += userBufferLength;
            //
            // For the last block, the length of the transfer would be
            // Length - (length already transferred)
            //
            userBufferLength = (Length - transferredLength);
            irpSp->Parameters.Read.ByteOffset.QuadPart = blockNo*RspCacheBlockSize;
            irpSp->Parameters.Read.Length = (ULONG) userBufferLength;

         } else {
            //
            // add previous length to the offset to get new offset
            //
            userBufferOffset += userBufferLength;
            //
            // Length of transfer for in-between blocks is blocksized
            //
            userBufferLength = RspCacheBlockSize;
            irpSp->Parameters.Read.ByteOffset.QuadPart = blockNo*RspCacheBlockSize;
            irpSp->Parameters.Read.Length = (ULONG) userBufferLength;
         }

         transferredLength += userBufferLength;
         //
         // The buffer for this particular associated IRP starts at the
         // originally supplied buffer + the user buffer offset as calculated above.
         // the length is in irp->Parameters.Read.Length (as well as userBufferLength)
         //
         if (UserBuffer == NULL) {
            //
            // We need to get an MDL for the user buffer (this is not paging i/o,
            // so the pages are not locked down)
            //
            ASSERT (Irp->UserBuffer);

            irp->UserBuffer = (PUCHAR)Irp->UserBuffer + userBufferOffset;
            irp->MdlAddress = IoAllocateMdl(irp->UserBuffer,
                                            (ULONG) userBufferLength,
                                            FALSE,
                                            FALSE,
                                            NULL) ;
            if (!irp->MdlAddress) {
               //
               // A resource problem has been encountered. Set appropriate status
               // in the Irp, and begin the completion process.
               //
               DebugTrace((DPFLTR_RSFILTER_ID,DBG_ERROR, "RsFilter: RsGetNoRecallData Unable to allocate an MDL for user buffer %x\n", (PUCHAR) Irp->UserBuffer+userBufferOffset));

               ExFreePool(readIo);

               Irp->IoStatus.Information = 0 ;
               status = STATUS_INSUFFICIENT_RESOURCES;
               return status;
            }
         } else {
            //
            //  The supplied user buffer is the system address of an already locked down
            //  pages. Just use it...
            //
            irp->UserBuffer = (PUCHAR)UserBuffer + userBufferOffset;
         }
      }

      //
      // Set the associated Irp count to one more than what it should be
      // this is to guard against the case where all the associated irps
      // complete in the loop below
      //
      Irp->AssociatedIrp.IrpCount =  (ULONG) ((endBlock - startBlock) + 2);
      //
      // Now all the associated irps are created, dispatch them off to recall the data
      //
      // Start with SUCCESS in master irp.
      // assoc. irps will update the status if necessary
      // in their completion routines
      //

      Irp->IoStatus.Status = STATUS_SUCCESS;
      status = STATUS_SUCCESS;

      IoSetCompletionRoutine(Irp,
                             &RsNoRecallMasterIrpCompletion,
                             readIo,
                             TRUE,
                             TRUE,
                             TRUE);


      IoSetNextIrpStackLocation(Irp);

      for (blockNo = startBlock; blockNo <= endBlock;  blockNo++) {

         BOOLEAN lockPages;

         irp = (PIRP) ExInterlockedRemoveHeadList(&readIo->AssocIrps,
                                                  &RsIoQueueLock);

         ExInterlockedInsertTailList(&readIo->AssocIrps,
                                     (PLIST_ENTRY) irp,
                                     &RsIoQueueLock);

         irp   = CONTAINING_RECORD(irp,
                                   IRP,
                                   Tail.Overlay.ListEntry);

         irpSp = IoGetCurrentIrpStackLocation(irp);

         //
         // If user passed in a valid pointer for UserBuffer,
         // it means the pages are already locked down.
         // if not we would need to lock them  when the
         // data transfer takes place, in RsPartialData
         //
         lockPages = (UserBuffer == NULL)?TRUE:FALSE;
         //
         // Since we are going to set a completion routine and
         // simulate an IoCallDriver, copy the parameters to the
         // the next stack location
         //
         IoCopyCurrentIrpStackLocationToNext(irp);
         IoSetCompletionRoutine(irp,
                                &RsCacheReadCompletion,
                                Irp,
                                TRUE,
                                TRUE,
                                TRUE);

         //
         // Simulate an IoCallDriver on the irp
         // before calling RsReadBlock
         //
         IoSetNextIrpStackLocation(irp);
         //
         // Dispatch to block read with real offset and length within the cache
         // block buffer that the copy takes place.
         // The real byte offset is in irpSp->Parameters.Read.ByteOffset
         // This modulo the block size is the relative offset within the block
         // The length is of course already calculated, in 
         // irpSp->Parameters.Read.Length
         //
         RsReadBlock(FileObject,
                     irp,
                     Usn,
                     volumeSerial,
                     fileId,
                     blockNo,
                     lockPages,
                     (ULONG) (irpSp->Parameters.Read.ByteOffset.QuadPart % (ULONGLONG) RspCacheBlockSize),
                     irpSp->Parameters.Read.Length);
      }
   } finally {
      //
      // Cleanup assoc. irps that we created if necessary
      //
      if (status != STATUS_SUCCESS) {
         //
         // If we get here, none of the assoc IRPs were dispatched
         //
         ASSERT (readIo != NULL);

         while (!IsListEmpty(&readIo->AssocIrps)) {

            listEntry = RemoveHeadList(&readIo->AssocIrps);

            ASSERT (listEntry != NULL);

            irp = CONTAINING_RECORD(listEntry,
                                    IRP,
                                    Tail.Overlay.ListEntry);
            if ((UserBuffer == NULL) && irp->MdlAddress) {
               IoFreeMdl(irp->MdlAddress);
            }
            IoFreeIrp(irp);
         }
         ExFreePool(readIo);
      }
   }
   //
   // All the assoc irps are dispatched:
   // now we can set the cancel routine for this IRP
   //
   status = RsCacheSetMasterIrpCancelRoutine(Irp,
                                             RsCancelNoRecall);
   return status;
}


NTSTATUS
RsCacheSetMasterIrpCancelRoutine(
                                IN  PIRP Irp,
                                IN  PDRIVER_CANCEL CancelRoutine)
/*++

Routine Description:

    This routine is called to set up an Irp for cancel.  We will set the cancel routine
    and initialize the Irp information we use during cancel.

Arguments:

    Irp - This is the Irp we need to set up for cancel.

    CancelRoutine - This is the cancel routine for this irp.


Return Value:

    STATUS_PENDING   - the cancel routine was set

    STATUS_CANCELLED - The Cancel flag was set in the IRP , so the IRP should
                       be completed as cancelled. The cancel routine will not
                       be set in this case

    Any other status - All the associated IRPs have already completed so
                       the master IRP should be completed with this status.
                       The cancel routine will not be set in this case
--*/
{

   KIRQL    irql;
   NTSTATUS status;
   //
   //  Assume that the Irp has not been cancelled.
   //
   IoAcquireCancelSpinLock( &irql );

   if (!Irp->Cancel) {
      //
      // decrease the associated irp count back again
      //
      if (InterlockedDecrement((PLONG) &Irp->AssociatedIrp.IrpCount) == 0) {
         //
         // All the assoc irps have already completed.
         status =  Irp->IoStatus.Status;
      } else {
         IoMarkIrpPending( Irp );
         IoSetCancelRoutine( Irp, CancelRoutine );
         status =  STATUS_PENDING;
      }
   } else {
      status = STATUS_CANCELLED;
   }

   IoReleaseCancelSpinLock( irql );
   return status;
}


NTSTATUS
RsCancelNoRecall(
                IN PDEVICE_OBJECT DeviceObject,
                IN PIRP Irp
                )
/*++

Routine Description:

    This function filters cancels an outstanding read-no-recall master AND associated IRPs

Arguments:

    DeviceObject - Pointer to the target device object of the create/open.

    Irp - Pointer to the I/O Request Packet that represents the operation.

Return Value:

    The function value is the status of the call to the file system's entry
    point.

--*/
{
   PRP_NO_RECALL_MASTER_IRP readIo;
   PLIST_ENTRY              entry;
   PIRP                     assocIrp;

   UNREFERENCED_PARAMETER(DeviceObject);

   //
   // Bump the associated irp count so that the master IRP
   // doesn't complete automatically
   //
   InterlockedIncrement(&Irp->AssociatedIrp.IrpCount);

   IoReleaseCancelSpinLock(Irp->CancelIrql);

   readIo = Irp->Tail.Overlay.DriverContext[0];
   ASSERT (readIo != NULL);


   entry = ExInterlockedRemoveHeadList(&readIo->AssocIrps,
                                       &RsIoQueueLock);
   while (entry != NULL) {
      assocIrp = CONTAINING_RECORD(entry,
                                   IRP,
                                   Tail.Overlay.ListEntry);
      IoCancelIrp(assocIrp);
      entry = ExInterlockedRemoveHeadList(&readIo->AssocIrps,
                                          &RsIoQueueLock);

   }
   //
   // The master IRP needs to be completed now
   //
   ASSERT (Irp->AssociatedIrp.IrpCount >= 1);
   IoCompleteRequest(Irp, IO_NO_INCREMENT);

   return STATUS_SUCCESS;
}


NTSTATUS
RsCacheReadCompletion(
                     IN PDEVICE_OBJECT DeviceObject,
                     IN PIRP  Irp,
                     IN PVOID Context
                     )
/*++

Routine Description

   This is the completion routine for each of the associated IRPs created
   to satisfy the original Master Irp for reading no-recall data
   This would update the master IRP status, Information as necessary

Arguments

   DeviceObject      - Not used
   Irp               - Pointer to the assoc. IRP being completed
   Context           - Pointer to the master irp

Return Value

   STATUS_SUCCESS

--*/
{
   PIRP                     assocIrp, masterIrp = (PIRP) Context;
   PLIST_ENTRY              entry;
   PRP_NO_RECALL_MASTER_IRP readIo;
   KIRQL                    oldIrql;

   UNREFERENCED_PARAMETER(DeviceObject);


   if (!NT_SUCCESS(Irp->IoStatus.Status)) {
      ((PIRP)(masterIrp))->IoStatus.Status = Irp->IoStatus.Status;
   } else {
      //
      // Update the read bytes count
      //
      ASSERT (masterIrp == Irp->AssociatedIrp.MasterIrp);

      InterlockedExchangeAdd((PLONG)&(((PIRP)(masterIrp))->IoStatus.Information),
                             (LONG)Irp->IoStatus.Information);
   }
   

   //
   // Extract the master irp structure
   //
   readIo = masterIrp->Tail.Overlay.DriverContext[0];

   ASSERT (readIo != NULL);

   ExAcquireSpinLock(&RsIoQueueLock,
                     &oldIrql);
   //
   // Iterate here to find the assoc irp and remove it
   //
   entry = readIo->AssocIrps.Flink;

   while ( entry != &readIo->AssocIrps) {
      assocIrp = CONTAINING_RECORD(entry,
                                   IRP,
                                   Tail.Overlay.ListEntry);
      if (Irp == assocIrp) {
         RemoveEntryList(entry);
         break;
      }
      entry = entry->Flink;
   }

   if (IsListEmpty(&(readIo->AssocIrps))) {
        //
        // Clear the master IRP cancel routine
        //
        RsClearCancelRoutine(masterIrp);
   }

   ExReleaseSpinLock(&RsIoQueueLock,
                     oldIrql);

   if (Irp->PendingReturned) {
      IoMarkIrpPending( Irp );
   }
   return STATUS_SUCCESS;
}


NTSTATUS
RsNoRecallMasterIrpCompletion(
                             IN PDEVICE_OBJECT DeviceObject,
                             IN PIRP  Irp,
                             IN PVOID Context)
/*++

Routine Description

   This is the completion routine for master Irp for reading no-recall data

Arguments

   DeviceObject      - Not used
   Irp               - Pointer to the assoc. IRP being completed
   Context           - Pointer to the internal structure tracking the master &
                       associated irps.

Return Value

   STATUS_SUCCESS

--*/
{
   PRP_NO_RECALL_MASTER_IRP readIo = (PRP_NO_RECALL_MASTER_IRP) Context;
   PLIST_ENTRY entry;
   PIRP assocIrp;


   ASSERT (Irp->Tail.Overlay.DriverContext[0] == (PVOID) readIo);

   if (readIo != NULL) {
      //
      // Cancel the associated IRPs if they are still around
      //
      entry = ExInterlockedRemoveHeadList(&readIo->AssocIrps,
                                          &RsIoQueueLock);
      while (entry != NULL) {
         assocIrp = CONTAINING_RECORD(entry,
                                      IRP,
                                      Tail.Overlay.ListEntry);
         IoCancelIrp(assocIrp);
         entry = ExInterlockedRemoveHeadList(&readIo->AssocIrps,
                                             &RsIoQueueLock);

      }
      ExFreePool(readIo);
   }

   if (Irp->PendingReturned) {
      IoMarkIrpPending( Irp );
   }

   return STATUS_SUCCESS;
}


NTSTATUS
RsReadBlock(
           IN PFILE_OBJECT FileObject,
           IN PIRP         Irp,
           IN USN          Usn,
           IN ULONG        VolumeSerial,
           IN ULONGLONG    FileId,
           IN ULONGLONG    Block,
           IN BOOLEAN      LockPages,
           IN ULONG        Offset,
           IN ULONG        Length)
/*++

Routine Description

   Reads the requested block of data into the UserBuffer from the cache.
   If this block is not cached, it queues a no-recall with the fsa to fetch
   the data off the storage.
   The completion processing for the no-recall request would fill the
   UserBuffer and the cache block

Arguments

   FileObject   - Pointer to the file object of the file
   Irp          - Pointer to the associated irp for this block read
   Usn          - Usn of the file
   VolumeSerial - Volume serial number of the volume on which the file resides
   FileId       - File Id of the file
   Block        - Block number of the block that needs to be read
   LockPages    - Specifies if user buffer pages need to be locked down before copying
   Offset       - Offset  in the block from which to copy (0 <= Offset < RspCacheBlockSize)
   Length       - Length to copy ( <= RspCacheBlockSize)

Return value

    STATUS_SUCCESS      - Irp was completed successfully
    STATUS_PENDING      - I/O for the block was initiated and the Irp was
                          queued for completion after i/o finishes
    Any other status    - Some error occurred and Irp was completed with this status


--*/
{
   PRP_FILE_BUF         fileBuf = NULL;
   NTSTATUS             status = STATUS_SUCCESS;

   PAGED_CODE();

   //
   // Ensure caller isn't trying to bite more
   // than he can chew
   //
   ASSERT((Offset+Length) <= RspCacheBlockSize);

   status = RsGetFileBuffer(Irp,
                            Usn,
                            VolumeSerial,
                            FileId,
                            Block,
                            LockPages,
                            &fileBuf);

   switch (status) {

   case STATUS_SUCCESS: {
         //
         // Buffer containing valid data found in the cache
         // Complete the request here by copying the data directly
         //
         BOOLEAN unlock = FALSE;
         PUCHAR  userBuffer;

         ASSERT (fileBuf && (fileBuf->State == RP_FILE_BUF_VALID));

         status = STATUS_SUCCESS;

         if (LockPages) {
            //
            // We need to lock the pages before copying
            //
            try {
               MmProbeAndLockProcessPages (Irp->MdlAddress,
                                           IoGetRequestorProcess(Irp),
                                           Irp->RequestorMode,
                                           IoModifyAccess) ;       // Modifying the buffer
               //
               // Indicate that we would need to get the pages unlocked
               // after copying
               //
               unlock = TRUE;
            }except (EXCEPTION_EXECUTE_HANDLER) {

               //
               // Something serious went wrong. Free the Mdl, and complete this
               // Irp will some meaningful sort of error.
               //
               DebugTrace((DPFLTR_RSFILTER_ID,DBG_ERROR, "RsFilter: Unable to lock read buffer!.\n"));
               RsLogError(__LINE__, AV_MODULE_RPCACHE, 0,
                          AV_MSG_NO_BUFFER_LOCK, NULL, NULL);
               status = STATUS_INVALID_USER_BUFFER;

            }
            if (NT_SUCCESS(status)) {
               userBuffer = MmGetSystemAddressForMdlSafe(Irp->MdlAddress,
                                                         NormalPagePriority) ;
               if (userBuffer == NULL) {
                  status = STATUS_INSUFFICIENT_RESOURCES;
               }
            }
         } else {
            //
            // The supplied UserBuffer in the IRP is the system address of
            // already locked down pages - we can directly access it
            //
            userBuffer = Irp->UserBuffer;
         }

         if (NT_SUCCESS(status)) {
            BOOLEAN synchronousIo;

            RtlCopyMemory(userBuffer, fileBuf->Data+Offset, Length);
            synchronousIo = BooleanFlagOn(FileObject->Flags, FO_SYNCHRONOUS_IO );
            Irp->IoStatus.Information += Length;

            if (synchronousIo) {
               //
               // Change the current byte offset in the file object
               // Use interlocked add because the associated IRPs can
               // complete in any order
               //
               ExInterlockedAddLargeStatistic(&FileObject->CurrentByteOffset,
                                              (ULONG)Irp->IoStatus.Information);
            }

         }

         if (unlock) {
            //
            // Unlock any pages we locked...
            //
            MmUnlockPages(Irp->MdlAddress);
            IoFreeMdl(Irp->MdlAddress);
            Irp->MdlAddress = NULL;
         }
         RsReleaseFileBuffer(fileBuf);
         Irp->IoStatus.Status = status;
         IoCompleteRequest(Irp, IO_NO_INCREMENT);
         break;
      }

   case STATUS_WAIT_63 :
      //
      // Fall through deliberately
      //
   case STATUS_TIMEOUT: {
         //
         // Buffer was not found - so a new buffer
         // was allocated for us to initiate i/o on.
         // OR buffer was found but previous attempt at i/o failed
         // This latter case is treated the same as if the
         // buffer was not found.
         // OR we are doing a non-cached no-recall read
         // Queue a no-recall with the FSA for this.
         //
         ASSERT ((fileBuf == NULL)  || (fileBuf->State == RP_FILE_BUF_IO));
         status = RsQueueNoRecall(FileObject,
                                  Irp,
                                  Block*RspCacheBlockSize,
                                  RspCacheBlockSize,
                                  Offset,
                                  Length,
                                  fileBuf,
                                  //
                                  // RsQueueNoRecall expects the buffer to be NULL
                                  // (and a valid Irp->MdlAddress) if the pages needed
                                  // to be locked down - if not it uses the
                                  // supplied buffer pointer to copy the data to.
                                  //
                                  (LockPages) ? NULL: Irp->UserBuffer);

         if (!NT_SUCCESS(status)) {
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
         }
         break;
      }

   case STATUS_PENDING: {
         //
         // IRP was queued on to a block with i/o in progress
         // Just return
         //
         break;
      }

   default : {
         //
         // Some unknown error Complete the IRP and return
         //

         Irp->IoStatus.Status = status;
         Irp->IoStatus.Information = 0;
         IoCompleteRequest(Irp, IO_NO_INCREMENT);
         break;
      }
   }
   return status;
}


NTSTATUS
RsGetFileBuffer(
               IN  PIRP         Irp,
               IN  USN          Usn,
               IN  ULONG        VolumeSerial,
               IN  ULONGLONG    FileId,
               IN  ULONGLONG    Block,
               IN  BOOLEAN      LockPages,
               OUT PRP_FILE_BUF *FileBuf
               )
/*++

Routine Description

    Locates and returns a locked buffer corresponding to the supplied
    volume/file/block ids.
    It's up to the calling routine to check if the buffer contains valid
    data - and if not to initiate i/o.
    In either case the caller is expected to release the buffer once
    it's done with it.

Arguments

    Usn           - USN of the file
    VolumeSerial  - Volume serial number of the volume on which the file resides
    FileId        - File id of the file
    Block         - Block number mapped to the buffer
    FileBuf       _ If return value is STATUS_SUCCESS, pointer to the locked buffer
                    for the block if the contents are valid is returned here -
                    if not, pointer to a free buffer on which i/o needs to be done

Return Value

    STATUS_SUCCESS  - FileBuf contains the pointer to the block with valid contents
                      In this case the block will be acquired shared
    STATUS_PENDING -  I/O had already begun on the block.
                      Hence this routine queues the new request to the block and returns this status
    STATUS_WAIT_63  - For lack of a better success status value. FileBuf contains the pointer to the
                      block on which I/O needs to be initiated. The block is removed from the LRU
    STATUS_TIMEOUT  - Timed out waiting for free buffer, *FileBuf will set to NULL

    STATUS_CANCELLED - The IRP was cancelled
--*/
{
   ULONG   bucketNumber;
   PRP_CACHE_BUCKET bucket;
   PRP_FILE_BUF  block;
   NTSTATUS status;
   BOOLEAN found;

   PAGED_CODE();

   //
   // Locate the bucket in which this block should reside
   //
   bucketNumber = RsHashFileBuffer(VolumeSerial, FileId, Block);

   bucket = &RspCacheBuckets[bucketNumber];
   //
   // Traverse the queue to find the block
   //
   found   = FALSE;

   RsAcquireLru();

   block = CONTAINING_RECORD(bucket->FileBufHead.Flink,
                             RP_FILE_BUF,
                             BucketLinks);

   while (block != CONTAINING_RECORD(&bucket->FileBufHead,
                                     RP_FILE_BUF,
                                     BucketLinks)) {
      if (block->FileId == FileId &&
          block->VolumeSerial == VolumeSerial &&
          block->Block == Block) {
         found = TRUE;
         break;
      }
      block = CONTAINING_RECORD(block->BucketLinks.Flink,
                                RP_FILE_BUF,
                                BucketLinks);
   }

   if (found) {
      //
      // We found the buffer corresponding to the block
      // Now we have 5 possible cases
      // 1. The buffer is busy - i.e. there's i/o in progress
      //    to fill the buffer with the block contents
      //    In this case, we unlock the bucket, wait for the
      //    i/o to complete and go back to try and find the block
      //
      // 2. I/O is completed on the buffer  successfully
      //    we move the buffer to the tail of the LRU if it was on the
      //    LRU, lock the buffer, unlock the queue and return
      //
      // 3. The buffer was found but the contents are stale
      //
      // 4. I/O completed with errors
      //
      // 5. The buffer contents are simply invalid and i/o needs to be initiated
      //
      if (block->State == RP_FILE_BUF_IO) {
         //
         // Case 1: Queue this request with the block and return
         //
         status = RsCacheQueueRequestWithBuffer(block,
                                                Irp,
                                                LockPages);
         if (status == STATUS_PENDING) {
            //
            // Queued successfully
            // Indicate i/o is in progress
            //
         } else if (status == STATUS_CANCELLED) {
            //
            // The IRP was cancelled : nothing to do, just return
            //
         } else {
            //
            // Couldn't queue it for some reason: just use the non-cached path for now
            //
            status = STATUS_TIMEOUT;
         }

      } else if ((Usn != block->Usn) ||
                 (block->State == RP_FILE_BUF_ERROR) ||
                 (block->State == RP_FILE_BUF_INVALID)) {
         // Case 3:
         // Block state is valid but has stale data: this
         // file buffer will be dispatched for I/O.
         // Or
         // Case 4:
         // Previous attempt at I/O ended in error
         // Or
         // Case 5:
         // Block is invalid and needs to refreshed with contents
         // In all cases, take it off the LRU since it will be dispatched
         // for i/o

         //
         // If somebody is using the block - i.e. copying data from it
         // we block till they are finished with it
         //
         RsAcquireFileBufferExclusive(block);

         block->State = RP_FILE_BUF_IO;

         RsReleaseFileBuffer(block);

         block->Usn = Usn;

         RsRemoveFromLru(block);
         //
         // Indicate i/o needs to be queued for this block
         //
         status = STATUS_WAIT_63;

      } else if (block->State == RP_FILE_BUF_VALID) {
         //
         // Case 2: block is valid
         //
         ASSERT (block->State == RP_FILE_BUF_VALID);

         RsAcquireFileBufferShared(block);

         RsMoveFileBufferToTailLru(block);

         status = STATUS_SUCCESS;
      }

      RsReleaseLru();

      DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsGetFileBuffer returning  block %x found on hash bucket %d\n", block, bucketNumber));

      *FileBuf = block;
   } else {
      PRP_CACHE_BUCKET blockBucket;
      ULONG blockBucketNumber;
      ULONG waitCount = 0;
      LARGE_INTEGER timeout;
      //
      // There's no buffer corresponding to the block allocated
      // Get one from the LRU free list
      //
      *FileBuf = NULL;

      timeout.QuadPart = 0;
      status = KeWaitForSingleObject(&RspCacheLru.AvailableSemaphore,
                                     UserRequest,
                                     KernelMode,
                                     FALSE,
                                     &timeout);

      if ((status == STATUS_TIMEOUT) ||
          (!NT_SUCCESS(status))) {
         //
         // That's all the time we'll wait..
         //
         RsReleaseLru();
         return status;
      }

      block = RsRemoveHeadLru(TRUE);

      if (block == NULL) {
         //
         // Should not happen!
         // Couldn't allocate a new free block and all the available ones are already
         // taken.
         //
         KeReleaseSemaphore(&RspCacheLru.AvailableSemaphore,
                            IO_NO_INCREMENT,
                            1L,
                            FALSE);

         RsReleaseLru();

         return STATUS_TIMEOUT;
      }

      //
      // block is a free buffer allocated from the LRU
      //
      ASSERT (block->State == RP_FILE_BUF_INVALID);

      blockBucketNumber = RsHashFileBuffer(block->VolumeSerial,
                                           block->FileId,
                                           block->Block);

      blockBucket = &RspCacheBuckets[blockBucketNumber];
      //
      // Reinitialize the block
      //
      RsReinitializeFileBuf(block, VolumeSerial, FileId, Usn, Block);
      //
      // Put the buffer in the busy state. We do not need to acuqire the buffer
      // because no body is using this buffer at this point
      //
      block->State = RP_FILE_BUF_IO;
      //
      // Remove the block from it's old queue
      //
      RsRemoveFromCacheBucket(block);
      //
      // Add it to the new queue
      //
      RsInsertTailCacheBucket(bucket, block);
      //
      // Release the current bucket
      //

      DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsGetFileBuffer returning  block %x from LRU\n", block));

      *FileBuf = block;

      RsReleaseLru();
      status = STATUS_WAIT_63;
   }

   return status;
}


VOID
RsCacheFsaPartialData(
                     IN PRP_IRP_QUEUE       ReadIo,
                     IN PUCHAR              Buffer,
                     IN ULONGLONG           Offset,
                     IN ULONG               Length,
                     IN NTSTATUS            Status
                     )
/*++
Routine Description

    This is the cache hook which will copy incoming norecall data from
    FSA  to the cache buffer

Arguments

    ReadIo  - Pointer to the read irp request packet
    Buffer  - Pointer to the buffer containing  the incoming data
    Offset  - Offset in the buffer that this partial data corresponds to
    Length  - Length retrieved in this stretch
    Status  - Indicates if the data is valid (STATUS_SUCCESS) or
              error if it is not

Return Value

    None

--*/
{
   PRP_FILE_BUF fileBuf;

   PAGED_CODE();

   if (Status != STATUS_SUCCESS) {
      //
      // Not really interested in the buffer contents
      // We don't have any cleaning up to do either
      // Just return
      //
      return;
   }

   fileBuf = ReadIo->cacheBuffer;

   ASSERT (fileBuf);
   ASSERT (Length <= RspCacheBlockSize);
   //
   // Copy the data to the offset *within* the cache block
   //
   RtlCopyMemory(((CHAR *) fileBuf->Data) + Offset,
                 Buffer,
                 Length);
}


VOID
RsCacheFsaIoComplete(
                    IN PRP_IRP_QUEUE ReadIo,
                    IN NTSTATUS      Status
                    )

/*++
Routine Description

    This is the cache hook which will be called when the
    cache block i/o transfer is complete.
    This will mark the state of the cache file buffer
    as appropriate, and release it.
    If the cache buffer is valid, we add it to
    the tail of the LRU - if not to the head.
    (so it can be reclaimed immediately)
    We raise the appropriate events indicating
    that i/o is complete on the buffer and also
    that a free buffer is available
    Note this is called after the cancel routine is cleared
    in the IRP

Arguments

    ReadIo  - Pointer to the read i/o request packet
    Status  - Indicates if the status of the i/o request

Return Value

    None

--*/
{
   PRP_FILE_BUF fileBuf = ReadIo->cacheBuffer;
   PIRP         irp;
   BOOLEAN      unlock = FALSE;
   PUCHAR       userBuffer;
   KAPC_STATE   apcState;
   PIO_STACK_LOCATION irpSp;
   NTSTATUS     status;
   BOOLEAN synchronousIo;
   ULONG        offsetIntoCacheBuffer;

   PAGED_CODE();

   ASSERT (fileBuf);

   RsAcquireLru();
   RsAcquireFileBufferExclusive(fileBuf);


   if (NT_SUCCESS(Status)) {
      fileBuf->State = RP_FILE_BUF_VALID;
      fileBuf->IoStatus = STATUS_SUCCESS;
      RsInsertTailLru(fileBuf);
   } else {
      fileBuf->State = RP_FILE_BUF_ERROR;
      fileBuf->IoStatus = Status;
      RsInsertHeadLru(fileBuf);
   }
   //
   // Complete all pending requests on the block here
   //
   while ((irp = RsCacheGetNextQueuedRequest(fileBuf)) != NULL) {

      if (NT_SUCCESS(Status)) {
         status = STATUS_SUCCESS;
         if (RsCacheIrpGetLockPages(irp)) {
            //
            // Probe and lock the buffer: we're going to write to it.
            // This is protected by the surrounding try-except
            //
            try {
               MmProbeAndLockProcessPages (irp->MdlAddress,
                                           IoGetRequestorProcess(irp),
                                           irp->RequestorMode,
                                           IoModifyAccess);
               unlock = TRUE;
               userBuffer = MmGetSystemAddressForMdlSafe(irp->MdlAddress,
                                                         NormalPagePriority) ;
               if (userBuffer == NULL) {
                  status = STATUS_INSUFFICIENT_RESOURCES;
               }
            }except(EXCEPTION_EXECUTE_HANDLER) {
               DebugTrace((DPFLTR_RSFILTER_ID,DBG_ERROR, "RsFilter: Unable to lock read buffer!.\n"));
               RsLogError(__LINE__, AV_MODULE_RPCACHE, 0,
                          AV_MSG_NO_BUFFER_LOCK, NULL, NULL);
               status = STATUS_INVALID_USER_BUFFER;
            }
         } else {
            userBuffer = irp->UserBuffer;
         }
         if (NT_SUCCESS(status)) {
            //
            // The pages are locked down and we have a system address to copy the data to
            //
            irpSp = IoGetCurrentIrpStackLocation(irp);

	    offsetIntoCacheBuffer = (ULONG) (irpSp->Parameters.Read.ByteOffset.QuadPart % (ULONGLONG) RspCacheBlockSize);

	    ASSERT ((offsetIntoCacheBuffer + irpSp->Parameters.Read.Length) <= RspCacheBlockSize);

            RtlCopyMemory(userBuffer,
                          fileBuf->Data + offsetIntoCacheBuffer,
                          irpSp->Parameters.Read.Length);

            irp->IoStatus.Information = irpSp->Parameters.Read.Length;

            synchronousIo = BooleanFlagOn(irpSp->FileObject->Flags, FO_SYNCHRONOUS_IO );

            if (synchronousIo) {
               //
               // Change the current byte offset in the file object
               // Use interlocked add because the associated IRPs can
               // complete in any order
               //
               ExInterlockedAddLargeStatistic(&irpSp->FileObject->CurrentByteOffset,
                                              (ULONG)irp->IoStatus.Information);
            }
         } else {
            //
            // We failed to get a system address for the MDL
            //
            irp->IoStatus.Information = 0;
         }
         if (unlock) {
            MmUnlockPages(irp->MdlAddress);
            unlock = FALSE;
            IoFreeMdl(irp->MdlAddress);
            irp->MdlAddress = NULL;
         }
         irp->IoStatus.Status = status;
         IoCompleteRequest(irp,
                           IO_DISK_INCREMENT);
      } else {
         //
         // I/o completed with errors
         //
         if (RsCacheIrpGetLockPages(irp)) {
            //
            // Free the already allocated MDL
            //
            IoFreeMdl(irp->MdlAddress);
            irp->MdlAddress = NULL;
         }
         irp->IoStatus.Status = Status;
         irp->IoStatus.Information = 0;
         IoCompleteRequest(irp,
                           IO_NO_INCREMENT);
      }
   }
   RsReleaseFileBuffer(fileBuf);
   RsReleaseLru();
}


NTSTATUS
RsCacheInitialize(VOID)
/*++

Routine Description

    Initializes the cache for no-recall buffers

Arguments

    None

Return Value

   Status

--*/
{
   ULONG i;
   PRP_FILE_BUF fileBuf;
   PUCHAR  data;

   PAGED_CODE();

   if (RspCacheInitialized) {
      return STATUS_SUCCESS;
   }

   //
   // Get all the registry based tunables
   //

   RsCacheGetParameters();

   //
   // Initialize the LRU structure
   //
   ExInitializeFastMutex(&(RspCacheLru.Lock));
   InitializeListHead(&RspCacheLru.FileBufHead);
   RspCacheLru.TotalCount = 0;
   RspCacheLru.LruCount = 0;

   //
   // Read the parameters here (RspCacheBlockSize, RspCacheMaxBuckets, RspCacheMaxBuffers)
   //

   //
   // Allocate and initialize the hash buckets
   //
   RspCacheBuckets = ExAllocatePool(NonPagedPool,
                                    RspCacheMaxBuckets * sizeof(RP_CACHE_BUCKET));
   if (RspCacheBuckets == NULL) {
      DebugTrace((DPFLTR_RSFILTER_ID,DBG_ERROR, "RsFilter: Could not allocate cache buckets!\n"));
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   for ( i = 0; i < RspCacheMaxBuckets ; i++) {
      InitializeListHead(&(RspCacheBuckets[i].FileBufHead));
   }
   //
   // Allocate the buffers and put them all on the
   // LRU
   //
   if (RspCachePreAllocate) {
      //
      // Initialize the buffers available semaphore
      //
      KeInitializeSemaphore(&RspCacheLru.AvailableSemaphore,
                            0,
                            RspCacheMaxBuffers);
      for (i = 0; i < RspCacheMaxBuffers; i++) {
         fileBuf = RsCacheAllocateBuffer();
         if (!fileBuf) {
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_ERROR, "RsFilter: Failed to allocate cache buffer\n"));
            break;
         }
         RspCacheLru.TotalCount++;
         RsInsertTailLru(fileBuf);
      }
   } else {
      //
      // Initialize the buffers available semaphore.
      //
      KeInitializeSemaphore(&RspCacheLru.AvailableSemaphore,
                            RspCacheMaxBuffers,
                            RspCacheMaxBuffers);
   }

   RspCacheInitialized = TRUE;

   return STATUS_SUCCESS;
}


NTSTATUS
RsCacheGetParameters(VOID)
/*++

Routine Description

   Reads the no-recall cache tunables from registry

Arguments

   None

Return Value

   Status.

--*/
{
   PRTL_QUERY_REGISTRY_TABLE parms;
   ULONG                     parmsSize;
   NTSTATUS                  status;

   ULONG defaultBlockSize   = RP_CACHE_DEFAULT_BLOCK_SIZE;
   ULONG defaultMaxBuckets  = RP_CACHE_DEFAULT_MAX_BUCKETS;
   ULONG defaultPreAllocate = RP_CACHE_DEFAULT_PREALLOCATE;
   ULONG defaultNoRecall    = RP_NO_RECALL_DEFAULT;
   ULONG defaultMaxBuffers  = RP_CACHE_MAX_BUFFERS_SMALL;

   PAGED_CODE();

   parmsSize =  sizeof(RTL_QUERY_REGISTRY_TABLE) * 6;

   parms = ExAllocatePool(PagedPool,
                          parmsSize);

   if (!parms) {
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   switch (MmQuerySystemSize()) {

   case MmSmallSystem:{
         defaultMaxBuffers = RP_CACHE_MAX_BUFFERS_SMALL;
         break;}
   case MmMediumSystem:{
         defaultMaxBuffers = RP_CACHE_MAX_BUFFERS_MEDIUM;
         break;}
   case MmLargeSystem:{
         defaultMaxBuffers = RP_CACHE_MAX_BUFFERS_LARGE;
         break;}

   }

   RtlZeroMemory(parms, parmsSize);

   parms[0].Flags         = RTL_QUERY_REGISTRY_DIRECT;
   parms[0].Name          = RP_CACHE_BLOCK_SIZE_KEY;
   parms[0].EntryContext  = &RspCacheBlockSize;
   parms[0].DefaultType   = REG_DWORD;
   parms[0].DefaultData   = &defaultBlockSize;
   parms[0].DefaultLength = sizeof(ULONG);

   parms[1].Flags         = RTL_QUERY_REGISTRY_DIRECT;
   parms[1].Name          = RP_CACHE_MAX_BUFFERS_KEY;
   parms[1].EntryContext  = &RspCacheMaxBuffers;
   parms[1].DefaultType   = REG_DWORD;
   parms[1].DefaultData   = &defaultMaxBuffers;
   parms[1].DefaultLength = sizeof(ULONG);

   parms[2].Flags         = RTL_QUERY_REGISTRY_DIRECT;
   parms[2].Name          = RP_CACHE_MAX_BUCKETS_KEY;
   parms[2].EntryContext  = &RspCacheMaxBuckets;
   parms[2].DefaultType   = REG_DWORD;
   parms[2].DefaultData   = &defaultMaxBuckets;
   parms[2].DefaultLength = sizeof(ULONG);

   parms[3].Flags         = RTL_QUERY_REGISTRY_DIRECT;
   parms[3].Name          = RP_CACHE_PREALLOCATE_KEY;
   parms[3].EntryContext  = &RspCachePreAllocate;
   parms[3].DefaultType   = REG_DWORD;
   parms[3].DefaultData   = &defaultPreAllocate;
   parms[3].DefaultLength = sizeof(ULONG);

   parms[4].Flags         = RTL_QUERY_REGISTRY_DIRECT;
   parms[4].Name          = RP_NO_RECALL_DEFAULT_KEY;
   parms[4].EntryContext  = &RsNoRecallDefault;
   parms[4].DefaultType   = REG_DWORD;
   parms[4].DefaultData   = &defaultNoRecall;
   parms[4].DefaultLength = sizeof(ULONG);
   //
   // Perform the query
   //
   status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES | RTL_REGISTRY_OPTIONAL,
                                   RP_CACHE_PARAMETERS_KEY,
                                   parms,
                                   NULL,
                                   NULL);
   ExFreePool(parms);
   return status;
}


PRP_FILE_BUF
RsCacheAllocateBuffer(VOID)
/*++

Routine Description

    Allocates and returns an initialized block
    of paged pool to buffer no-recall data

Arguments

    None

Return Value

   Pointer to the block if successfully allocated
   NULL if not
--*/
{
   PRP_FILE_BUF fileBuf;
   PUCHAR  data;

   PAGED_CODE();

   fileBuf = ExAllocatePool(NonPagedPool, sizeof(RP_FILE_BUF));
   if (!fileBuf) {
      return NULL;
   }

   data = ExAllocatePool(PagedPool, RspCacheBlockSize);

   if (!data) {
      ExFreePool(fileBuf);
      return NULL;
   }
   RsInitializeFileBuf(fileBuf, data);
   return fileBuf;
}


PIRP
RsCacheGetNextQueuedRequest(IN PRP_FILE_BUF FileBuf)
/*++

Routine Description

   Returns the next non-cancellable request from the
   queued requests for this block

Arguments

   FileBuf - Pointer to the block

Return Value

   NULL     - if none are found
   Pointer to non-cancellable request if one is found

--*/
{
   PIRP  irp;
   KIRQL cancelIrql;
   PLIST_ENTRY entry;
   BOOLEAN found = FALSE;

   IoAcquireCancelSpinLock(&cancelIrql);

   while (!IsListEmpty(&FileBuf->WaitQueue)) {
      //
      // Get next packet
      //
      entry = RemoveHeadList(&FileBuf->WaitQueue);
      //
      // Clear the cancel routine
      //
      irp = RsCacheIrpWaitQueueContainingIrp(entry);

      if (IoSetCancelRoutine(irp, NULL) == NULL) {
         //
         // This IRP was cancelled - let the cancel routine handle it
         //
         continue;
      } else {
         found = TRUE;
         break;
      }
   }

   IoReleaseCancelSpinLock(cancelIrql);

   return(found ? irp : NULL);
}


NTSTATUS
RsCacheCancelQueuedRequest(
                          IN PDEVICE_OBJECT DeviceObject,
                          IN PIRP Irp
                          )
/*++

Routine Description:

    This function filters cancels an outstanding read-no-recall IRP that
    has been queued to a block

Arguments:

    DeviceObject - Pointer to the target device object of the create/open.

    Irp - Pointer to the I/O Request Packet that represents the operation.

Return Value:

   STATUS_SUCCESS

--*/
{

   RemoveEntryList(RsCacheIrpWaitQueueEntry(Irp));

   IoReleaseCancelSpinLock(Irp->CancelIrql);

   Irp->IoStatus.Status = STATUS_CANCELLED;
   Irp->IoStatus.Information = 0;
   IoCompleteRequest(Irp,
                     IO_NO_INCREMENT);
   return STATUS_SUCCESS;
}


NTSTATUS
RsCacheQueueRequestWithBuffer(
                             IN PRP_FILE_BUF FileBuf,
                             IN PIRP Irp,
                             IN BOOLEAN LockPages)
/*++

Routine Description

   Queues the IRP associated cache block, to be completed
   when the i/o on the block finishes

N.B.: LRU lock is acquired when this is called

Arguments

   FileBuf   -   Pointer to the cache block on which the request is waiting
   Irp       -   Pointer to the IRP which is waiting
   LockPages -   True if the IRP pages need to be locked down during transfer

Return Value

   STATUS_PENDING    - Irp has been queued
   STATUS_CANCELLED  - Irp was cancelled
   Any other status  - Error in queueing the request

--*/
{
   NTSTATUS status;
   KIRQL    cancelIrql;

   IoAcquireCancelSpinLock(&cancelIrql);

   if (!Irp->Cancel) {
      RsCacheIrpSetLockPages(Irp, LockPages);

      InsertHeadList(&FileBuf->WaitQueue,
                     RsCacheIrpWaitQueueEntry(Irp));

      IoMarkIrpPending( Irp );
      IoSetCancelRoutine( Irp, RsCacheCancelQueuedRequest);
      status = STATUS_PENDING;
   } else {
      status = STATUS_CANCELLED;
   }

   IoReleaseCancelSpinLock(cancelIrql);
   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\fsa\fsafltr.cpp ===
/*++

(c) 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    fsafltr.cpp

Abstract:

    This class represents a file system filter for NTFS 5.0.

Author:

    Chuck Bardeen   [cbardeen]   12-Feb-1997

Revision History:

--*/

#include "stdafx.h"
extern "C" {
#include "devioctl.h"
#include <winerror.h>
#include "aclapi.h"

// #define MAC_SUPPORT  // NOTE: You must define MAC_SUPPORT in fsaftrcl.cpp to enable all the code

#ifdef MAC_SUPPORT
#include <macfile.h>
#endif  
}

#define WSB_TRACE_IS        WSB_TRACE_BIT_FSA

#include "wsb.h"
#include "HsmConn.h"
#include "job.h"
#include "fsa.h"
#include "fsafltr.h"
#include "fsaitemr.h"


#ifdef MAC_SUPPORT
extern HANDLE   FsaDllSfm;
extern BOOL     FsaMacSupportInstalled;

extern "C" {
typedef DWORD (*AdminConnect) (LPWSTR lpwsServerName, PAFP_SERVER_HANDLE phAfpServer);

extern  AdminConnect    pAfpAdminConnect;

typedef VOID (*AdminDisconnect) (AFP_SERVER_HANDLE hAfpServer);

extern  AdminDisconnect pAfpAdminDisconnect;

typedef VOID (*AdminBufferFree) (PVOID pBuffer);

extern  AdminBufferFree pAfpAdminBufferFree;

typedef DWORD (*AdminSessionEnum) (AFP_SERVER_HANDLE hAfpServer, LPBYTE *lpbBuffer,
                    DWORD dwPrefMaxLen, LPDWORD lpdwEntriesRead, LPDWORD lpdwTotalEntries,
                    LPDWORD lpdwResumeHandle);

extern  AdminSessionEnum    pAfpAdminSessionEnum;
}
#endif  

DWORD FsaIoctlThread(void *pFilterInterface);
DWORD FsaPipeThread(void *pFilterInterface);


HRESULT
CFsaFilter::Cancel(
    void
    )

/*++

Implements:

  IFsaFilter::Cancel().

--*/
{
    HRESULT                 hr = S_OK;
    HSM_JOB_STATE           oldState;

    WsbTraceIn(OLESTR("CFsaFilter::Cancel"), OLESTR(""));
    
    try {

        WsbAffirm((HSM_JOB_STATE_ACTIVE == m_state), E_UNEXPECTED);

        oldState = m_state;
        m_state = HSM_JOB_STATE_CANCELLING;

        try {

            // TBD - Do whatever it takes to cancel
            WsbAssertHr(E_NOTIMPL);
            m_state = HSM_JOB_STATE_CANCELLED;

        } WsbCatchAndDo(hr, m_state = oldState;);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaFilter::Cancel"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaFilter::CancelRecall(
    IN IFsaFilterRecall* pRecall
    )

/*++

Implements:

  IFsaFilter::CancelRecall().

--*/
{
    HRESULT                         hr = S_OK;
    CComPtr<IFsaFilterRecallPriv>   pRecallPriv;

    WsbTraceIn(OLESTR("CFsaFilter::CancelRecall"), OLESTR(""));
    
    try {

        WsbAssert(pRecall != 0, E_POINTER);

        // Get the private interface and tell the recall to cancel itself.
        WsbAffirmHr(pRecall->QueryInterface(IID_IFsaFilterRecallPriv, (void**) &pRecallPriv));
        WsbAffirmHr(pRecallPriv->Cancel());

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaFilter::CancelRecall"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaFilter::CompareTo(
    IN IUnknown* pUnknown,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbCollectable::CompareTo().

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IFsaFilter>     pFilter;

    WsbTraceIn(OLESTR("CFsaFilter::CompareTo"), OLESTR(""));
    
    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pUnknown, E_POINTER);

        // We need the IWsbBool interface to get the value of the object.
        WsbAffirmHr(pUnknown->QueryInterface(IID_IFsaFilter, (void**) &pFilter));

        // Compare the rules.
        hr = CompareToIFilter(pFilter, pResult);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaFilter::CompareTo"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CFsaFilter::CompareToIdentifier(
    IN GUID id,
    OUT SHORT* pResult
    )

/*++

Implements:

  IFsaFilter::CompareToIdentifier().

--*/
{
    HRESULT     hr = S_OK;
    SHORT       aResult = 0;

    WsbTraceIn(OLESTR("CFsaFilter::CompareToIdentifier"), OLESTR(""));

    try {

        aResult = WsbSign( memcmp(&m_id, &id, sizeof(GUID)) );

        if (0 != aResult) {
            hr = S_FALSE;
        }
        
        if (0 != pResult) {
            *pResult = aResult;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaFilter::CompareToIdentifier"), OLESTR("hr = <%ls>, result = <%d>"), WsbHrAsString(hr), aResult);

    return(hr);
}


HRESULT
CFsaFilter::CompareToIFilter(
    IN IFsaFilter* pFilter,
    OUT SHORT* pResult
    )

/*++

Implements:

  IFsaFilter::CompareToIFilter().

--*/
{
    HRESULT         hr = S_OK;
    GUID            id;

    WsbTraceIn(OLESTR("CFsaFilter::CompareToIFilter"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pFilter, E_POINTER);
        WsbAffirmHr(pFilter->GetIdentifier(&id));
        // Either compare the name or the id.
        hr = CompareToIdentifier(id, pResult);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaFilter::CompareToIFilter"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CFsaFilter::CleanupClients(
    void
    )

/*++

Implements:

  CFsaFilter::CleanupClients()

--*/
{
    HRESULT                         hr = S_OK;
    CComPtr<IFsaFilterClient>       pClient;
    CComPtr<IWsbEnum>               pEnum;
    FILETIME                        now, last;
    LARGE_INTEGER                   tNow, tLast;

    WsbTraceIn(OLESTR("CFsaFilter::CleanupClients"), OLESTR(""));
    
    EnterCriticalSection(&m_clientLock);

    try {

        WsbAffirmHr(m_pClients->Enum(&pEnum));
        hr = pEnum->First(IID_IFsaFilterClient, (void**) &pClient);

        while (S_OK == hr) {
            GetSystemTimeAsFileTime(&now);
            tNow.LowPart = now.dwLowDateTime;
            tNow.HighPart = now.dwHighDateTime;
    
            WsbAffirmHr(pClient->GetLastRecallTime(&last));
            tLast.LowPart = last.dwLowDateTime;
            tLast.HighPart = last.dwHighDateTime;
            //
            //  Get the time (in 100 nano-second units)
            //  from the end of the last recall until now.
            //
            if (tLast.QuadPart != 0) {
                tNow.QuadPart -= tLast.QuadPart;
                //
                // Convert to seconds and check against the expiration time
                //
                tNow.QuadPart /= (LONGLONG) 10000000;
                if (tNow.QuadPart > (LONGLONG) FSA_CLIENT_EXPIRATION_TIME) {
                    //
                    // This client structure is old - blow it away
                    //
                    WsbTrace(OLESTR("CFsaFilter::CleanupClients - cleaning up old client (%ls)\n"),
                        WsbLonglongAsString(tNow.QuadPart));
                    m_pClients->RemoveAndRelease(pClient);
                    pClient = NULL;
                    WsbAffirmHr(pEnum->Reset());
                }
            }

            pClient = NULL;
            hr = pEnum->Next(IID_IFsaFilterClient, (void**) &pClient);
        }
        if (hr == WSB_E_NOTFOUND) {
            hr = S_OK;
        }

    } WsbCatch(hr);

    LeaveCriticalSection(&m_clientLock);

    WsbTraceOut(OLESTR("CFsaFilter::CleanupClients"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CFsaFilter::DeleteRecall(
    IN IFsaFilterRecall* pRecall
    )

/*++

Implements:

  IFsaFilter::DeleteRecall().

--*/
{
    HRESULT                         hr = S_OK;
    CComPtr<IFsaFilterRecallPriv>   pRecallPriv;

    WsbTraceIn(OLESTR("CFsaFilter::DeleteRecall"), OLESTR(""));
    
    try {
        ULONG numEnt;

        WsbAssert(pRecall != 0, E_POINTER);

        // Delete the request.
        WsbAffirmHr(pRecall->QueryInterface(IID_IFsaFilterRecallPriv, (void**) &pRecallPriv));
        WsbAffirmHr(pRecallPriv->Delete());

        // Remove it from our collection.
        EnterCriticalSection(&m_recallLock);
        m_pRecalls->RemoveAndRelease(pRecall);
        LeaveCriticalSection(&m_recallLock);

        m_pRecalls->GetEntries(&numEnt);
        WsbTrace(OLESTR("CFsaFilter::DeleteRecall: Recall queue has %u entries after delete.\n"),
                numEnt);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaFilter::DeleteRecall"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaFilter::EnumRecalls(
    OUT IWsbEnum** ppEnum
    )

/*++

Implements:

  IFsaFilter::EnumRecalls().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != ppEnum, E_POINTER);
        EnterCriticalSection(&m_recallLock);
        hr = m_pRecalls->Enum(ppEnum);
        LeaveCriticalSection(&m_recallLock);
        WsbAffirmHr(hr);

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaFilter::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    try {
        m_bCritSecCreated = FALSE;

        //
        // These are the default parameters.
        // The max recalls and admin exemption setting are configurable via the admin gui.
        //
        m_minRecallInterval = 10;
        m_maxRecallBuffers = RP_MAX_RECALL_BUFFERS;
        m_maxRecalls = RP_DEFAULT_RUNAWAY_RECALL_LIMIT;
        m_exemptAdmin = FALSE;                   // By default admin is NOT exempt

        m_ioctlHandle = INVALID_HANDLE_VALUE;
        m_pipeHandle  = INVALID_HANDLE_VALUE;
        m_terminateEvent = NULL;

        m_pipeThread = NULL;
        m_ioctlThread = NULL;

        m_pFsaServer = NULL;

        WsbAffirmHr(CWsbCollectable::FinalConstruct());

        WsbAffirmHr(CoCreateGuid(&m_id));
        m_state = HSM_JOB_STATE_IDLE;

        //
        // Start out enabled 
        //
        m_isEnabled = TRUE;

        // Initialize critical sections
        WsbAffirmStatus(InitializeCriticalSectionAndSpinCount(&m_clientLock, 0));
        if (! InitializeCriticalSectionAndSpinCount(&m_recallLock, 0)) {
            DWORD dwErr = GetLastError();               
            hr = HRESULT_FROM_WIN32(dwErr);    
            DeleteCriticalSection(&m_clientLock);
            WsbAffirmHr(hr);             
        }
        if (! InitializeCriticalSectionAndSpinCount(&m_stateLock, 0)) {
            DWORD dwErr = GetLastError();               
            hr = HRESULT_FROM_WIN32(dwErr);    
            DeleteCriticalSection(&m_clientLock);
            DeleteCriticalSection(&m_recallLock);
            WsbAffirmHr(hr);             
        }
        m_bCritSecCreated = TRUE;
    
        // Create the Client List collection.
        WsbAffirmHr(CoCreateInstance(CLSID_CWsbOrderedCollection, NULL, CLSCTX_SERVER, IID_IWsbCollection, (void**) &m_pClients));

        // Create the Recall List collection.
        WsbAffirmHr(CoCreateInstance(CLSID_CWsbOrderedCollection, NULL, CLSCTX_SERVER, IID_IWsbCollection, (void**) &m_pRecalls));


#ifdef MAC_SUPPORT
        //
        // Attempt to load the Mac support 
        //
        FsaDllSfm = LoadLibrary(L"SFMAPI.DLL");
        if (FsaDllSfm != NULL) {
            //
            // The DLL is there - try importing the functions we will need
            //
            try {
                WsbAffirmPointer((pAfpAdminConnect = (AdminConnect) GetProcAddress((HMODULE) FsaDllSfm, "AfpAdminConnect")));
                WsbAffirmPointer((pAfpAdminDisconnect = (AdminDisconnect) GetProcAddress((HMODULE) FsaDllSfm, "AfpAdminDisconnect")));
                WsbAffirmPointer((pAfpAdminBufferFree = (AdminBufferFree) GetProcAddress((HMODULE) FsaDllSfm, "AfpAdminBufferFree")));
                WsbAffirmPointer((pAfpAdminSessionEnum = (AdminSessionEnum) GetProcAddress((HMODULE) FsaDllSfm, "AfpAdminSessionEnum")));
                FsaMacSupportInstalled = TRUE;
            } WsbCatchAndDo(hr, 
                FreeLibrary((HMODULE) FsaDllSfm);
                FsaDllSfm = NULL;
                );
        }

#endif


    } WsbCatch(hr);

    return(hr);
}



HRESULT
CFsaFilter::FinalRelease(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalRelease().

--*/
{
    HRESULT     hr = S_OK;
	HANDLE		pThreadHandles[THREAD_HANDLE_COUNT];
    DWORD       nThreadCount = 0;
    BOOL        bThreads = TRUE;
    BOOL        bTerminated = TRUE;
    

    WsbTraceIn(OLESTR("CFsaFilter::FinalRelease"), OLESTR(""));
#ifdef MAC_SUPPORT
    if (FsaDllSfm != NULL) {
        FreeLibrary((HMODULE) FsaDllSfm);
        FsaDllSfm = NULL;
    }
#endif

    //
    // Stop the ioctl and pipe threads
    //
    m_state = HSM_JOB_STATE_SUSPENDING;

	// But wait until they've completed first.
    if ((m_pipeThread) && (m_ioctlThread)) {
        pThreadHandles[0] = m_pipeThread;
        pThreadHandles[1] = m_ioctlThread;
        nThreadCount = 2;
    } else if (m_pipeThread) {
        pThreadHandles[0] = m_pipeThread;
        nThreadCount = 1;
    } else if (m_ioctlThread) {
        pThreadHandles[0] = m_ioctlThread;
        nThreadCount = 1;
    } else{
        // neither of the threads exist, skip wait.
        bThreads = FALSE;
    }

    if (bThreads) {

        switch (WaitForMultipleObjects(nThreadCount, pThreadHandles, TRUE, 20000)) {
            case WAIT_FAILED: {
                WsbTrace(OLESTR("CFsaFilter::FinalRelease: WaitforMultipleObjects returned error %lu\n"),
                    GetLastError());
            }
            // fall through...

            case WAIT_TIMEOUT: {
                WsbTrace(OLESTR("CFsaFilter::FinalRelease: force-terminating threads.\n"));

                // after timeout, force termination on threads
                // bTerminated specify if the force-termination succeeds
                DWORD dwExitCode;
                if (GetExitCodeThread( m_ioctlThread, &dwExitCode)) {
                    if (dwExitCode == STILL_ACTIVE) {   // thread still active
                        if (!TerminateThread (m_ioctlThread, 0)) {
                            WsbTrace(OLESTR("CFsaFilter::FinalRelease: TerminateThread returned error %lu\n"),
                                GetLastError());
                            bTerminated = FALSE;
                        }
                    }
                } else {
                    WsbTrace(OLESTR("CFsaFilter::FinalRelease: GetExitCodeThread returned error %lu\n"),
                                GetLastError());
                    bTerminated = FALSE;
                }

                if (GetExitCodeThread( m_pipeThread, &dwExitCode)) {
                    if (dwExitCode == STILL_ACTIVE) {   // thread still active
                        if (!TerminateThread (m_pipeThread, 0)) {
                            WsbTrace(OLESTR("CFsaFilter::FinalRelease: TerminateThread returned error %lu\n"),
                                GetLastError());
                            bTerminated = FALSE;
                        }
                    }
                } else {
                    WsbTrace(OLESTR("CFsaFilter::FinalRelease: GetExitCodeThread returned error %lu\n"),
                                GetLastError());
                    bTerminated = FALSE;
                }

                break;
            }

            default:
                break;
        }
    }

    if (m_pipeHandle != INVALID_HANDLE_VALUE) {
        CloseHandle(m_pipeHandle);
        m_pipeHandle = INVALID_HANDLE_VALUE;
    }
    
    if (m_ioctlHandle != INVALID_HANDLE_VALUE) {
        CloseHandle(m_ioctlHandle);
        m_ioctlHandle = INVALID_HANDLE_VALUE;
    }

    if (m_terminateEvent != NULL) {
        CloseHandle(m_terminateEvent);
        m_terminateEvent = NULL;
    }

    if (m_pipeThread != NULL) {
        CloseHandle(m_pipeThread);
    }
    if (m_ioctlThread != NULL) {
        CloseHandle(m_ioctlThread);
    }

    // delete CS only if threads were teriminated properly and CS were created successfully
    if (bTerminated && m_bCritSecCreated) {
        DeleteCriticalSection(&m_clientLock);
        DeleteCriticalSection(&m_recallLock);
        DeleteCriticalSection(&m_stateLock);
    }

    CWsbCollectable::FinalRelease();

    WsbTraceOut(OLESTR("CFsaFilter::FinalRelease"), OLESTR(""));

    return(hr);

}




HRESULT
CFsaFilter::FindRecall(
    IN  GUID recallId, 
    OUT IFsaFilterRecall** pRecall
    )

/*++

Implements:

  CFsaFilter:FindRecall().

--*/
{
    HRESULT                         hr = S_OK;
    CComPtr<IFsaFilterRecallPriv>   pRecallPriv;


    WsbTraceIn(OLESTR("CFsaFilter::FindRecall"), OLESTR(""));

    
    try {

        WsbAffirmHr(CoCreateInstance(CLSID_CFsaFilterRecallNTFS, NULL, CLSCTX_SERVER, IID_IFsaFilterRecallPriv, (void**) &pRecallPriv));
        WsbAffirmHr(pRecallPriv->SetIdentifier(recallId));
        EnterCriticalSection(&m_recallLock);
        hr = m_pRecalls->Find(pRecallPriv, IID_IFsaFilterRecall, (void**) pRecall);
        LeaveCriticalSection(&m_recallLock);
        WsbAffirmHr(hr);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaFilter::FindRecall"), OLESTR(""));

    return(hr);
}



HRESULT
CFsaFilter::GetAdminExemption(
    OUT BOOL *pIsExempt
    )

/*++

Implements:

  IFsaFilter::GetAdminExemption().

--*/
{
    HRESULT         hr = S_OK;

    
    try {

        WsbAssert(0 != pIsExempt, E_POINTER);
        *pIsExempt = m_exemptAdmin;

    } WsbCatch(hr);

    return(hr);
}



HRESULT
CFsaFilter::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaFilter::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CFsaFilterNTFS;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaFilter::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CFsaFilter::GetIdentifier(
    OUT GUID* pId
    )

/*++

Implements:

  IFsaFilter::GetIdentifier().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != pId, E_POINTER);

        *pId = m_id;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaFilter::GetLogicalName(
    OUT OLECHAR** pName,
    IN ULONG bufferSize
    )

/*++

Implements:

  IFsaFilter::GetLogicalName().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != pName, E_POINTER); 
        WsbAssert(m_pFsaServer != 0, E_POINTER); 

        // This has not been official defined, but for now the logical name will be the same name
        // as the FSA, since we will only have one filter.
        WsbAffirmHr(m_pFsaServer->GetLogicalName(pName, bufferSize));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaFilter::GetMaxRecallBuffers(
    OUT ULONG* pMaxBuffers
    )

/*++

Implements:

  IFsaFilter::GetMaxRecallBuffers().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != pMaxBuffers, E_POINTER); 
        *pMaxBuffers = m_maxRecallBuffers;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaFilter::GetMaxRecalls(
    OUT ULONG* pMaxRecalls
    )

/*++

Implements:

  IFsaFilter::GetMaxRecalls().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != pMaxRecalls, E_POINTER); 
        *pMaxRecalls = m_maxRecalls;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaFilter::GetMinRecallInterval(
    OUT ULONG* pMinInterval
    )

/*++

Implements:

  IFsaFilter::GetMinRecallInterval().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != pMinInterval, E_POINTER); 
        *pMinInterval = m_minRecallInterval;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaFilter::GetSizeMax(
    OUT ULARGE_INTEGER* pSize
    )

/*++

Implements:

  IPersistStream::GetSizeMax().

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IPersistStream> pPersistStream;


    WsbTraceIn(OLESTR("CFsaFilter::GetSizeMax"), OLESTR(""));

    try {

        WsbAssert(0 != pSize, E_POINTER);

        // We are only storing the configuration information, NOT the collections.
        pSize->QuadPart = WsbPersistSizeOf(GUID) + 3 * WsbPersistSizeOf(ULONG) + WsbPersistSizeOf(BOOL);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaFilter::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pSize));

    return(hr);
}


HRESULT
CFsaFilter::GetState(
    OUT HSM_JOB_STATE* pState
    )

/*++

Implements:

  IPersistStream::GetState().

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CFsaFilter::GetState"), OLESTR(""));

    try {

        WsbAssert(0 != pState, E_POINTER);

        *pState = m_state;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaFilter::GetState"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaFilter::Init(
    IN IFsaServer* pFsaServer
    )

/*++

Implements:

  IFsaFilterPriv::Init().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != pFsaServer, E_POINTER);

        // Store the parent FSA?
        m_pFsaServer = pFsaServer;

        m_isDirty = TRUE;

    } WsbCatch(hr);

    return(hr);
}
    

HRESULT
CFsaFilter::IsEnabled(
    void
    )

/*++

Implements:

  IFsaFilter::IsEnabled().

--*/
{
    return(m_isEnabled ? S_OK : S_FALSE);
}


HRESULT
CFsaFilter::Load(
    IN IStream* pStream
    )

/*++

Implements:

  IPersistStream::Load().

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaFilter::Load"), OLESTR(""));

    try {
        WsbAssert(0 != pStream, E_POINTER);
        
        // Do the easy stuff, but make sure that this order matches the order
        // in the save method.
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_id));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_maxRecalls));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_minRecallInterval));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_maxRecallBuffers));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_isEnabled));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_exemptAdmin));

    } WsbCatch(hr);                                        

    WsbTraceOut(OLESTR("CFsaFilter::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaFilter::Pause(
    void
    )

/*++

Implements:

  IFsaFilter::Pause().

--*/
{
    HRESULT                 hr = S_OK;
    HSM_JOB_STATE           oldState;
    RP_MSG                  tmp;
    DWORD                   outSize = 0;


    WsbTraceIn(OLESTR("CFsaFilter::Pause"), OLESTR(""));
    
    try {

        WsbAffirm((HSM_JOB_STATE_ACTIVE == m_state), E_UNEXPECTED);

        oldState = m_state;
        m_state = HSM_JOB_STATE_PAUSING;

        try {
            //
            // Tell the kernel mode driver to stop accepting new recall requests.
            //
            if (m_ioctlHandle != INVALID_HANDLE_VALUE) {
                tmp.inout.command = RP_SUSPEND_NEW_RECALLS;
                WsbAffirmStatus(DeviceIoControl(m_ioctlHandle, FSCTL_HSM_DATA, &tmp,
                            sizeof(RP_MSG),
                            &tmp, sizeof(RP_MSG), &outSize, NULL))
            }
            m_state = HSM_JOB_STATE_PAUSED;

        } WsbCatchAndDo(hr, m_state = oldState;);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaFilter::Pause"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaFilter::Resume(
    void
    )

/*++

Implements:

  IFsaFilter::Resume().

--*/
{
    HRESULT                 hr = S_OK;
    HSM_JOB_STATE           oldState;
    RP_MSG                  tmp;
    DWORD                   outSize = 0;


    WsbTraceIn(OLESTR("CFsaFilter::Resume"), OLESTR(""));
    
    try {

        WsbAffirm((HSM_JOB_STATE_PAUSED == m_state), E_UNEXPECTED);
         
        oldState = m_state;
        m_state = HSM_JOB_STATE_RESUMING;

        try {
            //
            // Tell the kernel mode driver to start accepting recall requests.
            //
            if (m_ioctlHandle != INVALID_HANDLE_VALUE) {
                tmp.inout.command = RP_ALLOW_NEW_RECALLS;
                WsbAffirmStatus(DeviceIoControl(m_ioctlHandle, FSCTL_HSM_DATA, &tmp,
                            sizeof(RP_MSG),
                            &tmp, sizeof(RP_MSG), &outSize, NULL))
            }

            m_state = HSM_JOB_STATE_ACTIVE;

        } WsbCatchAndDo(hr, m_state = oldState;);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaFilter::Resume"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaFilter::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )

/*++

Implements:

  IPersistStream::Save().

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IPersistStream> pPersistStream;

    WsbTraceIn(OLESTR("CFsaFilter::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));
    
    try {
        WsbAssert(0 != pStream, E_POINTER);
        
        // Do the easy stuff, but make sure that this order matches the order
        // in the load method.
        WsbAffirmHr(WsbSaveToStream(pStream, m_id));
        WsbAffirmHr(WsbSaveToStream(pStream, m_maxRecalls));
        WsbAffirmHr(WsbSaveToStream(pStream, m_minRecallInterval));
        WsbAffirmHr(WsbSaveToStream(pStream, m_maxRecallBuffers));
        WsbAffirmHr(WsbSaveToStream(pStream, m_isEnabled));
        WsbAffirmHr(WsbSaveToStream(pStream, m_exemptAdmin));

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaFilter::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaFilter::SendCancel(
    IN IFsaFilterRecallPriv *pRecallPriv
    )

/*++

Implements:

  IFsaFilterPriv::SendCancel()

--*/
{
    HRESULT                     hr = S_OK;
    RP_MSG                      tmp;
    DWORD                       outSize;
    ULONG                       numEnt;
    ULONGLONG                   driversId;
    CComPtr<IFsaFilterRecall>   pRecall;
    
    //Get Drivers ID of failing recall
    WsbAffirmHr(pRecallPriv->GetDriversRecallId(&driversId));

    tmp.inout.command = RP_RECALL_COMPLETE;
    tmp.inout.status = STATUS_CANCELLED;
    tmp.msg.rRep.actionFlags = 0;
    tmp.msg.rRep.filterId = driversId;
    
    DeviceIoControl(m_ioctlHandle, FSCTL_HSM_DATA, &tmp, sizeof(RP_MSG),
            &tmp, sizeof(RP_MSG), &outSize, NULL);

    //
    // Remove it from our collection
    //

    EnterCriticalSection(&m_recallLock);
    hr = m_pRecalls->RemoveAndRelease(pRecallPriv);
    LeaveCriticalSection(&m_recallLock);
    WsbAffirmHr(hr);

    hr = m_pRecalls->GetEntries(&numEnt);
    WsbTrace(OLESTR("CFsaFilter::SendCancel: Recall queue has %u entries after delete\n"), 
            numEnt);
    hr = S_OK;



    return(hr);
}

#define FSA_MAX_XFER    (1024 * 1024)   
#define FSA_MIN_XFER    (8 * 1024)  


HRESULT
CFsaFilter::SendComplete(
    IN IFsaFilterRecallPriv *pRecallPriv,
    IN HRESULT              status
    )

/*++

Implements:

  IFsaFilterPriv::SendComplete()

--*/
{
HRESULT                     hr = S_OK;
RP_MSG                      tmp;
BOOL                        code = FALSE;
ULONG                       numEnt;
BOOL                        didSend = FALSE;
DWORD                       ioSize;
CComPtr<IFsaFilterRecall>   pRecall;
CWsbStringPtr               pName;



    try {
        ioSize = sizeof(RP_MSG);

        WsbAffirmHr(pRecallPriv->QueryInterface(IID_IFsaFilterRecall, (void**) &pRecall));
        //  Get path of file failing recall.
        WsbAffirmHr(pRecall->GetPath((OLECHAR**) &pName, 0))
        WsbAssertPointer(pName);

        tmp.inout.command = RP_RECALL_COMPLETE;
        if (status == S_OK)
            tmp.inout.status = 0;
        else {
            // If the error indicates that Engine is not initialized yet -
            // log an error with law severity (it is considered as a normal situation)
            if (status != HSM_E_NOT_READY) {
                WsbLogEvent(FSA_MESSAGE_RECALL_FAILED, 0, NULL, (OLECHAR*) WsbAbbreviatePath(pName, 120), WsbHrAsString(status), NULL);
            } else {
                WsbLogEvent(FSA_MESSAGE_RECALL_FAILED_NOT_READY, 0, NULL, (OLECHAR*) WsbAbbreviatePath(pName, 120), WsbHrAsString(status), NULL);
            }
            tmp.inout.status = TranslateHresultToNtStatus(status);
        }

        WsbAffirmHr(pRecall->GetRecallFlags(&tmp.msg.rRep.actionFlags));

        WsbAffirmHr(pRecallPriv->GetDriversRecallId(&tmp.msg.rRep.filterId));
        WsbTrace(OLESTR("CFsaFilter::SendComplete: id = %I64x status = %s\n"), 
            tmp.msg.rRep.filterId, WsbHrAsString(status));
    
        WsbAffirmHr(pRecallPriv->LogComplete(status));

        WsbAffirmStatus(DeviceIoControl(m_ioctlHandle, FSCTL_HSM_DATA, &tmp, ioSize,
                &tmp, sizeof(RP_MSG), &ioSize, NULL));

        didSend = TRUE;

        WsbTrace(OLESTR("CFsaFilter::SendComplete: Ioctl returned %u  (%x)\n"), code, GetLastError());

        //
        // Remove it from our collection
        //

        EnterCriticalSection(&m_recallLock);
        hr = m_pRecalls->RemoveAndRelease(pRecallPriv);
        LeaveCriticalSection(&m_recallLock);
        WsbAffirmHr(hr);

        hr = m_pRecalls->GetEntries(&numEnt);
        WsbTrace(OLESTR("CFsaFilter::SendComplete: Recall queue has %u entries after delete\n"), 
                numEnt);
        hr = S_OK;

    } WsbCatchAndDo(hr,
        RP_MSG  aTmp;

        //
        // Log an event
        //
        WsbLogEvent(FSA_MESSAGE_RECALL_FAILED, 0, NULL, (OLECHAR*) WsbAbbreviatePath(pName, 120), WsbHrAsString(hr), NULL);

        //
        // If for some reason we did not tell the filter to complete the IO we
        // try it here (with a error indication) so we have done everything possible to keep the
        // application from hanging.
        //
        if (didSend == FALSE) {
            WsbAffirmHr(pRecallPriv->GetDriversRecallId(&aTmp.msg.pRep.filterId));
            aTmp.inout.command = RP_RECALL_COMPLETE;
            aTmp.inout.status = STATUS_FILE_IS_OFFLINE;
            aTmp.msg.rRep.actionFlags = 0;

            DeviceIoControl(m_ioctlHandle, FSCTL_HSM_DATA, &aTmp, sizeof(RP_MSG),
                    &aTmp, sizeof(RP_MSG), &ioSize, NULL);
            //
            // Remove it from our collection
            //

            EnterCriticalSection(&m_recallLock);
            hr = m_pRecalls->RemoveAndRelease(pRecallPriv);
            LeaveCriticalSection(&m_recallLock);
        }
    

    );

    return(hr);
}


HRESULT
CFsaFilter::SetAdminExemption(
    IN BOOL isExempt
    )

/*++

Implements:

  IFsaFilter::SetAdminExemption().

--*/
{
    HRESULT         hr = S_OK;

    m_exemptAdmin = isExempt;   // TRUE == Admin is exempt from runaway recall check.

    m_isDirty = TRUE;

    return(hr);
}
    

    

HRESULT
CFsaFilter::SetIdentifier(
    IN GUID id
    )

/*++

Implements:

  IFsaFilterPriv::SetIdentifier().

--*/
{
    HRESULT         hr = S_OK;

    m_id = id;

    m_isDirty = TRUE;

    return(hr);
}
    

HRESULT
CFsaFilter::SetIsEnabled(
    IN BOOL isEnabled
    )

/*++

Implements:

  IFsaFilter::SetIsEnabled().

--*/
{
    m_isEnabled = isEnabled;

    return(S_OK);
}


HRESULT
CFsaFilter::SetMaxRecallBuffers(
    IN ULONG maxBuffers
    )

/*++

Implements:

  IFsaFilter::SetMaxRecallBuffers().

--*/
{
    m_maxRecallBuffers = maxBuffers;
    m_isDirty = TRUE;

    return(S_OK);
}


HRESULT
CFsaFilter::SetMaxRecalls(
    IN ULONG maxRecalls
    )

/*++

Implements:

  IFsaFilter::SetMaxRecalls().

--*/
{
    m_maxRecalls = maxRecalls;
    m_isDirty = TRUE;

    return(S_OK);
}


HRESULT
CFsaFilter::SetMinRecallInterval(
    IN ULONG minInterval
    )

/*++

Implements:

  IFsaFilter::SetMinRecallInterval().

--*/
{
    m_minRecallInterval = minInterval;
    m_isDirty = TRUE;

    return(S_OK);
}

HRESULT
CFsaFilter::StopIoctlThread(
    void
    )

/*++

Implements:


 IFsaFilterPriv::StopIoctlThread()

     This stops the IOCTL thread and cancels outstanding IO to the 
     kernel mode File System Filter.

--*/

{
    HRESULT         hr = S_OK;
    RP_MSG          tmp;
    DWORD           outSize;

    WsbTraceIn(OLESTR("CFsaFilter::StopIoctlThread"), OLESTR(""));

    try {

        //
        // Signal the event to indicate to PipeThread that we are terminating
        // It is important to do this first before setting the state to IDLE,
        // to avoid deadlocks/race conditions 
        //
        if (m_terminateEvent != NULL) {
            WsbAffirmStatus(SetEvent(m_terminateEvent));
        }

        if (m_ioctlHandle != INVALID_HANDLE_VALUE) {
            //
            // The right order of shutting down is:
            //  1) Prevent new recalls from starting
            //  2) Canceling outstanding recalls
            //  3) Canceling pending Ioctls
            //
            // Note that (3) above causes the IoctlThread to terminate and close
            // the filter handle before doing so, hence this thread may NOT send
            // any more Ioctls after sending RP_CANCEL_ALL_DEVICEIO !!
            //
            DWORD dwLastErr = NO_ERROR;

            //
            // Tell the filter we are going away and it should fail all recall activity .
            //
            tmp.inout.command = RP_SUSPEND_NEW_RECALLS;
            if (! DeviceIoControl(m_ioctlHandle, FSCTL_HSM_DATA, &tmp,
                        sizeof(RP_MSG),
                        &tmp, sizeof(RP_MSG), &outSize, NULL)) {
                // Save error
                dwLastErr = GetLastError();
            }

            //
            // Cancel any pending recalls
            //
            tmp.inout.command = RP_CANCEL_ALL_RECALLS;
            if (! DeviceIoControl(m_ioctlHandle, FSCTL_HSM_DATA, &tmp,
                        sizeof(RP_MSG),
                        &tmp, sizeof(RP_MSG), &outSize, NULL)) {
                // Save error
                if (dwLastErr != NO_ERROR) {
                    dwLastErr = GetLastError();
                }
            }

            //
            // Set the filter state to idle
            //
            EnterCriticalSection(&m_stateLock);
            m_state = HSM_JOB_STATE_IDLE;

            //
            // Cancel the IOCTLS in the kernel filter.
            //
            tmp.inout.command = RP_CANCEL_ALL_DEVICEIO;
            BOOL bTmpStatus = DeviceIoControl(m_ioctlHandle, FSCTL_HSM_DATA, &tmp,
                        sizeof(RP_MSG),
                        &tmp, sizeof(RP_MSG), &outSize, NULL);

            LeaveCriticalSection(&m_stateLock);
            WsbAffirmStatus(bTmpStatus);

            // Throw if a previous error occurred
            if (dwLastErr != NO_ERROR) {
                hr = HRESULT_FROM_WIN32(dwLastErr);
                WsbAffirmHr(hr);
            }
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaFilter::StopIoctlThread"), OLESTR("Hr = %ls"), WsbHrAsString(hr));

    return(0);
}




DWORD FsaIoctlThread(
    void* pVoid
    )

/*++


--*/
{
HRESULT     hr;

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    hr = ((CFsaFilter*) pVoid)->IoctlThread();
    CoUninitialize();
    return(hr);
}



DWORD FsaPipeThread(
    void* pVoid
    )

/*++


--*/
{
HRESULT     hr;

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    hr = ((CFsaFilter*) pVoid)->PipeThread();
    CoUninitialize();
    return(hr);
}



HRESULT
CFsaFilter::Start(
    void
    )

/*++

Implements:

  IFsaFilter::Start().

--*/
{
    HRESULT                 hr = S_OK;
    HSM_JOB_STATE           oldState;
	DWORD					tid;

    WsbTraceIn(OLESTR("CFsaFilter::Start"), OLESTR(""));
    
    try {
        //
        // Create the event that is used to signal termination
        //
        WsbAffirmHandle((m_terminateEvent = CreateEvent(NULL,
                                                        TRUE,
                                                        FALSE,
                                                        NULL)));

        WsbAffirm((HSM_JOB_STATE_IDLE == m_state) || (HSM_JOB_STATE_CANCELLED == m_state), E_UNEXPECTED);
         
        oldState = m_state;
        m_state = HSM_JOB_STATE_STARTING;

        try {

            // TBD - Do whatever it takes to start.
            // 
            // This consists of starting a thread that will issue the IOCTL
            // requests to the kernel mode filter.  These IOCTL requests 
            // will complete when the kernel mode filter detects that a 
            // recall is needed.
            //

            WsbAffirm((m_pipeThread = CreateThread(0, 0, FsaPipeThread, (void*) this, 0, &tid)) != 0, HRESULT_FROM_WIN32(GetLastError()));
 
            if (m_pipeThread == NULL) {           
                m_state = oldState;
                WsbAssertHr(E_FAIL);  // TBD What error to return here??
            }

            WsbAffirm((m_ioctlThread = CreateThread(0, 0, FsaIoctlThread, (void*) this, 0, &tid)) != 0, HRESULT_FROM_WIN32(GetLastError()));
 
            if (m_ioctlThread == NULL) {           
                m_state = oldState;
                WsbAssertHr(E_FAIL);  // TBD What error to return here??
            }


        } WsbCatchAndDo(hr, m_state = oldState;);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaFilter::Start"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CFsaFilter::Test(
    USHORT* passed,
    USHORT* failed
    )

/*++

Implements:

  IWsbTestable::Test().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != passed, E_POINTER);
        WsbAssert(0 != failed, E_POINTER);

        *passed = 0;
        *failed = 0;

    } WsbCatch(hr);

    return(hr);
}


NTSTATUS
CFsaFilter::TranslateHresultToNtStatus(
    HRESULT hr
    )

/*++

Implements:

  CFsaFilter::TranslateHresultToNtStatus().

--*/
{
    NTSTATUS        ntStatus = 0;
    DWORD           w32Error;
    
    switch (hr) {
        case RMS_E_CARTRIDGE_BUSY:
            ntStatus = STATUS_FILE_IS_OFFLINE;
            break;

        case RMS_E_DRIVE_BUSY:
        case RMS_E_TIMEOUT:
        case RMS_E_CARTRIDGE_UNAVAILABLE:
            ntStatus = STATUS_FILE_IS_OFFLINE;
            break;

        case RMS_E_LIBRARY_UNAVAILABLE:
        case RMS_E_NTMS_NOT_CONNECTED:
            ntStatus = STATUS_FILE_IS_OFFLINE;
            break;

        case ERROR_IO_DEVICE:
            ntStatus = STATUS_REMOTE_STORAGE_MEDIA_ERROR;
            break;

        case STATUS_END_OF_FILE:
            ntStatus = hr;
            break;

        case E_FAIL:    
            ntStatus = STATUS_FILE_IS_OFFLINE;
            break;

        default:
            if (hr & FACILITY_NT_BIT) {
                //
                // NT status code - return it unchanged (except for removing the facility bit)
                //
                ntStatus = hr & ~(FACILITY_NT_BIT);
            } else if (FACILITY_WIN32 == HRESULT_FACILITY(hr)) {
                w32Error = hr & 0x0000ffff;
                //
                // Now convert the win32 error to a NT status code.
                //
                // Since there does not seem to be any easy macro to do this we convert the most common ones
                // and punt on the rest.
                //
                switch (w32Error) {
                    case ERROR_NOT_ENOUGH_MEMORY:
                    case ERROR_OUTOFMEMORY:
                        ntStatus = STATUS_NO_MEMORY;
                        break;

                    case ERROR_HANDLE_DISK_FULL:
                    case ERROR_DISK_FULL:
                        ntStatus = STATUS_DISK_FULL;
                        break;

                    default:
                        ntStatus = STATUS_FILE_IS_OFFLINE;
                        break;
                }
            } else {
                ntStatus = STATUS_FILE_IS_OFFLINE;
            }
            break;
    }

    return(ntStatus);
}



HRESULT
CFsaFilter::DoRecallAction(
    PFSA_IOCTL_CONTROL pIoCmd
    )

/*++

Implements:


 CFsaFilter::DoRecallAction()
    
    Find the already created recall object and start the data transfer.

--*/


{
CComPtr<IFsaFilterRecall>       pRecall;
CComPtr<IFsaFilterRecallPriv>   pRecallPriv;
CComPtr<IFsaResource>           pRecallResource;
HRESULT                         hr = S_OK;
RP_MSG                          tmp;
DWORD                           outSize;
BOOL                            gotToInit = FALSE;

    //
    //
    try {
        //
        // Get the Filter ID and find the recall object.
        //
        pRecall = NULL;
        WsbAffirmHr(CoCreateInstance(CLSID_CFsaFilterRecallNTFS,
            NULL, CLSCTX_SERVER, IID_IFsaFilterRecallPriv, 
            (void**) &pRecallPriv));

        WsbAffirmHr(pRecallPriv->SetDriversRecallId(pIoCmd->out.msg.rReq.filterId));
        WsbAffirmHr(pRecallPriv->SetThreadId(pIoCmd->out.msg.rReq.threadId));
        WsbAffirmHr(pRecallPriv->CompareBy(FSA_RECALL_COMPARE_ID));

        EnterCriticalSection(&m_recallLock);
        hr = m_pRecalls->Find(pRecallPriv, IID_IFsaFilterRecall, (void**) &pRecall);
        LeaveCriticalSection(&m_recallLock);

        WsbAffirmHr(hr);

        WsbAffirmHr(pRecall->CheckRecallLimit(m_minRecallInterval, m_maxRecalls, (BOOLEAN)( m_exemptAdmin ? TRUE : FALSE ) ) );
       
        pRecallPriv = 0;

        WsbAffirmHr(pRecall->QueryInterface(IID_IFsaFilterRecallPriv, (void**) &pRecallPriv));
        
        WsbTrace(OLESTR("CFsaFilter::DoRecallAction: Recall object Found - Calling StartRecall.\n"));
    
        // Set marker for event logging.  If we have failed before this point
        // we want to issue an event.  Init logs it's own events
        //
        gotToInit = TRUE;
        WsbAffirmHr(pRecallPriv->StartRecall(pIoCmd->out.msg.rReq.offset, 
                    pIoCmd->out.msg.rReq.length));
    
        WsbTrace(OLESTR("CFsaFilter::DoRecallAction: Recall Started.\n"));
    
    } WsbCatchAndDo(hr,
        //
        // Something failed while setting up the recall.
        // Free any resources required and
        // tell the kernel mode filter that the recall failed.
        //
        tmp.inout.status = TranslateHresultToNtStatus(hr);
        tmp.inout.command = RP_RECALL_COMPLETE;
        tmp.msg.rRep.actionFlags = 0;
        tmp.msg.rRep.filterId = pIoCmd->out.msg.rReq.filterId;
        DeviceIoControl(m_ioctlHandle, FSCTL_HSM_DATA, &tmp, sizeof(RP_MSG),
                        &tmp, sizeof(RP_MSG), &outSize, NULL);

        WsbTrace(OLESTR("CFsaFilter::DoRecallAction: Exception during recall processing.\n"));
    
        if (FALSE == gotToInit)  {
            CWsbStringPtr   pName; 
            HRESULT hrPath = E_FAIL;
            //
            //  If we didn't complete init and the error was not due to the runaway recall limit, then we need to log an event here.
            //  Otherwise, an event is already sent.
            //
            //  Get path of file failing recall.
            if (pRecall != 0) {
                hrPath = pRecall->GetPath((OLECHAR**) &pName, 0);
            }

            if (SUCCEEDED(hrPath) && ((WCHAR *)pName != NULL)) {
                WsbLogEvent(FSA_MESSAGE_RECALL_FAILED, 0, NULL, (OLECHAR*) WsbAbbreviatePath(pName, 120), WsbHrAsString(hr), NULL);
            } else {
                if (pRecall != 0) {
                    WsbLogEvent(FSA_MESSAGE_RECALL_FAILED_NOT_READY, 0, NULL, OLESTR("Path is null"), WsbHrAsString(hr), NULL);
                } else {
                    WsbLogEvent(FSA_MESSAGE_RECALL_FAILED_NOT_READY, 0, NULL, OLESTR("File not found"), WsbHrAsString(hr), NULL);
                }
            }

            //
            //  We also have to free the recall object
            //
            if (pRecall != NULL) {
                EnterCriticalSection(&m_recallLock);
                m_pRecalls->RemoveAndRelease(pRecall);
                LeaveCriticalSection(&m_recallLock);
            } 
        }

        );
    //
    // Cleanup any old client structures
    // TBD This should be async and not in the recall path
    //
    CleanupClients();

    return(hr);
}




HRESULT
CFsaFilter::DoOpenAction(
    PFSA_IOCTL_CONTROL pIoCmd
    )

/*++

Implements:


 CFsaFilter::DoOpenAction()
    
    Create an entry for the user opening the file and start the reall notification identification process.

--*/


{
CComPtr<IFsaFilterClient>       pClient, pFoundClient;
CComPtr<IFsaFilterRecallPriv>   pRecallPriv;
CComPtr<IFsaResource>           pRecallResource;
CComPtr<IFsaScanItem>           pScanItem;
HRESULT                         hr = S_OK;
PRP_MSG                         aTmp = NULL;
RP_MSG                          tmp;
DWORD                           ioLen, outSize;
FSA_PLACEHOLDER                 placeHolder;
OLECHAR                         *pPath = NULL;
DWORD                           nameLen;
DWORD                           dNameLen;
CWsbStringPtr                   uName;
CWsbStringPtr                   dName;
CWsbStringPtr                   idPath;
WCHAR                           userName[USER_NAME_LEN];
WCHAR                           domainName[USER_NAME_LEN];
SID_NAME_USE                    nUse;
BOOL                            gotToInit = FALSE;
LONGLONG                        fileId;    
BOOL                            status;
DWORD                           lErr;

    //
    // Got a recall request from the filter.  Create the
    // necessary objects.  The recall is not actually started until the first read or write.
    //
    //  See if a client object already exists for the
    //  authentication ID given by the filter driver.
    //  If it was found then check the runaway recall limit
    //  and fail the recall if the limit has been reached.
    //  If the client object does not exist then create it
    //  and start the identification process (this is done by 
    //  the client object).
    //  Get the resource interface for the volume the file is on.
    //  Create the recall object and initialize it.
    //
    try {
        ULONG numEnt;
    
        //
        // Get the file path from the filter.
        // We get it in a separate call because the path and 
        // security information could be very large.
        // Allocate the amount of space we will need and make the 
        // IOCTL call to get it.
        //
        ioLen = sizeof(RP_MSG) + pIoCmd->out.msg.oReq.userInfoLen +
                pIoCmd->out.msg.oReq.nameLen;
    
        WsbAffirmPointer((aTmp = (RP_MSG *) malloc(ioLen)));
    
        aTmp->inout.command = RP_GET_RECALL_INFO;
        aTmp->msg.riReq.filterId = pIoCmd->out.msg.oReq.filterId;
        status = DeviceIoControl(m_ioctlHandle, FSCTL_HSM_DATA, aTmp,
                    ioLen,
                    aTmp, ioLen, &outSize, NULL);

        if (!status) {
            lErr = GetLastError();
            if (lErr == ERROR_FILE_NOT_FOUND) {
                //
                // This is OK - the file must have been closed
                // We can just bail out.
                WsbThrow(S_OK);
            } else {
                //
                // Anything else must be an error
                //
                WsbThrow(HRESULT_FROM_WIN32(lErr));
            }
        }
                
    
        //
        // The path is UNICODE and in the format of
        // \path\file.ext.
        // or if open by ID the the ID is in the message
        //
        fileId = aTmp->msg.riReq.fileId;
        
        pPath = (OLECHAR *) ((CHAR *) &aTmp->msg.riReq.userToken +
                            pIoCmd->out.msg.oReq.userInfoLen);
    
        //
        // Get the resource interface via the serial number
        //

        WsbAffirmHr(m_pFsaServer->FindResourceBySerial(pIoCmd->out.msg.oReq.serial, &pRecallResource));
    
        WsbTrace(OLESTR("CFsaFilter::DoOpenAction: Found the resource.\n"));

        //if (pIoCmd->out.msg.oReq.options & FILE_OPEN_BY_FILE_ID) {
        //    if ((pIoCmd->out.msg.oReq.objIdHi != 0) || (pIoCmd->out.msg.oReq.objIdLo != 0)) {
        //        WsbAffirmHr(pRecallResource->FindObjectId(pIoCmd->out.msg.oReq.objIdHi, pIoCmd->out.msg.oReq.objIdLo, NULL, &pScanItem));
        //    } else {
        //        WsbAffirmHr(pRecallResource->FindFileId(pIoCmd->out.msg.oReq.fileId, NULL, &pScanItem));
        //    }
        //    WsbAffirmHr(pScanItem->GetPathAndName(NULL, &idPath, 0));
        //    pPath = idPath;
        //}
    
        WsbTrace(OLESTR("CFsaFilter::DoOpenAction: Recall request for <%ls>\n"),
                WsbAbbreviatePath(pPath, 120));

        pFoundClient = NULL;
        //
        // Recall notification is not done for no-recall operations - skip the client stuf
        //
        if (!(pIoCmd->out.msg.oReq.options & FILE_OPEN_NO_RECALL)) {
           //
           // Set up the client interface.
           // If one has not been created for this authentication ID then
           // create one now.
           // 
       
           WsbTrace(OLESTR("CFsaFilter::DoOpenAction: Client ID is %x:%x.\n"),
                   pIoCmd->out.msg.oReq.userAuthentication.HighPart, 
                   pIoCmd->out.msg.oReq.userAuthentication.LowPart);
       
           WsbAffirmHr(CoCreateInstance(CLSID_CFsaFilterClientNTFS, NULL, CLSCTX_SERVER, IID_IFsaFilterClient, (void**) &pClient));
           WsbAffirmHr(pClient->SetAuthenticationId(pIoCmd->out.msg.oReq.userAuthentication.HighPart, pIoCmd->out.msg.oReq.userAuthentication.LowPart));
           WsbAffirmHr(pClient->SetTokenSource(pIoCmd->out.msg.oReq.tokenSource));
           WsbAffirmHr(pClient->CompareBy(FSA_FILTERCLIENT_COMPARE_ID));
       
           EnterCriticalSection(&m_clientLock);
           hr = m_pClients->Find(pClient, IID_IFsaFilterClient, (void**) &pFoundClient);
           LeaveCriticalSection(&m_clientLock);
       
           if (hr == WSB_E_NOTFOUND) {
               //
               // Did not find an existing client structure - 
               // use the one we created for the find to initialize a new
               // one.  Add it to the collection in the filter object. 
               //
               WsbTrace(OLESTR("CFsaFilter::DoOpenAction: Create new client object.\n"));
       
               EnterCriticalSection(&m_clientLock);
               hr = m_pClients->Add(pClient);
               LeaveCriticalSection(&m_clientLock);
               WsbAffirmHr(hr);
               pFoundClient = pClient;
       
               //
               // Get the username from the SID passed from the 
               // kernel mode filter.
               //
               try {
                   nameLen = USER_NAME_LEN;
                   dNameLen = USER_NAME_LEN;
                   WsbAffirmStatus((LookupAccountSidW(NULL, 
                           (PSID) &aTmp->msg.riReq.userToken,
                           userName, &nameLen, 
                           domainName, &dNameLen, &nUse)));
       
                   WsbTrace(OLESTR("CFsaFilter::DoOpenAction: User = %ls/%ls.\n"),
                           domainName, userName);
       
               } WsbCatchAndDo(hr,
                   //
                   // We do not consider it a fatal error if we cannot
                   // get the user name and domain.
                   //
                   WsbTrace(OLESTR("CFsaFilter::DoOpenAction: Failed to get the user name - %x.\n"),
                           GetLastError());
                   wcscpy(userName, L"");
                   wcscpy(domainName, L"");
               );
       
               WsbAffirmHr(pFoundClient->SetUserName(userName));
               WsbAffirmHr(pFoundClient->SetDomainName(domainName));
           } else {
               //
               // The find did not return WSB_E_NOTFOUND.  Make sure it was not
               // some other error.
               //
               WsbAffirmHr(hr);
               WsbTrace(OLESTR("CFsaFilter::DoOpenAction: Found the client object.\n"));
               WsbAffirmHr(pFoundClient->GetUserName((OLECHAR **) &uName, 0));
               WsbAffirmHr(pFoundClient->GetDomainName((OLECHAR **) &dName, 0));
               wcsncpy(userName, (WCHAR *) uName, USER_NAME_LEN);
               wcsncpy(domainName, (WCHAR *) dName, USER_NAME_LEN);
           }
       
           WsbTrace(OLESTR("CFsaFilter::DoOpenAction: User = %ls/%ls.\n"),
                   domainName, userName);
   
           //
           // Start the identification process if needed
           //
           // TBD This might be better done in an async fashion.
           //
           WsbAffirmHr(pFoundClient->StartIdentify());
           WsbAffirmHr(pFoundClient->SetIsAdmin((BOOLEAN) pIoCmd->out.msg.oReq.isAdmin));
        }
        
        WsbTrace(OLESTR("CFsaFilter::DoOpenAction: Building recall request.\n"));
        //
        // Fill in the placeholder data the filter object will need
        //
        WsbAffirmHr(CopyRPDataToPlaceholder(&(pIoCmd->out.msg.oReq.eaData), &placeHolder));
        
        //
        // Now start the recall
        // 
        //
        // Create the recall interface and initialize it.
        // 
    
        WsbAffirmHr(CoCreateInstance(CLSID_CFsaFilterRecallNTFS,
            NULL, CLSCTX_SERVER, IID_IFsaFilterRecallPriv, 
            (void**) &pRecallPriv));
    
        WsbTrace(OLESTR("CFsaFilter::DoOpenAction: Recall object created.\n"));
    
        //
        //  Add it to the collection 
        //
        EnterCriticalSection(&m_recallLock);
        hr = m_pRecalls->Add(pRecallPriv);
        LeaveCriticalSection(&m_recallLock);
        WsbAffirmHr(hr);
    
        hr = m_pRecalls->GetEntries(&numEnt);
        WsbTrace(OLESTR("CFsaFilter::DoOpenAction: Recall queue has %u entries. Calling Init.\n"),
                numEnt);

        //
        // Set marker for event logging.  If we have failed before this point
        // we want to issue an event.  Init logs it's own events
        //
        gotToInit = TRUE;
        WsbAffirmHr(pRecallPriv->Init(pFoundClient, 
                    pIoCmd->out.msg.oReq.filterId, 
                    pRecallResource, pPath, fileId,
                    pIoCmd->out.msg.oReq.offset.QuadPart,
                    pIoCmd->out.msg.oReq.size.QuadPart,
                    pIoCmd->out.msg.oReq.options,
                    &placeHolder, 
                    (IFsaFilterPriv*) this));
    
        WsbTrace(OLESTR("CFsaFilter::DoOpenAction: Init complete.\n"));
    
        free(aTmp);
        aTmp = NULL;
    
    } WsbCatchAndDo(hr,
        //
        // Something failed while setting up the recall.
        // Free any resources required and
        // tell the kernel mode filter that the recall failed.
        //
        if (hr != S_OK) {
           tmp.inout.status = TranslateHresultToNtStatus(hr);
           tmp.inout.command = RP_RECALL_COMPLETE;
           tmp.msg.rRep.actionFlags = 0;
           tmp.msg.rRep.filterId = pIoCmd->out.msg.oReq.filterId;
           DeviceIoControl(m_ioctlHandle, FSCTL_HSM_DATA, &tmp, sizeof(RP_MSG),
                           &tmp, sizeof(RP_MSG), &outSize, NULL);
   
           WsbTrace(OLESTR("CFsaFilter::DoOpenAction: Exception during recall processing.\n"));
        }

        //  NOTE:  IF RUNAWAY RECALL BEHAVIOR CHANGES TO TRUNCATE ON CLOSE, CHANGE
        //  FSA_MESSAGE_HIT_RECALL_LIMIT_ACCESSDENIED TO FSA_MESSAGE_HIT_RECALL_LIMIT_TRUNCATEONCLOSE.
    
        if ((hr != S_OK) && (FALSE == gotToInit))  {
            //  If we didn't complete init, then we need to log an event here.
            //  Otherwise, an event is already sent.
            if (hr == FSA_E_HIT_RECALL_LIMIT) {
                WsbLogEvent(FSA_MESSAGE_HIT_RECALL_LIMIT_ACCESSDENIED, 0, NULL, userName, NULL);
            } else {
                WsbLogEvent(FSA_MESSAGE_RECALL_FAILED, 0, NULL, (OLECHAR*) WsbAbbreviatePath(pPath, 120), WsbHrAsString(hr), NULL);
            }
        }

        if (NULL != aTmp)
            free(aTmp);
        aTmp = NULL;
        );
    //
    // Cleanup any old client structures
    // TBD This should be async and not in the recall path
    //
    CleanupClients();

    return(hr);
}


HRESULT
CFsaFilter::DoRecallWaitingAction(
    PFSA_IOCTL_CONTROL pIoCmd
    )

/*++

Implements:


 CFsaFilter::DoRecallWaitingAction()
    
   Start the reall notification identification process: this is just another client
   waiting on an already issued recall

--*/


{
CComPtr<IFsaFilterClient>       pClient, pFoundClient;
CComPtr<IFsaFilterRecallPriv>   pRecallPriv;
CComPtr<IFsaFilterRecall>       pRecall;
CComPtr<IFsaResource>           pRecallResource;
CComPtr<IFsaScanItem>           pScanItem;
HRESULT                         hr = S_OK;
PRP_MSG                         aTmp = NULL;
DWORD                           ioLen, outSize;
OLECHAR                         *pPath = NULL;
DWORD                           nameLen;
DWORD                           dNameLen;
CWsbStringPtr                   uName;
CWsbStringPtr                   dName;
CWsbStringPtr                   idPath;
WCHAR                           userName[USER_NAME_LEN];
WCHAR                           domainName[USER_NAME_LEN];
SID_NAME_USE                    nUse;
LONGLONG                        fileId;    
BOOL                            status;
DWORD                           lErr;

    //
    // Got a recall request from the filter.  Create the
    // necessary objects.  The recall is not actually started until the first read or write.
    //
    //  See if a client object already exists for the
    //  authentication ID given by the filter driver.
    //  If it was found then check the runaway recall limit
    //  and fail the recall if the limit has been reached.
    //  If the client object does not exist then create it
    //  and start the identification process (this is done by 
    //  the client object).
    //  Get the resource interface for the volume the file is on.
    //  Create the recall object and initialize it.
    //
    try {
    
        //
        // Get the file path from the filter.
        // We get it in a separate call because the path and 
        // security information could be very large.
        // Allocate the amount of space we will need and make the 
        // IOCTL call to get it.
        //
        ioLen = sizeof(RP_MSG) + pIoCmd->out.msg.oReq.userInfoLen +
                pIoCmd->out.msg.oReq.nameLen;
    
        WsbAffirmPointer((aTmp = (RP_MSG *) malloc(ioLen)));
    
        aTmp->inout.command = RP_GET_RECALL_INFO;
        aTmp->msg.riReq.filterId = pIoCmd->out.msg.oReq.filterId;
        status = DeviceIoControl(m_ioctlHandle, FSCTL_HSM_DATA, aTmp,
                    ioLen,
                    aTmp, ioLen, &outSize, NULL);

        if (!status) {
            lErr = GetLastError();
            if (lErr == ERROR_FILE_NOT_FOUND) {
                //
                // This is OK - the file must have been closed
                // We can just bail out.
                WsbThrow(S_OK);
            } else {
                //
                // Anything else must be an error
                //
                WsbThrow(HRESULT_FROM_WIN32(lErr));
            }
        }
                
    
        //
        // The path is UNICODE and in the format of
        // \path\file.ext.
        // or if open by ID the the ID is in the message
        //
        fileId = aTmp->msg.riReq.fileId;
        
        pPath = (OLECHAR *) ((CHAR *) &aTmp->msg.riReq.userToken +
                            pIoCmd->out.msg.oReq.userInfoLen);
    
        //
        // Get the resource interface via the serial number
        //

        WsbAffirmHr(m_pFsaServer->FindResourceBySerial(pIoCmd->out.msg.oReq.serial, &pRecallResource));
    
        WsbTrace(OLESTR("CFsaFilter::DoRecallWaitingAction: Found the resource.\n"));

        WsbTrace(OLESTR("CFsaFilter::DoRecallWaitingAction: Recall request for <%ls>\n"),
                WsbAbbreviatePath(pPath, 120));

        pFoundClient = NULL;
        //
        // Recall notification is not done for no-recall operations - skip the client stuf
        //
        if (!(pIoCmd->out.msg.oReq.options & FILE_OPEN_NO_RECALL)) {
           //
           // Set up the client interface.
           // If one has not been created for this authentication ID then
           // create one now.
           // 
       
           WsbTrace(OLESTR("CFsaFilter::DoRecallWaitingAction: Client ID is %x:%x.\n"),
                   pIoCmd->out.msg.oReq.userAuthentication.HighPart, 
                   pIoCmd->out.msg.oReq.userAuthentication.LowPart);
       
           WsbAffirmHr(CoCreateInstance(CLSID_CFsaFilterClientNTFS, NULL, CLSCTX_SERVER, IID_IFsaFilterClient, (void**) &pClient));
           WsbAffirmHr(pClient->SetAuthenticationId(pIoCmd->out.msg.oReq.userAuthentication.HighPart, pIoCmd->out.msg.oReq.userAuthentication.LowPart));
           WsbAffirmHr(pClient->SetTokenSource(pIoCmd->out.msg.oReq.tokenSource));
           WsbAffirmHr(pClient->CompareBy(FSA_FILTERCLIENT_COMPARE_ID));
           EnterCriticalSection(&m_clientLock);
           hr = m_pClients->Find(pClient, IID_IFsaFilterClient, (void**) &pFoundClient);
           LeaveCriticalSection(&m_clientLock);
           if (hr == WSB_E_NOTFOUND) {
               //
               // Did not find an existing client structure - 
               // use the one we created for the find to initialize a new
               // one.  Add it to the collection in the filter object. 
               //
               WsbTrace(OLESTR("CFsaFilter::DoRecallWaitingAction: Create new client object.\n"));
       
               EnterCriticalSection(&m_clientLock);
               hr = m_pClients->Add(pClient);
               LeaveCriticalSection(&m_clientLock);
               WsbAffirmHr(hr);
               pFoundClient = pClient;
       
               //
               // Get the username from the SID passed from the 
               // kernel mode filter.
               //
               try {
                   nameLen = USER_NAME_LEN;
                   dNameLen = USER_NAME_LEN;
                   WsbAffirmStatus((LookupAccountSidW(NULL, 
                           (PSID) &aTmp->msg.riReq.userToken,
                           userName, &nameLen, 
                           domainName, &dNameLen, &nUse)));
       
                   WsbTrace(OLESTR("CFsaFilter::DoRecallWaitingAction: User = %ls/%ls.\n"),
                           domainName, userName);
       
               } WsbCatchAndDo(hr,
                   //
                   // We do not consider it a fatal error if we cannot
                   // get the user name and domain.
                   //
                   WsbTrace(OLESTR("CFsaFilter::DoRecallWaitingAction: Failed to get the user name - %x.\n"),
                           GetLastError());
                   wcscpy(userName, L"");
                   wcscpy(domainName, L"");
               );
       
               WsbAffirmHr(pFoundClient->SetUserName(userName));
               WsbAffirmHr(pFoundClient->SetDomainName(domainName));
           } else {
               //
               // The find did not return WSB_E_NOTFOUND.  Make sure it was not
               // some other error.
               //
               WsbAffirmHr(hr);
               WsbTrace(OLESTR("CFsaFilter::DoRecallWaitingAction: Found the client object.\n"));
               WsbAffirmHr(pFoundClient->GetUserName((OLECHAR **) &uName, 0));
               WsbAffirmHr(pFoundClient->GetDomainName((OLECHAR **) &dName, 0));
               wcsncpy(userName, (WCHAR *) uName, USER_NAME_LEN);
               wcsncpy(domainName, (WCHAR *) dName, USER_NAME_LEN);
           }
           WsbTrace(OLESTR("CFsaFilter::DoRecallWaitingAction: User = %ls/%ls.\n"),
                   domainName, userName);
   
           WsbAffirmHr(CoCreateInstance(CLSID_CFsaFilterRecallNTFS,
                         NULL, CLSCTX_SERVER, IID_IFsaFilterRecallPriv, 
                        (void**) &pRecallPriv));
           WsbAffirmHr(pRecallPriv->SetDriversRecallId((pIoCmd->out.msg.oReq.filterId & 0xFFFFFFFF)));
           WsbAffirmHr(pRecallPriv->CompareBy(FSA_RECALL_COMPARE_CONTEXT_ID));
           EnterCriticalSection(&m_recallLock);
           hr = m_pRecalls->Find(pRecallPriv, IID_IFsaFilterRecall, (void**) &pRecall);
           LeaveCriticalSection(&m_recallLock);
        
           WsbAffirmHr(hr);

           //
           // Start the identification process if needed
           //
           // TBD This might be better done in an async fashion.
           //
           WsbAffirmHr(pFoundClient->StartIdentify());
           WsbAffirmHr(pFoundClient->SetIsAdmin((BOOLEAN) pIoCmd->out.msg.oReq.isAdmin));

           // Note: code for the notify itself is moved to AddClient method
           hr = pRecall->AddClient(pFoundClient); 
           if (hr != S_OK) {
               WsbTrace(OLESTR("CFsaFilterRecall::DoRecallWaitingAction: AddClient returned %ls.\n"),
                    WsbHrAsString(hr));

           }
           hr = S_OK;
        }
        free(aTmp);
        aTmp = NULL;
    
    } WsbCatchAndDo(hr,
        //
        // Something failed while setting up the recall.
        // Free any resources required and
        // tell the kernel mode filter that the recall failed.
        //
        if (NULL != aTmp)
            free(aTmp);
        aTmp = NULL;
        );
    //
    // Cleanup any old client structures
    // TBD This should be async and not in the recall path
    //
    CleanupClients();

    return(hr);
}




HRESULT
CFsaFilter::DoNoRecallAction(
    PFSA_IOCTL_CONTROL pIoCmd
    )

/*++

Implements:


 CFsaFilter::DoNoRecallAction()
    
    This is used for read without recall - the data is copied to memory and not
    written to the file.


--*/


{
CComPtr<IFsaFilterClient>       pClient, pFoundClient;
//CComPtr<IFsaFilterRecallPriv>   pRecall;
CComPtr<IFsaFilterRecallPriv>   pRecallPriv;
CComPtr<IFsaResource>           pRecallResource;
CComPtr<IFsaScanItem>           pScanItem;
HRESULT                         hr = S_OK;
PRP_MSG                         aTmp = NULL;
RP_MSG                          tmp;
DWORD                           ioLen, outSize;
FSA_PLACEHOLDER                 placeHolder;
OLECHAR                         *pPath;
CWsbStringPtr                   idPath;
CWsbStringPtr                   uName;
CWsbStringPtr                   dName;
WCHAR                           userName[USER_NAME_LEN];
WCHAR                           domainName[USER_NAME_LEN];


    try {   
    
        //
        // Get the file path from the filter.
        // We get it in a separate call because the path and 
        // security information could be very large.
        // Allocate the amount of space we will need and make the 
        // IOCTL call to get it.
        //
        ioLen = sizeof(RP_MSG) + pIoCmd->out.msg.oReq.userInfoLen +
                pIoCmd->out.msg.oReq.nameLen;
    
        WsbAffirmPointer((aTmp = (RP_MSG *) malloc(ioLen)));
    
        aTmp->inout.command = RP_GET_RECALL_INFO;
        aTmp->msg.riReq.filterId = pIoCmd->out.msg.oReq.filterId;
        WsbAffirmStatus(DeviceIoControl(m_ioctlHandle, FSCTL_HSM_DATA, aTmp,
                    ioLen,
                    aTmp, ioLen, &outSize, NULL));
    
    
        //
        // The path is UNICODE and in the format of
        // \path\file.ext.
        //
        //
        pPath = (OLECHAR *) ((CHAR *) &aTmp->msg.riReq.userToken +
                            pIoCmd->out.msg.oReq.userInfoLen);
    
        WsbTrace(OLESTR("CFsaFilter::DoNoRecallAction: Recall (on read) request for %.80ls.\n"),
                pPath);
    
        //
        // Get the resource interface via the serial number
        //

        WsbAffirmHr(m_pFsaServer->FindResourceBySerial(pIoCmd->out.msg.oReq.serial, &pRecallResource));
    
        WsbTrace(OLESTR("CFsaFilter::DoNoRecallAction: Found the resource.\n"));
    
        if (pIoCmd->out.msg.oReq.options & FILE_OPEN_BY_FILE_ID) {
            if ((pIoCmd->out.msg.oReq.objIdHi != 0) || (pIoCmd->out.msg.oReq.objIdLo != 0)) {
                WsbAffirmHr(pRecallResource->FindObjectId(pIoCmd->out.msg.oReq.objIdHi, pIoCmd->out.msg.oReq.objIdLo, NULL, &pScanItem));
            } else {
                WsbAffirmHr(pRecallResource->FindFileId(pIoCmd->out.msg.oReq.fileId, NULL, &pScanItem));
            }
            WsbAffirmHr(pScanItem->GetPathAndName(NULL, &idPath, 0));
            pPath = idPath;
        }

        //
        // Set up the client interface.
        // If one has not been created for this authentication ID then
        // they are out of luck
        // 
    
        WsbTrace(OLESTR("CFsaFilter::DoNoRecallAction: Client ID is %x:%x.\n"),
                pIoCmd->out.msg.oReq.userAuthentication.HighPart, 
                pIoCmd->out.msg.oReq.userAuthentication.LowPart);
    
        WsbAffirmHr(CoCreateInstance(CLSID_CFsaFilterClientNTFS, NULL, CLSCTX_SERVER, IID_IFsaFilterClient, (void**) &pClient));
        WsbAffirmHr(pClient->SetAuthenticationId(pIoCmd->out.msg.oReq.userAuthentication.HighPart, pIoCmd->out.msg.oReq.userAuthentication.LowPart));
        WsbAffirmHr(pClient->SetTokenSource(pIoCmd->out.msg.oReq.tokenSource));
        WsbAffirmHr(pClient->CompareBy(FSA_FILTERCLIENT_COMPARE_ID));
    
        EnterCriticalSection(&m_clientLock);
        hr = m_pClients->Find(pClient, IID_IFsaFilterClient, (void**) &pFoundClient);
        LeaveCriticalSection(&m_clientLock);
    
        if (hr != WSB_E_NOTFOUND) {
            //
            // The find did not return WSB_E_NOTFOUND.  Make sure it was not
            // some other error.
            //
            WsbAffirmHr(hr);
            WsbTrace(OLESTR("CFsaFilter::DoNoRecallAction: Found the client object.\n"));
            WsbAffirmHr(pFoundClient->GetUserName((OLECHAR **) &uName, 0));
            WsbAffirmHr(pFoundClient->GetDomainName((OLECHAR **) &dName, 0));
            wcsncpy(userName, (WCHAR *) uName, USER_NAME_LEN);
            wcsncpy(domainName, (WCHAR *) dName, USER_NAME_LEN);
            WsbTrace(OLESTR("CFsaFilter::DoNoRecallAction: User = %ls/%ls.\n"),
                    domainName, userName);
            //
            // Start the identification process if needed
            //
            // TBD This might be better done in an async fashion.
            //
            WsbAffirmHr(pFoundClient->StartIdentify());
        } else  {
            WsbTrace(OLESTR("CFsaFilter::DoNoRecallAction: User = UNKNOWN.\n"));
            pFoundClient = 0;
        }

    
        WsbTrace(OLESTR("CFsaFilter::DoNoRecallAction: Building recall request.\n"));
        //
        // Fill in the placeholder data the filter object will need
        //
        if (RP_FILE_IS_TRUNCATED(pIoCmd->out.msg.oReq.eaData.data.bitFlags))
            placeHolder.isTruncated = TRUE;
        else
            placeHolder.isTruncated = FALSE;
    
    
        placeHolder.migrationTime.dwLowDateTime = pIoCmd->out.msg.oReq.eaData.data.migrationTime.LowPart;
        placeHolder.migrationTime.dwHighDateTime = pIoCmd->out.msg.oReq.eaData.data.migrationTime.HighPart;
        placeHolder.hsmId = pIoCmd->out.msg.oReq.eaData.data.hsmId;
        placeHolder.bagId = pIoCmd->out.msg.oReq.eaData.data.bagId;
        placeHolder.fileStart = pIoCmd->out.msg.oReq.eaData.data.fileStart.QuadPart;
        placeHolder.fileSize = pIoCmd->out.msg.oReq.eaData.data.fileSize.QuadPart;
        placeHolder.dataStart = pIoCmd->out.msg.oReq.eaData.data.dataStart.QuadPart;
        placeHolder.dataSize = pIoCmd->out.msg.oReq.eaData.data.dataSize.QuadPart;
        placeHolder.fileVersionId = pIoCmd->out.msg.oReq.eaData.data.fileVersionId.QuadPart;
        placeHolder.verificationData = pIoCmd->out.msg.oReq.eaData.data.verificationData.QuadPart;
        placeHolder.verificationType = pIoCmd->out.msg.oReq.eaData.data.verificationType;
        placeHolder.recallCount = pIoCmd->out.msg.oReq.eaData.data.recallCount;
        placeHolder.recallTime.dwLowDateTime = pIoCmd->out.msg.oReq.eaData.data.recallTime.LowPart;
        placeHolder.recallTime.dwHighDateTime = pIoCmd->out.msg.oReq.eaData.data.recallTime.HighPart;
        placeHolder.dataStreamStart = pIoCmd->out.msg.oReq.eaData.data.dataStreamStart.QuadPart;
        placeHolder.dataStreamSize = pIoCmd->out.msg.oReq.eaData.data.dataStreamSize.QuadPart;
        placeHolder.dataStream = pIoCmd->out.msg.oReq.eaData.data.dataStream;
    
        //
        // Now start the recall
        // 
        //
        // Create the recall interface and initialize it.
        // 
    
        WsbAffirmHr(CoCreateInstance(CLSID_CFsaFilterRecallNTFS,
            NULL, CLSCTX_SERVER, IID_IFsaFilterRecallPriv, 
            (void**) &pRecallPriv));
    
        WsbTrace(OLESTR("CFsaFilter::DoNoRecallAction: Recall object created.\n"));
    
        //
        //  Add it to the collection 
        //
    
        // 
        // Just  add & init
        //
        
        //WsbAffirmHr(pRecallPriv->QueryInterface(IID_IFsaFilterRecall, (void **)&pRecall));
        EnterCriticalSection(&m_recallLock);
        hr = m_pRecalls->Add(pRecallPriv);
        LeaveCriticalSection(&m_recallLock);
        WsbAffirmHr(hr);
    
        WsbTrace(OLESTR("CFsaFilter::DoNoRecallAction: Calling Init.\n"));
    
        WsbAffirmHr(pRecallPriv->Init(pFoundClient, 
                    pIoCmd->out.msg.oReq.filterId, 
                    pRecallResource, pPath,
                    pIoCmd->out.msg.oReq.fileId,
                    pIoCmd->out.msg.oReq.offset.QuadPart,
                    pIoCmd->out.msg.oReq.size.QuadPart,
                    pIoCmd->out.msg.oReq.options,
                    &placeHolder, 
                    (IFsaFilterPriv*) this));
    
    
        WsbTrace(OLESTR("CFsaFilter::DoNoRecallAction: Init complete.\n"));
    
        free(aTmp);
        aTmp = NULL;
    
    } WsbCatchAndDo(hr,
        //
        // Something failed while setting up the recall.
        // Free any resources required and
        // tell the kernel mode filter that the recall failed.
        //
        tmp.inout.status = TranslateHresultToNtStatus(hr);
        tmp.inout.command = RP_RECALL_COMPLETE;
        tmp.msg.rRep.actionFlags = 0;
        tmp.msg.rRep.filterId = pIoCmd->out.msg.oReq.filterId;
        DeviceIoControl(m_ioctlHandle, FSCTL_HSM_DATA, &tmp, sizeof(RP_MSG),
                        &tmp, sizeof(RP_MSG), &outSize, NULL);

        WsbTrace(OLESTR("CFsaFilter::DoNoRecallAction: Exception during recall processing.\n"));
    
        if (NULL != aTmp)
            free(aTmp);
        aTmp = NULL;
        );

    
    return(hr);
}




HRESULT
CFsaFilter::DoCloseAction(
    PFSA_IOCTL_CONTROL pIoCmd
    )

/*++

Implements:


 CFsaFilter::DoCloseAction()
    
    Handles any action that must be done to log the fact that a premigrated files data
    has changed.

--*/


{
HRESULT                 hr = S_OK;
OLECHAR                 *pPath;
CComPtr<IFsaScanItem>   pScanItem;
CComPtr<IFsaResource>   pResource;
CWsbStringPtr           idPath;

    
    try {
        //
        WsbAffirmHr(m_pFsaServer->FindResourceBySerial(pIoCmd->out.msg.oReq.serial, &pResource));
    
        WsbTrace(OLESTR("CFsaFilter::DoCloseAction: Found the resource.\n"));
    
        //
        // The path we give to the recall object does not include the
        // device name.
        //
        WsbAffirmHr(pResource->FindFileId(pIoCmd->out.msg.oReq.fileId, NULL, &pScanItem));
        WsbAffirmHr(pScanItem->GetPathAndName(NULL, &idPath, 0));
        //
        // We are done with this scan item
        //
        pScanItem = 0;
        pPath = idPath;

        WsbTrace(OLESTR("CFsaFilter::DoCloseAction: Close action logging for %.80ls.\n"),
                pPath);


    } WsbCatchAndDo(hr,
        //
        // Something failed while logging the close information.
        // Free any resources required and
        // tell the kernel mode filter that the close logging failed.
        //
    
        WsbTrace(OLESTR("CFsaFilter::DoCloseAction: Exception during close processing.\n"));
        );

    return(hr);

}


HRESULT
CFsaFilter::DoPreDeleteAction(
    PFSA_IOCTL_CONTROL /*pIoCmd*/
    )

/*++

Implements:


 CFsaFilter::DoPreDeleteAction()
    
    Log the possible delete.  Note that the file id is passed and not the name.

--*/
{
HRESULT     hr = S_OK;


    WsbTrace(OLESTR("CFsaFilter::DoPreDeleteAction: Pre-Delete action.\n"));

    return(hr);

}

HRESULT
CFsaFilter::DoPostDeleteAction(
    PFSA_IOCTL_CONTROL /*pIoCmd*/
    )

/*++

Implements:


 CFsaFilter::DoPostDeleteAction()
    
    Log the completed delete.

--*/
{
HRESULT     hr = S_OK;


    WsbTrace(OLESTR("CFsaFilter::DoPostDeleteAction: Post-Delete action.\n"));


    return(hr);

}


HRESULT
CFsaFilter::DoCancelRecall(
    ULONGLONG filterId
    )

/*++

Implements:


 CFsaFilter::DoCancelRecall
    
    Cancel the specified recall request.

--*/
{
HRESULT                         hr = S_OK;
CComPtr<IFsaFilterRecallPriv>   pRecallPriv;
CComPtr<IFsaFilterRecall>       pRecall;


    WsbTraceIn(OLESTR("CFsaFilter::DoCancelRecall"), OLESTR(""));

    try {
        ULONG numEnt;


        if (S_OK == m_pRecalls->GetEntries(&numEnt)) {
            WsbTrace(OLESTR("CFsaFilter::DoCancelRecall: Recall queue has %u entries before cancel\n"),
                numEnt);
        }
        WsbAffirmHr(CoCreateInstance(CLSID_CFsaFilterRecallNTFS, NULL, CLSCTX_SERVER, IID_IFsaFilterRecallPriv, (void**) &pRecallPriv));
        WsbAffirmHr(pRecallPriv->SetDriversRecallId(filterId));
        WsbAffirmHr(pRecallPriv->CompareBy(FSA_RECALL_COMPARE_ID));


        // >>> ENTER CRITICAL SECTION
        EnterCriticalSection(&m_recallLock);
        try {
            //
            // Find the recall, and cancel.
            //
            WsbAffirmHr(m_pRecalls->Find(pRecallPriv, IID_IFsaFilterRecall, (void**) &pRecall));
            pRecallPriv = NULL;
            WsbAffirmHr(pRecall->QueryInterface(IID_IFsaFilterRecallPriv, (void**) &pRecallPriv));
            WsbAffirmHr(pRecallPriv->CancelByDriver());
            //
            // Now remove the recall from our collection
            //
            WsbAffirmHr(m_pRecalls->RemoveAndRelease(pRecallPriv));

            WsbAffirmHr(m_pRecalls->GetEntries(&numEnt));
            WsbTrace(OLESTR("CFsaFilter::DoCancelRecall: Recall queue has %u entries after cancel\n"), numEnt);

        } WsbCatch(hr);
        LeaveCriticalSection(&m_recallLock);
        WsbThrow(hr);
        // <<< LEAVE CRITICAL SECTION


    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaFilter::DoCancelRecall"), OLESTR("Hr = %ls"), WsbHrAsString(hr));
    return(hr);

}




HRESULT
CFsaFilter::IoctlThread(
    void
    )

/*++

Implements:


 IFsaFilterPriv::IoctlThread()

     This is started as a thread and issues IOCTL requests to the 
     kernel mode File System Filter and waits for recall requests.

--*/

{
HRESULT         hr = S_OK;
HANDLE          port = NULL;
ULONG           index;
RP_MSG          tmp;
DWORD           outSize;
OVERLAPPED      *ovlp;
DWORD_PTR       key;
DWORD           lastError = NO_ERROR;
ULONG           numIoPending = 0;
OLECHAR         ioctlDrive[128];
CWsbStringPtr   pDrv;
BOOL            code;
PFSA_IOCTL_CONTROL              pIoCmd, pIo;
PFSA_IOCTL_CONTROL              pIoList = NULL;
SID_IDENTIFIER_AUTHORITY        siaNtAuthority = SECURITY_NT_AUTHORITY;
CComPtr<IFsaResource>           pResource;
BOOL                            ioctlCancelled = FALSE;

    WsbTraceIn(OLESTR("CFsaFilter::IoctlThread"), OLESTR(""));

    try {
        
        //
        // Set the ioctlDrive for the filter.
        // The ioctlDrive needs to be any NTFS drive letter.  By opening
        // any NTFS drive we can issue IOCTL requests that the kernel mode filter
        // will see.  It does not matter if the drive chosen is managed or not.
        // We just get the first resource interface in the list and get its drive 
        // letter to build the string.
        //
        swprintf(ioctlDrive, L"%s", RS_FILTER_SYM_LINK);                 
        WsbTrace(OLESTR("CFsaFilter::IoctlThread: Drive = %ls\n"), ioctlDrive);
        //
        // Now issue several IOCTL requests to the filter driver to get 
        // recall requests.  We must always keep at least one pending
        // so the filter driver has somewhere to go when a migrated file is 
        // opened.  We will issue the configured amount (m_maxRecallBuffers)
        // and wait for completion of any of them via a completion port.
        //
        for (index = 0; index < m_maxRecallBuffers; index++) {
            
            WsbAffirmPointer((pIoCmd = new FSA_IOCTL_CONTROL));
            pIoCmd->next = pIoList;
            pIoList = pIoCmd;
            pIoCmd->overlap.hEvent = NULL;
            pIoCmd->dHand = NULL;
            
            //
            // Create an event, a handle, and put it in the completion port.
            //
            WsbAffirmHandle(pIoCmd->overlap.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL));
            WsbAffirmHandle(pIoCmd->dHand = CreateFile(ioctlDrive, GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, NULL));
    
            WsbAffirmHandle(port = CreateIoCompletionPort(pIoCmd->dHand, port, (DWORD_PTR) pIoCmd, 1));
    
            pIoCmd->in.inout.command = RP_GET_REQUEST;
            pIoCmd->outSize = sizeof(RP_MSG);
            //
            // DeviceIoctlControl should always return ERROR_IO_PENDING
            //
            code = DeviceIoControl(pIoCmd->dHand, FSCTL_HSM_MSG, &pIoCmd->in,
                        sizeof(RP_MSG),
                        &pIoCmd->out, pIoCmd->outSize, &pIoCmd->outSize,
                        &pIoCmd->overlap);

            lastError = GetLastError();
            if ( (code == 0) && (lastError == ERROR_IO_PENDING)) {
                // Life is good
                numIoPending++;
            } else {
                WsbTrace(OLESTR("CFsaFilter::IoctlThread: DeviceIoControl returned %ls/%ls\n"), 
                        WsbBoolAsString(code), WsbLongAsString(lastError));
            }       
        }
    
        WsbTrace(OLESTR("CFsaFilter::IoctlThread: %ls ioctls issued successfully.\n"), WsbLongAsString(numIoPending));

        //
        // If we failed to send all Ioctls to the filter, there's no point in continuing - abort
        // (note that the thread will log FSA_MESSAGE_IOCTLTHREADFAILED before terminating)
        //
        if (0 == numIoPending) {
            hr = HRESULT_FROM_WIN32(lastError);
            WsbTrace(OLESTR("CFsaFilter::IoctlThread: no ioctls issued successfully. hr=%ls\n"), WsbHrAsString(hr));
            WsbAffirmHr(hr);
        }

        //
        // Open the handle we will use for commands to the kernel filter
        //
        WsbAffirmHandle(m_ioctlHandle = CreateFile(ioctlDrive, GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL, NULL));

        //
        // Just in case we left the filter with outstanding recalls from a previous
        // debug session or crash we tell it to cancel everything now.
        //
    
        tmp.inout.command = RP_CANCEL_ALL_RECALLS;
        WsbAffirmStatus(DeviceIoControl(m_ioctlHandle, FSCTL_HSM_DATA, &tmp,
                    sizeof(RP_MSG),
                    &tmp, sizeof(RP_MSG), &outSize, NULL))
    

        //
        // Now that we are ready to get recall requests we can tell the 
        // driver to start checking for recall activity.
        //
    
        tmp.inout.command = RP_ALLOW_NEW_RECALLS;
        WsbAffirmStatus(DeviceIoControl(m_ioctlHandle, FSCTL_HSM_DATA, &tmp,
                    sizeof(RP_MSG),
                    &tmp, sizeof(RP_MSG), &outSize, NULL))
    
        WsbTrace(OLESTR("CFsaFilter::IoctlThread: Kernel level filter recalls enabled.\n"));

        //
        // We are now ready to rock and roll
        //
        m_state = HSM_JOB_STATE_ACTIVE;
    
        //
        // Now just sit around and wait for the IO requests to complete.  When  
        // they do we are either quitting or a recall request was detected.
        //
        while (TRUE) {
            //
            // Wait for an IO request to complete.
            //
            if (! GetQueuedCompletionStatus(port, &outSize, &key, &ovlp, INFINITE)) {
                DWORD dwErr = GetLastError();               
                if (ERROR_OPERATION_ABORTED == dwErr) {
                    numIoPending--;
                    ioctlCancelled = TRUE;          
                }
                WsbAffirmHr(HRESULT_FROM_WIN32(dwErr));
            } else {
                numIoPending--;
            }
            
			pIoCmd = (FSA_IOCTL_CONTROL *) key;
			WsbAffirm(NULL != pIoCmd, E_FAIL);

			WsbTrace(OLESTR("CFsaFilter::IoctlThread: Filter event detected (%x:%x), Id = %I64x.\n"), 
				pIoCmd->out.inout.command,
				pIoCmd->out.msg.oReq.action,
				pIoCmd->out.msg.oReq.filterId);
			switch (pIoCmd->out.inout.command) {
				case RP_OPEN_FILE:
					hr = DoOpenAction(pIoCmd);
					break;

				case RP_RECALL_WAITING:
					hr = DoRecallWaitingAction(pIoCmd);
					break;

				//
				// Must be a cancelled recall
				//
				case RP_CANCEL_RECALL:
					DoCancelRecall(pIoCmd->out.msg.cReq.filterId);
					break;
				case RP_RUN_VALIDATE:
					//
					// A validate job is needed on a given volume (serial number is passed)
					// No completion message is expected by the filter for this action.
					//
					WsbTrace(OLESTR("CFsaFilter::Ioctlthread - Validate job for %x is needed\n"),
							pIoCmd->out.msg.oReq.serial);
					try {
						SYSTEMTIME      sysTime;
						FILETIME        curTime;
						LARGE_INTEGER   ctime;
        
						GetLocalTime(&sysTime);
						WsbAffirmStatus(SystemTimeToFileTime(&sysTime, &curTime));
						ctime.LowPart = curTime.dwLowDateTime;
						ctime.HighPart = curTime.dwHighDateTime;
						ctime.QuadPart += WSB_FT_TICKS_PER_HOUR * 2;
						curTime.dwLowDateTime = ctime.LowPart;
						curTime.dwHighDateTime = ctime.HighPart;
						WsbAffirmStatus(FileTimeToSystemTime(&curTime, &sysTime));
						WsbAffirmHr(m_pFsaServer->FindResourceBySerial(pIoCmd->out.msg.oReq.serial, &pResource));
						WsbAffirmHr(pResource->SetupValidateJob(sysTime));
					} WsbCatchAndDo(hr,
						//
						// Log an event indicating that the validate job should be run manually
						//
						CWsbStringPtr   tmpStr;

						if (pResource != 0) {
							hr = pResource->GetLogicalName(&tmpStr, 0);
							if (hr != S_OK) {
								tmpStr = L"<Unknown Volume>";
							}
						} else {
							tmpStr = L"<Unknown Volume>";
						}
						WsbLogEvent(FSA_MESSAGE_AUTOVALIDATE_SCHEDULE_FAILED, 0, NULL, (OLECHAR *) tmpStr, NULL);
					);
					break;
				case RP_RECALL_FILE:
					hr = DoRecallAction(pIoCmd);
					break;
                    
				case RP_START_NOTIFY:
            
					break;
				case RP_END_NOTIFY:

					break;
				case RP_CLOSE_FILE:
            
					break;
				default:
					WsbTrace(OLESTR("CFsaFilter::IoctlThread: Unknown filter request - %u.\n"), 
						pIoCmd->out.inout.command);
					break;
			}

			WsbTrace(OLESTR("CFsaFilter::IoctlThread: Issue new Ioctl.\n"));
			//
			// If object is still active, reset the event and issue another IOCTL
			//
            EnterCriticalSection(&m_stateLock);
            if (m_state == HSM_JOB_STATE_ACTIVE) {
    			ResetEvent(pIoCmd->overlap.hEvent);
	    		pIoCmd->in.inout.command = RP_GET_REQUEST;
		    	pIoCmd->outSize = sizeof(RP_MSG);
			    code = DeviceIoControl(pIoCmd->dHand, FSCTL_HSM_MSG,
				    	&pIoCmd->in,
					    sizeof(RP_MSG),
					    &pIoCmd->out, pIoCmd->outSize,
					    &pIoCmd->outSize, &pIoCmd->overlap);
                lastError = GetLastError();
                if ( (code == 0) && (lastError == ERROR_IO_PENDING)) {
                    // Life is good
                    numIoPending++;
                } else {
                    WsbTrace(OLESTR("CFsaFilter::IoctlThread: DeviceIoControl returned %ls/%ls\n"), 
                            WsbBoolAsString(code), WsbLongAsString(lastError));
                }       
            } else {
                //
                // Get out of the while loop
                //
                hr = S_OK;
                LeaveCriticalSection(&m_stateLock);
                break;
            }
            LeaveCriticalSection(&m_stateLock);

        } // End while active
    
        //
        // Now tell the filter we are going away and it should fail all recall activity .
        //
        tmp.inout.command = RP_SUSPEND_NEW_RECALLS;
        WsbAffirmStatus(DeviceIoControl(m_ioctlHandle, FSCTL_HSM_DATA, &tmp,
                    sizeof(RP_MSG),
                    &tmp, sizeof(RP_MSG), &outSize, NULL))

    } WsbCatch(hr);

    //
    // We need to wait for rest of Ioctls to be cancelled if we got out of the loop
    // either because the object is not active or the first Ioctl was cancelled
    // We cannot free Ioctl related data safely until all of them are done
    //
    if ((S_OK == hr) || ioctlCancelled) {
        //
        // Try to wait for the rest of the Ioctls to be cancelled 
        //
        HRESULT freeHr;

        hr = S_OK;

        try {
            WsbTrace(OLESTR("CFsaFilter::IoctlThread: Waiting for %lu more Ioctls to complete before freeing their resources\n"), numIoPending);
            for (index = 0; index < numIoPending; index++) {
                if (! GetQueuedCompletionStatus(port, &outSize, &key, &ovlp, 2000)) {
                    DWORD dwErr = GetLastError();               
                    if (ERROR_OPERATION_ABORTED != dwErr) {
                        WsbAffirmHr(HRESULT_FROM_WIN32(dwErr));
                    }
                 }
            }

            //
            // If we got here, all the Ioctls were cancelled or completed as expected.
            // It is safe to free their related resources
            //
            WsbTrace(OLESTR("CFsaFilter::IoctlThread: All of %lu Ioctls completed - free resources\n"), m_maxRecallBuffers);
      		pIoCmd = pIoList;
	        while (pIoCmd != NULL) {
                if (pIoCmd->overlap.hEvent != NULL) {
    		        CloseHandle(pIoCmd->overlap.hEvent);
                }
                if (pIoCmd->dHand != NULL) {
    		        CloseHandle(pIoCmd->dHand);
                }
    	        pIo = pIoCmd;
		        pIoCmd = pIoCmd->next;
		        delete pIo;
	        }
            pIoList = NULL;
            WsbTrace(OLESTR("CFsaFilter::IoctlThread: Freed Ioctls resources successfully\n"));

        } WsbCatchAndDo(freeHr,
            WsbTraceAlways(L"CFsaResource::IoctlThread - Failed to free Ioctls, freeHr = %ls\n", 
                WsbHrAsString(freeHr));
        );

    }

    //
    // Free rest of allocated resources
    // Note that if we couldn't wait for all the Ioctls to complete (or cancel)
    //  we better exit without freeing the Ioctl list
    //
    if (m_ioctlHandle != INVALID_HANDLE_VALUE) {
        CloseHandle(m_ioctlHandle);
        m_ioctlHandle = INVALID_HANDLE_VALUE;
    }
    if (port != NULL) {
        CloseHandle(port);
    }

    if (m_state == HSM_JOB_STATE_ACTIVE) {
        //
        // There must have been an error of some kind 
        //
        WsbLogEvent(FSA_MESSAGE_IOCTLTHREADFAILED, 0, NULL, WsbHrAsString(hr), NULL);
    }

    //
    // Set the filter state to idle
    //
    m_state = HSM_JOB_STATE_IDLE;
		
    WsbTraceOut(OLESTR("CFsaFilter::IoctlThread"), OLESTR("Hr = %ls"), WsbHrAsString(hr));

    return(0);
}
		




HRESULT
CFsaFilter::PipeThread(
    void
    )

/*++

Implements:


 IFsaFilterPriv::PipeThread()

     This is started as a thread and creates the named pipe used by recall notification
     clients to identify themselves.  When an identification response is received we
     impersonate the client, get the authentication token and find the client instance that
     matches the token.  If we find the client object we wet the machine name.

--*/

{
HRESULT                 hr = S_OK;
BOOL                    exitLoop, code, connected;
DWORD                   lastError, bytesRead, retCode;
WCHAR                   pName[100];
WSB_PIPE_MSG            msg; 
CComPtr<IFsaFilterClient>       pClient;
HANDLE                  tHandle = INVALID_HANDLE_VALUE;
HANDLE                  handleArray[2];
DWORD                   retLen;
TOKEN_STATISTICS        tStats;
SHORT                   result;
OVERLAPPED              pOverlap;
WCHAR                   machineName[MAX_COMPUTERNAME_LENGTH + 1];

    memset (&pOverlap, 0, sizeof(OVERLAPPED));
    pOverlap.hEvent = INVALID_HANDLE_VALUE;

    try {

        WsbTraceIn(OLESTR("CFsaFilter::PipeThread"), OLESTR(""));
    
        //
        // Create a client instance to use for finding the client of interest.
        //
        WsbAffirmHr(CoCreateInstance(CLSID_CFsaFilterClientNTFS, NULL, CLSCTX_SERVER, IID_IFsaFilterClient, (void**) &pClient));
    
        //
        //   Create a security scheme that allows anyone to write to the pipe on the client side,
        //   but preserves create-access (therefore creating-server-side privilege) to local system and admins.
        //
        PSID pAdminSID = NULL;
        PSID pSystemSID = NULL;
        PSID pWorldSID = NULL;
        PSID pGuestSID = NULL;
        PACL pACL = NULL;
        PSECURITY_DESCRIPTOR pSD = NULL;
#define     FSA_PIPE_NUM_ACE      4
        EXPLICIT_ACCESS ea[FSA_PIPE_NUM_ACE];
        SID_IDENTIFIER_AUTHORITY SIDAuthNT = SECURITY_NT_AUTHORITY;
        SID_IDENTIFIER_AUTHORITY SIDAuthWorld = SECURITY_WORLD_SID_AUTHORITY;
        SECURITY_ATTRIBUTES sa;

        memset(ea, 0, sizeof(EXPLICIT_ACCESS) * FSA_PIPE_NUM_ACE);

        try {
            // Create a SID for World
            WsbAssertStatus( AllocateAndInitializeSid( &SIDAuthWorld, 1,
                                 SECURITY_WORLD_RID,
                                 0, 0, 0, 0, 0, 0, 0,
                                 &pWorldSID) );

            // Initialize an EXPLICIT_ACCESS structure for an ACE.
            // The ACE allows the World limited access to the pipe
            ea[0].grfAccessPermissions = (FILE_ALL_ACCESS & ~(FILE_CREATE_PIPE_INSTANCE | WRITE_OWNER | WRITE_DAC));
            ea[0].grfAccessMode = SET_ACCESS;
            ea[0].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
            ea[0].Trustee.pMultipleTrustee = NULL;
            ea[0].Trustee.MultipleTrusteeOperation  = NO_MULTIPLE_TRUSTEE;
            ea[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;
            ea[0].Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
            ea[0].Trustee.ptstrName  = (LPTSTR) pWorldSID;

            // Create a SID for Guest
            WsbAssertStatus( AllocateAndInitializeSid( &SIDAuthNT, 2,
                                 SECURITY_BUILTIN_DOMAIN_RID,
                                 DOMAIN_ALIAS_RID_GUESTS,
                                 0, 0, 0, 0, 0, 0,
                                 &pGuestSID) );

            // Initialize an EXPLICIT_ACCESS structure for an ACE.
            // The ACE allows the Guests limited access to the pipe
            ea[1].grfAccessPermissions = (FILE_ALL_ACCESS & ~(FILE_CREATE_PIPE_INSTANCE | WRITE_OWNER | WRITE_DAC));
            ea[1].grfAccessMode = SET_ACCESS;
            ea[1].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
            ea[1].Trustee.pMultipleTrustee = NULL;
            ea[1].Trustee.MultipleTrusteeOperation  = NO_MULTIPLE_TRUSTEE;
            ea[1].Trustee.TrusteeForm = TRUSTEE_IS_SID;
            ea[1].Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
            ea[1].Trustee.ptstrName  = (LPTSTR) pGuestSID;

            // Create a SID for the Administrators group.
            WsbAssertStatus( AllocateAndInitializeSid( &SIDAuthNT, 2,
                                 SECURITY_BUILTIN_DOMAIN_RID,
                                 DOMAIN_ALIAS_RID_ADMINS,
                                 0, 0, 0, 0, 0, 0,
                                 &pAdminSID) );

            // Initialize an EXPLICIT_ACCESS structure for an ACE.
            // The ACE allows the Administrators group full access to the pipe
            ea[2].grfAccessPermissions = FILE_ALL_ACCESS;
            ea[2].grfAccessMode = SET_ACCESS;
            ea[2].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
            ea[2].Trustee.pMultipleTrustee = NULL;
            ea[2].Trustee.MultipleTrusteeOperation  = NO_MULTIPLE_TRUSTEE;
            ea[2].Trustee.TrusteeForm = TRUSTEE_IS_SID;
            ea[2].Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
            ea[2].Trustee.ptstrName  = (LPTSTR) pAdminSID;

            // Create a SID for the local system account
            WsbAssertStatus( AllocateAndInitializeSid( &SIDAuthNT, 1,
                                 SECURITY_LOCAL_SYSTEM_RID,
                                 0, 0, 0, 0, 0, 0, 0,
                                 &pSystemSID) );

            // Initialize an EXPLICIT_ACCESS structure for an ACE.
            // The ACE allows the local system full access to the pipe
            ea[3].grfAccessPermissions = FILE_ALL_ACCESS;
            ea[3].grfAccessMode = SET_ACCESS;
            ea[3].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
            ea[3].Trustee.pMultipleTrustee = NULL;
            ea[3].Trustee.MultipleTrusteeOperation  = NO_MULTIPLE_TRUSTEE;
            ea[3].Trustee.TrusteeForm = TRUSTEE_IS_SID;
            ea[3].Trustee.TrusteeType = TRUSTEE_IS_USER;
            ea[3].Trustee.ptstrName  = (LPTSTR) pSystemSID;

            // Create a new ACL that contains the new ACEs.
            WsbAffirmNoError( SetEntriesInAcl(FSA_PIPE_NUM_ACE, ea, NULL, &pACL));

            // Initialize a security descriptor.  
            pSD = (PSECURITY_DESCRIPTOR) WsbAlloc(SECURITY_DESCRIPTOR_MIN_LENGTH); 
            WsbAffirmPointer(pSD);
            WsbAffirmStatus(InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION));
 
            // Add the ACL to the security descriptor. 
            WsbAffirmStatus(SetSecurityDescriptorDacl(
                                pSD, 
                                TRUE,     // fDaclPresent flag   
                                pACL, 
                                FALSE));   // not a default DACL 

            // Initialize a security attributes structure.
            sa.nLength = sizeof (SECURITY_ATTRIBUTES);
            sa.lpSecurityDescriptor = pSD;
            sa.bInheritHandle = FALSE;
    
            //
            // Create a local named pipe with
            // the hsm pipe name
            // '.' signifies local pipe.
    
            swprintf(pName, L"\\\\.\\PIPE\\%s",  WSB_PIPE_NAME);
    
            WsbAffirmHandle((m_pipeHandle = CreateNamedPipeW(pName,
                        PIPE_ACCESS_INBOUND               // Inbound - Service only receives identify messages on this pipe
                        | FILE_FLAG_OVERLAPPED            // Use overlapped structure.
                        | FILE_FLAG_FIRST_PIPE_INSTANCE,  // Make sure we are the creator of the pipe
                        PIPE_WAIT |                       // Wait on messages.
                        PIPE_TYPE_BYTE,
                        WSB_MAX_PIPES,
                        WSB_PIPE_BUFF_SIZE,
                        WSB_PIPE_BUFF_SIZE,
                        WSB_PIPE_TIME_OUT,                // Specify time out.
                        &sa)));                           // Security attributes.

        } WsbCatch(hr);

        //
        // Free security objects and verify hr of pipe creation
        //
        if (pAdminSID) {
            FreeSid(pAdminSID);
        }
        if (pSystemSID) {
            FreeSid(pSystemSID);
        }
        if (pWorldSID) {
            FreeSid(pWorldSID);
        }
        if (pGuestSID) {
            FreeSid(pGuestSID);
        }
        if (pACL) {
            LocalFree(pACL);
        }
        if (pSD) {
            WsbFree(pSD);
        }

        WsbAffirmHr(hr);


        //
        // Create an event for overlapped i/o
        //
        WsbAffirmHandle((pOverlap.hEvent = CreateEvent(NULL,
                                                       FALSE,
                                                       FALSE, 
                                                       NULL)));
             
        //
        // Initialize the handle array. The first element sbould be the terminate event,
        // because we need to know if it signalled and always break out of the loop
        // regardless of whether the overlapped i/o is done or not
        // 
        handleArray[0] = m_terminateEvent;
        handleArray[1] = pOverlap.hEvent;

        exitLoop = FALSE;
        while ((!exitLoop) && ((m_state == HSM_JOB_STATE_ACTIVE) || (m_state == HSM_JOB_STATE_STARTING)))  {
            connected = FALSE;
            //
            // Block until a client connects.
            //
            code = ConnectNamedPipe(m_pipeHandle, &pOverlap);
            if (!code) {
                lastError = GetLastError();
        
                switch (lastError) {
                    // IO_PENDING, wait on the event 
                    case ERROR_IO_PENDING:  {
                         
                        retCode = WaitForMultipleObjects(2,
                                                         handleArray, 
                                                         FALSE,
                                                         INFINITE);
                        if (retCode == WAIT_OBJECT_0) {
                           //
                           // The termination event got signalled
                           //
                           exitLoop = TRUE;
                           continue;
                        } else if (retCode == (WAIT_OBJECT_0+1)) {
                           //
                           // A client connected
                           //
                           connected = TRUE;
                        }
                        break;
                    }

                    case ERROR_BROKEN_PIPE: {
                        //
                        // Pipe is broken, reconnect
                        //
                        break;
                    }

                    default: {
                        //
                        // Something else is wrong, just reconnect
                        //
                        break;
                    }
                }
            } else {
                connected = TRUE;
            }
        
        
            if (connected) {
                //
                // A client connected - get the identify message, identify them and continue waiting for 
                // pipe conections.
                //
                WsbTrace(OLESTR("CFsaFilter::PipeThread: Client has connected.\n"));
    
                pOverlap.Offset = 0;
                pOverlap.OffsetHigh = 0;
                code = ReadFile(m_pipeHandle, &msg, sizeof(WSB_PIPE_MSG), &bytesRead, &pOverlap);
                if (!code) {
                    lastError = GetLastError();
                }
                else {
                    lastError = ERROR_IO_PENDING;   // Read returned right away 
                }
            
                switch (lastError) {
                    // IO_PENDING, wait on the event or timeout in 4 seconds 
                    case ERROR_IO_PENDING:
                        if (!code)  {
                            retCode = WaitForMultipleObjects(2, 
                                                             handleArray,
                                                             FALSE,
                                                             (DWORD) 4000);
                        } else {
                            retCode = WAIT_OBJECT_0 + 1;    // Read returned right away
                        }
                        if (retCode == (WAIT_OBJECT_0+1)) {
                            //
                            // Read some data.  Do the identification
                            //
                            GetOverlappedResult(m_pipeHandle, &pOverlap, &bytesRead, FALSE);
                            if (bytesRead == sizeof(WSB_PIPE_MSG)) {
                                //
                                // Make sure the message is of the right type
                                // (Currently, only WSB_PMSG_IDENTIFY is valid)
                                //
                                if (msg.msgType != WSB_PMSG_IDENTIFY) {
                                    // bogus message - ignore it
                                    WsbTrace(OLESTR("CFsaFilter::PipeThread: Bad message type (%lu)\n"), msg.msgType);
                                    DisconnectNamedPipe(m_pipeHandle);
                                    break;
                                }

                                //
                                // Find the client instance that matches this user 
                                //
                                code = ImpersonateNamedPipeClient(m_pipeHandle);
                                if (code) {
                                    code = OpenThreadToken(GetCurrentThread(), TOKEN_QUERY,
                                                TRUE, &tHandle);
                                }

                                if (code) {
                                    code = GetTokenInformation(tHandle, TokenStatistics, &tStats,
                                                sizeof(TOKEN_STATISTICS), &retLen);
                                    CloseHandle(tHandle);
                                    if (code) {
                                        //
                                        // Get the passed in machine name in a local buffer and null terminated
                                        //
                                        wcsncpy(machineName, msg.msg.idrp.clientName, MAX_COMPUTERNAME_LENGTH);
                                        machineName[MAX_COMPUTERNAME_LENGTH] = L'\0';

                                        //
                                        // First we need to clean up any old client objects that
                                        // have the same machine name.  It is assumed that there can
                                        // only be one client per machine and a duplicate means that 
                                        // they must have re-connected with a different authentication
                                        // token.
                                        //
                                        {
                                        CComPtr<IFsaFilterClient>       pFoundClient;
    
                                            WsbAffirmHr(pClient->SetMachineName(machineName));
                                            WsbAffirmHr(pClient->CompareBy(FSA_FILTERCLIENT_COMPARE_MACHINE));
                                            EnterCriticalSection(&m_clientLock);
                                            hr = m_pClients->Find(pClient, IID_IFsaFilterClient, (void**) &pFoundClient);
                                            LeaveCriticalSection(&m_clientLock);
                                            if (hr == S_OK) {
                                                //
                                                // Found one with the same machine name - make sure the token
                                                // does not match, just to be sure.
                                                //
                                                hr = pFoundClient->CompareToAuthenticationId(tStats.AuthenticationId.HighPart, 
                                                    tStats.AuthenticationId.LowPart, &result);
    
                                                if (hr != S_OK) {
                                                    //
                                                    // It did not match - remove and release this one from 
                                                    // the collection.
                                                    //
                                                    EnterCriticalSection(&m_clientLock);
                                                    hr = m_pClients->RemoveAndRelease(pFoundClient);
                                                    LeaveCriticalSection(&m_clientLock);
                                                }
                                            }   
                                        }   // Let pFoundClient go out of scope
    
    
                                        {
                                        CComPtr<IFsaFilterClient>       pFoundClient;
    
                                            //
                                            // Now set the machine name for this client if we can find
                                            // it by authentication id.
                                            //
                                            WsbAffirmHr(pClient->SetAuthenticationId(tStats.AuthenticationId.HighPart, 
                                                    tStats.AuthenticationId.LowPart));
                                            WsbAffirmHr(pClient->CompareBy(FSA_FILTERCLIENT_COMPARE_ID));
                    
                                            WsbTrace(OLESTR("CFsaFilter::PipeThread: Finding client instance (%x:%x).\n"),
                                                    tStats.AuthenticationId.HighPart, 
                                                    tStats.AuthenticationId.LowPart);
                                    
                                            EnterCriticalSection(&m_clientLock);
                                            hr = m_pClients->Find(pClient, IID_IFsaFilterClient, (void**) &pFoundClient);
                                            LeaveCriticalSection(&m_clientLock);
                                            if (hr == S_OK) {
                                                //
                                                // Got it - set the machine name
                                                //
                                                WsbTrace(OLESTR("CFsaFilter::PipeThread: Identify client as %ws.\n"),
                                                    machineName);
                                    
                                                pFoundClient->SetMachineName(machineName);
                                            } else {
                                                WsbTrace(OLESTR("CFsaFilter::PipeThread: Failed to find the client instance (%ls).\n"), 
                                                    WsbHrAsString(hr));
                                            }
                                        } // Let pFoundClient go out of scope
                                    } else {
                                        WsbTrace(OLESTR("CFsaFilter::PipeThread: GetTokenInformation returned %u.\n"),
                                            GetLastError());
                                    }
                                } else {
                                    WsbTrace(OLESTR("CFsaFilter::PipeThread: OpenThreadToken or ImpersonateNamedPipeClient returned %u.\n"),
                                        GetLastError());
                                }
                                RevertToSelf();
                                DisconnectNamedPipe(m_pipeHandle);
                            } else {
                                //
                                // Bad data was read - blow them off
                                //
                                WsbTrace(OLESTR("CFsaFilter::PipeThread: Bad message size (%u)\n"),
                                    bytesRead);
                                DisconnectNamedPipe(m_pipeHandle);
                            }
    
                        } else {
                            //
                            // Timeout or error - cancel the read and disconnect the client
                            //
                            DisconnectNamedPipe(m_pipeHandle);
                            if (retCode == WAIT_OBJECT_0) {
                                //
                                // Termination event was signalled
                                //
                                exitLoop = TRUE;
                                continue;
                            }
                        }
                        break;
                    case ERROR_BROKEN_PIPE: {
                        // Pipe is broken., 
                        DisconnectNamedPipe(m_pipeHandle);
                        break;
                    }

                    default: {
                        // Something else is wrong.
                        DisconnectNamedPipe(m_pipeHandle);
                        break;
                    }
                }
            }
        } // End while state 

    } WsbCatch(hr);

    if (m_pipeHandle != INVALID_HANDLE_VALUE) {
        CloseHandle(m_pipeHandle);
        m_pipeHandle = INVALID_HANDLE_VALUE;
    }

    if (pOverlap.hEvent != INVALID_HANDLE_VALUE) {
        CloseHandle(pOverlap.hEvent);
    }

    WsbTraceOut(OLESTR("CFsaFilter::PipeThread"), OLESTR("Hr = %ls"), WsbHrAsString(hr));

    return (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\fsa\fsa.cpp ===
/*++

 

Module Name:

    fsa.cpp

Abstract:

    DLL main for Fsa

Author:

    Ran Kalach          [rankala]         28-July-1999

Revision History:

--*/

// fsa.cpp : Implementation of DLL Exports.

// Note: Currently, Fsa proxy/stub is compiled into a different DLL.
//      Below is relevant information if it is decided to merge the two DLLs.
// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for ...int.idl by adding the following 
//      files to the Outputs.
//          ...
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f ...ps.mk in the project directory.

#include "stdafx.h"
#include "initguid.h"

#include "fsa.h"
#include "fsafltr.h"
#include "fsaftclt.h"
#include "fsaftrcl.h"
#include "fsaitem.h"
#include "fsaprem.h"
#include "fsaunmdb.h"
#include "fsarcvy.h"
#include "fsarsc.h"
#include "fsasrvr.h"
#include "fsatrunc.h"
#include "fsapost.h"
#include "task.h"

#include <stdio.h>

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_CFsaFilterClientNTFS, CFsaFilterClient)
    OBJECT_ENTRY(CLSID_CFsaFilterNTFS, CFsaFilter)
    OBJECT_ENTRY(CLSID_CFsaFilterRecallNTFS, CFsaFilterRecall)
    OBJECT_ENTRY(CLSID_CFsaPostIt, CFsaPostIt)
    OBJECT_ENTRY(CLSID_CFsaPremigratedDb, CFsaPremigratedDb)
    OBJECT_ENTRY(CLSID_CFsaPremigratedRec, CFsaPremigratedRec)
    OBJECT_ENTRY(CLSID_CFsaRecoveryRec, CFsaRecoveryRec)
    OBJECT_ENTRY(CLSID_CFsaResourceNTFS, CFsaResource)
    OBJECT_ENTRY(CLSID_CFsaScanItemNTFS, CFsaScanItem)
    OBJECT_ENTRY(CLSID_CFsaServerNTFS, CFsaServer)
    OBJECT_ENTRY(CLSID_CFsaTruncatorNTFS, CFsaTruncator)
    OBJECT_ENTRY(CLSID_CFsaUnmanageDb, CFsaUnmanageDb)
    OBJECT_ENTRY(CLSID_CFsaUnmanageRec, CFsaUnmanageRec)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    HRESULT hr;

#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    hr = CoInitialize( 0 );
    if (SUCCEEDED(hr)) {
      hr = _Module.RegisterServer( FALSE );
      CoUninitialize( );
    }
    return( hr );
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    HRESULT hr;

#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif

    hr = CoInitialize( 0 );
    if (SUCCEEDED(hr)) {
        _Module.UnregisterServer();
        CoUninitialize( );
        hr = S_OK;
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\filter\rpzw.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999
(c) 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    RpZw.c

Abstract:

    This module contains support routines for the HSM file system filter.

Author:

    Rick Winter
    Ravisankar Pudipeddi (ravisp)  - 1998

Environment:

    Kernel mode


Revision History:

	X-12	460967		Michael C. Johnson		 5-Sep-2001
		Add a sanity check to RsCompleteRecall() to check that
		the implied setting of the file context state field to
		RP_RECALL_COMPLETED has actually happened and log and 
		handle the situation. We must handle the case as we are
		heading for a deadlock with the paging code if we don't.

	X-11	365077		Michael C. Johnson		 1-May-2001
		Although IoCreateFileSpecifyDeviceObjectHint() allows us to 
		bypass share access checking it doesn't bypass the check for 
		a readonly file attribute. Revert to the old scheme of 
		directly munging the file object after a successful open. 
		Note that we can still use IoCreateFileSpecifyDeviceObjectHint() 
		to avoid traversing the entire IO stack.

	X-10	206961		Michael C. Johnson		28-Mar-2001
		Open the target file by Id rather than by name so avoiding 
		troubles with renames happening after the initial collection
		of the filename on the first open of the file.

--*/

#include "pch.h"

extern ULONG RsNoRecallDefault;

#ifdef ALLOC_PRAGMA
   #pragma alloc_text(PAGE, RsMarkUsn)
   #pragma alloc_text(PAGE, RsOpenTarget)
   #pragma alloc_text(PAGE, RsQueryValueKey)
   #pragma alloc_text(PAGE, RsTruncateOnClose)
   #pragma alloc_text(PAGE, RsSetPremigratedState)
   #pragma alloc_text(PAGE, RsDeleteReparsePoint)
   #pragma alloc_text(PAGE, RsSetResetAttributes)
   #pragma alloc_text(PAGE, RsTruncateFile)
   #pragma alloc_text(PAGE, RsSetEndOfFile)
#endif


NTSTATUS
RsMarkUsn(IN PRP_FILE_CONTEXT Context)
/*++

Routine Description:

    Mark the USN record for this file object

Arguments:

   Context      - File context entry

Return Value:


Note:


--*/

{
   NTSTATUS                    retval = STATUS_SUCCESS;
   KEVENT                      event;
   PIO_STACK_LOCATION          irpSp;
   IO_STATUS_BLOCK             Iosb;
   PIRP                        irp;
   PDEVICE_OBJECT              deviceObject;
   PMARK_HANDLE_INFO           pHinfo;
   HANDLE                      volHandle;
   OBJECT_ATTRIBUTES           volName;
   POBJECT_NAME_INFORMATION    nameInfo = NULL;

   PAGED_CODE();

   try {
      DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsMarkUsn.\n"));

      //
      // Attempt allocating the buffer
      //
      pHinfo = ExAllocatePoolWithTag(NonPagedPool,
                                     sizeof(MARK_HANDLE_INFO),
                                     RP_FO_TAG
                                    );
      if (!pHinfo) {
         RsLogError(__LINE__, AV_MODULE_RPZW, sizeof(MARK_HANDLE_INFO),
                    AV_MSG_MEMORY, NULL, NULL);
         return STATUS_INSUFFICIENT_RESOURCES;
      }


      retval = RsGenerateDevicePath(Context->fileObjectToWrite->DeviceObject, &nameInfo);

      if (!NT_SUCCESS(retval)) {
          ExFreePool(pHinfo);
          return retval;
      }

      InitializeObjectAttributes(&volName, &nameInfo->Name, OBJ_CASE_INSENSITIVE| OBJ_KERNEL_HANDLE, NULL, NULL);

      DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsMarkUsn - Open volume - %ws.\n", nameInfo->Name.Buffer));

      retval = ZwOpenFile(&volHandle,
                          FILE_WRITE_ATTRIBUTES | SYNCHRONIZE,
                          &volName,
                          &Iosb,
                          FILE_SHARE_READ | FILE_SHARE_WRITE,
                          0);


      if (!NT_SUCCESS(retval)) {
         //
         // Log an error
         //
         DebugTrace((DPFLTR_RSFILTER_ID,DBG_ERROR, "RsFilter: RsMarkUsn - failed to open volume - %ws - %x.\n",
                               nameInfo->Name.Buffer, retval));


         RsLogError(__LINE__, AV_MODULE_RPZW, retval,
                    AV_MSG_MARK_USN_FAILED, NULL, NULL);

         ExFreePool(pHinfo);
         ExFreePool(nameInfo);
         return(retval);
      }

      ExFreePool(nameInfo);

      DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsMarkUsn - Build Irp for mark usn.\n"));

      //
      // First get the file info so we have the attributes
      //
      deviceObject = IoGetRelatedDeviceObject(Context->fileObjectToWrite);
      irp = IoAllocateIrp(deviceObject->StackSize, FALSE);

      if (irp) {
         irp->UserEvent = &event;
         irp->UserIosb = &Iosb;
         irp->Tail.Overlay.Thread = PsGetCurrentThread();
         irp->Tail.Overlay.OriginalFileObject = Context->fileObjectToWrite;
         irp->RequestorMode = KernelMode;
         //
         // Initialize the event
         //
         KeInitializeEvent(&event, SynchronizationEvent, FALSE);

         //
         // Set up the I/O stack location.
         //

         irpSp = IoGetNextIrpStackLocation(irp);
         irpSp->MajorFunction = IRP_MJ_FILE_SYSTEM_CONTROL;
         irpSp->MinorFunction = IRP_MN_USER_FS_REQUEST;
         irpSp->FileObject = Context->fileObjectToWrite;
         irpSp->Parameters.FileSystemControl.FsControlCode = FSCTL_MARK_HANDLE;
         irpSp->Parameters.FileSystemControl.InputBufferLength = sizeof(MARK_HANDLE_INFO);
         irpSp->Parameters.FileSystemControl.OutputBufferLength = 0;

         irp->AssociatedIrp.SystemBuffer = pHinfo;

         pHinfo->UsnSourceInfo = USN_SOURCE_DATA_MANAGEMENT;
         pHinfo->VolumeHandle = volHandle;
         pHinfo->HandleInfo = 0;
         //
         // Set the completion routine.
         //
         IoSetCompletionRoutine( irp, RsCompleteIrp, &event, TRUE, TRUE, TRUE );

         //
         // Send it to the FSD
         //
         Iosb.Status = 0;
         DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsMarkUsn - Call driver to mark USN\n"));

         retval = IoCallDriver(deviceObject, irp);

         DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsMarkUsn - IoCallDriver returns %x.\n", retval));

         if (retval == STATUS_PENDING) {
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsMarkUsn - Wait for event.\n"));
            retval = KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
         }

         ExFreePool(pHinfo);
         retval = Iosb.Status;

         DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsMarkUsn - Iosb returns %x.\n", retval));

         if (!NT_SUCCESS(retval)) {
            //
            // Log an error
            //
            RsLogError(__LINE__, AV_MODULE_RPZW, retval,
                       AV_MSG_MARK_USN_FAILED, NULL, NULL);

         }
         ZwClose(volHandle);
      } else {
         ZwClose(volHandle);
         ExFreePool(pHinfo);
         RsLogError(__LINE__, AV_MODULE_RPZW, sizeof(IRP),
                    AV_MSG_MEMORY, NULL, NULL);

         DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsMarkUsn - Failed to allocate an Irp.\n"));
         retval = STATUS_INSUFFICIENT_RESOURCES;
      }

   }except (RsExceptionFilter(L"RsMarkUsn", GetExceptionInformation()) ) {
      retval = STATUS_INVALID_USER_BUFFER;
   }

   DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsMarkUsn - Returning %x.\n", retval));
   return(retval);
}


NTSTATUS
RsCompleteRecall(IN PDEVICE_OBJECT DeviceObject,
                 IN ULONGLONG filterId, 
                 IN NTSTATUS recallStatus, 
                 IN ULONG RecallAction,
                 IN BOOLEAN CancellableRead) 
/*++

Routine Description:

   Completes the recall processing for this filter id.  All reads/writes are allowed to
   complete for all file objects waiting on this recall.  The file object remains in the queue until
   it is closed.

Arguments:

    DeviceObject - Filter device object
    FilterId     - The ID assigned when this request was added to the queue
    RecallStatus - Status of the recall operation
    RecallAction - Bitmask of actions to take after successful recall
    CancellableRead - This parameter is only checked if this was for a 
                      read-no-recall that is completing.
                      If TRUE - it indicates the IRP is cancellable,
                      if FALSE - the IRP is not cancellable

Return Value:

    0 If successful, non-zero if the id was not found.

Note:
    Do not count on the file context entry being there after this call.

--*/

{
   PRP_FILE_CONTEXT    context;
   PRP_FILE_OBJ        entry;
   BOOLEAN             done = FALSE, found;
   KIRQL               rirqL;
   LONGLONG            fileId;
   PRP_IRP_QUEUE       readIo;
   LARGE_INTEGER       combinedId;
   NTSTATUS            status = STATUS_SUCCESS;
   BOOLEAN             gotLock = FALSE;
   HANDLE              fileHandle;


   try {
      DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsCompleteRecall - Completion for %I64x!\n", filterId));

      context = RsAcquireFileContext(filterId, TRUE);

      if (NULL == context) {
         return(STATUS_SUCCESS);
      }


      gotLock = TRUE;
      combinedId.QuadPart = filterId;
      //
      //
      if (!(combinedId.QuadPart & RP_TYPE_RECALL)) {
         //
         // If this was no-recall open we need to complete the
         // read now.  We do this by finding the correct file object entry and the matching read.
         //
         DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsCompleteRecall - Look for no-recall read.\n"));
         done = FALSE;
         found = FALSE;
         //
         // Lock the file object queue
         //
         entry = CONTAINING_RECORD(context->fileObjects.Flink,
                                   RP_FILE_OBJ,
                                   list);

         while ((!done) && (entry != CONTAINING_RECORD(&context->fileObjects,
                                                       RP_FILE_OBJ,
                                                       list))) {
            if (!IsListEmpty(&entry->readQueue)) {
               //
               // Look at the reads to see if one has the matching ID
               //
               //                 
               found = FALSE;
               ExAcquireSpinLock(&entry->qLock, &rirqL);
               readIo =  CONTAINING_RECORD(entry->readQueue.Flink,
                                           RP_IRP_QUEUE,
                                           list);

               while ((readIo != CONTAINING_RECORD(&entry->readQueue,
                                                   RP_IRP_QUEUE,
                                                   list)) && (FALSE == found)) {
                  if (readIo->readId == (combinedId.HighPart & RP_READ_MASK)) {
                     //
                     // Found our read entry 
                     //
                     found = TRUE;
                     if (CancellableRead) {
                         //
                         // Clear the cancel routine first
                         //
                         if (RsClearCancelRoutine(readIo->irp)) {
                              RemoveEntryList(&readIo->list);
                         } else {
                              readIo = NULL;
                         }                   
                     } else {
                        RemoveEntryList(&readIo->list);
                     }
                  } else {
                     readIo = CONTAINING_RECORD(readIo->list.Flink,
                                                RP_IRP_QUEUE,
                                                list);
                  }
               }

               ExReleaseSpinLock(&entry->qLock, rirqL);

               if (found) {
                  done = TRUE;
                  break;
               }
            }
            //
            // Move on to next file object
            //
            entry = CONTAINING_RECORD(entry->list.Flink,
                                      RP_FILE_OBJ,
                                      list
                                     );
         }
         RsReleaseFileContext(context);

         if (!found) {
            //
            // Read was not found!
            //
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_ERROR, "RsFilter: RsCompleteRecall - no recall read Irp not found!\n"));
            return  (STATUS_NOT_FOUND);
         }

         if (readIo == NULL) {
            //
            // It was cancelled..
            //
            return STATUS_CANCELLED;
         }
    
         if (!NT_SUCCESS(status)) {
             readIo->irp->IoStatus.Status = STATUS_FILE_IS_OFFLINE;
         } else {
             readIo->irp->IoStatus.Status = recallStatus;
         }

         RsCompleteRead(readIo,
         (BOOLEAN) ((NULL == readIo->userBuffer) ? FALSE : TRUE));

         ExFreePool(readIo);

      } else {
          /*
          ** The service can occasionally send multiple recall
          ** completion messages. However the only ones we need to
          ** worry about are those that deal with normal recalls where
          ** one of the actions might lead to the file being
          ** re-truncated as part of (say) an abort approximately in
          ** parallel to a normal completion. If the abort get's in
          ** second, it will attempt to truncate the file using the
          ** handle in the context which the normal completion
          ** processing has already closed and null-ed out.
          */
          if (filterId == context->lastRecallCompletionFilterId) {

#if DBG
              RsLogError (__LINE__, 
                          AV_MODULE_RPZW, 
                          context->state,
                          AV_MSG_MULTIPLE_COMPLETION_ATTEMPTS, 
                          NULL, 
                          context->uniName->Name.Buffer);
#endif

              RsReleaseFileContext(context);
              return (STATUS_SUCCESS);
          }

          context->lastRecallCompletionFilterId = filterId;


         //
         // Normal recall
         //
         // We need to release the file context resource whilst making calls to NTFS because it could deadlock with
         // reads that may be going on.  The read causes a paging IO read (which holds the paging IO resource) and
         // when we see the paging IO read we try to get the context resource in RsCheckRead and if we are holding it
         // here and a call here requires the paging IO esource we deadlock.
         //

	 //
	 // There is an implicit assumption here that if the recall has completed the RP_RECALL_COMPLETED state has
	 // already been set in the file context (see RsPartialData()). If that is not the case then if any of the
         // pending reads are paging IOs then when they are released, MM will insert them into the top of the stack.
         // Eventually they will get to RsFilter which will check the file context and see that the recall is not
         // yet complete and so will queue them. Unfortunately since the page in code is synchronous (or so I've 
         // been told) this will result in a deadlock. This has been seen on at least one occasion.
         //

         fileId = context->fileId;
         //
         // If we did not complete the recall we need to re-truncate the file
         //

         if ((STATUS_CANCELLED    == recallStatus) &&
             (RP_RECALL_COMPLETED == context->state)) {
             /*
             ** Too late to abort so ignore the abort and complete normally.
             */
             recallStatus = STATUS_SUCCESS;
         }


         if (!NT_SUCCESS(recallStatus)) {
             //
             // Completed with errors
             //
             context->state        = RP_RECALL_NOT_RECALLED;
             context->recallStatus = recallStatus;

         } else if (((context->currentOffset.QuadPart != 0) &&
		     (context->currentOffset.QuadPart != context->rpData.data.dataStreamSize.QuadPart))) {
             //
             // The recall is being abandoned by FSA for some reason before it's complete
             //
             DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, 
                       "RsFilter: RsCompleteRecall - File was not fully recalled - %I64u bytes of %I64u\n",
                       context->currentOffset.QuadPart,
                       context->rpData.data.dataStreamSize.QuadPart));
            
             context->state        = RP_RECALL_NOT_RECALLED;
             context->recallStatus = STATUS_FILE_IS_OFFLINE;

         } else if (RP_RECALL_COMPLETED != context->state) {
             //
             // Implicit assumption that file marked as recall complete (see RsPartialData()) is false
             //
             DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, 
                       "RsFilter: RsCompleteRecall - File was not marked as fully recalled - 0x%x\n",
                       context->state));

             RsLogError(__LINE__, AV_MODULE_RPZW, context->state, AV_MSG_UNEXPECTED_ERROR, NULL, NULL);

             context->state        = RP_RECALL_NOT_RECALLED;
             context->recallStatus = STATUS_FILE_IS_OFFLINE;
	 }



         recallStatus = context->recallStatus;


         if (NULL != context->fileObjectToWrite) {

             /*
             ** The context has the true recall status at this point
             ** i.e. the FSA might think the recall completed successfully -
             ** but if we fail to set the premigrated state or something else failed,
             ** the filter would have updated context->recallStatus appropriately.
             **
             ** Note that if we have already recalled all of the file then we won't 
             ** do the truncate. That just digs us into a way bigger hole.
             */
             if (!NT_SUCCESS(context->recallStatus) && 
                 (context->currentOffset.QuadPart != 0) &&
                 (context->currentOffset.QuadPart != context->rpData.data.dataStreamSize.QuadPart)) {
                 /*
                 ** We had some sort of failure and we wrote at least some data (but not all) to the file. 
                 ** Make sure we remove any partial data.
                 */
                 context->currentOffset.QuadPart = 0;

                 RsTruncateFile(context);
             }



            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsCompleteRecall - Closing the handle.\n"));

            ObDereferenceObject( context->fileObjectToWrite );

            fileHandle = context->handle;

            context->handle            = NULL;
            context->fileObjectToWrite = NULL;

            RsReleaseFileContextEntryLock(context);
            ZwClose (fileHandle);
            RsAcquireFileContextEntryLockExclusive(context);

            InterlockedDecrement((PLONG) &context->refCount);
         }


         //
         // Technically the recall's not complete till we get this message from FSA
         //
         KeSetEvent(&context->recallCompletedEvent,
                    IO_NO_INCREMENT,
                    FALSE);
         //
         // Now complete the reads and writes for all file objects
         // that have not been completed yet (but only the ones
         // open for recall).
         //
         do {
            done = TRUE;

            entry = CONTAINING_RECORD(context->fileObjects.Flink,
                                      RP_FILE_OBJ,
                                      list);

            while (entry != CONTAINING_RECORD(&context->fileObjects,
                                              RP_FILE_OBJ,
                                              list)) {


               DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsCompleteRecall - Checking %x, QHead is (%x).\n", entry, &context->fileObjects));

               if ((!RP_IS_NO_RECALL(entry)) &&
                   !(entry->flags & RP_NO_DATA_ACCESS)  &&
                   (!IsListEmpty(&entry->readQueue)  ||
                    !IsListEmpty(&entry->writeQueue)) ) {
                  //
                  // Complete pending requests on this file which have been waiting for
                  // the recall
                  //
                  DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsCompleteRecall - Completing entry %x (next is %x) Qhead is (%x).\n",
                                        entry, entry->list.Flink, &context->fileObjects));

                  RsReleaseFileContextEntryLock(context);
                  gotLock = FALSE;
                  //
                  // Reference the file object so the file object (and context)
                  // entry is not removed on us.
                  //
                  ObReferenceObject(entry->fileObj);

                  if (entry->filterId == (combinedId.QuadPart & RP_FILE_MASK)) {
                     entry->recallAction = RecallAction;
                  }
                  //
                  // Complete all pending IRPs for this file object
                  // If failing them - use STATUS_FILE_IS_OFFLINE
                  //
                  RsCompleteAllRequests(context, 
                                        entry,
                                        NT_SUCCESS(recallStatus) 
                                                    ? recallStatus
                                                    : STATUS_FILE_IS_OFFLINE);

                  //
                  // Now we can  release the file object
                  //
                  ObDereferenceObject(entry->fileObj);

                  RsAcquireFileContextEntryLockExclusive(context);
                  gotLock = TRUE;
                  //
                  // We have to rescan the entire list again because
                  // we let go of the file context lock
                  //
                  entry = NULL;
                  done = FALSE;
                  break;
               }
               //
               // Move on to next file object
               //
               DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsCompleteRecall - Get next entry %x.\n", entry->list.Flink));

               entry = CONTAINING_RECORD(entry->list.Flink,
                                         RP_FILE_OBJ,
                                         list
                                        );
            }
         } while (!done);

         DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsCompleteRecall - Done.\n"));
         //
         // deref the context entry and free it if required.
         //
         RsReleaseFileContext(context);
         gotLock = FALSE;
      }

   }except (RsExceptionFilter(L"RsCompleteRecall", GetExceptionInformation())) {
        if (gotLock) {
            RsReleaseFileContext(context);
            gotLock = FALSE;
        }
        status = STATUS_UNSUCCESSFUL;
   }

   return (status);
}



NTSTATUS
RsOpenTarget(IN  PRP_FILE_CONTEXT Context,
             IN  ULONG            OpenAccess,
	     IN  ULONG            AdditionalAccess,
             OUT HANDLE          *Handle,
             OUT PFILE_OBJECT    *FileObject)
/*++

Routine Description:

    Open the target file with the given access and modifies
    the access after opening.

Arguments:

    Context             - Pointer to file context
    OpenAccess          - Access flags with which to open the file
    AdditionalAccess    - Additional access needed but which would fail an access check
                          eg when we need to recall a readonly file.
    FileObject          - Pointer to the file object of open is returned here

Return Value:

    Status

--*/

{
   NTSTATUS                  retval = STATUS_SUCCESS;
   OBJECT_ATTRIBUTES         obj;
   IO_STATUS_BLOCK           iob;
   PDEVICE_EXTENSION         deviceExtension = Context->FilterDeviceObject->DeviceExtension;
   POBJECT_NAME_INFORMATION  nameInfo = NULL;
   OBJECT_HANDLE_INFORMATION handleInformation;
   LARGE_INTEGER             byteOffset;
   UNICODE_STRING            strFileId;
   HANDLE                    VolumeHandle;


   PAGED_CODE();


   //
   // Get a handle for the volume
   //
   retval = RsGenerateDevicePath (Context->devObj, &nameInfo);

   if (!NT_SUCCESS (retval)) {
      DebugTrace((DPFLTR_RSFILTER_ID,DBG_ERROR, "RsFilter: RsOpenTarget - Failed to generate the full path - %x.\n", retval));
   }


   if (NT_SUCCESS(retval)) {

      InitializeObjectAttributes (&obj,
				  &nameInfo->Name,
				  OBJ_KERNEL_HANDLE,
				  NULL,
				  NULL);

      DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsOpenTarget - Opening Volume %ws.\n", nameInfo->Name.Buffer));

      retval = IoCreateFile (&VolumeHandle, 
			     FILE_READ_ATTRIBUTES | SYNCHRONIZE,
			     &obj, 
			     &iob, 
			     NULL,
			     0L,
			     FILE_SHARE_READ | FILE_SHARE_WRITE,
			     FILE_OPEN,
			     FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
			     NULL,
			     0,
			     CreateFileTypeNone,
			     NULL,
			     IO_FORCE_ACCESS_CHECK | IO_NO_PARAMETER_CHECKING);

      if (!NT_SUCCESS (retval)) {
         DebugTrace((DPFLTR_RSFILTER_ID,DBG_ERROR, "RsFilter: RsOpenTarget - IoCreateFile (Volume) returned %x.\n", retval));
      }
   }



   if (NT_SUCCESS(retval)) {
      //
      // Now that we have a handle to the volume, do a relative open by file id.
      //
      RtlInitUnicodeString (&strFileId, (PWCHAR) &Context->fileId);

      strFileId.Length        = 8;
      strFileId.MaximumLength = 8;


      InitializeObjectAttributes (&obj,
				  &strFileId,
				  OBJ_KERNEL_HANDLE,
				  VolumeHandle,
				  NULL);

      DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsOpenTarget - Opening target file by Id %ws.\n", nameInfo->Name.Buffer));


      retval = IoCreateFileSpecifyDeviceObjectHint (Handle, 
						    OpenAccess | SYNCHRONIZE,
						    &obj,
						    &iob,
						    NULL,
						    0L,
						    0L,
						    FILE_OPEN,
						    FILE_OPEN_BY_FILE_ID | FILE_OPEN_REPARSE_POINT | FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
						    NULL,
						    0,
						    CreateFileTypeNone,
						    NULL,
						    IO_IGNORE_SHARE_ACCESS_CHECK | IO_NO_PARAMETER_CHECKING,
						    deviceExtension->FileSystemDeviceObject);


      ZwClose (VolumeHandle);

      if (!NT_SUCCESS (retval)) {
         DebugTrace((DPFLTR_RSFILTER_ID,DBG_ERROR, "RsFilter: RsOpenTarget - IoCreateFile (target) returned %x.\n", retval));
      }
   }


   if (NT_SUCCESS(retval)) {

      retval = ObReferenceObjectByHandle( *Handle,
					  0L,
					  NULL,
					  KernelMode,
					  (PVOID *) FileObject,
					  &handleInformation);


      if (!NT_SUCCESS(retval)) {

         DebugTrace((DPFLTR_RSFILTER_ID,DBG_ERROR, "RsFilter: RsOpenTarget - ref file object returned %x.\n", retval));
         ZwClose(*Handle);
	 retval = STATUS_UNSUCCESSFUL;

      } else {

         // Apply the extra access directly to the file object if required. This is 
         // what lets us bypass the readonly attribute that may be set on the file.
         //
         if (AdditionalAccess & GENERIC_WRITE) {
	    (*FileObject)->WriteAccess = TRUE;
	 }

         if (AdditionalAccess & GENERIC_READ) {
            (*FileObject)->ReadAccess = TRUE;
         }

         //
         // Reference the context
         //
         InterlockedIncrement((PLONG) &Context->refCount);
         retval = STATUS_SUCCESS;

      }
   }


   if (NULL != nameInfo) {
      ExFreePool(nameInfo);
   }

   DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsOpenTarget - returning %x.\n", retval));

   return(retval);
}



//
//  Local Support routine
//

NTSTATUS
RsQueryValueKey (
                IN PUNICODE_STRING KeyName,
                IN PUNICODE_STRING ValueName,
                IN OUT PULONG ValueLength,
                IN OUT PKEY_VALUE_FULL_INFORMATION *KeyValueInformation,
                IN OUT PBOOLEAN DeallocateKeyValue
                )

/*++

Routine Description:

    Given a unicode value name this routine will return the registry
    information for the given key and value.

Arguments:

    KeyName - the unicode name for the key being queried.

    ValueName - the unicode name for the registry value located in the registry.

    ValueLength - On input it is the length of the allocated buffer.  On output
        it is the length of the buffer.  It may change if the buffer is
        reallocated.

    KeyValueInformation - On input it points to the buffer to use to query the
        the value information.  On output it points to the buffer used to
        perform the query.  It may change if a larger buffer is needed.

    DeallocateKeyValue - Indicates if the KeyValueInformation buffer is on the
        stack or needs to be deallocated.

Return Value:

    NTSTATUS - indicates the status of querying the registry.

--*/

{
   HANDLE        Handle;
   NTSTATUS      Status;
   ULONG         RequestLength;
   ULONG         ResultLength;
   OBJECT_ATTRIBUTES ObjectAttributes;
   PVOID         NewKey;

   PAGED_CODE();

   InitializeObjectAttributes( &ObjectAttributes,
                               KeyName,
                               OBJ_KERNEL_HANDLE,
                               NULL,
                               NULL);

   Status = ZwOpenKey( &Handle,
                       KEY_READ,
                       &ObjectAttributes);

   if (!NT_SUCCESS( Status )) {

      return Status;
   }

   RequestLength = *ValueLength;


   while (TRUE) {

      Status = ZwQueryValueKey( Handle,
                                ValueName,
                                KeyValueFullInformation,
                                *KeyValueInformation,
                                RequestLength,
                                &ResultLength);

      ASSERT( Status != STATUS_BUFFER_OVERFLOW );

      if (Status == STATUS_BUFFER_OVERFLOW) {

         //
         // Try to get a buffer big enough.
         //

         if (*DeallocateKeyValue) {

            ExFreePool( *KeyValueInformation );
            *ValueLength = 0;
            *KeyValueInformation = NULL;
            *DeallocateKeyValue = FALSE;
         }

         RequestLength += 256;

         NewKey = (PKEY_VALUE_FULL_INFORMATION)
                  ExAllocatePoolWithTag( PagedPool,
                                         RequestLength,
                                         'TLSR');

         if (NewKey == NULL) {
            return STATUS_NO_MEMORY;
         }

         *KeyValueInformation = NewKey;
         *ValueLength = RequestLength;
         *DeallocateKeyValue = TRUE;

      } else {

         break;
      }
   }

   ZwClose(Handle);

   if (NT_SUCCESS(Status)) {

      //
      // Treat as if no value was found if the data length is zero.
      //

      if ((*KeyValueInformation)->DataLength == 0) {

         Status = STATUS_OBJECT_NAME_NOT_FOUND;
      }
   }

   return Status;
}

#ifdef TRUNCATE_ON_CLOSE
NTSTATUS
RsTruncateOnClose (
                  IN PRP_FILE_CONTEXT Context
                  )

/*++

Routine Description:

    Truncate the file specified by the context entry

Arguments:

   Context      - Context entry

Return Value:

   status

--*/
{
   NTSTATUS                status = STATUS_SUCCESS;
   LARGE_INTEGER           fSize;

   PAGED_CODE();

   //
   // Open the file for exclusive access (ask for read/write data)
   // If it fails then someone else has it open and we can just bail out.
   //
   //
   //
   //    BIG NOTE   BIG NOTE   BIG NOTE   BIG NOTE   BIG NOTE 
   //
   // We need to make sure that the access check in RsOpenTarget() actually 
   // happens in this case. If we ever turn this functionality on then we 
   // need to have a means of telling RsOpenTarget() to not bypass the 
   // access check.
   //
   //    BIG NOTE   BIG NOTE   BIG NOTE   BIG NOTE   BIG NOTE 
   //
   ASSERT (FALSE);

   RsReleaseFileContextEntryLock(Context);
   if (NT_SUCCESS (status = RsOpenTarget(Context,
                                         FILE_READ_DATA | FILE_WRITE_DATA,
					 0,
                                         &Context->handle,
                                         &Context->fileObjectToWrite))) {

      //
      // Indicate to USN the writes are happening by HSM
      // and preserve last modified date
      //
      RsMarkUsn(Context);
      RsPreserveDates(Context);
      RsAcquireFileContextEntryLockExclusive(Context);

      fSize.QuadPart = 0;
      if (MmCanFileBeTruncated(Context->fileObjectToWrite->SectionObjectPointer, &fSize)) {
         if (NT_SUCCESS (status = RsTruncateFile(Context))) {
            Context->rpData.data.bitFlags |= RP_FLAG_TRUNCATED;
            RP_CLEAR_ORIGINATOR_BIT( Context->rpData.data.bitFlags );
            RP_GEN_QUALIFIER(&(Context->rpData), Context->rpData.qualifier);
            //
            // Note that the originator bit is not included in the checksum
            //
            RP_SET_ORIGINATOR_BIT( Context->rpData.data.bitFlags );
            status = RsWriteReparsePointData(Context);
            Context->state = RP_RECALL_NOT_RECALLED;
            Context->recallStatus = 0;
            Context->currentOffset.QuadPart = 0;

            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsFreeFileObject - File truncated on close.\n"));
         }
      } else {
         RsAcquireFileContextEntryLockExclusive(Context);
         DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsFreeFileObject - File not truncated on close because another user has it open.\n"));
      }
      ObDereferenceObject( Context->fileObjectToWrite );
      Context->fileObjectToWrite = NULL;
      ZwClose(Context->handle);
      Context->handle = 0;
      //
      // We can deref the context now
      //
      InterlockedDecrement((PLONG) &Context->refCount);
   }

   return(status);
}
#endif


NTSTATUS
RsSetPremigratedState(IN PRP_FILE_CONTEXT Context)
/*++

Routine Description:

   Marks the file as pre-migrated.

Arguments:

   Context      - File context entry

Return Value:

    0 If successful, non-zero if the id was not found.

Note:
   Assumes the context entry is locked and releases it temporarily.  Acquired exclusive on exit.

--*/

{
   LARGE_INTEGER  currentTime;
   NTSTATUS       status = STATUS_SUCCESS;

   PAGED_CODE();

   try {
      if (NULL != Context->fileObjectToWrite) {
         Context->rpData.data.bitFlags &= ~RP_FLAG_TRUNCATED;
         KeQuerySystemTime(&currentTime);
         Context->rpData.data.recallTime = currentTime;
         Context->rpData.data.recallCount++;
         RP_CLEAR_ORIGINATOR_BIT( Context->rpData.data.bitFlags );

         RP_GEN_QUALIFIER(&(Context->rpData), Context->rpData.qualifier);
         //
         // Note that the originator bit is not included in the checksum
         //
         RP_SET_ORIGINATOR_BIT( Context->rpData.data.bitFlags );
         DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsSetPremigrated - Setting %x to premigrated.\n", Context));

         RsReleaseFileContextEntryLock(Context);

         status = RsWriteReparsePointData(Context);

         if (NT_SUCCESS(status)) {

             NTSTATUS setAttributeStatus;
             //
             // This operation may fail but it is not critical
             //
             setAttributeStatus = RsSetResetAttributes(Context->fileObjectToWrite,
                                                       0,
                                                       FILE_ATTRIBUTE_OFFLINE);
             if (!NT_SUCCESS(setAttributeStatus)) {
                 //
                 // This is non-critical. Just log a message indicating we failed to 
                 // reset FILE_ATTRIBUTE_OFFLINE for the file though it's premgirated
                 //
                 RsLogError(__LINE__, 
                            AV_MODULE_RPZW, 
                            setAttributeStatus,
                            AV_MSG_RESET_FILE_ATTRIBUTE_OFFLINE_FAILED, 
                            NULL, 
                            (PWCHAR) Context->uniName->Name.Buffer);
             }
         }  else {
                //
                // Log an error
                //
                RsLogError(__LINE__, 
                           AV_MODULE_RPZW, 
                           status,
                           AV_MSG_SET_PREMIGRATED_STATE_FAILED, 
                           NULL, 
                           (PWCHAR) Context->uniName->Name.Buffer);
                //
                // Truncate the file back... 
                //
                RsTruncateFile(Context);
         }

         RsAcquireFileContextEntryLockExclusive(Context);
      }

   }except (RsExceptionFilter(L"RsSetPremigrated", GetExceptionInformation()) ) {
      //

      DebugTrace((DPFLTR_RSFILTER_ID,DBG_ERROR, "RsFilter: RsSetPremigrated - Exception = %x.\n", GetExceptionCode()));

   }

   return (status);
}


NTSTATUS
RsDeleteReparsePoint(IN PRP_FILE_CONTEXT Context)
                     
/*++

Routine description

   Deletes HSM reparse point on the file - if there was one

Arguments

   Context - pointer to the file context entry for the file

Return  Value

   Status

--*/
{
   REPARSE_DATA_BUFFER rpData;
   NTSTATUS            status;
   IO_STATUS_BLOCK     ioStatus;
   PIRP                irp;
   PIO_STACK_LOCATION  irpSp;
   KEVENT              event;
   HANDLE              handle = NULL;
   PFILE_OBJECT        fileObject = NULL;
   PDEVICE_OBJECT      deviceObject;
   BOOLEAN             gotLock    = FALSE;

   PAGED_CODE();
   try {
      RsAcquireFileContextEntryLockExclusive(Context);
      gotLock = TRUE;

      status = RsOpenTarget(Context,
                            0,
                            GENERIC_WRITE,
                            &handle,
                            &fileObject);

      if (!NT_SUCCESS(status)) {
         RsReleaseFileContextEntryLock(Context);
         gotLock = FALSE;
         return status;
      }
      RtlZeroMemory(&rpData, sizeof(REPARSE_DATA_BUFFER_HEADER_SIZE));
      rpData.ReparseTag = IO_REPARSE_TAG_HSM;
      rpData.ReparseDataLength = 0;

      KeInitializeEvent(&event,
                        SynchronizationEvent,
                        FALSE);
    
      deviceObject = IoGetRelatedDeviceObject(fileObject);

      DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsDeleteReparsePoint: DevObj stack locations %d\n", deviceObject->StackSize));
      
      irp =  IoBuildDeviceIoControlRequest(FSCTL_DELETE_REPARSE_POINT,
                                           deviceObject,
                                           &rpData,
                                           REPARSE_DATA_BUFFER_HEADER_SIZE,
                                           NULL,
                                           0,
                                           FALSE,
                                           &event,
                                           &ioStatus);

      if (irp == NULL) {
         RsReleaseFileContextEntryLock(Context);
         gotLock = FALSE;
         ObDereferenceObject(fileObject);
         ZwClose(handle);
         //
         // We can deref the context now
         //
         InterlockedDecrement((PLONG) &Context->refCount);
         return STATUS_INSUFFICIENT_RESOURCES;
      }
      //
      // Fill in the other stuff
      //
      irp->Tail.Overlay.OriginalFileObject = fileObject;
      //
      // Important since we supply a user event & wait for the IRP to complete
      //
      irp->Flags |= IRP_SYNCHRONOUS_API;

      irpSp = IoGetNextIrpStackLocation(irp);
      irpSp->FileObject = fileObject;
      irpSp->MajorFunction = IRP_MJ_FILE_SYSTEM_CONTROL;
      irpSp->Parameters.FileSystemControl.InputBufferLength = REPARSE_DATA_BUFFER_HEADER_SIZE;
      status = IoCallDriver(deviceObject,
                            irp);

      fileObject = NULL;
      if (status == STATUS_PENDING) {
         (VOID)KeWaitForSingleObject(&event,
                                     Executive,
                                     KernelMode,
                                     FALSE,
                                     (PLARGE_INTEGER) NULL);
         status = ioStatus.Status;
      }

      RsReleaseFileContextEntryLock(Context);
      gotLock = FALSE;

      DebugTrace((DPFLTR_RSFILTER_ID, DBG_VERBOSE, "RsFilter: RsDeleteReparsePoint: fileObject %x, handle %x\n", fileObject, handle));

      ZwClose(handle);
      //
      // We can deref the context now
      //
      InterlockedDecrement((PLONG) &Context->refCount);

   } except (RsExceptionFilter(L"RsDeleteReparsePoint", GetExceptionInformation())) {

      if (gotLock) {
         RsReleaseFileContextEntryLock(Context);
         gotLock = FALSE;
      }
      if (handle != NULL) {
          if (fileObject != NULL) {
               ObDereferenceObject(fileObject);
          }
          ZwClose(handle);
          InterlockedDecrement((PLONG) &Context->refCount);
      }
   }
   return status;
}


NTSTATUS
RsSetResetAttributes(IN PFILE_OBJECT     FileObject,
                     IN ULONG            SetAttributes,
                     IN ULONG            ResetAttributes)
/*++

Routine Description:

    Sets and resets the supplied file attributes for the file

Arguments:

    FileObject          - Pointer to the file object
    SetAttributes       - The list of attributes that need to be set
    ResetAttributes     - The list of attributes that need to be turned off

Return Value:

     STATUS_INVALID_PARAMETER - SetAttributes/ResetAttributes were not
                                mutually exclusive
     STATUS_SUCCESS           - Successfully set/reset attributes
     any other status         - some error occurred


--*/

{
   NTSTATUS                    retval = STATUS_SUCCESS;
   KEVENT                      event;
   PIO_STACK_LOCATION          irpSp;
   IO_STATUS_BLOCK             Iosb;
   PIRP                        irp;
   FILE_BASIC_INFORMATION      info;
   PDEVICE_OBJECT              deviceObject;

   PAGED_CODE();

   try {

      DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsSetAttributes - Build Irp for Set file info.\n"));

      //
      // Set and reset attributes should be mutually exclusive
      //
      if ((SetAttributes & ResetAttributes) != 0) {
        return STATUS_INVALID_PARAMETER;
      }
      //
      // If both are 0, we have nothing to do
      //
      if ((SetAttributes | ResetAttributes) == 0) {
        return STATUS_SUCCESS;
      }

      //
      // First get the file info so we have the attributes
      //
      deviceObject = IoGetRelatedDeviceObject(FileObject);
      irp = IoAllocateIrp(deviceObject->StackSize, FALSE);

      if (irp) {
         irp->UserEvent = &event;
         irp->UserIosb = &Iosb;
         irp->Tail.Overlay.Thread = PsGetCurrentThread();
         irp->Tail.Overlay.OriginalFileObject = FileObject;
         irp->RequestorMode = KernelMode;
         irp->Flags |= IRP_SYNCHRONOUS_API;
         //
         // Initialize the event
         //
         KeInitializeEvent(&event, SynchronizationEvent, FALSE);

         //
         // Set up the I/O stack location.
         //

         irpSp = IoGetNextIrpStackLocation(irp);
         irpSp->MajorFunction = IRP_MJ_QUERY_INFORMATION;
         irpSp->FileObject = FileObject;
         irpSp->Parameters.QueryFile.Length = sizeof(FILE_BASIC_INFORMATION);
         irpSp->Parameters.QueryFile.FileInformationClass = FileBasicInformation;
         irp->AssociatedIrp.SystemBuffer = &info;

         //
         // Set the completion routine.
         //
         IoSetCompletionRoutine( irp, RsCompleteIrp, &event, TRUE, TRUE, TRUE );

         //
         // Send it to the FSD
         //
         DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsSetAttributes - Call driver to get date info\n"));
         Iosb.Status = 0;

         retval = IoCallDriver(deviceObject, irp);

         if (retval == STATUS_PENDING) {
            retval = KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
         }

         retval = Iosb.Status;

         DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsSetAttributes - Query returns %x.\n", retval));
      } else {
         retval = STATUS_INSUFFICIENT_RESOURCES;
         RsLogError(__LINE__, AV_MODULE_RPZW, sizeof(IRP),
                    AV_MSG_MEMORY, NULL, NULL);
      }

      if (retval == STATUS_SUCCESS) {
         irp = IoAllocateIrp(deviceObject->StackSize, FALSE);
         if (irp) {
            irp->UserEvent = &event;
            irp->UserIosb = &Iosb;
            irp->Tail.Overlay.Thread = PsGetCurrentThread();
            irp->Tail.Overlay.OriginalFileObject = FileObject;
            irp->RequestorMode = KernelMode;
            irp->Flags |= IRP_SYNCHRONOUS_API;
            //
            // Initialize the event
            //
            KeInitializeEvent(&event, SynchronizationEvent, FALSE);
            //
            // Set the requisite attributes
            //
            info.FileAttributes |= SetAttributes;
            //
            // Reset the requisite attributes
            //
            info.FileAttributes &= ~ResetAttributes;

            irpSp = IoGetNextIrpStackLocation(irp);
            irpSp->MajorFunction = IRP_MJ_SET_INFORMATION;
            irpSp->FileObject = FileObject;
            irpSp->Parameters.QueryFile.Length = sizeof(FILE_BASIC_INFORMATION);
            irpSp->Parameters.QueryFile.FileInformationClass = FileBasicInformation;
            irp->AssociatedIrp.SystemBuffer = &info;

            //
            // Set the completion routine.
            //
            IoSetCompletionRoutine( irp, RsCompleteIrp, &event, TRUE, TRUE, TRUE );

            //
            // Send it to the FSD
            //
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsSetAttributes - Call driver to set dates to -1.\n"));
            Iosb.Status = 0;

            retval = IoCallDriver(deviceObject, irp);


            if (retval == STATUS_PENDING) {
               retval = KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
            }

            retval = Iosb.Status;

            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsSetAttributes - Set dates returns %x.\n", retval));

            if (!NT_SUCCESS(retval)) {
               //
               // Log an error
               //
               RsLogError(__LINE__, AV_MODULE_RPZW, retval,
                          AV_MSG_PRESERVE_DATE_FAILED, NULL, NULL);
            }


         } else {
            retval = STATUS_INSUFFICIENT_RESOURCES;
            RsLogError(__LINE__, AV_MODULE_RPZW, sizeof(IRP),
                       AV_MSG_MEMORY, irpSp, NULL);
         }
      }
   }except (RsExceptionFilter(L"RsSetAttributes", GetExceptionInformation())) {
      retval = STATUS_INVALID_USER_BUFFER;
   }

   DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsSetAttributes - Returning %x.\n", retval));
   return(retval);
}


NTSTATUS
RsTruncateFile(IN PRP_FILE_CONTEXT Context)
/*++

Routine Description

   Set the file size

Arguments

   Context - Represents the file to truncate

Return Value

   STATUS_SUCCESS                - File was truncated
   STATUS_INSUFFICIENT_RESOURCES - Failure to allocate memory
   Other                         - Status from file system


--*/
{
    NTSTATUS                    status = STATUS_SUCCESS;


    PAGED_CODE();

    try {

        status = RsSetEndOfFile(Context, 0);
        if (NT_SUCCESS(status)) {
            status = RsSetEndOfFile(Context,
                                    Context->rpData.data.dataStreamSize.QuadPart);
        }

        if (!NT_SUCCESS(status)) {
            RsLogError(__LINE__, AV_MODULE_RPFILFUN, 0,
                       AV_MSG_SET_SIZE_FAILED, NULL, (PWCHAR) L"RsTruncateFile");

        }

    }except (RsExceptionFilter(L"RsTruncateFile", GetExceptionInformation()))
    {
        status = STATUS_INVALID_USER_BUFFER;
    }

    DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsTruncateFile - Returning %x.\n", status));
    return(status);
}


NTSTATUS
RsSetEndOfFile(IN PRP_FILE_CONTEXT Context,
               IN ULONGLONG size)
/*++

Routine Description

   Set the file size

Arguments

   DeviceObject - Filter device object
   Context - Represents the file to set the size of
   Size    - Size to set

Return Value

   STATUS_SUCCESS                - File size was set
   STATUS_INSUFFICIENT_RESOURCES - Failure to allocate memory
   Other                         - Status from file system


--*/
{
    NTSTATUS                    status = STATUS_SUCCESS;
    KEVENT                      event;
    PIO_STACK_LOCATION          irpSp;
    IO_STATUS_BLOCK             Iosb;
    PIRP                        irp = NULL;
    BOOLEAN                     oldWriteAccess;
    FILE_END_OF_FILE_INFORMATION info;
    PDEVICE_OBJECT              deviceObject;


    PAGED_CODE();

    try {

        deviceObject = IoGetRelatedDeviceObject(Context->fileObjectToWrite);

        irp = IoAllocateIrp(deviceObject->StackSize, FALSE);

        if (!irp) {
            RsLogError(__LINE__, AV_MODULE_RPFILFUN, sizeof(IRP),
                       AV_MSG_MEMORY, NULL, NULL);
            return STATUS_INSUFFICIENT_RESOURCES;
        }


        irp->UserEvent = &event;
        irp->UserIosb = &Iosb;
        irp->Tail.Overlay.Thread = PsGetCurrentThread();
        irp->Tail.Overlay.OriginalFileObject = Context->fileObjectToWrite;
        irp->RequestorMode = KernelMode;
        irp->Flags |= IRP_SYNCHRONOUS_API;
        //
        // Initialize the event
        //
        KeInitializeEvent(&event,
                          SynchronizationEvent,
                          FALSE);

        //
        // Set up the I/O stack location.
        //
        irpSp = IoGetNextIrpStackLocation(irp);
        irpSp->MajorFunction = IRP_MJ_SET_INFORMATION;
        irpSp->FileObject   = Context->fileObjectToWrite;
        irpSp->Parameters.SetFile.Length = sizeof(FILE_END_OF_FILE_INFORMATION);
        irpSp->Parameters.SetFile.FileInformationClass = FileEndOfFileInformation;
        irpSp->Parameters.SetFile.FileObject = Context->fileObjectToWrite;
        irp->AssociatedIrp.SystemBuffer = &info;

        info.EndOfFile.QuadPart = size;
        //
        // Set the completion routine.
        //
        IoSetCompletionRoutine( irp,
                                RsCompleteIrp,
                                &event,
                                TRUE,
                                TRUE,
                                TRUE );
        //
        // Give the file object permission to write
        //
        oldWriteAccess = Context->fileObjectToWrite->WriteAccess;
        Context->fileObjectToWrite->WriteAccess = TRUE;

        //
        // Send it to the FSD
        //
        Iosb.Status = STATUS_NOT_SUPPORTED;
        status = IoCallDriver(deviceObject,
                              irp);

        if (status == STATUS_PENDING) {
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsSetEndOfFile - Wait for event.\n"));
            status = KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        }

        //
        // Restore the old access rights
        //
        Context->fileObjectToWrite->WriteAccess = oldWriteAccess;

        DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsSetEndOffile Iosb returns %x.\n", status));
        //
        // Free the allocated reparse data buffer
        //
    }except (RsExceptionFilter(L"RsSetEndOfFile", GetExceptionInformation()))
    {
        status = STATUS_INVALID_USER_BUFFER;
    }

    DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsSetEndOfFile - Returning %x.\n", status));
    return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\filter\rpfilter.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 2001
(c) 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    RpFilter.c

Abstract:

    This module contains the code that traps file access activity for
    the HSM system.

Author:

    This is a modified version of a sample program provided by
    Darryl E. Havens (darrylh) 26-Jan-1995 (Microsoft).
    Modified by Rick Winter

Environment:

    Kernel mode


Revision History:

    1998:
    Ravisankar Pudipeddi   (ravisp)

	X-14	477425		Michael C. Johnson		 8-Oct-2001
		Test IRP AuxiliaryBuffer field for NULL in RsCreateCheck() 
		before dereferencing it.

	X-13	108353		Michael C. Johnson		 3-May-2001
		When checking a file to determine the type of recall also
		check a the potential target disk to see whether or not
		it is writable. This is necessary now that we have read-only
		NTFS volumes.

	X-12	322750		Michael C. Johnson		 1-Mar-2001
		Ensure pool for fast IO dispatch table is always released 
		following an error in DriverEntry() 

		194325
		Ensure that the completion routines for Mount and LoadFs do
		not call inappropriate routines at an elevated IRLQ

		360053
		Return STATUS_INSUFFICIENT_RESOURCES when we fail to allocate
		an mdl in RsRead().

	X-11	311579		Michael C. Johnson		16-Feb-2001
		When fetching object id's need to account for possible 
		unalignment of source. This matters on IA64.

	X-10	238109		Michael C. Johnson		 5-Dec-2000
		Change from using GUID form of reparse point to the non-GUID 
		form when handling FSCTL_SET_REPARSE_POINT

--*/

#include "pch.h"
#pragma   hdrstop
#include "initguid.h"
#include "rpguid.h"


#define IsLongAligned(P)    ((P) == ALIGN_DOWN_POINTER((P), ULONG))

NTSYSAPI
ULONG
NTAPI
RtlLengthSid (
             PSID Sid
             );

ULONG     ExtendedDebug = 0;

#if DBG
   #define DBGSTATIC
   #undef ASSERTMSG
   #define ASSERTMSG(msg,exp) if (!(exp)) { DbgPrint("%s:%d %s %s\n",__FILE__,__LINE__,msg,#exp); if (KD_DEBUGGER_ENABLED) { DbgBreakPoint(); } }
#else
   #define DBGSTATIC
   #undef ASSERTMSG
   #define ASSERTMSG(msg,exp)
#endif // DBG



extern KSPIN_LOCK               RsIoQueueLock;
extern KSPIN_LOCK               RsValidateQueueLock;
extern LIST_ENTRY               RsIoQHead;
extern LIST_ENTRY               RsValidateQHead;
extern LIST_ENTRY               RsFileContextQHead;
extern FAST_MUTEX               RsFileContextQueueLock;
extern ULONG                    RsFileObjId;
extern ULONG                    RsNoRecallDefault;
extern KSEMAPHORE               RsFsaIoAvailableSemaphore;


/* This must be set to TRUE to allow recalls */
ULONG         RsAllowRecalls = FALSE;


#if DBG
// Controls debug output
ULONG        RsTraceLevel = 0;            // Set via debugger or registry
#endif

//
// Define the device extension structure for this driver's extensions.
//

#define RSFILTER_DEVICE_TYPE   FILE_DEVICE_DISK_FILE_SYSTEM


//
// Hack for legacy backup clients to let them skip remote storage files
//
#define RSFILTER_SKIP_FILES_FOR_LEGACY_BACKUP_VALUE     L"SkipFilesForLegacyBackup"
ULONG   RsSkipFilesForLegacyBackup = 0;


//
// If TRUE then do not require privs to tinker with RSS reparse points.
//
#define RSFILTER_ENABLE_LEGACY_REPARSE_POINT_ACCESS     L"EnableLegacyAccessMethod"
ULONG   RsEnableLegacyAccessMethod = FALSE;


//
// Media type determines whether we use cached/uncached no-recall path
// IMPORTANT: Keep these in sync with those defined in engcommn.h
//
#define RSENGINE_PARAMS_KEY           L"Remote_Storage_Server\\Parameters"
#define RSENGINE_MEDIA_TYPE_VALUE     L"MediaType"

//
// Media types that we recognize.
// IMPORTANT: Keep these in sync with those defined in engcommn.h
//
#define RS_SEQUENTIAL_ACCESS_MEDIA    0
#define RS_DIRECT_ACCESS_MEDIA        1

BOOLEAN RsUseUncachedNoRecall     =   FALSE;

//
// Define driver entry routine.
//

NTSTATUS
DriverEntry(
           IN PDRIVER_OBJECT DriverObject,
           IN PUNICODE_STRING RegistryPath
           );

//
// Define the local routines used by this driver module.  This includes a
// a sample of how to filter a create file operation, and then invoke an I/O
// completion routine when the file has successfully been created/opened.
//

NTSTATUS
RsInitialize(
    VOID
);

DBGSTATIC
NTSTATUS
RsPassThrough(
             IN PDEVICE_OBJECT DeviceObject,
             IN PIRP Irp
             );

DBGSTATIC
NTSTATUS
RsCreate(
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
        );


DBGSTATIC
NTSTATUS
RsCreateCheck(
             IN PDEVICE_OBJECT DeviceObject,
             IN PIRP Irp,
             IN PVOID Context
             );


DBGSTATIC
NTSTATUS
RsOpenComplete(
              IN PDEVICE_OBJECT DeviceObject,
              IN PIRP Irp,
              IN PVOID Context
              );

DBGSTATIC
NTSTATUS
RsRead(
      IN PDEVICE_OBJECT DeviceObject,
      IN PIRP Irp
      );

DBGSTATIC
NTSTATUS
RsWrite(
       IN PDEVICE_OBJECT DeviceObject,
       IN PIRP Irp
       );

DBGSTATIC
NTSTATUS
RsShutdown(
          IN PDEVICE_OBJECT DeviceObject,
          IN PIRP Irp
          );


DBGSTATIC
NTSTATUS
RsCleanupFile(
             IN PDEVICE_OBJECT DeviceObject,
             IN PIRP Irp
             );

DBGSTATIC
NTSTATUS
RsClose(
       IN PDEVICE_OBJECT DeviceObject,
       IN PIRP Irp
       );

DBGSTATIC
NTSTATUS
RsRecallFsControl(
                 IN PDEVICE_OBJECT DeviceObject,
                 IN PIRP  Irp
                 );

DBGSTATIC
NTSTATUS
RsFsControl(
           IN PDEVICE_OBJECT DeviceObject,
           IN PIRP Irp
           );

DBGSTATIC
NTSTATUS
RsFsControlMount(
		IN PDEVICE_OBJECT DeviceObject,
		IN PIRP Irp
		);
DBGSTATIC
NTSTATUS
RsFsControlLoadFs(
		 IN PDEVICE_OBJECT DeviceObject,
		 IN PIRP Irp
		 );

DBGSTATIC
NTSTATUS
RsFsControlUserFsRequest (
		         IN PDEVICE_OBJECT DeviceObject,
		         IN PIRP Irp
		         );
DBGSTATIC
PVOID
RsMapUserBuffer (
                IN OUT PIRP Irp
                );

DBGSTATIC
VOID
RsFsNotification(
                IN PDEVICE_OBJECT DeviceObject,
                IN BOOLEAN FsActive
                );

DBGSTATIC
BOOLEAN
RsFastIoCheckIfPossible(
                       IN PFILE_OBJECT FileObject,
                       IN PLARGE_INTEGER FileOffset,
                       IN ULONG Length,
                       IN BOOLEAN Wait,
                       IN ULONG LockKey,
                       IN BOOLEAN CheckForReadOperation,
                       OUT PIO_STATUS_BLOCK IoStatus,
                       IN PDEVICE_OBJECT DeviceObject
                       );

DBGSTATIC
BOOLEAN
RsFastIoRead(
            IN PFILE_OBJECT FileObject,
            IN PLARGE_INTEGER FileOffset,
            IN ULONG Length,
            IN BOOLEAN Wait,
            IN ULONG LockKey,
            OUT PVOID Buffer,
            OUT PIO_STATUS_BLOCK IoStatus,
            IN PDEVICE_OBJECT DeviceObject
            );

DBGSTATIC
BOOLEAN
RsFastIoWrite(
             IN PFILE_OBJECT FileObject,
             IN PLARGE_INTEGER FileOffset,
             IN ULONG Length,
             IN BOOLEAN Wait,
             IN ULONG LockKey,
             IN PVOID Buffer,
             OUT PIO_STATUS_BLOCK IoStatus,
             IN PDEVICE_OBJECT DeviceObject
             );

DBGSTATIC
BOOLEAN
RsFastIoQueryBasicInfo(
                      IN PFILE_OBJECT FileObject,
                      IN BOOLEAN Wait,
                      OUT PFILE_BASIC_INFORMATION Buffer,
                      OUT PIO_STATUS_BLOCK IoStatus,
                      IN PDEVICE_OBJECT DeviceObject
                      );

DBGSTATIC
BOOLEAN
RsFastIoQueryStandardInfo(
                         IN PFILE_OBJECT FileObject,
                         IN BOOLEAN Wait,
                         OUT PFILE_STANDARD_INFORMATION Buffer,
                         OUT PIO_STATUS_BLOCK IoStatus,
                         IN PDEVICE_OBJECT DeviceObject
                         );

DBGSTATIC
BOOLEAN
RsFastIoLock(
            IN PFILE_OBJECT FileObject,
            IN PLARGE_INTEGER FileOffset,
            IN PLARGE_INTEGER Length,
            PEPROCESS ProcessId,
            ULONG Key,
            BOOLEAN FailImmediately,
            BOOLEAN ExclusiveLock,
            OUT PIO_STATUS_BLOCK IoStatus,
            IN PDEVICE_OBJECT DeviceObject
            );

DBGSTATIC
BOOLEAN
RsFastIoUnlockSingle(
                    IN PFILE_OBJECT FileObject,
                    IN PLARGE_INTEGER FileOffset,
                    IN PLARGE_INTEGER Length,
                    PEPROCESS ProcessId,
                    ULONG Key,
                    OUT PIO_STATUS_BLOCK IoStatus,
                    IN PDEVICE_OBJECT DeviceObject
                    );

DBGSTATIC
BOOLEAN
RsFastIoUnlockAll(
                 IN PFILE_OBJECT FileObject,
                 PEPROCESS ProcessId,
                 OUT PIO_STATUS_BLOCK IoStatus,
                 IN PDEVICE_OBJECT DeviceObject
                 );

DBGSTATIC
BOOLEAN
RsFastIoUnlockAllByKey(
                      IN PFILE_OBJECT FileObject,
                      PVOID ProcessId,
                      ULONG Key,
                      OUT PIO_STATUS_BLOCK IoStatus,
                      IN PDEVICE_OBJECT DeviceObject
                      );

DBGSTATIC
BOOLEAN
RsFastIoDeviceControl(
                     IN PFILE_OBJECT FileObject,
                     IN BOOLEAN Wait,
                     IN PVOID InputBuffer OPTIONAL,
                     IN ULONG InputBufferLength,
                     OUT PVOID OutputBuffer OPTIONAL,
                     IN ULONG OutputBufferLength,
                     IN ULONG IoControlCode,
                     OUT PIO_STATUS_BLOCK IoStatus,
                     IN PDEVICE_OBJECT DeviceObject
                     );


DBGSTATIC
VOID
RsFastIoDetachDevice(
                    IN PDEVICE_OBJECT SourceDevice,
                    IN PDEVICE_OBJECT TargetDevice
                    );

/* **** New Fast IO dispatch points for NT 4.x */


DBGSTATIC
BOOLEAN
RsFastIoQueryNetworkOpenInfo(
                            IN PFILE_OBJECT FileObject,
                            IN BOOLEAN Wait,
                            OUT PFILE_NETWORK_OPEN_INFORMATION Buffer,
                            OUT PIO_STATUS_BLOCK IoStatus,
                            IN PDEVICE_OBJECT DeviceObject
                            );

DBGSTATIC
NTSTATUS
RsFastIoAcquireForModWrite(
                          IN PFILE_OBJECT FileObject,
                          IN PLARGE_INTEGER EndingOffset,
                          OUT PERESOURCE *ResourceToRelease,
                          IN PDEVICE_OBJECT DeviceObject
                          );

DBGSTATIC
BOOLEAN
RsFastIoMdlRead(
               IN PFILE_OBJECT FileObject,
               IN PLARGE_INTEGER FileOffset,
               IN ULONG Length,
               IN ULONG LockKey,
               OUT PMDL *MdlChain,
               OUT PIO_STATUS_BLOCK IoStatus,
               IN PDEVICE_OBJECT DeviceObject
               );


DBGSTATIC
BOOLEAN
RsFastIoMdlReadComplete(
                       IN PFILE_OBJECT FileObject,
                       IN PMDL MdlChain,
                       IN PDEVICE_OBJECT DeviceObject
                       );

DBGSTATIC
BOOLEAN
RsFastIoPrepareMdlWrite(
                       IN PFILE_OBJECT FileObject,
                       IN PLARGE_INTEGER FileOffset,
                       IN ULONG Length,
                       IN ULONG LockKey,
                       OUT PMDL *MdlChain,
                       OUT PIO_STATUS_BLOCK IoStatus,
                       IN PDEVICE_OBJECT DeviceObject
                       );

DBGSTATIC
BOOLEAN
RsFastIoMdlWriteComplete(
                        IN PFILE_OBJECT FileObject,
                        IN PLARGE_INTEGER FileOffset,
                        IN PMDL MdlChain,
                        IN PDEVICE_OBJECT DeviceObject
                        );

DBGSTATIC
BOOLEAN
RsFastIoReadCompressed(
                      IN PFILE_OBJECT FileObject,
                      IN PLARGE_INTEGER FileOffset,
                      IN ULONG Length,
                      IN ULONG LockKey,
                      OUT PVOID Buffer,
                      OUT PMDL *MdlChain,
                      OUT PIO_STATUS_BLOCK IoStatus,
                      OUT struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
                      IN ULONG CompressedDataInfoLength,
                      IN PDEVICE_OBJECT DeviceObject
                      );

DBGSTATIC
BOOLEAN
RsFastIoWriteCompressed(
                       IN PFILE_OBJECT FileObject,
                       IN PLARGE_INTEGER FileOffset,
                       IN ULONG Length,
                       IN ULONG LockKey,
                       IN PVOID Buffer,
                       OUT PMDL *MdlChain,
                       OUT PIO_STATUS_BLOCK IoStatus,
                       IN  struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
                       IN ULONG CompressedDataInfoLength,
                       IN PDEVICE_OBJECT DeviceObject
                       );

DBGSTATIC
BOOLEAN
RsFastIoMdlReadCompleteCompressed(
                                 IN PFILE_OBJECT FileObject,
                                 IN PMDL MdlChain,
                                 IN PDEVICE_OBJECT DeviceObject
                                 );

DBGSTATIC
BOOLEAN
RsFastIoMdlWriteCompleteCompressed(
                                  IN PFILE_OBJECT FileObject,
                                  IN PLARGE_INTEGER FileOffset,
                                  IN PMDL MdlChain,
                                  IN PDEVICE_OBJECT DeviceObject
                                  );

DBGSTATIC
BOOLEAN
RsFastIoQueryOpen(
                 IN PIRP Irp,
                 OUT PFILE_NETWORK_OPEN_INFORMATION NetworkInformation,
                 IN PDEVICE_OBJECT DeviceObject
                 );

DBGSTATIC
NTSTATUS
RsAsyncCompletion(
                 IN PDEVICE_OBJECT DeviceObject,
                 IN PIRP Irp,
                 IN PVOID Context
                 );

DBGSTATIC
NTSTATUS
RsPreAcquireFileForSectionSynchronization(
                                   IN  PFS_FILTER_CALLBACK_DATA Data,
                                   OUT PVOID *CompletionContext
                                 );

DBGSTATIC
VOID
RsPostAcquireFileForSectionSynchronization(
                                  IN    PFS_FILTER_CALLBACK_DATA Data,
                                  IN    NTSTATUS AcquireStatus,
                                  IN    PVOID CompletionContext
                                );
DBGSTATIC
VOID
RsPostReleaseFileForSectionSynchronization(
                                  IN  PFS_FILTER_CALLBACK_DATA Data,
                                  IN  NTSTATUS ReleaseStatus,
                                  IN  PVOID CompletionContext
                                );


NTSTATUS
RsFsctlRecallFile(IN PFILE_OBJECT FileObject);


NTSTATUS
RsRecallFile(IN PRP_FILTER_CONTEXT FilterContext);

NTSTATUS
RsQueryInformation(
                  IN PDEVICE_OBJECT DeviceObject,
                  IN PIRP Irp
                  );
NTSTATUS
RsQueryInformationCompletion(
                            IN PDEVICE_OBJECT DeviceObject,
                            IN PIRP Irp,
                            IN PVOID Context
                            );

//
// Global storage for this file system filter driver.
//

PDRIVER_OBJECT FsDriverObject;
PDEVICE_OBJECT FsDeviceObject;

ERESOURCE FsLock;

//
// Assign text sections for each routine.
//

#ifdef ALLOC_PRAGMA
   #pragma alloc_text(INIT, DriverEntry)
   #pragma alloc_text(PAGE, RsCreate)
   #pragma alloc_text(PAGE, RsShutdown)
   #pragma alloc_text(PAGE, RsCleanupFile)
   #pragma alloc_text(PAGE, RsClose)
   #pragma alloc_text(PAGE, RsRecallFsControl)
   #pragma alloc_text(PAGE, RsFsControl)
   #pragma alloc_text(PAGE, RsFsControlMount)
   #pragma alloc_text(PAGE, RsFsControlLoadFs)
   #pragma alloc_text(PAGE, RsFsControlUserFsRequest)
   #pragma alloc_text(PAGE, RsFsNotification)
   #pragma alloc_text(PAGE, RsFastIoCheckIfPossible)
   #pragma alloc_text(PAGE, RsFastIoRead)
   #pragma alloc_text(PAGE, RsFastIoWrite)
   #pragma alloc_text(PAGE, RsFastIoQueryBasicInfo)
   #pragma alloc_text(PAGE, RsFastIoQueryStandardInfo)
   #pragma alloc_text(PAGE, RsFastIoLock)
   #pragma alloc_text(PAGE, RsFastIoUnlockSingle)
   #pragma alloc_text(PAGE, RsFastIoUnlockAll)
   #pragma alloc_text(PAGE, RsFastIoUnlockAllByKey)
   #pragma alloc_text(PAGE, RsFastIoDeviceControl)
   #pragma alloc_text(PAGE, RsFastIoDetachDevice)
   #pragma alloc_text(PAGE, RsFastIoQueryNetworkOpenInfo)
   #pragma alloc_text(PAGE, RsFastIoMdlRead)
   #pragma alloc_text(PAGE, RsFastIoPrepareMdlWrite)
   #pragma alloc_text(PAGE, RsFastIoMdlWriteComplete)
   #pragma alloc_text(PAGE, RsFastIoReadCompressed)
   #pragma alloc_text(PAGE, RsFastIoWriteCompressed)
   #pragma alloc_text(PAGE, RsFastIoQueryOpen)
   #pragma alloc_text(PAGE, RsFsctlRecallFile)
   #pragma alloc_text(PAGE, RsInitialize)
   #pragma alloc_text(PAGE, RsRecallFile)
   #pragma alloc_text(PAGE, RsQueryInformation)
   #pragma alloc_text(PAGE, RsCompleteRead)
   #pragma alloc_text(PAGE, RsPreAcquireFileForSectionSynchronization)
   #pragma alloc_text(PAGE, RsPostAcquireFileForSectionSynchronization)
   #pragma alloc_text(PAGE, RsPostReleaseFileForSectionSynchronization)
#endif

NTSTATUS
DriverEntry(
           IN PDRIVER_OBJECT DriverObject,
           IN PUNICODE_STRING RegistryPath
           )

/*++

Routine Description:

    This is the initialization routine for the general purpose file system
    filter driver.  This routine creates the device object that represents this
    driver in the system and registers it for watching all file systems that
    register or unregister themselves as active file systems.

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    The function value is the final status from the initialization operation.

--*/

{
   UNICODE_STRING         nameString;
   UNICODE_STRING         symString;
   PDEVICE_OBJECT         deviceObject;
   PFILE_OBJECT           fileObject;
   NTSTATUS               status;
   PFAST_IO_DISPATCH      fastIoDispatch;
   ULONG                  i;
   PDEVICE_EXTENSION      deviceExtension;
   FS_FILTER_CALLBACKS    fsFilterCallbacks;

   UNREFERENCED_PARAMETER(RegistryPath);


   //
   // Create the device object.
   //

   RtlInitUnicodeString( &nameString, RS_FILTER_DEVICE_NAME);

   FsDriverObject = DriverObject;

   status = IoCreateDevice(
                          DriverObject,
                          sizeof( DEVICE_EXTENSION ),
                          &nameString,
                          FILE_DEVICE_DISK_FILE_SYSTEM,
                          FILE_DEVICE_SECURE_OPEN,
                          FALSE,
                          &deviceObject
                          );

   if (!NT_SUCCESS( status )) {
      DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "Error creating RsFilter device, error: %x\n", status ));
      RsLogError(__LINE__, AV_MODULE_RPFILTER, status,
                 AV_MSG_STARTUP, NULL, NULL);

      return status;
   }


   RtlInitUnicodeString( &symString, RS_FILTER_INTERNAL_SYM_LINK);
   status = IoCreateSymbolicLink(&symString, &nameString);
   if (!NT_SUCCESS( status )) {
      DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "Error creating symbolic link, error: %x\n", status ));
      RsLogError(__LINE__, AV_MODULE_RPFILTER, status,
                 AV_MSG_SYMBOLIC_LINK, NULL, NULL);

      IoDeleteDevice( deviceObject );
      return status;
   }

   FsDeviceObject = deviceObject;

   //
   // Initialize the driver object with this device driver's entry points.
   //

   for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++) {
      DriverObject->MajorFunction[i] = RsPassThrough;
   }
   DriverObject->MajorFunction[IRP_MJ_CREATE] = RsCreate;
   DriverObject->MajorFunction[IRP_MJ_READ] = RsRead;
   DriverObject->MajorFunction[IRP_MJ_WRITE] = RsWrite;
   DriverObject->MajorFunction[IRP_MJ_SHUTDOWN] = RsShutdown;
   DriverObject->MajorFunction[IRP_MJ_CLEANUP] = RsCleanupFile;
   DriverObject->MajorFunction[IRP_MJ_CLOSE] = RsClose;
   DriverObject->MajorFunction[IRP_MJ_FILE_SYSTEM_CONTROL] = RsFsControl;
   DriverObject->MajorFunction[IRP_MJ_QUERY_INFORMATION] = RsQueryInformation;

   //
   // Allocate fast I/O data structure and fill it in.
   //

   fastIoDispatch = ExAllocatePoolWithTag( NonPagedPool, sizeof( FAST_IO_DISPATCH ), RP_LT_TAG );
   if (!fastIoDispatch) {
      IoDeleteDevice( deviceObject );
      RsLogError(__LINE__, AV_MODULE_RPFILTER, status,
                 AV_MSG_STARTUP, NULL, NULL);
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   RtlZeroMemory( fastIoDispatch, sizeof( FAST_IO_DISPATCH ) );
   fastIoDispatch->SizeOfFastIoDispatch = sizeof( FAST_IO_DISPATCH );
   fastIoDispatch->FastIoCheckIfPossible = RsFastIoCheckIfPossible;
   fastIoDispatch->FastIoRead = RsFastIoRead;
   fastIoDispatch->FastIoWrite = RsFastIoWrite;
   fastIoDispatch->FastIoQueryBasicInfo = RsFastIoQueryBasicInfo;
   fastIoDispatch->FastIoQueryStandardInfo = RsFastIoQueryStandardInfo;
   fastIoDispatch->FastIoLock = RsFastIoLock;
   fastIoDispatch->FastIoUnlockSingle = RsFastIoUnlockSingle;
   fastIoDispatch->FastIoUnlockAll = RsFastIoUnlockAll;
   fastIoDispatch->FastIoUnlockAllByKey = RsFastIoUnlockAllByKey;
   fastIoDispatch->FastIoDeviceControl = RsFastIoDeviceControl;
   fastIoDispatch->FastIoDetachDevice = RsFastIoDetachDevice;
   fastIoDispatch->FastIoQueryNetworkOpenInfo = RsFastIoQueryNetworkOpenInfo;
   fastIoDispatch->MdlRead = RsFastIoMdlRead;
   fastIoDispatch->MdlReadComplete = RsFastIoMdlReadComplete;
   fastIoDispatch->PrepareMdlWrite = RsFastIoPrepareMdlWrite;
   fastIoDispatch->MdlWriteComplete = RsFastIoMdlWriteComplete;
   fastIoDispatch->FastIoReadCompressed = RsFastIoReadCompressed;
   fastIoDispatch->FastIoWriteCompressed = RsFastIoWriteCompressed;
   fastIoDispatch->MdlReadCompleteCompressed = RsFastIoMdlReadCompleteCompressed;
   fastIoDispatch->MdlWriteCompleteCompressed = RsFastIoMdlWriteCompleteCompressed;
   fastIoDispatch->FastIoQueryOpen = RsFastIoQueryOpen;

   DriverObject->FastIoDispatch = fastIoDispatch;

   //
   //  Setup the callbacks for the operations we receive through
   //  the FsFilter interface.
   //
   RtlZeroMemory(&fsFilterCallbacks, sizeof(FS_FILTER_CALLBACKS));

   fsFilterCallbacks.SizeOfFsFilterCallbacks = sizeof( FS_FILTER_CALLBACKS );
   fsFilterCallbacks.PreAcquireForSectionSynchronization = RsPreAcquireFileForSectionSynchronization;
   fsFilterCallbacks.PostAcquireForSectionSynchronization = RsPostAcquireFileForSectionSynchronization;
   fsFilterCallbacks.PostReleaseForSectionSynchronization = RsPostReleaseFileForSectionSynchronization;

   status = FsRtlRegisterFileSystemFilterCallbacks(DriverObject, &fsFilterCallbacks);

   if (!NT_SUCCESS( status )) {

       ExFreePool( fastIoDispatch );
       IoDeleteDevice( deviceObject );
       return status;
   }


   //
   // Initialize global data structures.
   //
   ExInitializeResourceLite( &FsLock );

   InitializeListHead(&RsIoQHead);
   InitializeListHead(&RsFileContextQHead);
   InitializeListHead(&RsValidateQHead);

   RsInitializeFileContextQueueLock();

   KeInitializeSpinLock(&RsIoQueueLock);
   KeInitializeSpinLock(&RsValidateQueueLock);


   //
   // Register this driver for watching file systems coming and going.
   //
   status = IoRegisterFsRegistrationChange( DriverObject, RsFsNotification );

   if (!NT_SUCCESS( status )) {
      DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Error registering FS change notification, error: %x\n", status ));
      ExFreePool( fastIoDispatch );
      IoDeleteDevice( deviceObject );
      RsLogError(__LINE__, AV_MODULE_RPFILTER, status,
                 AV_MSG_STARTUP, NULL, NULL);
      return status;
   }

   //
   // Indicate that the type for this device object is a primary, not a filter
   // device object so that it doesn't accidentally get used to call a file
   // system.
   //
   deviceExtension = deviceObject->DeviceExtension;
   deviceExtension->Type = 0;
   deviceExtension->Size = sizeof( DEVICE_EXTENSION );
   deviceExtension->WriteStatus = RsVolumeStatusUnknown;

   RtlInitUnicodeString( &nameString, (PWCHAR) L"\\Ntfs" );
   status = IoGetDeviceObjectPointer(
                                    &nameString,
                                    FILE_READ_ATTRIBUTES,
                                    &fileObject,
                                    &deviceObject
                                    );

   //
   // If NTFS was found then we must be starting while NT is up.
   // Try and attach now.
   //
   if (NT_SUCCESS( status )) {
      RsFsNotification( deviceObject, TRUE );
      ObDereferenceObject( fileObject );
   }
   //
   // Semaphore used to control access to the FSCTLs used for FSA-Filter communication
   // Set the limit to a few orders of magnitude more than  what the FSA could potentially
   // send
   //
   KeInitializeSemaphore(&RsFsaIoAvailableSemaphore,
                         0,
                         RP_MAX_RECALL_BUFFERS*1000);

   RsInitialize();
   RsCacheInitialize();

   RsTraceInitialize (RsDefaultTraceEntries);

   RsTrace0 (ModRpFilter);
   return STATUS_SUCCESS;
}


DBGSTATIC
NTSTATUS
RsPassThrough(
             IN PDEVICE_OBJECT DeviceObject,
             IN PIRP Irp
             )

/*++

Routine Description:

    This routine is the main dispatch routine for the general purpose file
    system driver.  It simply passes requests onto the next driver in the
    stack, which is presumably a disk file system.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.

Note:

    A note to filter file system implementors:  This routine actually "passes"
    through the request by taking this driver out of the loop.  If the driver
    would like to pass the I/O request through, but then also see the result,
    then rather than essentially taking itself out of the loop it could keep
    itself in by copying the caller's parameters to the next stack location
    and then set its own completion routine.  Note that it's important to not
    copy the caller's I/O completion routine into the next stack location, or
    the caller's routine will get invoked twice.

    Hence, this code could do the following:

    irpSp = IoGetCurrentIrpStackLocation( Irp );
    deviceExtension = DeviceObject->DeviceExtension;
    nextIrpSp = IoGetNextIrpStackLocation( Irp );

    RtlMoveMemory( nextIrpSp, irpSp, sizeof( IO_STACK_LOCATION ) );
    IoSetCompletionRoutine( Irp, NULL, NULL, FALSE, FALSE, FALSE );

    return IoCallDriver( deviceExtension->FileSystemDeviceObject, Irp );

    This example actually NULLs out the caller's I/O completion routine, but
    this driver could set its own completion routine so that it could be
    notified when the request was completed.

    Note also that the following code to get the current driver out of the loop
    is not really kosher, but it does work and is much more efficient than the
    above.


--*/

{
   PDEVICE_EXTENSION deviceExtension;

   deviceExtension = DeviceObject->DeviceExtension;

   if (!deviceExtension->Type) {
      Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
      Irp->IoStatus.Information = 0;
      IoCompleteRequest( Irp, IO_NO_INCREMENT );
      return STATUS_INVALID_DEVICE_REQUEST;
   }
   //
   // Get this driver out of the driver stack and get to the next driver as
   // quickly as possible.
   //
   IoSkipCurrentIrpStackLocation (Irp);

   //
   // Now call the appropriate file system driver with the request.
   //

   return IoCallDriver( deviceExtension->FileSystemDeviceObject, Irp );
}


DBGSTATIC
NTSTATUS
RsClose(
       IN PDEVICE_OBJECT DeviceObject,
       IN PIRP Irp
       )
{
   PDEVICE_EXTENSION    deviceExtension;
   PIO_STACK_LOCATION   currentStack;
   PRP_FILTER_CONTEXT   rpFilterContext;

   PAGED_CODE();


   //
   // Get a pointer to this driver's device extension for the specified
   // device.  Note that if the device being opened is the primary device
   // object rather than a filter device object, simply indicate that the
   // operation worked.
   //
   deviceExtension = DeviceObject->DeviceExtension;


   if (!deviceExtension->Type) {

      DebugTrace((DPFLTR_RSFILTER_ID,
                  DBG_VERBOSE, 
                  "RsFilter: Enter Close (Primary device) - devExt = %x\n", 
                  deviceExtension));


      Irp->IoStatus.Status      = STATUS_SUCCESS;
      Irp->IoStatus.Information = 0;

      IoCompleteRequest( Irp, IO_DISK_INCREMENT );

      return STATUS_SUCCESS;

   } 


   currentStack = IoGetCurrentIrpStackLocation (Irp);

   DebugTrace((DPFLTR_RSFILTER_ID,
               DBG_VERBOSE, 
               "RsFilter: Enter Close (Filter device) - devExt = %x\n", 
               deviceExtension));


   //
   // Remove it from the queue if it was there
   //
   rpFilterContext = (PRP_FILTER_CONTEXT) FsRtlRemovePerStreamContext (FsRtlGetPerStreamContextPointer (currentStack->FileObject), FsDeviceObject, currentStack->FileObject);


   if (NULL != rpFilterContext) {

       ASSERT (currentStack->FileObject == ((PRP_FILE_OBJ)(rpFilterContext->myFileObjEntry))->fileObj);

       RsFreeFileObject ((PLIST_ENTRY) rpFilterContext);
   }



   //
   // Get this driver out of the driver stack and get to the next driver as
   // quickly as possible.
   //
   IoSkipCurrentIrpStackLocation (Irp);


   //
   // Now call the appropriate file system driver with the request.
   //
   return IoCallDriver( deviceExtension->FileSystemDeviceObject, Irp );
}


DBGSTATIC
NTSTATUS
RsCreate(
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
        )

/*++

Routine Description:

    This function filters create/open operations.  It simply establishes an
    I/O completion routine to be invoked if the operation was successful.

Arguments:

    DeviceObject - Pointer to the target device object of the create/open.

    Irp - Pointer to the I/O Request Packet that represents the operation.

Return Value:

    The function value is the status of the call to the file system's entry
    point.

--*/

{
   PIO_STACK_LOCATION     irpSp;
   PDEVICE_EXTENSION      deviceExtension;
   NTSTATUS               status;
   RP_PENDING_CREATE      pnding;
   PRP_USER_SECURITY_INFO userSecurityInfo     = NULL;
   BOOLEAN                freeUserSecurityInfo = FALSE;
   BOOLEAN                bVolumeReadOnly      = FALSE;
   RP_VOLUME_WRITE_STATUS eNewVolumeWriteStatus;

   DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Enter Create\n"));

   PAGED_CODE();

   deviceExtension = DeviceObject->DeviceExtension;

   if (!deviceExtension->Type) {
      Irp->IoStatus.Status = STATUS_SUCCESS;
      Irp->IoStatus.Information = 0;

      IoCompleteRequest( Irp, IO_DISK_INCREMENT );
      return STATUS_SUCCESS;
   }


   //
   // Get a pointer to the current stack location in the IRP.  This is where
   // the function codes and parameters are stored.
   //

   irpSp = IoGetCurrentIrpStackLocation( Irp );



   //
   // See if we have already determined the write status for this volume. 
   // If not then go ahead and do it now. Note that due to the way this is
   // synchronised the first few create calls might each try and make the
   // determination but only the first will succeed with the update. We
   // choose this to keep the normal path as light weight as possible.
   //
   if ((RsVolumeStatusUnknown == deviceExtension->WriteStatus) && !deviceExtension->AttachedToNtfsControlDevice) {

       status = RsCheckVolumeReadOnly (DeviceObject, &bVolumeReadOnly);

       if (NT_SUCCESS (status)) {

           eNewVolumeWriteStatus = (bVolumeReadOnly) 
					? RsVolumeStatusReadOnly
					: RsVolumeStatusReadWrite;

	   InterlockedCompareExchange ((volatile LONG *) &deviceExtension->WriteStatus, 
				       eNewVolumeWriteStatus, 
				       RsVolumeStatusUnknown);

       }
   }


   //
   // Simply copy this driver stack location contents to the next driver's
   // stack.
   // Set a completion routine to check for the reparse point error return.
   //

   IoCopyCurrentIrpStackLocationToNext( Irp);


   //
   // If the Fsa is loaded and the file is not being opened
   // with FILE_OPEN_REPARSE_POINT then set a completion routine
   //
   if (!(irpSp->Parameters.Create.Options & FILE_OPEN_REPARSE_POINT)) {


      RtlZeroMemory(&pnding, sizeof(RP_PENDING_CREATE));

      KeInitializeEvent(&pnding.irpCompleteEvent, SynchronizationEvent, FALSE);

      IoSetCompletionRoutine (Irp,
                              RsCreateCheck,
                              &pnding,
                              TRUE,        // Call on success
                              TRUE,        // fail
                              TRUE) ;      // and on cancel
      //
      //
      DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: create calling IoCallDriver (%x) (pending)\n", Irp));

      status = IoCallDriver( deviceExtension->FileSystemDeviceObject, Irp );
      DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Leave create pending (%x)\n", Irp));
      //
      // We wait for the event to be set by the
      // completion routine.
      //
      KeWaitForSingleObject( &pnding.irpCompleteEvent,
                             UserRequest,
                             KernelMode,
                             FALSE,
                             (PLARGE_INTEGER) NULL );

      if (pnding.flags & RP_PENDING_RESEND_IRP) {
         //
         // If we need to reissue the IRP then do so now.
         //
         userSecurityInfo = ExAllocatePoolWithTag(PagedPool,
                                                  sizeof(RP_USER_SECURITY_INFO),
                                                  RP_SE_TAG);
         if (userSecurityInfo == NULL) {
             Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
             Irp->IoStatus.Information = 0;
             IoCompleteRequest( Irp, IO_DISK_INCREMENT );
             return STATUS_INSUFFICIENT_RESOURCES;
         }

         freeUserSecurityInfo = TRUE;

         RsGetUserInfo(&(irpSp->Parameters.Create.SecurityContext->AccessState->SubjectSecurityContext),
                    userSecurityInfo);

         KeClearEvent(&pnding.irpCompleteEvent);

         //
         // Completion routine has already been set for us.
         //
         status = IoCallDriver(deviceExtension->FileSystemDeviceObject, Irp);

         if (((pnding.flags & RP_PENDING_NO_OPLOCK) ||
              (pnding.flags & RP_PENDING_IS_RECALL) ||
              (pnding.flags & RP_PENDING_RESET_OFFLINE))) {

            if (status == STATUS_PENDING) {
               //
               // We have to wait for the create IRP to finish in this case.
               //
               (VOID) KeWaitForSingleObject( &pnding.irpCompleteEvent,
                                             UserRequest,
                                             KernelMode,
                                             FALSE,
                                             (PLARGE_INTEGER) NULL );

               status = Irp->IoStatus.Status;
            }

            if (!NT_SUCCESS(status)) {
               ExFreePool(pnding.qInfo);
               RsFreeUserSecurityInfo(userSecurityInfo);
               return status;
            }

            if (pnding.flags & RP_PENDING_NO_OPLOCK) {
               status = RsAddFileObj(pnding.fileObject,
                                     DeviceObject,
                                     NULL,
                                     pnding.options);
            }

            if (NT_SUCCESS(status) && (pnding.flags & RP_PENDING_IS_RECALL) && (NULL != pnding.qInfo)) {
               PRP_CREATE_INFO qInfo;
               DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Queue a recall\n"));

               qInfo = pnding.qInfo;
               if (!NT_SUCCESS(status = RsAddQueue(qInfo->serial,
                                                   &pnding.filterId,
                                                   qInfo->options,
                                                   pnding.fileObject,
                                                   pnding.deviceObject,
                                                   DeviceObject,
                                                   &qInfo->rpData,
                                                   qInfo->rpData.data.dataStreamStart,
                                                   qInfo->rpData.data.dataStreamSize,
                                                   qInfo->fileId,
                                                   qInfo->objIdHi,
                                                   qInfo->objIdLo,
                                                   qInfo->desiredAccess,
                                                   userSecurityInfo))) {
                  //
                  //
                  // Some kind of error queueing the recall
                  // We have to fail the open but the file is already open -
                  // What do we do here?
                  // Answer: we call the new API IoCancelFileOpen
                  //
                  Irp->IoStatus.Status = status;
                  IoCancelFileOpen(deviceExtension->FileSystemDeviceObject,
                                   pnding.fileObject);
               } else {
                  //
                  // We will keep the user-info
                  //
                  freeUserSecurityInfo = FALSE;
               }
            }

            if (NT_SUCCESS(status) && (pnding.flags & RP_PENDING_RESET_OFFLINE)) {
               status = RsSetResetAttributes(pnding.fileObject,
                                             0,
                                             FILE_ATTRIBUTE_OFFLINE);
               DebugTrace ((DPFLTR_RSFILTER_ID,DBG_INFO, 
                           "RsFilter: file opened for overwrite, reset FILE_ATTRIBUTE_OFFLINE,status of RsSetResetAttributes: %x\n",
                           status));

               status = STATUS_SUCCESS;
            }


            //
            // Many potential changes to 'status' so update IoStatus in the Irp.
            //
            Irp->IoStatus.Status = status;
         }
      } else {
        status = Irp->IoStatus.Status;

      }

      if (freeUserSecurityInfo) {
         //
         // We can discard the cached user info
         //
         ASSERT (userSecurityInfo != NULL);
         RsFreeUserSecurityInfo(userSecurityInfo);

      }
      //
      // Finally free the qInfo allocated in RsCreateCheck
      //
      if (pnding.qInfo) {
         ExFreePool(pnding.qInfo);
      }
      //
      // This IRP never completed. Complete it now
      //
      IoCompleteRequest(Irp, IO_NO_INCREMENT);

   } else {
      //
      // File opened with FILE_OPEN_REPARSE_POINT
      // Call the appropriate file system driver with the request.
      //
      DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Open with FILE_OPEN_REPARSE_POINT - %x\n", irpSp->FileObject));

      IoSetCompletionRoutine( Irp, NULL, NULL, FALSE, FALSE, FALSE );

      status = IoCallDriver( deviceExtension->FileSystemDeviceObject, Irp );
   }

   return status;
}


DBGSTATIC
NTSTATUS
RsCreateCheck(
             IN PDEVICE_OBJECT DeviceObject,
             IN PIRP Irp,
             IN PVOID Context
             )

/*++

Routine Description:

   This completion routine will be called by the I/O manager when an
   file create request has been completed by a filtered driver. If the
   returned code is a reparse error and it is a HSM reparse point then
   we must set up for the recall and re-issue the open request.

Arguments:

   DeviceObject - Pointer to the device object (filter's) for this request

   Irp - Pointer to the Irp that is being completed

   Context - Driver defined context - points to RP_PENDING_CREATE

Return Value:

   STATUS_SUCCESS           - Recall is complete
   STATUS_MORE_PROCESSING_REQUIRED  - Open request was sent back to file system
   STATUS_FILE_IS_OFFLINE   - File is offline and cannot be retrieved at this time


--*/

{
   PREPARSE_DATA_BUFFER  pHdr;
   PRP_DATA              pRpData;
   PIO_STACK_LOCATION    irpSp;
   PFILE_OBJECT          fileObject;
   ULONG                 dwRemainingNameLength;
   NTSTATUS              status;
   ULONG                 dwDisp;
   PDEVICE_EXTENSION     deviceExtension;
   ULONG                 qual;
   PRP_CREATE_INFO       qInfo;
   NTSTATUS              retval;
   LONGLONG              fileId;
   LONGLONG              objIdHi;
   LONGLONG              objIdLo;
   PRP_PENDING_CREATE    pnding;


   DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Enter create completion\n"));

   pnding = (PRP_PENDING_CREATE) Context;

   if (Irp->IoStatus.Status != STATUS_REPARSE) {
      //
      // Propogate the IRP pending flag.
      //

      if (Irp->PendingReturned) {
         IoMarkIrpPending( Irp );
      }

      DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Leave create completion - no reparse\n"));
      KeSetEvent(&pnding->irpCompleteEvent, IO_NO_INCREMENT, FALSE);
      //
      // This packet would be completed by RsCreate
      //
      return(STATUS_MORE_PROCESSING_REQUIRED);
   }

   try {
      pHdr = (PREPARSE_DATA_BUFFER) Irp->Tail.Overlay.AuxiliaryBuffer;
      status = STATUS_SUCCESS;


      //
      // Check for NULL to differentiate the IO_REMOUNT case in which 
      // case we just pass the irp on through..
      //
      if ((NULL != pHdr) && (pHdr->ReparseTag == IO_REPARSE_TAG_HSM)) {
         //
         // Insure that the reparse point data is at least the
         // minimum size we expect.
         //
         irpSp = IoGetCurrentIrpStackLocation( Irp );
         pRpData = (PRP_DATA) &pHdr->GenericReparseBuffer.DataBuffer;
         status = STATUS_FILE_IS_OFFLINE;
         //
         // Assume the data is invalid
         //
         Irp->IoStatus.Status = STATUS_FILE_IS_OFFLINE;

         if ((NULL != pRpData) &&
             (pHdr->ReparseDataLength >= sizeof(RP_DATA))) {
            //
            // Check the qualifier and signature
            //
            //
            // Clear the originator bit just in case.
            //
            RP_CLEAR_ORIGINATOR_BIT( pRpData->data.bitFlags );

            RP_GEN_QUALIFIER(pRpData, qual);
            if ((RtlCompareMemory(&pRpData->vendorId, &RP_MSFT_VENDOR_ID, sizeof(GUID)) == sizeof(GUID)) ||
                (pRpData->qualifier == qual)) {

               status = STATUS_MORE_PROCESSING_REQUIRED;

            } // Else error (STATUS_FILE_IS_OFFLINE;

         } // else error (STATUS_FILE_IS_OFFLINE);

         if (status != STATUS_MORE_PROCESSING_REQUIRED) {
            RsLogError(__LINE__, AV_MODULE_RPFILTER, status,
                       AV_MSG_DATA_ERROR, NULL, NULL);
         }

      } // Else pass it on (STATUS_SUCCESS)


      if (status == STATUS_MORE_PROCESSING_REQUIRED) {
         //
         // From here we need to process the Irp in some way.
         // Either pass it back to NTFS again or send it to the
         // HSM engine
         //

         deviceExtension = DeviceObject->DeviceExtension;
         dwRemainingNameLength = (ULONG) pHdr->Reserved; // Length of unparsed portion of the file name
         dwDisp = (irpSp->Parameters.Create.Options & 0xff000000) >> 24;
#ifdef IF_RICK_IS_RIGHT_ABOUT_REMOVING_THIS
         //
         // If they are opening the file without read or write access then we need to remember the
         // file object so we can fail oplocks
         //
         if ((RP_FILE_IS_TRUNCATED(pRpData->data.bitFlags)) &&
             !(irpSp->Parameters.Create.SecurityContext->DesiredAccess & FILE_HSM_ACTION_ACCESS) ) {
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Remember open of truncated file for non-data access\n"));
            pnding->Flags |= RP_PENDING_NO_OPLOCK;
            pnding->options = irpSp->Parameters.Create.Options;
         }
#endif
         pnding->fileObject = irpSp->FileObject;
         pnding->deviceObject = irpSp->FileObject->DeviceObject;
         //
         // If the unnamed datastream is being opened for read or write access and the disposition
         // is not overwrite or supercede then we have to recall it.
         //
         if ((dwRemainingNameLength == 0) &&
             (dwDisp != FILE_SUPERSEDE) && (dwDisp != FILE_OVERWRITE) && (dwDisp != FILE_OVERWRITE_IF) ) {
            //
            // Attempting to read or write the primary stream
            //
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: HSM Reparse point was hit. Length = %u\n",
                                  pHdr->ReparseDataLength));

            retval = STATUS_SUCCESS;
            //
            // Check for legacy backup.
            // If it is backup intent, and caller has backup privilege,
            // and read only (no delete access), and the caller has not specified
            // FILE_OPEN_NO_RECALL or FILE_OPEN_REPARSE_POINT (this last is granted
            // because we don't have this completion routine in this case)
            // then it is legacy backup.
            // Now if the registry hack override says we should skip them, so we do.
            // If not we simply add FILE_OPEN_NO_RECALL flag to permit a deep-backup
            // without letting the files that are being backed up being recalled to disk
            //
            if ((irpSp->Parameters.Create.Options & FILE_OPEN_FOR_BACKUP_INTENT) &&
                (irpSp->Parameters.Create.SecurityContext->AccessState->Flags & TOKEN_HAS_BACKUP_PRIVILEGE) &&
                !(irpSp->Parameters.Create.SecurityContext->DesiredAccess & DELETE)  &&
                !(irpSp->Parameters.Create.SecurityContext->DesiredAccess & FILE_WRITE_DATA)) {

                if (RsSkipFilesForLegacyBackup && !RP_IS_NO_RECALL_OPTION(irpSp->Parameters.Create.Options) && (RP_FILE_IS_TRUNCATED(pRpData->data.bitFlags))) {
                    //
                    // Legacy backup and the file is offline
                    //
                    retval               = STATUS_ACCESS_DENIED;
                    Irp->IoStatus.Status = STATUS_ACCESS_DENIED;
                } else {
                    //
                    // File is premigrated or it is not legacy backup
                    // We continue to set the NO_RECALL flag for premigrated files,
                    // it is harmless - because we don't really go to the tape for
                    // these files and ensure correctness for future
                    //
                    RP_SET_NO_RECALL_OPTION(irpSp->Parameters.Create.Options);
                }
            }



	    // If we are considering a recall of a truncated file then we should check that we 
	    // can actually repopulate the file, that is, the volume isn't read-only because 
	    // (say) it's a snapshot. If it is readonly then we should turn read requests into 
	    // 'no recall' requests and fail write requests.
	    //
            if (NT_SUCCESS (retval)                                        && 
		!RP_IS_NO_RECALL_OPTION (irpSp->Parameters.Create.Options) && 
		(RP_FILE_IS_TRUNCATED(pRpData->data.bitFlags))             &&
		(RsVolumeStatusReadOnly == deviceExtension->WriteStatus)) {

		if ((irpSp->Parameters.Create.SecurityContext->DesiredAccess & FILE_WRITE_DATA) ||
		    (irpSp->Parameters.Create.SecurityContext->DesiredAccess & DELETE)) {

		    // Wanted write access to the file but this is a readonly volume. Something
		    // not quite right here.
		    //
		    retval               = STATUS_MEDIA_WRITE_PROTECTED;
                    Irp->IoStatus.Status = STATUS_MEDIA_WRITE_PROTECTED;

		} else {

		    // Won't be able to put the file back on the volume so turn the request 
		    // into a 'no recall' request.
		    //
		    RP_SET_NO_RECALL_OPTION (irpSp->Parameters.Create.Options);

		}

            }



            if (NT_SUCCESS(retval)) {
               //
               // It is a HSM reparse point and needs a recall (or was opened no recall)
               //
               objIdLo = 0;
               objIdHi = 0;
               fileId  = 0;

               fileObject = irpSp->FileObject;
               if (irpSp->Parameters.Create.Options & FILE_OPEN_BY_FILE_ID) {
                  //
                  // Note that we assume that a fileId or objectId of zero is never valid.
                  //
                  if (fileObject->FileName.Length == sizeof(LONGLONG)) {
                     //
                     // Open by file ID
                     //
                     fileId = * ((LONGLONG *) fileObject->FileName.Buffer);

                  } else if (fileObject->FileName.Length >= (2 * sizeof(LONGLONG))) {
                     //
                     // Must be open by object ID. ObjectIds are 16 bytes long. The 
                     // expectation is that they will be preceeded by a '\' but we 
                     // are not going to require that. Let others who know better do
                     // so. We just care about the last 16 bytes.
                     //
                     objIdLo = * ((LONGLONG UNALIGNED *) &fileObject->FileName.Buffer[(fileObject->FileName.Length -      sizeof(LONGLONG))  / sizeof(WCHAR)]);
                     objIdHi = * ((LONGLONG UNALIGNED *) &fileObject->FileName.Buffer[(fileObject->FileName.Length - (2 * sizeof(LONGLONG))) / sizeof(WCHAR)]);
                  } else {
                     retval = STATUS_INVALID_PARAMETER;
                     Irp->IoStatus.Status = retval;
                  }
               }
            }

            if (NT_SUCCESS(retval)) {
               //
               // If open no recall was requested - it had better be read only access
               // Write or delete access is not allowed.
               //
               if ((irpSp->Parameters.Create.Options & FILE_OPEN_NO_RECALL) &&
                   ((irpSp->Parameters.Create.SecurityContext->DesiredAccess & FILE_WRITE_DATA) ||
                    (irpSp->Parameters.Create.SecurityContext->DesiredAccess & DELETE))) {
                  retval = STATUS_INVALID_PARAMETER;
                  Irp->IoStatus.Status = retval;
               }
            }

            if (STATUS_SUCCESS == retval) {
               //
               // We have to place all files with our reparse point on the list of files to watch IO for.
               // It is possible that the file is pre-migrated now but will be truncated by the time the open
               // really completes (truncate on close).
               //
               // If this file is not premigrated, we have to mark the file object as
               // random acces to prevent cache read ahead.  Cache read ahead would
               // cause deadlocks when it attempted to read portions of the file
               // that have not been recalled yet.
               //
               if (RP_FILE_IS_TRUNCATED(pRpData->data.bitFlags)) {
                  irpSp->FileObject->Flags |= FO_RANDOM_ACCESS;
               }

               if ( RP_FILE_IS_TRUNCATED(pRpData->data.bitFlags) &&
                    (FALSE == RsAllowRecalls) &&
                    (irpSp->Parameters.Create.SecurityContext->DesiredAccess & FILE_HSM_ACTION_ACCESS)) {
                  //
                  // Remote Storage system is not running and they wanted read/write data access.
                  //
                  status = STATUS_FILE_IS_OFFLINE;
                  Irp->IoStatus.Status = status;
               } else {
#if DBG
                  if (irpSp->Parameters.Create.Options & FILE_OPEN_BY_FILE_ID) {
                     DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsCreate: Open By ID\n"));
                  } else {
                     DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsCreate: Open by name\n"));

                  }

                  DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Desired Access : %x\n",
                                        irpSp->Parameters.Create.SecurityContext->DesiredAccess));
#endif // DBG
                  //
                  // From here out we must use a worker thread
                  // because some of the calls cannot be used at dispatch level
                  //
                  if (qInfo = ExAllocatePoolWithTag( NonPagedPool, sizeof(RP_CREATE_INFO) , RP_WQ_TAG)) {

                     //
                     // Get the serial number from the file object or the device object
                     // in the file object or the device object passed in.
                     // If it is not in any of these places we have a problem.
                     //
                     if ((irpSp->FileObject != 0) && (irpSp->FileObject->Vpb != 0)) {
                        qInfo->serial = irpSp->FileObject->Vpb->SerialNumber;
                     } else if ((irpSp->DeviceObject != 0) && (irpSp->FileObject->DeviceObject->Vpb != 0)) {
                        qInfo->serial = irpSp->FileObject->DeviceObject->Vpb->SerialNumber;
                     } else if (DeviceObject->Vpb != 0) {
                        qInfo->serial = DeviceObject->Vpb->SerialNumber;
                     } else {
                        //
                        // ERROR - no volume serial number - this is fatal
                        //
                        qInfo->serial = 0;
                        RsLogError(__LINE__, AV_MODULE_RPFILTER, 0,
                                   AV_MSG_SERIAL, NULL, NULL);
                     }
                     qInfo->options = irpSp->Parameters.Create.Options;
                     qInfo->irp = Irp;
                     qInfo->irpSp = irpSp;
                     qInfo->desiredAccess = irpSp->Parameters.Create.SecurityContext->DesiredAccess;

                     qInfo->fileId = fileId;
                     qInfo->objIdHi = objIdHi;
                     qInfo->objIdLo = objIdLo;
                     RtlMoveMemory(&qInfo->rpData, pRpData, sizeof(RP_DATA));

                     pnding->qInfo = qInfo;

                     qInfo->irpSp = IoGetCurrentIrpStackLocation( qInfo->irp );
                     qInfo->irpSp->Parameters.Create.Options |= FILE_OPEN_REPARSE_POINT;

		     IoCopyCurrentIrpStackLocationToNext( qInfo->irp );


                     //
                     // We have to free the buffer here because NTFS will assert if
                     // it is not NULL and the IO system has not had the chance to
                     // free it.
                     //
                     ExFreePool(qInfo->irp->Tail.Overlay.AuxiliaryBuffer);
                     qInfo->irp->Tail.Overlay.AuxiliaryBuffer = NULL;

                     IoSetCompletionRoutine( qInfo->irp,
                                             RsOpenComplete,
                                             pnding,
                                             TRUE,        // Call on success
                                             TRUE,        // fail
                                             TRUE) ;      // and on cancel

                     pnding->flags |= RP_PENDING_IS_RECALL | RP_PENDING_RESEND_IRP;
                     status = STATUS_MORE_PROCESSING_REQUIRED;
                  } else {
                     //
                     // Failed to get memory for queue information
                     //
                     status = STATUS_INVALID_PARAMETER;
                     Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
                     RsLogError(__LINE__, AV_MODULE_RPFILTER, sizeof(RP_CREATE_INFO),
                                AV_MSG_MEMORY, NULL, NULL);
                  }
               }
            }
         } else {
            //
            // There is a data stream or read/write data was not
            // specified so just open with FILE_OPEN_REPARSE_POINT
            //
            status = STATUS_MORE_PROCESSING_REQUIRED;
            irpSp->Parameters.Create.Options |= FILE_OPEN_REPARSE_POINT;

	    IoCopyCurrentIrpStackLocationToNext( Irp );

            IoSetCompletionRoutine( Irp,
                                    RsOpenComplete,
                                    pnding,
                                    TRUE,        // Call on success
                                    TRUE,        // fail
                                    TRUE) ;      // and on cancel

            if (dwRemainingNameLength != 0) {
               //
               // A named data stream is being opened
               //
               DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Opening datastream.\n"));
            } else {

               DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Opening with FILE_OVERWRITE or FILE_OVERWRITE_IF or FILE_SUPERSEDE\n"));

               ASSERT ((dwDisp == FILE_OVERWRITE) || (dwDisp == FILE_OVERWRITE_IF) || (dwDisp == FILE_SUPERSEDE));

               if (RP_FILE_IS_TRUNCATED(pRpData->data.bitFlags)) {
                  //
                  // Indicate that we need to reset the FILE_ATTRIBUTE_OFFLINE here
                  // This is because the file is being over-written - hence we can clear
                  // this attribute safely if NTFS successfuly completes the open with
                  // these options
                  //
                  pnding->flags |= RP_PENDING_RESET_OFFLINE;
               }
            }
            //
            // We have to free the buffer here because NTFS will assert if
            // it is not NULL and the IO system has not had the chance to
            // free it.
            //
            ExFreePool(Irp->Tail.Overlay.AuxiliaryBuffer);

            Irp->Tail.Overlay.AuxiliaryBuffer = NULL;
            pnding->flags |= RP_PENDING_RESEND_IRP;
         }
      }

      if (status != STATUS_MORE_PROCESSING_REQUIRED) {
         //
         // We want to pass the Irp untouched except we need to
         // Propogate the IRP pending flag.
         //
         DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Passing Irp as is\n"));

         if (Irp->PendingReturned) {
            IoMarkIrpPending( Irp );
         }

         if (status != STATUS_SUCCESS) {
            //
            // Irp status already set.
            //
            Irp->IoStatus.Information = 0;
         }
      } else {
         DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Not our reparse point\n"));
      }

   }except (RsExceptionFilter(L"RsCreateCheck", GetExceptionInformation()) ) {
      //
      // Propogate the IRP pending flag.
      //

      if (Irp->PendingReturned) {
         IoMarkIrpPending( Irp );
      }
   }

   KeSetEvent(&pnding->irpCompleteEvent, IO_NO_INCREMENT, FALSE);

   return(STATUS_MORE_PROCESSING_REQUIRED);
}


DBGSTATIC
NTSTATUS
RsOpenComplete(
              IN PDEVICE_OBJECT DeviceObject,
              IN PIRP Irp,
              IN PVOID Context
              )

/*++

Routine Description:

   This completion routine will be called by the I/O manager when an
   file create request has been completed by a filtered driver. The file object is on the queue and
   we just need to get the rest of the information we need to fill in the entry before letting the
   application get it's handle.

Arguments:

   DeviceObject - Pointer to the device object (filter's) for this request

   Irp - Pointer to the Irp that is being completed

   Context - Driver defined context - points to RP_PENDING_CREATE structure

Return Value:

   STATUS_SUCCESS


--*/

{
   PIO_STACK_LOCATION  irpSp;
   PRP_PENDING_CREATE  pnding;

   UNREFERENCED_PARAMETER(DeviceObject);

   pnding = (PRP_PENDING_CREATE) Context;

   irpSp = IoGetCurrentIrpStackLocation( Irp );

   DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsOpenComplete:  create options %x \n",irpSp->Parameters.Create.Options));

   if ((irpSp->FileObject) && RP_IS_NO_RECALL_OPTION(irpSp->Parameters.Create.Options)) {
      //
      // Do not support cached IO to this file
      //
      irpSp->FileObject->Flags &= ~FO_CACHE_SUPPORTED;
   }

   //
   // Propogate the IRP pending flag.
   //
   if (Irp->PendingReturned) {
      IoMarkIrpPending( Irp );
   }

   // Signal the mainline code that the open is now complete.

   KeSetEvent(&pnding->irpCompleteEvent, IO_NO_INCREMENT, FALSE);

   //
   // The IRP will be completed by RsCreate
   //
   return(STATUS_MORE_PROCESSING_REQUIRED);
}


NTSTATUS
RsRead(
      IN PDEVICE_OBJECT DeviceObject,
      IN PIRP Irp
      )

/*++

Routine Description:

   This entry point is called any time than IRP_MJ_READ has been requested
   of the file system driver that this filter is layered on top of. This
   code is required to correctly set the parameters (in the Irp stack) and
   pass the Irp (after setting its stack location) down.

   The file system filter will accomplish these objectives by taking the
   following steps:

   1. Copy current Irp stack location to the next Irp stack location.
   2. If file was open with no recall option then return the data
      otherwise call the targeted file system.

Arguments:

   DeviceObject - Pointer to the device object (filter's) for this request

   Irp - Pointer to the I/O request packet for this request

Return Value:

   The NTSTATUS returned from the filtered file system when called with this
   Irp.

--*/

{
   PIO_STACK_LOCATION          currentStack ;
   BOOLEAN                     pagingIo;
   PUCHAR                      buffer;
   LARGE_INTEGER               offset, length;
   PRP_DATA                    pRpData;
   NTSTATUS                    status = STATUS_SUCCESS;
   POBJECT_NAME_INFORMATION    str;
   LONGLONG                    fileId;
   LONGLONG                    objIdHi;
   LONGLONG                    objIdLo;
   ULONG                       options;
   PDEVICE_EXTENSION           deviceExtension;
   ULONGLONG                   filterId;
   USN                         usn;

   status = STATUS_SUCCESS;
   deviceExtension = DeviceObject->DeviceExtension;

   if (!deviceExtension->Type) {
      Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
      Irp->IoStatus.Information = 0;

      IoCompleteRequest( Irp, IO_NO_INCREMENT );

      return STATUS_INVALID_DEVICE_REQUEST;
   }


   //
   // As the rest of this routine will need to know information contained
   // in the stack locations (current and next) of the Irp that is being
   // dealt with, get those pointers now.
   //
   currentStack = IoGetCurrentIrpStackLocation (Irp) ;

   //
   // If this is not one of ours we should bail out asap
   //

   if (RsIsFileObj(currentStack->FileObject, TRUE, &pRpData, &str, &fileId, &objIdHi, &objIdLo, &options, &filterId, &usn) == FALSE) {
      //
      // An operation which does not require data modification has been
      // encountered.
      //
      // Get this driver out of the driver stack and get to the next driver as
      // quickly as possible.
      //

      IoSkipCurrentIrpStackLocation (Irp);

      DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Untouched read\n"));
      return(IoCallDriver( deviceExtension->FileSystemDeviceObject, Irp ));
   }
   //
   // Check if the file needs to be recalled...
   //
   if (!RP_IS_NO_RECALL_OPTION(options)) {
      DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Read: Offset = %I64x size = %u File Obj = %x.\n",
                            currentStack->Parameters.Read.ByteOffset.QuadPart,
                            currentStack->Parameters.Read.Length,
                            currentStack->FileObject));

      if ((status = RsCheckRead(Irp, currentStack->FileObject, deviceExtension)) == STATUS_SUCCESS) {
         //
         // Pass the read to the file system
         //
         IoSkipCurrentIrpStackLocation (Irp);

         DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Passing Read: Offset = %x%x size = %u.\n",
                             currentStack->Parameters.Read.ByteOffset.HighPart,
                             currentStack->Parameters.Read.ByteOffset.LowPart,
                             currentStack->Parameters.Read.Length));

         status = IoCallDriver( deviceExtension->FileSystemDeviceObject, Irp );
      } else if (status == STATUS_PENDING) {
         //
         // It was queued until the data is recalled (or failed already) - return the status from RsCheckRead
         // Fall through to return the status
         //
      } else {
         //
         // Some error occurred: complete the IRP with the error status
         //
         Irp->IoStatus.Status = status;
         Irp->IoStatus.Information = 0 ;
         IoCompleteRequest (Irp, IO_NO_INCREMENT) ;
      }
   } else {
      //
      //
      // File was open no-recall - if it is pre-migrated then we need not go to the FSA for the data and can let the reads go.
      //
      if (RP_FILE_IS_TRUNCATED(pRpData->data.bitFlags)) {
         if (FALSE == RsAllowRecalls) {
            RsLogError(__LINE__, AV_MODULE_RPFILTER, 0,
                       AV_MSG_FSA_ERROR, NULL, NULL);

            Irp->IoStatus.Status = STATUS_FILE_IS_OFFLINE;
            Irp->IoStatus.Information = 0 ;
            IoCompleteRequest (Irp, IO_NO_INCREMENT) ;
            return(STATUS_FILE_IS_OFFLINE) ;
         }


         //
         // Get the current flag status of IRP_PAGING_IO
         //
         pagingIo = BooleanFlagOn (Irp->Flags, IRP_PAGING_IO) ;

         DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Read (No Recall): Offset = %x%x size = %u Pageio = %u.\n",
                               currentStack->Parameters.Read.ByteOffset.HighPart,
                               currentStack->Parameters.Read.ByteOffset.LowPart,
                               currentStack->Parameters.Read.Length,
                               pagingIo));
         //
         // This is a read which requires action on the part of the file system
         // filter driver.
         //
         if (!pagingIo) {
            //
            // Set the buffer pointer to NULL so we know to lock the memory and get
            // the system address later.
            //
            buffer = NULL;

         } else {
            //
            // If it is paging IO we already have a locked down buffer so we can just
            // save away the system address.
            //
            buffer = MmGetSystemAddressForMdlSafe(Irp->MdlAddress,
                                                  NormalPagePriority);

            if (buffer == NULL) {
               Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
               Irp->IoStatus.Information = 0 ;
               IoCompleteRequest (Irp, IO_NO_INCREMENT);
	       return(STATUS_INSUFFICIENT_RESOURCES);
            }
         }


         //
         // Now that the a virtual address valid in system space has been obtained
         // for the user buffer, call the support routine to get the data
         //

         offset.QuadPart = currentStack->Parameters.Read.ByteOffset.QuadPart;
         length.QuadPart = currentStack->Parameters.Read.Length;

         DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: read...\n"));

         Irp->IoStatus.Information = 0;      // Initialize in case partial data is returned.

         if (!RsUseUncachedNoRecall) {
            //
            // Use cached no-recall path
            //
            status = RsGetNoRecallData(currentStack->FileObject,
                                       Irp,
                                       usn,
                                       offset.QuadPart,
                                       length.QuadPart,
                                       buffer);
         }  else {
             //
             // Use non-cached no-recall path
             //
             if (buffer == NULL) {
                //
                // We need to get an MDL for the user buffer (this is not paging i/o,
                // so the pages are not locked down)
                //
                ASSERT (Irp->UserBuffer);

                Irp->MdlAddress = IoAllocateMdl(
                                            Irp->UserBuffer,
                                            currentStack->Parameters.Read.Length,
                                            FALSE,
                                            FALSE,
                                            NULL) ;
                if (!Irp->MdlAddress) {
                    //
                    // A resource problem has been encountered. Set appropriate status
                    // in the Irp, and begin the completion process.
                    //
                   DebugTrace((DPFLTR_RSFILTER_ID,
			       DBG_ERROR, 
			       "RsFilter: RsCheckRead - norecall - Unable to allocate an MDL for user buffer %x\n", 
			       (PUCHAR) Irp->UserBuffer));

                   status = STATUS_INSUFFICIENT_RESOURCES;
                }
              }
              if (NT_SUCCESS(status)) {
                    status = RsQueueNoRecall(
                                         currentStack->FileObject,
                                         Irp,
                                         offset.QuadPart,
                                         length.QuadPart,
                                         0,
                                         currentStack->Parameters.Read.Length,
                                         NULL,
                                         //
                                         // RsQueueNoRecall expects the buffer to be NULL
                                         // (and a valid Irp->MdlAddress) if the pages needed
                                         // to be locked down - if not it uses the
                                         // supplied buffer pointer to copy the data to.
                                         //
                                         buffer);

             }

         }

         if (status != STATUS_PENDING) {
            //
            // Failed to queue the recall
            //
            if (status != STATUS_SUCCESS) {
               DebugTrace((DPFLTR_RSFILTER_ID,
			   DBG_INFO, 
			   "RsFilter: RsGetNoRecallData Failed to queue the request, status 0x%X\n",
			   status));
            }

	    if (!NT_SUCCESS (status)) {
	        Irp->IoStatus.Information = 0 ;
	    }

            Irp->IoStatus.Status = status;
            IoCompleteRequest (Irp, IO_NO_INCREMENT) ;
            //
            // Fall through to return the status
            //
         } else {
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: read returning pending\n"));
         }
      } else {
         //
         // Pass the read to the file system (file is pre-migrated)
         //
         IoSkipCurrentIrpStackLocation (Irp);

         DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Passing Read: Offset = %x%x size = %u.\n",
                             currentStack->Parameters.Read.ByteOffset.HighPart,
                             currentStack->Parameters.Read.ByteOffset.LowPart,
                             currentStack->Parameters.Read.Length));

         status = IoCallDriver( deviceExtension->FileSystemDeviceObject, Irp );
      }
   }

   return(status);

}


VOID
RsCompleteRead(IN PRP_IRP_QUEUE ReadIo,
               IN BOOLEAN Unlock)
/*++
Routine Description

   Completes the passed in no-recall Irp and unlocks any buffers & frees the Mdl
   if necessary

Arguments

   ReadIo - pointer to the RP_IRP_QUEUE entry for the IRP
   Unlock - If TRUE, the pages mapped by Irp->MdlAddress will be unlocked

Return Value

   None
--*/
{
   BOOLEAN                 pagingIo, synchronousIo;
   PIO_STACK_LOCATION      currentStack ;
   PIRP                    irp = NULL;

   PAGED_CODE();

   try {

      irp = ReadIo->irp;

      currentStack = IoGetCurrentIrpStackLocation (irp) ;
      pagingIo = BooleanFlagOn (irp->Flags, IRP_PAGING_IO) ;
      synchronousIo = BooleanFlagOn( currentStack->FileObject->Flags, FO_SYNCHRONOUS_IO );

      if (ReadIo->cacheBuffer) {
         //
         // This is a cached no-recall-read
         // Indicate to RsCache that this transfer is complete
         //
         RsCacheFsaIoComplete(ReadIo,
                              irp->IoStatus.Status);
      }

      if (!pagingIo) {
         //
         // Now that the data has been filled in, unmap the MDL so that
         // the data will be updated.
         //
         if (Unlock) {
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Unlock buffer....\n"));
            MmUnlockPages (irp->MdlAddress) ;
         }
         IoFreeMdl(irp->MdlAddress);
         irp->MdlAddress = NULL;
      }

      if (synchronousIo) {
         //
         // Change the current byte offset in the file object
         //
         currentStack->FileObject->CurrentByteOffset.QuadPart += irp->IoStatus.Information;
      }

      if (irp->IoStatus.Status != STATUS_SUCCESS) {
         irp->IoStatus.Information = 0;
      }

   }except (RsExceptionFilter(L"RsCompleteRead", GetExceptionInformation()) ) {
   }
   //
   // Everything has been unwound now. So, complete the irp.
   //
   DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Completing read (%x) with status of %x.\n", irp, irp->IoStatus.Status));

   IoCompleteRequest (irp, IO_NO_INCREMENT) ;
}


NTSTATUS
RsWrite(
       IN PDEVICE_OBJECT DeviceObject,
       IN PIRP Irp
       )

/*++

Routine Description:

   This entry point is called any time than IRP_MJ_WRITE has been requested
   of the file system driver that this filter is layered on top of. This
   code is required to correctly set the parameters (in the Irp stack) and
   pass the Irp (after setting its stack location) down.

   The file system filter will accomplish these objectives by taking the
   following steps:

   1. Copy current Irp stack location to the next Irp stack location.

Arguments:

   DeviceObject - Pointer to the device object (filter's) for this request

   Irp - Pointer to the I/O request packet for this request

Return Value:

   The NTSTATUS returned from the filtered file system when called with this
   Irp.

--*/

{
   PIO_STACK_LOCATION          currentStack ;
   NTSTATUS                    status;
   PDEVICE_EXTENSION           deviceExtension;
   BOOLEAN                     pagingIo;

   deviceExtension = DeviceObject->DeviceExtension;

   if (!deviceExtension->Type) {
      Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
      Irp->IoStatus.Information = 0;

      IoCompleteRequest( Irp, IO_NO_INCREMENT );

      return STATUS_INVALID_DEVICE_REQUEST;
   }
   //
   // As the rest of this routine will need to know information contained
   // in the stack locations (current and next) of the Irp that is being
   // dealt with, get those pointers now.
   //

   currentStack = IoGetCurrentIrpStackLocation (Irp) ;

   //
   // If this is paging i/o, or not one of ours we should bail out asap
   //
   pagingIo = BooleanFlagOn(Irp->Flags, IRP_PAGING_IO);

   if (pagingIo || (RsIsFileObj(currentStack->FileObject, FALSE, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL) == FALSE)) {
      //
      //
      // Get this driver out of the driver stack and get to the next driver as
      // quickly as possible.
      //

      IoSkipCurrentIrpStackLocation (Irp);

      DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Untouched write\n"));
      return(IoCallDriver( deviceExtension->FileSystemDeviceObject, Irp ));
   }
   //
   // It is a normal open - either queue the request or pass it on now.
   //
   DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Write: Offset = %x%x size = %u File Obj = %x.\n",
                         currentStack->Parameters.Write.ByteOffset.HighPart,
                         currentStack->Parameters.Write.ByteOffset.LowPart,
                         currentStack->Parameters.Write.Length,
                         currentStack->FileObject));

   if ((status = RsCheckWrite(Irp, currentStack->FileObject, deviceExtension)) == STATUS_SUCCESS) {
      //
      // Pass the write to the file system
      //
      IoSkipCurrentIrpStackLocation (Irp);

      DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Passing Write: Offset = %x%x size = %u.\n",
                          currentStack->Parameters.Write.ByteOffset.HighPart,
                          currentStack->Parameters.Write.ByteOffset.LowPart,
                          currentStack->Parameters.Write.Length));

      status = IoCallDriver( deviceExtension->FileSystemDeviceObject, Irp );
   } else if (status == STATUS_PENDING) {
      //
      // It was queued until the data is recalled (or failed already) - return the status from RsCheckWrite
      //
   } else {
      //
      // Some error occurred: complete the IRP with the error status
      //
      Irp->IoStatus.Status = status;
      Irp->IoStatus.Information = 0 ;
      IoCompleteRequest (Irp, IO_NO_INCREMENT) ;
   }

   return(status);
}


DBGSTATIC
NTSTATUS
RsShutdown(
          IN PDEVICE_OBJECT DeviceObject,
          IN PIRP Irp
          )

/*++

Routine Description:
    System is shutting down - complete all outstanding device IO requests

Arguments:

    DeviceObject - Pointer to the target device object

    Irp - Pointer to the I/O Request Packet that represents the operation.

Return Value:

    The function value is the status of the call to the file system's entry
    point.

--*/

{
   PDEVICE_EXTENSION     deviceExtension;


   PAGED_CODE();


   //
   // Get a pointer to this driver's device extension for the specified device.
   //
   deviceExtension = DeviceObject->DeviceExtension;


   //
   // Simply copy this driver stack location contents to the next driver's
   // stack.
   //
   IoCopyCurrentIrpStackLocationToNext( Irp );
   IoSetCompletionRoutine( Irp, NULL, NULL, FALSE, FALSE, FALSE );


   RsCancelRecalls();

   RsCancelIo();

   //
   // Now call the appropriate file system driver with the request.
   //

   return IoCallDriver( deviceExtension->FileSystemDeviceObject, Irp );
}


DBGSTATIC
NTSTATUS
RsCleanupFile(
             IN PDEVICE_OBJECT DeviceObject,
             IN PIRP Irp
             )

/*++

Routine Description:

    This function filters file cleanup operations.  If the file object is on our list
    then we may need to do some additional cleanup.  All of this will only happen on
    the last cleanup on the file.  This consists of the following:

    For files opened without no-recall option:

        If the file was not written by the user then we need to preserve the dates and mark the
        USN source info. (Since it was written by us to recall it).

        If the file was written by the user we should (may?) remove the reparse point information and
        tell the FSA of the change.

        If the file has not been fully recalled yet ???? (other file objects may be waiting on it).

        If the recall had never started (or is being done on another file object) then we just remove the
        file object from the list and let it go.


    For files opened with the no-recall option:

        Just remove it from the list.



Arguments:

    DeviceObject - Pointer to the target device object of the create/open.

    Irp - Pointer to the I/O Request Packet that represents the operation.

Return Value:

    The function value is the status of the call to the file system's entry
    point.

--*/

{
   PDEVICE_EXTENSION           deviceExtension;

   PAGED_CODE();


   deviceExtension = DeviceObject->DeviceExtension;

   if (!deviceExtension->Type) {
      Irp->IoStatus.Status = STATUS_SUCCESS;
      Irp->IoStatus.Information = 0;
      IoCompleteRequest( Irp, IO_DISK_INCREMENT );
      return STATUS_SUCCESS;
   }

   DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: RsCleanup\n"));


   //
   // Simply copy this driver stack location contents to the next driver's
   // stack.
   //
   IoCopyCurrentIrpStackLocationToNext( Irp );
   IoSetCompletionRoutine( Irp, NULL, NULL, FALSE, FALSE, FALSE );


   DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Leave cleanup\n"));

   return IoCallDriver( deviceExtension->FileSystemDeviceObject, Irp );

}


DBGSTATIC
NTSTATUS
RsRecallFsControl(
                 IN PDEVICE_OBJECT DeviceObject,
                 IN PIRP  Irp
                 )
/*++

Routine Description

   This handles all the recall-specific FSCTLs directed towards the primary device object
   for RsFilter
Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.

--*/
{
   NTSTATUS                status;
   PIO_STACK_LOCATION      irpSp = IoGetCurrentIrpStackLocation( Irp );
   PRP_MSG                 msg;


   PAGED_CODE();

   switch (irpSp->Parameters.FileSystemControl.FsControlCode) {

   case FSCTL_HSM_MSG: {
         //
         // This is an HSM specific message (METHOD_BUFFERED)
         //
         msg = (RP_MSG *) Irp->AssociatedIrp.SystemBuffer;
         if (msg == NULL) {
            status = STATUS_INVALID_USER_BUFFER;
            break;
         }
         status = STATUS_UNSUCCESSFUL;
         //
         // Make sure we can read the msg part
         //
         DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: FSCTL - msg = %x.\n", msg));

         if (irpSp->Parameters.FileSystemControl.InputBufferLength >= sizeof(RP_MSG)) {
            switch (msg->inout.command) {

            case RP_GET_REQUEST: {
                  DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: FSCTRL Wait for recall request\n"));
                  status = RsAddIo(Irp);

                  if (NT_SUCCESS(status)) {
                     status = STATUS_PENDING;
                  } else {
                     Irp->IoStatus.Information = 0;
                  }
                  break;
               }

            default: {
                  DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Unknown FSCTL! (%u)\n",
                                        msg->inout.command));
                  /* Complete the fsctl request */
                  status = STATUS_INVALID_PARAMETER;
                  Irp->IoStatus.Information = 0;
                  break;
               }
            }
         } else {
            status = STATUS_INVALID_USER_BUFFER;
            Irp->IoStatus.Information = 0;
         }

         DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: FSCTL - Complete request (%u) - %x.\n",
                               Irp->IoStatus.Information,
                               status));
         break;
      }

   case FSCTL_HSM_DATA: {
         try {
            //
            // This is an HSM specific message (METHOD_NEITHER)
            //
            ULONG length;

            status = STATUS_UNSUCCESSFUL;

            if ((irpSp->Parameters.FileSystemControl.Type3InputBuffer == NULL) ||
                (irpSp->Parameters.FileSystemControl.InputBufferLength < sizeof(RP_MSG))) {
               status = STATUS_INVALID_PARAMETER;
               break;
            }
            msg = (PRP_MSG) irpSp->Parameters.FileSystemControl.Type3InputBuffer;
            if (Irp->RequestorMode != KernelMode) {
               ProbeForWrite(msg,
                             sizeof(RP_MSG),
                             sizeof(UCHAR));
            };

            switch (msg->inout.command) {

            case RP_RECALL_COMPLETE: {
                  DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Fsa action complete %I64x (%x)\n",
                                        msg->msg.rRep.filterId, msg->inout.status));
                  (VOID) RsCompleteRecall(DeviceObject,
                                          msg->msg.rRep.filterId,
                                          msg->inout.status,
                                          msg->msg.rRep.actionFlags,
                                          TRUE);
                  /* Complete the FSCTL request */
                  Irp->IoStatus.Information = 0;
                  status = STATUS_SUCCESS;
                  break;
               }
            case RP_SUSPEND_NEW_RECALLS: {
                  DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Suspend new recalls\n"));
                  RsAllowRecalls = FALSE;
                  /* Complete the FSCTL request */
                  status = STATUS_SUCCESS;
                  break;
               }
            case RP_ALLOW_NEW_RECALLS: {
                  DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Allow new recalls\n"));
                  RsAllowRecalls = TRUE;
                  //
                  // Reload the registry params
                  //
                  status = RsInitialize();
                  break;
               }

            case RP_CANCEL_ALL_RECALLS: {
                  DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Cancel all recalls\n"));
                  RsCancelRecalls();
                  /* Complete the FSCTL request */
                  status = STATUS_SUCCESS;
                  break;
               }

            case RP_CANCEL_ALL_DEVICEIO: {
                  DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Cancel all FSCTL\n"));
                  RsCancelIo();
                  /* Complete the FSCTL request */
                  status = STATUS_SUCCESS;
                  break;
               }

            case RP_PARTIAL_DATA: {

                  PMDL mdlAddress;
                  ULONG total;
                  //
                  // Check if the passed in parameters are valid
                  //
                  status = STATUS_SUCCESS;

                  total = msg->msg.pRep.offsetToData + msg->msg.pRep.bytesRead;

                  if ((total < msg->msg.pRep.offsetToData) || (total < msg->msg.pRep.bytesRead)) {
                     //
                     // Overflow
                     //
                     status = STATUS_INVALID_PARAMETER;
                     break;
                  }

                  if (irpSp->Parameters.FileSystemControl.InputBufferLength < total) {
                     DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Invalid buffer for RP_PARTIAL_DATA - %u \n", irpSp->Parameters.FileSystemControl.InputBufferLength));
                     status = STATUS_INVALID_USER_BUFFER;
                     break;
                  }
                  //
                  // Now map the user buffer to a system address, since
                  // we would be accessing it another process context
                  //
                  mdlAddress = IoAllocateMdl(msg,
                                             irpSp->Parameters.FileSystemControl.InputBufferLength,
                                             FALSE,
                                             FALSE,
                                             NULL);
                  if (!mdlAddress) {
                     status = STATUS_INSUFFICIENT_RESOURCES;
                     break;
                  }
                  //
                  // This is protected by the enclosing try-except for
                  // FsControl module
                  //
                  try {
                     MmProbeAndLockPages(mdlAddress,
                                         UserMode,
                                         IoReadAccess);
                  }except (EXCEPTION_EXECUTE_HANDLER) {
                       DebugTrace((DPFLTR_RSFILTER_ID,DBG_ERROR, "RsFilter: Unable to lock read buffer!.\n"));
                        RsLogError(__LINE__, AV_MODULE_RPFILTER, 0,
                                   AV_MSG_NO_BUFFER_LOCK, NULL, NULL);
                       IoFreeMdl(mdlAddress);
                       status = STATUS_INVALID_USER_BUFFER;
                  }

                  if (!NT_SUCCESS(status)) {
                    break;
                  }

                  //
                  // Update msg to point to the system address
                  //
                  msg = MmGetSystemAddressForMdlSafe(mdlAddress,
                                                     NormalPagePriority);

                  if (msg == NULL) {
                     IoFreeMdl(mdlAddress);
                     break;
                  }

                  DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Partial data for a recall on read %I64x (%u)\n",
                                        msg->msg.pRep.filterId, msg->inout.status));
                  status = RsPartialData(DeviceObject,
                                         msg->msg.pRep.filterId,
                                         msg->inout.status,
                                         (CHAR *) msg + msg->msg.pRep.offsetToData,
                                         msg->msg.pRep.bytesRead,
                                         msg->msg.pRep.byteOffset);

                  MmUnlockPages(mdlAddress);
                  IoFreeMdl(mdlAddress);
                  Irp->IoStatus.Information = 0;
                  break;
               }

            case RP_GET_RECALL_INFO: {
                  DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Get Recall info for %I64x\n",
                                        msg->msg.riReq.filterId));

                  status = RsGetRecallInfo(msg,
                                           &Irp->IoStatus.Information,
                                           Irp->RequestorMode);
                  break;
               }

            default: {
                  DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Unknown FSCTL! (%u)\n",
                                        msg->inout.command));
                  /* Complete the fsctl request */
                  status = STATUS_INVALID_PARAMETER;
                  Irp->IoStatus.Information = 0;
                  break;
               }

            }
         }except (RsExceptionFilter(L"RsFilter", GetExceptionInformation())) {
            ASSERTMSG("RsFilter: Exception occurred in processing msg\n",FALSE);
            status = STATUS_INVALID_USER_BUFFER;
         }
         break;
      }
   default: {
         status = STATUS_INVALID_DEVICE_REQUEST;
         break;
      }
   }

   if (status != STATUS_PENDING) {
      Irp->IoStatus.Status = status;
      IoCompleteRequest (Irp, IO_NO_INCREMENT) ;
   }

   return status;
}



DBGSTATIC
NTSTATUS
RsFsControl(
           IN PDEVICE_OBJECT DeviceObject,
           IN PIRP Irp
           )

/*++

Routine Description:

    This routine is invoked whenever an I/O Request Packet (IRP) w/a major
    function code of IRP_MJ_FILE_SYSTEM_CONTROL is encountered.  For most
    IRPs of this type, the packet is simply passed through.  However, for
    some requests, special processing is required.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.

--*/
{
    NTSTATUS            status;
    PIO_STACK_LOCATION  irpSp            = IoGetCurrentIrpStackLocation( Irp );
    PDEVICE_EXTENSION   deviceExtension  = DeviceObject->DeviceExtension;


    PAGED_CODE();


    DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Enter FsControl\n"));


    if (!deviceExtension->Type) {
        //
	// This is for the primary device object
        //
        status = RsRecallFsControl(DeviceObject, Irp);

    } else {
	//
	// Begin by determining the minor function code for this file system control
	// function.
	//
	if (irpSp->MinorFunction == IRP_MN_MOUNT_VOLUME) {

	    status = RsFsControlMount (DeviceObject, Irp);


	} else if (irpSp->MinorFunction == IRP_MN_LOAD_FILE_SYSTEM) {

	    status = RsFsControlLoadFs (DeviceObject, Irp);


	} else if (irpSp->MinorFunction == IRP_MN_USER_FS_REQUEST) {

	    status = RsFsControlUserFsRequest (DeviceObject, Irp);


        } else {
            //
            // Not  a minor function we are interested in
            // Just get out of the way
            //
            IoSkipCurrentIrpStackLocation(Irp);

            status = IoCallDriver( deviceExtension->FileSystemDeviceObject, Irp );
        }
    }

    DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Exit FsControl\n"));

    return status;
}



DBGSTATIC
NTSTATUS
RsFsControlMount(
		IN PDEVICE_OBJECT DeviceObject,
		IN PIRP Irp
		)
{
    NTSTATUS            status;
    PIO_STACK_LOCATION  irpSp                    = IoGetCurrentIrpStackLocation( Irp );
    PDEVICE_EXTENSION   deviceExtension          = DeviceObject->DeviceExtension;
    PDEVICE_EXTENSION   NewFilterDeviceExtension = NULL;
    PDEVICE_OBJECT      NewFilterDeviceObject    = NULL;
    PDEVICE_OBJECT      pRealDevice              = NULL;
    PDEVICE_OBJECT	pTargetDevice            = NULL;
    KEVENT              CompletionEvent;
    PVPB		vpb;


    //
    // This is a mount request. Create a device object that can be
    // attached to the file system's volume device object if this request
    // is successful. We allocate this memory now since we can not return
    // an error in the completion routine.  
    //
    DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Mount volume\n"));


    status = IoCreateDevice (FsDriverObject,
			     sizeof( DEVICE_EXTENSION ),
			     (PUNICODE_STRING) NULL,
			     FILE_DEVICE_DISK_FILE_SYSTEM,
			     0,
			     FALSE,
			     &NewFilterDeviceObject);


    if (!NT_SUCCESS (status)) {

        //
        // Something went wrong, we cannot filter this volume
        //
	DebugTrace ((DPFLTR_RSFILTER_ID, 
		     DBG_VERBOSE, 
		     "RsFilter: Mount volume - failed to create device object (0x%08x)\n",
		     status));

        IoSkipCurrentIrpStackLocation(Irp);

        status = IoCallDriver (deviceExtension->FileSystemDeviceObject, Irp);

    } else {

	//
	// Set up the completion context
	//
	// Note that we need to save the RealDevice object
	// pointed to by the vpb parameter because this vpb
	// may be changed by the underlying file system. Both
	// FAT and CDFS may change the VPB address if the
	// volume being mounted is one they recognize from a
	// previous mount.
	//
	pRealDevice = irpSp->Parameters.MountVolume.Vpb->RealDevice;

        KeInitializeEvent (&CompletionEvent, SynchronizationEvent, FALSE);

	IoCopyCurrentIrpStackLocationToNext( Irp );

	IoSetCompletionRoutine (Irp,
				RsAsyncCompletion,
				&CompletionEvent,
				TRUE,
				TRUE,
				TRUE);

        status = IoCallDriver (deviceExtension->FileSystemDeviceObject, Irp);

	if (STATUS_PENDING == status) {

            KeWaitForSingleObject (&CompletionEvent, UserRequest, KernelMode, FALSE, NULL);

	}



        if (NT_SUCCESS( Irp->IoStatus.Status )) {

            //
            // Note that the VPB must be picked up from the target device object
            // in case the file system did a remount of a previous volume, in
            // which case it has replaced the VPB passed in as the target with
            // a previously mounted VPB.  
            //
            vpb = pRealDevice->Vpb;

            pTargetDevice = IoGetAttachedDevice( vpb->DeviceObject );


            NewFilterDeviceExtension = NewFilterDeviceObject->DeviceExtension;

            NewFilterDeviceExtension->RealDeviceObject       = vpb->RealDevice;
            NewFilterDeviceExtension->Attached               = TRUE;
            NewFilterDeviceExtension->Type                   = RSFILTER_DEVICE_TYPE;
            NewFilterDeviceExtension->Size                   = sizeof( DEVICE_EXTENSION );
            NewFilterDeviceExtension->WriteStatus            = RsVolumeStatusUnknown;
            NewFilterDeviceExtension->FileSystemDeviceObject = IoAttachDeviceToDeviceStack (NewFilterDeviceObject, pTargetDevice);

	    ASSERT (NULL != NewFilterDeviceExtension->FileSystemDeviceObject);


            NewFilterDeviceObject->Flags |= (NewFilterDeviceExtension->FileSystemDeviceObject->Flags & (DO_BUFFERED_IO | DO_DIRECT_IO)); 
            NewFilterDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

        } else {

            //
            // The mount request failed.  Simply delete the device object that was
            // created in case this request succeeded.
            //
            FsRtlEnterFileSystem();
            ExAcquireResourceExclusiveLite( &FsLock, TRUE );
            IoDeleteDevice( NewFilterDeviceObject);
            ExReleaseResourceLite( &FsLock );
            FsRtlExitFileSystem();
        }


	status = Irp->IoStatus.Status;

        IoCompleteRequest (Irp, IO_NO_INCREMENT);
    }


    DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Mount volume exit 0x%08X\n", status));

    return (status);
}



DBGSTATIC
NTSTATUS
RsFsControlLoadFs(
		 IN PDEVICE_OBJECT DeviceObject,
		 IN PIRP Irp
		 )
{
    NTSTATUS            status;
    PIO_STACK_LOCATION  irpSp           = IoGetCurrentIrpStackLocation( Irp );
    PDEVICE_EXTENSION   deviceExtension = DeviceObject->DeviceExtension;
    KEVENT              CompletionEvent;


    //
    // This is a load file system request being sent to a mini-file system
    // recognizer driver.  Detach from the file system now, and set
    // the address of a completion routine in case the function fails, in
    // which case a reattachment needs to occur.  Likewise, if the function
    // is successful, then the device object needs to be deleted.
    //
    DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Load file system\n"));

    KeInitializeEvent (&CompletionEvent, SynchronizationEvent, FALSE);


    IoDetachDevice( deviceExtension->FileSystemDeviceObject );
    deviceExtension->Attached = FALSE;

    IoCopyCurrentIrpStackLocationToNext( Irp );

    IoSetCompletionRoutine (Irp,
			    RsAsyncCompletion,
			    &CompletionEvent,
			    TRUE,
			    TRUE,
			    TRUE);

    status = IoCallDriver (deviceExtension->FileSystemDeviceObject, Irp);

    if (STATUS_PENDING == status) {

        KeWaitForSingleObject (&CompletionEvent, UserRequest, KernelMode, FALSE, NULL);

    }



    //
    // Begin by determining whether or not the load file system request was
    // completed successfully.
    //

    if (!NT_SUCCESS( Irp->IoStatus.Status )) {

        //
        // The load was not successful.  Simply reattach to the recognizer
        // driver in case it ever figures out how to get the driver loaded
        // on a subsequent call.
        //

        IoAttachDeviceToDeviceStack (DeviceObject, deviceExtension->FileSystemDeviceObject);
        deviceExtension->Attached = TRUE;

    } else {

        //
        // The load was successful.  However, in order to ensure that these
        // drivers do not go away, the I/O system has artifically bumped the
        // reference count on all parties involved in this manuever.  Therefore,
        // simply remember to delete this device object at some point in the
        // future when its reference count is zero.
        //
        FsRtlEnterFileSystem();
        ExAcquireResourceExclusiveLite( &FsLock, TRUE );
        IoDeleteDevice( DeviceObject);
        ExReleaseResourceLite( &FsLock );
        FsRtlExitFileSystem();
    }


    status = Irp->IoStatus.Status;

    IoCompleteRequest (Irp, IO_NO_INCREMENT);


    DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Load file system exit 0x%08X\n", status));

    return (status);
}



DBGSTATIC
NTSTATUS
RsFsControlUserFsRequest (
		         IN PDEVICE_OBJECT DeviceObject,
		         IN PIRP Irp
		         )
{
    NTSTATUS                        status;
    PIO_STACK_LOCATION              irpSp                 = IoGetCurrentIrpStackLocation( Irp );
    PDEVICE_EXTENSION               deviceExtension       = DeviceObject->DeviceExtension;
    PRP_DATA                        pRpData;
    PRP_DATA                        tmpRp;
    PFILE_ALLOCATED_RANGE_BUFFER    CurrentBuffer;
    PFILE_ALLOCATED_RANGE_BUFFER    OutputBuffer;
    ULONG                           RemainingBytes;
    LONGLONG                        StartingOffset;
    LONGLONG                        Length;
    ULONG                           InputBufferLength;
    ULONG                           OutputBufferLength;
    PCHAR                           rpOutputBuffer;
    PREPARSE_DATA_BUFFER            pRpBuffer;
    LARGE_INTEGER                   fSize;
    PRP_MSG                         msg;



    DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: FsCtl handler\n"));

    switch (irpSp->Parameters.FileSystemControl.FsControlCode) {

        case FSCTL_HSM_MSG: {
            //
            // This is an HSM specific message (METHOD_BUFFERED)
            //
            msg = (RP_MSG *) Irp->AssociatedIrp.SystemBuffer;
            if (msg == NULL) {
                status = STATUS_INVALID_USER_BUFFER;
                break;
            }

            status = STATUS_UNSUCCESSFUL;

            //
            // Make sure we can read the msg part
            //
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: FSCTL - msg = %x.\n", msg));
            if (irpSp->Parameters.FileSystemControl.InputBufferLength >= sizeof(RP_MSG)) {
                switch (msg->inout.command) {
                    case RP_CHECK_HANDLE: {
                        DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: FSCTL - Check Handle.\n"));
                        if (irpSp->Parameters.FileSystemControl.OutputBufferLength < sizeof(RP_MSG)) {
                            status = STATUS_BUFFER_TOO_SMALL;
                            Irp->IoStatus.Information = 0;
                        } else {
                            fSize.QuadPart = 0;
                            if ((irpSp->FileObject == NULL) || (irpSp->FileObject->SectionObjectPointer == NULL)) {
                                //
                                // If the wrong kind of handle is passed down
                                // like a volume handle, this could be NULL.
                                //
                                status = STATUS_INVALID_PARAMETER;
                            } else {
                                msg->msg.hRep.canTruncate =
                                MmCanFileBeTruncated(irpSp->FileObject->SectionObjectPointer,
                                                     &fSize);
                                DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: FSCTL - returning %x.\n", msg->msg.hRep.canTruncate));
                                status = STATUS_SUCCESS;
                                Irp->IoStatus.Information = sizeof(RP_MSG);
                            }
                        }
                        break;
                    }
                    default: {
                        DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: invalid RP_MSG (%u)\n",
                                              msg->inout.command));
                        status = STATUS_INVALID_PARAMETER;
                        Irp->IoStatus.Information = 0;
                        break;
                    }
                }
            } else {
                status = STATUS_INVALID_USER_BUFFER;
                Irp->IoStatus.Information = 0;
            }

            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: FSCTL - Complete request (%u) - %x.\n",
                                  Irp->IoStatus.Information,
                                  status));
            if (status != STATUS_PENDING) {
                Irp->IoStatus.Status = status;
                IoCompleteRequest (Irp, IO_NO_INCREMENT);
            }
            return status;
            break;
        }

        case FSCTL_QUERY_ALLOCATED_RANGES: {

            if (RsIsNoRecall(irpSp->FileObject, &pRpData) == TRUE) {

                DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsFsControl Handling Query Allocated Ranges for %x\n", irpSp->FileObject));
                Irp->IoStatus.Information = 0;

                try {

                    status = STATUS_SUCCESS;
                    if (irpSp->Parameters.FileSystemControl.InputBufferLength < sizeof(FILE_ALLOCATED_RANGE_BUFFER)) {
                        //
                        // Buffer too small
                        //
                        status = STATUS_INVALID_PARAMETER;
                    } else {
                        RemainingBytes = irpSp->Parameters.FileSystemControl.OutputBufferLength;
                        OutputBuffer = RsMapUserBuffer(Irp);
                        if (OutputBuffer != NULL) {
                            CurrentBuffer = OutputBuffer - 1;

                            if (Irp->RequestorMode != KernelMode) {
                                ProbeForRead( irpSp->Parameters.FileSystemControl.Type3InputBuffer,
                                              irpSp->Parameters.FileSystemControl.InputBufferLength,
                                              sizeof( ULONG ));

                                ProbeForWrite( OutputBuffer, RemainingBytes, sizeof( ULONG ));

                            } else if (!IsLongAligned(irpSp->Parameters.FileSystemControl.Type3InputBuffer ) ||
                                       !IsLongAligned(OutputBuffer)) {
                                status = STATUS_INVALID_USER_BUFFER;
                                leave;
                            }
                            //
                            //  Carefully extract the starting offset and length from
                            //  the input buffer.  If we are beyond the end of the file
                            //  or the length is zero then return immediately.  Otherwise
                            //  trim the length to file size.
                            //

                            StartingOffset = ((PFILE_ALLOCATED_RANGE_BUFFER) irpSp->Parameters.FileSystemControl.Type3InputBuffer)->FileOffset.QuadPart;
                            Length = ((PFILE_ALLOCATED_RANGE_BUFFER) irpSp->Parameters.FileSystemControl.Type3InputBuffer)->Length.QuadPart;
                            //
                            //  Check that the input parameters are valid.
                            //

                            if ((Length < 0) ||
                                 (StartingOffset < 0) ||
                                 (Length > MAXLONGLONG - StartingOffset)) {

                                status = STATUS_INVALID_PARAMETER;
                                leave;
                            }
                            //
                            //  Check that the requested range is within file size
                            //  and has a non-zero length.
                            //

                            if (Length == 0) {
                                leave;
                            }

                            if (StartingOffset > pRpData->data.dataStreamSize.QuadPart) {
                                leave;
                            }

                            if (pRpData->data.dataStreamSize.QuadPart - StartingOffset < Length) {
                                Length = pRpData->data.dataStreamSize.QuadPart - StartingOffset;
                            }

                            // Now just say that the whole thing is there

                            if (RemainingBytes < sizeof( FILE_ALLOCATED_RANGE_BUFFER )) {
                                status = STATUS_BUFFER_TOO_SMALL;

                            } else {
                                CurrentBuffer += 1;
                                CurrentBuffer->FileOffset.QuadPart = StartingOffset;
                                CurrentBuffer->Length.QuadPart = Length;
                                Irp->IoStatus.Information = sizeof( FILE_ALLOCATED_RANGE_BUFFER );
                            }
                            leave;
                        } else {
                            // Unable to map the user buffer
                            status = STATUS_INSUFFICIENT_RESOURCES;
                        }
                    }
                } except(EXCEPTION_EXECUTE_HANDLER) {
                    status = STATUS_INVALID_USER_BUFFER;
                }

                Irp->IoStatus.Status = status;
                IoCompleteRequest (Irp, IO_NO_INCREMENT) ;
                return(STATUS_SUCCESS) ;
            }
               break;
        }

        case FSCTL_GET_REPARSE_POINT: {

            if (RsIsNoRecall(irpSp->FileObject, &pRpData) == TRUE) {

                //
                //  Get the length of the input and output buffers.
                //
                DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsFsControl Handling Get Reparse Point for %x\n", irpSp->FileObject));

                InputBufferLength  = irpSp->Parameters.FileSystemControl.InputBufferLength;
                OutputBufferLength = irpSp->Parameters.FileSystemControl.OutputBufferLength;
                Irp->IoStatus.Information = 0;

                if (Irp->AssociatedIrp.SystemBuffer != NULL) {
                    rpOutputBuffer = (PCHAR)Irp->AssociatedIrp.SystemBuffer;
                } else if (Irp->MdlAddress != NULL) {
                    rpOutputBuffer = (PCHAR)MmGetSystemAddressForMdlSafe( Irp->MdlAddress,
                                                                          NormalPagePriority );
                    if (rpOutputBuffer == NULL) {
                        status = STATUS_INSUFFICIENT_RESOURCES;
                    }
                } else {
                    //
                    //  Return an invalid user buffer error.
                    //
                    rpOutputBuffer = NULL;
                    status = STATUS_INVALID_USER_BUFFER;
                }


                if ((rpOutputBuffer != NULL) && ((sizeof(RP_DATA) + REPARSE_DATA_BUFFER_HEADER_SIZE) > OutputBufferLength)) {

                    //
                    //  The input buffer is too short. Return a buffer too small error.
                    //  The caller receives the required length in  IoStatus.Information.
                    //

                    status = STATUS_BUFFER_OVERFLOW;

                    //
                    //  Now copy whatever portion of the reparse buffer will fit.  Hopefully the
                    //  caller allocated enough to hold the header, which contains the reparse
                    //  tag and reparse data length.
                    //

                    if (OutputBufferLength > 0) {
                        if (OutputBufferLength >= REPARSE_DATA_BUFFER_HEADER_SIZE) {
                            pRpBuffer = (PREPARSE_DATA_BUFFER) rpOutputBuffer;
                            pRpBuffer->ReparseTag = IO_REPARSE_TAG_HSM;
                            pRpBuffer->ReparseDataLength = sizeof(RP_DATA);
                            pRpBuffer->Reserved = 0;
                        }

                        if (OutputBufferLength > REPARSE_DATA_BUFFER_HEADER_SIZE) {
                            RtlCopyMemory( rpOutputBuffer + REPARSE_DATA_BUFFER_HEADER_SIZE,
                                           pRpData,
                                           OutputBufferLength - REPARSE_DATA_BUFFER_HEADER_SIZE);
                        }
                        if (OutputBufferLength > (ULONG) (REPARSE_DATA_BUFFER_HEADER_SIZE + FIELD_OFFSET(RP_DATA, data.migrationTime))) {
                            //
                            // Now fake out the bit to say it is pre-migrated (not truncated)
                            //
                            tmpRp = (PRP_DATA) (rpOutputBuffer + REPARSE_DATA_BUFFER_HEADER_SIZE);
                            tmpRp->data.bitFlags &= ~RP_FLAG_TRUNCATED;
                            RP_GEN_QUALIFIER(tmpRp, tmpRp->qualifier)
                        }
                    }
                } else if (rpOutputBuffer != NULL) {
                    //
                    //  Copy the value of the reparse point attribute to the buffer.
                    //  Return all the value including the system header fields (e.g., Tag and Length)
                    //  stored at the beginning of the value of the reparse point attribute.
                    //

                    pRpBuffer = (PREPARSE_DATA_BUFFER) rpOutputBuffer;
                    pRpBuffer->ReparseTag = IO_REPARSE_TAG_HSM;
                    pRpBuffer->ReparseDataLength = sizeof(RP_DATA);
                    pRpBuffer->Reserved = 0;

                    RtlCopyMemory( rpOutputBuffer + REPARSE_DATA_BUFFER_HEADER_SIZE,
                                   pRpData,
                                   sizeof(RP_DATA));

                    //
                    // Now fake out the bit to say it is pre-migrated (not truncated)
                    //
                    tmpRp = (PRP_DATA) (rpOutputBuffer + REPARSE_DATA_BUFFER_HEADER_SIZE);
                    tmpRp->data.bitFlags &= ~RP_FLAG_TRUNCATED;
                    RP_GEN_QUALIFIER(tmpRp, tmpRp->qualifier)
                    status = STATUS_SUCCESS;
                }

                Irp->IoStatus.Status = status;
                if (NT_SUCCESS(status)) {
                    if (OutputBufferLength <= sizeof(RP_DATA) + REPARSE_DATA_BUFFER_HEADER_SIZE) {
                        Irp->IoStatus.Information = OutputBufferLength;
                    } else {
                        Irp->IoStatus.Information = sizeof(RP_DATA) + REPARSE_DATA_BUFFER_HEADER_SIZE;
                    }
		} else {
                    Irp->IoStatus.Information = 0;
                }

                IoCompleteRequest (Irp, IO_NO_INCREMENT) ;
                return(status);
            }
            break;
        }

        case FSCTL_REQUEST_OPLOCK_LEVEL_1:
        case FSCTL_REQUEST_OPLOCK_LEVEL_2:
        case FSCTL_REQUEST_BATCH_OPLOCK:
        case FSCTL_REQUEST_FILTER_OPLOCK: {
            if ((RsIsFileObj(irpSp->FileObject, TRUE, &pRpData, NULL, NULL, NULL, NULL, NULL, NULL, NULL) == TRUE) &&  RP_FILE_IS_TRUNCATED(pRpData->data.bitFlags))  {
                //
                // Fail oplocks on any file that is in the file object list.
                // This is to prevent a deadlock problem that was seen with Content Indexing where
                // they open for read_attribute access (thus not recalling) and setting an oplock
                // then opening for recall.  The recall causes an oplock break and CI cannot process
                // it because the thread is tied up waiting for the recall.
                //
                DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Failing oplock for truncated file opened with non-data access.\n"));

		status = STATUS_OPLOCK_NOT_GRANTED;
                Irp->IoStatus.Status = status;
                Irp->IoStatus.Information = 0;
                IoCompleteRequest (Irp, IO_NO_INCREMENT) ;
                return(status) ;
            }
            break;
        }

        case FSCTL_SET_REPARSE_POINT: {
            //
            // First see if it if our tag.  If not let it pass, otherwise...
            //  If it is us setting it then let it go.
            //  If it is someone else (backup) then we need to note it so we can do a validate job at some point.
            //  If the file is being truncated and it has a filter context (for any file object) then we
            //  need to touch up some of the entries in the context entry to make sure the state is correct.
            //
            InputBufferLength  = irpSp->Parameters.FileSystemControl.InputBufferLength;
            //
            // There had better be a buffer at least large enough for the reparse point tag and length
            //
            if ((Irp->AssociatedIrp.SystemBuffer != NULL) &&
                 (InputBufferLength >= (REPARSE_DATA_BUFFER_HEADER_SIZE + sizeof(RP_DATA)))) {

                pRpBuffer = (PREPARSE_DATA_BUFFER)Irp->AssociatedIrp.SystemBuffer;
                if ((pRpBuffer->ReparseTag == IO_REPARSE_TAG_HSM) &&
                    (pRpBuffer->ReparseDataLength >= sizeof(RP_DATA))) {

                    // 
                    // It's our tag. Does the caller have sufficient priviledges to play with it?
                    //
                    LUID restorePriviledge = RtlConvertLongToLuid (SE_RESTORE_PRIVILEGE);

                    if (!RsEnableLegacyAccessMethod &&
                        !SeSinglePrivilegeCheck (restorePriviledge, Irp->RequestorMode)) {
                        // 
                        // Caller is required to have
                        // SE_RESTORE_PRIVILEGE but they do NOT, so
                        //
                        status = STATUS_ACCESS_DENIED;
                        Irp->IoStatus.Status      = status;
                        Irp->IoStatus.Information = 0;
                        IoCompleteRequest (Irp, IO_NO_INCREMENT);
                        return (status);
                    }

                    //
                    // It is our tag - now see if we set it or someone else did.
                    //
                    tmpRp = (PRP_DATA) &pRpBuffer->GenericReparseBuffer.DataBuffer[0];
                    if (RP_IS_ENGINE_ORIGINATED(tmpRp->data.bitFlags)) {
                        RP_CLEAR_ORIGINATOR_BIT(tmpRp->data.bitFlags);
                        //
                        // See if it is getting truncated
                        //
                        if (RP_FILE_IS_TRUNCATED(tmpRp->data.bitFlags)) {
                            PRP_FILTER_CONTEXT      filterContext;
                            PRP_FILE_OBJ            entry;
                            PRP_FILE_CONTEXT        context;

                            filterContext = (PRP_FILTER_CONTEXT) FsRtlLookupPerStreamContext (FsRtlGetPerStreamContextPointer (irpSp->FileObject),  
                                                                                              FsDeviceObject,
                                                                                              irpSp->FileObject);

                            if (filterContext != NULL) {
                                entry = (PRP_FILE_OBJ) filterContext->myFileObjEntry;
                                context = entry->fsContext;
                                RsAcquireFileContextEntryLockExclusive(context);
                                context->state = RP_RECALL_NOT_RECALLED;
                                context->recallStatus = 0;
                                context->currentOffset.QuadPart = 0;
                                memcpy(&context->rpData, tmpRp, sizeof(RP_DATA));
                                KeClearEvent(&context->recallCompletedEvent);
                                RsReleaseFileContextEntryLock(context);
                            }
                        }
                    } else {
                        //
                        // It must be backup or someone else.  We need to flag the event so that the
                        // engine can clean things up later with a validate job.
                        //
                        //
                        // Get the serial number from the file object or the device object
                        // in the file object or the device object passed in.
                        // If it is not in any of these places we have a problem.
                        //
                        DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Set of Reparse Point by non-HSM program.\n"));

                        if ((irpSp->FileObject != 0) && (irpSp->FileObject->Vpb != 0)) {
                            RemainingBytes = irpSp->FileObject->Vpb->SerialNumber;
                        } else if ((irpSp->DeviceObject != 0) && (irpSp->FileObject->DeviceObject->Vpb != 0)) {
                            RemainingBytes = irpSp->FileObject->DeviceObject->Vpb->SerialNumber;
                        } else if (DeviceObject->Vpb != 0) {
                            RemainingBytes = DeviceObject->Vpb->SerialNumber;
                        } else {
                            //
                            // ERROR - no volume serial number - We cannot log which volume
                            // needs a validate.  Let it go but log an event.
                            //
                            RemainingBytes = 0;
                            RsLogError(__LINE__, AV_MODULE_RPFILTER, 0, AV_MSG_SERIAL, NULL, NULL);
                        }
                        if (RemainingBytes != 0) {
                            //
                            // Set the registry entry or let the Fsa know a validate is needed
                            //
                            RsLogValidateNeeded(RemainingBytes);
                        }
                    }
                }
            }
            break;
        }

        case FSCTL_RECALL_FILE: {
            //
            // Forces explicit recall of file
            // This will be honored only if the file is opened for write access
            // *and* it is not opened for NO_RECALL
            //
            status = RsFsctlRecallFile(irpSp->FileObject);
            Irp->IoStatus.Status = status;
            Irp->IoStatus.Information = 0;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return status;
        }

        default: {
            break;
        }
    } // End of the switch


    //
    // Just get out of the way
    //
    IoSkipCurrentIrpStackLocation(Irp);

    status = IoCallDriver( deviceExtension->FileSystemDeviceObject, Irp );


    DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: FsCtl handler exit 0x%08X\n", status));

    return (status);
}



PVOID
RsMapUserBuffer (
                IN OUT PIRP Irp
                )

/*++

Routine Description:

    This routine conditionally maps the user buffer for the current I/O
    request in the specified mode.  If the buffer is already mapped, it
    just returns its address.

Arguments:

    Irp - Pointer to the Irp for the request.

Return Value:

    Mapped address

--*/

{
   PVOID SystemBuffer;

   PAGED_CODE();

   //
   // If there is no Mdl, then we must be in the Fsd, and we can simply
   // return the UserBuffer field from the Irp.
   //

   if (Irp->MdlAddress == NULL) {

      return Irp->UserBuffer;

   } else {

      //
      //  MM can return NULL if there are no system ptes.
      //

      SystemBuffer = MmGetSystemAddressForMdlSafe( Irp->MdlAddress,
                                                   NormalPagePriority );

      return SystemBuffer;
   }
}


DBGSTATIC
VOID
RsFsNotification(
                IN PDEVICE_OBJECT DeviceObject,
                IN BOOLEAN FsActive
                )

/*++

Routine Description:

    This routine is invoked whenever a file system has either registered or
    unregistered itself as an active file system.

    For the former case, this routine creates a device object and attaches it
    to the specified file system's device object.  This allows this driver
    to filter all requests to that file system.

    For the latter case, this file system's device object is located,
    detached, and deleted.  This removes this file system as a filter for
    the specified file system.

Arguments:

    DeviceObject - Pointer to the file system's device object.

    FsActive - Boolean indicating whether the file system has registered
        (TRUE) or unregistered (FALSE) itself as an active file system.

Return Value:

    None.

--*/

{
   NTSTATUS                    status;
   PDEVICE_OBJECT              deviceObject;
   PDEVICE_OBJECT              nextAttachedDevice;
   PDEVICE_OBJECT              fsDevice;
   PDEVICE_OBJECT              ntfsDevice;
   UNICODE_STRING              ntfsName;
   POBJECT_NAME_INFORMATION    nameInfo;
   CHAR                        buff[64 + sizeof(OBJECT_NAME_INFORMATION)];
   ULONG                       size;
   PFILE_OBJECT                fileObject;

   PAGED_CODE();

   DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Enter Fs Notification\n"));
   //
   // Begin by determine whether or not the file system is a disk-based file
   // system.  If not, then this driver is not concerned with it.
   //

   if (DeviceObject->DeviceType != FILE_DEVICE_DISK_FILE_SYSTEM) {
      return;
   }


   //
   // Find the Ntfs device object (if there) and see if the passed in device object is the same.
   // If it is we may be loading after boot time and may not be the top level driver.
   // If this is the case the name may we get from ObQueryNameString may not be NTFS but we will
   // attach anyway and hope it works.  We will log a warning so we know this happened.
   //


   RtlInitUnicodeString( &ntfsName, (PWCHAR) L"\\Ntfs" );
   status = IoGetDeviceObjectPointer(
                                    &ntfsName,
                                    FILE_READ_ATTRIBUTES,
                                    &fileObject,
                                    &ntfsDevice
                                    );

   if (NT_SUCCESS( status )) {
      ObDereferenceObject( fileObject );
   } else {
      ntfsDevice = NULL;
   }

   //
   // If it is not the NTFS file system we do not care about it either
   //

   nameInfo = (POBJECT_NAME_INFORMATION) buff;
   status = ObQueryNameString(
                             DeviceObject->DriverObject,
                             nameInfo,
                             64,
                             &size
                             );


   if (NT_SUCCESS(status)) {
      DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Checking %ws\n", nameInfo->Name.Buffer));

      RtlInitUnicodeString(&ntfsName, (PWCHAR) RP_NTFS_NAME);

      if (0 != RtlCompareUnicodeString(&nameInfo->Name,
                                       &ntfsName, TRUE)) {
         //
         // The name did not match - see if the device object matches
         //
         if (DeviceObject == ntfsDevice) {
            //
            // The name does not match but the deivce is NTFS.
            // We will go ahrad and attach but we will log an event so we know what
            // happened.
            RsLogError(__LINE__, AV_MODULE_RPFILTER, 0,
                       AV_MSG_REGISTER_WARNING, NULL, NULL);

         } else {
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Skipping %ws\n", nameInfo->Name.Buffer));
            return;
         }
      }
   } else {
      DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Failed to get driver name\n"));
      RsLogError(__LINE__, AV_MODULE_RPFILTER, status,
                 AV_MSG_REGISTER_ERROR, NULL, NULL);

      /* Assume it it not NTFS ! */
      return;
   }

   //
   // Begin by determining whether this file system is registering or
   // unregistering as an active file system.
   //

   if (FsActive) {

      PDEVICE_EXTENSION deviceExtension;


      DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Attach to %ws\n", nameInfo->Name.Buffer));
      //
      // The file system has registered as an active file system.  If it is
      // a disk-based file system attach to it.
      //

      FsRtlEnterFileSystem();
      ExAcquireResourceExclusiveLite( &FsLock, TRUE );
      status = IoCreateDevice(
                             FsDriverObject,
                             sizeof( DEVICE_EXTENSION ),
                             (PUNICODE_STRING) NULL,
                             FILE_DEVICE_DISK_FILE_SYSTEM,
                             0,
                             FALSE,
                             &deviceObject
                             );
      if (NT_SUCCESS( status )) {
         deviceExtension = deviceObject->DeviceExtension;
         fsDevice = deviceExtension->FileSystemDeviceObject  =
                    IoAttachDeviceToDeviceStack(deviceObject, DeviceObject);

         if (NULL == fsDevice) {
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Error attaching to the device (%x) (Flags = %x)",
                                  status, DeviceObject->Flags));
            if (DeviceObject->Flags & DO_DEVICE_INITIALIZING) {
               //
               // Some filter drivers accidentally or intentionally leave the DO_DEVICE_INITIALIZING
               // flag set.  This prevents any other filters from attaching.  We log a
               // special error here to alert technical support that this has happened.
               // The only thing that can be done is to find out what driver is the offender and
               // adjust the load order to get us in first.  The author of the offending driver
               // should be contacted and informed of the error and urged to correct it.  Any
               // dependancy of the offending driver may have of loading before HSM cannot be
               // satisfied in this case and the user would have to choose between HSM and the
               // other application.
               //
               RsLogError(__LINE__, AV_MODULE_RPFILTER, status,
                          AV_MSG_ATTACH_INIT_ERROR, NULL, NULL);
            } else {
               RsLogError(__LINE__, AV_MODULE_RPFILTER, status,
                          AV_MSG_ATTACH_ERROR, NULL, NULL);
            }
            IoDeleteDevice( deviceObject );
         } else {
            deviceExtension->Type                        = RSFILTER_DEVICE_TYPE;
            deviceExtension->Size                        = sizeof( DEVICE_EXTENSION );
            deviceExtension->Attached                    = TRUE;
	    deviceExtension->AttachedToNtfsControlDevice = TRUE;
	    deviceExtension->WriteStatus                 = RsVolumeStatusUnknown;

            deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
         }
      } else {
         DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Error creating a device object (%x)", status));
         RsLogError(__LINE__, AV_MODULE_RPFILTER, status,
                    AV_MSG_REGISTER_ERROR, NULL, NULL);
      }
      ExReleaseResourceLite( &FsLock );
      FsRtlExitFileSystem();
   } else {

      //
      // Search the linked list of drivers attached to this device and check
      // to see whether this driver is attached to it.  If so, remove it.
      //

      DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Detach from %ws\n", nameInfo->Name.Buffer));

      if (nextAttachedDevice = DeviceObject->AttachedDevice) {

         PDEVICE_EXTENSION deviceExtension;

         //
         // This registered file system has someone attached to it.  Scan
         // until this driver's device object is found and detach it.
         //

         FsRtlEnterFileSystem();
         ExAcquireResourceSharedLite( &FsLock, TRUE );

         while (nextAttachedDevice) {
            deviceExtension = nextAttachedDevice->DeviceExtension;
            if (deviceExtension->Type == RSFILTER_DEVICE_TYPE &&
                deviceExtension->Size == sizeof( DEVICE_EXTENSION )) {

               //
               // A device object that may belong to this driver has been
               // located.  Scan the list of device objects owned by this
               // driver to see whether or not is actually belongs to this
               // driver.
               //

               fsDevice = FsDriverObject->DeviceObject;
               while (fsDevice) {
                  if (fsDevice == nextAttachedDevice) {
                     IoDetachDevice( DeviceObject );
                     deviceExtension = fsDevice->DeviceExtension;
                     deviceExtension->Attached = FALSE;

                     if (!fsDevice->AttachedDevice) {
                        IoDeleteDevice( fsDevice );
                     }
                     // **** What to do if still attached?
                     ExReleaseResourceLite( &FsLock );
                     FsRtlExitFileSystem();
                     return;
                  }
                  fsDevice = fsDevice->NextDevice;
               }

            }


            DeviceObject = nextAttachedDevice;
            nextAttachedDevice = nextAttachedDevice->AttachedDevice;
         }
         ExReleaseResourceLite( &FsLock );
         FsRtlExitFileSystem();
      }
   }

   DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Exit Fs notification\n"));
   return;
}


DBGSTATIC
BOOLEAN
RsFastIoCheckIfPossible(
                       IN PFILE_OBJECT FileObject,
                       IN PLARGE_INTEGER FileOffset,
                       IN ULONG Length,
                       IN BOOLEAN Wait,
                       IN ULONG LockKey,
                       IN BOOLEAN CheckForReadOperation,
                       OUT PIO_STATUS_BLOCK IoStatus,
                       IN PDEVICE_OBJECT DeviceObject
                       )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for checking to see
    whether fast I/O is possible for this file.

    This function simply invokes the file system's cooresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be operated on.

    FileOffset - Byte offset in the file for the operation.

    Length - Length of the operation to be performed.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    LockKey - Provides the caller's key for file locks.

    CheckForReadOperation - Indicates whether the caller is checking for a
        read (TRUE) or a write operation.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
   PDEVICE_OBJECT      deviceObject;
   PFAST_IO_DISPATCH   fastIoDispatch;


   PAGED_CODE();

   DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Enter fast Io check\n"));

   //
   // Do not allow fast io on files opened with no-recall option
   //
   if (RsIsFastIoPossible(FileObject) == TRUE) {
      deviceObject = ((PDEVICE_EXTENSION) (DeviceObject->DeviceExtension))->FileSystemDeviceObject;
      if (!deviceObject) {
         return FALSE;
      }
      fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

      if (fastIoDispatch && fastIoDispatch->FastIoCheckIfPossible) {
         DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Exit Fast IO check -= system\n"));
         return(fastIoDispatch->FastIoCheckIfPossible)(
                                                      FileObject,
                                                      FileOffset,
                                                      Length,
                                                      Wait,
                                                      LockKey,
                                                      CheckForReadOperation,
                                                      IoStatus,
                                                      deviceObject
                                                      );
      } else {
         DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Exit Fast Io check - False\n"));
         return FALSE;
      }
   } else {
      DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: No fast IO on files being recalled.\n"));
      return FALSE;
   }


}


DBGSTATIC
BOOLEAN
RsFastIoRead(
            IN PFILE_OBJECT FileObject,
            IN PLARGE_INTEGER FileOffset,
            IN ULONG Length,
            IN BOOLEAN Wait,
            IN ULONG LockKey,
            OUT PVOID Buffer,
            OUT PIO_STATUS_BLOCK IoStatus,
            IN PDEVICE_OBJECT DeviceObject
            )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for reading from a
    file.

    This function simply invokes the file system's cooresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be read.

    FileOffset - Byte offset in the file of the read.

    Length - Length of the read operation to be performed.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    LockKey - Provides the caller's key for file locks.

    Buffer - Pointer to the caller's buffer to receive the data read.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
   PDEVICE_OBJECT      deviceObject;
   PFAST_IO_DISPATCH   fastIoDispatch;
   ULONG               options = 0;


   PAGED_CODE();
   DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Fast Io Read\n"));

   //
   // Do not allow fast io on files opened with no-recall option
   //
   if (RsIsFastIoPossible(FileObject) == TRUE) {
      deviceObject = ((PDEVICE_EXTENSION) (DeviceObject->DeviceExtension))->FileSystemDeviceObject;
      if (!deviceObject) {
         return FALSE;
      }
      fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

      if (fastIoDispatch && fastIoDispatch->FastIoRead) {
         return(fastIoDispatch->FastIoRead)(
                                           FileObject,
                                           FileOffset,
                                           Length,
                                           Wait,
                                           LockKey,
                                           Buffer,
                                           IoStatus,
                                           deviceObject
                                           );
      } else {
         return FALSE;
      }
   } else {
      DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Do not allow fast IO on read-no-recall\n"));
      return FALSE;
   }

}


DBGSTATIC
BOOLEAN
RsFastIoWrite(
             IN PFILE_OBJECT FileObject,
             IN PLARGE_INTEGER FileOffset,
             IN ULONG Length,
             IN BOOLEAN Wait,
             IN ULONG LockKey,
             IN PVOID Buffer,
             OUT PIO_STATUS_BLOCK IoStatus,
             IN PDEVICE_OBJECT DeviceObject
             )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for writing to a
    file.

    This function simply invokes the file system's cooresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be written.

    FileOffset - Byte offset in the file of the write operation.

    Length - Length of the write operation to be performed.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    LockKey - Provides the caller's key for file locks.

    Buffer - Pointer to the caller's buffer that contains the data to be
        written.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
   PDEVICE_OBJECT deviceObject;
   PFAST_IO_DISPATCH fastIoDispatch;

   PAGED_CODE();

   DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Fast Io Write\n"));

   if (RsIsFastIoPossible(FileObject) == TRUE) {
      deviceObject = ((PDEVICE_EXTENSION) (DeviceObject->DeviceExtension))->FileSystemDeviceObject;
      if (!deviceObject) {
         return FALSE;
      }
      fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

      if (fastIoDispatch && fastIoDispatch->FastIoWrite) {
         return(fastIoDispatch->FastIoWrite)(
                                            FileObject,
                                            FileOffset,
                                            Length,
                                            Wait,
                                            LockKey,
                                            Buffer,
                                            IoStatus,
                                            deviceObject
                                            );
      } else {
         return FALSE;
      }
   } else {
      return FALSE;
   }


}


DBGSTATIC
BOOLEAN
RsFastIoQueryBasicInfo(
                      IN PFILE_OBJECT FileObject,
                      IN BOOLEAN Wait,
                      OUT PFILE_BASIC_INFORMATION Buffer,
                      OUT PIO_STATUS_BLOCK IoStatus,
                      IN PDEVICE_OBJECT DeviceObject
                      )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for querying basic
    information about the file.

    This function simply invokes the file system's cooresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be queried.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    Buffer - Pointer to the caller's buffer to receive the information about
        the file.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
   PDEVICE_OBJECT deviceObject;
   PFAST_IO_DISPATCH fastIoDispatch;
   BOOLEAN retval;
   ULONG openOptions;



   PAGED_CODE();

   DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Fast Io QBasic\n"));

   deviceObject = ((PDEVICE_EXTENSION) (DeviceObject->DeviceExtension))->FileSystemDeviceObject;
   if (!deviceObject) {
      return FALSE;
   }
   fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

   if (fastIoDispatch && fastIoDispatch->FastIoQueryBasicInfo) {
      retval =  (fastIoDispatch->FastIoQueryBasicInfo)(
                                                      FileObject,
                                                      Wait,
                                                      Buffer,
                                                      IoStatus,
                                                      deviceObject
                                                      );
   } else {
      return FALSE;
   }

   if (retval &&
       RsIsFileObj(FileObject, TRUE, NULL, NULL, NULL, NULL, NULL, &openOptions, NULL, NULL) &&
       RP_IS_NO_RECALL_OPTION(openOptions)) {
      //
      // This file was opened NO_RECALL, so we strip the FILE_ATTRIBUTE_OFFLINE bit
      //
      Buffer->FileAttributes &= ~FILE_ATTRIBUTE_OFFLINE;
   }

   return retval;
}


DBGSTATIC
BOOLEAN
RsFastIoQueryStandardInfo(
                         IN PFILE_OBJECT FileObject,
                         IN BOOLEAN Wait,
                         OUT PFILE_STANDARD_INFORMATION Buffer,
                         OUT PIO_STATUS_BLOCK IoStatus,
                         IN PDEVICE_OBJECT DeviceObject
                         )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for querying standard
    information about the file.

    This function simply invokes the file system's cooresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be queried.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    Buffer - Pointer to the caller's buffer to receive the information about
        the file.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
   PDEVICE_OBJECT deviceObject;
   PFAST_IO_DISPATCH fastIoDispatch;

   PAGED_CODE();

   DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Fast Io QStandard\n"));

   deviceObject = ((PDEVICE_EXTENSION) (DeviceObject->DeviceExtension))->FileSystemDeviceObject;
   if (!deviceObject) {
      return FALSE;
   }
   fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

   if (fastIoDispatch && fastIoDispatch->FastIoQueryStandardInfo) {
      return(fastIoDispatch->FastIoQueryStandardInfo)(
                                                     FileObject,
                                                     Wait,
                                                     Buffer,
                                                     IoStatus,
                                                     deviceObject
                                                     );
   } else {
      return FALSE;
   }

}


DBGSTATIC
BOOLEAN
RsFastIoLock(
            IN PFILE_OBJECT FileObject,
            IN PLARGE_INTEGER FileOffset,
            IN PLARGE_INTEGER Length,
            PEPROCESS ProcessId,
            ULONG Key,
            BOOLEAN FailImmediately,
            BOOLEAN ExclusiveLock,
            OUT PIO_STATUS_BLOCK IoStatus,
            IN PDEVICE_OBJECT DeviceObject
            )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for locking a byte
    range within a file.

    This function simply invokes the file system's cooresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be locked.

    FileOffset - Starting byte offset from the base of the file to be locked.

    Length - Length of the byte range to be locked.

    ProcessId - ID of the process requesting the file lock.

    Key - Lock key to associate with the file lock.

    FailImmediately - Indicates whether or not the lock request is to fail
        if it cannot be immediately be granted.

    ExclusiveLock - Indicates whether the lock to be taken is exclusive (TRUE)
        or shared.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
   PDEVICE_OBJECT deviceObject;
   PFAST_IO_DISPATCH fastIoDispatch;

   PAGED_CODE();

   DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Fast Io Lock\n"));

   deviceObject = ((PDEVICE_EXTENSION) (DeviceObject->DeviceExtension))->FileSystemDeviceObject;
   if (!deviceObject) {
      return FALSE;
   }
   fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

   if (fastIoDispatch && fastIoDispatch->FastIoLock) {
      return(fastIoDispatch->FastIoLock)(
                                        FileObject,
                                        FileOffset,
                                        Length,
                                        ProcessId,
                                        Key,
                                        FailImmediately,
                                        ExclusiveLock,
                                        IoStatus,
                                        deviceObject
                                        );
   } else {
      return FALSE;
   }

}


DBGSTATIC
BOOLEAN
RsFastIoUnlockSingle(
                    IN PFILE_OBJECT FileObject,
                    IN PLARGE_INTEGER FileOffset,
                    IN PLARGE_INTEGER Length,
                    PEPROCESS ProcessId,
                    ULONG Key,
                    OUT PIO_STATUS_BLOCK IoStatus,
                    IN PDEVICE_OBJECT DeviceObject
                    )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for unlocking a byte
    range within a file.

    This function simply invokes the file system's cooresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be unlocked.

    FileOffset - Starting byte offset from the base of the file to be
        unlocked.

    Length - Length of the byte range to be unlocked.

    ProcessId - ID of the process requesting the unlock operation.

    Key - Lock key associated with the file lock.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
   PDEVICE_OBJECT deviceObject;
   PFAST_IO_DISPATCH fastIoDispatch;

   PAGED_CODE();

   DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Fast Io Unlock\n"));

   deviceObject = ((PDEVICE_EXTENSION) (DeviceObject->DeviceExtension))->FileSystemDeviceObject;
   if (!deviceObject) {
      return FALSE;
   }

   fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

   if (fastIoDispatch && fastIoDispatch->FastIoUnlockSingle) {
      return(fastIoDispatch->FastIoUnlockSingle)(
                                                FileObject,
                                                FileOffset,
                                                Length,
                                                ProcessId,
                                                Key,
                                                IoStatus,
                                                deviceObject
                                                );
   } else {
      return FALSE;
   }
}


DBGSTATIC
BOOLEAN
RsFastIoUnlockAll(
                 IN PFILE_OBJECT FileObject,
                 PEPROCESS ProcessId,
                 OUT PIO_STATUS_BLOCK IoStatus,
                 IN PDEVICE_OBJECT DeviceObject
                 )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for unlocking all
    locks within a file.

    This function simply invokes the file system's cooresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be unlocked.

    ProcessId - ID of the process requesting the unlock operation.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
   PDEVICE_OBJECT deviceObject;
   PFAST_IO_DISPATCH fastIoDispatch;

   PAGED_CODE();

   DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Fast Io Unlock all\n"));

   deviceObject = ((PDEVICE_EXTENSION) (DeviceObject->DeviceExtension))->FileSystemDeviceObject;
   if (!deviceObject) {
      return FALSE;
   }
   fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

   if (fastIoDispatch && fastIoDispatch->FastIoUnlockAll) {
      return(fastIoDispatch->FastIoUnlockAll)(
                                             FileObject,
                                             ProcessId,
                                             IoStatus,
                                             deviceObject
                                             );
   } else {
      return FALSE;
   }

}


DBGSTATIC
BOOLEAN
RsFastIoUnlockAllByKey(
                      IN PFILE_OBJECT FileObject,
                      PVOID ProcessId,
                      ULONG Key,
                      OUT PIO_STATUS_BLOCK IoStatus,
                      IN PDEVICE_OBJECT DeviceObject
                      )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for unlocking all
    locks within a file based on a specified key.

    This function simply invokes the file system's cooresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be unlocked.

    ProcessId - ID of the process requesting the unlock operation.

    Key - Lock key associated with the locks on the file to be released.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
   PDEVICE_OBJECT deviceObject;
   PFAST_IO_DISPATCH fastIoDispatch;

   PAGED_CODE();

   DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Fast Io Unlock by key\n"));

   deviceObject = ((PDEVICE_EXTENSION) (DeviceObject->DeviceExtension))->FileSystemDeviceObject;
   if (!deviceObject) {
      return FALSE;
   }
   fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

   if (fastIoDispatch && fastIoDispatch->FastIoUnlockAllByKey) {
      return(fastIoDispatch->FastIoUnlockAllByKey)(
                                                  FileObject,
                                                  ProcessId,
                                                  Key,
                                                  IoStatus,
                                                  deviceObject
                                                  );
   } else {
      return FALSE;
   }

}


DBGSTATIC
BOOLEAN
RsFastIoDeviceControl(
                     IN PFILE_OBJECT FileObject,
                     IN BOOLEAN Wait,
                     IN PVOID InputBuffer OPTIONAL,
                     IN ULONG InputBufferLength,
                     OUT PVOID OutputBuffer OPTIONAL,
                     IN ULONG OutputBufferLength,
                     IN ULONG IoControlCode,
                     OUT PIO_STATUS_BLOCK IoStatus,
                     IN PDEVICE_OBJECT DeviceObject
                     )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for device I/O control
    operations on a file.

    This function simply invokes the file system's cooresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object representing the device to be
        serviced.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    InputBuffer - Optional pointer to a buffer to be passed into the driver.

    InputBufferLength - Length of the optional InputBuffer, if one was
        specified.

    OutputBuffer - Optional pointer to a buffer to receive data from the
        driver.

    OutputBufferLength - Length of the optional OutputBuffer, if one was
        specified.

    IoControlCode - I/O control code indicating the operation to be performed
        on the device.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
   PDEVICE_OBJECT deviceObject;
   PFAST_IO_DISPATCH fastIoDispatch;

   PAGED_CODE();

   DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Fast Io Ioctl\n"));

   deviceObject = ((PDEVICE_EXTENSION) (DeviceObject->DeviceExtension))->FileSystemDeviceObject;
   if (!deviceObject) {
      return FALSE;
   }
   fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

   if (fastIoDispatch && fastIoDispatch->FastIoDeviceControl) {
      return(fastIoDispatch->FastIoDeviceControl)(
                                                 FileObject,
                                                 Wait,
                                                 InputBuffer,
                                                 InputBufferLength,
                                                 OutputBuffer,
                                                 OutputBufferLength,
                                                 IoControlCode,
                                                 IoStatus,
                                                 deviceObject
                                                 );
   } else {
      return FALSE;
   }

}



DBGSTATIC
VOID
RsFastIoDetachDevice(
                    IN PDEVICE_OBJECT SourceDevice,
                    IN PDEVICE_OBJECT TargetDevice
                    )

/*++

Routine Description:

    This routine is invoked on the fast path to detach from a device that
    is being deleted.  This occurs when this driver has attached to a file
    system volume device object, and then, for some reason, the file system
    decides to delete that device (it is being dismounted, it was dismounted
    at some point in the past and its last reference has just gone away, etc.)

Arguments:

    SourceDevice - Pointer to this driver's device object, which is attached
        to the file system's volume device object.

    TargetDevice - Pointer to the file system's volume device object.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
   PAGED_CODE();

   //
   // Simply acquire the database lock for exclusive access, and detach from
   // the file system's volume device object.
   //

   DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Fast Io Detach device\n"));

   FsRtlEnterFileSystem();
   ExAcquireResourceExclusiveLite( &FsLock, TRUE );
   IoDetachDevice( TargetDevice );
   IoDeleteDevice( SourceDevice );
   ExReleaseResourceLite( &FsLock );
   FsRtlExitFileSystem();
}

/* New Fast Io routines for NT 4.x */

DBGSTATIC
BOOLEAN
RsFastIoQueryNetworkOpenInfo(
                            IN PFILE_OBJECT FileObject,
                            IN BOOLEAN Wait,
                            OUT PFILE_NETWORK_OPEN_INFORMATION Buffer,
                            OUT PIO_STATUS_BLOCK IoStatus,
                            IN PDEVICE_OBJECT DeviceObject
                            )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for querying network
    information about a file.

    This function simply invokes the file system's cooresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be queried.

    Wait - Indicates whether or not the caller can handle the file system
        having to wait and tie up the current thread.

    Buffer - Pointer to a buffer to receive the network information about the
        file.

    IoStatus - Pointer to a variable to receive the final status of the query
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
   PDEVICE_OBJECT deviceObject;
   PFAST_IO_DISPATCH fastIoDispatch;

   PAGED_CODE();

   DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Fast Io QNetOpen\n"));

   deviceObject = ((PDEVICE_EXTENSION) (DeviceObject->DeviceExtension))->FileSystemDeviceObject;
   if (!deviceObject) {
      return FALSE;
   }
   fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

   if (fastIoDispatch && fastIoDispatch->FastIoQueryNetworkOpenInfo) {
      return(fastIoDispatch->FastIoQueryNetworkOpenInfo)(
                                                        FileObject,
                                                        Wait,
                                                        Buffer,
                                                        IoStatus,
                                                        deviceObject
                                                        );
   } else {
      return FALSE;
   }

}


DBGSTATIC
NTSTATUS
RsFastIoAcquireForModWrite(
                          IN PFILE_OBJECT FileObject,
                          IN PLARGE_INTEGER EndingOffset,
                          OUT PERESOURCE *ResourceToRelease,
                          IN PDEVICE_OBJECT DeviceObject
                          )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for acquiring the
    file resource prior to attempting a modified write operation.

    This function simply invokes the file system's cooresponding routine, or
    returns an error if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object whose resource is to be acquired.

    EndingOffset - The offset to the last byte being written plus one.

    ResourceToRelease - Pointer to a variable to return the resource to release.
        Not defined if an error is returned.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is either success or failure based on whether or not
    fast I/O is possible for this file.

--*/

{
   PDEVICE_OBJECT deviceObject;
   PFAST_IO_DISPATCH fastIoDispatch;

   PAGED_CODE();

   DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Fast Io Acquire Mod Write\n"));

   deviceObject = ((PDEVICE_EXTENSION) (DeviceObject->DeviceExtension))->FileSystemDeviceObject;
   if (!deviceObject) {
      return FALSE;
   }
   fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

   if (fastIoDispatch && fastIoDispatch->AcquireForModWrite) {
      return(fastIoDispatch->AcquireForModWrite)(
                                                FileObject,
                                                EndingOffset,
                                                ResourceToRelease,
                                                DeviceObject
                                                );
   } else {
      return STATUS_NOT_IMPLEMENTED;
   }
}


DBGSTATIC
BOOLEAN
RsFastIoMdlRead(
               IN PFILE_OBJECT FileObject,
               IN PLARGE_INTEGER FileOffset,
               IN ULONG Length,
               IN ULONG LockKey,
               OUT PMDL *MdlChain,
               OUT PIO_STATUS_BLOCK IoStatus,
               IN PDEVICE_OBJECT DeviceObject
               )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for reading a file
    using MDLs as buffers.

    This function simply invokes the file system's cooresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object that is to be read.

    FileOffset - Supplies the offset into the file to begin the read operation.

    Length - Specifies the number of bytes to be read from the file.

    LockKey - The key to be used in byte range lock checks.

    MdlChain - A pointer to a variable to be filled in w/a pointer to the MDL
        chain built to describe the data read.

    IoStatus - Variable to receive the final status of the read operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
   PDEVICE_OBJECT deviceObject;
   PFAST_IO_DISPATCH fastIoDispatch;

   PAGED_CODE();

   DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Fast Io Mdl Read\n"));

   if (RsIsFastIoPossible(FileObject) != TRUE) {
      return FALSE;
   }

   deviceObject = ((PDEVICE_EXTENSION) (DeviceObject->DeviceExtension))->FileSystemDeviceObject;
   if (!deviceObject) {
      return FALSE;
   }

   fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

   if (fastIoDispatch && fastIoDispatch->MdlRead) {
      return(fastIoDispatch->MdlRead)(
                                     FileObject,
                                     FileOffset,
                                     Length,
                                     LockKey,
                                     MdlChain,
                                     IoStatus,
                                     deviceObject
                                     );
   } else {
      return FALSE;
   }

}


DBGSTATIC
BOOLEAN
RsFastIoMdlReadComplete(
                       IN PFILE_OBJECT FileObject,
                       IN PMDL MdlChain,
                       IN PDEVICE_OBJECT DeviceObject
                       )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for completing an
    MDL read operation.

    This function simply invokes the file system's cooresponding routine, if
    it has one.  It should be the case that this routine is invoked only if
    the MdlRead function is supported by the underlying file system, and
    therefore this function will also be supported, but this is not assumed
    by this driver.

Arguments:

    FileObject - Pointer to the file object to complete the MDL read upon.

    MdlChain - Pointer to the MDL chain used to perform the read operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE, depending on whether or not it is
    possible to invoke this function on the fast I/O path.

--*/

{
   PDEVICE_OBJECT deviceObject;
   PFAST_IO_DISPATCH fastIoDispatch;

   DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Fast Io Mdl Read Complete\n"));

   deviceObject = ((PDEVICE_EXTENSION) (DeviceObject->DeviceExtension))->FileSystemDeviceObject;
   if (!deviceObject) {
      return FALSE;
   }
   fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

   if (fastIoDispatch && fastIoDispatch->MdlReadComplete) {
      return(fastIoDispatch->MdlReadComplete)(
                                             FileObject,
                                             MdlChain,
                                             deviceObject
                                             );
   }

   return FALSE;
}


DBGSTATIC
BOOLEAN
RsFastIoPrepareMdlWrite(
                       IN PFILE_OBJECT FileObject,
                       IN PLARGE_INTEGER FileOffset,
                       IN ULONG Length,
                       IN ULONG LockKey,
                       OUT PMDL *MdlChain,
                       OUT PIO_STATUS_BLOCK IoStatus,
                       IN PDEVICE_OBJECT DeviceObject
                       )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for preparing for an
    MDL write operation.

    This function simply invokes the file system's cooresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object that will be written.

    FileOffset - Supplies the offset into the file to begin the write operation.

    Length - Specifies the number of bytes to be write to the file.

    LockKey - The key to be used in byte range lock checks.

    MdlChain - A pointer to a variable to be filled in w/a pointer to the MDL
        chain built to describe the data written.

    IoStatus - Variable to receive the final status of the write operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
   PDEVICE_OBJECT deviceObject;
   PFAST_IO_DISPATCH fastIoDispatch;

   PAGED_CODE();

   DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Fast Io Prep Mdl Write\n"));

   if (RsIsFastIoPossible(FileObject) != TRUE) {
      return FALSE;
   }

   deviceObject = ((PDEVICE_EXTENSION) (DeviceObject->DeviceExtension))->FileSystemDeviceObject;
   if (!deviceObject) {
      return FALSE;
   }

   fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

   if (fastIoDispatch && fastIoDispatch->PrepareMdlWrite) {
      return(fastIoDispatch->PrepareMdlWrite)(
                                             FileObject,
                                             FileOffset,
                                             Length,
                                             LockKey,
                                             MdlChain,
                                             IoStatus,
                                             deviceObject
                                             );
   } else {
      return FALSE;
   }

}


DBGSTATIC
BOOLEAN
RsFastIoMdlWriteComplete(
                        IN PFILE_OBJECT FileObject,
                        IN PLARGE_INTEGER FileOffset,
                        IN PMDL MdlChain,
                        IN PDEVICE_OBJECT DeviceObject
                        )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for completing an
    MDL write operation.

    This function simply invokes the file system's cooresponding routine, if
    it has one.  It should be the case that this routine is invoked only if
    the PrepareMdlWrite function is supported by the underlying file system,
    and therefore this function will also be supported, but this is not
    assumed by this driver.

Arguments:

    FileObject - Pointer to the file object to complete the MDL write upon.

    FileOffset - Supplies the file offset at which the write took place.

    MdlChain - Pointer to the MDL chain used to perform the write operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE, depending on whether or not it is
    possible to invoke this function on the fast I/O path.

--*/

{
   PDEVICE_OBJECT deviceObject;
   PFAST_IO_DISPATCH fastIoDispatch;

   PAGED_CODE();

   DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Fast Io Mdl Write Complete\n"));

   deviceObject = ((PDEVICE_EXTENSION) (DeviceObject->DeviceExtension))->FileSystemDeviceObject;
   if (!deviceObject) {
      return FALSE;
   }
   fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

   if (fastIoDispatch && fastIoDispatch->MdlWriteComplete) {
      return(fastIoDispatch->MdlWriteComplete)(
                                              FileObject,
                                              FileOffset,
                                              MdlChain,
                                              deviceObject
                                              );
   }

   return FALSE;
}


DBGSTATIC
BOOLEAN
RsFastIoReadCompressed(
                      IN PFILE_OBJECT FileObject,
                      IN PLARGE_INTEGER FileOffset,
                      IN ULONG Length,
                      IN ULONG LockKey,
                      OUT PVOID Buffer,
                      OUT PMDL *MdlChain,
                      OUT PIO_STATUS_BLOCK IoStatus,
                      OUT struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
                      IN ULONG CompressedDataInfoLength,
                      IN PDEVICE_OBJECT DeviceObject
                      )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for reading compressed
    data from a file.

    This function simply invokes the file system's cooresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object that will be read.

    FileOffset - Supplies the offset into the file to begin the read operation.

    Length - Specifies the number of bytes to be read from the file.

    LockKey - The key to be used in byte range lock checks.

    Buffer - Pointer to a buffer to receive the compressed data read.

    MdlChain - A pointer to a variable to be filled in w/a pointer to the MDL
        chain built to describe the data read.

    IoStatus - Variable to receive the final status of the read operation.

    CompressedDataInfo - A buffer to receive the description of the compressed
        data.

    CompressedDataInfoLength - Specifies the size of the buffer described by
        the CompressedDataInfo parameter.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
   PDEVICE_OBJECT deviceObject;
   PFAST_IO_DISPATCH fastIoDispatch;

   PAGED_CODE();

   DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Fast Io Read Compressed\n"));

   if (RsIsFastIoPossible(FileObject) != TRUE) {
      return FALSE;
   }

   deviceObject = ((PDEVICE_EXTENSION) (DeviceObject->DeviceExtension))->FileSystemDeviceObject;
   if (!deviceObject) {
      return FALSE;
   }
   fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

   if (fastIoDispatch && fastIoDispatch->FastIoReadCompressed) {
      return(fastIoDispatch->FastIoReadCompressed)(
                                                  FileObject,
                                                  FileOffset,
                                                  Length,
                                                  LockKey,
                                                  Buffer,
                                                  MdlChain,
                                                  IoStatus,
                                                  CompressedDataInfo,
                                                  CompressedDataInfoLength,
                                                  deviceObject
                                                  );
   } else {
      return FALSE;
   }

}


DBGSTATIC
BOOLEAN
RsFastIoWriteCompressed(
                       IN PFILE_OBJECT FileObject,
                       IN PLARGE_INTEGER FileOffset,
                       IN ULONG Length,
                       IN ULONG LockKey,
                       IN PVOID Buffer,
                       OUT PMDL *MdlChain,
                       OUT PIO_STATUS_BLOCK IoStatus,
                       IN struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
                       IN ULONG CompressedDataInfoLength,
                       IN PDEVICE_OBJECT DeviceObject
                       )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for writing compressed
    data to a file.

    This function simply invokes the file system's cooresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object that will be written.

    FileOffset - Supplies the offset into the file to begin the write operation.

    Length - Specifies the number of bytes to be write to the file.

    LockKey - The key to be used in byte range lock checks.

    Buffer - Pointer to the buffer containing the data to be written.

    MdlChain - A pointer to a variable to be filled in w/a pointer to the MDL
        chain built to describe the data written.

    IoStatus - Variable to receive the final status of the write operation.

    CompressedDataInfo - A buffer to containing the description of the
        compressed data.

    CompressedDataInfoLength - Specifies the size of the buffer described by
        the CompressedDataInfo parameter.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
   PDEVICE_OBJECT deviceObject;
   PFAST_IO_DISPATCH fastIoDispatch;

   PAGED_CODE();

   DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Fast Io Write Compressed\n"));

   if (RsIsFastIoPossible(FileObject) != TRUE) {
      return FALSE;
   }

   deviceObject = ((PDEVICE_EXTENSION) (DeviceObject->DeviceExtension))->FileSystemDeviceObject;
   if (!deviceObject) {
      return FALSE;
   }

   fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

   if (fastIoDispatch && fastIoDispatch->FastIoWriteCompressed) {
      return(fastIoDispatch->FastIoWriteCompressed)(
                                                   FileObject,
                                                   FileOffset,
                                                   Length,
                                                   LockKey,
                                                   Buffer,
                                                   MdlChain,
                                                   IoStatus,
                                                   CompressedDataInfo,
                                                   CompressedDataInfoLength,
                                                   deviceObject
                                                   );
   } else {
      return FALSE;
   }

}


DBGSTATIC
BOOLEAN
RsFastIoMdlReadCompleteCompressed(
                                 IN PFILE_OBJECT FileObject,
                                 IN PMDL MdlChain,
                                 IN PDEVICE_OBJECT DeviceObject
                                 )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for completing an
    MDL read compressed operation.

    This function simply invokes the file system's cooresponding routine, if
    it has one.  It should be the case that this routine is invoked only if
    the read compressed function is supported by the underlying file system,
    and therefore this function will also be supported, but this is not assumed
    by this driver.

Arguments:

    FileObject - Pointer to the file object to complete the compressed read
        upon.

    MdlChain - Pointer to the MDL chain used to perform the read operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE, depending on whether or not it is
    possible to invoke this function on the fast I/O path.

--*/

{
   PDEVICE_OBJECT deviceObject;
   PFAST_IO_DISPATCH fastIoDispatch;


   DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Fast Io Read Compressed complete\n"));

   deviceObject = ((PDEVICE_EXTENSION) (DeviceObject->DeviceExtension))->FileSystemDeviceObject;
   if (!deviceObject) {
      return FALSE;
   }
   fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

   if (fastIoDispatch && fastIoDispatch->MdlReadCompleteCompressed) {
      return(fastIoDispatch->MdlReadCompleteCompressed)(
                                                       FileObject,
                                                       MdlChain,
                                                       deviceObject
                                                       );
   }

   return FALSE;
}


DBGSTATIC
BOOLEAN
RsFastIoMdlWriteCompleteCompressed(
                                  IN PFILE_OBJECT FileObject,
                                  IN PLARGE_INTEGER FileOffset,
                                  IN PMDL MdlChain,
                                  IN PDEVICE_OBJECT DeviceObject
                                  )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for completing a
    write compressed operation.

    This function simply invokes the file system's cooresponding routine, if
    it has one.  It should be the case that this routine is invoked only if
    the write compressed function is supported by the underlying file system,
    and therefore this function will also be supported, but this is not assumed
    by this driver.

Arguments:

    FileObject - Pointer to the file object to complete the compressed write
        upon.

    FileOffset - Supplies the file offset at which the file write operation
        began.

    MdlChain - Pointer to the MDL chain used to perform the write operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE, depending on whether or not it is
    possible to invoke this function on the fast I/O path.

--*/

{
   PDEVICE_OBJECT deviceObject;
   PFAST_IO_DISPATCH fastIoDispatch;

   DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Fast Io Write Compressed complete\n"));

   deviceObject = ((PDEVICE_EXTENSION) (DeviceObject->DeviceExtension))->FileSystemDeviceObject;
   if (!deviceObject) {
      return FALSE;
   }
   fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

   if (fastIoDispatch && fastIoDispatch->MdlWriteCompleteCompressed) {
      return(fastIoDispatch->MdlWriteCompleteCompressed)(
                                                        FileObject,
                                                        FileOffset,
                                                        MdlChain,
                                                        deviceObject
                                                        );
   }

   return FALSE;
}


DBGSTATIC
BOOLEAN
RsFastIoQueryOpen(
                 IN PIRP Irp,
                 OUT PFILE_NETWORK_OPEN_INFORMATION NetworkInformation,
                 IN PDEVICE_OBJECT DeviceObject
                 )

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for opening a file
    and returning network information it.

    This function simply invokes the file system's cooresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    Irp - Pointer to a create IRP that represents this open operation.  It is
        to be used by the file system for common open/create code, but not
        actually completed.

    NetworkInformation - A buffer to receive the information required by the
        network about the file being opened.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

{
   PDEVICE_OBJECT deviceObject;
   PFAST_IO_DISPATCH fastIoDispatch;
   BOOLEAN result;

   PAGED_CODE();

   DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Fast Io Q Open\n"));

   deviceObject = ((PDEVICE_EXTENSION) (DeviceObject->DeviceExtension))->FileSystemDeviceObject;
   if (!deviceObject) {
      return FALSE;
   }
   fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

   if (fastIoDispatch && fastIoDispatch->FastIoQueryOpen) {
      PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation( Irp );

      irpSp->DeviceObject = deviceObject;

      result = (fastIoDispatch->FastIoQueryOpen)(
                                                Irp,
                                                NetworkInformation,
                                                deviceObject
                                                );
      if (!result) {
         irpSp->DeviceObject = DeviceObject;
      }
      return result;
   } else {
      return FALSE;
   }
}


DBGSTATIC
NTSTATUS
RsAsyncCompletion(
                 IN PDEVICE_OBJECT pDeviceObject,
                 IN PIRP           pIrp,
                 IN PVOID          pvContext
                 )
/*++

Routine Description:

    This routine is invoked for the completion of a mount or load fs
    request. It's only job is to synchronise with the mainline code.


Arguments:

    DeviceObject - Pointer to this driver's device object.

    Irp - Pointer to the IRP that was just completed.

    Context - Pointer to the completion context.


Return Value:

    STATUS_MORE_PROCESSING_REQUIRED if the qork item was queued or the
    return value of the real completion code if not..

--*/

{
   PKEVENT	pCompletionEvent = (PKEVENT) pvContext;


   UNREFERENCED_PARAMETER (pDeviceObject);
   UNREFERENCED_PARAMETER (pIrp);

   DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Async completion\n"));

   KeSetEvent (pCompletionEvent, IO_NO_INCREMENT, FALSE);


   return STATUS_MORE_PROCESSING_REQUIRED;
}


DBGSTATIC
NTSTATUS
RsPreAcquireFileForSectionSynchronization(
                    IN  PFS_FILTER_CALLBACK_DATA Data,
                    OUT PVOID *CompletionContext
                               )
/*++


Routine Description:

    This routine is the FS Filter pre-acquire file routine - called
    as a result of Mm attempting to acquire the file exclusively  in 
    preparation for a create section.

    The file- if it is a HSM migrated file- is recalled in this callback.

Arguments:

    Data - The FS_FILTER_CALLBACK_DATA structure containing the information
        about this operation.

    CompletionContext - A context set by this operation that will be passed
        to the corresponding RsPostFsFilterOperation call.
        The completion context is set to point to the createSectionLock count
        in the file context for this file. This will be appropriately 
        incremented in the PostAcquire callback if the acquire was successful

Return Value:

    STATUS_SUCCESS          if the operation can continue 
    STATUS_FILE_IS_OFFLINE  the file could not be recalled or the recall was
                            cancelled
--*/
{
   PFILE_OBJECT           fileObject;
   PRP_FILE_OBJ           entry;
   PRP_FILTER_CONTEXT     filterContext;
   PRP_FILE_CONTEXT       context;
   NTSTATUS               status = STATUS_SUCCESS;


   fileObject = Data->FileObject;

   filterContext = (PRP_FILTER_CONTEXT) FsRtlLookupPerStreamContext(FsRtlGetPerStreamContextPointer(fileObject), FsDeviceObject, fileObject);

   if (filterContext != NULL) {
      entry = (PRP_FILE_OBJ) filterContext->myFileObjEntry;
      ASSERT (entry != NULL);
      //
      // Now - if the file is in the no recall mode, but we see
      // a memory mapping section open for it, and the file has
      // been opened with write intent we should convert
      // the file to a recall on data access mode and initiate
      // the recall. Essentially if a file is open for write access
      // and we go through the acquire file for create section path,
      // (a memory mapped section is being opened), we recall right now,
      // even though we might never see a write for it later.
      // We are forced to do this because, if a user writes through
      // the mapped view, we could possibly not see the writes (Ntfs
      // will flush the pages to disk)
      //
      //
      if (RP_IS_NO_RECALL(entry) && (entry->desiredAccess & FILE_WRITE_DATA)) {
         //
         // Convert the file to recall mode
         //
         RP_RESET_NO_RECALL(entry);
      }

      //
      // If it was opened for no recall we do nothing, otherwise we must start
      // the recall here, before acquiring the resource.
      //
      if (!RP_IS_NO_RECALL(entry)) {
         //
         // Need to recall
         //
         status = RsRecallFile(filterContext);
      }
      if (!NT_SUCCESS(status)) {
           //
           // We are failing this op., so the post-acquire would not be 
           // called
           //
           status = STATUS_FILE_IS_OFFLINE;
      } else {
            //
            // Set the completion context for the post operation
            //
            context = entry->fsContext;
            ASSERT (context != NULL);
           *CompletionContext = &context->createSectionLock;
      }
   }

   return status;
}


DBGSTATIC
VOID
RsPostAcquireFileForSectionSynchronization(
                    IN PFS_FILTER_CALLBACK_DATA Data,
                    IN NTSTATUS AcquireStatus,
                    IN PVOID    CompletionContext
                               )
/*++


Routine Description:

    This routine is the FS Filter post-acquire file routine - called
    as a result of Mm attempting to acquire the file exclusively  in 
    preparation for a create section, just after the acquire succeeded

    If the completion context was non-NULL then the acquire was for a
    HSM managed file. We increment the createSection lock for the file
    to indicate there is an exclusive lock on this file

Arguments:

    Data - The FS_FILTER_CALLBACK_DATA structure containing the information
        about this operation.
    AcquireStatus - Status of the AcquireFile operation

    CompletionContext - A context set by the PreAcquire operation: this is
                        file context's create section lock if set. 
                        If it is NULL, then the file is not a HSM file so just 
                        do nothing                    

Return Value:

    NONE

--*/
{

   PAGED_CODE();

   if (NT_SUCCESS(AcquireStatus) && (CompletionContext != NULL)) {
          InterlockedIncrement((PULONG) CompletionContext);
   }
}



DBGSTATIC
VOID
RsPostReleaseFileForSectionSynchronization(
                    IN PFS_FILTER_CALLBACK_DATA Data,
                    IN NTSTATUS ReleaseStatus,
                    IN PVOID    CompletionContext
                               )
/*++


Routine Description:

    This routine is the FS Filter post-release file routine - called
    as a result of Mm attempting to acquire the file exclusively  in 
    preparation for a create section, just after the release is done

    We simply decrement the create section lock count for the file if
    it is a HSM managed file.

Arguments:

    Data - The FS_FILTER_CALLBACK_DATA structure containing the information
           about this operation.

    ReleaseStatus - Status of the ReleaseFile operation

    CompletionContext - A context set by the PreAcquire operation. Unused.
                        

Return Value:

    NONE

--*/
{
   PFILE_OBJECT           fileObject;
   PRP_FILE_OBJ           entry;
   PRP_FILTER_CONTEXT     filterContext;
   PRP_FILE_CONTEXT       context;

   PAGED_CODE();

   if (NT_SUCCESS(ReleaseStatus)) {

       fileObject = Data->FileObject;
       filterContext = (PRP_FILTER_CONTEXT) FsRtlLookupPerStreamContext(FsRtlGetPerStreamContextPointer(fileObject), FsDeviceObject, fileObject);

       if (filterContext != NULL) {
           entry = (PRP_FILE_OBJ) filterContext->myFileObjEntry;
           ASSERT (entry != NULL);
           context = entry->fsContext;
           ASSERT (context != NULL);
           InterlockedDecrement(&context->createSectionLock);
        }
   }

   return;
}


NTSTATUS
RsFsctlRecallFile(IN PFILE_OBJECT FileObject)
/*++

Routine Description

    This routine recalls the file specified by the file object
    if it is not already recalled.

Arguments

    FileObject - Pointer to the file object for the file to be recalled

Return Value

    Status of the recall

--*/
{
   PRP_FILTER_CONTEXT     filterContext;
   PRP_FILE_OBJ           entry;
   NTSTATUS               status = STATUS_SUCCESS;

   PAGED_CODE();

   filterContext = (PRP_FILTER_CONTEXT) FsRtlLookupPerStreamContext(FsRtlGetPerStreamContextPointer(FileObject), FsDeviceObject, FileObject);

   if (filterContext != NULL) {
      entry = (PRP_FILE_OBJ) filterContext->myFileObjEntry;

      if (!(entry->desiredAccess & FILE_WRITE_DATA) &&
          !(entry->desiredAccess & FILE_READ_DATA)) {
         //
         // Just  a confirmation - take this check away when shipping
         //
         DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO,"RsRecallFile: attempting a recall on a file not opened for read or write\n"));
         return STATUS_ACCESS_DENIED;
      }

      if (RP_IS_NO_RECALL(entry)) {
         return STATUS_ACCESS_DENIED;
      }

      //
      // Obviously the file is going to get out of the no-recall state
      //
      RP_RESET_NO_RECALL(entry);

      status = RsRecallFile(filterContext);
   }
   return status;
}


NTSTATUS
RsRecallFile(IN PRP_FILTER_CONTEXT FilterContext)
/*++

Routine Description

    This routine recalls the file specified by the file object
    if it is not already recalled.

Arguments

    FilterContext - pointer to the filter context

Return Value

    Status of the recall

--*/
{

   NTSTATUS               retval = STATUS_FILE_IS_OFFLINE, status, qRet;
   BOOLEAN                gotLock;
   PRP_FILE_OBJ           entry;
   PRP_FILE_CONTEXT       context;
   PKEVENT                eventToWaitOn;
   ULONGLONG              filterId;
   LONGLONG               start, size;

   PAGED_CODE();

   entry = (PRP_FILE_OBJ) FilterContext->myFileObjEntry;

   context = entry->fsContext;

   RsAcquireFileContextEntryLockExclusive(context);
   gotLock = TRUE;
   try {
      DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsRecallFile - RecallStatus = %u.\n",
                            context->state));

      ObReferenceObject(entry->fileObj);

      switch (context->state) {

      case RP_RECALL_COMPLETED: {
            //
            // Nothing we can do if recallStatus is not STATUS_SUCCESS
            //
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsRecallFile - recall complete.\n"));
            if (context->recallStatus == STATUS_CANCELLED) {
               //
               // Previous recall was cancelled by user. Start another recall
               // now
               // So fall through deliberately to the NOT_RECALLED_CASE
               //
            } else {
               retval = context->recallStatus;
               ObDereferenceObject(entry->fileObj);
               RsReleaseFileContextEntryLock(context);
               gotLock = FALSE;
               break;
            }
         }
      case RP_RECALL_NOT_RECALLED: {
            //
            // Start the recall here.
            //
            //
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsRecallFile - Queueing the recall.\n"));

            retval = STATUS_SUCCESS;
            context->state = RP_RECALL_STARTED;

            KeResetEvent(&context->recallCompletedEvent);

            entry->filterId = (ULONGLONG) InterlockedIncrement((PLONG) &RsFileObjId);
            entry->filterId <<= 32;
            entry->filterId |= RP_TYPE_RECALL;

            filterId = context->filterId | entry->filterId;
            start = context->rpData.data.dataStart.QuadPart;
            size =  context->rpData.data.dataSize.QuadPart;

            RsReleaseFileContextEntryLock(context);
            gotLock = FALSE;

            qRet = RsQueueRecallOpen(context,
                                     entry,
                                     filterId,
                                     start,
                                     size,
                                     RP_OPEN_FILE);
            start = context->rpData.data.dataStreamStart.QuadPart;
            size =  context->rpData.data.dataStreamSize.QuadPart;


            if (NT_SUCCESS(qRet)) {
               qRet = RsQueueRecall(filterId ,
                                    start,
                                    size);
            };

            if (!NT_SUCCESS(qRet)) {
               //
               // If it failed we need to fail any reads we get later, since we
               // cannot fail this call.
               //
               RsAcquireFileContextEntryLockExclusive(context);
               gotLock = TRUE;

               context->state = RP_RECALL_NOT_RECALLED;
               context->recallStatus = STATUS_FILE_IS_OFFLINE;
               DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsRecallFile - Failed to queue the recall.\n"));
               //
               // If we got as far as queuing the recall, then we should not
               // fail the other IRPs.
               //
               RsFailAllRequests(context, FALSE);

               RsReleaseFileContextEntryLock(context);
               gotLock = FALSE;
               retval = STATUS_FILE_IS_OFFLINE;

            } else {
               DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsRecallFile - Queued the recall.\n"));
               eventToWaitOn = &context->recallCompletedEvent;
               status = KeWaitForSingleObject(eventToWaitOn,
                                              Executive,
                                              KernelMode,
                                              FALSE,
                                              NULL);

               if (status == STATUS_SUCCESS) {
                    retval = context->recallStatus;
               } else {
                    //
                    // Wait did not succeed
                    //
                    retval = STATUS_FILE_IS_OFFLINE;
               }

               DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsRecallFile - recall done - %x.\n", context->state));
            }

            ObDereferenceObject(entry->fileObj);
            break;
         }

      case RP_RECALL_STARTED: {
            //
            // recall is started. we wait for it to complete here
            //
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsRecallFile - recall started.\n"));
            eventToWaitOn = &context->recallCompletedEvent;

            filterId = context->filterId | entry->filterId;
            qRet = RsQueueRecallOpen(context,
                                     entry,
                                     filterId,
                                     0,0,
                                     RP_RECALL_WAITING);

            RsReleaseFileContextEntryLock(context);
            gotLock = FALSE;
            status = KeWaitForSingleObject(eventToWaitOn,
                                           Executive,
                                           KernelMode,
                                           FALSE,
                                           NULL);

            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsRecallFile - recall finished.\n"));
            if (status == STATUS_SUCCESS) {
                 retval = context->recallStatus;
            } else {
                //
                // Wait did not succeed
                //
                retval = STATUS_FILE_IS_OFFLINE;
            }
            ObDereferenceObject(entry->fileObj);
            break;
         }


      default:  {
            //
            // Something strange - Fail the write
            //
            RsLogError(__LINE__, AV_MODULE_RPFILTER, context->state,
                       AV_MSG_UNEXPECTED_ERROR, NULL, NULL);

            //
            // TEMPORARY BEGIN: to track down RSFilter bug
            //
            DbgPrint("RsFilter: Unexpected error! File context = %x, Contact RaviSp to debug\n", context);
            DbgBreakPoint();
            //
            // TEMPORARY END
            //

            RsReleaseFileContextEntryLock(context);
            gotLock = FALSE;
            ObDereferenceObject(entry->fileObj);
            retval = STATUS_FILE_IS_OFFLINE;
            break;
         }
      }

      if (gotLock == TRUE) {
         RsReleaseFileContextEntryLock(context);
         gotLock = FALSE;
      }
   }except (RsExceptionFilter(L"RsRecallFile", GetExceptionInformation())) {
      //
      // Something bad happened - just log an error and return
      //
      if (gotLock == TRUE) {
         RsReleaseFileContextEntryLock(context);
         gotLock = FALSE;
      }
      retval = STATUS_INVALID_USER_BUFFER;
   }

   return retval;
}


NTSTATUS
RsQueryInformation(
                  IN PDEVICE_OBJECT DeviceObject,
                  IN PIRP Irp
                  )
/*++

Routine Description

   Filters the IRP_MJ_QUERY_INFORMATION call
   We mask out FILE_ATTRIBUTE_OFFLINE while returning the attributes

Arguments

   DeviceObject   - Pointer to our device object
   Irp            - The set information Irp

Return Value

   status

--*/
{
   PIO_STACK_LOCATION          currentStack ;
   NTSTATUS                    status = STATUS_SUCCESS;
   PDEVICE_EXTENSION           deviceExtension;
   ULONG                        openOptions;

   PAGED_CODE();

   deviceExtension = DeviceObject->DeviceExtension;

   try {
      if (!deviceExtension->Type) {
         status = STATUS_INVALID_DEVICE_REQUEST;
         leave;
      }

      currentStack = IoGetCurrentIrpStackLocation (Irp) ;

      if (currentStack->Parameters.QueryFile.FileInformationClass != FileBasicInformation &&  currentStack->Parameters.QueryFile.FileInformationClass != FileAllInformation) {
         //
         // We are not interested in this IRP
         //
         IoSkipCurrentIrpStackLocation(Irp);
         leave;
      }

      //
      // Check if this is hsm managed & if so get the reparse point data
      //
      if (RsIsFileObj(currentStack->FileObject, TRUE, NULL, NULL, NULL, NULL, NULL, &openOptions, NULL, NULL) == FALSE) {
         //
         //
         // Get this driver out of the driver stack and get to the next driver as
         // quickly as possible.
         //
         IoSkipCurrentIrpStackLocation(Irp);
         leave;
      }

      if (!RP_IS_NO_RECALL_OPTION(openOptions)) {
         IoSkipCurrentIrpStackLocation(Irp);
         leave;
      }

      IoCopyCurrentIrpStackLocationToNext(Irp);
      IoSetCompletionRoutine( Irp,
                              RsQueryInformationCompletion,
                              NULL,
                              TRUE,
                              TRUE,
                              TRUE );
   } finally {
      if (NT_SUCCESS(status)) {
         status = IoCallDriver(deviceExtension->FileSystemDeviceObject,
                               Irp);
      } else {
         Irp->IoStatus.Status = status;
         Irp->IoStatus.Information = 0;
         IoCompleteRequest( Irp, IO_NO_INCREMENT );
      }
   }
   return status;
}


NTSTATUS
RsQueryInformationCompletion(
                            IN PDEVICE_OBJECT DeviceObject,
                            IN PIRP Irp,
                            IN PVOID Context
                            )
/*++

Routine Description:

   Completion routine for query information

Arguments:



Return Value:


Note:

--*/
{
   PIO_STACK_LOCATION currentStack = IoGetCurrentIrpStackLocation(Irp);
   PFILE_BASIC_INFORMATION  basicInfo;

   UNREFERENCED_PARAMETER( DeviceObject );

   if (NT_SUCCESS(Irp->IoStatus.Status)) {
      if (currentStack->Parameters.QueryFile.FileInformationClass == FileBasicInformation) {
         basicInfo = Irp->AssociatedIrp.SystemBuffer;
      } else if (currentStack->Parameters.QueryFile.FileInformationClass == FileAllInformation) {
         basicInfo = &(((PFILE_ALL_INFORMATION) Irp->AssociatedIrp.SystemBuffer)->BasicInformation);
      } else {
         //
         // This shouldn't happen
         //
         return STATUS_SUCCESS;

      }
      //
      // Turn off the OFFLINE attribute
      //
      basicInfo->FileAttributes &= ~FILE_ATTRIBUTE_OFFLINE;
   }

   return STATUS_SUCCESS;
}


NTSTATUS
RsInitialize(VOID)
/*++

Routine Description:

    Initialize the environment.

Arguments:

    NONE

Return Value:

    0

Note:

    This is called when the FSA enables recalls


--*/
{
   PRTL_QUERY_REGISTRY_TABLE parms;
   ULONG                     parmsSize;
   NTSTATUS                  status = STATUS_SUCCESS;
   ULONG                     defaultEnableLegacyAccessMethod = FALSE;
   ULONG                     defaultSkipFilesForLegacyBackup = 0;
   ULONG                     defaultMediaType                = RS_SEQUENTIAL_ACCESS_MEDIA;
   ULONG                     mediaType;

   PAGED_CODE();

   parmsSize =  sizeof(RTL_QUERY_REGISTRY_TABLE) * 2;

   parms = ExAllocatePoolWithTag(PagedPool,
                                 parmsSize,
                                 RP_ER_TAG
                                );

   if (!parms) {
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   RtlZeroMemory(parms, parmsSize);

   parms[0].Flags         = RTL_QUERY_REGISTRY_DIRECT;
   parms[0].Name          = RSFILTER_SKIP_FILES_FOR_LEGACY_BACKUP_VALUE;
   parms[0].EntryContext  = &RsSkipFilesForLegacyBackup;
   parms[0].DefaultType   = REG_DWORD;
   parms[0].DefaultData   = &defaultSkipFilesForLegacyBackup;
   parms[0].DefaultLength = sizeof(ULONG);

   //
   // Perform the query
   //
   status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES | RTL_REGISTRY_OPTIONAL,
                                   RSFILTER_PARAMS_KEY,
                                   parms,
                                   NULL,
                                   NULL);


   //
   // Not finding the key/value is no reason to fail the function. Treat as 
   // a success and allow things to proceed normally.
   //

   if (NT_SUCCESS(status) || (STATUS_OBJECT_NAME_NOT_FOUND == status)) {

       RtlZeroMemory(parms, parmsSize);

       parms[0].Flags         = RTL_QUERY_REGISTRY_DIRECT;
       parms[0].Name          = RSENGINE_MEDIA_TYPE_VALUE;
       parms[0].EntryContext  = &mediaType;
       parms[0].DefaultType   = REG_DWORD;
       parms[0].DefaultData   = &defaultMediaType;
       parms[0].DefaultLength = sizeof(ULONG);

       status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES | RTL_REGISTRY_OPTIONAL,
                                       RSENGINE_PARAMS_KEY,
                                       parms,
                                       NULL,
                                       NULL);
       if (NT_SUCCESS(status)) {
           if (mediaType == RS_DIRECT_ACCESS_MEDIA) {
               RsUseUncachedNoRecall = TRUE;
           } else  {
               RsUseUncachedNoRecall = FALSE;
           }
       }
   }



   //
   // Not finding the key/value is no reason to fail the function. Treat as 
   // a success and allow things to proceed normally.
   //

   if (NT_SUCCESS(status) || (STATUS_OBJECT_NAME_NOT_FOUND == status)) {

       RtlZeroMemory(parms, parmsSize);

       parms[0].Flags         = RTL_QUERY_REGISTRY_DIRECT;
       parms[0].Name          = RSFILTER_ENABLE_LEGACY_REPARSE_POINT_ACCESS;
       parms[0].EntryContext  = &RsEnableLegacyAccessMethod;
       parms[0].DefaultType   = REG_DWORD;
       parms[0].DefaultData   = &defaultEnableLegacyAccessMethod;
       parms[0].DefaultLength = sizeof (defaultEnableLegacyAccessMethod);

       status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES | RTL_REGISTRY_OPTIONAL,
                                       RSFILTER_PARAMS_KEY,
                                       parms,
                                       NULL,
                                       NULL);
   }

   ExFreePool(parms);

   return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\filter\rpsec.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999
(c) 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    RpSec.c

Abstract:

    This module contains security related support routines for the HSM file system filter.

Author:

    Rick Winter

Environment:

    Kernel mode


Revision History:

    1998:
    Ravisankar Pudipeddi   (ravisp) 
        
--*/

#include "pch.h"

NTSYSAPI
ULONG
NTAPI
RtlLengthSid (
             PSID Sid
             );

NTSYSAPI
BOOLEAN
NTAPI
RtlEqualSid (
            PSID Sid1,
            PSID Sid2
            );

#ifdef ALLOC_PRAGMA
   #pragma alloc_text(PAGE, RsGetUserInfo)
#endif

VOID
RsGetUserInfo(
              IN  PSECURITY_SUBJECT_CONTEXT SubjectContext,
              OUT PRP_USER_SECURITY_INFO    UserSecurityInfo)
{
   NTSTATUS            status;
   char                *tBuff;
   PTOKEN_USER         user;
   PTOKEN_STATISTICS   stats;
   PTOKEN_SOURCE       source;
   BOOLEAN             lProc = FALSE;
   ULONG               ix;
   PACCESS_TOKEN       token;

   PAGED_CODE();

   token = SeQuerySubjectContextToken(SubjectContext);

   user = NULL;
   status = SeQueryInformationToken(token, TokenUser, &user);

   if ((NT_SUCCESS(status)) && (NULL != user)) {
      UserSecurityInfo->userInfoLen = RtlLengthSid(user->User.Sid);
      tBuff = (char *) ExAllocatePoolWithTag(NonPagedPool, 
                                             UserSecurityInfo->userInfoLen, 
                                             RP_SE_TAG);
      if (NULL == tBuff) {
         RsLogError(__LINE__, AV_MODULE_RPSEC, status,
                    AV_MSG_USER_ERROR, NULL, NULL);
         UserSecurityInfo->userInfoLen = 0;
         UserSecurityInfo->userInfo = NULL;
      } else {
         RtlCopyMemory(tBuff, user->User.Sid, UserSecurityInfo->userInfoLen);
         UserSecurityInfo->userInfo = tBuff;
      }

      ExFreePool(user);
   } else {
      // Unable to get user info
      RsLogError(__LINE__, AV_MODULE_RPSEC, status,
                 AV_MSG_USER_ERROR, NULL, NULL);
      UserSecurityInfo->userInfoLen = 0;
      UserSecurityInfo->userInfo = NULL;
   }

   UserSecurityInfo->isAdmin = SeTokenIsAdmin(token);

   stats = NULL;
   status = SeQueryInformationToken(token, TokenStatistics, &stats);
   if ((NT_SUCCESS( status )) && (NULL != stats) ) {
      RtlCopyLuid(&UserSecurityInfo->userInstance, &stats->TokenId);
      RtlCopyLuid(&UserSecurityInfo->userAuthentication, &stats->AuthenticationId);
      UserSecurityInfo->localProc = lProc;
      ExFreePool(stats);
   } else {
      UserSecurityInfo->userInstance.LowPart = 0L;
      UserSecurityInfo->userInstance.HighPart = 0L;
      UserSecurityInfo->userAuthentication.LowPart = 0L;
      UserSecurityInfo->userAuthentication.HighPart = 0L;
      RsLogError(__LINE__, AV_MODULE_RPSEC, status,
                 AV_MSG_USER_ERROR, NULL, NULL);
   }

   source = NULL;
   strcpy(UserSecurityInfo->tokenSource, "???");
   status = SeQueryInformationToken(token, TokenSource, &source);
   if ((NT_SUCCESS( status )) && (NULL != source)) {
      RtlCopyLuid(&UserSecurityInfo->tokenSourceId, &source->SourceIdentifier);
      strncpy(UserSecurityInfo->tokenSource, source->SourceName, TOKEN_SOURCE_LENGTH);
      ExFreePool(source);
      //
      // Remove trailing spaces from the source name and NULL terminate it
      //
      ix = TOKEN_SOURCE_LENGTH - 1;
      UserSecurityInfo->tokenSource[ix] = '\0';
      ix--;
      while (UserSecurityInfo->tokenSource[ix] == ' ') {
         UserSecurityInfo->tokenSource[ix] = '\0';
         ix--;
      }

   } else {
      UserSecurityInfo->tokenSourceId.LowPart = 0L;
      UserSecurityInfo->tokenSourceId.HighPart = 0L;
      strcpy(UserSecurityInfo->tokenSource, "N/A");
      RsLogError(__LINE__, AV_MODULE_RPSEC, status,
                 AV_MSG_USER_ERROR, NULL, NULL);
   }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\filter\rpfilfun.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 2001
(c) 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    RpFilfun.c

Abstract:

    This module contains support routines for the HSM file system filter.

Author:

    Rick Winter
    Ravisankar Pudipeddi   (ravisp)    - 1998

Environment:

    Kernel mode


Revision History:

	X-16			Michael C. Johnson		25-Jan-2002
		Fix some unititialised variables found by PREfast.

	X-15    460967		Michael C. Johnson		 5-Sep-2001
                Detect the failure to allocate the irp in RsDoWrite() and 
                handle the error appropriately.

	X-14	108353		Michael C. Johnson		 3-May-2001
		When checking a file to determine the type of recall also
		check a the potential target disk to see whether or not
		it is writable. This is necessary now that we have read-only
		NTFS volumes.

	X-13	365077		Michael C. Johnson		 1-May-2001
		Although IoCreateFileSpecifyDeviceObjectHint() allows us to 
		bypass share access checking it doesn't bypass the check for 
		a readonly file attribute. Revert to the old scheme of 
		directly munging the file object after a successful open. 
		Note that we can still use IoCreateFileSpecifyDeviceObjectHint() 
		to avoid traversing the entire IO stack.

	X-12	332127		Michael C. Johnson		10-Apr-2001
		Reduce the number of times a notification message is sent 
		to the service to once per file stream. Use the exisiting 
		RP_NOTIFICATION_SENT flag but use it for all cases.

	X-11	206961		Michael C. Johnson		16-Mar-2001
		Refresh the cached filename in the file context on each new 
		open of the file in case the file has been renamed since the
		last time we saw an open.

		273036
		Correct reported status on logging of failed reparse point
		deletions. 

		Add in memory trace mechanism in preparation for attempts
		to flush out lingering reparse point deletion troubles.

	X-10	326345		Michael C. Johnson		26-Feb-2001
		Only send a single RP_RECALL_WAITING to the fsa on any one
		file object. Use the new flag RP_NOTIFICATION_SENT to record 
		when notification has been done.


--*/


#include "pch.h"

ULONG                   RsFileContextId       = 1;
ULONG                   RsFileObjId           = 1;
ULONG                   RsNoRecallReadId      = 1;
ULONG                   RsFsaRequestCount     = 0;

ULONG                   RsDefaultTraceEntries = DEFAULT_TRACE_ENTRIES;
PRP_TRACE_CONTROL_BLOCK RsTraceControlBlock   = NULL;

KSPIN_LOCK              RsIoQueueLock;
LIST_ENTRY              RsIoQHead;

FAST_MUTEX              RsFileContextQueueLock;
LIST_ENTRY              RsFileContextQHead;

KSPIN_LOCK              RsValidateQueueLock;
LIST_ENTRY              RsValidateQHead;


//
// Semaphore signalling that a new FSCTL from FSA is available for RsFilter's
// consumption
//
KSEMAPHORE            RsFsaIoAvailableSemaphore;

extern PDRIVER_OBJECT FsDriverObject;
extern ULONG          RsAllowRecalls;
extern ULONG          RsNoRecallDefault;



NTSTATUS
RsCancelIoIrp(
             PDEVICE_OBJECT DeviceObject,
             PIRP Irp
             );

PRP_IRP_QUEUE
RsDequeuePacket(
               IN PLIST_ENTRY Head,
               IN PKSPIN_LOCK Lock
               );

#ifdef ALLOC_PRAGMA
    #pragma alloc_text(PAGE, RsAddQueue)
    #pragma alloc_text(PAGE, RsCheckRead)
    #pragma alloc_text(PAGE, RsCheckWrite)
    #pragma alloc_text(PAGE, RsAddFileObj)
    #pragma alloc_text(PAGE, RsMakeContext)
    #pragma alloc_text(PAGE, RsAcquireFileContext)
    #pragma alloc_text(PAGE, RsReleaseFileContext)
    #pragma alloc_text(PAGE, RsGetFileId)
    #pragma alloc_text(PAGE, RsGetFileName)
    #pragma alloc_text(PAGE, RsGetFileInfo)
    #pragma alloc_text(PAGE, RsQueueRecall)
    #pragma alloc_text(PAGE, RsQueueRecallOpen)
    #pragma alloc_text(PAGE, RsPartialWrite)
    #pragma alloc_text(PAGE, RsWriteReparsePointData)
    #pragma alloc_text(PAGE, RsGetRecallInfo)
    #pragma alloc_text(PAGE, RsGetFsaRequest)
    #pragma alloc_text(PAGE, RsGenerateDevicePath)
    #pragma alloc_text(PAGE, RsGenerateFullPath)
    #pragma alloc_text(PAGE, RsFreeFileObject)
    #pragma alloc_text(PAGE, RsFailAllRequests)
    #pragma alloc_text(PAGE, RsCancelRecalls)
    #pragma alloc_text(PAGE, RsIsNoRecall)
    #pragma alloc_text(PAGE, RsIsFastIoPossible)
    #pragma alloc_text(PAGE, RsQueueNoRecall)
    #pragma alloc_text(PAGE, RsQueueNoRecallOpen)
    #pragma alloc_text(PAGE, RsDoWrite)
    #pragma alloc_text(PAGE, RsPreserveDates)
    #pragma alloc_text(PAGE, RsCompleteAllRequests)
    #pragma alloc_text(PAGE, RsLogValidateNeeded)
    #pragma alloc_text(PAGE, RsQueueValidate)
    #pragma alloc_text(PAGE, RsQueueCancel)
    #pragma alloc_text(PAGE, RsGetFileUsn)
    #pragma alloc_text(PAGE, RsCheckVolumeReadOnly)

    #pragma alloc_text(INIT, RsTraceInitialize)

#endif


NTSTATUS
RsAddQueue(IN  ULONG          Serial,
           OUT PULONGLONG     RecallId,
           IN  ULONG          OpenOption,
           IN  PFILE_OBJECT   FileObject,
           IN  PDEVICE_OBJECT DevObj,
           IN  PDEVICE_OBJECT FilterDeviceObject,
           IN  PRP_DATA       PhData,
           IN  LARGE_INTEGER  RecallStart,
           IN  LARGE_INTEGER  RecallSize,
           IN  LONGLONG       FileId,
           IN  LONGLONG       ObjIdHi,
           IN  LONGLONG       ObjIdLo,
           IN  ULONG          DesiredAccess,
           IN  PRP_USER_SECURITY_INFO UserSecurityInfo)
/*++

Routine Description:

   This function adds a file object queue entry to the internal queue

Arguments:
   Open options from the Irp
   Irp
   IO_STACK_LOCATION
   Device object
   Placeholder data

Return Value:
  0 if queued ok
  non-zero otherwise


Note:  We will retrieve some security information.  The calls necessary to do this require that the
call be made from irql DISPATCH_LEVEL or above.


--*/
{
    PRP_FILE_OBJ            entry;
    ULONGLONG               filterId;
    PIRP                    ioIrp;
    PRP_FILE_CONTEXT        context;
    NTSTATUS                status;
    PRP_FILTER_CONTEXT      filterContext;
    BOOLEAN                 gotLock = FALSE;

    PAGED_CODE();

    try {

        entry = (RP_FILE_OBJ *) ExAllocatePoolWithTag(NonPagedPool, sizeof(RP_FILE_OBJ), RP_RQ_TAG);

        if (NULL == entry) {
            RsLogError(__LINE__, AV_MODULE_RPFILFUN, sizeof(RP_FILE_OBJ),
                       AV_MSG_MEMORY, NULL, NULL);

            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        RtlZeroMemory(entry, sizeof(RP_FILE_OBJ));

        entry->fileObj = FileObject;
        entry->devObj = DevObj;
        ExInitializeResourceLite(&entry->resource);
        KeInitializeSpinLock(&entry->qLock);
        InitializeListHead(&entry->readQueue);
        InitializeListHead(&entry->writeQueue);
        entry->openOptions = OpenOption;
        entry->objIdHi = ObjIdHi;
        entry->objIdLo = ObjIdLo;
        entry->fileId = FileId;
        entry->desiredAccess = DesiredAccess;
        entry->userSecurityInfo = UserSecurityInfo;

        if (UserSecurityInfo->isAdmin) {
            entry->flags |= RP_OPEN_BY_ADMIN;
        }

        if (UserSecurityInfo->localProc) {
            entry->flags |= RP_OPEN_LOCAL;
        }

        if (!(DesiredAccess & FILE_HSM_ACTION_ACCESS) ) {
            entry->flags |= RP_NO_DATA_ACCESS;
        }
        //
        // Now see if there is a file context entry for this file
        // This call will create one if necessary, or return an already existing one.
        // The file context entry is locked when this call returns and the
        // ref count bumped up
        //
        status = RsMakeContext(FileObject, &context);

        if (!NT_SUCCESS(status)) {
            RsLogError(__LINE__, AV_MODULE_RPFILFUN, sizeof(RP_FILE_OBJ),
                       AV_MSG_MEMORY, NULL, NULL);
            ExDeleteResourceLite(&entry->resource);
            ExFreePool(entry);
            return status;
        }

        gotLock = TRUE;
        entry->fsContext = context;


        if (!(context->flags & RP_FILE_INITIALIZED)) {
            //
            // We have to initialize it here.
            //
            InitializeListHead(&context->fileObjects);
            context->devObj = DevObj;
	    context->FilterDeviceObject = FilterDeviceObject;
            KeInitializeSpinLock(&context->qLock);
            KeInitializeEvent(&context->recallCompletedEvent,
                              NotificationEvent,
                              FALSE);
            context->fileId = FileId;
            context->recallSize = RecallSize;
            filterId = (ULONGLONG) InterlockedIncrement((PLONG) &RsFileContextId);
            context->filterId = filterId;
            context->serial = Serial;
            memcpy(&context->rpData, PhData, sizeof(RP_DATA));

            context->flags |= RP_FILE_INITIALIZED;

            if (RP_FILE_IS_TRUNCATED(PhData->data.bitFlags)) {
                context->state = RP_RECALL_NOT_RECALLED;
                context->recallStatus = STATUS_SUCCESS;
                context->currentOffset.QuadPart = 0;
            } else {
                //
                // File is pre-migrated
                //
                context->state = RP_RECALL_COMPLETED;
                context->recallStatus = STATUS_SUCCESS;
                context->currentOffset.QuadPart = RecallSize.QuadPart;
            }


            if (NT_SUCCESS(status) && RP_IS_NO_RECALL_OPTION(OpenOption)) {
                 status = RsGetFileUsn(context,
                                       FileObject,
                                       FilterDeviceObject);

            }

            if (!NT_SUCCESS(status)) {
                DebugTrace((DPFLTR_RSFILTER_ID,DBG_ERROR, "RsFilter:RsAddQueue: Failed to get the path (%x).\n", status));
                RsLogError(__LINE__, AV_MODULE_RPFILFUN, status, AV_MSG_PATH_ERROR, NULL, NULL);
                //
                // Deref & release context
                //
                RsReleaseFileContext(context);
                gotLock = FALSE;
                ExDeleteResourceLite(&entry->resource);
                ExFreePool(entry);

                return(status);
            }
        }


        //
        // Discard any existing filename to force an update of cached filename 
        // in case of renames since the original open.
        //
        if (context->uniName != NULL) {
            ExFreePool(context->uniName);
            context->uniName = NULL;
        }

        status = RsGetFileInfo(entry, FilterDeviceObject);


        filterId = context->filterId;

        if (context->flags & RP_FILE_WAS_WRITTEN) {
            //
            // If file was written to - we cannot operate in a no-recall mode
            //
            RP_RESET_NO_RECALL_OPTION(OpenOption);
        }

        if (RP_IS_NO_RECALL_OPTION(OpenOption)) {
            //
            // Open no recall - the file object does not have an ID - each read will get one later.
            //
            entry->filterId = 0;

            RP_SET_NO_RECALL(entry);

        } else {
            //
            // A normal recall - assign a filter ID to the file object
            //
            entry->filterId = (ULONGLONG) InterlockedIncrement((PLONG) &RsFileObjId);
            entry->filterId <<= 32;
            entry->filterId |= RP_TYPE_RECALL;
            filterId |= entry->filterId;
        }

        *RecallId = filterId;

        filterContext= (PRP_FILTER_CONTEXT) ExAllocatePoolWithTag(NonPagedPool, sizeof(RP_FILTER_CONTEXT), RP_RQ_TAG);
        if (NULL == filterContext) {
            RsLogError(__LINE__, AV_MODULE_RPFILFUN, sizeof(RP_FILTER_CONTEXT),
                       AV_MSG_MEMORY, NULL, NULL);
            //
            // Deref/free context
            //
            RsReleaseFileContext(context);
            gotLock = FALSE;

            ExDeleteResourceLite(&entry->resource);
            ExFreePool(entry);
            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        RtlZeroMemory(filterContext, sizeof(RP_FILTER_CONTEXT));
        FsRtlInitPerStreamContext( &filterContext->context,
                                   FsDeviceObject,
                                   FileObject,
                                   RsFreeFileObject);
        filterContext->myFileObjEntry = entry;

        DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsAddQueue: Allocated filter context tag  %x : %x (id = %I64X).\n", context, entry, *RecallId));

        status = FsRtlInsertPerStreamContext(FsRtlGetPerStreamContextPointer(FileObject), &filterContext->context);

        if (NT_SUCCESS(status)) {

            // Now that we have gotten everything setup we can put it on the queue
            //
            ExInterlockedInsertTailList(&context->fileObjects,
                                        (PLIST_ENTRY) entry,
                                        &context->qLock);
        } else {
            //
            // Failed to add filter context.
            //
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_ERROR, "RsFilter: Failed to insert filter context %x.\n", status));

            RsReleaseFileContext(context);
            gotLock = FALSE;

            ExDeleteResourceLite(&entry->resource);
            ExFreePool(entry);
        }

        RsReleaseFileContextEntryLock(context);
        gotLock = FALSE;

    }except (RsExceptionFilter(L"RsAddQueue", GetExceptionInformation())) {
        //
        // Something bad happened - just log an error and return
        //
        if (gotLock) {
            RsReleaseFileContextEntryLock(context);
        }

    }
    return(status);
}


NTSTATUS
RsGetFileUsn(IN PRP_FILE_CONTEXT Context,
             IN PFILE_OBJECT     FileObject,
             IN PDEVICE_OBJECT   FilterDeviceObject)
/*++

Routine Description:

   This function retrieves the file USN of the specified file

Arguments:

   Context              -     pointer to the file context entry where the USN is stored
   FileObject           -     pointer to the file object
   FilterDeviceObject   -     pointer to the dev obj for RsFilter

Return Value:
  0 if queued ok
  non-zero otherwise

--*/
{
    PIRP               irp;
    KEVENT             event;
    PDEVICE_EXTENSION  deviceExtension = FilterDeviceObject->DeviceExtension;
    PUSN_RECORD        usnRecord;
    ULONG              usnRecordSize;
    NTSTATUS           status;
    IO_STATUS_BLOCK    ioStatus;
    PIO_STACK_LOCATION irpSp;

    PAGED_CODE();

    usnRecordSize = sizeof(USN_RECORD) + 4096;
    usnRecord = ExAllocatePoolWithTag(PagedPool,
                                      usnRecordSize,
                                      RP_US_TAG);

    if (!usnRecord) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    KeInitializeEvent(&event,
                      SynchronizationEvent,
                      FALSE);


    irp =  IoBuildDeviceIoControlRequest(FSCTL_READ_FILE_USN_DATA,
                                         deviceExtension->FileSystemDeviceObject,
                                         NULL,
                                         0,
                                         usnRecord,
                                         usnRecordSize,
                                         FALSE,
                                         &event,
                                         &ioStatus);
    if (irp == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Fill in the other stuff
    //
    irp->Tail.Overlay.OriginalFileObject = FileObject;
    irp->RequestorMode = KernelMode;
    irp->PendingReturned = FALSE;
    irp->Cancel = FALSE;
    irp->CancelRoutine = (PDRIVER_CANCEL) NULL;
    irp->Flags |= IRP_SYNCHRONOUS_API;

    irpSp = IoGetNextIrpStackLocation(irp);

    irpSp->FileObject = FileObject;
    irpSp->MajorFunction = IRP_MJ_FILE_SYSTEM_CONTROL;

    irpSp->Parameters.FileSystemControl.OutputBufferLength = usnRecordSize;

    ObReferenceObject(FileObject);

    status = IoCallDriver(deviceExtension->FileSystemDeviceObject,
                          irp);

    if (status == STATUS_PENDING) {
        (VOID)KeWaitForSingleObject(&event,
                                    Executive,
                                    KernelMode,
                                    FALSE,
                                    (PLARGE_INTEGER) NULL);
        status = ioStatus.Status;
    }

    if (NT_SUCCESS(status)) {
        Context->usn = usnRecord->Usn;
    }

    ExFreePool(usnRecord);

    return status;
}


NTSTATUS
RsAddFileObj(IN PFILE_OBJECT   FileObj,
             IN PDEVICE_OBJECT FilterDeviceObject,
             IN RP_DATA        *PhData,
             IN ULONG          OpenOption)
/*++

Routine Description:

   This function adds a file object queue entry to the internal queue

Arguments:
   FileObj              -     pointer to the file object
   FilterDeviceObject   -     pointer to the dev obj for RsFilter
   PhData               -     pointer to the placeholder data
   OpenOption           -     File Open options from the Irp

Return Value:
  0 if queued ok
  non-zero otherwise

--*/
{
    PRP_FILE_OBJ            entry;
    ULONGLONG               filterId;
    PRP_FILE_CONTEXT        context;
    NTSTATUS                status = STATUS_FILE_IS_OFFLINE;
    PRP_FILTER_CONTEXT      filterContext;
    BOOLEAN                 gotLock = FALSE;

    PAGED_CODE();

    try {
        entry = (RP_FILE_OBJ *) ExAllocatePoolWithTag(NonPagedPool, sizeof(RP_FILE_OBJ), RP_RQ_TAG);
        if (NULL == entry) {
            RsLogError(__LINE__, AV_MODULE_RPFILFUN, sizeof(RP_FILE_OBJ),
                       AV_MSG_MEMORY, NULL, NULL);

            return(STATUS_INSUFFICIENT_RESOURCES);
        }


        RtlZeroMemory(entry, sizeof(RP_FILE_OBJ));

        entry->fileObj = FileObj;
        entry->devObj = FileObj->DeviceObject;
        ExInitializeResourceLite(&entry->resource);
        KeInitializeSpinLock(&entry->qLock);
        InitializeListHead(&entry->readQueue);
        InitializeListHead(&entry->writeQueue);
        entry->openOptions = OpenOption;
        entry->flags = RP_NO_DATA_ACCESS;
        //
        // Now see if there is a file context entry for this file
        // This call will create one if necessary, or return an already existing one.
        // The file context entry is locked when this call returns.
        //
        status = RsMakeContext(FileObj, &context);

        if (!NT_SUCCESS(status)) {
            RsLogError(__LINE__, AV_MODULE_RPFILFUN, sizeof(RP_FILE_OBJ),
                       AV_MSG_MEMORY, NULL, NULL);
            ExDeleteResourceLite(&entry->resource);
            ExFreePool(entry);
            return(status);
        }

        gotLock = TRUE;
        entry->fsContext = context;


        if (!(context->flags & RP_FILE_INITIALIZED)) {
            //
            // We have to initialize it here.
            //
            // Get the volume serial number
            if ((FileObj !=0) && (FileObj->Vpb != 0)) {
                context->serial = FileObj->Vpb->SerialNumber;
            } else if ((FileObj->DeviceObject != 0) && (FileObj->DeviceObject->Vpb!=0)) {
                context->serial = FileObj->DeviceObject->Vpb->SerialNumber;
            } else {
                RsLogError(__LINE__,
                           AV_MODULE_RPFILFUN,
                           0,
                           AV_MSG_SERIAL,
                           NULL,
                           NULL);
                ExDeleteResourceLite(&entry->resource);
                ExFreePool(entry);
                //
                // Deref the context
                //
                RsReleaseFileContext(context);
                gotLock = FALSE;

                return(STATUS_INVALID_PARAMETER);
            }
            InitializeListHead(&context->fileObjects);
            context->devObj = FileObj->DeviceObject;
	    context->FilterDeviceObject = FilterDeviceObject;
            KeInitializeSpinLock(&context->qLock);
            KeInitializeEvent(&context->recallCompletedEvent,
                              NotificationEvent,
                              FALSE);
            filterId = (ULONGLONG) InterlockedIncrement((PLONG) &RsFileContextId);

            if (RP_IS_NO_RECALL_OPTION(OpenOption)) {
                entry->filterId = (ULONGLONG) InterlockedIncrement((PLONG) &RsFileObjId);
                entry->filterId <<= 32;
                entry->filterId &= ~RP_TYPE_RECALL;
                filterId |= entry->filterId;
                RP_SET_NO_RECALL(entry);
            } else {
                filterId |= RP_TYPE_RECALL;
            }

            context->filterId = filterId;

            if (RP_FILE_IS_TRUNCATED(PhData->data.bitFlags)) {
                context->state = RP_RECALL_NOT_RECALLED;
                context->recallStatus = 0;
                context->currentOffset.QuadPart = 0;
            } else {
                // File is pre-migrated
                context->state = RP_RECALL_COMPLETED;
                context->recallStatus = STATUS_SUCCESS;
                context->currentOffset.QuadPart = 0;
            }

            if (NULL != PhData) {
                memcpy(&context->rpData, PhData, sizeof(RP_DATA));
            }

            context->flags |= RP_FILE_INITIALIZED;
        }


        //
        // Discard any existing filename to force an update of cached filename 
        // in case of renames since the original open.
        //
        if (context->uniName != NULL) {
            ExFreePool(context->uniName);
            context->uniName = NULL;
        }

	RsGetFileInfo(entry, FilterDeviceObject);


        filterContext= (PRP_FILTER_CONTEXT) ExAllocatePoolWithTag(NonPagedPool, sizeof(RP_FILTER_CONTEXT), RP_RQ_TAG);
        if (NULL == filterContext) {
            RsLogError(__LINE__, AV_MODULE_RPFILFUN, sizeof(RP_FILTER_CONTEXT),
                       AV_MSG_MEMORY, NULL, NULL);


            ExDeleteResourceLite(&entry->resource);
            ExFreePool(entry);

            RsReleaseFileContext(context);
            gotLock = FALSE;

            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        RtlZeroMemory(filterContext, sizeof(RP_FILTER_CONTEXT));
        FsRtlInitPerStreamContext(&filterContext->context,
                                  FsDeviceObject,
                                  FileObj,
                                  RsFreeFileObject);
        filterContext->myFileObjEntry = entry;


        status = FsRtlInsertPerStreamContext(FsRtlGetPerStreamContextPointer(FileObj), &filterContext->context);
        if (NT_SUCCESS(status)) {
            //
            // Now that we have gotten everything setup we can put it on the queue
            //
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsAddFileObj: Allocated filter context tag (%x : %x).\n",
                                  context, entry));

            ExInterlockedInsertTailList(&context->fileObjects, (PLIST_ENTRY) entry, &context->qLock);
            RsReleaseFileContextEntryLock(context);
            gotLock = FALSE;
        } else {
            //
            // Failed to add filter context.
            //
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_ERROR, "RsFilter: Failed to insert filter context %x.\n", status));

            RsReleaseFileContext(context);
            gotLock = FALSE;

            ExDeleteResourceLite(&entry->resource);
            ExFreePool(entry);
            ExFreePool(filterContext);
        }

    }except (RsExceptionFilter(L"RsAddFileObj",GetExceptionInformation())) {
        //
        // Something bad happened - just log an error and return
        //
        if (gotLock) {
            RsReleaseFileContext(context);
        }
        status = STATUS_UNEXPECTED_IO_ERROR;
    }

    return(status);
}


NTSTATUS
RsReleaseFileContext(IN PRP_FILE_CONTEXT Context)
/*++

Routine Description:

   This function frees a file context (if the refcount is zero).
   Lock the queue first then see if the refcount is zero.  If it is then
   remove the file object and free the memory.

Arguments:
   file context structure.

Return Value:
   STATUS_SUCCESS


--*/
{
    BOOLEAN            gotLock, found = FALSE;
    PRP_FILE_CONTEXT   entry;
    NTSTATUS           status = STATUS_SUCCESS;

    PAGED_CODE();

    try {
        RsAcquireFileContextQueueLock();
        gotLock = TRUE;

        entry = CONTAINING_RECORD(RsFileContextQHead.Flink,
                                  RP_FILE_CONTEXT,
                                  list);

        while (entry != CONTAINING_RECORD(&RsFileContextQHead,
                                          RP_FILE_CONTEXT,
                                          list)) {
            if (entry == Context) {
                //
                // Found this one
                //
                if (InterlockedDecrement((PLONG) &entry->refCount) == 0) {
                    //
                    // If the refcount is still zero then dequeue and free the entry.
                    //
                    DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsReleaseFileContext - Freeing file context %x\n", entry));

                    RemoveEntryList(&entry->list);
                    if (entry->uniName != NULL) {
                        ExFreePool(entry->uniName);
                        entry->uniName = NULL;
                    }
                    RsReleaseFileContextEntryLock(entry);
                    ExDeleteResourceLite(&entry->resource);
                    ExFreePool(entry);
                } else {
                    RsReleaseFileContextEntryLock(entry);
                }
                break;
            } else {
                entry = CONTAINING_RECORD(entry->list.Flink,
                                          RP_FILE_CONTEXT,
                                          list
                                         );
            }
        }
        RsReleaseFileContextQueueLock();
        gotLock = FALSE;
    }except (RsExceptionFilter(L"RsReleaseFileContext", GetExceptionInformation()))
    {
        if (gotLock) {
            RsReleaseFileContextQueueLock();
        }
    }
    return(status);
}


NTSTATUS
RsMakeContext(IN PFILE_OBJECT FileObj,
              OUT PRP_FILE_CONTEXT *Context)
/*++

Routine Description:

   This function finds or creates the file context entry for the given file object.
   Lock the queue first then see if there is already a context.  If not,
   allocate and initialize one.

Arguments:
   IN  file object
   OUT file context structure.

Return Value:
   STATUS_SUCCESS or error

--*/
{
    BOOLEAN            gotLock = FALSE, found = FALSE;
    PRP_FILE_CONTEXT   entry;
    NTSTATUS           status = STATUS_SUCCESS;

    PAGED_CODE();

    try {

        RsAcquireFileContextQueueLock();
        gotLock = TRUE;

        DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsMakeContext - Search the queue\n"));
        entry = CONTAINING_RECORD(RsFileContextQHead.Flink,
                                  RP_FILE_CONTEXT,
                                  list);

        while (entry != CONTAINING_RECORD(&RsFileContextQHead,
                                          RP_FILE_CONTEXT,
                                          list)) {
            if (entry->fsContext == FileObj->FsContext) {
                //
                // Found our file context entry
                //
                *Context = entry;
                InterlockedIncrement((PLONG) &entry->refCount);
                RsReleaseFileContextQueueLock();
                gotLock = FALSE;

                RsAcquireFileContextEntryLockExclusive(entry);
                found = TRUE;
                break;
            } else {
                entry = CONTAINING_RECORD(entry->list.Flink,
                                          RP_FILE_CONTEXT,
                                          list
                                         );
            }
        }

        if (!found) {
            //
            // None there - create one and put it in the list.
            //
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsMakeContext - Not found - create a new context.\n"));

            entry = ExAllocatePoolWithTag(NonPagedPool, sizeof(RP_FILE_CONTEXT), RP_RQ_TAG);
            if (entry != NULL) {
                RtlZeroMemory(entry, sizeof(RP_FILE_CONTEXT));
                *Context = entry;
                entry->fsContext = FileObj->FsContext;
                ExInitializeResourceLite(&entry->resource);
                RsAcquireFileContextEntryLockExclusive(entry);
                entry->refCount = 1;
                InsertTailList(&RsFileContextQHead,  &entry->list);
            } else {
                status = STATUS_INSUFFICIENT_RESOURCES;
                *Context = NULL;
            }

            RsReleaseFileContextQueueLock();
            gotLock = FALSE;
        } else {
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsMakeContext - found %x.\n", entry));
        }
    }except(RsExceptionFilter(L"RsMakeContext", GetExceptionInformation()))
    {
        if (gotLock) {
            RsReleaseFileContextQueueLock();
        }
    }
    return(status);
}


NTSTATUS
RsFreeFileObject(IN PLIST_ENTRY FilterContext)
/*++

Routine Description:

   This function frees a file object structure.  It is called by the file system
   when a file object is going away.  We need to find the file context and remove
   the file object entry from it's list.  If the refcount for file context is now
   0 then we free the file context entry also.

Arguments:
   file context structure.

Return Value:
   STATUS_SUCCESS


--*/
{
    PRP_FILTER_CONTEXT      rpFilterContext = (PRP_FILTER_CONTEXT) FilterContext;
    PRP_FILE_OBJ            rpFileObject    = rpFilterContext->myFileObjEntry;
    PRP_FILE_CONTEXT        rpFileContext   = rpFileObject->fsContext;
    BOOLEAN                 done            = FALSE;
    BOOLEAN                 gotLock         = FALSE;

    PAGED_CODE();


    try {
        DebugTrace ((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsFreeFileObject:  %x : %x.\n", 
		     rpFileContext, rpFileObject));


        //
        // Lock the file context entry
        //
        RsAcquireFileContextEntryLockExclusive (rpFileContext);
        gotLock = TRUE;


        //
        // Remove the file object entry and free it.
        //
        rpFileObject = CONTAINING_RECORD (rpFileContext->fileObjects.Flink, 
					  RP_FILE_OBJ,
					  list);

        while ((!done) && (rpFileObject != CONTAINING_RECORD (&rpFileContext->fileObjects, 
							      RP_FILE_OBJ,
							      list))) {

            if (rpFileObject == rpFilterContext->myFileObjEntry) {
		//
                done = TRUE;
                RemoveEntryList (&rpFileObject->list);

            } else {

                //
                // Move on to next file object
                //
                rpFileObject = CONTAINING_RECORD (rpFileObject->list.Flink,
						  RP_FILE_OBJ, 
						  list
						);
            }
        }


        if (done == TRUE) {

            //
            // If it is a normal recall and the recall has started but we have not written any data yet then
            // tell the FSA to cancel it.
            //
            if (!RP_IS_NO_RECALL (rpFileObject) && (rpFileContext->state != RP_RECALL_COMPLETED) && !(rpFileObject->flags & RP_NO_DATA_ACCESS)) {
                //
                // No I/O has been done to the file yet - tell the FSA to cancel
                //
                RsQueueCancel (rpFileObject->filterId | rpFileContext->filterId);
            }


#ifdef TRUNCATE_ON_CLOSE

            if (!RP_IS_NO_RECALL (rpFileObject)              && 
                (NULL != rpFileContext->fileObjectToWrite)   && 
                (rpFileContext->state  == RP_RECALL_STARTED) && 
                (rpFileObject->flags & RP_NO_DATA_ACCESS)) {
                //
                // IO has been started. If there are no more file objects referencing this context entry we
                // may as well stop the recall and re-truncate the file.
                //
                if (IsListEmpty (&rpFileContext->fileObjects)) {

                    DebugTrace ((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsFreeFileObject - Could truncate partially recalled file.\n"));

                    RsLogError (__LINE__, AV_MODULE_RPFILFUN, sizeof(RP_IRP_QUEUE),
				AV_MSG_CODE_HIT, NULL, L"Partial recall truncate");
                }
            }


            //
            // If the file was recalled and the action flag says so then truncate it now.
            // Do this if we are the only opener.
            //
            DebugTrace ((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsFreeFileObject - action = %x.\n", rpFileObject->recallAction));

            if ((!RP_IS_NO_RECALL (rpFileObject)) &&
                (rpFileContext->state == RP_RECALL_COMPLETED) &&
                (rpFileContext->recallStatus == STATUS_SUCCESS) &&
                (rpFileObject->recallAction & RP_RECALL_ACTION_TRUNCATE) &&
                (IsListEmpty (&rpFileContext->fileObjects))) {
                //
                // We have to reopen the file and truncate it now.  This happens when the FSA decides that a particular
                // client is recalling too many files.
                //
                RsTruncateOnClose(rpFileContext);
            }
#endif


            RsFreeUserSecurityInfo (rpFileObject->userSecurityInfo);
            ExDeleteResourceLite (&rpFileObject->resource);


            //
            // Deref/free the file context
            //
            RsReleaseFileContext (rpFileContext);
            gotLock = FALSE;
            ExFreePool (rpFileObject);

        } else {

            RsReleaseFileContextEntryLock (rpFileContext);
            gotLock = FALSE;
        }


        //
        // Always free the filter context pointer
        //
        ExFreePool(rpFilterContext);

    }except (RsExceptionFilter (L"RsFreeFileObject", GetExceptionInformation ()))
    {
        //
        // Something bad happened - just log an error and return
        //
        if (gotLock) {
            RsReleaseFileContextEntryLock (rpFileContext);
        }
    }

    return(STATUS_SUCCESS);
}



NTSTATUS
RsCheckRead(IN  PIRP Irp,
            IN  PFILE_OBJECT FileObject,
            IN  PDEVICE_EXTENSION DeviceExtension)

/*++

Routine Description:

   See if the file may be read.  Start the recall if it is not already started.  Either return OK
   or queue the read request.

Arguments:

    Irp             - Pointer to the read irp
    FileObject      - Pointer to the file object of the file
    DeviceExtension - Device extension for the RsFilter device object


Return Value:

    STATUS_SUCCESS      The read may be passed on down to the file system.
    STATUS_PENDING      The IRP has been queued pending a recall
    Any other status    An error occurred, caller should complete the IRP with this status

Note:

--*/
{
    NTSTATUS               retval = STATUS_FILE_IS_OFFLINE, qRet;
    BOOLEAN                gotLock = FALSE;
    PRP_FILE_OBJ           entry;
    PRP_FILE_CONTEXT       context;
    PRP_IRP_QUEUE          readIo;
    PIO_STACK_LOCATION     currentStack ;
    ULONGLONG              filterId;
    LONGLONG               start, size;
    PRP_FILTER_CONTEXT     filterContext;

    PAGED_CODE();

    filterContext = (PRP_FILTER_CONTEXT) FsRtlLookupPerStreamContext(FsRtlGetPerStreamContextPointer(FileObject), FsDeviceObject, FileObject);
    if (filterContext == NULL) {
        //
        // Not found - should not happen
        //
        return(STATUS_SUCCESS);
    }


    try {
        entry = (PRP_FILE_OBJ) filterContext->myFileObjEntry;
        context = entry->fsContext;

        ASSERT(FileObject == entry->fileObj);

        currentStack = IoGetCurrentIrpStackLocation (Irp) ;

        RsAcquireFileContextEntryLockExclusive(context);
        gotLock = TRUE;

        DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsCheckRead (%x : %x) - State = %u\n", context, entry, context->state));

        //
        // We found the entry - if the recall has not been started then start it now,
        // If it has already been started and we do not have to wait then return OK,
        // otherwise queue the read.

        ObReferenceObject(entry->fileObj);

        switch (context->state) {
        
        case RP_RECALL_COMPLETED: {

                if (context->recallStatus == STATUS_CANCELLED) {
                    //
                    // Previous recall was cancelled by user. Start another recall
                    // now
                    // So fall through deliberately to the NOT_RECALLED_CASE
                    //
                } else {
                    if (NT_SUCCESS(context->recallStatus)) {
                        //
                        // Recall is done
                        //
                        retval = STATUS_SUCCESS;
                    } else {
                        //
                        // Recall is done but it failed. We return the
                        // uniform status value STATUS_FILE_IS_OFFLINE
                        //
                        retval = STATUS_FILE_IS_OFFLINE;
                    }
                    RsReleaseFileContextEntryLock(context);
                    gotLock = FALSE;
                    ObDereferenceObject(entry->fileObj);
                    break;
                }
            }

        case RP_RECALL_NOT_RECALLED: {
                //
                // Start the recall here.
                // context Resource acquired
                //
                retval = STATUS_SUCCESS;
                RsAcquireFileObjectEntryLockExclusive(entry);

                readIo = ExAllocatePoolWithTag(NonPagedPool, sizeof(RP_IRP_QUEUE), RP_RQ_TAG);

                if (readIo == NULL) {
                    //
                    // Problem ...
                    DebugTrace((DPFLTR_RSFILTER_ID, DBG_ERROR, "RsFilter: RsCheckRead - No memory!\n"));

                    RsLogError(__LINE__, AV_MODULE_RPFILFUN, sizeof(RP_IRP_QUEUE),
                               AV_MSG_MEMORY, NULL, NULL);


                    //
                    // Release the locks
                    //
                    RsReleaseFileObjectEntryLock(entry);
                    RsReleaseFileContextEntryLock(context);
                    gotLock = FALSE;
                    ObDereferenceObject(entry->fileObj);
                    //
                    // Complete the read with an error.
                    //
                    retval = STATUS_FILE_IS_OFFLINE;
                    break;
                }

                RtlZeroMemory(readIo, sizeof(RP_IRP_QUEUE));

                DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsCheckRead - Queue Irp %x\n", Irp));

                readIo->irp = Irp;
                readIo->offset = currentStack->Parameters.Read.ByteOffset.QuadPart;
                readIo->length = currentStack->Parameters.Read.Length;
                readIo->deviceExtension = DeviceExtension;

                ExInterlockedInsertHeadList(&entry->readQueue, (PLIST_ENTRY) readIo, &entry->qLock);


                DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsCheckRead - After Q - Read Q: %u  Write Q %u\n",
                                      IsListEmpty(&entry->readQueue),
                                      IsListEmpty(&entry->writeQueue)));

                /*
                ** On a new recall ensure the entry id is bumped to
                ** allow for the case where the context state is reset
                ** to RP_RECALL_NOT_RECALLED such as happens when the
                ** user has reached the runaway recall limit. This may
                ** mean that we double increment the entry id but that
                ** is better than the alternative.  
                */
                entry->filterId = (ULONGLONG) InterlockedIncrement((PLONG) &RsFileObjId);
                entry->filterId <<= 32;
                entry->filterId |= RP_IS_NO_RECALL(entry) ? 0 : RP_TYPE_RECALL;

                filterId = context->filterId | entry->filterId;
                start = context->rpData.data.dataStreamStart.QuadPart;
                size =  context->rpData.data.dataStreamSize.QuadPart;
                RsReleaseFileObjectEntryLock(entry);
                //
                // Assume the worst
                //
                retval = STATUS_FILE_IS_OFFLINE;
                //
                // We are going to hold the Irp so set a cancel routing and mark it pending
                //
                context->state = RP_RECALL_STARTED;
                KeResetEvent(&context->recallCompletedEvent);
                RsReleaseFileContextEntryLock(context);
                gotLock = FALSE;
                //
                // Indicate to FSA we are going to recall it
                //
                qRet = RsQueueRecallOpen(context,
                                         entry,
                                         filterId,
                                         start,
                                         size,
                                         RP_OPEN_FILE);
                if (NT_SUCCESS(qRet)) {

                    DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsCheckRead - Queueing the recall (%I64x).\n", filterId));
                    qRet = RsQueueRecall(filterId, start, size);

                    if (NT_SUCCESS(qRet)) {
                        //
                        // Now we are ready to set the cancel routine
                        //
                        retval = RsSetCancelRoutine(Irp,
                                                    RsCancelReadRecall) ? STATUS_PENDING : STATUS_CANCELLED;
                    }
                }

                if (!NT_SUCCESS(qRet) || !NT_SUCCESS(retval)) {
                    //
                    // If it failed we need to fail this read and all others waiting on this recall.
                    // Since we unlocked the queue to start the recall we need to lock it again and walk through
                    // it to find all reads or writes that came in since we unlocked it.
                    //
                    DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsCheckRead - Failed to queue the recall.\n"));
                    //
                    // Pluck the current IRP out from the queue, that we added just now
                    // It will be completed  by the caller (the cancel routine wasn't set for
                    // this IRP yet, so we can safely remove it)
                    //
                    RsAcquireFileObjectEntryLockExclusive(entry);
                    RsInterlockedRemoveEntryList(&readIo->list,
                                                 &entry->qLock);
                    RsReleaseFileObjectEntryLock(entry);
                    ExFreePool(readIo);

                    RsAcquireFileContextEntryLockExclusive(context);
                    gotLock = TRUE;
                    context->state = RP_RECALL_NOT_RECALLED;
                    //
                    // If we got as far as queuing the recall, then we should not
                    // fail the other IRPs.
                    //
                    if (!NT_SUCCESS(qRet)) {
                        RsFailAllRequests(context, FALSE);
                    }
                    RsReleaseFileContextEntryLock(context);

                    retval = STATUS_FILE_IS_OFFLINE;
                    gotLock = FALSE;
                }
                DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsCheckRead - Queued the recall.\n"));
                ObDereferenceObject(entry->fileObj);
                break;
            }

        case RP_RECALL_STARTED: {
                //
                // Let the read complete if the data is available and no writes have been issued..
                // Must check if write is within portion of the file already recalled OR if the file has been recalled in full
                // but the state had not changed yet we let the read go anyway - they may be reading beyond the end of the file.
                //
                if (!(context->flags & RP_FILE_WAS_WRITTEN) &&
                    ((context->currentOffset.QuadPart >=
                      (currentStack->Parameters.Read.ByteOffset.QuadPart + currentStack->Parameters.Read.Length)) ||
                     (context->currentOffset.QuadPart == context->recallSize.QuadPart))) {

                    DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsCheckRead - Data for this read is available - let it go (flags = %x).\n",
                                          entry->fileObj->Flags));
                    retval = STATUS_SUCCESS;
                    RsReleaseFileContextEntryLock(context);
                    gotLock = FALSE;
                    ObDereferenceObject(entry->fileObj);
                    break;
                }
                //
                // Wait for the recall to complete before allowing any reads
                // Once we get this stable we can try and let reads complete as the
                // data is available.
                //
                // context entry acquired.
                readIo = ExAllocatePoolWithTag(NonPagedPool, sizeof(RP_IRP_QUEUE), RP_RQ_TAG);
                if (readIo == NULL) {
                    //

                    DebugTrace((DPFLTR_RSFILTER_ID,DBG_ERROR, "RsFilter: RsCheckRead - No memory!\n"));

                    RsLogError(__LINE__, AV_MODULE_RPFILFUN, sizeof(RP_IRP_QUEUE),
                               AV_MSG_MEMORY, NULL, NULL);

                    RsReleaseFileContextEntryLock(context);
                    gotLock = FALSE;
                    ObDereferenceObject(entry->fileObj);
                    retval = STATUS_FILE_IS_OFFLINE;
                    break;
                }

                RsAcquireFileObjectEntryLockExclusive(entry);
                RtlZeroMemory(readIo, sizeof(RP_IRP_QUEUE));

                //
                // We are going to hold the Irp..
                //
                DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsCheckRead - Queue Irp %x\n", Irp));
                readIo->irp = Irp;
                readIo->offset = currentStack->Parameters.Read.ByteOffset.QuadPart;
                readIo->length = currentStack->Parameters.Read.Length;
                readIo->deviceExtension = DeviceExtension;
                readIo->flags = 0;
                ExInterlockedInsertHeadList(&entry->readQueue, (PLIST_ENTRY) readIo, &entry->qLock);
                if (RsSetCancelRoutine(Irp,
                                       (PVOID) RsCancelReadRecall)) {
                    retval = STATUS_PENDING;
                    filterId = context->filterId | entry->filterId;
                    qRet = RsQueueRecallOpen(context,
                                             entry,
                                             filterId,
                                             0,0,
                                             RP_RECALL_WAITING);
                } else {
                    RsInterlockedRemoveEntryList(&readIo->list,
                                                 &entry->qLock);
                    retval = STATUS_CANCELLED;
                }


                RsReleaseFileObjectEntryLock(entry);
                RsReleaseFileContextEntryLock(context);
                gotLock = FALSE;
                ObDereferenceObject(entry->fileObj);
                break;
            }

        default: {
                //
                // Something strange - Fail the read
                //
                RsLogError(__LINE__, AV_MODULE_RPFILFUN, context->state,
                           AV_MSG_UNEXPECTED_ERROR, NULL, NULL);
                RsReleaseFileContextEntryLock(context);
                gotLock = FALSE;
                ObDereferenceObject(entry->fileObj);
                retval = STATUS_FILE_IS_OFFLINE;
                break;
            }
        }

        if (gotLock == TRUE) {
            RsReleaseFileContextEntryLock(context);
            gotLock = FALSE;
        }
    }except (RsExceptionFilter(L"RsCheckRead", GetExceptionInformation()))
    {
        //
        // Something bad happened - just log an error and return
        //
        if (gotLock) {
            RsReleaseFileContextEntryLock(context);
            gotLock = FALSE;
        }
        retval = STATUS_INVALID_USER_BUFFER;
    }

    return(retval);
}


NTSTATUS
RsCheckWrite(IN  PIRP Irp,
             IN  PFILE_OBJECT FileObject,
             IN  PDEVICE_EXTENSION DeviceExtension)
/*++

Routine Description:

   See if the file may be read.  Start the recall if it is not already started.  Either return OK
   or queue the read request.

Arguments:

    Irp             - Pointer to the write irp
    FileObject      - Pointer to the file object of the file
    DeviceExtension - Device extension for the RsFilter device object


Return Value:

    STATUS_SUCCESS      The read may be passed on down to the file system.
    STATUS_PENDING      The IRP has been queued pending a recall
    Any other status    An error occurred, caller should complete the IRP with this status

Note:

--*/
{
    NTSTATUS               retval = STATUS_FILE_IS_OFFLINE, qRet;
    BOOLEAN                gotLock = FALSE;
    PRP_FILE_OBJ           entry;
    PRP_FILE_CONTEXT       context;
    PRP_IRP_QUEUE          writeIo;
    PIO_STACK_LOCATION     currentStack ;
    ULONGLONG              filterId;
    LONGLONG               start, size;
    PRP_FILTER_CONTEXT     filterContext;

    PAGED_CODE();

    filterContext = (PRP_FILTER_CONTEXT) FsRtlLookupPerStreamContext(FsRtlGetPerStreamContextPointer(FileObject), FsDeviceObject, FileObject);

    if (filterContext == NULL) {
        //
        // Not found - should this be STATUS_FILE_IS_OFFLINE?
        //
        return STATUS_SUCCESS;
    }

    try {
        entry = (PRP_FILE_OBJ) filterContext->myFileObjEntry;
        context = entry->fsContext;

        ASSERT(FileObject == entry->fileObj);

        currentStack = IoGetCurrentIrpStackLocation (Irp) ;

        RsAcquireFileContextEntryLockExclusive(context);
        gotLock = TRUE;

        context->flags |= RP_FILE_WAS_WRITTEN;

        DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsCheckWrite (%x : %x) - State = %u\n", context, entry, context->state));

        //
        // We found the entry - if the recall has not been started then start it now,
        // If it has already been started and we do not have to wait then return OK,
        // otherwise queue the read.

        ObReferenceObject(entry->fileObj);

        switch (context->state) {
        
        case RP_RECALL_COMPLETED: {

                if (context->recallStatus == STATUS_CANCELLED) {
                    //
                    // Previous recall was cancelled by user. Start another recall
                    // now
                    // So fall through deliberately to the NOT_RECALLED_CASE
                    //
                } else {
                    if (NT_SUCCESS(context->recallStatus)) {
                        if (!(context->flags & RP_FILE_REPARSE_POINT_DELETED)) {
                            RsReleaseFileContextEntryLock(context);
                            gotLock = FALSE;

                            retval = RsDeleteReparsePoint(context);

                            if (!NT_SUCCESS(retval)) {
                                RsLogError(__LINE__,
                                           AV_MODULE_RPFILFUN,
                                           retval,
                                           AV_MSG_DELETE_REPARSE_POINT_FAILED,
                                           NULL,
                                           NULL);
                            } else {
                                RsAcquireFileContextEntryLockExclusive(context);
                                gotLock = TRUE;
                                context->flags |= RP_FILE_REPARSE_POINT_DELETED;
                                RsReleaseFileContextEntryLock(context);
                                gotLock = FALSE;
                            }
                        } else {
                            RsReleaseFileContextEntryLock(context);
                            gotLock = FALSE;
                        }
                        retval = STATUS_SUCCESS;
                    } else {
                        //
                        // Recall is done but it failed. We return
                        // the uniform status STATUS_FILE_IS_OFFLINE;
                        //
                        RsReleaseFileContextEntryLock(context);
                        gotLock = FALSE;
                        retval = STATUS_FILE_IS_OFFLINE;
                    }
                    ObDereferenceObject(entry->fileObj);
                    break;
                }
            }

        case RP_RECALL_NOT_RECALLED: {
                //
                // Start the recall here.
                // context Resource acquired
                //
                retval = STATUS_SUCCESS;
                qRet = STATUS_SUCCESS;
                RsAcquireFileObjectEntryLockExclusive(entry);

                writeIo = ExAllocatePoolWithTag(NonPagedPool, sizeof(RP_IRP_QUEUE), RP_RQ_TAG);
                if (writeIo == NULL) {
                    //
                    // Problem ...
                    DebugTrace((DPFLTR_RSFILTER_ID, DBG_ERROR, "RsFilter: RsCheckWrite - No memory!\n"));

                    RsLogError(__LINE__, AV_MODULE_RPFILFUN, sizeof(RP_IRP_QUEUE),
                               AV_MSG_MEMORY, NULL, NULL);
                    //
                    // Release the locks
                    //
                    RsReleaseFileObjectEntryLock(entry);
                    RsReleaseFileContextEntryLock(context);
                    gotLock = FALSE;
                    ObDereferenceObject(entry->fileObj);
                    //
                    // Complete the read with an error.
                    //
                    retval = STATUS_FILE_IS_OFFLINE;
                    break;
                }

                RtlZeroMemory(writeIo, sizeof(RP_IRP_QUEUE));
                //
                // We are going to hold the Irp
                //
                DebugTrace((DPFLTR_RSFILTER_ID, DBG_INFO, "RsFilter: RsCheckWrite - Queue Irp %x\n", Irp));

                writeIo->irp = Irp;
                writeIo->offset = currentStack->Parameters.Read.ByteOffset.QuadPart;
                writeIo->length = currentStack->Parameters.Read.Length;
                writeIo->deviceExtension = DeviceExtension;

                ExInterlockedInsertHeadList(&entry->writeQueue, (PLIST_ENTRY) writeIo, &entry->qLock);

                DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsCheckWrite - After Q - Read Q: %u  Write Q %u\n",
                           IsListEmpty(&entry->readQueue),
                           IsListEmpty(&entry->writeQueue)));



                //
                // Even if this is a no-recall file we 
                // need to indicate to FSA a normal recall will happen
                //     We have to do this on a write - because the file would
                // be normally in a no-recall mode till the first write
                // We don't have this issue with a read - because a recall
                // would be queued on the read ONLY if the file was explicitly
                // opened with recall on data access. This would mean that the
                // recall intent is posted to FSA at create time itself
                //
                entry->filterId = (ULONGLONG) InterlockedIncrement((PLONG) &RsFileObjId);
                entry->filterId <<= 32;
                entry->filterId |= RP_TYPE_RECALL;


                filterId = context->filterId | entry->filterId;
                start = context->rpData.data.dataStreamStart.QuadPart;
                size =  context->rpData.data.dataStreamSize.QuadPart;


                RsReleaseFileObjectEntryLock(entry);
                //
                // Assume the worst
                //
                retval  = STATUS_FILE_IS_OFFLINE;

                context->state = RP_RECALL_STARTED;
                KeResetEvent(&context->recallCompletedEvent);

                RsReleaseFileContextEntryLock(context);
                gotLock = FALSE;
                //
                // Indicate to FSA we are going to recall it
                //
                qRet = RsQueueRecallOpen(context,
                                         entry,
                                         filterId,
                                         start,
                                         size,
                                         RP_OPEN_FILE);

                if (NT_SUCCESS(qRet)) {

                    DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsCheckWrite - Queueing the recall.\n"));

                    qRet = RsQueueRecall(filterId, start, size);

                    if (NT_SUCCESS(qRet)) {
                        //
                        // Now we're ready to set the cancel routine for the IRP
                        //
                        retval = RsSetCancelRoutine(Irp,
                                                    (PVOID) RsCancelWriteRecall) ? STATUS_PENDING : STATUS_CANCELLED;
                    }
                }

                if (!NT_SUCCESS(qRet) || !NT_SUCCESS(retval)) {
                    //
                    // If it failed we need to fail this read and all others waiting on this recall.
                    // Since we unlocked the queue to start the recall we need to lock it again and walk through
                    // it to find all reads or writes that came in since we unlocked it.
                    //
                    DebugTrace((DPFLTR_RSFILTER_ID,DBG_ERROR, "RsFilter: RsCheckWrite - Failed to queue the recall.\n"));

                    //
                    // Pluck the current IRP out from the queue, that we added just now
                    // It will be completed  by the caller
                    //
                    RsAcquireFileObjectEntryLockExclusive(entry);
                    RsInterlockedRemoveEntryList(&writeIo->list,
                                                 &entry->qLock);
                    RsReleaseFileObjectEntryLock(entry);

                    RsAcquireFileContextEntryLockExclusive(context);
                    gotLock = TRUE;
                    context->state = RP_RECALL_NOT_RECALLED;
                    //
                    // If we got as far as queueing the recall, we
                    // should not be failing the other IRPs
                    //
                    if (!NT_SUCCESS(qRet)) {
                        RsFailAllRequests(context, FALSE);
                    }
                    RsReleaseFileContextEntryLock(context);
                    gotLock = FALSE;
                    retval = STATUS_FILE_IS_OFFLINE;
                    ExFreePool(writeIo);
                }
                DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsCheckWrite - Queued the recall.\n"));
                ObDereferenceObject(entry->fileObj);
                break;
            }

        case RP_RECALL_STARTED: {
                //
                // Always wait for the recall to complete before allowing any reads
                // Once we get this stable we can try and let reads complete as the
                // data is available.
                //
                // context entry acquired.

                writeIo = ExAllocatePoolWithTag(NonPagedPool, sizeof(RP_IRP_QUEUE), RP_RQ_TAG);
                if (writeIo == NULL) {
                    //

                    DebugTrace((DPFLTR_RSFILTER_ID,DBG_ERROR, "RsFilter: RsCheckWrite - No memory!\n"));

                    RsLogError(__LINE__, AV_MODULE_RPFILFUN, sizeof(RP_IRP_QUEUE),
                               AV_MSG_MEMORY, NULL, NULL);


                    RsReleaseFileContextEntryLock(context);
                    gotLock = FALSE;
                    ObDereferenceObject(entry->fileObj);
                    retval = STATUS_FILE_IS_OFFLINE ;
                    break;
                }

                RtlZeroMemory(writeIo, sizeof(RP_IRP_QUEUE));

                RsAcquireFileObjectEntryLockExclusive(entry);
                //
                // We are going to hold the Irp
                //
                DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsCheckWrite - Queue Irp %x\n", Irp));
                writeIo->irp = Irp;
                writeIo->offset = currentStack->Parameters.Read.ByteOffset.QuadPart;
                writeIo->length = currentStack->Parameters.Read.Length;
                writeIo->deviceExtension = DeviceExtension;
                writeIo->flags = 0;
                ExInterlockedInsertHeadList(&entry->writeQueue, (PLIST_ENTRY) writeIo, &entry->qLock);
                if (RsSetCancelRoutine(Irp,
                                       (PVOID) RsCancelWriteRecall)) {
                    retval = STATUS_PENDING;
                    filterId = context->filterId | entry->filterId;
                    qRet = RsQueueRecallOpen(context,
                                             entry,
                                             filterId,
                                             0,0,
                                             RP_RECALL_WAITING);
                } else {
                    RsInterlockedRemoveEntryList(&writeIo->list,
                                                 &entry->qLock);
                    retval = STATUS_CANCELLED;
                }
                RsReleaseFileObjectEntryLock(entry);
                RsReleaseFileContextEntryLock(context);
                gotLock = FALSE;
                ObDereferenceObject(entry->fileObj);
                break;
            }

        default: {
                //
                // Something strange - Fail the write
                //
                RsLogError(__LINE__, AV_MODULE_RPFILFUN, context->state,
                           AV_MSG_UNEXPECTED_ERROR, NULL, NULL);

                RsReleaseFileContextEntryLock(context);
                gotLock = FALSE;
                ObDereferenceObject(entry->fileObj);
                retval = STATUS_FILE_IS_OFFLINE;
                break;
            }
        }

        if (gotLock == TRUE) {
            RsReleaseFileContextEntryLock(context);
            gotLock = FALSE;
        }

    }except (RsExceptionFilter(L"RsCheckWrite", GetExceptionInformation()))
    {
        //
        // Something bad happened - just log an error and return
        //
        if (gotLock) {
            RsReleaseFileContextEntryLock(context);
        }
        retval = STATUS_INVALID_USER_BUFFER;
    }

    return(retval);
}


BOOLEAN
RsIsFileObj(IN  PFILE_OBJECT FileObj,
            IN  BOOLEAN      ReturnContextData,
            OUT PRP_DATA *RpData,
            OUT POBJECT_NAME_INFORMATION *Str,
            OUT LONGLONG *FileId,
            OUT LONGLONG *ObjIdHi,
            OUT LONGLONG *ObjIdLo,
            OUT ULONG *Options,
            OUT ULONGLONG *FilterId,
            OUT USN       *Usn)
/*++

Routine Description:

    Determine if a file object is on the queue,
    and return context data if required


Arguments:

   FileObj           - Pointer to the file object being tested
   ReturnContextData - If TRUE, context data from the filter context is returned
                       via the next few parameters
   RpData            - If not NULL, this will be filled with a pointer to the reparse point data
   (so on - each of the other arguments, if non null, will be filled with the relevant data)
   .....
   ......

Return Value:

   TRUE -   file object is managed by HSM and found in the queue.
   FALSE  othersise


--*/
{
    BOOLEAN                retval = TRUE;
    PRP_FILTER_CONTEXT     filterContext;
    PRP_FILE_OBJ           entry;
    PRP_FILE_CONTEXT       context;
    BOOLEAN                gotLock = FALSE;

    filterContext = (PRP_FILTER_CONTEXT) FsRtlLookupPerStreamContext (FsRtlGetPerStreamContextPointer(FileObj), 
								      FsDeviceObject, 
								      FileObj);
    if (filterContext == NULL) {
        //
        // Not found
        return(FALSE);
    }


    entry = (PRP_FILE_OBJ) filterContext->myFileObjEntry;
    context = entry->fsContext;

    if (context->fileObjectToWrite == FileObj) {
        //
        // Do not look at writes for this file object
        //
        return(FALSE);
    }



    try {
        if (ReturnContextData) {
            RsAcquireFileContextEntryLockShared(context);
            RsAcquireFileObjectEntryLockShared(entry);
            gotLock = TRUE;

            if (RpData) {
                *RpData = &context->rpData;
            }

            if (Str != NULL) {
                *Str = context->uniName;
            }
            if (FileId != NULL) {
                *FileId = entry->fileId;
            }
            if (ObjIdLo != NULL) {
                *ObjIdLo = entry->objIdLo;
            }

            if (ObjIdHi != NULL) {
                *ObjIdHi = entry->objIdHi;
            }

            if (Options != NULL) {
                *Options = entry->openOptions;
            }

            if (FilterId != NULL) {
                *FilterId = context->filterId;
            }

            if (Usn != NULL) {
                *Usn = context->usn;
            }

            RsReleaseFileContextEntryLock(context);
            RsReleaseFileObjectEntryLock(entry);
            gotLock = FALSE;
        }
    }except (RsExceptionFilter(L"RsIsFileObj", GetExceptionInformation()))
    {
        //
        // Something bad happened - just log an error and return
        //
        if (gotLock) {
            RsReleaseFileContextEntryLock(context);
            RsReleaseFileObjectEntryLock(entry);
        }
        retval = FALSE;
    }


    return(retval);
}


NTSTATUS
RsQueueRecall(IN ULONGLONG FilterId,
              IN ULONGLONG RecallStart,
              IN ULONGLONG RecallSize)
/*++

Routine Description:

   This function starts a recall for the specified offset and length

Arguments:
   filterID
   offset and length

Return Value:
  0 if queued ok
  non-zero otherwise



--*/
{
    ULONG                   retval;
    RP_MSG                  *msg;
    PIRP                    ioIrp;
    PIO_STACK_LOCATION      irpSp;

    PAGED_CODE();

    try {
        //
        // If the FSA is not running then fail right away.
        //
        if (FALSE == RsAllowRecalls) {
            return(STATUS_FILE_IS_OFFLINE);
        }
        //
        // Get a free IOCTL
        //
        ioIrp = RsGetFsaRequest();

        if (NULL != ioIrp) {

            if (NULL != ioIrp->AssociatedIrp.SystemBuffer) {
                msg = (RP_MSG *) ioIrp->AssociatedIrp.SystemBuffer;
                msg->inout.command = RP_RECALL_FILE;
                msg->msg.rReq.filterId = FilterId;
                msg->msg.rReq.offset = RecallStart;
                msg->msg.rReq.length = RecallSize;
                msg->msg.rReq.threadId = HandleToUlong(PsGetCurrentThreadId());
            }

            // Complete a device IOCTL to let the WIN32 code know we have
            // one ready to go.
            //
            irpSp = IoGetCurrentIrpStackLocation(ioIrp);
            ioIrp->IoStatus.Status = STATUS_SUCCESS;
            ioIrp->IoStatus.Information = irpSp->Parameters.DeviceIoControl.OutputBufferLength;

            DebugTrace((DPFLTR_RSFILTER_ID, DBG_INFO, "RsFilter: RsQueueRecall - complete FSA IOCTL.\n"));

            IoCompleteRequest(ioIrp, IO_NO_INCREMENT);
            retval = STATUS_SUCCESS;
        } else {
            retval = STATUS_INSUFFICIENT_RESOURCES;
        }
    }except (RsExceptionFilter(L"RsQueueRecall", GetExceptionInformation())) {
        retval = STATUS_UNEXPECTED_IO_ERROR;
    }
    return(retval);
}


NTSTATUS
RsQueueNoRecall(IN PFILE_OBJECT FileObject,
                IN PIRP         Irp,
                IN ULONGLONG    RecallStart,
                IN ULONGLONG    RecallSize,
                IN ULONG        BufferOffset,
                IN ULONG        BufferLength,
                IN PRP_FILE_BUF CacheBuffer OPTIONAL,
                IN PVOID        UserBuffer)
/*++

Routine Description:

   This function starts a recall for the specified offset and length

Arguments:

   FileObject   - Pointer to file object
   Irp          - IRP associated with the recall
   RecallStart  - This is the start offset of the actuall recall in the file
   RecallSize   - Length of bytes needed to be recalled
   BufferOffset -  This is the offset at which the caller actually needs data
                   to be copied into the user buffer. This is >= the RecallStart
                   offset.
   BufferLength - Length of data the user actually needs. This is <= RecallSize
   CacheBuffer  - If present, this is the cache buffer associated with the recall
                  (into which the recall data will be copied )
   UserBuffer   - UserBuffer for the data

Return Value:
  0 if queued ok
  non-zero otherwise
--*/
{
    RP_MSG                   *msg;
    PIRP                     ioIrp;
    PIO_STACK_LOCATION       irpSp;
    PRP_IRP_QUEUE            readIo;
    ULONGLONG                readId;
    LARGE_INTEGER            combinedId;
    PRP_FILTER_CONTEXT       filterContext;
    PRP_FILE_OBJ             entry;
    PRP_FILE_CONTEXT         context;
    NTSTATUS                 retval;

    PAGED_CODE();

    filterContext = (PRP_FILTER_CONTEXT) FsRtlLookupPerStreamContext(FsRtlGetPerStreamContextPointer(FileObject), FsDeviceObject, FileObject);
    if (filterContext == NULL) {
        //
        // Not found
        return(STATUS_NOT_FOUND);
    }

    entry = (PRP_FILE_OBJ) filterContext->myFileObjEntry;
    context = entry->fsContext;

    try {
        //
        // If the FSA is not running then fail right away.
        //
        if (FALSE == RsAllowRecalls) {
            return(STATUS_FILE_IS_OFFLINE);
        }
        readId = InterlockedIncrement((PLONG) &RsNoRecallReadId);
        readId &= RP_READ_MASK;

        //
        // We have to queue a fake open to get the filter ID correct in the FSA
        // then we queue the recall for the read we need.
        //

        combinedId.QuadPart = context->filterId;
        combinedId.HighPart |= (ULONG) readId;

        if ((retval = RsQueueNoRecallOpen(entry,
                                          combinedId.QuadPart,
                                          RecallStart,
                                          RecallSize)) != STATUS_SUCCESS) {
            return(retval);
        }

        readIo = ExAllocatePoolWithTag(NonPagedPool, sizeof(RP_IRP_QUEUE), RP_RQ_TAG);

        if (readIo == NULL) {
            //
            // Problem ...
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_ERROR, "RsFilter: RsQueueNoRecall - No memory!\n"));

            RsLogError(__LINE__, AV_MODULE_RPFILFUN, sizeof(RP_IRP_QUEUE),
                       AV_MSG_MEMORY, NULL, NULL);
            return(STATUS_INSUFFICIENT_RESOURCES);
        }
        //
        // Get a free IOCTL to queue the recall
        //
        ioIrp = RsGetFsaRequest();

        if (ioIrp == NULL) {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        RtlZeroMemory(readIo, sizeof(RP_IRP_QUEUE));

        readIo->readId = readId;
        readIo->irp = Irp;
        readIo->irp->IoStatus.Information = 0;
        readIo->cacheBuffer = CacheBuffer;
        readIo->userBuffer =  UserBuffer;
        readIo->offset = BufferOffset;
        readIo->length = BufferLength;
        readIo->recallOffset = RecallStart;
        readIo->recallLength = RecallSize;
        readIo->flags  |= RP_IRP_NO_RECALL;

        ExInterlockedInsertHeadList(&entry->readQueue,
                                    (PLIST_ENTRY) readIo,
                                    &entry->qLock);

        DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsQueueNoRecall - Irp %x was queued.\n", readIo->irp));

        msg = (RP_MSG *) ioIrp->AssociatedIrp.SystemBuffer;
        msg->inout.command = RP_RECALL_FILE;
        msg->msg.rReq.filterId = combinedId.QuadPart;
        msg->msg.rReq.offset = RecallStart;
        msg->msg.rReq.length = RecallSize;
        msg->msg.rReq.threadId = HandleToUlong(PsGetCurrentThreadId());
        //
        // Complete a device IOCTL to let the WIN32 code know we have
        // one ready to go.
        //
        // We're going to hold this IRP: set the cancel routine here
        //
        if (!RsSetCancelRoutine(Irp, (PVOID) RsCancelReadRecall)) {
            RsInterlockedRemoveEntryList(&readIo->list,
                                         &entry->qLock);
            //
            // Add back the now unused FSA request to the queue
            //
            RsAddIo(ioIrp);
            //
            // This was cancelled
            //
            retval =  STATUS_CANCELLED;
        } else {
            ioIrp->IoStatus.Status = STATUS_SUCCESS;
            irpSp = IoGetCurrentIrpStackLocation(ioIrp);
            ioIrp->IoStatus.Information = irpSp->Parameters.DeviceIoControl.OutputBufferLength;
            IoCompleteRequest(ioIrp, IO_NO_INCREMENT);
            retval = STATUS_PENDING;
        }
    }except (RsExceptionFilter(L"RsQueueNoRecall", GetExceptionInformation())) {
        //
        // Something bad happened - just log an error and return
        //
        retval = STATUS_UNEXPECTED_IO_ERROR;
    }

    return(retval);
}


NTSTATUS
RsQueueNoRecallOpen(IN PRP_FILE_OBJ Entry,
                    IN ULONGLONG    FilterId,
                    IN ULONGLONG    Offset,
                    IN ULONGLONG    Size)
/*++

Routine Description:

   Queue a request for a no-recall recall

Arguments:
   file object entry (locked)
   filterID
   offset and length

Return Value:

   Status

--*/
{
    NTSTATUS                 retval;
    RP_MSG                   *msg;
    PIRP                     ioIrp;
    PIO_STACK_LOCATION       irpSp;
    PRP_FILE_CONTEXT         context;

    PAGED_CODE();

    DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter:   RsQueueNoRecallOpen.\n"));

    ioIrp = RsGetFsaRequest();

    if (NULL != ioIrp) {
        context = Entry->fsContext;
        DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter:   RsQueueNoRecallOpen - context %x.\n", context));
        RsAcquireFileContextEntryLockShared(context);
        RsAcquireFileObjectEntryLockExclusive(Entry);

        if (NULL != ioIrp->AssociatedIrp.SystemBuffer) {
            msg = (RP_MSG *) ioIrp->AssociatedIrp.SystemBuffer;
            msg->inout.command = RP_OPEN_FILE;
            if (context->uniName != NULL) {
                msg->msg.oReq.nameLen = context->uniName->Name.Length + sizeof(WCHAR);  // Account for the NULL
            } else {
                msg->msg.oReq.nameLen = 0;
            }
            msg->msg.oReq.filterId = FilterId;
            msg->msg.oReq.options = Entry->openOptions;
            msg->msg.oReq.objIdHi = Entry->objIdHi;
            msg->msg.oReq.objIdLo = Entry->objIdLo;
            msg->msg.oReq.offset.QuadPart = Offset;
            msg->msg.oReq.size.QuadPart = Size;
            msg->msg.oReq.userInfoLen  = Entry->userSecurityInfo->userInfoLen;
            msg->msg.oReq.userInstance = Entry->userSecurityInfo->userInstance;
            msg->msg.oReq.userAuthentication = Entry->userSecurityInfo->userAuthentication;
            msg->msg.oReq.tokenSourceId = Entry->userSecurityInfo->tokenSourceId;
            msg->msg.oReq.isAdmin = (Entry->flags & RP_OPEN_BY_ADMIN);
            msg->msg.oReq.localProc =(Entry->flags & RP_OPEN_LOCAL);

            msg->msg.oReq.serial = context->serial;

            memcpy(&msg->msg.oReq.eaData, &context->rpData, sizeof(RP_DATA));
            //
            // Complete a device IOCTL to let the WIN32 code know we have
            // one ready to go.
            //
            irpSp = IoGetCurrentIrpStackLocation(ioIrp);
            ioIrp->IoStatus.Status = STATUS_SUCCESS;
            ioIrp->IoStatus.Information = irpSp->Parameters.DeviceIoControl.OutputBufferLength;

            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter:   RsQueueNoRecallOpen queue open for ID %I64x.\n", FilterId));
            IoCompleteRequest(ioIrp, IO_NO_INCREMENT);
            retval = STATUS_SUCCESS;

        } else {
            ioIrp->IoStatus.Status = STATUS_INVALID_USER_BUFFER;
            ioIrp->IoStatus.Information = 0;
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_ERROR, "RsFilter:   RsQueueNoRecallOpen IO request had invalid buffer - %p.\n", ioIrp->AssociatedIrp.SystemBuffer));
            RsLogError(__LINE__, AV_MODULE_RPFILFUN, 0 ,
                       AV_MSG_UNEXPECTED_ERROR, NULL, NULL);
            IoCompleteRequest(ioIrp, IO_NO_INCREMENT);
            retval = STATUS_INVALID_USER_BUFFER;
        }
        RsReleaseFileContextEntryLock(context);
        RsReleaseFileObjectEntryLock(Entry);
    } else {
        retval = STATUS_INSUFFICIENT_RESOURCES;
    }

    return(retval);
}


NTSTATUS
RsQueueRecallOpen(IN PRP_FILE_CONTEXT Context,
                  IN PRP_FILE_OBJ Entry,
                  IN ULONGLONG    FilterId,
                  IN ULONGLONG    Offset,
                  IN ULONGLONG    Size,
                  IN ULONG        Command)
/*++

Routine Description:

   Queue a request for a recall

Arguments:
   file object entry (locked)
   filterID
   offset and length

Return Value:
  0 if queued ok
  non-zero otherwise

--*/
{
    PIRP                      ioIrp;
    PRP_MSG                   msg;
    NTSTATUS                  retval;
    PIO_STACK_LOCATION        irpSp;

    PAGED_CODE();

    DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter:   RsQueueRecallOpen.\n"));

    //
    // If the request is to send a recall waiting notification and one has already 
    // been sent for this recall instance then there is no need to send another.
    //
    if (Entry->flags & RP_NOTIFICATION_SENT) {

        retval = STATUS_SUCCESS;

    } else {

        ioIrp = RsGetFsaRequest();

        if (NULL != ioIrp) {
            if (NULL != ioIrp->AssociatedIrp.SystemBuffer) {
                msg = (RP_MSG *) ioIrp->AssociatedIrp.SystemBuffer;
                msg->inout.command = Command;
                ASSERT (Context->uniName != NULL);
                msg->msg.oReq.nameLen = Context->uniName->Name.Length + sizeof(WCHAR);  // Account for a NULL
                msg->msg.oReq.filterId = FilterId;
                msg->msg.oReq.options = Entry->openOptions;
                msg->msg.oReq.fileId = Context->fileId;
                msg->msg.oReq.objIdHi = Entry->objIdHi;
                msg->msg.oReq.objIdLo = Entry->objIdLo;
                msg->msg.oReq.offset.QuadPart = Offset;
                msg->msg.oReq.size.QuadPart = Size;
                msg->msg.oReq.serial = Context->serial;

                memcpy(&msg->msg.oReq.eaData, &Context->rpData, sizeof(RP_DATA));
                //
                // Get user info 
                //
                msg->msg.oReq.userInfoLen  = Entry->userSecurityInfo->userInfoLen;
                msg->msg.oReq.userInstance = Entry->userSecurityInfo->userInstance;
                msg->msg.oReq.userAuthentication = Entry->userSecurityInfo->userAuthentication;
                msg->msg.oReq.tokenSourceId = Entry->userSecurityInfo->tokenSourceId;
                msg->msg.oReq.isAdmin = (Entry->flags & RP_OPEN_BY_ADMIN);
                msg->msg.oReq.localProc =(Entry->flags & RP_OPEN_LOCAL);

                RtlCopyMemory(msg->msg.oReq.tokenSource, 
                              Entry->userSecurityInfo->tokenSource,
                              sizeof(Entry->userSecurityInfo->tokenSource));

                //
                // Complete a device IOCTL to let the WIN32 code know we have
                // one ready to go.
                //
                irpSp = IoGetCurrentIrpStackLocation(ioIrp);
                ioIrp->IoStatus.Status = STATUS_SUCCESS;
                ioIrp->IoStatus.Information = irpSp->Parameters.DeviceIoControl.OutputBufferLength;
                DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter:   RsQueueRecallOpen queue open for ID %I64x.\n", FilterId));
                IoCompleteRequest(ioIrp, IO_NO_INCREMENT);

		Entry->flags |= RP_NOTIFICATION_SENT;


                retval = STATUS_SUCCESS;
            } else {
                ioIrp->IoStatus.Status = STATUS_INVALID_USER_BUFFER;
                ioIrp->IoStatus.Information = 0;
                DebugTrace((DPFLTR_RSFILTER_ID,DBG_ERROR, "RsFilter:   RsQueueRecallOpen IO request had invalid buffer - %p.\n", ioIrp->AssociatedIrp.SystemBuffer));
                RsLogError(__LINE__, AV_MODULE_RPFILFUN, 0 ,
                           AV_MSG_UNEXPECTED_ERROR, NULL, NULL);

                IoCompleteRequest(ioIrp, IO_NO_INCREMENT);
                retval = STATUS_INVALID_USER_BUFFER;
            }
        } else {
            retval = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    return retval;
}


NTSTATUS
RsQueueCancel(IN ULONGLONG FilterId)
/*++

Routine Description:

   Queue a recall cancelled request to the Fsa

Arguments:
   filter ID

Return Value:
  0 if queued ok
  non-zero otherwise


--*/
{
    NTSTATUS              retval;
    RP_MSG                *msg;
    BOOLEAN               gotLock = FALSE;
    PIRP                  ioIrp;
    PIO_STACK_LOCATION    irpSp;

    PAGED_CODE();

    try {
        //
        // Need to wait for IO entry as long as there are no IOCTLS or until we time out
        //
        ioIrp = RsGetFsaRequest();

        if (NULL != ioIrp) {
            if (NULL != ioIrp->AssociatedIrp.SystemBuffer) {
                msg = (RP_MSG *) ioIrp->AssociatedIrp.SystemBuffer;
                msg->inout.command = RP_CANCEL_RECALL;
                msg->msg.cReq.filterId = FilterId;
            }
            //
            // Complete a device IOCTL to let the WIN32 code know we have
            // one cancelled
            //
            irpSp = IoGetCurrentIrpStackLocation(ioIrp);
            ioIrp->IoStatus.Status = STATUS_SUCCESS;
            ioIrp->IoStatus.Information = irpSp->Parameters.DeviceIoControl.OutputBufferLength;
            IoCompleteRequest(ioIrp, IO_NO_INCREMENT);
            retval = STATUS_SUCCESS;
        } else {
            retval = STATUS_INSUFFICIENT_RESOURCES;
        }
        DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter:  Notify Fsa of cancelled recall %I64x\n", FilterId));
    }except (RsExceptionFilter(L"RsQueueCancel", GetExceptionInformation())) {
    }
    return(retval);
}


NTSTATUS
RsPreserveDates(IN PRP_FILE_CONTEXT Context)
/*++

Routine Description:

    Preserve the last modified date for this file object

Arguments:

    File object list entry

Return Value:


Note:


--*/
{
    NTSTATUS                    retval = STATUS_SUCCESS;
    KEVENT                      event;
    PIO_STACK_LOCATION          irpSp;
    IO_STATUS_BLOCK             Iosb;
    PIRP                        irp;
    FILE_BASIC_INFORMATION      dateInfo;
    PDEVICE_OBJECT              deviceObject;

    PAGED_CODE();

    try {

        DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsPreserveDates - Build Irp for Set file info.\n"));
        //
        // First get the file info so we have the attributes
        //
        deviceObject = IoGetRelatedDeviceObject(Context->fileObjectToWrite);
        irp = IoAllocateIrp(deviceObject->StackSize, FALSE);

        if (irp) {
            irp->UserEvent = &event;
            irp->UserIosb = &Iosb;
            irp->Tail.Overlay.Thread = PsGetCurrentThread();
            irp->Tail.Overlay.OriginalFileObject = Context->fileObjectToWrite;
            irp->RequestorMode = KernelMode;
            irp->Flags |= IRP_SYNCHRONOUS_API;
            //
            // Initialize the event
            //
            KeInitializeEvent(&event, SynchronizationEvent, FALSE);

            //
            // Set up the I/O stack location.
            //

            irpSp = IoGetNextIrpStackLocation(irp);
            irpSp->MajorFunction = IRP_MJ_QUERY_INFORMATION;
            irpSp->FileObject = Context->fileObjectToWrite;
            irpSp->Parameters.QueryFile.Length = sizeof(FILE_BASIC_INFORMATION);
            irpSp->Parameters.QueryFile.FileInformationClass = FileBasicInformation;
            irp->AssociatedIrp.SystemBuffer = &dateInfo;

            //
            // Set the completion routine.
            //
            IoSetCompletionRoutine( irp, RsCompleteIrp, &event, TRUE, TRUE, TRUE );

            //
            // Send it to the FSD
            //
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsPreserveDates - Call driver to get date info\n"));
            Iosb.Status = 0;

            retval = IoCallDriver(deviceObject,
                                  irp);

            if (retval == STATUS_PENDING) {
                retval = KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
            }

            retval = Iosb.Status;

            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsPreserveDates - Query returns %x.\n", retval));
        } else {
            retval = STATUS_INSUFFICIENT_RESOURCES;
            RsLogError(__LINE__, AV_MODULE_RPFILFUN, sizeof(IRP),
                       AV_MSG_MEMORY, NULL, NULL);
        }

        if (retval == STATUS_SUCCESS) {
            irp = IoAllocateIrp(deviceObject->StackSize, FALSE);
            if (irp) {
                irp->UserEvent = &event;
                irp->UserIosb = &Iosb;
                irp->Tail.Overlay.Thread = PsGetCurrentThread();
                irp->Tail.Overlay.OriginalFileObject = Context->fileObjectToWrite;
                irp->RequestorMode = KernelMode;
                irp->Flags |= IRP_SYNCHRONOUS_API;
                //
                // Initialize the event
                //
                KeInitializeEvent(&event, SynchronizationEvent, FALSE);

                //
                // Set up the I/O stack location.
                //
                dateInfo.LastWriteTime.QuadPart = -1;
                dateInfo.ChangeTime.QuadPart = -1;

                irpSp = IoGetNextIrpStackLocation(irp);
                irpSp->MajorFunction = IRP_MJ_SET_INFORMATION;
                irpSp->FileObject = Context->fileObjectToWrite;
                irpSp->Parameters.QueryFile.Length = sizeof(FILE_BASIC_INFORMATION);
                irpSp->Parameters.QueryFile.FileInformationClass = FileBasicInformation;
                irp->AssociatedIrp.SystemBuffer = &dateInfo;

                //
                // Set the completion routine.
                //
                IoSetCompletionRoutine( irp, RsCompleteIrp, &event, TRUE, TRUE, TRUE );

                //
                // Send it to the FSD
                //
                DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsPreserveDates - Call driver to set dates to -1.\n"));
                Iosb.Status = 0;

                retval = IoCallDriver(deviceObject,
                                      irp);

                if (retval == STATUS_PENDING) {
                    retval = KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
                }

                retval = Iosb.Status;

                DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsPreserveDates - Set dates returns %x.\n", retval));

                if (!NT_SUCCESS(retval)) {
                    //
                    // Log an error
                    //
                    RsLogError(__LINE__, AV_MODULE_RPFILFUN, retval,
                               AV_MSG_PRESERVE_DATE_FAILED, NULL, NULL);
                }


            } else {
                retval = STATUS_INSUFFICIENT_RESOURCES;
                RsLogError(__LINE__, AV_MODULE_RPFILFUN, sizeof(IRP),
                           AV_MSG_MEMORY, irpSp, NULL);
            }
        }
    }except (RsExceptionFilter(L"RsPreserveDates", GetExceptionInformation()))
    {
        retval = STATUS_INVALID_USER_BUFFER;
    }

    DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsPreserveDates - Returning %x.\n", retval));
    return(retval);
}


NTSTATUS
RsDoWrite( IN PDEVICE_OBJECT   DeviceObject,
           IN PRP_FILE_CONTEXT Context)
/*++

Routine Description:

   Partial data for a recall has been received - write it out to the file.

Arguments:

   DeviceObject - Filter device object
   Context      - File context entry


Return Value:

    0 If successful, non-zero if the id was not found.

Note:

--*/
{
    NTSTATUS            retval = STATUS_SUCCESS;
    KEVENT              event;
    PIO_STACK_LOCATION  irpSp;
    IO_STATUS_BLOCK     Iosb;
    PIRP                irp;
    PDEVICE_EXTENSION   deviceExtension;
    LARGE_INTEGER       fileOffset;

    PAGED_CODE();

    try {
        DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsDoWrite Writing to file (%u bytes at offset %I64u.\n",
                              Context->nextWriteSize, Context->currentOffset.QuadPart));

        //
        //  Write the data back to the file
        //

        fileOffset.QuadPart = Context->currentOffset.QuadPart;

        irp = IoBuildAsynchronousFsdRequest(
                                           IRP_MJ_WRITE,
                                           IoGetRelatedDeviceObject(Context->fileObjectToWrite),
                                           (PVOID) Context->nextWriteBuffer,
                                           Context->nextWriteSize,
                                           &fileOffset,
                                           &Iosb);
        if (NULL == irp) {

            retval = STATUS_INSUFFICIENT_RESOURCES;

            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsDoWrite - Failed to write data - %x\n", retval));
            RsLogError(__LINE__, AV_MODULE_RPFILFUN, retval, AV_MSG_WRITE_FAILED, NULL, NULL);

        } else {

            irp->Flags |= IRP_NOCACHE  | IRP_SYNCHRONOUS_API;
            irpSp = IoGetNextIrpStackLocation(irp);

            irpSp->FileObject = Context->fileObjectToWrite;

            IoSetCompletionRoutine( irp, RsCompleteIrp, &event, TRUE, TRUE, TRUE );

            // Initialize the event on which we'll wait for the write to complete.     //
            KeInitializeEvent(&event, NotificationEvent, FALSE);    //

            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsDoWrite - Calling driver for Irp %x\n", irp));
            retval = IoCallDriver(IoGetRelatedDeviceObject(Context->fileObjectToWrite),
                                  irp);
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsDoWrite - Call driver returned %x\n", retval));

            if (retval == STATUS_PENDING) {
                DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsDoWrite - Wait for event.\n"));
                retval = KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);

                retval = Iosb.Status;
            }

            if (!NT_SUCCESS(retval)) {
                DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsDoWrite - Failed to write data - %x\n", retval));
                RsLogError(__LINE__, AV_MODULE_RPFILFUN, retval, AV_MSG_WRITE_FAILED, NULL, NULL);
            } else {
                //
                // Update the file object list with recall status.
                // Complete any reads that are ready to go.
                //
                Context->currentOffset.QuadPart += Context->nextWriteSize;
            }
        }

    }except (RsExceptionFilter(L"RsDoWrite", GetExceptionInformation()))
    {
        retval = STATUS_INVALID_USER_BUFFER;
    }

    return(retval);
}



PRP_FILE_CONTEXT
RsAcquireFileContext(IN ULONGLONG FilterId,
                     IN BOOLEAN   Exclusive)
/*++

Routine Description:

   Acquire exclusive access to the file object entry

Arguments:
   filterID

Return Value:
  Pointer to the file context entry (locked exclusive) or NULL

--*/
{
    BOOLEAN          gotLock = FALSE, done;
    ULONGLONG        combinedId;
    PRP_FILE_CONTEXT entry;

    PAGED_CODE();

    try {

        RsAcquireFileContextQueueLock();
        gotLock = TRUE;
        combinedId = (FilterId & RP_CONTEXT_MASK);

        if (TRUE == IsListEmpty(&RsFileContextQHead)) {
            RsReleaseFileContextQueueLock();   // Something strange
            gotLock = FALSE;
            return(NULL) ;
        }

        entry = CONTAINING_RECORD(RsFileContextQHead.Flink,
                                  RP_FILE_CONTEXT,
                                  list);
        done = FALSE;
        while (entry != CONTAINING_RECORD(&RsFileContextQHead,
                                          RP_FILE_CONTEXT,
                                          list)) {
            if (entry->filterId == combinedId) {
                //
                // Found our file context entry
                //
                done = TRUE;
                break;
            }
            entry = CONTAINING_RECORD(entry->list.Flink,
                                      RP_FILE_CONTEXT,
                                      list
                                     );
        }

        if (done) {
            InterlockedIncrement((PLONG) &entry->refCount);
        }

        RsReleaseFileContextQueueLock();
        gotLock = FALSE;
        if (done) {
            //
            // Acquire the entry exclusively
            //
            if (Exclusive) {
                RsAcquireFileContextEntryLockExclusive(entry);
            } else {
                RsAcquireFileContextEntryLockShared(entry);
            }
        } else {
            entry = NULL;
        }
    }except (RsExceptionFilter(L"RsAcquireFileContext", GetExceptionInformation()))
    {
        //
        // Something bad happened - just log an error and return
        //
        if (gotLock) {
            RsReleaseFileContextQueueLock();
        }
        entry = NULL;
    }

    return(entry);
}



NTSTATUS
RsPartialData(IN  PDEVICE_OBJECT DeviceObject,
              IN  ULONGLONG FilterId,
              IN  NTSTATUS Status,
              IN  CHAR *Buffer,
              IN  ULONG BufLen,
              IN  ULONGLONG BuffOffset)
/*++

Routine Description:

   Partial data for a recall on read has been received - fill in the read buffer or write the
   data out to the file, depending on the type of recall.

Arguments:

    DeviceObject - Filter device object
    FilterId   - The ID assigned when this request was added to the queue
    Status     - The status to complete the Irp with (if applicable).
    Buffer     - Buffer containing no-recall data
    BufLen     - Amount of data recalled in this transfer (length of Buffer)
    BuffOffset - If this is a RECALL, absolute file offset this transfer corresponds to
                 If this is a NO_RECALL, the offset within the original requested
                 block of data, that this buffer corresponds to

Return Value:

    0 If successful, non-zero if the id was not found.

Note:

--*/
{
    PRP_FILE_CONTEXT    context;
    PRP_FILE_OBJ        entry;
    NTSTATUS            retval  = STATUS_SUCCESS;
    PRP_IRP_QUEUE       readIo  = NULL;
    BOOLEAN             done    = FALSE;
    BOOLEAN             found   = FALSE;
    BOOLEAN             gotLock = FALSE;
    KIRQL               rirqL;
    LARGE_INTEGER       combinedId;
    KAPC_STATE          apcState;

    UNREFERENCED_PARAMETER(Status);

    try {
        context = RsAcquireFileContext(FilterId, TRUE);

        if (NULL == context) {
            return(STATUS_INVALID_PARAMETER);
        }

        gotLock = TRUE;

        DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsPartialData - Context = %x buffer = %x\n",
                              context,
                              Buffer));

        combinedId.QuadPart = FilterId;

        //
        // If a normal recall then write the data to the file.
        //
        if (combinedId.QuadPart & RP_TYPE_RECALL) {
            //
            // Normal recall - write the data to the file
            //
            retval = RsPartialWrite(DeviceObject,
                                    context,
                                    Buffer,
                                    BufLen,
                                    BuffOffset);
            //
            // If the file has been fully recalled we can change the file state to pre-migrated.
            // We do this now rather than waiting for the recall completion message because of a race condition
            // with our regression test code.  When the last read is completed the test code closes the file and checks the state
            // and verifies that it is pre-migrated.  In some cases this happens before we get the recall completion message
            // and update the state of the file.
            //

            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsPartialData - After write - retval = %x curent = %I64u end = %I64u\n",
                                  retval,
                                  context->currentOffset.QuadPart,
                                  context->rpData.data.dataStreamSize.QuadPart));

            if ( (NT_SUCCESS(retval)) && (context->currentOffset.QuadPart == context->rpData.data.dataStreamSize.QuadPart)) {

                retval = RsSetPremigratedState(context);

                if (NT_SUCCESS(retval)) {
                    context->state = RP_RECALL_COMPLETED;
                    context->recallStatus = STATUS_SUCCESS;
                } else {
                    //
                    // Something went wrong in setting the file to premigrated
                    // Let's clean up
                    //
                    context->state                  = RP_RECALL_NOT_RECALLED;
                    context->recallStatus           = retval;
                    context->currentOffset.QuadPart = 0;
                    RsTruncateFile(context);
                }
            }

            //
            // Complete whatever reads we can
            //
            if (NT_SUCCESS(retval)) {
                RsCompleteReads(context);
            }
            RsReleaseFileContext(context);
            gotLock = FALSE;
        } else {
            //
            // Find the read that this data is for ...
            //
            //
            // Lock the file object queue
            //
            entry = CONTAINING_RECORD(context->fileObjects.Flink,
                                      RP_FILE_OBJ,
                                      list);

            while ((!done) && (entry != CONTAINING_RECORD(&context->fileObjects,
                                                          RP_FILE_OBJ,
                                                          list))) {
                if (RP_IS_NO_RECALL(entry) && (!IsListEmpty(&entry->readQueue))) {
                    //
                    // Look at the reads to see if one has the matching ID
                    //
                    //
                    found = FALSE;
                    ExAcquireSpinLock(&entry->qLock, &rirqL);
                    readIo =  CONTAINING_RECORD(entry->readQueue.Flink,
                                                RP_IRP_QUEUE,
                                                list);
                    while ((readIo != CONTAINING_RECORD(&entry->readQueue,
                                                        RP_IRP_QUEUE,
                                                        list)) && (FALSE == found)) {
                        if (readIo->readId == (combinedId.HighPart & RP_READ_MASK)) {
                            //
                            // Found our read entry
                            found = TRUE;
                            //
                            // At this point the IRP will become non-cancellable
                            // The FSA does fetch the data for the entire request of the IRP
                            // so the RECALL_COMPLETE message from the FSA is going to arrive
                            // pretty soon. Since the i/o is essentially complete, making the
                            // IRP non-cancellable from this point is not bad
                            //
                            if (!RsClearCancelRoutine(readIo->irp)) {
                                //
                                // Yes we found the entry - however it's being cancelled
                                // Let the cancel handle it
                                //
                                readIo = NULL;
                            }
                        } else {
                            readIo = CONTAINING_RECORD(readIo->list.Flink,
                                                       RP_IRP_QUEUE,
                                                       list);
                        }
                    }
                    ExReleaseSpinLock(&entry->qLock, rirqL);

                    if (found) {
                        done = TRUE;
                        break;
                    }
                }
                //
                // Move on to next file object
                //
                entry = CONTAINING_RECORD(entry->list.Flink,
                                          RP_FILE_OBJ,
                                          list
                                         );
            }


            if (!found) {
                //
                // ERROR - read was not found
                //
                RsReleaseFileContext(context);
                gotLock = FALSE;
                DebugTrace((DPFLTR_RSFILTER_ID,DBG_ERROR, "RsFilter: RsPartialData - Read Irp not found!\n"));
                return(STATUS_INVALID_USER_BUFFER);
            }
            //
            // Note we only use the low part because reads are limited in size
            //

            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Partial data of %u bytes at offset %I64u\n",
                                  BufLen, BuffOffset));
            //
            // Check if the request was cancelled
            //
            if (readIo == NULL) {
                RsReleaseFileContext(context);
                gotLock = FALSE;
                return STATUS_CANCELLED;
            }

            if (readIo->userBuffer == NULL) {
                //
                // Now comes the slightly risky part of this operation. Now that the
                // MDL has been allocated, it is IMPERATIVE that the buffer be probed
                // and locked so that when the buffer copy thread runs, it does not
                // have to be concerned with touching this memory at a raised IRQL.
                //
                // It is safe to stick the MDL in the Irp->MdlAddress as the file
                // systems look at that field before attempting to probe and lock
                // the users buffer themselves. If they see the Mdl, they will just
                // use it instead.
                //
                // CRITICAL CRITICAL CRITICAL CRITICAL CRITICAL CRITICAL CRITICAL
                //
                // This MUST take place within a try except handler, so that if something
                // should happen to the user buffer before the driver got to this point,
                // a graceful failure can occur. Otherwise the system could bug check.

                try {
                    MmProbeAndLockProcessPages (readIo->irp->MdlAddress,
                                                IoGetRequestorProcess(readIo->irp),
                                                readIo->irp->RequestorMode,
                                                //
                                                // Modifying the buffer
                                                //
                                                IoModifyAccess);      

                }except (EXCEPTION_EXECUTE_HANDLER) {

                    //
                    // Something serious went wrong. Free the Mdl, and complete this
                    // Irp with some meaningful sort of error.
                    //

                    DebugTrace((DPFLTR_RSFILTER_ID,DBG_ERROR, "RsFilter: RsPartialData unable to lock read buffer\n"));
                    RsLogError(__LINE__, AV_MODULE_RPFILFUN, 0,
                               AV_MSG_NO_BUFFER_LOCK, NULL, NULL);
                    retval = STATUS_INVALID_USER_BUFFER;

                }
                //
                // Everything that needs to be done has been done at this point.
                // Therefore, just get the data we need and return it in the callers buffer.
                //
                //
                // Get the system address for the MDL which represents the users buffer.
                //

                if (STATUS_SUCCESS == retval) {
                    readIo->userBuffer = MmGetSystemAddressForMdlSafe(readIo->irp->MdlAddress,
                                                                      NormalPagePriority) ;
                    if (readIo->userBuffer == NULL) {
                        retval = STATUS_INSUFFICIENT_RESOURCES;
                    }
                }

            }

            //
            // See if we need to copy this data to the user buffer
            // i.e. check if there is an overlap between the data that the
            // user requested and the data that is brought in
            //
            if (readIo->userBuffer &&
                ((BuffOffset + BufLen) >  readIo->offset) &&
                (BuffOffset  <=  (readIo->offset + readIo->length - 1))) {
                ULONGLONG userBeg, userEnd;
                ULONGLONG recallBeg, recallEnd;
                ULONGLONG targetOffset, sourceOffset;
                ULONGLONG targetLength;
                //
                // There are 2 possibilities here for the overlap
                //
                userBeg   = readIo->offset;
                userEnd   = readIo->offset + readIo->length - 1;
                recallBeg = BuffOffset;
                recallEnd = BuffOffset + BufLen - 1 ;

                if (recallBeg > userBeg) {
                    //
                    //
                    // In the following picture, CacheXXXX denotes the cache buffer's
                    // aligned begin and end offsets -  which is what the original recall request is for.
                    // UserXXXX denotes the offset within this cache buffer (0-based) that
                    // we need to copy the data to (target offsets)
                    // RecallXXXX is the offsets within this cache buffer (0-based) that has been
                    // currently recalled, which are the source offsets for copying the data from
                    // 0                                                RspCacheBlockSize-1
                    // CacheBufferBegin                               CacheBufferEnd
                    // ==============================================================
                    //          TargetOffset = RecallBegin-UserBegin
                    //     UserBegin           UserEnd
                    //     ============================
                    //          RecallBegin                   RecallEnd
                    //          ==================================
                    //          SourceOffset=0
                    // In this case, we begin copying at offset RecallBegin and copy till UserEnd or
                    // RecallEnd, whichever occurs earlier
                    //
                    //
                    // target offset is the offset within the user buffer that copying begins
                    // source offset is the offset within the recalled data buffer that copying begins
                    // target length is the length of the copy
                    //
                    targetOffset = (recallBeg - userBeg);
                    sourceOffset = 0;
                    targetLength = MIN(recallEnd, userEnd) - recallBeg + 1;
                } else {
                    //
                    // 0                                               RspCacheBlockSize-1
                    // CacheBufferBegin                               CacheBufferEnd
                    // ==============================================================
                    //              TargetOffset = 0
                    //              UserBegin                        UserEnd
                    //              =====================================
                    //    RecallBegin                   RecallEnD
                    //    ==================================
                    //             SourceOffset = (UserBegin-RecallBegin)
                    // In this case, we begin copying at offset UserBegin and copy till UserEnd
                    // or RecallEnd, whichever occurs earlier
                    //
                    targetOffset = 0;
                    sourceOffset = (userBeg - recallBeg);
                    targetLength = MIN(recallEnd, userEnd) - userBeg + 1;
                }

                DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Copying from %X to %X length %X bytes, current irql %X\n",
                                      Buffer+sourceOffset, ((CCHAR *) readIo->userBuffer)+targetOffset,
                                      targetLength, KeGetCurrentIrql()));
                RtlCopyMemory(((CHAR *) readIo->userBuffer) + targetOffset,
                              Buffer+sourceOffset,
                              (ULONG) targetLength);

                readIo->irp->IoStatus.Information += (ULONG) targetLength;
            }

            //
            // Call the no recall cache manager to finish with the buffer
            //
            if (readIo->cacheBuffer) {
                RsCacheFsaPartialData(readIo,
                                      (PUCHAR) Buffer,
                                      BuffOffset,
                                      BufLen,
                                      retval);
            }
            //
            // At this point make the IRP cancellable again..
            //
            if (!RsSetCancelRoutine(readIo->irp,
                                    RsCancelReadRecall)) {
                //
                // It is attempted to be cancelled..So be it.
                //
                retval = STATUS_CANCELLED;

                RsCompleteRecall(DeviceObject,
                                 FilterId,
                                 retval,
                                 0,
                                 FALSE);
            }
            RsReleaseFileContext(context);
            gotLock = FALSE;
        }

    }except (RsExceptionFilter(L"RsPartialData", GetExceptionInformation()))
    {
        if (gotLock) {
            RsReleaseFileContext(context);
        }
        retval = STATUS_INVALID_USER_BUFFER;
    }
    return(retval);
}


NTSTATUS
RsPartialWrite(IN  PDEVICE_OBJECT   DeviceObject,
               IN  PRP_FILE_CONTEXT Context,
               IN  CHAR *Buffer,
               IN  ULONG BufLen,
               IN  ULONGLONG Offset)
/*++

Routine Description:

   Partial data for a recall has been received - write it out to the file.
   NOTE: The file context entry lock is held by caller  when calling this
   routine

Arguments:

   DeviceObject - Filter device object
   Context      - File context entry
   Buffer       - Buffer with the data
   BufLen       - Length of the buffer
   Offset       - Offset into the file

Return Value:

    0 If successful, non-zero if the id was not found.

Note:

--*/
{
    NTSTATUS            retval     = STATUS_SUCCESS;
    PFILE_OBJECT        fileObject = NULL;
    HANDLE              fileHandle = NULL;


    PAGED_CODE();

    try {
        DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsPartialWrite - Writing to file (%u bytes at offset %I64u.\n",
                              BufLen, Offset));

        //
        //  If the recall was cancelled or some other kind of error ocurred we need to fail any more writes we may receive.
        //
        if (Context->state == RP_RECALL_COMPLETED) {
            return(Context->recallStatus);
        }

        if (Context->createSectionLock) {
            return STATUS_FILE_IS_OFFLINE;     
        }

        //
        //  Write the data back to the file
        //
        //
        // Open the target file if it is not already opened..
        //

        if (NULL == Context->fileObjectToWrite) {

            RsReleaseFileContextEntryLock(Context);

            retval = RsOpenTarget(Context,
                                  0,
                                  GENERIC_READ | GENERIC_WRITE,
                                  &fileHandle,
                                  &fileObject);

            RsAcquireFileContextEntryLockExclusive(Context);


            //
            // Context is referenced if the open was successful
            //
            if (NT_SUCCESS(retval)) {


                /*
                ** Anything other than NULL would indicate a colliding 
                ** open and that is NOT suppposed to happen
                */
                ASSERT ((NULL == Context->fileObjectToWrite) &&
                        (NULL == Context->handle));


                if (NULL == Context->fileObjectToWrite) {
                    Context->fileObjectToWrite = fileObject;
                } else {
                    ObDereferenceObject (fileObject);
                }

                if (NULL == Context->handle) {
                    Context->handle = fileHandle;
                } else {
                    ZwClose (fileHandle);
                }

                //
                // Indicate to USN the writes are happening by HSM
                // and preserve last modified date
                //
                RsMarkUsn(Context);
                RsPreserveDates(Context);
            }
        }


        if (NT_SUCCESS(retval)) {
            //
            //  Write the data back to the file
            //
            Context->nextWriteBuffer = Buffer;
            Context->currentOffset.QuadPart = Offset;
            Context->nextWriteSize = BufLen;
            //
            // Release the file context while writing to the file to avoid
            // deadlocks... (why???) code added by rick.
            //
            RsReleaseFileContextEntryLock(Context);
            retval = RsDoWrite(DeviceObject, Context);
            RsAcquireFileContextEntryLockExclusive(Context);

        } else {
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_ERROR, "RsFilter: RsPartialWrite - Failed to open the file - %x\n", retval));
        }

    }except (RsExceptionFilter(L"RsPartialWrite", GetExceptionInformation()))
    {
        retval = STATUS_INVALID_USER_BUFFER;
    }

    return(retval);
}


NTSTATUS
RsCompleteIrp(
             IN PDEVICE_OBJECT DeviceObject,
             IN PIRP Irp,
             IN PVOID Context
             )
/*++

Routine Description:

   completion routine for partialWrite

Arguments:



Return Value:


Note:

--*/
{
    //  Set the event so that our call will wake up.    //
    UNREFERENCED_PARAMETER( DeviceObject );

    if (Irp->MdlAddress) {
        DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsCompleteIrp - Free MDL.\n"));
        MmUnlockPages (Irp->MdlAddress) ;
        IoFreeMdl (Irp->MdlAddress) ;
    }

    KeSetEvent( (PKEVENT)Context, 0, FALSE );

    //
    // Propogate status/information to the user iosb
    //
    if (Irp->UserIosb) {
        Irp->UserIosb->Status      =  Irp->IoStatus.Status;
        Irp->UserIosb->Information =  Irp->IoStatus.Information;
    }

    IoFreeIrp(Irp);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
RsFailAllRequests(IN PRP_FILE_CONTEXT Context,
                  IN BOOLEAN          FailNoRecallReads)
/*++

Routine Description:

    Fail all reads and writes waiting on a recall for this file id.

Arguments:

    Context             - Pointer to file context entry
    FailNoRecallReads   - If this TRUE pending NO_RECALL reads will be failed
                          as well as regular read/writes

Return Value:

    Status

--*/
{
    NTSTATUS            retval = STATUS_SUCCESS;
    PRP_FILE_OBJ        entry;
    BOOLEAN             done = FALSE;

    PAGED_CODE();

    try {
        //
        // Lock the file object queue
        //
        entry = CONTAINING_RECORD(Context->fileObjects.Flink,
                                  RP_FILE_OBJ,
                                  list);

        while ((!done) && (entry != CONTAINING_RECORD(&Context->fileObjects,
                                                      RP_FILE_OBJ,
                                                      list))) {
            if (FailNoRecallReads || !RP_IS_NO_RECALL(entry)) {
                //

                RsCompleteAllRequests(Context, entry, STATUS_FILE_IS_OFFLINE);
            }
            //
            // Move on to next file object
            //
            entry = CONTAINING_RECORD(entry->list.Flink,
                                      RP_FILE_OBJ,
                                      list
                                     );
        }

    }except (RsExceptionFilter(L"RsFailAllRequests", GetExceptionInformation())) {
        retval = STATUS_INVALID_USER_BUFFER;
    }

    return(retval);
}


NTSTATUS
RsCompleteAllRequests(IN PRP_FILE_CONTEXT Context,
                      IN PRP_FILE_OBJ Entry,
                      IN NTSTATUS     Status)
/*++

Routine Description:

    Complete all reads and writes waiting on a recall for this file object.
    This function works ok even if  the caller has acquired the file object resource
    (and assumed it was OK to hold the resource until all reads and writes have
    completed.)

Arguments:

    File object list entry, status

Return Value:


Note:


--*/
{
    NTSTATUS            retval = STATUS_SUCCESS;
    NTSTATUS            localStatus;
    PRP_IRP_QUEUE       pndIo;
    KAPC_STATE          apcState;

    PAGED_CODE();

    try {

        DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsCompleteAllRequests - Entry: %x Read Q: %u  Write Q %u\n",
                              Entry,
                              IsListEmpty(&Entry->readQueue),
                              IsListEmpty(&Entry->writeQueue)));
        //
        // For normal recalls just complete the Irps
        //
        pndIo = RsDequeuePacket(&Entry->readQueue, &Entry->qLock);
        while (pndIo != NULL) {
            if (pndIo->flags & RP_IRP_NO_RECALL) {
                //
                // For no recall we only have reads to deal with and we must be sure to
                // free the MDL if required.
                //
                pndIo->irp->IoStatus.Status = Status;
                pndIo->irp->IoStatus.Information = 0;
                RsCompleteRead(pndIo, (BOOLEAN) ((NULL == pndIo->userBuffer) ? FALSE : TRUE));
            } else {
                //
                // Attach to the originator process so the IRP can be completed in that
                // context
                //
                KeStackAttachProcess((PKPROCESS) IoGetRequestorProcess(pndIo->irp), &apcState);
                if (Status != STATUS_SUCCESS) {
                    DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsCompleteAllRequests - Failing read %x\n", pndIo->irp));
                    pndIo->irp->IoStatus.Status = Status;
                    pndIo->irp->IoStatus.Information = 0;
                    IoCompleteRequest (pndIo->irp, IO_NO_INCREMENT) ;
                } else {
                    DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsCompleteAllRequests - Complete read %x ext = %x\n", pndIo->irp, pndIo->deviceExtension));
                    //
                    // Resend the IRP down
                    //
                    IoSkipCurrentIrpStackLocation(pndIo->irp);
                    localStatus =  IoCallDriver( pndIo->deviceExtension->FileSystemDeviceObject, pndIo->irp );
                    DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter:RsCompleteAllRequests - NTFS returned status %X\n", localStatus));
                }
                KeUnstackDetachProcess(&apcState);
            }

            ExFreePool(pndIo);

            pndIo = RsDequeuePacket(&Entry->readQueue, &Entry->qLock);
        }

        pndIo = RsDequeuePacket(&Entry->writeQueue, &Entry->qLock);
        while ( pndIo != NULL) {

            if (Status != STATUS_SUCCESS) {
                DebugTrace((DPFLTR_RSFILTER_ID,DBG_ERROR, "RsFilter: RsCompleteAllRequests - Fail write %x\n", pndIo->irp));

                //
                // Attach to the originator process so the IRP can be completed in that
                // context
                //
                pndIo->irp->IoStatus.Status = Status;
                pndIo->irp->IoStatus.Information = 0;

                KeStackAttachProcess((PKPROCESS) IoGetRequestorProcess(pndIo->irp),
                                     &apcState);

                IoCompleteRequest (pndIo->irp, IO_NO_INCREMENT) ;

                KeUnstackDetachProcess(&apcState);
            } else {
                DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsCompleteAllRequests - Complete write %x\n", pndIo->irp));
                //
                // Resend the IRP down
                //
                IoSkipCurrentIrpStackLocation(pndIo->irp);
                //
                // Attach to the originator process so the IRP can be completed in that
                // context
                //
                KeStackAttachProcess((PKPROCESS) IoGetRequestorProcess(pndIo->irp),
                                     &apcState);

                localStatus = IoCallDriver( pndIo->deviceExtension->FileSystemDeviceObject,
                                            pndIo->irp );

                KeUnstackDetachProcess(&apcState);
                //
                // Now delete the reparse point if there was one
                //
                if (!(Context->flags & RP_FILE_REPARSE_POINT_DELETED) && NT_SUCCESS(localStatus)) {

		    DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter:RsCompleteAllRequests: deleteing reparse point, pndIo=%x\n", pndIo));

		    localStatus = RsDeleteReparsePoint(Context);

		    if (!NT_SUCCESS(localStatus)) {
			RsLogError(__LINE__,
				   AV_MODULE_RPFILFUN,
				   localStatus,
				   AV_MSG_DELETE_REPARSE_POINT_FAILED,
				   NULL,
				   NULL);
		    } else {
			RsAcquireFileContextEntryLockExclusive(Context);
			Context->flags |= RP_FILE_REPARSE_POINT_DELETED;
			RsReleaseFileContextEntryLock(Context);
		    }
		}



                DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter:RsCompleteAllRequests - NTFS returned status %X\n", localStatus));

            }

            ExFreePool(pndIo);
            pndIo = RsDequeuePacket(&Entry->writeQueue, &Entry->qLock);
        }
    }except (RsExceptionFilter(L"RsCompleteAllRequests", GetExceptionInformation()))
    {
    }

    DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsCompleteAllRequests - Done.\n"));
    return(retval);
}


NTSTATUS
RsCompleteReads(IN PRP_FILE_CONTEXT Context)
/*++

Routine Description:

   Completes all reads for which data is available for all file objects

Arguments:

    Context - file context entry


Return Value:

    0 If successful, non-zero if the id was not found.


--*/
{
    PRP_FILE_OBJ        entry, oldEntry;
    BOOLEAN             found;
    KIRQL               rirqL;
    PRP_IRP_QUEUE       readIo, oldReadIo;
    NTSTATUS            localStatus;
    KAPC_STATE          apcState;
    PEPROCESS           process;
    LIST_ENTRY          satisfiableIrps;

    try {

        if (Context->flags & RP_FILE_WAS_WRITTEN) {
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsCompleteReads - File was writen - do not complete reads for %I64x!\n", Context->filterId));
            return(STATUS_SUCCESS);
        }

        DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsCompleteReads - Complete reads for %I64x!\n", Context->filterId));
        //
        // Lock the file object queue
        //
        entry = CONTAINING_RECORD(Context->fileObjects.Blink,
                                  RP_FILE_OBJ,
                                  list);

        while (entry != CONTAINING_RECORD(&Context->fileObjects,
                                          RP_FILE_OBJ,
                                          list)) {
            //
            // Ref this file object so it does not go away unexpectedly
            //
            ObReferenceObject(entry->fileObj);
            InitializeListHead(&satisfiableIrps);

            //
            // Look at the reads and prepare a list of all that can be completed
            // Start at the end of the list as those will be the earliest reads issued.
            //

            ExAcquireSpinLock(&entry->qLock, &rirqL);

            readIo = CONTAINING_RECORD(entry->readQueue.Blink,
                                       RP_IRP_QUEUE,
                                       list);

            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsCompleteReads - Checking read %p - list head is %p\n", readIo, &entry->readQueue));

            while (readIo != CONTAINING_RECORD(&entry->readQueue,
                                               RP_IRP_QUEUE,
                                               list)) {
                //
                //  Save the next entry  to be visited
                //
                oldReadIo = CONTAINING_RECORD(readIo->list.Blink,
                                              RP_IRP_QUEUE,
                                              list);
                if (!(readIo->readId & RP_READ_MASK) &&
                    (Context->currentOffset.QuadPart >= (LONGLONG) (readIo->offset + readIo->length))) {
                    //
                    // This one can be completed - *if* we can clear the cancel routine
                    // if not, irp is in the process of being cancelled and we will let it be cancelled
                    // after we release the entry->qLock
                    //
                    if (RsClearCancelRoutine(readIo->irp)) {
                        RemoveEntryList(&readIo->list);
                        InsertTailList(&satisfiableIrps,
                                       &readIo->list);

                    }

                }
                readIo = oldReadIo;
            }

            ExReleaseSpinLock(&entry->qLock, rirqL);

            //
            // We have to release the lock on the context entry first so the possible paging read that this may cause
            // can be passed through by RsCheckRead (which will get the same context lock on a different thread)
            // We can safely assume the context entry will not be freed out from underneath us because
            // we are still recalling the file (this code is called from RsPartialWrite)
            //
            //
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsCompleteReads - Complete read for offset %I64u & %u bytes\n", readIo->offset, readIo->length));
            RsReleaseFileContextEntryLock(Context);

            readIo = CONTAINING_RECORD(satisfiableIrps.Flink,
                                       RP_IRP_QUEUE,
                                       list);
            while (readIo != CONTAINING_RECORD(&satisfiableIrps,
                                               RP_IRP_QUEUE,
                                               list)) {
                //
                // Attach to the originator process so the IRP can be completed in that context

                process = IoGetRequestorProcess(readIo->irp);
                ObReferenceObject(process);

                KeStackAttachProcess((PKPROCESS) process, &apcState);
                //
                //
                // Resend the IRP down
                IoSkipCurrentIrpStackLocation(readIo->irp);
                localStatus =  IoCallDriver( readIo->deviceExtension->FileSystemDeviceObject, readIo->irp );
                //
                // Get the lock again.
                //
                DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter:RsCompleteReads - NTFS returned status %X\n", localStatus));
                KeUnstackDetachProcess(&apcState);

                ObDereferenceObject(process);
                oldReadIo = readIo;
                readIo = CONTAINING_RECORD(oldReadIo->list.Flink,
                                           RP_IRP_QUEUE,
                                           list);
                ExFreePool(oldReadIo);
            }

            RsAcquireFileContextEntryLockExclusive(Context);
            //
            // Move on to next file object
            //
            oldEntry = entry;
            entry = CONTAINING_RECORD(entry->list.Blink,
                                      RP_FILE_OBJ,
                                      list
                                     );

            ObDereferenceObject(oldEntry->fileObj);
        }

    }except (RsExceptionFilter(L"RsCompleteReads", GetExceptionInformation()))
    {

        DebugTrace((DPFLTR_RSFILTER_ID,DBG_ERROR, "RsFilter: RsCompleteReads - Exception = %x.\n", GetExceptionCode()));

    }

    return(STATUS_SUCCESS);
}


VOID
RsCancelRecalls(VOID)
/*++

Routine Description:

    Cancel all pending recall activity.

Arguments:

    None

Return Value:

    None

Note:

    All pending recall activity is canceled.  Any recall requests are failed with
    STATUS_FILE_IS_OFFLINE.


--*/
{
    PRP_FILE_CONTEXT  context;
    BOOLEAN           gotLock = FALSE;

    PAGED_CODE();

    try {
        RsAcquireFileContextQueueLock();
        gotLock = TRUE;
        context = CONTAINING_RECORD(RsFileContextQHead.Flink,
                                    RP_FILE_CONTEXT,
                                    list);

        while (context != CONTAINING_RECORD(&RsFileContextQHead,
                                            RP_FILE_CONTEXT,
                                            list)) {

            RsAcquireFileContextEntryLockExclusive(context);

            context->recallStatus = STATUS_CANCELLED;
            context->state = RP_RECALL_COMPLETED;

            KeSetEvent(&context->recallCompletedEvent,
                       IO_NO_INCREMENT,
                       FALSE);

            RsFailAllRequests(context, TRUE);

            RsReleaseFileContextEntryLock(context);

            context = CONTAINING_RECORD(context->list.Flink,
                                        RP_FILE_CONTEXT,
                                        list
                                       );
        }


        RsReleaseFileContextQueueLock();
        gotLock = FALSE;

    }except (RsExceptionFilter(L"RsCancelRecalls", GetExceptionInformation()))
    {
        if (gotLock) {
            RsReleaseFileContextQueueLock();
        }
    }
}


NTSTATUS
RsGetRecallInfo(IN OUT PRP_MSG               Msg,
                OUT    PULONG_PTR            InfoSize,
                IN     KPROCESSOR_MODE       RequestorMode)
/*++

Routine Description:

    Return the file name and SID info to the FSA.  This is retrieved via an FSCTL call because
    the information is variable in size and may be large (file path may be 32K).

Arguments:

    Msg       FSCTL request message from the Fsa.
    InfoSize  Size of the recall info is returned in this parameter

Return Value:

    STATUS_NO_SUCH_FILE - File entry was not found
    STATUS_BUFFER_OVERFLOW - An exception was hit

Note:


--*/
{
    PRP_FILE_CONTEXT    context;
    WCHAR               *nInfo;
    NTSTATUS            retval;
    BOOLEAN             done, gotLock = FALSE;
    PRP_FILE_OBJ        entry;

    PAGED_CODE();

    try {
        //
        context = RsAcquireFileContext(Msg->msg.riReq.filterId, FALSE);

        if (NULL == context) {
            *InfoSize = 0;
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_ERROR, "RsFilter: RsGetRecallInfo Returns %x\n", STATUS_NO_SUCH_FILE));
            return(STATUS_NO_SUCH_FILE);
        }
        gotLock = TRUE;
        DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsGetRecallInfo context = %x\n",
                              context));

        //
        // Now find the file object entry
        //
        done = FALSE;
        //
        // Lock the file object queue
        //
        entry = CONTAINING_RECORD(context->fileObjects.Flink,
                                  RP_FILE_OBJ,
                                  list);

        while ((!done) && (entry != CONTAINING_RECORD(&context->fileObjects,
                                                      RP_FILE_OBJ,
                                                      list))) {
            if (Msg->msg.riReq.filterId & RP_TYPE_RECALL) {
                if (entry->filterId == (Msg->msg.riReq.filterId & RP_FILE_MASK)) {
                    //
                    // This is the one.
                    //
                    done = TRUE;
                }
            } else {
                //
                // This is a no-recall open - we have to find the ID in the read Irp.
                //
                if (RP_IS_NO_RECALL(entry)) {
                    //
                    // Since there is no user notification for this type of open we don't really care
                    // which file object entry we use so we get the first one opened for no-recall.
                    //
                    done = TRUE;
                }
            }

            if (!done) {
                //
                // Move on to next file object
                //
                entry = CONTAINING_RECORD(entry->list.Flink,
                                          RP_FILE_OBJ,
                                          list
                                         );
            }
        }


        if (done) {
            //
            // Return the file ID, name, and user info
            //
            Msg->msg.riReq.fileId = entry->fileId;

            if (NULL != entry->userSecurityInfo->userInfo) {
                DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsGetRecallInfo copy user info - %u bytes\n", entry->userSecurityInfo->userInfoLen));
                //
                // Make sure the buffer supplied is valid
                //
                if (RequestorMode != KernelMode) {
                    ProbeForWrite(&Msg->msg.riReq.userToken,
                                  entry->userSecurityInfo->userInfoLen,
                                  sizeof(UCHAR));
                };
                RtlCopyMemory(&Msg->msg.riReq.userToken,
                              entry->userSecurityInfo->userInfo,
                              entry->userSecurityInfo->userInfoLen);
            }

            if (context->uniName != NULL) {
                nInfo = (WCHAR *) ((CHAR *) &Msg->msg.riReq.userToken + entry->userSecurityInfo->userInfoLen);

                //
                // Make sure the buffer supplied is valid
                //
                if (RequestorMode != KernelMode) {
                    ProbeForWrite(nInfo,
                                  context->uniName->Name.Length,
                                  sizeof(UCHAR));
                };

                DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsGetRecallInfo copy file name - %u bytes\n", context->uniName->Name.Length));

                RtlCopyMemory(nInfo, context->uniName->Name.Buffer, context->uniName->Name.Length);

                nInfo[context->uniName->Name.Length / sizeof(WCHAR)] = L'\0';
                *InfoSize = sizeof(RP_MSG) + context->uniName->Name.Length + entry->userSecurityInfo->userInfoLen + sizeof(WCHAR);
            } else {
                *InfoSize = sizeof(RP_MSG) + entry->userSecurityInfo->userInfoLen;
            }
            retval = STATUS_SUCCESS;
        } else {
            *InfoSize = 0;
            retval = STATUS_NO_SUCH_FILE;
        }
        RsReleaseFileContext(context);
        gotLock = FALSE;

    }except (RsExceptionFilter(L"RsGetRecallInfo", GetExceptionInformation()))
    {
        if (gotLock) {
            RsReleaseFileContext(context);
        }
        retval = STATUS_INVALID_USER_BUFFER;
    }

    DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsGetRecallInfo Returns %x\n", retval));

    return(retval);
}


NTSTATUS
RsWriteReparsePointData(IN PRP_FILE_CONTEXT Context)
/*++

Routine Description

   Writes out the reparse point data to the specified file

Arguments

   Context  - Pointer to the structure which specificies the file object
              and the reparse point data that needs to be written out

Return Value

   STATUS_SUCCESS                - Reparse point data written out as specified
   STATUS_INSUFFICIENT_RESOURCES - Failure to allocate memory
   STATUS_INVALID_USER_BUFFER    - Buffer passed in was bad (touching it caused
                                   an exception)
   STATUS_NOT_SUPPORTED          - File system did not support writing of the reparse
                                   point data


--*/
{
    NTSTATUS                    status = STATUS_SUCCESS;
    PREPARSE_DATA_BUFFER        pRpBuffer = NULL;
    KEVENT                      event;
    PIO_STACK_LOCATION          irpSp;
    IO_STATUS_BLOCK             Iosb;
    PIRP                        irp = NULL;
    PDEVICE_OBJECT              deviceObject;
    BOOLEAN                     oldWriteAccess;

    PAGED_CODE();

    try {

        //
        // Attempt allocating the RP buffer to write out
        //
        pRpBuffer = ExAllocatePoolWithTag(PagedPool,
                                          REPARSE_DATA_BUFFER_HEADER_SIZE + sizeof(Context->rpData),
                                          RP_FO_TAG
                                         );
        if (!pRpBuffer) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        deviceObject = IoGetRelatedDeviceObject(Context->fileObjectToWrite);

        irp = IoAllocateIrp(deviceObject->StackSize, FALSE);

        if (!irp) {
            ExFreePool(pRpBuffer);
            RsLogError(__LINE__, AV_MODULE_RPFILFUN, sizeof(IRP),
                       AV_MSG_MEMORY, NULL, NULL);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        // Setup the reparse data buffer
        //
        RtlZeroMemory(pRpBuffer, REPARSE_DATA_BUFFER_HEADER_SIZE);
        pRpBuffer->ReparseTag = IO_REPARSE_TAG_HSM;
        pRpBuffer->ReparseDataLength = sizeof(Context->rpData);
        //
        // Copy in the reparse point data
        //
        RtlCopyMemory(((PUCHAR)pRpBuffer) + REPARSE_DATA_BUFFER_HEADER_SIZE,
                      &Context->rpData,
                      sizeof(Context->rpData));

        irp->UserEvent = &event;
        irp->UserIosb = &Iosb;
        irp->Tail.Overlay.Thread = PsGetCurrentThread();
        irp->Tail.Overlay.OriginalFileObject = Context->fileObjectToWrite;
        irp->RequestorMode = KernelMode;
        irp->Flags |= IRP_SYNCHRONOUS_API;
        //
        // Initialize the event
        //
        KeInitializeEvent(&event,
                          SynchronizationEvent,
                          FALSE);

        //
        // Set up the I/O stack location.
        //
        irpSp = IoGetNextIrpStackLocation(irp);
        irpSp->MajorFunction = IRP_MJ_FILE_SYSTEM_CONTROL;
        irpSp->MinorFunction = IRP_MN_USER_FS_REQUEST;
        irpSp->FileObject = Context->fileObjectToWrite;
        irpSp->Parameters.FileSystemControl.FsControlCode = FSCTL_SET_REPARSE_POINT;
        irpSp->Parameters.FileSystemControl.InputBufferLength = REPARSE_DATA_BUFFER_HEADER_SIZE + sizeof(Context->rpData);

        irp->AssociatedIrp.SystemBuffer = pRpBuffer;
        //
        // Set the completion routine.
        //
        IoSetCompletionRoutine( irp,
                                RsCompleteIrp,
                                &event,
                                TRUE,
                                TRUE,
                                TRUE );
        //
        // Give the file object permission to write
        //
        oldWriteAccess = Context->fileObjectToWrite->WriteAccess;
        Context->fileObjectToWrite->WriteAccess = TRUE;

        //
        // Send it to the FSD
        //
        Iosb.Status = STATUS_NOT_SUPPORTED;
        status = IoCallDriver(deviceObject,
                              irp);

        if (status == STATUS_PENDING) {
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsWriteReparsePointData - Wait for event.\n"));
            status = KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        }

        //
        // Restore the old access rights
        //
        Context->fileObjectToWrite->WriteAccess = oldWriteAccess;

        DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsWriteReparsePointData Iosb returns %x.\n", status));

        if (!NT_SUCCESS(status)) {
            RsLogError(__LINE__, AV_MODULE_RPFILFUN, status,
                       AV_MSG_WRITE_REPARSE_FAILED, NULL, NULL);
        }


        //
        // Free the allocated reparse data buffer
        //
        ExFreePool(pRpBuffer);
        pRpBuffer = NULL;
    }except (RsExceptionFilter(L"RsWriteReparsePointData", GetExceptionInformation()))
    {
        status = STATUS_INVALID_USER_BUFFER;
        if (pRpBuffer) {
            ExFreePool(pRpBuffer);
        }
    }

    DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsWriteReparsePointData- Returning %x.\n", status));
    return(status);
}




NTSTATUS
RsAddIo(PIRP irp)
/*++

Routine Description:

    Add a IOCTL request to the queue.  These requests will be
    removed from the queue and completed when recall activity is detected.
    Recall activity includes requests to recall a file as well as notifications
    of events like the deletion or overwriting of a file with a HSM reparse point.


Arguments:

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    0 on success, non-zero if error (no memory)

Note:

--*/
{
    KIRQL               oldIrql;
    NTSTATUS            retval = STATUS_SUCCESS;

    RsGetIoLock(&oldIrql);

    DebugTrace((DPFLTR_RSFILTER_ID,DBG_LOCK, "RsFilter: RsAddIo %u\n", RsFsaRequestCount));

    InsertTailList(&RsIoQHead,
                   &irp->Tail.Overlay.ListEntry);

    if (RsSetCancelRoutine(irp,
                           RsCancelIoIrp)) {
        KeReleaseSemaphore(&RsFsaIoAvailableSemaphore,
                           IO_NO_INCREMENT,
                           1L,
                           FALSE);
        InterlockedIncrement((PLONG) &RsFsaRequestCount);
        retval = STATUS_PENDING;
    } else {
        RemoveEntryList(&irp->Tail.Overlay.ListEntry);
        retval = STATUS_CANCELLED;
    }

    RsPutIoLock(oldIrql);

    return(retval);
}


PIRP
RsRemoveIo(VOID)
/*++

Routine Description:

    Remove one of the IOCTL requests on the queue


Arguments:

    None

Return Value:

    Pointer to an IRP or NULL

Note:

--*/
{
    PLIST_ENTRY      entry;
    PIRP             irp;
    RP_MSG          *msg;
    KIRQL            oldIrql;

    RsGetIoLock(&oldIrql);

    entry = RemoveHeadList(&RsIoQHead);

    if ( entry == &RsIoQHead) {
        RsPutIoLock(oldIrql);
        return NULL;
    };

    irp = CONTAINING_RECORD(entry,
                            IRP,
                            Tail.Overlay.ListEntry);

    if (!RsClearCancelRoutine(irp)) {
        //
        // This is going to be cancelled, let the cancel routine finish with it
        //
        irp = NULL;
    } else {
        InterlockedDecrement((PLONG) &RsFsaRequestCount);
    }

    RsPutIoLock(oldIrql);

    DebugTrace((DPFLTR_RSFILTER_ID,DBG_LOCK, "RsFilter: RsRemoveIo %u\n", RsFsaRequestCount));

    return(irp);
}


ULONG
RsIsNoRecall(IN PFILE_OBJECT FileObject,
             OUT PRP_DATA    *RpData)
/*++

Routine Description:

    Determine if a file object is on the queue and was open with no-recall on read option


Arguments:

    IN  - File Object
    OUT - Reparse point data

Return Value:



Note:
    This function should not be used to determine if reads should be passed to the FSA as no-recall
    reads.  If another handle was opened for recall and written to then the reads should wait for the recall
    to complete.  This function can be used to determine if the reparse point info should be munged.

--*/
{
    ULONG                  retval;
    PRP_FILTER_CONTEXT     filterContext;
    PRP_FILE_OBJ           entry;
    PRP_FILE_CONTEXT       context;
    BOOLEAN                gotLock = FALSE;

    PAGED_CODE();

    try {

        filterContext = (PRP_FILTER_CONTEXT) FsRtlLookupPerStreamContext(FsRtlGetPerStreamContextPointer(FileObject), FsDeviceObject, FileObject);
        if (filterContext == NULL) {
            //
            // Not found
            return(FALSE);
        }

        entry = (PRP_FILE_OBJ) filterContext->myFileObjEntry;
        context = (PRP_FILE_CONTEXT) entry->fsContext;

        ASSERT(FileObject == entry->fileObj);

        RsAcquireFileContextEntryLockShared(context);
        gotLock = TRUE;
        retval = FALSE;
        if (RP_IS_NO_RECALL(entry)) {

            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: reporting file (%x : %x) open for no recall.\n", context, entry));

            *RpData = &context->rpData;
            retval = TRUE;
        }
        RsReleaseFileContextEntryLock(context);
        gotLock = FALSE;

    }except (RsExceptionFilter(L"RsIsNoRecall", GetExceptionInformation()))
    {
        if (gotLock) {
            RsReleaseFileContextEntryLock(context);
        }
    }

    return(retval);
}


BOOLEAN
RsIsFastIoPossible(IN PFILE_OBJECT FileObject)
/*++

Routine Description:

    Determine if Fast IO is OK for this file object


Arguments:

    None

Return Value:



Note:

--*/
{
    BOOLEAN                retval;
    PRP_FILTER_CONTEXT     filterContext;
    PRP_FILE_OBJ           entry;
    PRP_FILE_CONTEXT       context;

    PAGED_CODE();


    filterContext = (PRP_FILTER_CONTEXT) FsRtlLookupPerStreamContext (FsRtlGetPerStreamContextPointer(FileObject), 
								      FsDeviceObject, 
								      FileObject);

    if (NULL == filterContext) {
        //
        // Not found - FastIo possible
        //
        retval = TRUE;
    } else {
        //
        // Found
	//
        entry = (PRP_FILE_OBJ) filterContext->myFileObjEntry;


        //
        // If the file has already been recalled then fast IO is allowed.
        //
        RsAcquireFileObjectEntryLockShared(entry);

        context = entry->fsContext;
        retval  = (RP_RECALL_COMPLETED == context->state);

        RsReleaseFileObjectEntryLock(entry);
    }

    return (retval);
}


VOID
RsCancelIo(VOID)
/*++

Routine Description:

    Cancel all the IOCTL requests on the queue.

Arguments:

    FILE OBJECT - If this is not NULL we cancel only the requests for this file object

Return Value:

    NONE

Note:

--*/
{
    PIRP             irp;
    PLIST_ENTRY      entry;
    LIST_ENTRY       cancelledIrps;
    KIRQL            irql;
    LARGE_INTEGER    timeout;

    InitializeListHead(&cancelledIrps);

    RsGetIoLock(&irql);

    while (!IsListEmpty(&RsIoQHead)) {
        entry = RemoveHeadList(&RsIoQHead);
        irp = CONTAINING_RECORD(entry,
                                IRP,
                                Tail.Overlay.ListEntry);

        if (RsClearCancelRoutine(irp)) {
            irp->IoStatus.Status = STATUS_CANCELLED;
            irp->IoStatus.Information = 0;
            //
            // Add it to our queue of IRPs which will be
            // completed after we get back to a safer IRQL
            //
            InsertTailList(&cancelledIrps,
                           &irp->Tail.Overlay.ListEntry);
        }
    }

    RsPutIoLock(irql);
    //
    // Complete the cancelled IRPs
    //
    timeout.QuadPart = 0;
    while (!IsListEmpty(&cancelledIrps)) {
        entry = RemoveHeadList(&cancelledIrps);
        irp = CONTAINING_RECORD(entry,
                                IRP,
                                Tail.Overlay.ListEntry);
        IoCompleteRequest(irp,
                          IO_NO_INCREMENT);
        InterlockedDecrement((PLONG) &RsFsaRequestCount);
        //
        // The semaphore count needs to be adjusted
        // Do a simple zero-length wait to decrement it
        //
        ASSERT (KeReadStateSemaphore(&RsFsaIoAvailableSemaphore) > 0);

        KeWaitForSingleObject(&RsFsaIoAvailableSemaphore,
                              Executive,
                              KernelMode,
                              FALSE,
                              &timeout);
    }

    DebugTrace((DPFLTR_RSFILTER_ID,DBG_LOCK, "RsFilter: RsCancelIo %u\n", RsFsaRequestCount));
}


NTSTATUS
RsCancelIoIrp(
             PDEVICE_OBJECT DeviceObject,
             PIRP Irp)
/*++

Routine Description

    This function filters cancels an outstanding IOCTL IRP
    Since this is only called if the FSA service is killed or crashes
    we set RsAllowRecalls to FALSE to prevent further recall activity
    and cancel any pending recall activity.

Arguments:

    DeviceObject - Pointer to the target device object of the create/open.

    Irp - Pointer to the I/O Request Packet that represents the operation.

Return Value:

    The function value is the status of the call to the file system's entry
    point.
--*/
{
    NTSTATUS        status;
    LARGE_INTEGER   timeout;
    PRP_MSG         msg;

    DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Cancel IOCTL ...\n"));

    UNREFERENCED_PARAMETER(DeviceObject);

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    RsAllowRecalls = FALSE;
    RsCancelRecalls();

    RsInterlockedRemoveEntryList(&Irp->Tail.Overlay.ListEntry,
                                 &RsIoQueueLock);

    if (NULL != Irp->AssociatedIrp.SystemBuffer) {
        msg = (RP_MSG *) Irp->AssociatedIrp.SystemBuffer;
        msg->inout.command = RP_CANCEL_ALL_DEVICEIO;
    }

    InterlockedDecrement((PLONG) &RsFsaRequestCount);
    DebugTrace((DPFLTR_RSFILTER_ID,DBG_LOCK, "RsFilter: RsCancelIoIrp %u\n", RsFsaRequestCount));

    //
    // The semaphore count needs to be adjusted
    // Do a simple zero-length wait to decrement it
    //
    ASSERT (KeReadStateSemaphore(&RsFsaIoAvailableSemaphore) > 0);

    timeout.QuadPart = 0L;
    status =  KeWaitForSingleObject(&RsFsaIoAvailableSemaphore,
                                    UserRequest,
                                    KernelMode,
                                    FALSE,
                                    &timeout);

    ASSERT (status == STATUS_SUCCESS);

    Irp->IoStatus.Status = STATUS_CANCELLED;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return(STATUS_SUCCESS);
}


VOID
RsCancelReadRecall(IN PDEVICE_OBJECT DeviceObject,
                   IN PIRP Irp)
/*++

Routine Description:


    Cancel routine for the recall Irp.  If it is on the queue then clean it up.


Arguments:

    DeviceObject - Pointer to the device object
            Irp  - Pointer to the IRP

Return Value:

    None

--*/
{
    KIRQL                  oldIrql;
    PIO_STACK_LOCATION     currentStack ;
    PRP_IRP_QUEUE          io;
    PRP_FILTER_CONTEXT     filterContext;
    PRP_FILE_OBJ           entry;
    PRP_FILE_CONTEXT       context;
    BOOLEAN                found = FALSE, gotLock = FALSE;
    LARGE_INTEGER          combinedId;


    UNREFERENCED_PARAMETER(DeviceObject);
    currentStack = IoGetCurrentIrpStackLocation (Irp) ;

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    filterContext = (PRP_FILTER_CONTEXT) FsRtlLookupPerStreamContext(FsRtlGetPerStreamContextPointer(currentStack->FileObject), FsDeviceObject, currentStack->FileObject);
    if (filterContext == NULL) {
        //
        // Not found
        Irp->IoStatus.Status = STATUS_CANCELLED;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return;
    }

    entry = (PRP_FILE_OBJ) filterContext->myFileObjEntry;
    context = entry->fsContext;

    RsAcquireFileObjectEntryLockExclusive(entry);
    gotLock = TRUE;

    try {

        ExAcquireSpinLock(&entry->qLock,
                          &oldIrql);

        io =  CONTAINING_RECORD (entry->readQueue.Flink,
                                 RP_IRP_QUEUE,
                                 list);

        while (io != CONTAINING_RECORD(&entry->readQueue,
                                       RP_IRP_QUEUE,
                                       list)) {

            if (io->irp == Irp) {
                //
                // Remove irp from queue

                RemoveEntryList(&io->list);
                found = TRUE;
                break;
            } else {
                io = CONTAINING_RECORD(io->list.Flink,
                                       RP_IRP_QUEUE,
                                       list);
            }
        }
        ExReleaseSpinLock(&entry->qLock,
                          oldIrql);
        RsReleaseFileObjectEntryLock(entry);
        gotLock = FALSE;

        if (found) {
            Irp->IoStatus.Status = STATUS_CANCELLED;
            Irp->IoStatus.Information = 0;
            //
            // We need to clean up if this for a READ_NO_RECALL
            //
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Found the read Irp\n"));

            if (RP_IS_NO_RECALL(entry)) {
                //
                // Complete the read
                //
                RsCompleteRead(io, (BOOLEAN) ((NULL == io->userBuffer) ? FALSE : TRUE));
                //
                // Tell the FSA to cancel it.
                //
                combinedId.QuadPart  = context->filterId;
                combinedId.HighPart |= (ULONG) io->readId;
                DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Cancel read for ID #%I64x.\n",
                                      combinedId.QuadPart));
                RsQueueCancel(combinedId.QuadPart);

            } else {
                DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Cancel a read for ID #%I64x.\n",
                                      entry->filterId));
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
            }

            ExFreePool(io);
        } else {
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Did not find the read Irp\n"));
            //
            // Cancel the request anyway
            //
            Irp->IoStatus.Status = STATUS_CANCELLED;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
        }
    }except (RsExceptionFilter(L"RsCancelReadRecall", GetExceptionInformation()))
    {
        if (gotLock) {
            RsReleaseFileObjectEntryLock(entry);
        }
    }
    return;
}


VOID
RsCancelWriteRecall(IN PDEVICE_OBJECT DeviceObject,
                    IN PIRP Irp)
/*++

Routine Description:


    Cancel routine for the recall Irp.  If it is on the queue then clean it up.


Arguments:

    DeviceObject - Pointer to the device object
            Irp  - Pointer to the IRP

Return Value:

    None

--*/
{
    KIRQL                  oldIrql;
    PRP_IRP_QUEUE          io;
    PRP_FILTER_CONTEXT     filterContext;
    PRP_FILE_OBJ           entry;
    PRP_FILE_CONTEXT       context;
    PIO_STACK_LOCATION     currentStack ;
    BOOLEAN                found = FALSE, gotLock = FALSE;

    UNREFERENCED_PARAMETER(DeviceObject);
    currentStack = IoGetCurrentIrpStackLocation (Irp) ;

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    filterContext = (PRP_FILTER_CONTEXT) FsRtlLookupPerStreamContext(FsRtlGetPerStreamContextPointer(currentStack->FileObject), FsDeviceObject, currentStack->FileObject);
    if (filterContext == NULL) {
        //
        // Not found
        Irp->IoStatus.Status = STATUS_CANCELLED;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return;
    }

    entry = (PRP_FILE_OBJ) filterContext->myFileObjEntry;
    context = entry->fsContext;
    RsAcquireFileObjectEntryLockExclusive(entry);
    gotLock = TRUE;

    try {

        DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Cancel recall ID #%I64x.\n",
                              entry->filterId));


        ExAcquireSpinLock(&entry->qLock,
                          &oldIrql);

        io = CONTAINING_RECORD(entry->writeQueue.Flink,
                               RP_IRP_QUEUE,
                               list);

        while (io != CONTAINING_RECORD(&entry->writeQueue,
                                       RP_IRP_QUEUE,
                                       list)) {
            if (io->irp == Irp) {
                //
                // Remove irp from queue
                //
                RemoveEntryList (&io->list);
                found = TRUE;
                break;
            } else {
                io = CONTAINING_RECORD(io->list.Flink,
                                       RP_IRP_QUEUE,
                                       list);
            }
        }

        ExReleaseSpinLock(&entry->qLock,
                          oldIrql);

        RsReleaseFileObjectEntryLock(entry);
        gotLock = TRUE;
        DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Cancel a write for ID #%I64x\n",
                              entry->filterId | context->filterId));

        Irp->IoStatus.Status = STATUS_CANCELLED;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        if (found) {
            ExFreePool(io);
        }
    }except (RsExceptionFilter(L"RsCancelWriteRecall", GetExceptionInformation()))
    {
        if (gotLock) {
            RsReleaseFileObjectEntryLock(entry);
        }
    }
    return;
}


ULONG
RsTerminate(VOID)
/*++

Routine Description:

    Called on termination to clean up any necessary items.

Arguments:

    NONE

Return Value:

    0

Note:


--*/
{
    PAGED_CODE();

    return(0);
}


NTSTATUS RsGenerateDevicePath(IN PDEVICE_OBJECT deviceObject,
                              OUT POBJECT_NAME_INFORMATION *nameInfo
                             )
/*++

Routine Description:

    Generate a full path specification from the device object.

Arguments:

    deviceObject  - the file object to get the device object from
    nameInfo - where to put the name


Return Value:

    0 on success

Note:


--*/
{
    NTSTATUS                   status;
    ULONG                      size;
    NTSTATUS                   retval = STATUS_SUCCESS;
    USHORT                     nLen;
    POBJECT_NAME_INFORMATION   deviceName = NULL;
    UNICODE_STRING             tmpString;


    PAGED_CODE();

    try {
        if (deviceName = ExAllocatePoolWithTag( NonPagedPool, AV_DEV_OBJ_NAME_SIZE, RP_FN_TAG)) {
            size = AV_DEV_OBJ_NAME_SIZE;

            status = ObQueryNameString(
                                      deviceObject,
                                      deviceName,
                                      size,
                                      &size
                                      );

            if (!NT_SUCCESS(status)) {
                if (AV_DEV_OBJ_NAME_SIZE < size) {
                    /* Did not allocate enough space for the device name -
                        reallocate and try again */
                    ExFreePool(deviceName);
                    if (deviceName = ExAllocatePoolWithTag( NonPagedPool, size + 10, RP_FN_TAG)) {
                        status = ObQueryNameString(
                                                  deviceObject,
                                                  deviceName,
                                                  size + 10,
                                                  &size
                                                  );
                    } else {
                        RsLogError(__LINE__, AV_MODULE_RPFILFUN, size,
                                   AV_MSG_MEMORY, NULL, NULL);
                        return(STATUS_INSUFFICIENT_RESOURCES);
                    }
                }

            }
        } else {
            RsLogError(__LINE__, AV_MODULE_RPFILFUN, AV_DEV_OBJ_NAME_SIZE,
                       AV_MSG_MEMORY, NULL, NULL);
            return(STATUS_INSUFFICIENT_RESOURCES);
        }


        if (!NT_SUCCESS(status)) {
            //
            // Failed to get device object name
            //
            // Log an error
            //
            ExFreePool(deviceName);
            return(STATUS_NO_SUCH_DEVICE);
        }

        DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsGenerateDevicePath Device name is %u bytes - %ws\n",
                              deviceName->Name.Length, deviceName->Name.Buffer));

        nLen = (USHORT) (AV_NAME_OVERHEAD + size);

        if (*nameInfo = ExAllocatePoolWithTag( NonPagedPool, nLen, RP_FN_TAG)) {
            RtlZeroMemory(*nameInfo, nLen);
            (*nameInfo)->Name.Length = 0;
            (*nameInfo)->Name.MaximumLength = (USHORT) (nLen - sizeof(OBJECT_NAME_INFORMATION));
            (*nameInfo)->Name.Buffer = (WCHAR *) ((CHAR *) *nameInfo + sizeof(OBJECT_NAME_INFORMATION));


            RtlInitUnicodeString(&tmpString, (PWCHAR) L"");
            //RtlInitUnicodeString(&tmpString, L"\\\\.");
            RtlCopyUnicodeString(&(*nameInfo)->Name, &tmpString);

            status = RtlAppendUnicodeStringToString(&(*nameInfo)->Name, &deviceName->Name);
            if (NT_SUCCESS(status)) {
                retval = STATUS_SUCCESS;
            } else {
                retval = status;
            }

        } else {
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_ERROR, "RsFilter: RsGenerateDevicePath failed - no memory\n"));
            retval = STATUS_INSUFFICIENT_RESOURCES;
            RsLogError(__LINE__, AV_MODULE_RPFILFUN, nLen,
                       AV_MSG_MEMORY, NULL, NULL);
        }

        ExFreePool(deviceName);
        deviceName = NULL;

    }except (RsExceptionFilter(L"RsGenerateDevicePath", GetExceptionInformation()))
    {
        if (*nameInfo != NULL)
            ExFreePool( *nameInfo );

        if (deviceName != NULL)
            ExFreePool( deviceName );

        retval = STATUS_BUFFER_OVERFLOW;
    }

    return(retval);
}



NTSTATUS RsGenerateFullPath(IN POBJECT_NAME_INFORMATION fileName,
                            IN PDEVICE_OBJECT deviceObject,
                            OUT POBJECT_NAME_INFORMATION *nameInfo
                           )
/*++

Routine Description:

    Generate a full path specification from the file object and file name given.
    Return the path with the device specific portion.

Arguments:

    fileName      - Path from the root of the device
    deviceObject  - the file object to get the device object from
    nameInfo - where to put the name


Return Value:

    0 on success

Note:


--*/
{
    NTSTATUS                   status;
    ULONG                      size;
    NTSTATUS                   retval = STATUS_SUCCESS;
    USHORT                     nLen;
    POBJECT_NAME_INFORMATION   deviceName = NULL;

    PAGED_CODE();

    try {
        *nameInfo = NULL;
        size = AV_DEV_OBJ_NAME_SIZE;
        if (deviceName = ExAllocatePoolWithTag( NonPagedPool, size, RP_FN_TAG)) {
            status = ObQueryNameString(
                                      deviceObject,
                                      deviceName,
                                      size,
                                      &size
                                      );

            if (!NT_SUCCESS(status)) {
                if (AV_DEV_OBJ_NAME_SIZE < size) {
                    /* Did not allocate enough space for the device name -
                        reallocate and try again */
                    ExFreePool(deviceName);
                    if (deviceName = ExAllocatePoolWithTag( NonPagedPool, size + 10, RP_FN_TAG)) {
                        status = ObQueryNameString(
                                                  deviceObject,
                                                  deviceName,
                                                  size + 10,
                                                  &size
                                                  );
                        DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsGenerateFullPath - Second try for device name returned %x.\n", status));
                    } else {
                        RsLogError(__LINE__, AV_MODULE_RPFILFUN, size,
                                   AV_MSG_MEMORY, NULL, NULL);
                        return(STATUS_INSUFFICIENT_RESOURCES);
                    }
                }

            }
        } else {
            RsLogError(__LINE__, AV_MODULE_RPFILFUN, AV_DEV_OBJ_NAME_SIZE,
                       AV_MSG_MEMORY, NULL, NULL);
            return(STATUS_INSUFFICIENT_RESOURCES);
        }


        if (!NT_SUCCESS(status)) {
            //
            // Failed to get device object name
            //
            ExFreePool(deviceName);
            //
            // Log an error
            //
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_ERROR, "RsFilter: RsGenerateFullPath - Failed to get the device name - %x.\n", status));
            return(STATUS_NO_SUCH_DEVICE);
        }

        nLen = (USHORT) (AV_NAME_OVERHEAD +
                         fileName->Name.MaximumLength +
                         size);

        if (*nameInfo = ExAllocatePoolWithTag( NonPagedPool, nLen, RP_FN_TAG)) {

            (*nameInfo)->Name.Length = 0;
            (*nameInfo)->Name.MaximumLength = (USHORT) (nLen - sizeof(OBJECT_NAME_INFORMATION));
            (*nameInfo)->Name.Buffer = (PWCHAR) ((CHAR *) *nameInfo + sizeof(OBJECT_NAME_INFORMATION));

            RtlCopyUnicodeString(&(*nameInfo)->Name, &deviceName->Name);

            status = RtlAppendUnicodeStringToString(&(*nameInfo)->Name, &fileName->Name);
            if (NT_SUCCESS(status)) {
                retval = STATUS_SUCCESS;
            } else {
                DebugTrace((DPFLTR_RSFILTER_ID,DBG_ERROR, "RsFilter: RsGenerateFullPath - Failed to append filename (nLen = %u, fileName = %u dev = %u) - %x.\n",
                                      nLen, fileName->Name.MaximumLength, size, status));
                ExFreePool( *nameInfo );
                retval = status;
            }

        } else {
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_ERROR, "RsFilter: RsGenerateFullPath failed - no memory\n"));
            retval = STATUS_INSUFFICIENT_RESOURCES;
            RsLogError(__LINE__, AV_MODULE_RPFILFUN, nLen,
                       AV_MSG_MEMORY, NULL, NULL);
        }

        ExFreePool(deviceName);
        deviceName = NULL;

    }except (RsExceptionFilter(L"RsGenerateFullPath", GetExceptionInformation()))
    {
        if (*nameInfo != NULL)
            ExFreePool( *nameInfo );

        if (deviceName != NULL)
            ExFreePool( deviceName );

        retval = STATUS_BUFFER_OVERFLOW;
    }

    return(retval);
}



BOOLEAN
RsAddValidateObj(ULONG serial, LARGE_INTEGER cTime)
/*++

Routine Description:


 Add an entry to the queue if needed.


Arguments:
    Volume serial number
    Time

Return Value:

 Return TRUE if the registry should be updated, FALSE if not.

Note:


--*/
{
    PRP_VALIDATE_INFO    entry;
    KIRQL                irqL;
    LARGE_INTEGER        lTime;
    BOOLEAN              done = FALSE;
    BOOLEAN              gotLock = FALSE;


    try {
        RsGetValidateLock(&irqL);
        gotLock = TRUE;

        entry = (RP_VALIDATE_INFO *) RsValidateQHead.Flink;
        while ((entry != (RP_VALIDATE_INFO *) &RsValidateQHead) && (FALSE == done)) {
            if (entry->serial == serial) {
                done = TRUE;
            } else {
                entry = (RP_VALIDATE_INFO *) entry->list.Flink;
                if (entry == (RP_VALIDATE_INFO *) &RsValidateQHead) {
                    done = TRUE;
                }
            }
        }


        if (entry != (RP_VALIDATE_INFO *) &RsValidateQHead) {
            lTime.QuadPart = entry->lastSetTime.QuadPart;
        }

        RsPutValidateLock(irqL);
        gotLock = FALSE;

        if (entry == (RP_VALIDATE_INFO *) &RsValidateQHead) {
            entry = ExAllocatePoolWithTag(NonPagedPool, sizeof(RP_VALIDATE_INFO), RP_VO_TAG);
            if (NULL == entry) {
                RsLogError(__LINE__, AV_MODULE_RPFILFUN, sizeof(RP_VALIDATE_INFO),
                           AV_MSG_MEMORY, NULL, NULL);

                return(TRUE);
            }

            entry->serial = serial;
            entry->lastSetTime.QuadPart = cTime.QuadPart;
            ExInterlockedInsertTailList(&RsValidateQHead, (PLIST_ENTRY) entry, &RsValidateQueueLock);
            return(TRUE);
        }

    }except (RsExceptionFilter(L"RsAddValidateObj", GetExceptionInformation()))
    {
        if (gotLock == TRUE) {
            RsPutValidateLock(irqL);
        }

    }
    //
    // There was already an entry.  If this was an hour or more later
    // we need to update the registry again.
    //
    if ( (cTime.QuadPart - lTime.QuadPart) >= AV_FT_TICKS_PER_HOUR) {
        return(TRUE);
    } else {
        return(FALSE);
    }
}


BOOLEAN
RsRemoveValidateObj(ULONG serial)
/*++

Routine Description:


 remove an entry from the queue if needed.


Arguments:
    Volume serial number
    Time

Return Value:

 Return TRUE for success

Note:


--*/
{
    PRP_VALIDATE_INFO    entry;
    KIRQL                irqL;
    BOOLEAN              done = FALSE;
    BOOLEAN              retval = FALSE;
    BOOLEAN              gotLock = FALSE;


    try {
        RsGetValidateLock(&irqL);
        gotLock = TRUE;

        entry =  CONTAINING_RECORD(RsValidateQHead.Flink,
                                   RP_VALIDATE_INFO,
                                   list);
        while ((entry != CONTAINING_RECORD(&RsValidateQHead,
                                           RP_VALIDATE_INFO,
                                           list)) && (FALSE == done)) {
            if (entry->serial == serial) {
                RemoveEntryList(&entry->list);
                done = TRUE;
            } else {
                entry =  CONTAINING_RECORD(entry->list.Flink,
                                           RP_VALIDATE_INFO,
                                           list);
            }
        }

        RsPutValidateLock(irqL);
        gotLock = FALSE;

        if (done) {
            ExFreePool(entry);
        }
    }except (RsExceptionFilter(L"RsRemoveValidateObj", GetExceptionInformation()))
    {
        retval = FALSE;
        if (gotLock == TRUE) {
            RsPutValidateLock(irqL);
        }

    }
    return(retval);
}



VOID
RsLogValidateNeeded(ULONG serial)
/*++

Routine Description:

    Log the fact that a validate job needs to be run on a given volume.
    If it was already logged in the last hour then forget it, otherwise update it.
    Let the Fsa know by completing an IOCTL (if the FSA is running).
    Write an entry to the registry to indicate it in case the Fsa is not running.

Arguments:

    Serial number of the volume

Return Value:

    NONE

Note:


--*/
{
    NTSTATUS            retval;
    WCHAR               serBuf[10];
    LARGE_INTEGER       cTime;
    UNICODE_STRING      str;

    PAGED_CODE();

    KeQuerySystemTime(&cTime);

    if (RsAddValidateObj(serial, cTime) == TRUE) {
        str.Buffer = &serBuf[0];
        str.Length = 10 * sizeof(WCHAR);
        str.MaximumLength = 10 * sizeof(WCHAR);

        retval = RtlIntegerToUnicodeString(serial, 16, &str);
        serBuf[8] = L'\0';
        DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Reg value name is %ws\n", serBuf));

        if (!NT_SUCCESS(RsQueueValidate(serial))) {
            RsLogError(__LINE__, AV_MODULE_RPFILFUN, 0,
                       AV_MSG_VALIDATE_WARNING, NULL, NULL);
        }
        retval = RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE, FSA_VALIDATE_LOG_KEY_NAME, serBuf, REG_BINARY, &cTime, sizeof(LARGE_INTEGER));
        if (!NT_SUCCESS(retval)) {
            RsLogError(__LINE__, AV_MODULE_RPFILFUN, 0,
                       AV_MSG_VALIDATE_WARNING, NULL, NULL);

            DebugTrace((DPFLTR_RSFILTER_ID,DBG_ERROR, "RsFilter: Set registry entry returned %x\n", retval));
        }
    }
}


NTSTATUS
RsQueueValidate(ULONG serial)
/*++

Routine Description:

   Let the Fsa know that a validate job is needed

Arguments:
   Volume serial number

Return Value:

   Status

--*/
{
    ULONG               retval;
    RP_MSG              *msg;
    PIRP                ioIrp;
    PIO_STACK_LOCATION  irpSp;

    PAGED_CODE();

    try {
        //
        // Need to wait for IO entry as long as there are no IOCTLS or until we time out
        //
        ioIrp = RsGetFsaRequest();
        if (NULL != ioIrp) {

            if (NULL != ioIrp->AssociatedIrp.SystemBuffer) {
                msg = (RP_MSG *) ioIrp->AssociatedIrp.SystemBuffer;
                msg->inout.command = RP_RUN_VALIDATE;
                msg->msg.oReq.serial = serial;
            }
            //
            // Now that we have gotten everything setup we can put it on the queue
            //
            //
            // Complete a device IOCTL to let the Fsa know
            //
            irpSp = IoGetCurrentIrpStackLocation(ioIrp);
            ioIrp->IoStatus.Status = STATUS_SUCCESS;
            ioIrp->IoStatus.Information = irpSp->Parameters.DeviceIoControl.OutputBufferLength;

            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: Letting the Fsa know a validate is needed for %x\n",
                                  serial));

            IoCompleteRequest(ioIrp, IO_NO_INCREMENT);
            retval = STATUS_SUCCESS;
        } else {
            retval = STATUS_INSUFFICIENT_RESOURCES;
        }
    }except (RsExceptionFilter(L"RsQueueValidate", GetExceptionInformation())) {
        retval = STATUS_UNEXPECTED_IO_ERROR;
    }

    return(retval);
}



VOID
RsLogError(ULONG line,
           ULONG file,
           ULONG code,
           NTSTATUS ioError,
           PIO_STACK_LOCATION irpSp,
           WCHAR *msgString)
/*++

Routine Description:

    Log an error to the event log.

Arguments:

   Line number
   Source file ID
   Error code
   IRP (may be NULL if no IRP is involved)
   Message parm string - 30 Unicode chars max
                         (optional - NULL if not needed)

Return Value:

    NONE

Note:

   The information may be seen in the NT event log.  You need to view the
   NT system log.  You will see events with RsFilter as the source.  If
   you view the event detail you will see the log message and some hex
   data.  At offset 0x28 you will see the line, file id, and error code
   information (4 bytes each - lo byte first).


--*/
{
    PIO_ERROR_LOG_PACKET    pErr;
    PAV_ERR                 eStuff;
    AV_ERR                  memErr;
    size_t                  size;
    BOOLEAN                 gotMem = FALSE;


    DebugTrace((DPFLTR_RSFILTER_ID,DBG_VERBOSE, "RsFilter: Log error %u in %u of %u\n", code, line, file));

    if (msgString != NULL)
        size = wcslen(msgString) * sizeof(WCHAR) + sizeof(WCHAR);
    else
        size = 0;

    if (sizeof(IO_ERROR_LOG_PACKET) + sizeof(AV_ERR) + size > ERROR_LOG_MAXIMUM_SIZE)
        size -=  (sizeof(IO_ERROR_LOG_PACKET) + sizeof(AV_ERR) + size) -
                 ERROR_LOG_MAXIMUM_SIZE;


    if (ioError == AV_MSG_MEMORY) {
        // No memory to allocate for the error packet - use the stack
        // allocated one and make sure there is no additional message string
        eStuff = &memErr;
        size = 0;
    } else {
        eStuff = ExAllocatePoolWithTag( NonPagedPool, size + sizeof(AV_ERR), RP_ER_TAG);
        if (eStuff != NULL) {
            gotMem = TRUE;
        } else {
            // no memory - do the best we can.
            eStuff = &memErr;
            size = 0;
            gotMem = FALSE;
        }
    }


    pErr = (PVOID) IoAllocateErrorLogEntry(FsDriverObject->DeviceObject,
                                           (UCHAR) (sizeof(IO_ERROR_LOG_PACKET) + sizeof(AV_ERR) + size));

    if (NULL != pErr) {
        if (NULL != irpSp)
            pErr->MajorFunctionCode = irpSp->MajorFunction;
        else
            pErr->MajorFunctionCode = 0;

        pErr->RetryCount = 0;
        pErr->DumpDataSize = offsetof(AV_ERR, string);
        pErr->NumberOfStrings = 1;
        pErr->StringOffset = offsetof(IO_ERROR_LOG_PACKET, DumpData) +
                             offsetof(AV_ERR, string);
        pErr->EventCategory = 0;
        pErr->ErrorCode = ioError;
        pErr->UniqueErrorValue = code;
        pErr->FinalStatus = STATUS_SUCCESS;
        pErr->SequenceNumber = 0x999;
        pErr->IoControlCode = 0;

        memset(eStuff, 0, sizeof(AV_ERR));
        eStuff->line = line;
        eStuff->file = file;
        eStuff->code = code;

        //
        // Copy the string if it is there AND we allocated memory for it
        //
        if ( (NULL != msgString) && (gotMem)) {
            RtlCopyMemory(eStuff->string, msgString, size);
            eStuff->string[(size / sizeof(WCHAR)) - 1] = L'\0';
        }

        RtlCopyMemory(&pErr->DumpData[0], eStuff, sizeof(AV_ERR) + size);
        IoWriteErrorLogEntry((PVOID) pErr);
    }

    if (gotMem) {
        ExFreePool(eStuff);
    }
}


PIRP
RsGetFsaRequest(VOID)
/*++

Routine description

Gets the next free FSA action request packet, to be used for filter/fsa communication,
sent down by the FSA and returns it.
If none are available immediately, waits for a limited time for one
to become available.

Arguments

None

Return Value

Pointer to the next free FSA request packet if successful
NULL if there are none and we've timed out waiting for a free one.


--*/
{
    PIRP           ioIrp = NULL;
    LARGE_INTEGER  waitInterval;
    NTSTATUS       status;

    PAGED_CODE();

    while (TRUE) {
        //
        // Get hold of a pending FSCTL
        //
        if (FALSE == RsAllowRecalls) {
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter:  recalls disabled, not getting Fsa request\n"));
            break;
        }

        waitInterval.QuadPart = RP_WAIT_FOR_FSA_IO_TIMEOUT;

        status =  KeWaitForSingleObject(&RsFsaIoAvailableSemaphore,
                                        UserRequest,
                                        KernelMode,
                                        FALSE,
                                        &waitInterval);
        if (status == STATUS_TIMEOUT) {
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO,  "RsFilter:  out of FSCTLs and timed out waiting for one\n"));
            //
            // Log this error so PSS may identify that the recall failed
            // specifically because we ran out of resources to communicate
            // with the recall engine 
            //
            RsLogError(__LINE__, AV_MODULE_RPFILFUN, 0, AV_MSG_OUT_OF_FSA_REQUESTS, NULL, NULL);
            break;
        }

        ioIrp = RsRemoveIo();

        if (NULL == ioIrp) {
            //
            // io was cancelled for some reason after it was retrieved.
            // Try to get another
            //
            continue;
        } else {
            //
            // Found a  free FSCTL
            //
            break;
        }
    }

    return ioIrp;
}


NTSTATUS
RsGetFileInfo(IN PRP_FILE_OBJ   Entry,
              IN PDEVICE_OBJECT DeviceObject )

/*++

Routine Description:

   Get the needed information to fill out the file object queue info.

Arguments:

    Entry               - Pointer to the file object entry
    DeviceObject        - Filter device object for RsFilter


Return Value:

    0 If successful, non-zero if the id was not found.

Note:

--*/
{
    NTSTATUS            retval = STATUS_SUCCESS;
    PRP_FILE_CONTEXT    context;

    PAGED_CODE();

    try {

        DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsGetFileInfo - Getting file name & id information.\n"));

        context = Entry->fsContext;

        if (context->fileId == 0) {
            //
            // No file ID - we need to get it now
            //
            retval = RsGetFileId(Entry,
                                 DeviceObject);
        }

        if ((retval == STATUS_SUCCESS) && (context->uniName == NULL)) {
            //
            // No file name - we need to get it now
            //
            retval = RsGetFileName(Entry,
                                   DeviceObject);
        }


    }except (RsExceptionFilter(L"RsGetFileInfo", GetExceptionInformation()))
    {

        retval = STATUS_INVALID_USER_BUFFER;
    }

    DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsGetFileInfo - Returning %x.\n", retval));

    return(retval);
}



NTSTATUS
RsGetFileName(IN PRP_FILE_OBJ Entry,
              IN PDEVICE_OBJECT DeviceObject)

/*++

Routine Description:

   Get the file name

Arguments:

    Entry        -  File object queue entry

    DeviceObject -  Filter Device Object for RsFilter

Return Value:

    0 If successful, non-zero if the name was not found.

Note:

--*/
{
    NTSTATUS                retval = STATUS_SUCCESS;
    KEVENT                  event;
    PIO_STACK_LOCATION      irpSp = NULL;
    IO_STATUS_BLOCK         Iosb;
    PIRP                    irp;
    PDEVICE_EXTENSION       deviceExtension;
    PFILE_NAME_INFORMATION  nameInfo;
    ULONG                   size;
    PRP_FILE_CONTEXT        context;

    PAGED_CODE();

    try {

        context = Entry->fsContext;

        deviceExtension = DeviceObject->DeviceExtension;

        retval = STATUS_BUFFER_OVERFLOW;
        size = sizeof(FILE_NAME_INFORMATION) + 1024;

        while (retval == STATUS_BUFFER_OVERFLOW) {

            irp = IoAllocateIrp(DeviceObject->StackSize, FALSE);

            if (irp) {
                irp->UserEvent = &event;
                irp->UserIosb = &Iosb;
                irp->Tail.Overlay.Thread = PsGetCurrentThread();
                irp->Tail.Overlay.OriginalFileObject = Entry->fileObj;
                irp->RequestorMode = KernelMode;
                irp->Flags |= IRP_SYNCHRONOUS_API;
                //
                // Initialize the event
                //
                KeInitializeEvent(&event, SynchronizationEvent, FALSE);

                //
                // Set up the I/O stack location.
                //

                irpSp = IoGetNextIrpStackLocation(irp);
                irpSp->MajorFunction = IRP_MJ_QUERY_INFORMATION;
                irpSp->DeviceObject = Entry->devObj;
                irpSp->FileObject = Entry->fileObj;
                irpSp->Parameters.QueryFile.FileInformationClass = FileNameInformation;

                Iosb.Status = STATUS_SUCCESS;

                //
                // Set the completion routine.
                //
                IoSetCompletionRoutine( irp, RsCompleteIrp, &event, TRUE, TRUE, TRUE );

                //
                // Send it to the FSD
                //
                nameInfo = ExAllocatePoolWithTag(NonPagedPool, size, RP_FO_TAG);
                if (NULL != nameInfo) {
                    irpSp->Parameters.QueryFile.Length = size;
                    irp->AssociatedIrp.SystemBuffer = nameInfo;

                    retval = IoCallDriver(deviceExtension->FileSystemDeviceObject, irp);

                    if (retval == STATUS_PENDING) {
                        DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsGetFileName - Wait for event.\n"));
                        retval = KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);

                        retval = Iosb.Status;
                        DebugTrace((DPFLTR_RSFILTER_ID, 
                                    DBG_INFO, 
                                    "RsFilter: QUERY_INFO returned STATUS_PENDING: nameInfo=%x size=%x\n", 
                                    nameInfo, 
                                    size));
                    }

                    DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsGetFileName - Get name info returned %x.\n", retval));

                    if (retval == STATUS_BUFFER_OVERFLOW) {
                        // Now we have the name size - allocate space and get the name
                        DebugTrace((DPFLTR_RSFILTER_ID, 
                                    DBG_ERROR,
                                    "RsFilter: QUERY_INFO returned STATUS_BUFFER_OVERFLOW: nameInfo=%x size=%x\n",
                                    nameInfo,
                                    size));

                        size = nameInfo->FileNameLength + sizeof(FILE_NAME_INFORMATION);
                        ExFreePool(nameInfo);
                        nameInfo = NULL;
                    } else if (retval == STATUS_SUCCESS) {
                        context->uniName = ExAllocatePoolWithTag(NonPagedPool, 
                                                                 sizeof(OBJECT_NAME_INFORMATION) + nameInfo->FileNameLength + sizeof(WCHAR), 
                                                                 RP_FN_TAG);
                        if (context->uniName != NULL) {
                            context->uniName->Name.Length = (USHORT) nameInfo->FileNameLength;
                            context->uniName->Name.MaximumLength = (USHORT) nameInfo->FileNameLength + sizeof(WCHAR);
                            context->uniName->Name.Buffer = (PWSTR) ((CHAR *) context->uniName + sizeof(OBJECT_NAME_INFORMATION));
                            RtlCopyMemory(context->uniName->Name.Buffer,
                                          nameInfo->FileName,
                                          context->uniName->Name.Length);
                            
                            context->uniName->Name.Buffer [context->uniName->Name.Length / sizeof (WCHAR)] = L'\0';
                        } else {
                            // no memory for the file name
                            retval = STATUS_INSUFFICIENT_RESOURCES;
                            RsLogError(__LINE__, AV_MODULE_RPFILFUN, sizeof(OBJECT_NAME_INFORMATION) + nameInfo->FileNameLength + 2,
                                       AV_MSG_MEMORY, irpSp, NULL);
                        }

                        ExFreePool(nameInfo);
                    } else {
                        ExFreePool(nameInfo);
                    }
                } else {
                    // No memory = free the irp and report an error

                    RsLogError(__LINE__, AV_MODULE_RPFILFUN, size,
                               AV_MSG_MEMORY, irpSp, NULL);
                    IoFreeIrp(irp);
                    retval = STATUS_INSUFFICIENT_RESOURCES;
                }

            } else {
                retval = STATUS_INSUFFICIENT_RESOURCES;
                RsLogError(__LINE__, AV_MODULE_RPFILFUN, sizeof(IRP),
                           AV_MSG_MEMORY, irpSp, NULL);

            }
        }
    }except (RsExceptionFilter(L"RsGetFileName", GetExceptionInformation()))
    {
        retval = STATUS_INVALID_USER_BUFFER;
    }

    DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsGetFileName - Returning %x.\n", retval));
    return(retval);
}


NTSTATUS
RsGetFileId(IN PRP_FILE_OBJ    Entry,
            IN PDEVICE_OBJECT  DeviceObject)

/*++

Routine Description:

   Get the file name

Arguments:

    Entry        -  File object queue entry
    DeviceObject -  Filter Device Object for RsFilter


Return Value:

    0 If successful, non-zero if the name was not found.

Note:

--*/
{
    NTSTATUS                    retval = STATUS_SUCCESS;
    KEVENT                      event;
    PIO_STACK_LOCATION          irpSp;
    IO_STATUS_BLOCK             Iosb;
    PIRP                        irp;
    PDEVICE_EXTENSION           deviceExtension;
    FILE_INTERNAL_INFORMATION   idInfo;
    PRP_FILE_CONTEXT            context;

    PAGED_CODE();

    try {

        context = Entry->fsContext;

        deviceExtension = DeviceObject->DeviceExtension;

        DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsGetFileId - Build Irp for File ID ext = %x.\n", deviceExtension->FileSystemDeviceObject));
        irp = IoAllocateIrp(DeviceObject->StackSize, FALSE);

        if (irp) {
            irp->UserEvent = &event;
            irp->UserIosb = &Iosb;
            irp->Tail.Overlay.Thread = PsGetCurrentThread();
            irp->Tail.Overlay.OriginalFileObject = Entry->fileObj;
            irp->RequestorMode = KernelMode;
            irp->Flags |= IRP_SYNCHRONOUS_API;
            //
            // Initialize the event
            //
            KeInitializeEvent(&event, SynchronizationEvent, FALSE);

            //
            // Set up the I/O stack location.
            //

            irpSp = IoGetNextIrpStackLocation(irp);
            irpSp->MajorFunction = IRP_MJ_QUERY_INFORMATION;
            irpSp->DeviceObject = Entry->devObj;
            irpSp->FileObject = Entry->fileObj;
            irpSp->Parameters.QueryFile.Length = sizeof(FILE_INTERNAL_INFORMATION);
            irpSp->Parameters.QueryFile.FileInformationClass = FileInternalInformation;
            irp->AssociatedIrp.SystemBuffer = &idInfo;

            //
            // Set the completion routine.
            //
            IoSetCompletionRoutine( irp, RsCompleteIrp, &event, TRUE, TRUE, TRUE );

            //
            // Send it to the FSD
            //
            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsGetFileId - Call driver for File ID.\n"));
            Iosb.Status = 0;

            retval = IoCallDriver(deviceExtension->FileSystemDeviceObject, irp);

            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsGetFileId - IoCallDriver returns %x.\n", retval));

            if (retval == STATUS_PENDING) {
                DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsGetFileId - Wait for event.\n"));
                retval = KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
            }

            retval = Iosb.Status;

            DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsGetFileId - Iosb returns %x.\n", retval));

            if (retval == STATUS_SUCCESS) {
                DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsGetFileId - File ID is %x%x.\n",
                                      idInfo.IndexNumber.HighPart,
                                      idInfo.IndexNumber.LowPart));
                context->fileId = idInfo.IndexNumber.QuadPart;
            }
        } else {
            retval = STATUS_INSUFFICIENT_RESOURCES;
            RsLogError(__LINE__, AV_MODULE_RPFILFUN, sizeof(IRP),
                       AV_MSG_MEMORY, NULL, NULL);
        }
    }except (RsExceptionFilter(L"RsGetFileId", GetExceptionInformation()))
    {

        retval = STATUS_INVALID_USER_BUFFER;
    }

    DebugTrace((DPFLTR_RSFILTER_ID,DBG_INFO, "RsFilter: RsGetFileId - Returning %x.\n", retval));
    return(retval);
}


BOOLEAN
RsSetCancelRoutine(IN PIRP Irp,
                   IN PDRIVER_CANCEL CancelRoutine)
/*++

Routine Description:

    This routine is called to set up an Irp for cancel.  We will set the cancel routine
    and initialize the Irp information we use during cancel.

Arguments:

    Irp - This is the Irp we need to set up for cancel.

    CancelRoutine - This is the cancel routine for this irp.


Return Value:

    BOOLEAN - TRUE if we initialized the Irp, FALSE if the Irp has already
        been marked cancelled.  It will be marked cancelled if the user
        has cancelled the irp before we could put it in the queue.

--*/
{

    KIRQL Irql;
    BOOLEAN retval = TRUE;

    //
    //  Assume that the Irp has not been cancelled.
    //
    IoAcquireCancelSpinLock( &Irql );

    if (!Irp->Cancel) {
        IoMarkIrpPending( Irp );
        IoSetCancelRoutine( Irp, CancelRoutine );
    } else {
        retval = FALSE;
    }
    IoReleaseCancelSpinLock( Irql );
    return retval;
}


BOOLEAN
RsClearCancelRoutine (
                     IN PIRP Irp
                     )

/*++

Routine Description:

    This routine is called to clear an Irp from cancel.  It is called when RsFilter is
    internally ready to continue processing the Irp.  We need to know if cancel
    has already been called on this Irp.  In that case we allow the cancel routine
    to complete the Irp.

Arguments:

    Irp - This is the Irp we want to process further.

Return Value:

    BOOLEAN - TRUE if we can proceed with processing the Irp,  FALSE if the cancel
        routine will process the Irp.

--*/
{
    KIRQL   oldIrql;
    BOOLEAN retval = TRUE;

    IoAcquireCancelSpinLock(&oldIrql);
    //
    //  Check if the cancel routine has been called.
    //
    if (IoSetCancelRoutine( Irp, NULL ) == NULL) {
        //
        //  Let our cancel routine handle the Irp.
        //
        retval = FALSE;
    }

    IoReleaseCancelSpinLock(oldIrql);
    return retval;
}


LONG
RsExceptionFilter (
                  IN WCHAR *FunctionName,
                  IN PEXCEPTION_POINTERS ExceptionPointer
                  )

/*++

Routine Description:

    This routine logs the exception that occurred.

Arguments:

    Function name
    ExceptionPointer - Supplies the exception record to logged

Return Value:

    ULONG - returns EXCEPTION_EXECUTE_HANDLER

--*/
{
    NTSTATUS ExceptionCode = ExceptionPointer->ExceptionRecord->ExceptionCode;
    WCHAR    name[256];

    DebugTrace((DPFLTR_RSFILTER_ID, DBG_ERROR, "RsExceptionFilter %ws %p %X\n", FunctionName, ExceptionPointer->ExceptionRecord->ExceptionAddress, ExceptionCode));

#if DBG
    DbgPrint("RsFilter, excpetion in  %ws exception pointer %p exception address %p exception code %x\n", FunctionName, ExceptionPointer, ExceptionPointer->ExceptionRecord->ExceptionAddress, ExceptionCode);

    DbgBreakPoint();
#endif

    swprintf(name, L"%p - %.20ws", ExceptionPointer->ExceptionRecord->ExceptionAddress, FunctionName);

    RsLogError(__LINE__, AV_MODULE_RPFILFUN,
               ExceptionCode,
               AV_MSG_EXCEPTION,
               NULL,
               name);
    return EXCEPTION_EXECUTE_HANDLER;
}


VOID
RsInterlockedRemoveEntryList(PLIST_ENTRY Entry,
                             PKSPIN_LOCK Lock)
/*++

Routine Description

    Removes the supplied entry from the queue it is on

Arguments

    Entry -     Entry to be removed from the linked list (could be anywhere in the list)

    Lock -      Pointer to spinlock protecting the list

Return Value

    None

--*/
{
    KIRQL oldIrql;

    ExAcquireSpinLock(Lock, &oldIrql);
    RemoveEntryList(Entry);
    ExReleaseSpinLock(Lock, oldIrql);
}


PRP_IRP_QUEUE
RsDequeuePacket(
               IN PLIST_ENTRY Head,
               IN PKSPIN_LOCK Lock)
/*++

Routine Description

   Dequeues a pending IRP entry packet from the queue it is on

Arguments

    Head -      Pointer to the head of the queue

    Lock -      Pointer to spinlock protecting the list

Return Value

    Pointer to the next non-cancellable packet on the queue
    NULL if none can be found

--*/
{
    PRP_IRP_QUEUE entry;
    KIRQL         oldIrql;
    BOOLEAN       found = FALSE;

    ExAcquireSpinLock(Lock, &oldIrql);

    while (!IsListEmpty(Head)) {
        entry = (PRP_IRP_QUEUE) RemoveHeadList(Head);
        //
        // We found another packet. If this packet is
        // not already cancelled - then we are done
        //
        entry = CONTAINING_RECORD(entry,
                                  RP_IRP_QUEUE,
                                  list);

        if (RsClearCancelRoutine(entry->irp)) {
            //
            // This packet was not cancelled
            //
            found = TRUE;
            break;
        }
    }

    ASSERT ((!found) || !(entry->irp->Cancel));

    ExReleaseSpinLock(Lock, oldIrql);

    return(found ? entry : NULL);
}




NTSTATUS
RsCheckVolumeReadOnly (IN     PDEVICE_OBJECT FilterDeviceObject,
		       IN OUT PBOOLEAN       pbReturnedFlagReadOnly)

/*++

Routine Description:

    Determine if the target volume is writable

Arguments:

    FilterDeviceObject     - Filter Device Object for this filtered volume
    pbReturnedFlagReadOnly - output flag indicating if the volume is readonly


Return Value:

    0 If successful, non-zero if the test was not completed

Note:

--*/
{
    NTSTATUS                      retval                = STATUS_SUCCESS;
    POBJECT_NAME_INFORMATION      VolumeNameInfo        = NULL;
    PFILE_OBJECT                  VolumeFileObject      = NULL;
    HANDLE                        VolumeHandle          = NULL;
    BOOLEAN                       bObjectReferenced     = FALSE;
    BOOLEAN                       bHandleOpened         = FALSE;
    PDEVICE_EXTENSION             deviceExtension       = FilterDeviceObject->DeviceExtension;
    IO_STATUS_BLOCK               Iosb;
    OBJECT_ATTRIBUTES             objAttributes;
    ULONG                         ReturnedLength;
    UNICODE_STRING                ucsSlash;
    UNICODE_STRING                ucsRootDirectory;

    struct {
	FILE_FS_ATTRIBUTE_INFORMATION VolumeInformation;
	WCHAR                         VolumeNameBuffer [50];
    } FsAttributeInformationBuffer;


    PAGED_CODE();


    ucsRootDirectory.Buffer = NULL;
    ucsRootDirectory.Length = 0;

    RtlInitUnicodeString (&ucsSlash, L"\\");


    ASSERT (NULL != deviceExtension->RealDeviceObject);


    if (NT_SUCCESS (retval)) {

	retval = RsGenerateDevicePath (deviceExtension->RealDeviceObject, &VolumeNameInfo);

    }



    if (NT_SUCCESS (retval)) {

	ucsRootDirectory.MaximumLength = VolumeNameInfo->Name.Length + ucsSlash.Length + sizeof (UNICODE_NULL);
	ucsRootDirectory.Buffer        = ExAllocatePoolWithTag (NonPagedPool, ucsRootDirectory.MaximumLength, RP_RD_TAG);


	if (NULL == ucsRootDirectory.Buffer) {

	    retval = STATUS_INSUFFICIENT_RESOURCES;

	}
    }



    if (NT_SUCCESS (retval)) {

	RtlCopyUnicodeString (&ucsRootDirectory, &VolumeNameInfo->Name);
	RtlAppendUnicodeStringToString (&ucsRootDirectory, &ucsSlash);

	InitializeObjectAttributes (&objAttributes,
				    &ucsRootDirectory,
				    OBJ_KERNEL_HANDLE,
				    NULL,
				    NULL);


	retval = IoCreateFileSpecifyDeviceObjectHint (&VolumeHandle, 
						      FILE_READ_ATTRIBUTES | SYNCHRONIZE,
						      &objAttributes, 
						      &Iosb, 
						      NULL,
						      0L,
						      FILE_SHARE_DELETE,
						      FILE_OPEN,
						      FILE_SYNCHRONOUS_IO_NONALERT,
						      NULL,
						      0,
						      CreateFileTypeNone,
						      NULL,
						      IO_FORCE_ACCESS_CHECK | IO_NO_PARAMETER_CHECKING,
						      deviceExtension->FileSystemDeviceObject);

	bHandleOpened = NT_SUCCESS (retval);
    }


    if (NT_SUCCESS (retval)) {

	retval = ObReferenceObjectByHandle (VolumeHandle,
					    FILE_READ_ATTRIBUTES,
					    *IoFileObjectType,
					    KernelMode,
					    &VolumeFileObject,
					    NULL);

	bObjectReferenced = NT_SUCCESS (retval);

    }



    if (NT_SUCCESS (retval)) {

	retval = IoQueryVolumeInformation (VolumeFileObject,
					   FileFsAttributeInformation,
					   sizeof (FsAttributeInformationBuffer),
					   &FsAttributeInformationBuffer,
					   &ReturnedLength);

    }


    if (NT_SUCCESS (retval)) {

	ASSERT (ReturnedLength >= sizeof (FsAttributeInformationBuffer.VolumeInformation));

	*pbReturnedFlagReadOnly = (0 != (FsAttributeInformationBuffer.VolumeInformation.FileSystemAttributes & 
					 FILE_READ_ONLY_VOLUME));

    }



    if (bObjectReferenced) {
	ObDereferenceObject (VolumeFileObject);
    }

    if (bHandleOpened) {
        ZwClose (VolumeHandle);
    }

    if (NULL != ucsRootDirectory.Buffer) {
        ExFreePool (ucsRootDirectory.Buffer);
    }

    if (NULL != VolumeNameInfo) {
	ExFreePool (VolumeNameInfo);
    }


    return (retval);
}


NTSTATUS RsTraceInitialize (ULONG ulRequestedTraceEntries)
    {
    NTSTATUS			status      = STATUS_SUCCESS;
    PRP_TRACE_CONTROL_BLOCK	tcb         = NULL;


    if ((NULL == RsTraceControlBlock) && (ulRequestedTraceEntries > 0))
	{
	tcb = (PRP_TRACE_CONTROL_BLOCK) ExAllocatePoolWithTag (NonPagedPool,
							       sizeof (RP_TRACE_CONTROL_BLOCK),
							       RP_TC_TAG);

	status = (NULL == tcb) ? STATUS_INSUFFICIENT_RESOURCES : STATUS_SUCCESS;


	if (NT_SUCCESS (status))
	    {
	    KeInitializeSpinLock (&tcb->Lock);

	    tcb->EntryNext    = 0;
	    tcb->EntryMaximum = ulRequestedTraceEntries;
	    tcb->EntryBuffer  = (PRP_TRACE_ENTRY) ExAllocatePoolWithTag (NonPagedPool,
									 sizeof (RP_TRACE_ENTRY) * ulRequestedTraceEntries,
									 RP_TE_TAG);

	    status = (NULL == tcb->EntryBuffer) ? STATUS_INSUFFICIENT_RESOURCES : STATUS_SUCCESS;
	    }


	if (NT_SUCCESS (status))
	    {
	    RsTraceControlBlock = tcb;
	    tcb = NULL;
	    }
	}


    if (NULL != tcb)
	{
	if (NULL != tcb->EntryBuffer) ExFreePool (tcb->EntryBuffer);

	ExFreePool (tcb);
	}


    return (status);
    }


/*
** Add a trace entry to the trace buffer.
*/
VOID RsTraceAddEntry (RpModuleCode ModuleCode,
		      USHORT       usLineNumber,
		      ULONG_PTR    Value1,
		      ULONG_PTR    Value2,
		      ULONG_PTR    Value3,
		      ULONG_PTR    Value4)
    {
    PRP_TRACE_ENTRY		teb;
    PRP_TRACE_CONTROL_BLOCK	tcb = RsTraceControlBlock;
    LARGE_INTEGER		Timestamp;
    KIRQL			PreviousIpl;


    if (NULL != tcb)
	{
	KeQuerySystemTime (&Timestamp);

	KeAcquireSpinLock (&tcb->Lock, &PreviousIpl);

	if (tcb->EntryNext >= tcb->EntryMaximum) 
	    {
	    tcb->EntryNext = 0;
	    }

	teb = &tcb->EntryBuffer [tcb->EntryNext];

	teb->ModuleCode   = ModuleCode;
	teb->usLineNumber = usLineNumber;
	teb->usIrql       = (USHORT) PreviousIpl;
	teb->Timestamp    = Timestamp;
	teb->Value1       = Value1;
	teb->Value2       = Value2;
	teb->Value3       = Value3;
	teb->Value4       = Value4;

	tcb->EntryNext++;

	KeReleaseSpinLock (&tcb->Lock, PreviousIpl);
	}
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\fsa\fsafltr.h ===
#ifndef _FSAFLTR_
#define _FSAFLTR_

/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    fsafltr.h

Abstract:

    This class represents a file system filter for NTFS 5.0.

Author:

    Chuck Bardeen   [cbardeen]   12-Feb-1997

Revision History:

--*/

#include "resource.h"       // main symbols

#include "wsb.h"
#include "fsa.h"
#include "rpdata.h"
#include "rpguid.h"
#include "rpio.h"


typedef struct _FSA_IOCTL_CONTROL {
    HANDLE      dHand;
    OVERLAPPED  overlap;
    RP_MSG      in;
    RP_MSG      out;
    DWORD       outSize;
    struct _FSA_IOCTL_CONTROL   *next;
} FSA_IOCTL_CONTROL, *PFSA_IOCTL_CONTROL;

//
// This defines the length of time a client structure will be kept around after 
// the last recall was done (in seconds).
//
#define FSA_CLIENT_EXPIRATION_TIME  600 // 10 minutes
#define THREAD_HANDLE_COUNT 2 //for WaitForMultipleObjects array

/*++

Class Name:
    
    CFsaFilter

Class Description:

    This class represents a file system filter for NTFS 5.0.

--*/

class CFsaFilter : 
    public CWsbCollectable,
    public IFsaFilter,
    public IFsaFilterPriv,
    public CComCoClass<CFsaFilter,&CLSID_CFsaFilterNTFS>
{
public:
    CFsaFilter() {}
BEGIN_COM_MAP(CFsaFilter)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IFsaFilter)
    COM_INTERFACE_ENTRY(IFsaFilterPriv)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_FsaFilter)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);
    STDMETHOD(FinalRelease)(void);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IUnknown* pUnknown, SHORT* pResult);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbTestable
    STDMETHOD(Test)(USHORT *passed, USHORT* failed);

// IFsaFilterPriv
public:
    STDMETHOD(Init)(IFsaServer* pServer);
    STDMETHOD(SetIdentifier)(GUID id);
    STDMETHOD(IoctlThread)(void);
    STDMETHOD(PipeThread)(void);
    STDMETHOD(SendCancel)(IFsaFilterRecallPriv *pRecallPriv);
    STDMETHOD(SendComplete)(IFsaFilterRecallPriv *pRecall, HRESULT result);

// IFsaFilter
public:
    STDMETHOD(Cancel)(void);
    STDMETHOD(CancelRecall)(IFsaFilterRecall* pRecall);
    STDMETHOD(CompareToIdentifier)(GUID id, SHORT* pResult);
    STDMETHOD(CompareToIFilter)(IFsaFilter* pFilter, SHORT* pResult);
    STDMETHOD(DeleteRecall)(IFsaFilterRecall* pRecall);
    STDMETHOD(EnumRecalls)(IWsbEnum** ppEnum);
    STDMETHOD(GetAdminExemption)(BOOL *isExempt);
    STDMETHOD(GetIdentifier)(GUID* pId);
    STDMETHOD(GetLogicalName)(OLECHAR** pName, ULONG bufferSize);
    STDMETHOD(GetMaxRecallBuffers)(ULONG* pMaxBuffers);
    STDMETHOD(GetMaxRecalls)(ULONG* pMaxRecalls);
    STDMETHOD(GetMinRecallInterval)(ULONG* pMinIterval);
    STDMETHOD(GetState)(HSM_JOB_STATE* pState);
    STDMETHOD(IsEnabled)();
    STDMETHOD(Pause)(void);
    STDMETHOD(Resume)(void);
    STDMETHOD(SetIsEnabled)(BOOL isEnabled);
    STDMETHOD(SetMaxRecalls)(ULONG maxRecalls);
    STDMETHOD(SetMinRecallInterval)(ULONG minIterval);
    STDMETHOD(SetMaxRecallBuffers)(ULONG maxBuffers);
    STDMETHOD(Start)(void);
    STDMETHOD(StopIoctlThread)(void);
    STDMETHOD(FindRecall)(GUID recallId, IFsaFilterRecall** pRecall);
    STDMETHOD(SetAdminExemption)(BOOL isExempt);

private:
    HRESULT DoOpenAction(PFSA_IOCTL_CONTROL pIoCmd);
    HRESULT DoRecallWaitingAction(PFSA_IOCTL_CONTROL pIoCmd);
    HRESULT DoRecallAction(PFSA_IOCTL_CONTROL pIoCmd);
    HRESULT DoNoRecallAction(PFSA_IOCTL_CONTROL pIoCmd);
    HRESULT DoCloseAction(PFSA_IOCTL_CONTROL pIoCmd);
    HRESULT DoPreDeleteAction(PFSA_IOCTL_CONTROL pIoCmd);
    HRESULT DoPostDeleteAction(PFSA_IOCTL_CONTROL pIoCmd);
    HRESULT DoCancelRecall(ULONGLONG filterId);
    HRESULT CleanupClients(void);
    NTSTATUS CFsaFilter::TranslateHresultToNtStatus(HRESULT hr);
    

protected:
    GUID                        m_id;
    HSM_JOB_STATE               m_state;
    ULONG                       m_maxRecalls;
    ULONG                       m_minRecallInterval;
    ULONG                       m_maxRecallBuffers;
    HANDLE                      m_pipeHandle;
    HANDLE                      m_pipeThread;
    HANDLE                      m_ioctlThread;
    HANDLE                      m_ioctlHandle;
    HANDLE                      m_terminateEvent;
    IFsaServer*                 m_pFsaServer;       // Parent Pointer, Weak Reference
    CComPtr<IWsbCollection>     m_pClients;
    CComPtr<IWsbCollection>     m_pRecalls;
    CRITICAL_SECTION            m_clientLock;       // Protect client collection from multiple thread access
    CRITICAL_SECTION            m_recallLock;       // Protect recall collection from multiple thread access
    CRITICAL_SECTION            m_stateLock;        // Protect state change while sending new Ioctls
    BOOL                        m_bCritSecCreated;  // Indicates whether all CritSec were created successfully (for cleanup)
    BOOL                        m_isEnabled;
    BOOL                        m_exemptAdmin;      // TRUE = exempt admin from runaway recall check
};

#endif  // _FSAFLTR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\fsa\fsaftclt.cpp ===
/*++

(c) 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    fsaftclt.cpp

Abstract:

    This class represents a user who the filter has detected accessing a file with placeholder information.

Author:

    Chuck Bardeen   [cbardeen]   12-Feb-1997

Revision History:

--*/

#include "stdafx.h"
extern "C" {
#include <ntseapi.h>
#include <wchar.h>
#include <lmaccess.h>
#include <lmserver.h>
#include <lmshare.h>
#include <lmapibuf.h>
#include <lmerr.h>

// #define MAC_SUPPORT  // NOTE: You must define MAC_SUPPORT in fsafltr.cpp to enable all the code

#ifdef MAC_SUPPORT
#include <macfile.h>
#endif  
}


#define WSB_TRACE_IS        WSB_TRACE_BIT_FSA

#include "wsb.h"
#include "fsa.h"
#include "fsaftclt.h"

static USHORT iCountFtclt = 0;  // Count of existing objects

//
// We need to dynamically load the DLL for MAC support because it is not there if
// the MAC service is not installed.
//
#ifdef MAC_SUPPORT
HANDLE      FsaDllSfm = 0;
BOOL        FsaMacSupportInstalled = FALSE;

extern "C" {
DWORD   (*pAfpAdminConnect) (LPWSTR lpwsServerName, PAFP_SERVER_HANDLE phAfpServer);
VOID    (*pAfpAdminDisconnect) (AFP_SERVER_HANDLE hAfpServer);
VOID    (*pAfpAdminBufferFree) (PVOID pBuffer);
DWORD   (*pAfpAdminSessionEnum) (AFP_SERVER_HANDLE hAfpServer, LPBYTE *lpbBuffer,
            DWORD dwPrefMaxLen, LPDWORD lpdwEntriesRead, LPDWORD lpdwTotalEntries,
            LPDWORD lpdwResumeHandle);
}
#endif  

DWORD FsaIdentifyThread(void *pNotifyInterface);



DWORD FsaIdentifyThread(
    void* pVoid
    )

/*++
    Entry point of the thread that performs identify operation with remote clients.

--*/
{
HRESULT     hr;

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    hr = ((CFsaFilterClient*) pVoid)->IdentifyThread();
    CoUninitialize();
    return(hr);
}

//
//  Get RsNotify interface (being used here in identify thread -
//  similar utility function is being used in RsLnk)
//
static
HRESULT
GetNotifyClientInterface(
    IN  OLECHAR * machineName,
    OUT IFsaRecallNotifyClient ** ppClient
    )
{
    HRESULT hr = S_OK;

    try {

        //
        // Make sure parameters OK and OUTs initially cleared
        //

        WsbAffirmPointer ( ppClient );
        *ppClient = 0;

        //
        // If connecting local, things work better to use NULL
        // for the computer name
        //

        if ( machineName ) {

            CWsbStringPtr localMachine;
            WsbAffirmHr( WsbGetComputerName( localMachine ) );

            if( _wcsicmp( localMachine, machineName ) == 0 ) {

                machineName = 0;

            }

        }

        //
        // Set server info
        //
        COSERVERINFO        csi;
        COAUTHINFO          cai;
        memset ( &csi, 0, sizeof ( csi ) );
        memset ( &cai, 0, sizeof ( cai ) );

        // Set machine name
        csi.pwszName  = machineName;

        // Create a proxy with security settings of no authentication (note that RsNotify is running with this security)
        cai.dwAuthnSvc = RPC_C_AUTHN_WINNT;
        cai.dwAuthzSvc = RPC_C_AUTHZ_DEFAULT;
        cai.pwszServerPrincName = NULL;
        cai.dwImpersonationLevel = RPC_C_IMP_LEVEL_IMPERSONATE;
        cai.pAuthIdentityData = NULL;
        cai.dwCapabilities = EOAC_NONE;

        cai.dwAuthnLevel = RPC_C_AUTHN_LEVEL_NONE;

        csi.pAuthInfo = &cai;

        //
        // We want IFsaRecallNotifyClient back
        //

        MULTI_QI            mqi;
        memset ( &mqi, 0, sizeof ( mqi ) );
        mqi.pIID = &IID_IFsaRecallNotifyClient;

        //
        // Make the connection...
        //

        WsbAffirmHr ( CoCreateInstanceEx ( 
            CLSID_CFsaRecallNotifyClient, 0, 
	        CLSCTX_NO_FAILURE_LOG | ( machineName ? CLSCTX_REMOTE_SERVER : CLSCTX_LOCAL_SERVER ), 
            &csi, 1, &mqi ) );
        WsbAffirmHr ( mqi.hr );

        //
        // We need to make sure we clean up correctly if any interface
        // post-processing fails, so assign over to a smart pointer for
        // the time being
        //

        CComPtr<IFsaRecallNotifyClient> pClientTemp = (IFsaRecallNotifyClient*)mqi.pItf;
        mqi.pItf->Release ( );

        //
        // Finally, we need to set the security on the procy to allow the
        // anonymous connection. Values should be the same as above (COAUTHINFO)
        // We need to make sure this is a remote machine first. Otherwise, we
        // get an error of E_INVALIDARG.
        //
        if( machineName ) {

            CComPtr<IClientSecurity> pSecurity;
            WsbAffirmHr( pClientTemp->QueryInterface( IID_IClientSecurity, (void**)&pSecurity ) );

            WsbAffirmHr( pSecurity->SetBlanket ( pClientTemp, RPC_C_AUTHN_NONE, RPC_C_AUTHZ_NONE, 0, RPC_C_AUTHN_LEVEL_NONE, RPC_C_IMP_LEVEL_IDENTIFY, 0, 0 ) );

        }

        //
        // Finally, assign over and AddRef the return.
        //

        *ppClient = pClientTemp;
        (*ppClient)->AddRef ( );

    } WsbCatch ( hr );

    return ( hr );
}


HRESULT
CFsaFilterClient::CheckRecallLimit(
    IN DWORD   minRecallInterval,
    IN DWORD   maxRecalls,
    IN BOOLEAN exemptAdmin
    )

/*++

Implements:

  IWsbCollectable::CheckRecallLimit().

--*/
{
    HRESULT                     hr = S_OK;
    FILETIME                    now, last;
    LARGE_INTEGER               tNow, tLast;
    ULONG                       rCount;


    WsbTraceIn(OLESTR("CFsaFilterClient::CheckRecallLimit"), OLESTR(""));
    
    try {
        //
        // Now check for runaway recall limits if the user is not
        // an administrator
        //
        
        if ((!m_isAdmin) || (!exemptAdmin)) {
            //
            // See if the time since the end of the last recall is 
            // less than m_minRecallInterval (in seconds) and if so, 
            // increment the count.
            // If not, then reset the count (if we were not 
            // already triggered).
            // If the count is equal to the max then set the trigger.
            //
            WsbTrace(OLESTR("CHsmFilter::IoctlThread: Not an administrator or admin is not exempt.\n"));
            GetSystemTimeAsFileTime(&now);
            tNow.LowPart = now.dwLowDateTime;
            tNow.HighPart = now.dwHighDateTime;
    
            GetLastRecallTime(&last);
    
            tLast.LowPart = last.dwLowDateTime;
            tLast.HighPart = last.dwHighDateTime;
            //
            //  Get the time (in 100 nano-second units)
            //  from the end of the last recall until now.
            //
            tNow.QuadPart -= tLast.QuadPart;
            //
            // Convert to seconds and check against the interval time
            //
            tNow.QuadPart /= (LONGLONG) 10000000;
            if (tNow.QuadPart < (LONGLONG) minRecallInterval) {
                //
                // This one counts - increment the count
                // and check for a trigger.
                //
                GetRecallCount(&rCount);
                rCount++;
                SetRecallCount(rCount);
    
                WsbTrace(OLESTR("CHsmFilterClient::CheckRecallLimit: Recall count bumped to %ls.\n"),
                        WsbLongAsString(rCount));
    
                if (rCount >= maxRecalls) {
                    // 
                    // Hit the runaway recall limit.  Set the 
                    // limit flag.
                    //
                    WsbTrace(OLESTR("CHsmFilter::IoctlThread: Hit the runaway recall limit!!!.\n"));
                    SetHitRecallLimit(TRUE);
                }
            } else {
                //
                // Reset the count if they are not already triggered.
                // If they are triggered then reset the trigger and
                // limit if it has been a respectable time.
                // TBD - What is a respectable time??
                //
                if (HitRecallLimit() != S_FALSE) {
                    if (tNow.QuadPart > (LONGLONG) minRecallInterval * 100) {
                        //
                        // A respectable time has passed - reset the trigger and count.
                        //
                        WsbTrace(OLESTR("CHsmFilterClient::CheckRecallLimit: Resetting recall limit trigger and count.\n"));
                        SetHitRecallLimit(FALSE);
                        SetRecallCount(0);
                        m_loggedLimitError = FALSE;
                    }
                } else {
                    //
                    // This one did not count and they were not already triggered.
                    // Reset the count to zero.
                    //
                    WsbTrace(OLESTR("CHsmFilterClient::CheckRecallLimit: Resetting recall count.\n"));
                    SetRecallCount(0);
                }
            }
            //
            // Fail if the limit is hit.
            //
            WsbAffirm(HitRecallLimit() == S_FALSE, FSA_E_HIT_RECALL_LIMIT);
        }

    } WsbCatch(hr);

    //  NOTE - IF RUNAWAY RECALL BEHAVIOR CHANGES TO TRUNCATE ON CLOSE, CHANGE
    //  FSA_MESSAGE_HIT_RECALL_LIMIT_ACCESSDENIED TO FSA_MESSAGE_HIT_RECALL_LIMIT_TRUNCATEONCLOSE.

    if ( (hr == FSA_E_HIT_RECALL_LIMIT) && (!m_loggedLimitError)) {
        WsbLogEvent(FSA_MESSAGE_HIT_RECALL_LIMIT_ACCESSDENIED, 0, NULL, (WCHAR *) m_userName, NULL);
        m_loggedLimitError = TRUE;
    }

    WsbTraceOut(OLESTR("CHsmFilterClient::CheckRecallLimit"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaFilterClient::CompareBy(
    FSA_FILTERCLIENT_COMPARE by
    )

/*++

Implements:

  IFsaFilterClient::CompareBy().

--*/
{
    HRESULT                 hr = S_OK;

    m_compareBy = by;
    m_isDirty = TRUE;

    return(hr);
}


HRESULT
CFsaFilterClient::CompareTo(
    IN IUnknown* pUnknown,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbCollectable::CompareTo().

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IFsaFilterClient>   pClient;

    WsbTraceIn(OLESTR("CFsaFilterClient::CompareTo"), OLESTR(""));
    
    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pUnknown, E_POINTER);

        // We need the IWsbBool interface to get the value of the object.
        WsbAffirmHr(pUnknown->QueryInterface(IID_IFsaFilterClient, (void**) &pClient));

        // Compare the rules.
        hr = CompareToIClient(pClient, pResult);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmFilterClient::CompareTo"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CFsaFilterClient::CompareToAuthenticationId(
    IN LONG luidHigh,
    IN ULONG luidLow,
    OUT SHORT* pResult
    )

/*++

Implements:

  IFsaFilterClient::CompareToAuthenticationId().

--*/
{
    HRESULT     hr = S_OK;
    SHORT       aResult;

    WsbTraceIn(OLESTR("CFsaFilterClient::CompareToAuthenticationId"), OLESTR(""));

    try {

        if (m_luidHigh > luidHigh) {
            aResult = 1;
        } else if (m_luidHigh < luidHigh) {
            aResult = -1;
        } else if (m_luidLow > luidLow) {
            aResult = 1;
        } else if (m_luidLow < luidLow) {
            aResult = -1;
        } else {
            aResult = 0;
        }

        if (0 != aResult) {
            hr = S_FALSE;
        }

        if (0 != pResult) {
            *pResult = aResult;
        }


    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaFilterClient::CompareToAuthenticationId"), OLESTR("hr = <%ls>, result = <%d>"), WsbHrAsString(hr), aResult);

    return(hr);
}


HRESULT
CFsaFilterClient::CompareToIClient(
    IN IFsaFilterClient* pClient,
    OUT SHORT* pResult
    )

/*++

Implements:

  IFsaFilterClient::CompareToIClient().

--*/
{
    HRESULT         hr = S_OK;
    CWsbStringPtr   name;
    LONG            luidHigh;
    ULONG           luidLow;

    WsbTraceIn(OLESTR("CFsaFilterClient::CompareToIClient"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pClient, E_POINTER);

        switch (m_compareBy) {
        case FSA_FILTERCLIENT_COMPARE_ID:
            WsbAffirmHr(pClient->GetAuthenticationId(&luidHigh, &luidLow));
            hr = CompareToAuthenticationId(luidHigh, luidLow, pResult);
            break;
        case FSA_FILTERCLIENT_COMPARE_MACHINE:
            WsbAffirmHr(pClient->GetMachineName(&name, 0));
            hr = CompareToMachineName(name, pResult);
            break;
        default:
            WsbAssert(FALSE, E_UNEXPECTED);
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaFilterClient::CompareToIClient"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CFsaFilterClient::CompareToMachineName(
    IN OLECHAR* name,
    OUT SHORT* pResult
    )

/*++

Implements:

  IFsaFilterClient::CompareToMachineName().

--*/
{
    HRESULT     hr = S_OK;
    SHORT       aResult;

    WsbTraceIn(OLESTR("CFsaFilterClient::CompareToMachineName"), OLESTR(""));

    try {

        aResult = (SHORT)wcscmp(name, m_machineName); // TBD - Case sensitive or not?

        if (0 != aResult) {
            hr = S_FALSE;
        }
        
        if (0 != pResult) {
            *pResult = aResult;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaFilterClient::CompareToMachineName"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaFilterClient::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    WsbTraceIn(OLESTR("CFsaFilterClient::FinalConstruct"),OLESTR(""));
    try {

        WsbAffirmHr(CWsbCollectable::FinalConstruct());

        m_compareBy = FSA_FILTERCLIENT_COMPARE_ID;
        m_luidHigh = 0;
        m_luidLow = 0;
        m_hasRecallDisabled = FALSE;
        m_hitRecallLimit = FALSE;
        m_lastRecallTime.dwLowDateTime = 0; 
        m_lastRecallTime.dwHighDateTime = 0;    
        m_identified = FALSE;
        m_tokenSource = L"";
        m_msgCounter = 1;
        m_identifyThread = NULL;
        m_isAdmin = FALSE;
        m_loggedLimitError = FALSE;
        m_recallCount = 0;
    
    } WsbCatch(hr);

    iCountFtclt++;
    WsbTraceOut(OLESTR("CFsaFilterClient::FinalConstruct"),OLESTR("Count is <%d>"), iCountFtclt);

    return(hr);
}
void
CFsaFilterClient::FinalRelease(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalRelease().

--*/
{
    WsbTraceIn(OLESTR("CFsaFilterClient::FinalRelease"),OLESTR(""));

    if (NULL != m_identifyThread) {
        CloseHandle(m_identifyThread);
        m_identifyThread = NULL;
    }

    CWsbCollectable::FinalRelease();

    iCountFtclt--;
    WsbTraceOut(OLESTR("CFsaFilterClient::FinalRelease"),OLESTR("Count is <%d>"), iCountFtclt);
}


HRESULT
CFsaFilterClient::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaFilterClient::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CFsaFilterClientNTFS;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaFilterClient::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CFsaFilterClient::GetAuthenticationId(
    OUT LONG* pLuidHigh,
    OUT ULONG* pLuidLow
    )

/*++

Implements:

  IFsaFilterClient::GetAuthenticationId().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != pLuidHigh, E_POINTER);
        WsbAssert(0 != pLuidLow, E_POINTER);

        *pLuidHigh = m_luidHigh;
        *pLuidLow = m_luidLow;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaFilterClient::GetDomainName(
    OUT OLECHAR** pName,
    IN ULONG bufferSize
    )

/*++

Implements:

  IFsaFilterClient::GetDomainName().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != pName, E_POINTER);
        WsbAffirmHr(m_domainName.CopyTo(pName, bufferSize));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaFilterClient::GetIsAdmin(
    OUT BOOLEAN *pIsAdmin
    )

/*++

Implements:

  IPersist::GetIsAdmin().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaFilterClient::GetIsAdmin"), OLESTR(""));

    try {

        WsbAssert(0 != pIsAdmin, E_POINTER);
        *pIsAdmin = m_isAdmin;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaFilterClient::GetIsAdmin"), OLESTR("hr = <%ls>, isAdmin = <%u>"), WsbHrAsString(hr), *pIsAdmin);

    return(hr);
}


HRESULT
CFsaFilterClient::GetLastRecallTime(
    OUT FILETIME* pTime
    )

/*++

Implements:

  IFsaFilterClient::GetLastRecallTime().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != pTime, E_POINTER); 
        *pTime = m_lastRecallTime;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaFilterClient::GetMachineName(
    OUT OLECHAR** pName,
    IN ULONG bufferSize
    )

/*++

Implements:

  IFsaFilterClient::GetMachineName().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != pName, E_POINTER);
        WsbAffirmHr(m_machineName.CopyTo(pName, bufferSize));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaFilterClient::GetRecallCount(
    OUT ULONG* pCount
    )

/*++

Implements:

  IFsaFilterClient::GetRecallCount().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != pCount, E_POINTER); 
        *pCount = m_recallCount;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaFilterClient::GetUserName(
    OUT OLECHAR** pName,
    IN ULONG bufferSize
    )

/*++

Implements:

  IFsaFilterClient::GetUserName().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != pName, E_POINTER);
        WsbAffirmHr(m_userName.CopyTo(pName, bufferSize));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaFilterClient::GetSizeMax(
    OUT ULARGE_INTEGER* pSize
    )

/*++

Implements:

  IPersistStream::GetSizeMax().

--*/
{
    HRESULT                 hr = S_OK;


    WsbTraceIn(OLESTR("CFsaFilterClient::GetSizeMax"), OLESTR(""));

    try {

        WsbAssert(0 != pSize, E_POINTER);
        pSize->QuadPart = 0;

        // WE don't need to persist these.
        hr = E_NOTIMPL;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaFilterClient::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pSize));

    return(hr);
}


HRESULT
CFsaFilterClient::HasRecallDisabled(
    void
    )

/*++

Implements:

  IFsaFilterClient::HasRecallDisabled().

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CFsaFilterClient::HasRecallDisabled"), OLESTR(""));
    
    if (!m_hasRecallDisabled) {
        hr = S_FALSE;
    }

    WsbTraceOut(OLESTR("CHsmFilterClient::HasRecallDisabled"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaFilterClient::HitRecallLimit(
    void
    )

/*++

Implements:

  IFsaFilterClient::HitRecallLimit().

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CFsaFilterClient::HitRecallLimit"), OLESTR(""));
    
    if (!m_hitRecallLimit) {
        hr = S_FALSE;
    }

    WsbTraceOut(OLESTR("CHsmFilterClient::HitRecallLimit"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CFsaFilterClient::IdentifyThread(
    void
    )

/*++

Implements:

  CFsaFilterClient::IdentifyThread().

Notes:
  Unlike recall start/stop messages that were moved to RsLnk.exe (bugs 570471, 571109),
  the identification is still being done from RsServ for the following reasons:
  1) There is only one IdentifyThread - moving this thread to RsLnk solves nothing
  2) The notification process actally needs to know whether an identification is taking 
     place, so it could delay the notification (wait for the thread to be done).

--*/
{
#define WSB_BUFF_SIZE           1024

    HRESULT             hr = S_OK;
    BOOL                done, guestUser, noUser;
    DWORD               res, totalEnt, numEnt;
    UCHAR               *buff = NULL;
    NET_API_STATUS      status;
    SESSION_INFO_1      *sess;
    CWsbStringPtr       pipePath;
    ULONG               holdOff = 0;
#ifdef MAC_SUPPORT
    LPBYTE              macBuff = NULL;
    PAFP_SESSION_INFO   macInfo;
    AFP_SERVER_HANDLE   macHandle = 0;
    DWORD               macResume = 0;
    DWORD               macTotalEntries, macTotalRead;
    DWORD               result;
#endif


    WsbTraceIn(OLESTR("CFsaFilterClient::IdentifyThread"), OLESTR(""));

    try {
        WsbTrace(OLESTR("CFsaFilterClient::IdentifyThread Flag: %x  Client ID: %x:%x Source: %ls\n"), 
            m_identified, m_luidHigh, m_luidLow, (WCHAR *) m_tokenSource);

        //
        // If already identified then we bail out here.
        //
        WsbAffirm(m_identified == FALSE, S_OK);

        
        done = FALSE;
        res = 0;
        
        noUser = FALSE;
        if (_wcsicmp(m_userName, L"GUEST") == 0) {
            /* It is the guest user - find all sessions and
                send to ones marked guest */
            guestUser = TRUE;
        } else {
            guestUser = FALSE;
            if (wcslen(m_userName) == 0) {
                noUser = TRUE;
            }
        }

        CComPtr<IFsaRecallNotifyClient> pRecallClient;

        WsbAffirmHr(WsbGetComputerName( pipePath ));

        WsbAffirmHr(pipePath.Prepend("\\\\"));
        WsbAffirmHr(pipePath.Append("\\pipe\\"));
        WsbAffirmHr(pipePath.Append(WSB_PIPE_NAME));

        while ( done == FALSE ) {

            if ( (guestUser == FALSE) && (noUser == FALSE) ) {

                // If NetSessionEnum fails, try calling again for all users
                status = NetSessionEnum(NULL, NULL, m_userName, 1, &buff,
                                WSB_BUFF_SIZE, &numEnt, &totalEnt, &res);

                if (status != 0) {
                    status = NetSessionEnum(NULL, NULL, NULL, 1, &buff,
                                    WSB_BUFF_SIZE, &numEnt, &totalEnt, &res);
                }
            } else {
                status = NetSessionEnum( NULL, NULL, NULL, 1, &buff,
                    WSB_BUFF_SIZE, &numEnt, &totalEnt, &res );
            }

            if ((status == NERR_Success) || (status == ERROR_MORE_DATA)) {

                WsbTrace(OLESTR("CHsmFilterClient::IdentifyThread: NetSessionEnum output: Total entries=%ls , Read entries=%ls \n"),
                        WsbLongAsString(totalEnt), WsbLongAsString(numEnt));

                if (status != ERROR_MORE_DATA) {
                    done = TRUE;
                }

                sess = (SESSION_INFO_1  *) buff;

                while ( numEnt != 0 ) {
                    //
                    // If the request was made from the user GUEST then 
                    // we enumerate all sessions and send the           
                    // identification request to all the machines with  
                    // sessions marked as GUEST.  This is because the   
                    // session may have some other user name but the    
                    // request could still have GUEST access.           
                    //
                    if (((guestUser) && (sess->sesi1_user_flags & SESS_GUEST)) ||
                         (!guestUser)) {

                        //
                        // Send the identify request message 
                        //

                        WsbTrace(OLESTR("CFsaFilterClient::IdentifyThread - Sending identify request to %ls (local machine = %ls)\n"),
                                sess->sesi1_cname, (WCHAR *) pipePath);

                        hr = GetNotifyClientInterface ( sess->sesi1_cname, &pRecallClient );
                        if ( SUCCEEDED ( hr ) ) {

                            hr = pRecallClient->IdentifyWithServer( pipePath );
                            if (hr != S_OK) {
                                WsbTrace(OLESTR("CFsaFilterClient::IdentifyThread - error Identifing (%ls)\n"),
                                    WsbHrAsString(hr));
                            }
                        } else {
                            WsbTrace(OLESTR("CFsaFilterClient::IdentifyThread - error getting notify client interface hr = %ls (%x)\n"),
                                WsbHrAsString( hr ), hr);
                        }
                        hr = S_OK;
                        pRecallClient.Release ( );
                    }

                    sess++;
                    numEnt--;
                }

                NetApiBufferFree(buff);
                buff = NULL;
            } else {
                done = TRUE;
            }
        }
    
#ifdef MAC_SUPPORT
        //
        // Done with LAN manager scan, now do a MAC scan.
        //
        if ( (FsaMacSupportInstalled) && ((pAfpAdminConnect)(NULL, &macHandle) == NO_ERROR) ) {
            //
            // We have connected to the MAC service - do a session enumeration
            //
            macResume = 0;
            done = FALSE;   
            while (done == FALSE) {
                result = (pAfpAdminSessionEnum)(macHandle, &macBuff, -1,
                        &macTotalRead, &macTotalEntries, &macResume);

                if ((result == NO_ERROR) || (result == ERROR_MORE_DATA)) {
                        //
                        // Read some entries - send the message to each one 
                        //
                        if (macTotalRead == macTotalEntries) {
                            done = TRUE;
                        }

                        macInfo = (PAFP_SESSION_INFO) macBuff;
                        while ( macTotalRead != 0 ) {
                            //
                            // Send to each matching user
                            //
                            if ( ( NULL != macInfo->afpsess_ws_name ) &&
                                 ( _wcsicmp(m_userName, macInfo->afpsess_username ) == 0 ) ) {

                                WsbTrace(OLESTR("CHsmFilterClient::IdentifyThread: Send Identify to MAC %ls.\n"),
                                    macInfo->afpsess_ws_name);

                                //
                                // Send the identify request message 
                                //
            
                                hr = GetNotifyClientInterface ( sess->sesi1_cname, &pRecallClient );
                                if ( SUCCEEDED ( hr ) ) {
                                    pRecallClient->IdentifyWithServer ( pipePath );
                                }

                                hr = S_OK;
                                pRecallClient.Release ( );
                            }
                        macInfo++;
                        macTotalRead--;
                        }

                        (pAfpAdminBufferFree)(macBuff);
                        macBuff = NULL;
                } else {
                    done = TRUE;
                }
            (pAfpAdminDisconnect)(macHandle);
            macHandle = 0;
            }
        }
#endif
        
    } WsbCatch(hr);

    if (buff != NULL) {
        NetApiBufferFree(buff);
    }

#ifdef MAC_SUPPORT
    
    if (FsaMacSupportInstalled) {
        if (macBuff != NULL) {
            (pAfpAdminBufferFree)(macBuff);
        }
        if (macHandle != 0) {
            (pAfpAdminDisconnect)(macHandle);
        }
    }
#endif

    WsbTraceOut(OLESTR("CFsaFilterClient::IdentifyThread"), OLESTR("hr = %ls"), WsbHrAsString(hr));
    return(hr);
}



HRESULT
CFsaFilterClient::Load(
    IN IStream* pStream
    )

/*++

Implements:

  IPersistStream::Load().

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaFilterClient::Load"), OLESTR(""));

    try {
        WsbAssert(0 != pStream, E_POINTER);
        
        // No persistence.
        hr = E_NOTIMPL;

    } WsbCatch(hr);                                        

    WsbTraceOut(OLESTR("CFsaFilterClient::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaFilterClient::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )

/*++

Implements:

  IPersistStream::Save().

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IPersistStream> pPersistStream;

    WsbTraceIn(OLESTR("CFsaFilterClient::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));
    
    try {
        WsbAssert(0 != pStream, E_POINTER);
        
        // No persistence.
        hr = E_NOTIMPL;

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaFilterClient::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaFilterClient::SendRecallInfo(
    IFsaFilterRecall *pRecall,
    BOOL             starting,
    HRESULT          rHr
    )

/*++

Implements:

  CFsaFilterClient::SendRecallInfo

--*/
{
    HRESULT hr = E_FAIL;

    WsbTraceIn(OLESTR("CFsaFilterClient::SendRecallInfo"), OLESTR(""));

    if( ! m_identified && ( m_identifyThread != NULL ) ) {

        //
        // Wait for up to 10 seconds for identify thread to complete if
        // Client not yet identified
        // Note that after fix to 570399, once the thread is created, the handle will only be valid
        // (till the object is destructed), only that if the thread is not running, the handle would 
        // be signaled and the wait will finish immediately
        //
        WaitForSingleObject( m_identifyThread, 10000 );
    }

    //
    // Let the client know that the recall is starting or is finished
    //

    if ( m_identified ) {
    
        try {
            WsbTrace(OLESTR("CFsaFilterClient::SendRecallInfo - Client (%ls) is being notified of recall status (starting = %u hr = %x).\n"),
                        (WCHAR *) m_machineName, starting, rHr);
    
            //
            // Create intermediate server object which will be the client's
            // connection back to the service. This object acts as a middle
            // man to overcome the admin-only access into the FSA service.
            //
            CComPtr<IFsaRecallNotifyServer> pRecallServer;
            WsbAffirmHr(CoCreateInstance(CLSID_CFsaRecallNotifyServer, 0, CLSCTX_NO_FAILURE_LOG | CLSCTX_ALL, IID_IFsaRecallNotifyServer, (void**)&pRecallServer));
            WsbAffirmHr(pRecallServer->Init(pRecall));

            //
            // Use same object (different interface) to send the notifications
            // (bugs 570471, 571109)
            //
            CComPtr<IFsaRecallNotifySend> pRecallNotify;
            WsbAffirmHr(pRecallServer->QueryInterface(IID_IFsaRecallNotifySend, (void**)&pRecallNotify));
            CComPtr<IFsaRecallNotifyClient> pRecallClient;
            hr = pRecallNotify->SendNotification(m_machineName, starting, rHr);
            if (hr != S_OK) {
                WsbTrace(OLESTR("CFsaFilterClient::SendRecallInfo - failed in SendNotification (%ls)\n"), 
                    WsbHrAsString(hr));
            }

        } WsbCatch(hr);
    }

    WsbTraceOut(OLESTR("CFsaFilterClient::SendRecallInfo"), OLESTR("hr = %ls"), WsbHrAsString(hr));
    return(hr);
}



HRESULT
CFsaFilterClient::SetAuthenticationId(
    IN LONG luidHigh,
    IN ULONG luidLow
    )

/*++

Implements:

  IFsaFilterClient::SetAuthenticationId().

--*/
{
    m_luidHigh = luidHigh;
    m_luidLow = luidLow;

    return(S_OK);
}


HRESULT
CFsaFilterClient::SetDomainName(
    IN OLECHAR* name
    )

/*++

Implements:

  IFsaFilterClient::SetDomainName().

--*/
{
    HRESULT         hr = S_OK;

    try {

        m_domainName = name;
        WsbAssert(m_domainName != 0, E_UNEXPECTED);

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaFilterClient::SetIsAdmin(
    IN BOOLEAN isAdmin
    )

/*++

Implements:

  IFsaFilterClient::SetIsAdmin().

--*/
{
    m_isAdmin = isAdmin;

    return(S_OK);
}


HRESULT
CFsaFilterClient::SetLastRecallTime(
    IN FILETIME time
    )

/*++

Implements:

  IFsaFilterClient::SetLastRecallTime().

--*/
{
    m_lastRecallTime = time;

    return(S_OK);
}


HRESULT
CFsaFilterClient::SetMachineName(
    IN OLECHAR* name
    )

/*++

Implements:

  IFsaFilterClient::SetMachineName().

--*/
{
    HRESULT         hr = S_OK;

    try {
        WsbAssert(name != 0, E_UNEXPECTED);

        m_machineName = name;
        m_identified = TRUE;

        WsbTrace(OLESTR("CFsaFilterClient::SetMachineName Flag: %x  Client ID: %x:%x Source: %ls == %ls\n"), 
            m_identified, m_luidLow, m_luidHigh, (WCHAR *) m_tokenSource, (WCHAR *) m_machineName);


    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaFilterClient::SetRecallCount(
    IN ULONG count
    )

/*++

Implements:

  IFsaFilterClient::SetRecallCount().

--*/
{
    m_recallCount = count;

    return(S_OK);
}


HRESULT
CFsaFilterClient::SetUserName(
    IN OLECHAR* name
    )

/*++

Implements:

  IFsaFilterClient::SetUserName().

--*/
{
    HRESULT         hr = S_OK;

    try {

        m_userName = _wcsupr(name);
        WsbAssert(m_userName != 0, E_UNEXPECTED);

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaFilterClient::SetHasRecallDisabled(
    IN BOOL     hasBeen
    )

/*++

Implements:

  IFsaFilterClient::SetHasRecallDisabled().

--*/
{
    m_hasRecallDisabled = hasBeen;

    return(S_OK);
}


HRESULT
CFsaFilterClient::SetHitRecallLimit(
    IN BOOL     hasBeen
    )

/*++

Implements:

  IFsaFilterClient::SetHitRecallLimit().

--*/
{
    m_hitRecallLimit = hasBeen;

    return(S_OK);
}




HRESULT
CFsaFilterClient::SetTokenSource(
    IN CHAR     *source
    )

/*++

Implements:

  IFsaFilterClient::SetTokenSource()

--*/
{
    OLECHAR tSource[TOKEN_SOURCE_LENGTH + 1];
    memset (tSource, 0, sizeof (tSource));

    if (-1 == mbstowcs((WCHAR *) tSource, source, TOKEN_SOURCE_LENGTH)) {
        return E_INVALIDARG;
    }

    m_tokenSource = tSource;
    return(S_OK);
}


HRESULT
CFsaFilterClient::StartIdentify(
    void
    )

/*++

Implements:

  CFsaFilterClient::StartIdentify().

--*/
{
#define WSB_BUFF_SIZE           1024

    HRESULT             hr = S_OK;
    DWORD                   tid;


    WsbTraceIn(OLESTR("CFsaFilterClient::StartIdentify"), OLESTR(""));

    try {
        WsbTrace(OLESTR("CFsaFilterClient::StartIdentify Flag: %x  Client ID: %x:%x Source: %ls\n"), 
            m_identified, m_luidHigh, m_luidLow, (WCHAR *) m_tokenSource);

        //
        // If already identified then we bail out here.
        //
        WsbAffirm(m_identified == FALSE, S_OK);
        //
        // If the request is from User32 then it is local 
        //

        if (_wcsicmp(m_tokenSource, L"User32") == 0) {

            //
            // Identified as the local machine.
            // Set the name and bail out with S_OK
            //
            WsbAffirmHr(WsbGetComputerName( m_machineName ));
            m_identified = TRUE;

            WsbTrace(OLESTR("CHsmFilterClient::StartIdentify: Identified as %ls.\n"),
                    (WCHAR *) m_machineName);

            WsbThrow( S_OK );
        } else {
            //
            // This code assumes that only one thread (IoctlThread) can execute 
            // (otherwise, it should be protected by a CS)
            //
            // Start the identification thread (if one is not running yet)
            //
            DWORD dwWaitStatus = 0;
            if ( (NULL == m_identifyThread) ||
                 ((dwWaitStatus = WaitForSingleObject(m_identifyThread, 0)) == WAIT_OBJECT_0) ) {
                // Thread is not running
                WsbTrace(OLESTR("CHsmFilterClient::StartIdentify: Starting ID thread.\n"));
                HANDLE hTempThread = NULL;

                WsbAffirm((hTempThread = CreateThread(0, 0, FsaIdentifyThread, (void*) this, 0, &tid)) != 0, HRESULT_FROM_WIN32(GetLastError()));
                if (hTempThread == NULL) {           
                    WsbAssertHr(E_FAIL);  
                }

                HANDLE hPrevThread = (HANDLE)InterlockedExchangePointer(&(void *)m_identifyThread, (void *)hTempThread);
                if (hPrevThread != NULL) {
                    CloseHandle(hPrevThread);
                }

            } else {
                WsbTrace(OLESTR("CFsaFilterClient::StartIdentify: thread is null or waut failed. thread=%p wait=%lu err=%lu\n"),
                    (void *)m_identifyThread, dwWaitStatus, GetLastError());
            }
            
        }

        
    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CFsaFilterClient::StartIdentify"), OLESTR("hr = %ls"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CFsaFilterClient::Test(
    USHORT* passed,
    USHORT* failed
    )

/*++

Implements:

  IWsbTestable::Test().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != passed, E_POINTER);
        WsbAssert(0 != failed, E_POINTER);

        *passed = 0;
        *failed = 0;

    } WsbCatch(hr);

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\fsa\fsaftrcl.h ===
#ifndef _FSAFTRCL_
#define _FSAFTRCL_

/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    fsaftrcl.h

Abstract:

    This class represents a filter initiated recall request that is still in-progress.

Author:

    Chuck Bardeen   [cbardeen]   12-Feb-1997

Revision History:

--*/

#include "resource.h"       // main symbols

#include "fsa.h"


/*++

Class Name:
    
    CFsaFilterRecall

Class Description:

    This class represents a filter initiated recall request that is still in-progress.

--*/

class CFsaFilterRecall : 
    public CWsbCollectable,
    public IFsaFilterRecall,
    public IFsaFilterRecallPriv,
    public CComCoClass<CFsaFilterRecall,&CLSID_CFsaFilterRecallNTFS>
{
public:
    CFsaFilterRecall() {}
BEGIN_COM_MAP(CFsaFilterRecall)
    COM_INTERFACE_ENTRY(IFsaFilterRecall)
    COM_INTERFACE_ENTRY(IFsaFilterRecallPriv)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_FsaFilterRecall)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);
    void (FinalRelease)(void);
#ifdef FSA_RECALL_LEAK_TEST
    STDMETHOD_(unsigned long, InternalAddRef)(void);
    STDMETHOD_(unsigned long, InternalRelease)(void);
#endif
// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IUnknown* pUnknown, SHORT* pResult);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbTestable
    STDMETHOD(Test)(USHORT *passed, USHORT* failed);

// IFsaFilterRecall
public:
    STDMETHOD(CompareToIdentifier)(GUID id, SHORT* pResult);
    STDMETHOD(CompareToIRecall)(IFsaFilterRecall* pRecall, SHORT* pResult);
    STDMETHOD(CompareToDriversRecallId)(ULONGLONG id, SHORT* pResult);
    STDMETHOD(CompareToDriversContextId)(ULONGLONG id, SHORT* pResult);
    STDMETHOD(CompareBy)(FSA_RECALL_COMPARE by);
    STDMETHOD(GetIdentifier)(GUID* pId);
    STDMETHOD(GetMode)(ULONG* pMode);
    STDMETHOD(GetOffset)(LONGLONG* pOffset);
    STDMETHOD(GetPath)(OLECHAR** pName, ULONG bufferSize);
    STDMETHOD(GetResource)(IFsaResource** ppResource);
    STDMETHOD(GetRecallFlags)(ULONG* recallFlags);
    STDMETHOD(GetSession)(IHsmSession** ppSession);
    STDMETHOD(GetSize)(LONGLONG* pSize);
    STDMETHOD(GetState)(HSM_JOB_STATE* pState);
    STDMETHOD(GetUserName)(OLECHAR** pName, ULONG bufferSize);
    STDMETHOD(HasCompleted)(HRESULT resultHr);
    STDMETHOD(WasCancelled)(void);
    STDMETHOD(CreateLocalStream)(IStream **ppStream);
    STDMETHOD(CheckRecallLimit)(DWORD minRecallInterval, DWORD maxRecalls, BOOLEAN exemptAdmin);
    STDMETHOD(AddClient)(IFsaFilterClient *pWaitingClient);

// IFsaFilterRecallPriv
public:
    STDMETHOD(Cancel)(void);
    STDMETHOD(CancelByDriver)(void);
    STDMETHOD(Delete)(void);
    STDMETHOD(GetClient)(IFsaFilterClient** ppClient);
    STDMETHOD(GetDriversRecallId)(ULONGLONG* pId);
    STDMETHOD(SetDriversRecallId)(ULONGLONG pId);
    STDMETHOD(SetThreadId)(DWORD id);
    STDMETHOD(GetPlaceholder)(FSA_PLACEHOLDER* pPlaceholder);
    STDMETHOD(Init)(IFsaFilterClient* pClient, ULONGLONG pDriversRecallId, IFsaResource* pResource, OLECHAR* path, LONGLONG fileId, LONGLONG offset, LONGLONG size, ULONG mode, FSA_PLACEHOLDER* pPlaceholder, IFsaFilterPriv* pFilterPriv);
    STDMETHOD(SetIdentifier)(GUID id);
    STDMETHOD(StartRecall)(ULONGLONG offset, ULONGLONG size);
    STDMETHOD(GetStream)(IStream **ppStream);
    STDMETHOD(LogComplete)(HRESULT hr);

protected:
    CComPtr<IFsaFilterClient>   m_pClient;          
    CComPtr<IWsbCollection>     m_pWaitingClients;          
    BOOL                        m_waitingClientsNotified;
    HANDLE                      m_waitingClientEvent;
    HANDLE                      m_notifyEvent;      // An event for signaling on recall notify
    IFsaFilterPriv*             m_pFilterPriv;      // Parent Pointer, Weak Reference
    ULONGLONG                   m_driversRecallId;
    ULONG                       m_mode;
    LONGLONG                    m_offset;
    LONGLONG                    m_size;
    LONGLONG                    m_fileId;
    GUID                        m_id;
    CWsbStringPtr               m_path;
    FSA_PLACEHOLDER             m_placeholder;
    CComPtr<IFsaResource>       m_pResource;
    CComPtr<IHsmSession>        m_pSession;
    HSM_JOB_STATE               m_state;
    BOOL                        m_wasCancelled;
    DWORD                       m_cookie;
    BOOL                        m_kernelCompletionSent;
    CComPtr<IDataMover>         m_pDataMover;
    CComPtr<IStream>            m_pStream;
    ULONG                       m_compareBy;
    FILETIME                    m_startTime;
    ULONG                       numRefs;
    ULONG                       m_recallFlags;
    DWORD                       m_threadId; //thread id of thread causing recall
};

#endif  // _FSAFTRCL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\fsa\fsaitem.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    fsaitem.cpp

Abstract:

    This class contains represents a scan item (i.e. file or directory) for NTFS 5.0.

Author:

    Chuck Bardeen    [cbardeen]   1-Dec-1996

Revision History:

--*/

#include "stdafx.h"

#define WSB_TRACE_IS        WSB_TRACE_BIT_FSA

#include "wsb.h"
#include "wsbtrak.h"
#include "fsa.h"
#include "mover.h"
#include "fsaitem.h"
#include "fsaprem.h"

static USHORT iCountItem = 0;  // Count of existing objects



HRESULT
CFsaScanItem::CompareTo(
    IN IUnknown* pUnknown,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbCollectable::CompareTo().

--*/
{
    HRESULT                  hr = S_OK;
    CComPtr<IFsaScanItem>    pScanItem;

    WsbTraceIn(OLESTR("CFsaScanItem::CompareTo"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pUnknown, E_POINTER);

        // We need the IWsbBool interface to get the value of the object.
        WsbAffirmHr(pUnknown->QueryInterface(IID_IFsaScanItem, (void**) &pScanItem));

        // Compare the rules.
        hr = CompareToIScanItem(pScanItem, pResult);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaScanItem::CompareTo"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CFsaScanItem::CompareToIScanItem(
    IN IFsaScanItem* pScanItem,
    OUT SHORT* pResult
    )

/*++

Implements:

  IFsaScanItem::CompareToIScanItem().

--*/
{
    HRESULT          hr = S_OK;
    CWsbStringPtr    path;
    CWsbStringPtr    name;

    WsbTraceIn(OLESTR("CFsaScanItem::CompareToIScanItem"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pScanItem, E_POINTER);

        // Either compare the name or the id.
           WsbAffirmHr(pScanItem->GetPath(&path, 0));
           WsbAffirmHr(pScanItem->GetName(&name, 0));
           hr = CompareToPathAndName(path, name, pResult);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaScanItem::CompareToIScanItem"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CFsaScanItem::CompareToPathAndName(
    IN OLECHAR* path,
    IN OLECHAR* name,
    OUT SHORT* pResult
    )

/*++

Implements:

  IFsaScanItem::CompareToPathAndName().

--*/
{
    HRESULT       hr = S_OK;
    SHORT         aResult = 0;

    WsbTraceIn(OLESTR("CFsaScanItem::CompareToPathAndName"), OLESTR(""));

    try {

        // Compare the path.
        aResult = (SHORT) _wcsicmp(m_path, path);

        // Compare the name.
        if (0 == aResult) {
            aResult = (SHORT) _wcsicmp(m_findData.cFileName, name);
        }

        if (0 != aResult) {
            hr = S_FALSE;
        }

        if (0 != pResult) {
            *pResult = aResult;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaScanItem::CompareToPathAndName"), OLESTR("hr = <%ls>, result = <%u>"), WsbHrAsString(hr), aResult);

    return(hr);
}


HRESULT
CFsaScanItem::Copy(
    IN OLECHAR* dest,
    IN BOOL /*retainHierarcy*/,
    IN BOOL /*expandPlaceholders*/,
    IN BOOL overwriteExisting
    )

/*++

Implements:

  IFsaScanItem::Copy().

--*/
{
    HRESULT            hr = S_OK;

    try {

        // NOTE : This default behavior causes placeholders
        // to be expanded and probably doesn't retain the heirarchy.
        WsbAssert(0 != dest, E_POINTER);
        WsbAssert(CopyFile(m_findData.cFileName, dest, overwriteExisting), E_FAIL);

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaScanItem::CreateLocalStream(
    OUT IStream **ppStream
    )

/*++

Implements:

  IFsaScanItem::CreateLocalStream().

--*/
{
    HRESULT          hr = S_OK;
    LARGE_INTEGER    fileSize;
    CWsbStringPtr    volName;

    WsbTraceIn(OLESTR("CFsaScanItem::CreateLocalStream"), OLESTR(""));
    try {
        CWsbStringPtr    localName;

        if ( !m_gotPlaceholder) {
            //
            // Get the placeholder info
            //
            fileSize.LowPart = m_findData.nFileSizeLow;
            fileSize.HighPart = m_findData.nFileSizeHigh;
            WsbAffirmHr(IsManaged(0, fileSize.QuadPart));
        }

        WsbAssert( 0 != ppStream, E_POINTER);
        WsbAffirmHr( CoCreateInstance( CLSID_CNtFileIo, 0, CLSCTX_SERVER, IID_IDataMover, (void **)&m_pDataMover ) );
        //
        // Set the device name for the mover so it can set the source infor for the USN journal.
        //
        WsbAffirmHr(m_pResource->GetPath(&volName, 0));
        WsbAffirmHr( m_pDataMover->SetDeviceName(volName));
        //WsbAffirmHr(GetFullPathAndName( NULL, 0, &localName, 0));
        WsbAffirmHr(GetFullPathAndName( OLESTR("\\\\?\\"), 0, &localName, 0));
        WsbAffirmHr( m_pDataMover->CreateLocalStream(
                localName, MVR_MODE_WRITE | MVR_FLAG_HSM_SEMANTICS | MVR_FLAG_POSIX_SEMANTICS, &m_pStream ) );

        LARGE_INTEGER seekTo;
        ULARGE_INTEGER pos;
        seekTo.QuadPart = m_placeholder.dataStreamStart;
        WsbAffirmHr( m_pStream->Seek( seekTo, STREAM_SEEK_SET, &pos ) );
        *ppStream = m_pStream;
        m_pStream.p->AddRef();

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaScanItem::CreateLocalStream"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT
CFsaScanItem::Delete(
    void
    )

/*++

Implements:

  IFsaScanItem::Delete().

--*/
{
    HRESULT             hr = S_OK;
    CWsbStringPtr       tmpString;
    HANDLE              fileHandle;

    try {

        // This is the name of the file we want to delete.
        WsbAffirmHr(GetFullPathAndName(OLESTR("\\\\?\\"), 0, &tmpString, 0));

        // Since we want to be POSIX compliant, we can't use DeleteFile() and instead will
        // open with the delete on close flag. This doesn't handle read-only files, so we
        // have to change that ourselves.
        WsbAffirmHr(MakeReadWrite());

        fileHandle = CreateFile(tmpString, GENERIC_WRITE, 0, 0, OPEN_EXISTING, FILE_FLAG_OPEN_REPARSE_POINT | FILE_FLAG_POSIX_SEMANTICS | FILE_FLAG_DELETE_ON_CLOSE, 0);

        if (INVALID_HANDLE_VALUE == fileHandle) {
            WsbThrow(HRESULT_FROM_WIN32(GetLastError()));
        } else {
            if (!CloseHandle(fileHandle)) {
                WsbThrow(HRESULT_FROM_WIN32(GetLastError()));
            }
        }

    } WsbCatch(hr);

    return(hr);
}
#pragma optimize("g", off)

HRESULT
CFsaScanItem::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT        hr = S_OK;

    WsbTraceIn(OLESTR("CFsaScanItem::FinalConstruct"), OLESTR(""));

    try {

        WsbAffirmHr(CComObjectRoot::FinalConstruct());

        m_handle = INVALID_HANDLE_VALUE;
        m_gotPhysicalSize = FALSE;
        m_physicalSize.QuadPart = 0;
        m_gotPlaceholder  = FALSE;
        m_changedAttributes = FALSE;
        m_handleRPI = 0;

        //  Add class to object table
        WSB_OBJECT_ADD(CLSID_CFsaScanItemNTFS, this);

    } WsbCatch(hr);

    iCountItem++;

    WsbTraceOut(OLESTR("CFsaScanItem::FinalConstruct"), OLESTR("hr = <%ls>, Count is <%d>"),
            WsbHrAsString(hr), iCountItem);

    return(hr);
}
#pragma optimize("", on)


void
CFsaScanItem::FinalRelease(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalRelease().

--*/
{
    WsbTraceIn(OLESTR("CFsaScanItem::FinalRelease"), OLESTR(""));

    //  Subtract class from object table
    WSB_OBJECT_SUB(CLSID_CFsaScanItemNTFS, this);

    // Terminate the scan and free the path memory.
    if (INVALID_HANDLE_VALUE != m_handle) {
        FindClose(m_handle);
        m_handle = INVALID_HANDLE_VALUE;
    }
    if (0 != m_handleRPI) {
        CloseHandle(m_handleRPI);
        m_handleRPI = 0;
    }

    if (m_pUnmanageDb != NULL) {
        // Db must be open
        (void)m_pUnmanageDb->Close(m_pDbSession);
        m_pDbSession = 0;
        m_pUnmanageRec = 0;
    }

    if (TRUE == m_changedAttributes) {
        //
        // We changed it from read only to read/write - put it back.
        //
        RestoreAttributes();
    }

    //
    // Detach the data mover stream
    if (m_pDataMover != 0) {
        WsbAffirmHr( m_pDataMover->CloseStream() );
    }

    // Let the parent class do his thing.
    CComObjectRoot::FinalRelease();

    iCountItem--;
    WsbTraceOut(OLESTR("CFsaScanItem::FinalRelease"), OLESTR("Count is <%d>"), iCountItem);
}


HRESULT
CFsaScanItem::FindFirst(
    IN IFsaResource* pResource,
    IN OLECHAR* path,
    IN IHsmSession* pSession
    )

/*++

Implements:

  IFsaScanItem::FindFirst().

--*/
{
    HRESULT                  hr = S_OK;
    CWsbStringPtr            findPath;
    CWsbStringPtr            searchName;
    OLECHAR*                 slashPtr;
    DWORD                    lErr;

    WsbTraceIn(OLESTR("CFsaScanItem::FindFirst"), OLESTR("path = <%ls>"),
            path);

    try {

        WsbAssert(0 != pResource, E_POINTER);
        WsbAssert(0 != path, E_POINTER);

        // Store off some of the scan information.
        m_pResource = pResource;
        m_pSession = pSession;

        // Break up the incoming path into a path and a name.
        m_path = path;
        slashPtr = wcsrchr(m_path, L'\\');

        // We could try to support relative path stuff (i.e. current
        // directory, but I am not going to do it for now.
        WsbAffirm(slashPtr != 0, E_FAIL);
        searchName = &(slashPtr[1]);
        slashPtr[1] = 0;

        // Get a path that can be used by the find function.
        WsbAffirmHr(GetPathForFind(searchName, &findPath, 0));

        // Scan starting at the specified path.
        m_handle = FindFirstFileEx(findPath, FindExInfoStandard, &m_findData, FindExSearchNameMatch, 0, FIND_FIRST_EX_CASE_SENSITIVE);

        lErr = GetLastError();

        // If we found a file, then remember the scan handle and
        // return the scan item.
        WsbAffirm(INVALID_HANDLE_VALUE != m_handle, WSB_E_NOTFOUND);

        m_gotPhysicalSize = FALSE;
        m_physicalSize.QuadPart = 0;
        m_gotPlaceholder  = FALSE;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaScanItem::FindFirst"), OLESTR("hr = <%ls>"),
            WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaScanItem::FindNext(
    void
    )

/*++

Implements:

  IFsaScanItem::FindNext().

--*/
{
    HRESULT                    hr = S_OK;

    WsbTraceIn(OLESTR("CFsaScanItem::FindNext"), OLESTR(""));

    try {

        WsbAssert(INVALID_HANDLE_VALUE != m_handle, E_FAIL);

        if (TRUE == m_changedAttributes) {
            //
            // We changed it from read only to read/write - put it back.
            //
            RestoreAttributes();
        }

        // Continue the scan.
        WsbAffirm(FindNextFile(m_handle, &m_findData), WSB_E_NOTFOUND);

        m_gotPhysicalSize = FALSE;
        m_physicalSize.QuadPart = 0;
        m_gotPlaceholder  = FALSE;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaScanItem::FindNext"), OLESTR("hr = <%ls>"),
            WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaScanItem::GetAccessTime(
    OUT FILETIME* pTime
    )

/*++

Implements:

  IFsaScanItem::GetAccessTime().

--*/
{
    HRESULT            hr = S_OK;

    try {

        WsbAssert(0 != pTime, E_POINTER);
        *pTime = m_findData.ftLastAccessTime;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaScanItem::GetGroup(
    OUT OLECHAR** /*pGroup*/,
    IN ULONG /*bufferSize*/
    )

/*++

Implements:

  IFsaScanItem::GetGroup().

--*/
{
    HRESULT            hr = S_OK;

    try {

        hr = E_NOTIMPL;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaScanItem::GetLogicalSize(
    OUT LONGLONG* pSize
    )

/*++

Implements:

  IFsaScanItem::GetLogicalSize().

--*/
{
    HRESULT            hr = S_OK;
    LARGE_INTEGER   logSize;

    try {

        WsbAssert(0 != pSize, E_POINTER);
        logSize.LowPart = m_findData.nFileSizeLow;
        logSize.HighPart = m_findData.nFileSizeHigh;
        *pSize = logSize.QuadPart;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaScanItem::GetModifyTime(
    OUT FILETIME* pTime
    )

/*++

Implements:

  IFsaScanItem::GetModifyTime().

--*/
{
    HRESULT            hr = S_OK;

    try {

        WsbAssert(0 != pTime, E_POINTER);
        *pTime = m_findData.ftLastWriteTime;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaScanItem::GetName(
    OUT OLECHAR** pName,
    IN ULONG bufferSize
    )

/*++

Implements:

  IFsaScanItem::GetName().

--*/
{
    HRESULT            hr = S_OK;
    CWsbStringPtr    tmpString = m_findData.cFileName;

    try {

        WsbAssert(0 != pName, E_POINTER);
        WsbAffirmHr(tmpString.CopyTo(pName, bufferSize));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaScanItem::GetOwner(
    OUT OLECHAR** /*pOwner*/,
    IN ULONG      /*bufferSize*/
    )

/*++

Implements:

  IFsaScanItem::GetOwner().

--*/
{
    HRESULT            hr = S_OK;

    try {

        hr = E_NOTIMPL;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaScanItem::GetPath(
    OUT OLECHAR** pPath,
    IN ULONG bufferSize
    )

/*++

Implements:

  IFsaScanItem::GetPath().

--*/
{
    HRESULT            hr = S_OK;

    try {

        WsbAssert(0 != pPath, E_POINTER);
        WsbAffirmHr(m_path.CopyTo(pPath, bufferSize));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaScanItem::GetPathForFind(
    IN OLECHAR* searchName,
    OUT OLECHAR** pPath,
    IN ULONG bufferSize
    )

/*++

Implements:

  IFsaScanItem::GetPathForFind().

--*/
{
    HRESULT          hr = S_OK;
    CWsbStringPtr    tmpString;

    try {

        WsbAssert(0 != pPath, E_POINTER);

        // Get a buffer.
        WsbAffirmHr(tmpString.TakeFrom(*pPath, bufferSize));

        try {

            // Get the path to the resource of the resource.
            //
            WsbAffirmHr(m_pResource->GetPath(&tmpString, 0));
            WsbAffirmHr(tmpString.Prepend(OLESTR("\\\\?\\")));
            //WsbAffirmHr(tmpString.Append(OLESTR("\\")));

            // Copy in the path.
            //WsbAffirmHr(tmpString.Prepend(OLESTR("\\\\?\\")));
            WsbAffirmHr(tmpString.Append(&(m_path[1])));
            WsbAffirmHr(tmpString.Append(searchName));

        } WsbCatch(hr);

        WsbAffirmHr(tmpString.GiveTo(pPath));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaScanItem::GetPathAndName(
    IN    OLECHAR* appendix,
    OUT OLECHAR** pPath,
    IN ULONG bufferSize
    )

/*++

Implements:

  IFsaScanItem::GetPathAndName().

--*/
{
    HRESULT          hr = S_OK;
    CWsbStringPtr    tmpString;

    try {

        WsbAssert(0 != pPath, E_POINTER);

        // Get a buffer.
        WsbAffirmHr(tmpString.TakeFrom(*pPath, bufferSize));

        try {

            tmpString = m_path;
            tmpString.Append(m_findData.cFileName);

            if (0 != appendix) {
                tmpString.Append(appendix);
            }

        } WsbCatch(hr);

        // Give responsibility for freeing the memory back to the caller.
        WsbAffirmHr(tmpString.GiveTo(pPath));

    } WsbCatch(hr);


    return(hr);
}


HRESULT
CFsaScanItem::GetFullPathAndName(
    IN    OLECHAR* prependix,
    IN    OLECHAR* appendix,
    OUT OLECHAR** pPath,
    IN ULONG bufferSize
    )

/*++

Implements:

  IFsaScanItem::GetFullPathAndName().

--*/
{
    HRESULT          hr = S_OK;
    CWsbStringPtr    tmpString;
    CWsbStringPtr    tmpString2;

    try {

        WsbAssert(0 != pPath, E_POINTER);

        // Get a buffer.
        WsbAffirmHr(tmpString.TakeFrom(*pPath, bufferSize));

        try {
            if (0 != prependix) {
                tmpString = prependix;
                // Get the path to the resource of the resource.
                WsbAffirmHr(m_pResource->GetPath(&tmpString2, 0));
                WsbAffirmHr(tmpString.Append(tmpString2));
            } else {
                WsbAffirmHr(m_pResource->GetPath(&tmpString, 0));
            }

            // Copy in the path.
            WsbAffirmHr(tmpString.Append(&(m_path[1])));
            WsbAffirmHr(tmpString.Append(m_findData.cFileName));
            if (0 != appendix) {
                WsbAffirmHr(tmpString.Append(appendix));
            }

        } WsbCatch(hr);

        // Give responsibility for freeing the memory back to the caller.
        WsbAffirmHr(tmpString.GiveTo(pPath));


    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaScanItem::GetPhysicalSize(
    OUT LONGLONG* pSize
    )

/*++

Implements:

  IFsaScanItem::GetPhysicalSize().

--*/
{
    HRESULT          hr = S_OK;
    CWsbStringPtr    path;

    try {

        WsbAssert(0 != pSize, E_POINTER);

        //WsbAssertHr(GetFullPathAndName(NULL, 0, &path, 0));
        WsbAssertHr(GetFullPathAndName(OLESTR("\\\\?\\"), 0, &path, 0));

        // Only read this value in once, but wait until it is asked for
        // before reading it in (since this call takes time and many scans
        // won't need the information.
        if (!m_gotPhysicalSize) {
            m_physicalSize.LowPart = GetCompressedFileSize(path, &m_physicalSize.HighPart);
            if (MAXULONG == m_physicalSize.LowPart) {
                //  Have to check last error since  MAXULONG could be a valid
                //  value for the low part of the size.
                DWORD err = GetLastError();

                if (err != NO_ERROR) {
                    WsbTrace(OLESTR("CFsaScanItem::GetPhysicalSize of %ws Last error = %u\n"),
                        (WCHAR *) path, err);
                }

                WsbAffirm(NO_ERROR == err, E_FAIL);
            }
            m_gotPhysicalSize = TRUE;
        }

        *pSize = m_physicalSize.QuadPart;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaScanItem::GetPremigratedUsn(
    OUT LONGLONG* pFileUsn
    )

/*++

Implements:

Routine Description:

    Get the USN Journal number for this file from the premigrated list.

Arguments:

    pFileUsn - Pointer to File USN to be returned.

Return Value:

    S_OK   - success

--*/
{
    HRESULT            hr = S_OK;

    try {
        CComPtr<IWsbDbSession>              pDbSession;
        CComPtr<IFsaPremigratedDb>          pPremDb;
        CComPtr<IFsaResourcePriv>            pResourcePriv;

        WsbAssert(pFileUsn, E_POINTER);

        //  Get the premigrated list DB
        WsbAffirmHr(m_pResource->QueryInterface(IID_IFsaResourcePriv,
                (void**) &pResourcePriv));
        WsbAffirmHr(pResourcePriv->GetPremigrated(IID_IFsaPremigratedDb,
                (void**) &pPremDb));

        //  Open the premigration list
        WsbAffirmHr(pPremDb->Open(&pDbSession));

        try {
            FSA_PLACEHOLDER                     PlaceHolder;
            CComPtr<IFsaPremigratedRec>         pPremRec;
            LONGLONG                            usn;

            //  Get a DB entity for the search
            WsbAffirmHr(pPremDb->GetEntity(pDbSession, PREMIGRATED_REC_TYPE,
                    IID_IFsaPremigratedRec, (void**) &pPremRec));
            WsbAffirmHr(pPremRec->UseKey(PREMIGRATED_BAGID_OFFSETS_KEY_TYPE));

            //  Find the record
            WsbAffirmHr(GetPlaceholder(0, 0, &PlaceHolder));
            WsbAffirmHr(pPremRec->SetBagId(PlaceHolder.bagId));
            WsbAffirmHr(pPremRec->SetBagOffset(PlaceHolder.fileStart));
            WsbAffirmHr(pPremRec->SetOffset(PlaceHolder.dataStreamStart));
            WsbAffirmHr(pPremRec->FindEQ());

            //  Get the stored USN
            WsbAffirmHr(pPremRec->GetFileUSN(&usn));
            *pFileUsn = usn;
        } WsbCatch(hr);

        //  Close the DB
        pPremDb->Close(pDbSession);

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaScanItem::GetSession(
    OUT IHsmSession** ppSession
    )

/*++

Implements:

  IFsaScanItem::GetSession().

--*/
{
    HRESULT            hr = S_OK;

    try {

        WsbAssert(0 != ppSession, E_POINTER);

        *ppSession = m_pSession;
        m_pSession.p->AddRef();

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaScanItem::GetUncPathAndName(
    IN    OLECHAR* prependix,
    IN    OLECHAR* appendix,
    OUT OLECHAR** pPath,
    IN ULONG bufferSize
    )

/*++

Implements:

  IFsaScanItem::GetUncPathAndName().

--*/
{
    HRESULT          hr = S_OK;
    CWsbStringPtr    tmpString;
    CWsbStringPtr    tmpString2;

    try {

        WsbAssert(0 != pPath, E_POINTER);

        // Get a buffer.
        WsbAffirmHr(tmpString.TakeFrom(*pPath, bufferSize));

        try {
            if (0 != prependix) {
                tmpString = prependix;
                // Get the path to the resource of the resource.
                WsbAffirmHr(m_pResource->GetUncPath(&tmpString2, 0));
                WsbAffirmHr(tmpString.Append(tmpString2));
            } else {
                WsbAffirmHr(m_pResource->GetPath(&tmpString, 0));
            }

            // Copy in the path.
            WsbAffirmHr(tmpString.Append(&(m_path[1])));
            WsbAffirmHr(tmpString.Append(m_findData.cFileName));
            if (0 != appendix) {
                WsbAffirmHr(tmpString.Append(appendix));
            }

        } WsbCatch(hr);

        // Give responsibility for freeing the memory back to the caller.
        WsbAffirmHr(tmpString.GiveTo(pPath));


    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaScanItem::IsAParent(
    void
    )

/*++

Implements:

  IFsaScanItem::IsAParent().

--*/
{
    HRESULT            hr = S_FALSE;

    if ((m_findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0) {
        hr = S_OK;
    }

    return(hr);
}


HRESULT
CFsaScanItem::IsARelativeParent(
    void
    )

/*++

Implements:

  IFsaScanItem::IsARelativeParent().

--*/
{
    HRESULT            hr = S_FALSE;

    if ((m_findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0) {

        // looking for "."
        if (m_findData.cFileName[0] == L'.') {

            if (m_findData.cFileName[1] == 0) {
                hr = S_OK;
            }

            // looking for "."
            else if (m_findData.cFileName[1] == L'.') {

                if (m_findData.cFileName[2] == 0) {
                    hr = S_OK;
                }
            }
        }
    }

    return(hr);
}


HRESULT
CFsaScanItem::IsCompressed(
    void
    )

/*++

Implements:

  IFsaScanItem::IsCompressed().

--*/
{
    HRESULT            hr = S_FALSE;

    if ((m_findData.dwFileAttributes & FILE_ATTRIBUTE_COMPRESSED) != 0) {
        hr = S_OK;
    }

    return(hr);
}


HRESULT
CFsaScanItem::IsEncrypted(
    void
    )

/*++

Implements:

  IFsaScanItem::IsEncrypted().

--*/
{
    HRESULT            hr = S_FALSE;

    if ((m_findData.dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED) != 0) {
        hr = S_OK;
    }

    return(hr);
}


HRESULT
CFsaScanItem::IsDeleteOK(
    IN IFsaPostIt *pPostIt
    )

/*++

Implements:

  IFsaScanItem::IsDeleteOK().

--*/
{
    HRESULT            hr = S_OK;
    WsbTraceIn(OLESTR("CFsaScanItem::IsDeleteOK"), OLESTR(""));

    try  {
        //
        // Get the version ID from the FSA Post it.  This is the
        // version of the file at the time of the migrate request
        //
        LONGLONG            workVersionId;
        WsbAffirmHr(pPostIt->GetFileVersionId(&workVersionId));

        //
        // Get the version of the file at the time of this scan
        //
        LONGLONG            scanVersionId;
        WsbAffirmHr(GetVersionId(&scanVersionId));

        //
        // See if the versions match
        //
        WsbTrace(OLESTR("CFsaScanItem::IsDeleteOK: workVersionId:<%I64u> scanVersionId:<%I64u>\n"),
            workVersionId, scanVersionId);

        if (workVersionId != scanVersionId)  {
            WsbTrace(OLESTR("CFsaScanItem::IsDeleteOK: File version has changed!\n"));
            WsbThrow(FSA_E_FILE_CHANGED);
        }

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CFsaScanItem::IsDeleteOk"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT
CFsaScanItem::IsGroupMemberOf(
    OLECHAR* /*group*/
    )

/*++

Implements:

  IFsaScanItem::IsGroupMemberOf().

--*/
{
    HRESULT            hr = S_FALSE;

    hr = E_NOTIMPL;

    return(hr);
}


HRESULT
CFsaScanItem::IsHidden(
    void
    )

/*++

Implements:

  IFsaScanItem::IsHidden().

--*/
{
    HRESULT            hr = S_FALSE;

    if ((m_findData.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN) != 0) {
        hr = S_OK;
    }

    return(hr);
}


HRESULT
CFsaScanItem::IsManageable(
    IN LONGLONG offset,
    IN LONGLONG size
    )

/*++

Implements:

  IFsaScanItem::IsManageable().

--*/
{
    HRESULT         hr = S_FALSE;
    HRESULT         hr2;
    LONGLONG        logicalSize;
    LONGLONG        managableSize;
    LONGLONG        maxFileSize;
    FILETIME        time;
    FILETIME        managableTime;
    BOOL            isRelative;

    //
    // Get some strings for logging and tracing
    //
    CWsbStringPtr    fileName;
    CWsbStringPtr    jobName;
    try  {
        WsbAffirmHr(GetFullPathAndName( 0, 0, &fileName, 0));
        WsbAffirmHr(m_pSession->GetName(&jobName, 0));
    } WsbCatch( hr );

    WsbTraceIn(OLESTR("CFsaScanItem::IsManageable"), OLESTR("<%ls>"), (OLECHAR *)fileName);
    try {

        // To be managable the item:
        //    - can't already be managed (premigratted or truncated)
        //  - can't be a link
        //  - can't be encrypted
        //  - can't be sparse
        //  - can't have extended attributes (reparse point limitation)
        //  - must have a size bigger than the resource's default size
        //  - must have a last access time older than the resource's default time

        // Managed?
        hr2 = IsManaged(offset, size);
        if (S_FALSE == hr2) {

            // A link?
            hr2 = IsALink();
            if (S_FALSE == hr2) {

                // Encrypted?
                hr2 = IsEncrypted();
                if (S_FALSE == hr2) {

                    // A sparse?
                    hr2 = IsSparse();
                    if (S_FALSE == hr2) {

                        // A sparse?
                        hr2 = HasExtendedAttributes();
                        if (S_FALSE == hr2) {

                            // Big enough?
                            WsbAffirmHr(GetLogicalSize(&logicalSize));
                            WsbAffirmHr(m_pResource->GetManageableItemLogicalSize(&managableSize));
                            if (logicalSize >= managableSize) {

                                // Old enough?
                                WsbAffirmHr(GetAccessTime(&time));
                                WsbAffirmHr(m_pResource->GetManageableItemAccessTime(&isRelative, &managableTime));
                                if (WsbCompareFileTimes(time, managableTime, isRelative, FALSE) >= 0) {

                                    // Small enough? (This is according to media size limit !)
                                    CComPtr<IFsaResourcePriv> pResourcePriv;
                                    WsbAffirmHr(m_pResource->QueryInterface(IID_IFsaResourcePriv,
                                                    (void**) &pResourcePriv));
                                    WsbAffirmHr(pResourcePriv->GetMaxFileLogicalSize(&maxFileSize));
                                    if ((logicalSize <= maxFileSize) || (0 == maxFileSize)) {

                                        // It can be managed!!
                                        hr = S_OK;
                                    } else {
                                        WsbLogEvent(FSA_MESSAGE_FILESKIPPED_ISTOOLARGE, 0, NULL, (OLECHAR*) jobName, WsbAbbreviatePath(fileName, 120), WsbHrAsString(hr), NULL);
                                        WsbTrace(OLESTR("CFsaScanItem::IsManageable: file not manageable: Logical size = %I64d; Max file size = %I64d\n"), 
                                                    logicalSize, maxFileSize);
                                    }
                                }  else  {
                                    WsbLogEvent(FSA_MESSAGE_FILESKIPPED_ISACCESSED, 0, NULL,  (OLECHAR*) jobName, WsbAbbreviatePath(fileName, 120), WsbHrAsString(hr), NULL);
                                }
                            } else  {
                                WsbLogEvent(FSA_MESSAGE_FILESKIPPED_ISTOOSMALL, 0, NULL, (OLECHAR*) jobName, WsbAbbreviatePath(fileName, 120), WsbHrAsString(hr), NULL);
                            }
                        } else  {
                            WsbLogEvent(FSA_MESSAGE_FILESKIPPED_HASEA, 0, NULL, (OLECHAR*) jobName, WsbAbbreviatePath(fileName, 120), WsbHrAsString(hr), NULL);
                        }
                    } else  {
                        WsbLogEvent(FSA_MESSAGE_FILESKIPPED_ISSPARSE, 0, NULL, (OLECHAR*) jobName, WsbAbbreviatePath(fileName, 120), WsbHrAsString(hr), NULL);
                    }
                } else  {
                       WsbLogEvent(FSA_MESSAGE_FILESKIPPED_ISENCRYPTED, 0, NULL, (OLECHAR*) jobName, WsbAbbreviatePath(fileName, 120), WsbHrAsString(hr), NULL);
                }
            } else  {
                WsbLogEvent(FSA_MESSAGE_FILESKIPPED_ISALINK, 0, NULL, (OLECHAR*) jobName, WsbAbbreviatePath(fileName, 120), WsbHrAsString(hr), NULL);
            }
        } else  {
            WsbLogEvent(FSA_MESSAGE_FILESKIPPED_ISMANAGED, 0, NULL, (OLECHAR*) jobName, WsbAbbreviatePath(fileName, 120), WsbHrAsString(hr), NULL);
        }


    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaScanItem::IsManageable"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT
CFsaScanItem::IsMigrateOK(
    IN IFsaPostIt *pPostIt
    )

/*++

Implements:

  IFsaScanItem::IsMigrateOK().

--*/
{
    HRESULT            hr = S_OK;
    WsbTraceIn(OLESTR("CFsaScanItem::IsMigrateOK"), OLESTR(""));

    try  {
        //
        // Make sure the file isn't already managed.  This could happen if two jobs were scanning
        // the same volume.
        //
        LONGLONG                    offset;
        LONGLONG                    size;

        WsbAffirmHr(pPostIt->GetRequestOffset(&offset));
        WsbAffirmHr(pPostIt->GetRequestSize(&size));
        if (IsManaged(offset, size) == S_OK)  {
            //
            // The file is already managed so skip it
            //
            WsbTrace(OLESTR("A manage request for an already managed file - skip it!\n"));
            WsbThrow(FSA_E_FILE_ALREADY_MANAGED);
        }

        //
        // Get the version ID from the FSA Post it.  This is the
        // version of the file at the time of the migrate request
        //
        LONGLONG            workVersionId;
        WsbAffirmHr(pPostIt->GetFileVersionId(&workVersionId));

        //
        // Get the version of the file at the time of this scan
        //
        LONGLONG            scanVersionId;
        WsbAffirmHr(GetVersionId(&scanVersionId));

        //
        // See if the versions match
        //
        WsbTrace(OLESTR("CFsaScanItem::IsMigrateOK: workVersionId:<%I64u> scanVersionId:<%I64u>\n"),
            workVersionId, scanVersionId);

        if (workVersionId != scanVersionId)  {
            WsbTrace(OLESTR("CFsaScanItem::IsMigrateOK: File version has changed!\n"));
            WsbThrow(FSA_E_FILE_CHANGED);
        }


    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CFsaScanItem::IsMigrateOK"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT
CFsaScanItem::IsMbit(
    void
    )

/*++

Implements:

  IFsaScanItem::IsMbit().

--*/
{
    HRESULT            hr = S_FALSE;

    if ((m_findData.dwFileAttributes & FILE_ATTRIBUTE_ARCHIVE) != 0) {
        hr = S_OK;
    }

    return(hr);
}


HRESULT
CFsaScanItem::IsOffline(
    void
    )
/*++

Implements:

    IFsaScanItem::IsOffline().

--*/
{
    HRESULT             hr = S_FALSE;

    if ((m_findData.dwFileAttributes & FILE_ATTRIBUTE_OFFLINE) != 0) {
        hr = S_OK;
    }

    return(hr);
}


HRESULT
CFsaScanItem::IsOwnerMemberOf(
    OLECHAR* /*group*/
    )

/*++

Implements:

  IFsaScanItem::IsOwnerMemberOf().

--*/
{
    HRESULT            hr = S_FALSE;

    hr = E_NOTIMPL;

    return(hr);
}


HRESULT
CFsaScanItem::IsReadOnly(
    void
    )

/*++

Implements:

  IFsaScanItem::IsReadOnly().

--*/
{
    HRESULT            hr = S_FALSE;

    if ((m_findData.dwFileAttributes & FILE_ATTRIBUTE_READONLY) != 0) {
        hr = S_OK;
    }

    return(hr);
}


HRESULT
CFsaScanItem::IsRecallOK(
    IN IFsaPostIt *pPostIt
    )

/*++

Implements:

  IFsaScanItem::IsRecallOK().

--*/
{
    HRESULT            hr = S_OK;
    WsbTraceIn(OLESTR("CFsaScanItem::IsRecallOK"), OLESTR(""));

    try  {
        LONGLONG offset;
        LONGLONG size;
        //
        // Make sure the file is still truncated
        //
        WsbAffirmHr(pPostIt->GetRequestOffset(&offset));
        WsbAffirmHr(pPostIt->GetRequestSize(&size));
        hr = IsTruncated(offset, size);
        if (S_OK != hr)  {
            //
            // The file is not truncated, so skip it
            //
            WsbTrace(OLESTR("CFsaScanItem::IsRecallOK - file isn't truncated.\n"));
            WsbThrow(FSA_E_FILE_NOT_TRUNCATED);
        }

        // Get the version ID from the FSA Post it.  This is the
        // version of the file at the time of the migrate request
        //
        LONGLONG            workVersionId;
        WsbAffirmHr(pPostIt->GetFileVersionId(&workVersionId));

        //
        // Get the version of the file
        //
        LONGLONG            scanVersionId;
        WsbAffirmHr(GetVersionId(&scanVersionId));

        //
        // See if the versions match
        //
        WsbTrace(OLESTR("CFsaScanItem::IsRecallOK: workVersionId:<%I64u> scanVersionId:<%I64u>\n"),
            workVersionId, scanVersionId);

        if (workVersionId != scanVersionId)  {
            WsbTrace(OLESTR("CFsaScanItem::IsRecallOK: File version has changed!\n"));

            //
            // If the use has changed alternate data streams
            // the file version ID may have changed but it is
            // OK to recall the file.  So if the version ID's
            // don't match, then check to see if the truncated
            // part of the file is OK.  If so, allow the recall
            // to happen.
            //

            //
            // Check to see if the whole file is still sparse
            //
            if (IsTotallySparse() == S_OK)  {
                //
                // The file is OK so far to recall but we need
                // to make the last modify dates match
                //
                FSA_PLACEHOLDER     placeholder;
                WsbAffirmHr(pPostIt->GetPlaceholder(&placeholder));;
                placeholder.fileVersionId = scanVersionId;
                WsbAffirmHr(pPostIt->SetPlaceholder(&placeholder));
            } else  {
                //
                // The file has been changed, recalling data will
                // overwrite something that has been added since the
                // truncation occurred.  So don't do anything.
                //
                WsbTrace(OLESTR("File is no longer sparse.!\n"));
                WsbThrow(FSA_E_FILE_CHANGED);
            }


        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaScanItem::IsRecallOK"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT
CFsaScanItem::IsSparse(
    void
    )

/*++

Implements:

  IFsaScanItem::IsSparse().

--*/
{
    HRESULT         hr = S_FALSE;
    LONGLONG        size;

    WsbTraceIn(OLESTR("CFsaScanItem::IsSparse"), OLESTR(""));
       
    if ((m_findData.dwFileAttributes & FILE_ATTRIBUTE_SPARSE_FILE) != 0) {
        hr = GetLogicalSize( &size ) ;
        if ( S_OK == hr ) {
            hr = CheckIfSparse(0, size );
            if ( (FSA_E_FILE_IS_TOTALLY_SPARSE == hr) ||
                 (FSA_E_FILE_IS_PARTIALLY_SPARSE == hr) ) {
                hr = S_OK;
            } else {
                hr = S_FALSE;
            }
        }
    }
    WsbTraceOut(OLESTR("CFsaScanItem::IsSparse"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT
CFsaScanItem::IsTotallySparse(
    void
    )

/*++

Implements:

  IFsaScanItem::IsTotallySparse().

--*/
{
    HRESULT         hr = S_FALSE;
    LONGLONG        size;

    WsbTraceIn(OLESTR("CFsaScanItem::IsTotallySparse"), OLESTR(""));
    if ((m_findData.dwFileAttributes & FILE_ATTRIBUTE_SPARSE_FILE) != 0) {
        hr = GetLogicalSize( &size ) ;
        if ( S_OK == hr ) {
            hr = CheckIfSparse(0, size );
            if (FSA_E_FILE_IS_TOTALLY_SPARSE == hr)  {
                    hr = S_OK;
            } else  {
                hr = S_FALSE;
            }
        }
    }

    WsbTraceOut(OLESTR("CFsaScanItem::IsTotallySparse"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT
CFsaScanItem::Manage(
    IN LONGLONG offset,
    IN LONGLONG size,
    IN GUID storagePoolId,
    IN BOOL truncate
    )

/*++

Implements:

  IFsaScanItem::Manage().

--*/
{
    HRESULT            hr = S_OK;

    WsbTraceIn(OLESTR("CFsaScanItem::Manage"), OLESTR(""));

    try {

        WsbAssert(GUID_NULL != storagePoolId, E_INVALIDARG);
        WsbAffirmHr(m_pResource->Manage((IFsaScanItem*) this, offset, size, storagePoolId, truncate));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaScanItem::Manage"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaScanItem::Move(
    OLECHAR* dest,
    BOOL /*retainHierarcy*/,
    BOOL /*expandPlaceholders*/,
    BOOL overwriteExisting
    )

/*++

Implements:

  IFsaScanItem::Move().

--*/
{
    HRESULT          hr = S_OK;
    DWORD            mode = MOVEFILE_COPY_ALLOWED;

    try {

        // NOTE : This default behavior causes placeholders
        // to be expanded when moving to another volume and probably doesn't
        // retain the heirarchy.
        WsbAssert(0 != dest, E_POINTER);

        if (overwriteExisting) {
            mode |= MOVEFILE_REPLACE_EXISTING;
        }

        WsbAssert(MoveFileEx(m_findData.cFileName, dest, mode), E_FAIL);

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaScanItem::Recall(
    IN LONGLONG offset,
    IN LONGLONG size,
    IN BOOL deletePlaceholder
    )

/*++

Implements:

  IFsaScanItem::Recall().

--*/
{
    HRESULT            hr = S_OK;

    WsbTraceIn(OLESTR("CFsaScanItem::Recall"), OLESTR(""));

    try {

        WsbAffirmHr(m_pResource->Recall((IFsaScanItem*) this, offset, size, deletePlaceholder));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaScanItem::Recall"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaScanItem::Recycle(
    void
    )

/*++

Implements:

  IFsaScanItem::Recycle().

--*/
{
    HRESULT            hr = S_OK;

    try {

        // Probably need to look at SHFileOperation().

        hr = E_NOTIMPL;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaScanItem::IsSystem(
    void
    )

/*++

Implements:

  IFsaScanItem::IsSystem().

--*/
{
    HRESULT            hr = S_FALSE;

    if ((m_findData.dwFileAttributes & FILE_ATTRIBUTE_SYSTEM) != 0) {
        hr = S_OK;
    }

    return(hr);
}


HRESULT
CFsaScanItem::Test(
    USHORT* passed,
    USHORT* failed
    )

/*++

Implements:

  IWsbTestable::Test().

--*/
{
    HRESULT        hr = S_OK;

    try {

        WsbAssert(0 != passed, E_POINTER);
        WsbAssert(0 != failed, E_POINTER);

        *passed = 0;
        *failed = 0;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaScanItem::Unmanage(
    IN LONGLONG offset,
    IN LONGLONG size
    )

/*++

Implements:

  IFsaScanItem::Unmanage().

--*/
{
    HRESULT            hr = S_OK;

    WsbTraceIn(OLESTR("CFsaScanItem::Unmanage"), OLESTR("<%ls>"),
            WsbAbbreviatePath(m_path, 120));

    try {

        // We only need to worry about files that have placeholder information.
        if (IsManaged(offset, size) == S_OK) {

            // If the file is truncated, then we need to recall the data
            // before deleting the placeholder information.
            // NOTE: We set a flag on the Recall so the placeholder will
            // be deleted after the file is recalled.
            if (IsTruncated(offset, size) == S_OK) {
                WsbAffirmHr(Recall(offset, size, TRUE));
            } else {

                //  For disaster recovery, it would be better to delete the placeholder
                //  and THEN remove this file from the premigration list.  Unfortunately,
                //  after deleting the placeholder, the RemovePremigrated call fails
                //  because it needs to get some information from the placeholder (which
                //  is gone).  So we do it in this order.
                hr = m_pResource->RemovePremigrated((IFsaScanItem*) this, offset, size);
                if (WSB_E_NOTFOUND == hr) {
                    //  It's no tragedy if this file wasn't in the list since we were
                    //  going to delete it anyway (although it shouldn't happen) so
                    //  let's continue anyway
                    hr = S_OK;
                }
                WsbAffirmHr(hr);
                WsbAffirmHr(DeletePlaceholder(offset, size));
            }
        }

    } WsbCatch(hr);
    WsbTraceOut(OLESTR("CFsaScanItem::Unmanage"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaScanItem::Validate(
    IN LONGLONG offset,
    IN LONGLONG size
    )

/*++

Implements:

  IFsaScanItem::Validate().

--*/
{
    HRESULT         hr = S_OK;
    BOOL            fileIsTruncated = FALSE;
    LONGLONG        usn = 0;

    WsbTraceIn(OLESTR("CFsaScanItem::Validate"), OLESTR("offset = <%I64u>, size = <%I64u>"),
            offset, size);
    try {
        //
        // Do some local validation before calling the engine.
        //

        // We only need to worry about files that have placeholder information.
        if (IsManaged(offset, size) == S_OK) {
            //
            // If the file is marked as truncated, make sure it is still truncated.
            //
            if (IsTruncated(offset, size) == S_OK) {
                //
                // Check to see if the file is totally sparse to see if it is truncated.
                //
                if (IsTotallySparse() != S_OK)  {
                    //
                    // The file is marked as truncated but is not truncated
                    // Make it truncated.
                    //
                    WsbAffirmHr(Truncate(offset,size));
                    WsbLogEvent(FSA_MESSAGE_VALIDATE_TRUNCATED_FILE, 0, NULL,  WsbAbbreviatePath(m_path, 120), WsbHrAsString(hr), NULL);
                }
            fileIsTruncated = TRUE;
            }
        }

        //
        // The last modify date may be updated on a file if the named data streams
        // have been modified.  So check to see if the dates match.  If they don't,
        // if the file is trunctated, see if it is still truncated, if so, update the
        // modify date in the placeholder to the file's modify date.  If the file is
        // premigrated and the modify dates don't match, delete the placeholder.

        // Get the version ID from the file
        LONGLONG            scanVersionId;
        WsbAffirmHr(GetVersionId(&scanVersionId));

        // Get the version ID from the placeholder
        FSA_PLACEHOLDER     scanPlaceholder;
        WsbAffirmHr(GetPlaceholder(offset, size, &scanPlaceholder));

        if (TRUE == fileIsTruncated)  {

            // Check to see if the dates match
            if (scanPlaceholder.fileVersionId != scanVersionId)  {
                WsbTrace(OLESTR("CFsaScanItem::Validate - placeholer version ID = <%I64u>, file version Id = <%I64u>"),
                        scanPlaceholder.fileVersionId, scanVersionId);
                //
                // Update the placeholder information on the reparse point
                //
                LONGLONG afterPhUsn;
                scanPlaceholder.fileVersionId = scanVersionId;
                WsbAffirmHr(CreatePlaceholder(offset, size, scanPlaceholder, FALSE, 0, &afterPhUsn));
                WsbLogEvent(FSA_MESSAGE_VALIDATE_RESET_PH_MODIFY_TIME, 0, NULL,  WsbAbbreviatePath(m_path, 120), WsbHrAsString(hr), NULL);
            }
        } else {
            // The file is pre-migrated.  Verify that it has not changed since we managed it and if it has then unmanage it.
            if (Verify(offset, size) != S_OK) {
                WsbAffirmHr(Unmanage(offset, size));
                WsbLogEvent(FSA_MESSAGE_VALIDATE_UNMANAGED_FILE, 0, NULL,  WsbAbbreviatePath(m_path, 120), WsbHrAsString(hr), NULL);
            }
        }

        // Now that all of this stuff is OK, call the engine
        if (IsManaged(offset, size) == S_OK) {
            WsbAffirmHr(m_pResource->Validate((IFsaScanItem*) this, offset, size, usn));
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaScanItem::Validate"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT
CFsaScanItem::FindFirstInDbIndex(
    IN IFsaResource* pResource,
    IN IHsmSession* pSession
    )

/*++

Implements:

  IFsaScanItemPriv::FindFirstInDbIndex().

--*/
{
    HRESULT                  hr = S_OK;

    WsbTraceIn(OLESTR("CFsaScanItem::FindFirstInDbIndex"), OLESTR(""));

    try {
        CComPtr<IFsaResourcePriv>   pResourcePriv;

        WsbAssert(0 != pResource, E_POINTER);

        // Store off some of the scan information.
        m_pResource = pResource;
        m_pSession = pSession;

        // If Db is already present (could happen if somebody calls First() twice in a row),
        // we close the Db and reopen since we cannot be sure that the resource is the same!
        if (m_pUnmanageDb != NULL) {
            // Db must be open
            (void)m_pUnmanageDb->Close(m_pDbSession);
            m_pDbSession = 0;
            m_pUnmanageRec = 0;
            m_pUnmanageDb = 0;
        }

        // Get and open the Unmanage db 
        // (Note: if this scanning is ever extended to use another DB, 
        // this method should get additional parameter for which DB to scan)
        WsbAffirmHr(m_pResource->QueryInterface(IID_IFsaResourcePriv,
                (void**) &pResourcePriv));
        hr = pResourcePriv->GetUnmanageDb(IID_IFsaUnmanageDb,
                (void**) &m_pUnmanageDb);
        if (WSB_E_RESOURCE_UNAVAILABLE == hr) {
            // Db was not created ==> no files to scan
            hr = WSB_E_NOTFOUND;
        }
        WsbAffirmHr(hr);

        hr = m_pUnmanageDb->Open(&m_pDbSession);
        if (S_OK != hr) {
            m_pUnmanageDb = NULL;
            WsbAffirmHr(hr);
        }

        // Get a record to traverse with and set for sequential traversing
        WsbAffirmHr(m_pUnmanageDb->GetEntity(m_pDbSession, UNMANAGE_REC_TYPE, IID_IFsaUnmanageRec,
                (void**)&m_pUnmanageRec));
        WsbAffirmHr(m_pUnmanageRec->SetSequentialScan());

        //  Get file information
        WsbAffirmHr(GetFromDbIndex(TRUE));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaScanItem::FindFirstInDbIndex"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CFsaScanItem::FindNextInDbIndex(
    void
    )

/*++

Implements:

  IFsaScanItemPriv::FindNextInDbIndex().

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CFsaScanItem::FindNextInDbIndex"), OLESTR(""));

    try {
        WsbAssert(m_pUnmanageDb != NULL, E_FAIL);

        //  Get file information
        WsbAffirmHr(GetFromDbIndex(FALSE));

    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CFsaScanItem::FindNextInDbIndex"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CFsaScanItem::GetFromDbIndex(
    BOOL first
    )

/*

Implements:

  CFsaScanItem::GetFromDbIndex().

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CFsaScanItem::GetFromDbIndex"), OLESTR(""));

    try {
        IFsaScanItem*   pScanItem;
        HRESULT         hrFindFileId = S_OK;
        LONGLONG        fileId;
        BOOL            bCont;

        WsbAssert(m_pUnmanageDb != NULL, E_FAIL);
        WsbAssert(m_pUnmanageRec != NULL, E_FAIL);

        do {
            bCont = FALSE;

            // Get first/next record
            if (first) {
                hr = m_pUnmanageRec->First();
            } else {
                hr = m_pUnmanageRec->Next();
            }
            WsbAffirm(S_OK == hr, WSB_E_NOTFOUND);

            // Get file id
            WsbAffirmHr(m_pUnmanageRec->GetFileId(&fileId));
   
            //  Reset some items in case this isn't the first call to FindFileId 
            //  (FindFileId actually "attach" the object to a different file)
            if (INVALID_HANDLE_VALUE != m_handle) {
                FindClose(m_handle);
                m_handle = INVALID_HANDLE_VALUE;
            }
            if (TRUE == m_changedAttributes) {
                RestoreAttributes();
            }

            //  Find the file from the ID 
            pScanItem = this;
            hrFindFileId = m_pResource->FindFileId(fileId, m_pSession, &pScanItem);

            //  If the FindFileId failed, we just skip that item and get the 
            //  next one.  This is to keep the scan from just stopping on this
            //  item.  FindFileId could fail because the file has been deleted
            //  or open exclusively by somebody else
            if (!SUCCEEDED(hrFindFileId)) {
                WsbTrace(OLESTR("CFsaScanItem::GetFromDbIndex: file id %I64d skipped since FindFileId failed with hr = <%ls>\n"),
                    fileId, WsbHrAsString(hrFindFileId));
                first = FALSE;
                bCont = TRUE;
            } 
        } while (bCont);

        WsbAffirmHr(pScanItem->Release());  // Get rid of extra ref. count (we get extra ref count only when FindFileId succeeds)

    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CFsaScanItem::GetFromDbIndex"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\fsa\fsaitem.h ===
#ifndef _FSAITEM_
#define _FSAITEM_

/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    fsaitem.cpp

Abstract:

    This class contains represents a scan item (i.e. file or directory) for NTFS 5.0.

Author:

    Chuck Bardeen   [cbardeen]   1-Dec-1996

Revision History:

--*/

#include "resource.h"       // main symbols

#include "wsb.h"
#include "job.h"
#include "mover.h"
#include "fsa.h"
#include "fsaprv.h"

// Registry parameters
#define FSA_MAX_SIZE_DISK_FULL                  OLESTR("MaxSizeDiskFullKB")    

// Usn journal defaults
#define FSA_MAX_SIZE_DISK_FULL_DEFAULT          (10 * 1024)         // in KB (i.e. 10 MB)

/*++

Class Name:
    
    CFsaScanItem

Class Description:


--*/


class CFsaScanItem : 
    public CComObjectRoot,
    public IFsaScanItem,
    public IFsaScanItemPriv,
    public CComCoClass<CFsaScanItem,&CLSID_CFsaScanItemNTFS>
{
public:
    CFsaScanItem() {}
BEGIN_COM_MAP(CFsaScanItem)
    COM_INTERFACE_ENTRY(IFsaScanItem)
    COM_INTERFACE_ENTRY(IFsaScanItemPriv)
//  COM_INTERFACE_ENTRY(IWsbCollectable)
//  COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_FsaScanItem)

// CComObjectRoot
public:
    HRESULT FinalConstruct(void);
    void FinalRelease(void);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IUnknown* pUnknown, SHORT* pResult);

// IWsbTestable
    STDMETHOD(Test)(USHORT *passed, USHORT* failed);

// IFsaScanItemPriv
public:
    STDMETHOD(FindFirst)(IFsaResource* pResource, OLECHAR* path, IHsmSession* pSession);
    STDMETHOD(FindFirstInRPIndex)(IFsaResource* pResource, IHsmSession* pSession);
    STDMETHOD(FindFirstInDbIndex)(IFsaResource* pResource, IHsmSession* pSession);
    STDMETHOD(FindNext)(void);
    STDMETHOD(FindNextInRPIndex)(void);
    STDMETHOD(FindNextInDbIndex)(void);
    STDMETHOD(TruncateInternal)(LONGLONG offset, LONGLONG size);  
    STDMETHOD(VerifyInternal)(LONGLONG offset, LONGLONG size, LONGLONG usn1, LONGLONG usn2);

// IFsaScanItem
public:
    STDMETHOD(CheckIfSparse)(LONGLONG offset, LONGLONG size);  
    STDMETHOD(CompareToIScanItem)(IFsaScanItem* pScanItem, SHORT* pResult);
    STDMETHOD(CompareToPathAndName)(OLECHAR* path, OLECHAR* name, SHORT* pResult);
    STDMETHOD(Copy)(OLECHAR* dest, BOOL retainHierarcy, BOOL expandPlaceholders, BOOL overwriteExisting);  
    STDMETHOD(CreateLocalStream)(IStream **ppStream);
    STDMETHOD(CreatePlaceholder)(LONGLONG offset, LONGLONG size, FSA_PLACEHOLDER pPlaceholder, BOOL checkUsn, LONGLONG usn, LONGLONG *pUsn);
    STDMETHOD(Delete)(void);  
    STDMETHOD(DeletePlaceholder)(LONGLONG offset, LONGLONG size);  
    STDMETHOD(FindFirstPlaceholder)(LONGLONG* pOffset, LONGLONG* pSize, FSA_PLACEHOLDER* pPlaceholder);  
    STDMETHOD(FindNextPlaceholder)(LONGLONG* pOffset, LONGLONG* pSize, FSA_PLACEHOLDER* pPlaceholder);  
    STDMETHOD(GetAccessTime)(FILETIME* pTime);  
    STDMETHOD(GetFileId)(LONGLONG* pFileId);
    STDMETHOD(GetFileUsn)(LONGLONG* pFileUsn);
    STDMETHOD(GetFullPathAndName)(OLECHAR* prependix, OLECHAR *appendix, OLECHAR** pPath, ULONG bufferSize);
    STDMETHOD(GetGroup)(OLECHAR** pOwner, ULONG bufferSize);  
    STDMETHOD(GetLogicalSize)(LONGLONG* pSize);  
    STDMETHOD(GetModifyTime)(FILETIME* pTime);  
    STDMETHOD(GetOwner)(OLECHAR** pOwner, ULONG bufferSize);  
    STDMETHOD(GetName)(OLECHAR** pName, ULONG bufferSize);
    STDMETHOD(GetPath)(OLECHAR** pPath, ULONG bufferSize);
    STDMETHOD(GetPathForFind)(OLECHAR* searchName, OLECHAR** pPath, ULONG bufferSize);
    STDMETHOD(GetPathAndName)(OLECHAR* appendix, OLECHAR** pPath, ULONG bufferSize);
    STDMETHOD(GetPhysicalSize)(LONGLONG* pSize);
    STDMETHOD(GetPlaceholder)(LONGLONG offset, LONGLONG size, FSA_PLACEHOLDER* pPlaceholder);
    STDMETHOD(GetSession)(IHsmSession** ppSession);
    STDMETHOD(GetUncPathAndName)(OLECHAR* prependix, OLECHAR *appendix, OLECHAR** pPath, ULONG bufferSize);
    STDMETHOD(GetVersionId)(LONGLONG* pId);
    STDMETHOD(HasExtendedAttributes)(void); 
    STDMETHOD(IsALink)(void);  
    STDMETHOD(IsAParent)(void); 
    STDMETHOD(IsARelativeParent)(void); 
    STDMETHOD(IsCompressed)(void); 
    STDMETHOD(IsDeleteOK)(IFsaPostIt *pPostIt);
    STDMETHOD(IsEncrypted)(void); 
    STDMETHOD(IsHidden)(void); 
    STDMETHOD(IsGroupMemberOf)(OLECHAR* group);
    STDMETHOD(IsManageable)(LONGLONG offset, LONGLONG size);  
    STDMETHOD(IsManaged)(LONGLONG offset, LONGLONG size);  
    STDMETHOD(IsMbit)(void);  
    STDMETHOD(IsOffline)(void);  
    STDMETHOD(IsMigrateOK)(IFsaPostIt *pPostIt);
    STDMETHOD(IsOwnerMemberOf)(OLECHAR* group);
    STDMETHOD(IsPremigrated)(LONGLONG offset, LONGLONG size);  
    STDMETHOD(IsReadOnly)(void); 
    STDMETHOD(IsRecallOK)(IFsaPostIt *pPostIt);
    STDMETHOD(IsSparse)(void); 
    STDMETHOD(IsSystem)(void); 
    STDMETHOD(IsTotallySparse)(void); 
    STDMETHOD(IsTruncated)(LONGLONG offset, LONGLONG size);  
    STDMETHOD(Manage)(LONGLONG offset, LONGLONG size, GUID storagePoolId, BOOL truncate);  
    STDMETHOD(Move)(OLECHAR* dest, BOOL retainHierarcy, BOOL expandPlaceholders, BOOL overwriteExisting);  
    STDMETHOD(Recall)(LONGLONG offset, LONGLONG size, BOOL deletePlaceholder);  
    STDMETHOD(Recycle)(void);  
    STDMETHOD(Truncate)(LONGLONG offset, LONGLONG size);  
    STDMETHOD(Unmanage)(LONGLONG offset, LONGLONG size);  
    STDMETHOD(Validate)(LONGLONG offset, LONGLONG size);  
    STDMETHOD(PrepareForManage)(LONGLONG offset, LONGLONG size);  
    STDMETHOD(Verify)(LONGLONG offset, LONGLONG size);
    STDMETHOD(TruncateValidated)(LONGLONG offset, LONGLONG size);

//  Private functions
private:
    STDMETHOD(CheckUsnJournalForChanges)(LONGLONG StartUsn, LONGLONG StopUsn, BOOL *pChanged);
    STDMETHOD(GetPremigratedUsn)(LONGLONG* pFileUsn);
    STDMETHOD(GetFromRPIndex)(BOOL first);
    STDMETHOD(GetFromDbIndex)(BOOL first);
    STDMETHOD(CalculateCurrentCRCAndUSN)(LONGLONG offset,LONGLONG size, ULONG *pCurrentCRC, LONGLONG *pUsn);
    STDMETHOD(CalculateCurrentCRCInternal)(HANDLE handle, LONGLONG offset,LONGLONG size, ULONG *pCurrentCRC);
    STDMETHOD(MakeReadWrite)(void);  
    STDMETHOD(RestoreAttributes)(void);  
    STDMETHOD(CheckIfDiskFull)(void);  

protected:
    CComPtr<IFsaResource>       m_pResource;
    CWsbStringPtr               m_path;
    CComPtr<IHsmSession>        m_pSession;
    HANDLE                      m_handle;
    WIN32_FIND_DATA             m_findData;
    BOOL                        m_gotPhysicalSize;
    ULARGE_INTEGER              m_physicalSize;
    BOOL                        m_gotPlaceholder;
    FSA_PLACEHOLDER             m_placeholder;
    BOOL                        m_changedAttributes;
    ULONG                       m_originalAttributes;
    CComPtr<IDataMover>         m_pDataMover;
    CComPtr<IStream>            m_pStream;

    //  Only used for Reparse Point Index scan:
    HANDLE                      m_handleRPI;

    //  Used by :Verify
    HANDLE                      m_handleVerify;

    // Only used for Database scan
    CComPtr<IFsaUnmanageDb>     m_pUnmanageDb;
    CComPtr<IFsaUnmanageRec>    m_pUnmanageRec;
    CComPtr<IWsbDbSession>      m_pDbSession;

};

#endif  // _FSAITEM_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\fsa\fsaftclt.h ===
#ifndef _FSAFTCLT_
#define _FSAFTCLT_

/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    fsafltr.cpp

Abstract:

    This class represents a user who the filter has detected accessing a file with placeholder information.

Author:

    Chuck Bardeen   [cbardeen]   12-Feb-1997

Revision History:

--*/

#include "resource.h"       // main symbols

#include "fsa.h"


/*++

Class Name:
    
    CFsaFilterClient

Class Description:

    This class represents a user who the filter has detected accessing a file with placeholder information.

--*/

class CFsaFilterClient : 
    public CWsbCollectable,
    public IFsaFilterClient,
    public CComCoClass<CFsaFilterClient,&CLSID_CFsaFilterClientNTFS>
{
public:
    CFsaFilterClient() {}
BEGIN_COM_MAP(CFsaFilterClient)
    COM_INTERFACE_ENTRY(IFsaFilterClient)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_FsaFilterClient)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);
    void (FinalRelease)(void);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IUnknown* pUnknown, SHORT* pResult);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbTestable
    STDMETHOD(Test)(USHORT *passed, USHORT* failed);

// IFsaFilterClient
public:
    STDMETHOD(CompareBy)(FSA_FILTERCLIENT_COMPARE by);
    STDMETHOD(CompareToAuthenticationId)(LONG luidHigh, ULONG luidLow, SHORT* pResult);
    STDMETHOD(CompareToIClient)(IFsaFilterClient* pClient, SHORT* pResult);
    STDMETHOD(CompareToMachineName)(OLECHAR* name, SHORT* pResult);
    STDMETHOD(GetAuthenticationId)(LONG* pLuidHigh, ULONG* pLuidLow);
    STDMETHOD(GetDomainName)(OLECHAR** pName, ULONG bufferSize);
    STDMETHOD(GetLastRecallTime)(FILETIME* pTime);
    STDMETHOD(GetMachineName)(OLECHAR** pName, ULONG bufferSize);
    STDMETHOD(GetRecallCount)(ULONG* pCount);
    STDMETHOD(GetUserName)(OLECHAR** pName, ULONG bufferSize);
    STDMETHOD(HasRecallDisabled)(void);
    STDMETHOD(HitRecallLimit)(void);
    STDMETHOD(SetAuthenticationId)(LONG luidHigh, ULONG luidLow);
    STDMETHOD(SetDomainName)(OLECHAR* pName);
    STDMETHOD(SetHasRecallDisabled)(BOOL isDisabled);
    STDMETHOD(SetHitRecallLimit)(BOOL hitLimit);
    STDMETHOD(SetLastRecallTime)(FILETIME time);
    STDMETHOD(SetMachineName)(OLECHAR* pName);
    STDMETHOD(SetRecallCount)(ULONG count);
    STDMETHOD(SetUserName)(OLECHAR* pName);
    STDMETHOD(StartIdentify)();
    STDMETHOD(SetTokenSource)(CHAR *source);
    STDMETHOD(SendRecallInfo)(IFsaFilterRecall *pRecall, BOOL starting, HRESULT rHr);
    STDMETHOD(IdentifyThread)(void);
    STDMETHOD(SetIsAdmin)(BOOLEAN isAdmin);
    STDMETHOD(GetIsAdmin)(BOOLEAN *isAdmin);
    STDMETHOD(CheckRecallLimit)(DWORD minRecallInterval, DWORD maxRecalls, BOOLEAN exemptAdmin);

protected:
    FSA_FILTERCLIENT_COMPARE    m_compareBy;
    LONG                        m_luidHigh;
    ULONG                       m_luidLow;
    CWsbStringPtr               m_domainName;
    BOOL                        m_hasRecallDisabled;
    BOOL                        m_hitRecallLimit;
    FILETIME                    m_lastRecallTime;
    CWsbStringPtr               m_machineName;
    ULONG                       m_recallCount;
    CWsbStringPtr               m_userName;
    BOOL                        m_identified;
    CWsbStringPtr               m_tokenSource;
    ULONG                       m_msgCounter;
    HANDLE volatile             m_identifyThread;
    BOOLEAN                     m_isAdmin;
    BOOLEAN                     m_loggedLimitError;
};

#endif  // _FSAFTCLT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\fsa\fsaitemr.h ===
#ifndef _FSAITEMR_
#define _FSAITEMR_

/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    FsaItemR.h

Abstract:

    This header file defines special helper function needed for
    the reparse point data.

Author:

    Michael Lotz    [lotz]   3-Mar-1997

Revision History:

--*/


#ifdef __cplusplus
extern "C" {
#endif

// Helper Functions

extern HRESULT CopyRPDataToPlaceholder( IN CONST PRP_DATA pReparseData,
                                        OUT FSA_PLACEHOLDER *pPlaceholder );
    

#ifdef __cplusplus
}
#endif

#endif // _FSAITEMR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\fsa\fsaftrcl.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    fsaftrcl.cpp

Abstract:

    This class represents a filter initiated recall request that is still in-progress.

Author:

    Chuck Bardeen   [cbardeen]   12-Feb-1997

Revision History:

--*/




#include "stdafx.h"
#include "devioctl.h"

#define WSB_TRACE_IS        WSB_TRACE_BIT_FSA

#include "wsb.h"
#include "fsa.h"
#include "job.h"
#include "fsaftrcl.h"
#include "rpdata.h"
#include "rpio.h"

static USHORT iCountFtrcl = 0;  // Count of existing objects


HRESULT
CFsaFilterRecall::Cancel(
    void
    )

/*++

Implements:

  IFsaFilterRecallPriv::Cancel().

--*/
{
    CComPtr<IFsaFilterClient>       pClient;
    CComPtr<IWsbEnum>               pEnum;
    HRESULT                         hr = S_OK, hr2;
    DWORD                           dwStatus;


    WsbTraceIn(OLESTR("CFsaFilterRecall::Cancel"), OLESTR("filter Id = %I64x"),
            m_driversRecallId);
    
    try {

        WsbAffirm(!m_wasCancelled, E_UNEXPECTED);

        try {
                
            //
            // Tell the  filter to fail the open of the file.
            //
            if (m_kernelCompletionSent == FALSE) {
                WsbAffirmHr(m_pFilterPriv->SendCancel((IFsaFilterRecallPriv *) this));
                m_kernelCompletionSent = TRUE;
                m_wasCancelled = TRUE;
            }
    
            if (m_pClient != 0) {
                // Reporting on recall end must be synchronized with the recall start notification, 
                // because such notification might be sent after the recall starts
                switch (WaitForSingleObject(m_notifyEvent, INFINITE)) {
                    case WAIT_OBJECT_0:
                        m_pClient->SendRecallInfo((IFsaFilterRecall *) this, FALSE, HRESULT_FROM_WIN32(ERROR_OPERATION_ABORTED));
                        SetEvent(m_notifyEvent);
                        break;

                    case WAIT_FAILED:
                    default:
                        WsbTrace(OLESTR("CFsaFilterRecall::Cancel: WaitForSingleObject returned error %lu\n"), GetLastError());

                        // Notify anyway
                        m_pClient->SendRecallInfo((IFsaFilterRecall *) this, FALSE, HRESULT_FROM_WIN32(ERROR_OPERATION_ABORTED));
                        break;
                }
            }

            dwStatus = WaitForSingleObject(m_waitingClientEvent, INFINITE);

            // Notify on recall end no matter what the status is
            if (m_pWaitingClients != 0) {
                // 
                // Send recall notifications to all clients waiting for 
                // the recall to finish
                //
                hr2 = m_pWaitingClients->Enum(&pEnum);
                if (S_OK == hr2) {
                    hr2 = pEnum->First(IID_IFsaFilterClient, (void**) &pClient);
                    while (S_OK == hr2) {
                        pClient->SendRecallInfo((IFsaFilterRecall *) this, FALSE, HRESULT_FROM_WIN32(ERROR_OPERATION_ABORTED));         
                        m_pWaitingClients->RemoveAndRelease(pClient);
                        pClient = NULL;
                        pEnum->Reset();
                        hr2 = pEnum->First(IID_IFsaFilterClient, (void**) &pClient);
                    }
                }
            }

            m_waitingClientsNotified = TRUE;

            switch (dwStatus) {
                case WAIT_OBJECT_0:
                    SetEvent(m_waitingClientEvent);
                    break;

                case WAIT_FAILED:
                default:
                    WsbTrace(OLESTR("CFsaFilterRecall::Cancel: WaitForSingleObject returned error %lu\n"), dwStatus);
                    break;
            }            
            
            //
            // Now get the engine to cancel it, if possible..
            //
            if (m_pSession != 0) {
                WsbAffirmHr(m_pSession->Cancel(HSM_JOB_PHASE_ALL));
            }

        } WsbCatch(hr);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaFilterRecall::Cancel"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaFilterRecall::CancelByDriver(
    void
    )

/*++

Implements:

  IFsaFilterRecallPriv::CancelByDriver().

--*/
{
    HRESULT                 hr = S_OK;


    WsbTraceIn(OLESTR("CFsaFilterRecall::CancelByDriver"), OLESTR("filter Id = %I64x"),
            m_driversRecallId);
    
    try {

        WsbAffirm(!m_wasCancelled, E_UNEXPECTED);

        try {
            //
            // No need to tell the filter anymore - reset the flag.
            //
            m_kernelCompletionSent = TRUE;
            //
            // Now get the engine to cancel it, if possible..
            //
            if (m_pSession != 0) {
                WsbAffirmHr(m_pSession->Cancel(HSM_JOB_PHASE_ALL));
            }

        } WsbCatch(hr);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaFilterRecall::CancelByDriver"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaFilterRecall::CompareBy(
    IN FSA_RECALL_COMPARE by
    )

/*++

Implements:

  IWsbCollectable::CompareBy().

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaFilterRecall::CompareBy"), OLESTR("by = %ld"),
            static_cast<LONG>(by));
    
    try {
        m_compareBy = by;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaFilterRecall::CompareBy"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaFilterRecall::CompareTo(
    IN IUnknown* pUnknown,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbCollectable::CompareTo().

--*/
{
    HRESULT                         hr = S_OK;
    CComPtr<IFsaFilterRecall>       pRecall;
    CComPtr<IFsaFilterRecallPriv>   pRecallPriv;
    ULONGLONG                       id;


    // WsbTraceIn(OLESTR("CFsaFilterRecall::CompareTo"), OLESTR(""));
    
    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pUnknown, E_POINTER);

        if (m_compareBy == FSA_RECALL_COMPARE_IRECALL) {
            // We need the IFsaFilterRecall interface to get the value of the object.
            WsbAffirmHr(pUnknown->QueryInterface(IID_IFsaFilterRecall, (void**) &pRecall));
            // Compare the rules.
            hr = CompareToIRecall(pRecall, pResult);
        } else {
            // We need the IFsaFilterRecallPriv interface to get the value of the object.
            WsbAffirmHr(pUnknown->QueryInterface(IID_IFsaFilterRecallPriv, (void**) &pRecallPriv));
            WsbAffirmHr(pRecallPriv->GetDriversRecallId(&id));
            // Compare the driver id
            if (m_compareBy == FSA_RECALL_COMPARE_CONTEXT_ID) {
                hr = CompareToDriversContextId((id&0xFFFFFFFF), pResult);
            } else {
                hr = CompareToDriversRecallId(id, pResult);
           }
        }
    } WsbCatch(hr);

    // WsbTraceOut(OLESTR("CFsaFilterRecall::CompareTo"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CFsaFilterRecall::CompareToDriversRecallId(
    IN ULONGLONG id,
    OUT SHORT* pResult
    )

/*++

Implements:

  IFsaFilterRecall::CompareToDriversRecallId().

--*/
{
    HRESULT     hr = S_OK;
    SHORT       aResult;

    // WsbTraceIn(OLESTR("CFsaFilterRecall::CompareToDriversRecallId"), OLESTR(""));

    try {
        
        if (m_driversRecallId == id)
            aResult = 0;
        else
            aResult = 1;

        if (0 != aResult) {
            hr = S_FALSE;
        }
        
        if (0 != pResult) {
            *pResult = aResult;
        }

    } WsbCatch(hr);

    // WsbTraceOut(OLESTR("CFsaFilterRecall::CompareToDriversRecallId"), OLESTR("hr = <%ls>, result = <%d>"), WsbHrAsString(hr), aResult);

    return(hr);
}


HRESULT
CFsaFilterRecall::CompareToDriversContextId(
    IN ULONGLONG id,
    OUT SHORT* pResult
    )

/*++

Implements:

  IFsaFilterRecall::CompareToDriversContextId().

--*/
{
    HRESULT     hr = S_OK;
    SHORT       aResult;

    // WsbTraceIn(OLESTR("CFsaFilterRecall::CompareToDriversContextId"), OLESTR(""));

    try {
        
        if ((m_driversRecallId & 0xFFFFFFFF) == id)
            aResult = 0;
        else
            aResult = 1;

        if (0 != aResult) {
            hr = S_FALSE;
        }
        
        if (0 != pResult) {
            *pResult = aResult;
        }

    } WsbCatch(hr);

    // WsbTraceOut(OLESTR("CFsaFilterRecall::CompareToDriversContextId"), OLESTR("hr = <%ls>, result = <%d>"), WsbHrAsString(hr), aResult);

    return(hr);
}


HRESULT
CFsaFilterRecall::CompareToIdentifier(
    IN GUID id,
    OUT SHORT* pResult
    )

/*++

Implements:

  IFsaFilterRecall::CompareToIdentifier().

--*/
{
    HRESULT     hr = S_OK;
    SHORT       aResult;

    // WsbTraceIn(OLESTR("CFsaFilterRecall::CompareToIdentifier"), OLESTR(""));

    try {

        aResult = WsbSign( memcmp(&m_id, &id, sizeof(GUID)) );

        if (0 != aResult) {
            hr = S_FALSE;
        }
        
        if (0 != pResult) {
            *pResult = aResult;
        }

    } WsbCatch(hr);

    // WsbTraceOut(OLESTR("CFsaFilterRecall::CompareToIdentifier"), OLESTR("hr = <%ls>, result = <%d>"), WsbHrAsString(hr), aResult);

    return(hr);
}


HRESULT
CFsaFilterRecall::CompareToIRecall(
    IN IFsaFilterRecall* pRecall,
    OUT SHORT* pResult
    )

/*++

Implements:

  IFsaFilterRecall::CompareToIRecall().

--*/
{
    HRESULT         hr = S_OK;
    CWsbStringPtr   name;
    GUID            id;

    // WsbTraceIn(OLESTR("CFsaFilterRecall::CompareToIRecall"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pRecall, E_POINTER);

        WsbAffirmHr(pRecall->GetIdentifier(&id));
        hr = CompareToIdentifier(id, pResult);

    } WsbCatch(hr);

    // WsbTraceOut(OLESTR("CFsaFilterRecall::CompareToIRecall"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CFsaFilterRecall::CreateLocalStream(
    OUT IStream **ppStream
    )  

/*++

Implements:

  IFsaFilterRecall::CreateLocalStream().

--*/
{
    HRESULT         hr = S_OK;
    WCHAR           idString[50];
    CWsbStringPtr   pDrv;
    OLECHAR         volume[64];
    

    WsbTraceIn(OLESTR("CFsaFilterRecall::CreateLocalStream"), OLESTR("filter Id = %I64x"),
            m_driversRecallId);

    try {
        WsbAssert( 0 != ppStream, E_POINTER);

        swprintf(idString, L"%I64u", m_driversRecallId);
        
        WsbAffirmHr( CoCreateInstance( CLSID_CFilterIo, 0, CLSCTX_SERVER, IID_IDataMover, (void **)&m_pDataMover ) );
        WsbAssertHr( m_pDataMover->CreateLocalStream(
                idString, MVR_MODE_WRITE | MVR_FLAG_HSM_SEMANTICS | MVR_FLAG_POSIX_SEMANTICS, &m_pStream ) );
        //
        // Set the device name for  the mover which is used to recall the file.
        // This is the RsFilter's primary device object's name to which the 
        // the RP_PARTIAL_DATA msgs etc. will be sent
        // 
        WsbAffirmHr(m_pResource->GetPath(&pDrv,0));
        swprintf(volume, L"\\\\.\\%s", pDrv);
        //
        // strip trailing backslash if any
        //
        if (volume[wcslen(volume)-1] == L'\\') {
            volume[wcslen(volume)-1] = L'\0';
        }   
        WsbAssertHr( m_pDataMover->SetDeviceName(RS_FILTER_SYM_LINK,
                                                 volume));

        *ppStream = m_pStream;
        m_pStream.p->AddRef();


    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaFilterRecall::CreateLocalStream"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}



HRESULT
CFsaFilterRecall::Delete(
    void
    )

/*++

Implements:

  IFsaFilterRecallPriv::Delete().

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CFsaFilterRecall::Delete"), OLESTR("filter Id = %I64x"),
            m_driversRecallId);
    
    try {
        //
        // Tell the kernel mode filter to fail the open of the file.
        //
        if (m_kernelCompletionSent == FALSE) {
            WsbAffirmHr(m_pFilterPriv->SendCancel((IFsaFilterRecallPriv *) this));
            m_kernelCompletionSent = TRUE;
            m_wasCancelled = TRUE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaFilterRecall::Delete"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaFilterRecall::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaFilterRecall::FinalConstruct"), OLESTR(""));
    
    try {

        WsbAffirmHr(CWsbCollectable::FinalConstruct());

        m_notifyEvent = NULL;
        m_waitingClientEvent = NULL;
        m_driversRecallId = 0;
        memset(&m_placeholder, 0, sizeof(FSA_PLACEHOLDER));
        m_state = HSM_JOB_STATE_IDLE;
        m_wasCancelled = FALSE;
        m_kernelCompletionSent = FALSE;
        m_pDataMover = 0;
        m_pStream = 0;
        m_recallFlags = 0;
        m_compareBy = FSA_RECALL_COMPARE_IRECALL;
        numRefs = 0;
        m_waitingClientsNotified = FALSE;
        m_pFilterPriv = NULL;
        m_threadId = 0;
        WsbAffirmHr(CoCreateGuid(&m_id));

        // Initialize notify synchronization event and waiting clients event
        WsbAffirmHandle((m_notifyEvent = CreateEvent(NULL, FALSE, TRUE, NULL)));
        WsbAffirmHandle((m_waitingClientEvent = CreateEvent(NULL, FALSE, TRUE, NULL)));
        
        // Create the waiting client collection.
        WsbAffirmHr(CoCreateInstance(CLSID_CWsbOrderedCollection, NULL, CLSCTX_SERVER, IID_IWsbCollection, (void**) &m_pWaitingClients));
    
    } WsbCatch(hr);

    iCountFtrcl++;

    WsbTraceOut(OLESTR("CFsaFilterRecall::FinalConstruct"), OLESTR("hr = %ls, Count is <%d>"), WsbHrAsString(hr), iCountFtrcl);

    return(hr);
}


void
CFsaFilterRecall::FinalRelease(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalRelease().

--*/
{

    WsbTraceIn(OLESTR("CFsaFilterRecall::FinalRelease"), OLESTR(""));
    
    CWsbCollectable::FinalRelease();

    // Free notify synchronization event and waiting client event 
    if (m_waitingClientEvent != NULL) {
        CloseHandle(m_waitingClientEvent);
        m_waitingClientEvent = NULL;
    }
    if (m_notifyEvent != NULL) {
        CloseHandle(m_notifyEvent);
        m_notifyEvent = NULL;
    }

    iCountFtrcl--;

    WsbTraceOut(OLESTR("CFsaFilterRecall::FinalRelease"), OLESTR("Count is <%d>"), iCountFtrcl);

}


#ifdef FSA_RECALL_LEAK_TEST



ULONG
CFsaFilterRecall::InternalAddRef(
    void
    )

/*++

Implements:

  CComObjectRoot::AddRef().

--*/
{

    numRefs++;  
    WsbTrace(OLESTR("CFsaFilterRecall::AddRef (%p) - Count = %u\n"), this, numRefs);
    return(CComObjectRoot::InternalAddRef());
}


ULONG
CFsaFilterRecall::InternalRelease(
    void
    )

/*++

Implements:

  CComObjectRoot::InternalRelease().

--*/
{
    
    WsbTrace(OLESTR("CFsaFilterRecall::Release (%p) - Count = %u\n"), this, numRefs);
    numRefs--;  
    return(CComObjectRoot::InternalRelease());
}

#endif



HRESULT
CFsaFilterRecall::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaFilterRecall::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CFsaFilterRecallNTFS;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaFilterRecall::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CFsaFilterRecall::GetClient(
    OUT IFsaFilterClient** ppClient
    )

/*++

Implements:

  IFsaFilterRecallPriv::GetClient().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != ppClient, E_POINTER);

        *ppClient = m_pClient;
        if (m_pClient != 0) {
            m_pClient.p->AddRef();
        }

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaFilterRecall::GetRecallFlags(
    OUT ULONG *pFlags
    )  

/*++

Implements:

  IFsaFilterRecall::GetRecallFlags()

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CFsaFilterRecall::GetRecallFlags"), OLESTR(""));
    try {
        WsbAssert( 0 != pFlags, E_POINTER);
        *pFlags = m_recallFlags;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaFilterRecall::GetRecallFlags"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT
CFsaFilterRecall::GetStream(
    OUT IStream **ppStream
    )  

/*++

Implements:

  IFsaFilterRecall::GetStream()

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CFsaFilterRecall::GetStream"), OLESTR(""));
    try {
        WsbAssert( 0 != ppStream, E_POINTER);
        if ((m_mode & FILE_OPEN_NO_RECALL) && (m_pStream != 0)) {
            *ppStream = m_pStream;
            m_pStream.p->AddRef();
        } else {
            *ppStream = 0;
            hr = WSB_E_NOTFOUND;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaFilterRecall::GetStream"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}



HRESULT
CFsaFilterRecall::GetDriversRecallId(
    OUT ULONGLONG* pId
    )

/*++

Implements:

  IFsaFilterRecallPriv::GetDriversRecallId().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != pId, E_POINTER);

        *pId = m_driversRecallId;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaFilterRecall::GetIdentifier(
    OUT GUID* pId
    )

/*++

Implements:

  IFsaFilterRecall::GetIdentifier().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != pId, E_POINTER);

        *pId = m_id;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaFilterRecall::GetMode(
    OUT ULONG* pMode
    )

/*++

Implements:

  IFsaFilterRecall::GetMode().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != pMode, E_POINTER);

        *pMode = m_mode;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaFilterRecall::GetOffset(
    OUT LONGLONG* pOffset
    )

/*++

Implements:

  IFsaFilterRecall::GetOffset().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != pOffset, E_POINTER);

        *pOffset = m_offset;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaFilterRecall::GetPath(
    OUT OLECHAR** pName,
    IN ULONG bufferSize
    )

/*++

Implements:

  IFsaFilterRecall::GetPath().

--*/
{
    HRESULT         hr = S_OK;
    CWsbStringPtr   tmpString;

    try {

        WsbAssert(0 != pName, E_POINTER);

        WsbAffirmHr(tmpString.TakeFrom(*pName, bufferSize));

        try {
            WsbAffirmHr(m_pResource->GetUncPath(&tmpString, 0));
            WsbAffirmHr(tmpString.Append(m_path));
        } WsbCatch(hr);

        WsbAffirmHr(tmpString.GiveTo(pName));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaFilterRecall::GetPlaceholder(
    OUT FSA_PLACEHOLDER* pPlaceholder
    )

/*++

Implements:

  IFsaFilterRecallPriv::GetPlaceholder().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != pPlaceholder, E_POINTER); 
        *pPlaceholder = m_placeholder;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaFilterRecall::GetResource(
    OUT IFsaResource** ppResource
    )

/*++

Implements:

  IFsaFilterRecall::GetResource().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != ppResource, E_POINTER);

        *ppResource = m_pResource;
        m_pResource.p->AddRef();

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaFilterRecall::GetSession(
    OUT IHsmSession** ppSession
    )

/*++

Implements:

  IFsaFilterRecall::GetSession().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != ppSession, E_POINTER);

        *ppSession = m_pSession;
        m_pSession.p->AddRef();

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaFilterRecall::GetSize(
    OUT LONGLONG* pSize
    )

/*++

Implements:

  IFsaFilterRecall::GetSize().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != pSize, E_POINTER);

        *pSize = m_size;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaFilterRecall::GetSizeMax(
    OUT ULARGE_INTEGER* pSize
    )

/*++

Implements:

  IPersistStream::GetSizeMax().

--*/
{
    HRESULT                 hr = S_OK;


    WsbTraceIn(OLESTR("CFsaFilterRecall::GetSizeMax"), OLESTR(""));

    try {

        WsbAssert(0 != pSize, E_POINTER);
        pSize->QuadPart = 0;

        // WE don't need to persist these.
        hr = E_NOTIMPL;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaFilterRecall::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pSize));

    return(hr);
}


HRESULT
CFsaFilterRecall::GetState(
    OUT HSM_JOB_STATE* pState
    )

/*++

Implements:

  IFsaFilterRecall::GetState().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != pState, E_POINTER); 
        *pState = m_state;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaFilterRecall::GetUserName(
    OUT OLECHAR** pName,
    IN ULONG bufferSize
    )

/*++

Implements:

  IFsaFilterRecall::GetUserName().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != pName, E_POINTER);

        if (m_pClient != 0) {
            WsbAffirmHr(m_pClient->GetUserName(pName, bufferSize));
        } else {
            hr = WSB_E_NOTFOUND;
        }

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaFilterRecall::HasCompleted(
    HRESULT     resultHr
    )

/*++

Implements:

  IFsaFilterRecall::HasCompleted().

--*/
{
    HRESULT                         hr = S_OK, hr2 = S_OK;
    CComPtr<IFsaFilterClient>       pClient;
    CComPtr<IWsbEnum>               pEnum;
    FILETIME                        now;
    BOOL                            bSendNotify = TRUE;
    DWORD                           dwStatus;
    

    WsbTraceIn(OLESTR("CFsaFilterRecall::HasCompleted"), 
            OLESTR("filter Id = %I64x, recall hr = <%ls>"), m_driversRecallId,
            WsbHrAsString(resultHr));

    try {

        // The job is complete, let the kernel mode filter know what happened.

        GetSystemTimeAsFileTime(&now);

        if (m_pClient != 0) {
            m_pClient->SetLastRecallTime(now);      // Not fatal if this fails
        }

        if (m_kernelCompletionSent == FALSE) {
            WsbAffirmHr(m_pFilterPriv->SendComplete((IFsaFilterRecallPriv *) this, resultHr));
            m_kernelCompletionSent = TRUE;
        }

        if (m_pClient != 0) {
            // Reporting on recall end must be synchronized with the recall start notification, 
            // because such notification might be sent after the recall starts
            switch (WaitForSingleObject(m_notifyEvent, INFINITE)) {
                case WAIT_OBJECT_0:
                    // Send recall notifications to the client that initiated the recall 
                    m_pClient->SendRecallInfo((IFsaFilterRecall *) this, FALSE, resultHr);
                    SetEvent(m_notifyEvent);
                    break;

                 case WAIT_FAILED:
                 default:
                    WsbTrace(OLESTR("CFsaFilterRecall::HasCompleted: WaitForSingleObject returned error %lu\n"), GetLastError());

                    // Notify anyway
                    m_pClient->SendRecallInfo((IFsaFilterRecall *) this, FALSE, resultHr);
                    break;
            }

            bSendNotify = FALSE;    
        }

        dwStatus = WaitForSingleObject(m_waitingClientEvent, INFINITE);

        // Notify on recall end no matter what the status is
        if (m_pWaitingClients != 0) {
            // 
            // Send recall notifications to all clients waiting for the recall 
            // to finish
            //
            hr2 = m_pWaitingClients->Enum(&pEnum);
            if (S_OK == hr2) {
                hr2 = pEnum->First(IID_IFsaFilterClient, (void**) &pClient);
                while (S_OK == hr2) {
                   pClient->SendRecallInfo((IFsaFilterRecall *) this, FALSE, resultHr);            
                   m_pWaitingClients->RemoveAndRelease(pClient);
                   pClient = NULL;
                   pEnum->Reset();
                   hr2 = pEnum->First(IID_IFsaFilterClient, (void**) &pClient);
                }
            }
        }

        m_waitingClientsNotified = TRUE;

        switch (dwStatus) {
            case WAIT_OBJECT_0:
                SetEvent(m_waitingClientEvent);
                break;

            case WAIT_FAILED:
            default:
                WsbTrace(OLESTR("CFsaFilterRecall::HasCompleted: WaitForSingleObject returned error %lu\n"), dwStatus);
                break;
        }            

        //
        // Detach the data mover stream
        //
        if (m_pDataMover != 0) {    
            WsbAffirmHr( m_pDataMover->CloseStream() );
        }

    } WsbCatchAndDo(hr,
        if ((m_pClient != 0) && bSendNotify) {
            m_pClient->SendRecallInfo((IFsaFilterRecall *) this, FALSE, resultHr);
            bSendNotify = FALSE;
        }
    );

    WsbTraceOut(OLESTR("CFsaFilterRecall::HasCompleted"), OLESTR("filter Id = %I64x, sent = <%ls>, hr = <%ls>"), 
            m_driversRecallId, WsbBoolAsString(m_kernelCompletionSent), 
            WsbHrAsString(hr));

    return(hr);
}



HRESULT
CFsaFilterRecall::CheckRecallLimit(
    IN DWORD   minRecallInterval,
    IN DWORD   maxRecalls,
    IN BOOLEAN exemptAdmin
    )

/*++

Implements:

  IFsaFilterRecall::CheckRecallLimit().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CFsaFilterRecall::CheckRecallLimit"), OLESTR("filter Id = %I64x"),
            m_driversRecallId);

    try {

        // Check the limit if we are not file open no recall
        if (!(m_mode & FILE_OPEN_NO_RECALL) && (m_pClient != NULL)) {
            WsbAffirmHr(m_pClient->CheckRecallLimit(minRecallInterval, maxRecalls, exemptAdmin));
        }

    } WsbCatch(hr);

    //
    //  Commenting the following out: we are reverting back to 
    //  denial of service when we hit the recall limit, not trunc-on-close
    //
    //  If we hit the recall limit then we start to truncate on close.
    //
    // if (hr == FSA_E_HIT_RECALL_LIMIT) {
    //    m_recallFlags |= RP_RECALL_ACTION_TRUNCATE;
    // }
    WsbTraceOut(OLESTR("CFsaFilterRecall::CheckRecallLimit"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaFilterRecall::Init(
    IN IFsaFilterClient* pClient,
    IN ULONGLONG DriversRecallId,
    IN IFsaResource* pResource,
    IN OLECHAR* path,
    IN LONGLONG fileId,
    IN LONGLONG offset,
    IN LONGLONG size,
    IN ULONG mode,
    IN FSA_PLACEHOLDER* pPlaceholder,
    IN IFsaFilterPriv *pFilterPriv
    )

/*++

Implements:

  IFsaFilterRecallPriv::Init().

--*/
{
    HRESULT                             hr = S_OK;
    FILETIME                            now;
    CComPtr<IFsaResourcePriv>           pResourcePriv;

    WsbTraceIn(OLESTR("CFsaFilterRecall::Init"), OLESTR("filter ID = %I64x, offset = %I64u, size = %I64u"), 
            DriversRecallId, offset, size);

    try {
        m_pClient = pClient;
        m_driversRecallId = DriversRecallId;
        m_pResource = pResource;
        m_placeholder = *pPlaceholder;
        m_pFilterPriv = pFilterPriv;
        m_path = path;
        m_mode = mode;
        m_fileId = fileId;
        GetSystemTimeAsFileTime(&m_startTime);

        m_offset = offset;
        m_size = size;
        m_isDirty = TRUE;

        WsbAssert(m_path != 0, E_UNEXPECTED);
        //
        // Get the recall started with the engine
        // Start a session and ask it to advise us of state changes.
        // Tell the resource object that we got an open.
        //

        hr = S_OK;
        
    } WsbCatchAndDo(hr,
        // 
        // Something failed - send the kernel completion if it has not been sent already.
        //
        GetSystemTimeAsFileTime(&now);
        if (m_pClient != 0) {
            m_pClient->SetLastRecallTime(now);
        }
        if (m_kernelCompletionSent == FALSE) {
            m_pFilterPriv->SendComplete((IFsaFilterRecallPriv *) this, hr);
            m_kernelCompletionSent = TRUE;
        } else  {
            WsbLogEvent(FSA_MESSAGE_RECALL_FAILED, 0, NULL, (OLECHAR*) WsbAbbreviatePath(path, 120), WsbHrAsString(hr), NULL);
        }

        if (m_pClient != 0) {
            m_pClient->SendRecallInfo((IFsaFilterRecall *) this, FALSE, E_FAIL);  // Not fatal if this fails
        }

    );

    WsbTraceOut(OLESTR("CFsaFilterRecall::Init"), OLESTR("%ls"), WsbHrAsString(hr));

    return(hr);
}

    

HRESULT
CFsaFilterRecall::Load(
    IN IStream* pStream
    )

/*++

Implements:

  IPersistStream::Load().

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaFilterRecall::Load"), OLESTR(""));

    try {
        WsbAssert(0 != pStream, E_POINTER);
        
        // No persistence.
        hr = E_NOTIMPL;

    } WsbCatch(hr);                                        

    WsbTraceOut(OLESTR("CFsaFilterRecall::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaFilterRecall::LogComplete(
    IN HRESULT result
    )

/*++

Implements:

  IFsaFilterRecallPriv:LogComplete(HRESULT result)

--*/
{
    HRESULT                     hr = S_OK;
    FILETIME                    completeTime;
    LONGLONG                    recallTime;

    WsbTraceIn(OLESTR("CFsaFilterRecall::LogComplete"), OLESTR("filter Id = %I64x"),
            m_driversRecallId);

    try {
        // Calculate the time it took for this recall to complete
        GetSystemTimeAsFileTime(&completeTime);
        recallTime = WsbFTtoLL(WsbFtSubFt(completeTime, m_startTime));
        // If over 10 minutes then show time in minutes otherwise show in seconds
        if (recallTime >= (WSB_FT_TICKS_PER_MINUTE * (LONGLONG) 10)) {
            recallTime = recallTime / WSB_FT_TICKS_PER_MINUTE;
            WsbTrace(OLESTR("CFsaFilterRecall::LogComplete Recall of %ws completed in %I64u minutes. (%ws)\n"),
                WsbAbbreviatePath(m_path, 120), recallTime, WsbHrAsString(result));
            WsbLogEvent(FSA_MESSAGE_RECALL_TIMING_MINUTES, 0, NULL, 
                WsbAbbreviatePath(m_path, 120), WsbLonglongAsString(recallTime), WsbHrAsString(result), NULL);
        } else {
            recallTime = recallTime / WSB_FT_TICKS_PER_SECOND;
            WsbTrace(OLESTR("CFsaFilterRecall::LogComplete Recall of %ws completed in %I64u seconds. (%ws)\n"),
                WsbAbbreviatePath(m_path, 120), recallTime, WsbHrAsString(result));
            WsbLogEvent(FSA_MESSAGE_RECALL_TIMING_SECONDS, 0, NULL, 
                WsbAbbreviatePath(m_path, 120), WsbLonglongAsString(recallTime), WsbHrAsString(result), NULL);
        }

    } WsbCatch(hr);                                        

    WsbTraceOut(OLESTR("CFsaFilterRecall::LogComplete"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaFilterRecall::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )

/*++

Implements:

  IPersistStream::Save().

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IPersistStream> pPersistStream;

    WsbTraceIn(OLESTR("CFsaFilterRecall::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));
    
    try {
        WsbAssert(0 != pStream, E_POINTER);
        
        // No persistence.
        hr = E_NOTIMPL;

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaFilterRecall::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaFilterRecall::SetDriversRecallId(
    IN ULONGLONG pId
    )

/*++

Implements:

  IFsaFilterRecallPriv::SetDriversRecallId().

--*/
{
    HRESULT         hr = S_OK;

    try {

        m_driversRecallId = pId;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaFilterRecall::SetThreadId(
    IN DWORD id
    )

/*++

Implements:

  IFsaFilterRecallPriv::SetThreadId().

--*/
{
    HRESULT         hr = S_OK;

    try {

        m_threadId = id;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaFilterRecall::SetIdentifier(
    IN GUID id
    )

/*++

Implements:

  IFsaFilterRecallPriv::SetIdentifier().

--*/
{
    HRESULT         hr = S_OK;

    m_id = id;
    m_isDirty = TRUE;

    return(hr);
}



HRESULT
CFsaFilterRecall::StartRecall(
    IN ULONGLONG offset,
    IN ULONGLONG size
    )

/*++

Implements:

  IFsaFilterRecallPriv::StartRecall().

--*/
{
    HRESULT                             hr = S_OK;
    FILETIME                            now;
    CComPtr<IFsaResourcePriv>           pResourcePriv;
    CWsbStringPtr                       sessionName;
    ULONG                               tryLoop;
    BOOL                                bSentNotify = FALSE;


    WsbTraceIn(OLESTR("CFsaFilterRecall::StartRecall"), OLESTR("filter Id = %I64x"),
            m_driversRecallId);

    try {
        m_offset = offset;
        m_size = size;
        if (m_mode & FILE_OPEN_NO_RECALL) {
            if (m_offset >= m_placeholder.dataStreamSize) {
                //
                // Read beyond the end of file
                //
                hr = STATUS_END_OF_FILE;
                WsbAffirmHr(hr);
            } else if ( (m_offset + m_size) > (m_placeholder.dataStreamStart + m_placeholder.dataStreamSize) ) {
                //
                // They are asking for more than we have - adjust the read size
                //
                m_size -= (m_offset + m_size) - (m_placeholder.dataStreamStart + m_placeholder.dataStreamSize);
            }
        }

        m_isDirty = TRUE;

        WsbAssert(m_path != 0, E_UNEXPECTED);
        //
        // Get the recall started with the engine
        // Start a session and ask it to advise us of state changes.
        // Tell the resource object that we got an open.
        //
        WsbTrace(OLESTR("CFsaFilterRecall::StartRecall:  BeginSession\n"));

        // Get the string that we are using to describe the session.
        WsbAffirmHr(sessionName.LoadFromRsc(_Module.m_hInst, IDS_FSA_RECALL_NAME));

        WsbAffirmHr(m_pResource->BeginSession(sessionName, HSM_JOB_LOG_ITEMMOSTFAIL | HSM_JOB_LOG_HR, 1, 1, &m_pSession));

        WsbTrace(OLESTR("CFsaFilterRecall::StartRecall: Session is setup.\n"));
        WsbTrace(OLESTR("CFsaFilterRecall::StartRecall: Notify the client that the recall started.\n"));

        if (m_pClient != 0) {
            hr = m_pClient->SendRecallInfo((IFsaFilterRecall *) this, TRUE, S_OK);  // Not fatal if this fails
            if (! SUCCEEDED(hr)) {
                WsbTrace(OLESTR("CFsaFilterRecall::StartRecall: SendNotify failed with %ls.\n"),
                    WsbHrAsString(hr));
            } else {
                if (hr != S_OK) {
                    WsbTrace(OLESTR("CFsaFilterRecall::StartRecall: SendNotify returned %ls.\n"),
                        WsbHrAsString(hr));
                }

                bSentNotify = TRUE;
            }
        }
        hr = S_OK;
        
        //
        // Tell the resource to send the job to the engine.
        //
        WsbTrace(OLESTR("CFsaFilterRecall::StartRecall: Calling FilterSawOpen.\n"));

        WsbAffirmHr(m_pResource->QueryInterface(IID_IFsaResourcePriv, (void**) &pResourcePriv));

        if (m_mode & FILE_OPEN_NO_RECALL) {
            WsbAffirmHr(pResourcePriv->FilterSawOpen(m_pSession, 
                (IFsaFilterRecall*) this,
                m_path, 
                m_fileId,
                offset, 
                size,
                &m_placeholder, 
                m_mode, 
                FSA_RESULT_ACTION_NORECALL,
                m_threadId));
        } else {
            WsbAffirmHr(pResourcePriv->FilterSawOpen(m_pSession, 
                (IFsaFilterRecall*) this,
                m_path, 
                m_fileId,
                offset, 
                size, 
                &m_placeholder, 
                m_mode, 
                FSA_RESULT_ACTION_OPEN,
                m_threadId));
        }

        //
        // The work is now complete - terminate the session.
        //
        WsbTrace(OLESTR("CFsaFilterRecall::StartRecall: End Session.\n"));
        WsbAffirmHr(m_pResource->EndSession(m_pSession));

        //
        // Try the notification again if we have not sent it yet.
        // On the first recall from a remote client the identification usually does not
        // happen in time for the first attempt so we try again here.
        // We will try 5 times with a .1 second delay between.
        //

        WsbTrace(OLESTR("CFsaFilterRecall::StartRecall: m_pClient = %x sent = %u.\n"),
                    m_pClient, bSentNotify);

        if ((m_pClient != 0) && (!bSentNotify)) {
            tryLoop = 5;
            while ((tryLoop != 0) &&( !bSentNotify)) {

                // Reporting here is done after the recall is started.
                // Therefore, it must be synchronized with the recall end notification
                switch (WaitForSingleObject(m_notifyEvent, INFINITE)) {
                    case WAIT_OBJECT_0:
                        // Check if need to report (if recall did not end yet)
                        if (m_kernelCompletionSent == FALSE) {
                            // Recall end was not sent yet
                            hr = m_pClient->SendRecallInfo((IFsaFilterRecall *) this, TRUE, S_OK);  // Not fatal if this fails
                        }
                        SetEvent(m_notifyEvent);
                        break;

                    case WAIT_FAILED:
                    default:
                        WsbTrace(OLESTR("CFsaFilterRecall::StartRecall: WaitForSingleObject returned error %lu\n"), GetLastError());

                        // Just get out without notifying
                        hr = S_OK;
                        break;
                }

                if (! SUCCEEDED(hr)) {
                    WsbTrace(OLESTR("CFsaFilterRecall::StartRecall: Retried notify failed with %ls.\n"),
                        WsbHrAsString(hr));
                    if (tryLoop != 1) {
                        Sleep(100);     // Sleep .1 sec and try again
                    }
                } else {
                    if (hr != S_OK)
                        WsbTrace(OLESTR("CFsaFilterRecall::StartRecall: Retried notify returned %ls.\n"),
                            WsbHrAsString(hr));

                    bSentNotify = TRUE;
                }

            tryLoop--;
            }

        hr = S_OK;
        }

    } WsbCatchAndDo(hr,
        // 
        // Something failed - send the kernel completion if it has not been sent already.
        //
        GetSystemTimeAsFileTime(&now);
        if (m_pClient != 0) {
            m_pClient->SetLastRecallTime(now);
        }
        if (m_kernelCompletionSent == FALSE) {
            m_pFilterPriv->SendComplete((IFsaFilterRecallPriv *) this, hr);
            m_kernelCompletionSent = TRUE;
        } else  {
            //
            // STATUS_END_OF_FILE is not really an error - it just means they tried to read past the end - some apps do this and expect
            // this status to tell them when to stop reading.
            //
            if (hr != STATUS_END_OF_FILE) {
                WsbLogEvent(FSA_MESSAGE_RECALL_FAILED, 0, NULL, (OLECHAR*) WsbAbbreviatePath(m_path, 120), WsbHrAsString(hr), NULL);
            }
        }

        if (m_pClient != 0) {
            m_pClient->SendRecallInfo((IFsaFilterRecall *) this, FALSE, E_FAIL);  // Not fatal if this fails
        }

    );

    WsbTraceOut(OLESTR("CFsaFilterRecall::StartRecall"), OLESTR("%ls"), WsbHrAsString(hr));

    return(hr);
}


    

HRESULT
CFsaFilterRecall::Test(
    USHORT* passed,
    USHORT* failed
    )

/*++

Implements:

  IWsbTestable::Test().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != passed, E_POINTER);
        WsbAssert(0 != failed, E_POINTER);

        *passed = 0;
        *failed = 0;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaFilterRecall::WasCancelled(
    void
    )

/*++

Implements:

  IFsaFilterRecall::WasCancelled().

--*/
{
    HRESULT                 hr = S_OK;

    if (!m_wasCancelled) {
        hr = S_FALSE;
    }

    return(hr);
}


HRESULT
CFsaFilterRecall::AddClient(
    IFsaFilterClient *pWaitingClient
    )
/*++

Implements:

    IFsaFilterRecall::AddClient    

--*/
{
    HRESULT hr = E_FAIL;
    
    switch (WaitForSingleObject(m_waitingClientEvent, INFINITE)) {
        case WAIT_OBJECT_0:
            if ((!m_waitingClientsNotified) && (m_pWaitingClients != 0)) {
                hr = m_pWaitingClients->Add(pWaitingClient);
                if (hr == S_OK) {
                    // Notify client only if it was added successfully to the collection
                    hr = pWaitingClient->SendRecallInfo((IFsaFilterRecall *) this, TRUE, S_OK);  // Not fatal if this fails
                    if (hr != S_OK) {
                        // Note that S_FALSE is an "expected failure" but we still want to trace this
                        WsbTrace(OLESTR("CFsaFilterRecall::AddClient: SendNotify for start returned %ls.\n"), 
                                WsbHrAsString(hr));
                    } 
                }
            } 

            SetEvent(m_waitingClientEvent);
            break;

        case WAIT_FAILED:
        default:
            DWORD dwErr = GetLastError();
            WsbTrace(OLESTR("CFsaFilterRecall::AddClient: WaitForSingleObject returned error %lu\n"), dwErr);

            // Don't add waiting client
            hr = HRESULT_FROM_WIN32(dwErr);
            break;
    }

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\fsa\fsaitemr.cpp ===
/*++

(c) 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    fsaitemr.cpp

Abstract:

    This class contains represents a scan item (i.e. file or directory) for NTFS 5.0.

Author:

    Chuck Bardeen   [cbardeen]   1-Dec-1996

Revision History:
    Michael Lotz    [lotz    ]  13-Jan-1997

--*/

#include "stdafx.h"

#define WSB_TRACE_IS        WSB_TRACE_BIT_FSA

#include "wsb.h"
#include "fsa.h"
#include "fsaitem.h"
#include "rpdata.h"
#include "rpio.h"
#include "rpguid.h"
#include "fsaitemr.h"


#define SHARE_FLAGS         (FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE)
#define EXCLUSIVE_FLAG      ( 0 ) // exclusive open without sharing of the file

//
// Notice these two bits are NOT the same location????
//
#define BIT_FOR_TRUNCATED   FILE_ATTRIBUTE_OFFLINE
#define BIT_FOR_RP          FILE_ATTRIBUTE_REPARSE_POINT

//
// File extensions that are treated as special cases for truncate
//
#define EXT_FOR_EXE     L".exe"
#define EXT_FOR_DLL     L".dll"

//
// Macros and defines for exe and dll headers
//
#define SIZE_OF_NT_SIGNATURE    sizeof(DWORD)
//
// Macros
//
/* Offset to PE file signature                              */
#define NTSIGNATURE(a) ((LPVOID)((BYTE *)a                +  \
                        ((PIMAGE_DOS_HEADER)a)->e_lfanew))

/* MS-OS header identifies the NT PEFile signature dword;
   the PEFILE header exists just after that dword.           */
#define PEFHDROFFSET(a) ((LPVOID)((BYTE *)a               +  \
                         ((PIMAGE_DOS_HEADER)a)->e_lfanew +  \
                             SIZE_OF_NT_SIGNATURE))

/* PE optional header is immediately after PEFile header.    */
#define OPTHDROFFSET(a) ((LPVOID)((BYTE *)a               +  \
                         ((PIMAGE_DOS_HEADER)a)->e_lfanew +  \
                           SIZE_OF_NT_SIGNATURE           +  \
                           sizeof (IMAGE_FILE_HEADER)))

/* Section headers are immediately after PE optional header. */
#define SECHDROFFSET(a) ((LPVOID)((BYTE *)a               +  \
                         ((PIMAGE_DOS_HEADER)a)->e_lfanew +  \
                           SIZE_OF_NT_SIGNATURE           +  \
                           sizeof (IMAGE_FILE_HEADER)     +  \
                           sizeof (IMAGE_OPTIONAL_HEADER)))



HRESULT
OpenObject (
    IN WCHAR const *pwszFile,
    IN ULONG CreateOptions,
    IN ULONG DesiredAccess,
    IN ULONG ShareAccess,
    IN ULONG CreateDisposition,
    OUT IO_STATUS_BLOCK *IoStatusBlock,
    OUT HANDLE *ObjectHandle 
    )
    
/*++

Implements: A wrapper function for NtCreateFile

  OpenObject

--*/
//
//  Simple wrapper for NtCreateFile
//

{
    HRESULT             hr = S_OK;
    NTSTATUS            ntStatus;
    BOOL                bStatus;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    UNICODE_STRING      str;
    RTL_RELATIVE_NAME_U RelativeName;
    PVOID               StrBuffer = NULL;
    BOOL                bReleaseRelativeName = FALSE;

    WsbTraceIn(OLESTR("OpenObject"), OLESTR(""));
    //
    // Null out the pointer so we know when it was allocated
    //
    str.Buffer = NULL;
    RelativeName.RelativeName.Buffer = NULL;
    
    try {
        //
        // Convert input name into special format with \??\
        //
        //bStatus = RtlDosPathNameToNtPathName_U( pwszFile,
        //                                        &str,
        //                                        NULL,
        //                                        NULL );
        //WsbAffirm( bStatus, E_FAIL);

        bStatus = RtlDosPathNameToRelativeNtPathName_U(
                                pwszFile,
                                &str,
                                NULL,
                                &RelativeName
                                );

        WsbAffirm( bStatus, E_FAIL);
        bReleaseRelativeName = TRUE;
        StrBuffer = str.Buffer;

        if ( RelativeName.RelativeName.Length ) {
            str = RelativeName.RelativeName;
        } else {
            RelativeName.ContainingDirectory = NULL;
        }

        InitializeObjectAttributes(
            &ObjectAttributes,
            &str,
            0,
            RelativeName.ContainingDirectory,
            NULL
            );


        ntStatus = NtCreateFile(
                    ObjectHandle,
                    DesiredAccess | SYNCHRONIZE,
                    &ObjectAttributes,
                    IoStatusBlock,
                    NULL,                    // pallocationsize (none!)
                    FILE_ATTRIBUTE_NORMAL,
                    ShareAccess,
                    CreateDisposition,
                    CreateOptions | FILE_OPEN_REPARSE_POINT | FILE_OPEN_FOR_BACKUP_INTENT | FILE_SYNCHRONOUS_IO_NONALERT,
                    NULL,                    // EA buffer (none!)
                    0);
        //
        // Right now if the file is not a reparse point the above open
        // fails -- so now try it without the FILE_OPEN_REPARSE_POINT
        //
        if ( STATUS_NOT_A_REPARSE_POINT == ntStatus) {          
            WsbAffirmNtStatus(  NtCreateFile(
                        ObjectHandle,
                        DesiredAccess | SYNCHRONIZE,
                        &ObjectAttributes,
                        IoStatusBlock,
                        NULL,                    // pallocationsize (none!)
                        FILE_ATTRIBUTE_NORMAL,
                        ShareAccess,
                        CreateDisposition,
                        CreateOptions | FILE_OPEN_FOR_BACKUP_INTENT | FILE_SYNCHRONOUS_IO_NONALERT | FILE_FLAG_POSIX_SEMANTICS,
                        NULL,                    // EA buffer (none!)
                        0 ) );
        } else {
            WsbAffirmNtStatus( ntStatus );
        }

    } WsbCatch( hr );
 
    //
    // Clean up the memory if we allocated it
    //
    if (bReleaseRelativeName) {
        RtlReleaseRelativeName(&RelativeName);
    }
    
    if (NULL != StrBuffer) {
        RtlFreeHeap(RtlProcessHeap(), 0, StrBuffer);
    }

    //if( NULL == str.Buffer ) {
    //    bStatus = RtlFreeHeap( RtlProcessHeap(), 0, str.Buffer );
    //}
    
    WsbTraceOut(OLESTR("OpenObject"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return( hr );
}  // OpenObject


HRESULT
CopyPlaceholderToRP (
    IN CONST FSA_PLACEHOLDER *pPlaceholder,
    OUT PREPARSE_DATA_BUFFER pReparseBuffer,
    IN BOOL bTruncated
    )
    
/*++

Implements: A wrapper function for copying the placeholder data into the reparse point

  CopyPlaceholderToRP

--*/
//
//  Simple wrapper moving the data from the scan item in-memory 
//  placeholder information into a reparse point buffer
//

{
    HRESULT         hr = S_OK;
    PRP_DATA        pHsmData;
    
    WsbTraceIn(OLESTR("CopyPlaceholderToRP"), OLESTR(""));
    WsbTrace(OLESTR("  fileStart = %I64d, dataStart = %I64d, dataStreamStart = %I64d\n"),
            pPlaceholder->fileStart, pPlaceholder->dataStart, 
            pPlaceholder->dataStreamStart);
    WsbTrace(OLESTR("  fileSize = %I64d, dataSize = %I64d, dataStreamSize = %I64d\n"),
            pPlaceholder->fileSize, pPlaceholder->dataSize, 
            pPlaceholder->dataStreamSize);
    try {
        //
        // Validate the pointers passed in
        //
        WsbAssert( NULL != pPlaceholder, E_POINTER );
        WsbAssert( NULL != pReparseBuffer, E_POINTER );
        
        //
        // Setup the pointer to our hsm data
        //
        pHsmData = (PRP_DATA) &pReparseBuffer->GenericReparseBuffer.DataBuffer[0];

        //
        // Set the generic reparse point header information for the tag and size
        //
        pReparseBuffer->ReparseTag        = IO_REPARSE_TAG_HSM ;
        pReparseBuffer->ReparseDataLength = sizeof(RP_DATA);
        pReparseBuffer->Reserved          = 0 ;

        //
        // Set the private data that is the vendor id and version number
        //
        pHsmData->vendorId = RP_MSFT_VENDOR_ID;
        pHsmData->version  = RP_VERSION;
        
        //
        // Assume for now that there is only one placeholder
        // This needs to be updated
        //
        pHsmData->numPrivateData = 1;
        pHsmData->fileIdentifier = GUID_NULL;
        
        
        ZeroMemory(pHsmData->data.reserved, RP_RESV_SIZE);
        //
        // If the file is to indicate the file is truncated then set the bit
        // otherwise make sure it is off
        //
        RP_INIT_BITFLAG( pHsmData->data.bitFlags );
        if( bTruncated ) {
            RP_SET_TRUNCATED_BIT( pHsmData->data.bitFlags );
        } else {
            RP_CLEAR_TRUNCATED_BIT( pHsmData->data.bitFlags );
        }

        //
        // Set the truncate on close bit as needed
        //
        if( pPlaceholder->truncateOnClose ) {
            RP_SET_TRUNCATE_ON_CLOSE_BIT( pHsmData->data.bitFlags );
        } else {
            RP_CLEAR_TRUNCATE_ON_CLOSE_BIT( pHsmData->data.bitFlags );
        }

        //
        // Set the Premigrate on close bit as needed
        //
        if( pPlaceholder->premigrateOnClose ) {
            RP_SET_PREMIGRATE_ON_CLOSE_BIT( pHsmData->data.bitFlags );
        } else {
            RP_CLEAR_PREMIGRATE_ON_CLOSE_BIT( pHsmData->data.bitFlags );
        }

        //
        // Set the global bit flags based on the placeholder data
        // For now since we are assuming one placeholder then set
        // them the same.
        pHsmData->globalBitFlags = pHsmData->data.bitFlags;

        //
        // Move over the data parts of the information
        //
        pHsmData->data.migrationTime.QuadPart    = WsbFTtoLL( pPlaceholder->migrationTime );
        pHsmData->data.hsmId                     = pPlaceholder->hsmId;
        pHsmData->data.bagId                     = pPlaceholder->bagId;
        pHsmData->data.fileStart.QuadPart        = pPlaceholder->fileStart;
        pHsmData->data.fileSize.QuadPart         = pPlaceholder->fileSize;
        pHsmData->data.dataStart.QuadPart        = pPlaceholder->dataStart;
        pHsmData->data.dataSize.QuadPart         = pPlaceholder->dataSize;
        pHsmData->data.fileVersionId.QuadPart    = pPlaceholder->fileVersionId;
        pHsmData->data.verificationData.QuadPart = pPlaceholder->verificationData;
        pHsmData->data.verificationType          = pPlaceholder->verificationType;
        pHsmData->data.recallCount               = pPlaceholder->recallCount;
        pHsmData->data.recallTime.QuadPart       = WsbFTtoLL( pPlaceholder->recallTime );
        pHsmData->data.dataStreamStart.QuadPart  = pPlaceholder->dataStreamStart;
        pHsmData->data.dataStreamSize.QuadPart   = pPlaceholder->dataStreamSize;
        pHsmData->data.dataStream                = pPlaceholder->dataStream;

        pHsmData->data.dataStreamCRCType         = pPlaceholder->dataStreamCRCType;
        pHsmData->data.dataStreamCRC.QuadPart    = pPlaceholder->dataStreamCRC;
        //
        // Lastly generate the check sum
        //
        RP_GEN_QUALIFIER(pHsmData, pHsmData->qualifier);

        //
        // Now set the bit that tells the filter that it is us setting the reparse point.
        // This is not included in the qualifier checksum generation.
        //
        RP_SET_ORIGINATOR_BIT( pHsmData->data.bitFlags );

        
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CopyPlaceholderToRP"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return( hr );
}





HRESULT
CopyRPDataToPlaceholder (
    IN CONST PRP_DATA pHsmData,
    OUT FSA_PLACEHOLDER *pPlaceholder
    )
    
/*++

Implements: A wrapper function for moving the Reparse Point into generic FSA_PLACEHOLDER format

  CopyRPDataToPlaceholder

--*/

{
    HRESULT         hr = S_OK;
    ULONG           qualifier;        // Used to checksum the data
    
    WsbTraceIn(OLESTR("CopyRPDataToPlaceholder"), OLESTR(""));
    WsbTrace(OLESTR("  fileStart = %I64d, dataStart = %I64d, dataStreamStart = %I64d\n"),
            pHsmData->data.fileStart.QuadPart, pHsmData->data.dataStart.QuadPart, 
            pHsmData->data.dataStreamStart.QuadPart);
    WsbTrace(OLESTR("  fileSize = %I64d, dataSize = %I64d, dataStreamSize = %I64d\n"),
            pHsmData->data.fileSize.QuadPart, pHsmData->data.dataSize.QuadPart, 
            pHsmData->data.dataStreamSize.QuadPart);
    //
    //  Simple wrapper moving the data from the reparse point buffer into the 
    //  generic placeholder information
    //
    try {
        //
        // Validate the pointers passed in
        //
        WsbAssert( NULL != pHsmData, E_POINTER );
        WsbAssert( NULL != pPlaceholder, E_POINTER );

        //
        // Just in case, we clear out the originator bit.
        //
        RP_CLEAR_ORIGINATOR_BIT( pHsmData->data.bitFlags );

        //
        // Verify the check sum and the key private fields
        //
        RP_GEN_QUALIFIER(pHsmData, qualifier);
        WsbAffirm( pHsmData->qualifier == qualifier, E_FAIL );
        WsbAffirm( RP_MSFT_VENDOR_ID   == pHsmData->vendorId, E_FAIL );
        WsbAffirm( RP_VERSION          == pHsmData->version, E_FAIL );
        
        //
        // Now that everything worked, save the values in our private data
        //
        pPlaceholder->migrationTime     = WsbLLtoFT( pHsmData->data.migrationTime.QuadPart );
        pPlaceholder->hsmId             = pHsmData->data.hsmId;
        pPlaceholder->bagId             = pHsmData->data.bagId;
        pPlaceholder->fileStart         = pHsmData->data.fileStart.QuadPart;
        pPlaceholder->fileSize          = pHsmData->data.fileSize.QuadPart;
        pPlaceholder->dataStart         = pHsmData->data.dataStart.QuadPart;
        pPlaceholder->dataSize          = pHsmData->data.dataSize.QuadPart;
        pPlaceholder->fileVersionId     = pHsmData->data.fileVersionId.QuadPart;
        pPlaceholder->verificationData  = pHsmData->data.verificationData.QuadPart;
        pPlaceholder->verificationType  = pHsmData->data.verificationType;
        pPlaceholder->recallCount       = pHsmData->data.recallCount;
        pPlaceholder->recallTime        = WsbLLtoFT( pHsmData->data.recallTime.QuadPart );
        pPlaceholder->dataStreamStart   = pHsmData->data.dataStreamStart.QuadPart;
        pPlaceholder->dataStreamSize    = pHsmData->data.dataStreamSize.QuadPart;
        pPlaceholder->dataStream        = pHsmData->data.dataStream;
        pPlaceholder->dataStreamCRCType = pHsmData->data.dataStreamCRCType;
        pPlaceholder->dataStreamCRC     = pHsmData->data.dataStreamCRC.QuadPart;

        //
        // Set placeholder bits
        //
        if( RP_FILE_IS_TRUNCATED( pHsmData->data.bitFlags ) ) {
            pPlaceholder->isTruncated = TRUE;
        } else {
            pPlaceholder->isTruncated = FALSE;
        }

        if( RP_FILE_DO_TRUNCATE_ON_CLOSE( pHsmData->data.bitFlags ) ) {
            pPlaceholder->truncateOnClose = TRUE;
        } else {
            pPlaceholder->truncateOnClose = FALSE;
        }

        if( RP_FILE_DO_PREMIGRATE_ON_CLOSE( pHsmData->data.bitFlags ) ) {
            pPlaceholder->premigrateOnClose = TRUE;
        } else {
            pPlaceholder->premigrateOnClose = FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CopyRPDataToPlaceholder"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return( hr );
}

HRESULT
CopyRPToPlaceholder (
    IN CONST PREPARSE_DATA_BUFFER pReparseBuffer,
    OUT FSA_PLACEHOLDER *pPlaceholder
    )
    
/*++

Implements: A wrapper function for moving the Reparse Point into generic FSA_PLACEHOLDER format

  CopyRPToPlaceholder

--*/

{
    HRESULT         hr = S_OK;
    PRP_DATA        pHsmData;
    
    WsbTraceIn(OLESTR("CopyRPToPlaceholder"), OLESTR(""));
    //
    //  Simple wrapper moving the data from the reparse point buffer into the 
    //  generic placeholder information
    //
    try {
        //
        // Validate the pointers passed in
        //
        WsbAssert( NULL != pReparseBuffer, E_POINTER );
        WsbAssert( NULL != pPlaceholder, E_POINTER );

        //
        // Get the pointers setup correctly to this buffer because the 
        // type REPARSE_DATA_BUFFER actually doesn't have any space
        // allocated for the data and that is our own type, so get pointers
        // pointing into the real allocated space so we can use them
        //
        pHsmData = (PRP_DATA) &pReparseBuffer->GenericReparseBuffer.DataBuffer[0];

        //
        // Validate the key public fields to make sure it is data we 
        // understand
        //
        WsbAffirm( IO_REPARSE_TAG_HSM == pReparseBuffer->ReparseTag , S_FALSE );
        WsbAffirm( sizeof(RP_DATA) == pReparseBuffer->ReparseDataLength , S_FALSE );

        //
        // Copy over the RP_DATA information
        //
        WsbAffirmHr(CopyRPDataToPlaceholder(pHsmData, pPlaceholder));


    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CopyRPToPlaceholder"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return( hr );
}



HRESULT 
CFsaScanItem::CalculateCurrentCRCAndUSN(
    IN LONGLONG offset,
    IN LONGLONG size,
    OUT ULONG *pCurrentCRC,
    OUT LONGLONG *pUsn
    )

{
    HRESULT                 hr = S_OK;
    HRESULT                 hrTest = S_OK;
    CWsbStringPtr           path;
    IO_STATUS_BLOCK         IoStatusBlock;
    HANDLE                  handle = INVALID_HANDLE_VALUE;
    FILE_BASIC_INFORMATION  basicInformation;

    try {
        WsbTraceIn(OLESTR("CFsaScanItem::CalculateCurrentCRCAndUSN"), OLESTR("offset = <%I64d>, size = <%I64d>"),
                offset, size);

        //
        // Create the real file name we need to open, under the covers this
        // allocates the buffer since the path pointer is null
        //
        WsbAffirmHr( GetFullPathAndName( OLESTR("\\\\?\\"), NULL, &path, 0));
        //WsbAffirmHr( GetFullPathAndName( NULL, NULL, &path, 0));
        WsbTrace(OLESTR("CFsaScanItem::CalculateCurrentCRCAndUSN for file <%ls>"), (OLECHAR *)path);
        
        // Open the file.   
        WsbAffirmHr( OpenObject( path, 
                                 FILE_NON_DIRECTORY_FILE,
                                 FILE_READ_DATA | FILE_WRITE_ATTRIBUTES | FILE_READ_ATTRIBUTES,
                                 EXCLUSIVE_FLAG,
                                 FILE_OPEN,
                                 &IoStatusBlock,
                                 &handle ) );

        //
        // The open worked, our handle should be valid but we check to be
        // safe and sure 
        //
        WsbAssertHandle( handle );
        
        //
        // Get the current attributes of the file and the times
        //
        WsbAssertNtStatus( NtQueryInformationFile( handle,
                                                    &IoStatusBlock,
                                                    (PVOID)&basicInformation,
                                                    sizeof( basicInformation ),
                                                    FileBasicInformation ) );
        
        //
        // Set the time flags so that when we close the handle the
        // time are not updated on the file and the FileAttributes 
        //
        basicInformation.CreationTime.QuadPart = -1;
        basicInformation.LastAccessTime.QuadPart = -1;
        basicInformation.LastWriteTime.QuadPart = -1;
        basicInformation.ChangeTime.QuadPart = -1;
        WsbAssertNtStatus( NtSetInformationFile( handle,
                                                 &IoStatusBlock,
                                                 (PVOID)&basicInformation,
                                                 sizeof( basicInformation ),
                                                 FileBasicInformation ) );
        //
        // Calculate the CRC
        //                                         
        WsbAffirmHr(CalculateCurrentCRCInternal(handle, offset, size, pCurrentCRC));                                                 
        
        //
        // Calculate the USN
        //
        *pUsn = 0;
        hr = WsbGetUsnFromFileHandle(handle, FALSE, pUsn); 
        if (S_OK != hr)  {
            //
            // If we can't get the USN set it to 0 which is an invalid
            // USN and keep going.
            *pUsn = 0;
            hr = S_OK;
        }
        
        //
        // Close the file
        //
        NtClose( handle );
        handle = INVALID_HANDLE_VALUE;
        
    } WsbCatch( hr );
    
    //
    // Close the file for sure
    //
    if( INVALID_HANDLE_VALUE != handle) {
        NtClose( handle );
    }

    WsbTraceOut(OLESTR("CalculateCurrentCRCAndUSN"), OLESTR("hr = <%ls>, CRC is <%ls>, USN is <%ls>"), 
        WsbHrAsString(hr), WsbPtrToUlongAsString(pCurrentCRC), WsbPtrToLonglongAsString(pUsn));
    return(hr);
}

HRESULT 
CFsaScanItem::CalculateCurrentCRCInternal(
    IN HANDLE   handle,
    IN LONGLONG offset,
    IN LONGLONG size,
    ULONG *pCurrentCRC
    )

{
    HRESULT                 hr = S_OK;
    HRESULT                 hrTest = S_OK;
    register ULONG          crc32 = 0;
    LONGLONG                bytesRemaining;
    LONGLONG                bytesToRead;
    ULONG                   bufferSize;
    ULONG                   bytesRead;
    CHAR *                  pBuffer = 0;
    CHAR *                  pCurrent;
    IO_STATUS_BLOCK         IoStatusBlock;

    try {
        WsbTraceIn(OLESTR("CFsaScanItem::CalculateCurrentCRCInternal"), OLESTR("offset = <%I64d>, size = <%I64d>"),
                offset, size);

        
        // set initial value of CRC to 'pre-conditioning value'
        INITIALIZE_CRC(crc32);

        //
        // Set up to read where we want to start
        //
        LARGE_INTEGER startPoint;
        startPoint.QuadPart = offset;
        
        // Get the size of the file.
        bytesToRead = size;
        
        //
        // Figure out the size of the buffer to create
        //
        if (bytesToRead < 1024*1024) {
            //
            // Allocate one buffer the size of the file
            //
            bufferSize = (ULONG)bytesToRead;
        } else  {
            bufferSize = (1024 * 1024);
        }
        
        pBuffer = (CHAR *)malloc(bufferSize);
        if (0 == pBuffer) {
            //
            // Try again for half the space
            //
            bufferSize = bufferSize / 2;
            pBuffer = (CHAR *)malloc(bufferSize);
            if (0 == pBuffer)  {
                WsbThrow( E_OUTOFMEMORY );
            }
        }

        // Start calculating CRC by processing a 'chunk' of the file at a time.
        // While there are still chunks left, read that amount.  Otherwise read the amount left.
        for (bytesRemaining = bytesToRead; bytesRemaining > 0; bytesRemaining -= bytesRead) {

            // Read data from the file. 
            WsbAssertNtStatus(NtReadFile(handle, NULL, NULL, NULL, &IoStatusBlock, pBuffer, bufferSize, &startPoint, NULL));
            bytesRead = (DWORD)IoStatusBlock.Information;
            startPoint.QuadPart += bytesRead;

            // Each byte needs to be added into the CRC.
            for (pCurrent = pBuffer; (pCurrent < (pBuffer + bytesRead)) && (S_OK == hr); pCurrent++) {

                hrTest = WsbCRCReadFile((UCHAR *)pCurrent, &crc32);
                if (S_OK != hrTest) {
                    hr = S_FALSE;
                }
            }
        }
        
        // return ones-complement of the calc'd CRC value - this is the actual CRC
        FINIALIZE_CRC(crc32);
        *pCurrentCRC = crc32;

    } WsbCatch( hr );
    
    //
    // Make sure allocated memory is freed
    //
    if (0 != pBuffer)  {
        free(pBuffer);
    }    
    
    
    WsbTraceOut(OLESTR("CalculateCurrentCRCInternal"), OLESTR("hr = <%ls>, CRC is <%ls>"), WsbHrAsString(hr), WsbPtrToUlongAsString(pCurrentCRC));
    return(hr);
}

HRESULT
CFsaScanItem::CreatePlaceholder(
    IN LONGLONG offset,
    IN LONGLONG size,
    IN FSA_PLACEHOLDER placeholder,
    IN BOOL checkUsn,
    IN LONGLONG usn,                    
    OUT LONGLONG *pUsn
    )  

/*++

Implements:

  IFsaScanItem::CreatePlaceholder().

--*/
{
    HRESULT                 hr = S_OK;
    CWsbStringPtr           path;
    HANDLE                  handle = INVALID_HANDLE_VALUE;
    ULONG                   DesiredAccess;
    IO_STATUS_BLOCK         IoStatusBlock;
    PREPARSE_DATA_BUFFER    pReparseBuffer;
    UCHAR                   ReparseBuffer[sizeof(REPARSE_DATA_BUFFER) + sizeof(RP_DATA) + 10];
    NTSTATUS                ntStatus;
    FILE_BASIC_INFORMATION  basicInformation;
    LONGLONG                lastWriteTime;
    LONGLONG                nowUsn = 0;
    CWsbStringPtr           volName;
    ULONG                   attributes;

    WsbTraceIn(OLESTR("CFsaScanItem::CreatePlaceholder"), OLESTR("offset = <%I64d>, size = <%I64d>, checkUsn = <%ls>, usn = <%I64d>"),
                        offset, size, WsbBoolAsString(checkUsn), usn);
    try {
        BOOL wasReadOnly = FALSE;
        
        //
        // Set the offset and size information
        //
        placeholder.dataStreamStart = offset;
        placeholder.dataStreamSize = size;
        
        //
        // Get the pointers setup correctly to this buffer because the 
        // type REPARSE_DATA_BUFFER actually doesn't have any space
        // allocated for the data and that is our own type, so get pointers
        // pointing into the real allocated space so we can use them
        //
        pReparseBuffer = (PREPARSE_DATA_BUFFER)ReparseBuffer;
        WsbAffirmHr( CopyPlaceholderToRP( &placeholder, pReparseBuffer, placeholder.isTruncated ) );
        
        //
        // Create the real file name we need to open, under the covers this
        // allocates the buffer since the path pointer is null
        //
        WsbAffirmHr( GetFullPathAndName( OLESTR("\\\\?\\"), NULL, &path, 0));
        //WsbAffirmHr( GetFullPathAndName( NULL, NULL, &path, 0));

        // Save whether this was readonly for later
        if (S_OK == IsReadOnly()) {
            wasReadOnly = TRUE;
        }
        
        //
        // Make sure the file is read/write
        WsbAffirmHr( MakeReadWrite() );
        
        //
        // Open the file to put the placeholder information in the reparse point
        //
        DesiredAccess = FILE_READ_DATA | FILE_WRITE_DATA | FILE_WRITE_ATTRIBUTES | FILE_READ_ATTRIBUTES ;
        WsbAffirmHr( OpenObject( path, 
                                 FILE_NON_DIRECTORY_FILE | FILE_NO_INTERMEDIATE_BUFFERING,
                                 DesiredAccess,
                                 EXCLUSIVE_FLAG,
                                 FILE_OPEN,
                                 &IoStatusBlock,
                                 &handle ) );

        //
        // The open worked, our handle should be valid but we check to be
        // safe and sure 
        //
        WsbAssertHandle( handle );

        //
        // Tell the USN journal that we are the source of the changes.
        //
        WsbAffirmHr(m_pResource->GetPath(&volName, 0));
        WsbAffirmHr(WsbMarkUsnSource(handle, volName));

        
        //
        // Get the USN from the file now before any writes occur.  
        // Note:  NtSetInformationFile will not change the USN if you set the FileAttributes to 0
        // and the dates to -1.  Setting the attributes to 0 leaves them unchanged.
        // 
        // (For now we skip this check for read-only files because the call to MakeReadWrite
        // changes the USN. This needs to be fixed in the future.)
        //
        if (checkUsn && !wasReadOnly)  {
            //
            // Get the current USN for this file
            //
            hr = WsbGetUsnFromFileHandle(handle, FALSE, &nowUsn);
            if (S_OK != hr)  {
                nowUsn = 0;
                hr = S_OK;
            }
        }            
        
        //
        // Get the current attributes of the file and the times
        //
        WsbAssertNtStatus( NtQueryInformationFile( handle,
                                                    &IoStatusBlock,
                                                    (PVOID)&basicInformation,
                                                    sizeof( basicInformation ),
                                                    FileBasicInformation ) );
        
        lastWriteTime = basicInformation.LastWriteTime.QuadPart;
        
        //
        // Set the time flags so that when we close the handle the
        // time are not updated on the file and the FileAttributes 
        // indicate the file is offline.  You must do this AFTER you
        // get the USN because the NtSetInformationFile changes the USN
        //
        basicInformation.CreationTime.QuadPart = -1;
        basicInformation.LastAccessTime.QuadPart = -1;
        basicInformation.LastWriteTime.QuadPart = -1;
        basicInformation.ChangeTime.QuadPart = -1;
        //
        // Set the attributes to 0 to avoid the usn change (the file attributes will remain unchanged).
        //
        attributes = basicInformation.FileAttributes;
        basicInformation.FileAttributes = 0;               // No change to attributes

        WsbAssertNtStatus( NtSetInformationFile( handle,
                                                 &IoStatusBlock,
                                                 (PVOID)&basicInformation,
                                                 sizeof( basicInformation ),
                                                 FileBasicInformation ) );
        
        
        basicInformation.FileAttributes = attributes;

        //
        // Make sure that the modify time of the file matches that
        // of the placeholder data. 
        //
        if (lastWriteTime != placeholder.fileVersionId)  {
            //
            // The file has changed - don't put the reparse point on the file.
            //
            hr = FSA_E_REPARSE_NOT_WRITTEN_FILE_CHANGED;
            WsbLogEvent(FSA_MESSAGE_REPARSE_NOT_WRITTEN_FILE_CHANGED, 0, NULL,  WsbAbbreviatePath(path, 120), WsbHrAsString(hr), NULL);
            WsbThrow( hr );
        } else if (checkUsn)  {
            // 
            // If we are to check the USN do it now
            //
            
            //
            // Rember if a USN is 0, it is not useful information so we can't
            // rely on it
            //
            WsbTrace(OLESTR("CFsaScanItem::CreatePlaceholder premig usn = <%I64d>, current usn <%I64d>\n"),
                    usn, nowUsn);
            if ((0 != nowUsn) && (0  != usn) && (nowUsn != usn))  {
                //
                // The file has changed - don't put the reparse point on the file.
                //
                hr = FSA_E_REPARSE_NOT_WRITTEN_FILE_CHANGED;
                WsbLogEvent(FSA_MESSAGE_REPARSE_NOT_WRITTEN_FILE_CHANGED, 0, NULL,  WsbAbbreviatePath(path, 120), WsbHrAsString(hr), NULL);
                WsbThrow( hr );
            }
        }

        //
        // Make the file able to be a sparse file
        // Note we assert only if the error is not a disk full error because we can get STATUS_NO_DISK_SPACE from this call and we 
        // do not want to see the log for that error.  
        // This is because the file must be padded out to a 16 cluster boundry before being made sparse.
        //
        // Note that this call does not affect the files data.  It just enables "sparseness" for the file. 
        //
        ntStatus = NtFsControlFile( handle,
                                NULL,
                                NULL,
                                NULL,
                                &IoStatusBlock,
                                FSCTL_SET_SPARSE,
                                NULL,
                                0,
                                NULL,
                                0 );


        if (!NT_SUCCESS(ntStatus)) {
            if (STATUS_DISK_FULL == ntStatus) {
                // Check whether the disk is really full, otherwise, assume that user has passed the quota limit
                // Note: we ignore errors here and assume disk-full
                hr = CheckIfDiskFull();
                if (S_OK == hr) {
                    hr = FSA_E_REPARSE_NOT_CREATED_DISK_FULL;
                } else if (S_FALSE == hr) {
                    hr = FSA_E_REPARSE_OWNER_PASS_QUOTA;
                } else {
                    // error
                    WsbTraceAlways(OLESTR("CFsaScanItem::CreatePlaceholder: failed to check disk space after DISK_FULL error. hr=<%ls>\n"),
                                    WsbHrAsString(hr));                                
                    hr = FSA_E_REPARSE_NOT_CREATED_DISK_FULL;
                }

            } else {
                hr = HRESULT_FROM_NT(ntStatus);
            }
            WsbLogEvent(FSA_MESSAGE_REPARSE_NOT_CREATED, 0, NULL,  
                    WsbAbbreviatePath(path, 120), WsbHrAsString(hr), NULL);
            WsbThrow(hr);
        }
        
                                                            
        //
        // Do the work of setting the Reparse Point
        //
        ntStatus = NtFsControlFile( handle,
                                  NULL,
                                  NULL,
                                  NULL,
                                  &IoStatusBlock,
                                  FSCTL_SET_REPARSE_POINT,
                                  pReparseBuffer,
                                  FIELD_OFFSET(REPARSE_DATA_BUFFER, GenericReparseBuffer)
                                    + pReparseBuffer->ReparseDataLength,
                                  NULL,
                                  0 );
        
        //
        // Check the return code, if everything worked update the in memory flag
        //
        if (!NT_SUCCESS(ntStatus)) {
            if (STATUS_DISK_FULL == ntStatus) {
                // Check whether the disk is really full, otherwise, assume that user has passed the quota limit
                // Note: we ignore errors here and assume disk-full
                hr = CheckIfDiskFull();
                if (S_OK == hr) {
                    hr = FSA_E_REPARSE_NOT_CREATED_DISK_FULL;
                } else if (S_FALSE == hr) {
                    hr = FSA_E_REPARSE_OWNER_PASS_QUOTA;
                } else {
                    // error
                    WsbTraceAlways(OLESTR("CFsaScanItem::CreatePlaceholder: failed to check disk space after DISK_FULL error. hr=<%ls>\n"),
                                    WsbHrAsString(hr));                                
                    hr = FSA_E_REPARSE_NOT_CREATED_DISK_FULL;
                }

            } else {
                hr = HRESULT_FROM_NT(ntStatus);
            }
            WsbLogEvent(FSA_MESSAGE_REPARSE_NOT_CREATED, 0, NULL,  
                    WsbAbbreviatePath(path, 120), WsbHrAsString(hr), NULL);
            WsbThrow(hr);
        }
 
        //
        // Now that we change the bit, change the in memory flags for 
        // this scan item
        //
        m_findData.dwFileAttributes |= BIT_FOR_RP;
 
        //
        // Set the OFFLINE attribute to indicate the correct status of 
        // the file
        //
        if( placeholder.isTruncated ) {
            basicInformation.FileAttributes |= BIT_FOR_TRUNCATED;
        } else {
            basicInformation.FileAttributes &= ~BIT_FOR_TRUNCATED;
        }

        basicInformation.FileAttributes |= FILE_ATTRIBUTE_NORMAL;  // Just in case result was zero (then no attributes would be set)

        WsbAssertNtStatus( NtSetInformationFile( handle,
                                                 &IoStatusBlock,
                                                 (PVOID)&basicInformation,
                                                 sizeof( basicInformation ),
                                                 FileBasicInformation ) );
        
        //
        // Get the current attributes of the file and the times
        //
        WsbAssertNtStatus( NtQueryInformationFile( handle,
                                                    &IoStatusBlock,
                                                    (PVOID)&basicInformation,
                                                    sizeof( basicInformation ),
                                                    FileBasicInformation ) );
        
        //
        // Set the in memory copy of the attributes to the right values
        //
        m_findData.dwFileAttributes = basicInformation.FileAttributes;

        //
        // Restore original attributes if required (must be done before retrieving the USN
        // since changing attributes changes the USN as well)
        //
        if (TRUE == m_changedAttributes) {
            RestoreAttributes();
        }

        //
        // Before we close the file, get the USN to return to the caller
        // Writing the reparse information will change the USN.
        //
        hr = WsbGetUsnFromFileHandle(handle, TRUE, pUsn);
        if (S_OK != hr)  {
            *pUsn = 0;
            hr = S_OK;
        }
        
        //
        // Close the file since we are done with it and set the handle to invalid
        //
        WsbAssertNtStatus( NtClose( handle ) );
        handle =  INVALID_HANDLE_VALUE;

        //
        // Now that everything worked change the in memory flags for 
        // this scan item
        //
        m_placeholder    = placeholder;
        m_gotPlaceholder = TRUE;
        WsbTrace( OLESTR("(CreatePlaceholder) Reparse CRC <%ls>\n"), 
                            WsbLonglongAsString( m_placeholder.dataStreamCRC ) );
                                                                                

    } WsbCatch(hr);

    //
    // if we opened the file we need to close it
    //
    if( INVALID_HANDLE_VALUE != handle) {
        NtClose( handle );
    }

    WsbTraceOut(OLESTR("CFsaScanItem::CreatePlaceholder"), OLESTR("hr = <%ls>, usn = <%ls>"), 
                WsbHrAsString(hr), WsbPtrToLonglongAsString(pUsn));
    return(hr);
}


HRESULT
CFsaScanItem::DeletePlaceholder(
    IN LONGLONG /*offset*/,
    IN LONGLONG /*size*/
    )  

/*++

Implements:

  IFsaScanItem::DeletePlaceholder().

--*/
{
    HRESULT         hr = S_OK;
    CWsbStringPtr   path;
    HANDLE          handle = INVALID_HANDLE_VALUE;
    ULONG           DesiredAccess;
    IO_STATUS_BLOCK IoStatusBlock;
    PREPARSE_DATA_BUFFER    pReparseBuffer;
    UCHAR                   ReparseBuffer[sizeof(REPARSE_DATA_BUFFER) + sizeof(RP_DATA) + 10];
    NTSTATUS        ntStatus;
    FILE_BASIC_INFORMATION  basicInformation;

    WsbTraceIn(OLESTR("CFsaScanItem::DeletePlaceholder"), OLESTR(""));
    //
    // Remove the Reparse Point off the file
    //
    try {

        //
        // Create the real file name we need to open, under the covers this
        // allocates the buffer since the path pointer is null
        //
        WsbAffirmHr( GetFullPathAndName( OLESTR("\\\\?\\"), NULL, &path, 0));
        //WsbAffirmHr( GetFullPathAndName( NULL, NULL, &path, 0));

        // Make sure it is read/write
        WsbAffirmHr( MakeReadWrite() );
        //
        // Open the file to remove the placeholder information in the reparse point
        //
        DesiredAccess = FILE_READ_DATA | FILE_WRITE_DATA | FILE_WRITE_ATTRIBUTES | FILE_READ_ATTRIBUTES ;
        WsbAffirmHr( OpenObject( path, 
                                 FILE_NON_DIRECTORY_FILE | FILE_NO_INTERMEDIATE_BUFFERING,
                                 DesiredAccess,
                                 EXCLUSIVE_FLAG,
                                 FILE_OPEN,
                                 &IoStatusBlock,
                                 &handle ) );

        //
        // The open worked, our handle should be valid but we check to be
        // safe and sure 
        //
        WsbAssertHandle( handle );
        
        //
        // Get the current attributes of the file and the times
        //
        WsbAssertNtStatus( NtQueryInformationFile( handle,
                                                    &IoStatusBlock,
                                                    (PVOID)&basicInformation,
                                                    sizeof( basicInformation ),
                                                    FileBasicInformation ) );
        
        //
        // Set the time flags so that when we close the handle the
        // time are not updated on the file and the FileAttributes 
        // indicate the file is offline
        //
        basicInformation.CreationTime.QuadPart = -1;
        basicInformation.LastAccessTime.QuadPart = -1;
        basicInformation.LastWriteTime.QuadPart = -1;
        basicInformation.ChangeTime.QuadPart = -1;
        basicInformation.FileAttributes &= ~BIT_FOR_TRUNCATED;
        basicInformation.FileAttributes |= FILE_ATTRIBUTE_NORMAL;  // Just in case result was zero (then no attributes would be set)

        WsbAssertNtStatus( NtSetInformationFile( handle,
                                                 &IoStatusBlock,
                                                 (PVOID)&basicInformation,
                                                 sizeof( basicInformation ),
                                                 FileBasicInformation ) );

        m_findData.dwFileAttributes &= ~BIT_FOR_TRUNCATED;
        m_originalAttributes &= ~BIT_FOR_TRUNCATED;
        
        //
        // Get the pointers setup correctly to this buffer because the 
        // type REPARSE_DATA_BUFFER actually doesn't have any space
        // allocated for the data and that is our own type, so get pointers
        // pointing into the real allocated space so we can use them
        //
        pReparseBuffer = (PREPARSE_DATA_BUFFER)ReparseBuffer;


        pReparseBuffer->ReparseTag        = IO_REPARSE_TAG_HSM ;
        pReparseBuffer->ReparseDataLength = 0 ;
        pReparseBuffer->Reserved          = 0 ;
        
        //
        // Do the work of deleting the Reparse Point
        //
        ntStatus = NtFsControlFile( handle,
                                  NULL,
                                  NULL,
                                  NULL,
                                  &IoStatusBlock,
                                  FSCTL_DELETE_REPARSE_POINT,
                                  pReparseBuffer,
                                  FIELD_OFFSET(REPARSE_DATA_BUFFER, GenericReparseBuffer),
                                  NULL,
                                  0 );
        
        //
        // Check the return code - verify this is the correct way to check
        //
        WsbAssertNtStatus( ntStatus );
 
        //
        // Close the file since we are done with it and set the handle to invalid
        //
        WsbAssertNtStatus( NtClose( handle ) );
        handle =  INVALID_HANDLE_VALUE;

        
        //
        // Now that everything worked change the in memory flags for 
        // this scan item
        //
        m_findData.dwFileAttributes &= ~BIT_FOR_RP;
        m_gotPlaceholder = FALSE;

    } WsbCatch(hr);

    //
    // if we opened the file we need to close it
    //
    if( INVALID_HANDLE_VALUE != handle) {
        NtClose( handle );
    }
    
    WsbTraceOut(OLESTR("CFsaScanItem::DeletePlaceholder"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT
CFsaScanItem::GetFromRPIndex(
    BOOL first
    )

/*

    Get file information from the Reparse Point Index

--*/
{
    HRESULT                 hr = S_OK;
    BOOLEAN                 bFirst;

    bFirst = (BOOLEAN)( first ? TRUE : FALSE );
    WsbTraceIn(OLESTR("CFsaScanItem::GetFromRPIndex"), OLESTR(""));

    try {
        HRESULT                        hrFindFileId;
        IO_STATUS_BLOCK                IoStatusBlock;
        IFsaScanItem *                 pScanItem;
        FILE_REPARSE_POINT_INFORMATION ReparsePointInfo;
        NTSTATUS                       Status;

        WsbAssert(0 != m_handleRPI, E_FAIL);

try_again:
        Status = NtQueryDirectoryFile(m_handleRPI,
                                   NULL,     //  Event 
                                   NULL,     //  ApcRoutine 
                                   NULL,     //  ApcContext 
                                   &IoStatusBlock,
                                   &ReparsePointInfo,
                                   sizeof(ReparsePointInfo),
                                   FileReparsePointInformation, 
                                   TRUE,     //  ReturnSingleEntry
                                   NULL,     //  FileName 
                                   bFirst );  //  RestartScan 
        if (Status != STATUS_SUCCESS) {
            WsbTrace(OLESTR("CFsaScanItem::GetFromRPIndex: CreateFileW failed, GetLastError = %ld\n"), 
                    GetLastError());
            WsbThrow(WSB_E_NOTFOUND);
        }

        //  Reset some items in case this isn't the first call to
        //  FindFileId
        if (INVALID_HANDLE_VALUE != m_handle) {
            FindClose(m_handle);
            m_handle = INVALID_HANDLE_VALUE;
        }
        if (TRUE == m_changedAttributes) {
            RestoreAttributes();
        }

        //  Find the file from the ID (not efficient or elegant, perhaps, but 
        //  the code is already there).
        pScanItem = this;
        hrFindFileId = m_pResource->FindFileId(ReparsePointInfo.FileReference,
                m_pSession, &pScanItem);

        //  If the FindFileId failed, we just skip that item and get the 
        //  next one.  This is to keep the scan from just stopping on this
        //  item.  FindFileId could fail because the file has been deleted
        //  already or the NT code could have a bug that prevents finding
        //  the file name from the ID when the ID ends with 0x5C.
        if (!SUCCEEDED(hrFindFileId)) {
            bFirst = FALSE;
            goto try_again;
        }
        WsbAffirmHr(pScanItem->Release());  // Get rid of extra ref. count

    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CFsaScanItem::GetFromRPIndex"), 
            OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaScanItem::CheckUsnJournalForChanges(
    LONGLONG StartUsn, 
    LONGLONG StopUsn,
    BOOL*    pChanged
)

/*

    Check the USN Journal for changes to the unnamed data stream for this
    file between the given USNs.

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CFsaScanItem::CheckUsnJournalForChanges"), OLESTR(""));

    *pChanged = FALSE;
    try {
        LONGLONG                fileId;
        CWsbStringPtr           volName;
        ULONGLONG               volUsnJournalId;

        WsbAffirm(StartUsn <= StopUsn, E_UNEXPECTED);
        WsbAffirmHr(m_pResource->GetPath(&volName, 0));
        WsbAffirmHr(m_pResource->GetUsnId(&volUsnJournalId));
        WsbAffirmHr(GetFileId(&fileId));
        WsbAffirmHr(WsbCheckUsnJournalForChanges(volName, volUsnJournalId, fileId, 
                StartUsn, StopUsn, pChanged));

    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CFsaScanItem::CheckUsnJournalForChanges"), 
            OLESTR("changed = %ls, hr = <%ls>"), WsbBoolAsString(*pChanged),
            WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaScanItem::FindFirstInRPIndex(
    IN IFsaResource* pResource,
    IN IHsmSession* pSession
    )

/*++

Implements:

  IFsaResource::FindFirstInRPIndex

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CFsaScanItem::FindFirstInRPIndex"), OLESTR(""));

    try {
        CWsbStringPtr     path;

        WsbAssert(0 != pResource, E_POINTER);

        // Store off some of the scan information.
        m_pResource = pResource;
        m_pSession = pSession;

        //  Generate the Reparse Point Index directory name for this volume
        WsbAffirmHr(pResource->GetPath(&path, 0));
        WsbAffirmHr(path.Prepend("\\\\?\\"));
        WsbAffirmHr(path.Append("$Extend\\$Reparse:$R:$INDEX_ALLOCATION"));

        WsbTrace(OLESTR("CFsaScanItem::FindFirstInRPIndex: path = <%ls>\n"),
            static_cast<WCHAR*>(path));

        //  Open the Reparse Point Index
        m_handleRPI = CreateFileW(static_cast<WCHAR*>(path),
                        GENERIC_READ,
                        FILE_SHARE_READ, 
                        NULL,
                        OPEN_EXISTING,
                        FILE_FLAG_BACKUP_SEMANTICS | SECURITY_IMPERSONATION,
                        NULL );
        if (INVALID_HANDLE_VALUE == m_handleRPI) {
            WsbTrace(OLESTR("CFsaScanItem::FindFirstInRPIndex: CreateFileW failed, GetLastError = %ld\n"), 
                    GetLastError());
            WsbThrow(WSB_E_NOTFOUND);
        }

        //  Get file information
        WsbAffirmHr(GetFromRPIndex(TRUE));

    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CFsaScanItem::FindFirstInRPIndex"), 
            OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaScanItem::FindFirstPlaceholder(
    IN OUT LONGLONG* pOffset,
    IN OUT LONGLONG* pSize,
    IN OUT FSA_PLACEHOLDER* pPlaceholder
    )
/*++

Implements:

  IFsaScanItem::FindFirstPlaceholder().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CFsaScanItem::FindFirstPlaceholder"), OLESTR(""));
    try {

        WsbAssert(0 != pOffset, E_POINTER);
        WsbAssert(0 != pSize, E_POINTER);
        WsbAssert(0 != pPlaceholder, E_POINTER);

        // Until these routines get rewritten, assume that the first placeholder is the one for the
        // who file that is returned by GetPlaceholder().
        *pOffset = 0;
        WsbAffirmHr(GetLogicalSize(pSize));

        // The code above assumes that a WSB_E_NOTFOUND error will be returned if there is no
        // reparse point.
        try {
            WsbAffirmHr(GetPlaceholder(*pOffset, *pSize, pPlaceholder));
        } WsbCatchAndDo(hr, if (E_UNEXPECTED == hr) {hr = WSB_E_NOTFOUND;});
        
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaScanItem::FindFirstPlaceholder"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT
CFsaScanItem::FindNextInRPIndex(
    void
    )

/*++

Implements:

  IFsaResource::FindNextInRPIndex

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CFsaScanItem::FindNextInRPIndex"), OLESTR(""));

    try {

        WsbAssert(0 != m_handleRPI, E_FAIL);

        //  Get file information
        WsbAffirmHr(GetFromRPIndex(FALSE));

    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CFsaScanItem::FindNextInRPIndex"), 
            OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaScanItem::FindNextPlaceholder(
    IN OUT LONGLONG* pOffset,
    IN OUT LONGLONG* pSize,
    IN OUT FSA_PLACEHOLDER* pPlaceholder
    )
/*++

Implements:

  IFsaScanItem::FindNextPlaceholder().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CFsaScanItem::FindNext"), OLESTR(""));
    try {

        WsbAssert(0 != pOffset, E_POINTER);
        WsbAssert(0 != pSize, E_POINTER);
        WsbAssert(0 != pPlaceholder, E_POINTER);

        // Until these routines get rewritten, assume there is only one placeholder.
        hr = WSB_E_NOTFOUND;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaScanItem::FindNextPlaceholder"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT
CFsaScanItem::GetFileId(
    OUT LONGLONG* pFileId
    )

/*++

Implements:

  IFsaScanItem::GetFileId().

--*/
{
    HANDLE          handle = INVALID_HANDLE_VALUE;
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CFsaScanItem::GetFileId"), OLESTR(""));

    try {
        ULONG                     DesiredAccess;
        FILE_INTERNAL_INFORMATION iInfo;
        IO_STATUS_BLOCK           IoStatusBlock;
        CWsbStringPtr             path;

        WsbAssert(0 != pFileId, E_POINTER);

        //
        // Create the real file name we need to open, under the covers this
        // allocates the buffer since the path pointer is null
        //
        WsbAffirmHr( GetFullPathAndName( OLESTR("\\\\?\\"), NULL, &path, 0));
        //WsbAffirmHr( GetFullPathAndName( NULL, NULL, &path, 0));
        WsbTrace(OLESTR("CFsaScanItem::GetFileId, full Path = <%ls>\n"),
                    static_cast<WCHAR*>(path));

        //
        // Open the file
        //
        DesiredAccess = FILE_READ_ATTRIBUTES ;
        WsbAffirmHr( OpenObject( path, 
                                 FILE_NON_DIRECTORY_FILE,
                                 DesiredAccess,
                                 SHARE_FLAGS,
                                 FILE_OPEN,
                                 &IoStatusBlock,
                                 &handle ) );

        //
        // The open worked, our handle should be valid but we check to be
        // safe and sure 
        //
        WsbAssertHandle( handle );

        //  Get the internal information
        WsbAssertNtStatus( NtQueryInformationFile( handle,
                                                &IoStatusBlock,
                                                &iInfo,
                                                sizeof(FILE_INTERNAL_INFORMATION),
                                                FileInternalInformation ));

        //  Get the file id
        *pFileId = iInfo.IndexNumber.QuadPart;
 
        //
        // Close the file since we are done with it and set the handle to invalid
        //
        WsbAssertNtStatus( NtClose( handle ) );
        handle =  INVALID_HANDLE_VALUE;

    } WsbCatchAndDo(hr,
        WsbTrace(OLESTR("CFsaScanItem::GetFileId, GetLastError = %lx\n"),
            GetLastError());
    );

    //
    // if we opened the file we need to close it
    //
    if( INVALID_HANDLE_VALUE != handle) {
        NtClose( handle );
    }
    WsbTraceOut(OLESTR("CFsaScanItem::GetFileId"), OLESTR("Hr = <%ls>, FileId = %I64x"),
            WsbHrAsString(hr), *pFileId);

    return(hr);
}


HRESULT
CFsaScanItem::GetFileUsn(
    OUT LONGLONG* pFileUsn
    )

/*++

Routine Description:

    Get the current USN Journal number for this file.

Arguments:

    pFileUsn - Pointer to File USN to be returned.

Return Value:

    S_OK   - success

--*/
{
    HANDLE          handle = INVALID_HANDLE_VALUE;
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CFsaScanItem::GetFileUsn"), OLESTR(""));

    try {
        ULONG                     DesiredAccess;
        IO_STATUS_BLOCK           IoStatusBlock;
        CWsbStringPtr             path;

        WsbAssert(pFileUsn, E_POINTER);

        //
        // Create the real file name we need to open, under the covers this
        // allocates the buffer since the path pointer is null
        //
        WsbAffirmHr( GetFullPathAndName( OLESTR("\\\\?\\"), NULL, &path, 0));
        WsbTrace(OLESTR("CFsaScanItem::GetFileUsn, full Path = <%ls>\n"),
                    static_cast<WCHAR*>(path));

        //
        // Open the file
        //
        DesiredAccess = FILE_READ_ATTRIBUTES ;
        WsbAffirmHr( OpenObject( path, 
                                 FILE_NON_DIRECTORY_FILE | FILE_NO_INTERMEDIATE_BUFFERING,
                                 DesiredAccess,
                                 SHARE_FLAGS,
                                 FILE_OPEN,
                                 &IoStatusBlock,
                                 &handle ) );

        //
        // The open worked, our handle should be valid but we check to be
        // safe and sure 
        //
        WsbAssertHandle( handle );

        //  Get the internal information
        WsbAffirmHr(WsbGetUsnFromFileHandle(handle, FALSE, pFileUsn));
 
        //
        // Close the file since we are done with it and set the handle to invalid
        //
        WsbAssertNtStatus( NtClose( handle ) );
        handle =  INVALID_HANDLE_VALUE;

    } WsbCatchAndDo(hr,
        WsbTrace(OLESTR("CFsaScanItem::GetFileUsn, GetLastError = %lx\n"),
            GetLastError());
    );

    //
    // if we opened the file we need to close it
    //
    if( INVALID_HANDLE_VALUE != handle) {
        NtClose( handle );
    }
    WsbTraceOut(OLESTR("CFsaScanItem::GetFileUsn"), OLESTR("Hr = <%ls>, FileUsn = %I64d"),
            WsbHrAsString(hr), *pFileUsn);

    return(hr);
}


HRESULT
CFsaScanItem::GetPlaceholder(
    IN LONGLONG offset,
    IN LONGLONG size,
    OUT FSA_PLACEHOLDER* pPlaceholder
    )
/*++

Implements:

  IFsaScanItem::GetPlaceholder().

--*/
{
    WsbTraceIn(OLESTR("CFsaScanItem::GetPlaceholder"), OLESTR(""));
    HRESULT         hr = S_OK;

    //
    // If we already have the placeholder information just return it
    //
    try {

        //
        // Validate the file is managed. If it is the affirm will succeed.
        // If the file is not managed then we can only tell the caller the
        // problem.
        //
        WsbAffirmHr(hr = IsManaged(offset, size));
        
        //
        // Make sure the file is managed - will return S_OK
        //
        WsbAffirm( S_OK == hr, FSA_E_NOTMANAGED );
        
        //
        // Assert that the internal flag for the data is set, should
        // always be on if the hr was S_OK above
        //
        WsbAssert( m_gotPlaceholder, E_UNEXPECTED );
        
        //
        // Copy the data to the callers structure
        //
        *pPlaceholder = m_placeholder;
        
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaScanItem::GetPlaceholder"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT
CFsaScanItem::HasExtendedAttributes(
    void
    )

/*++

Implements:

  IFsaScanItem::HasExtendedAttributes().

--*/
{
    HRESULT                     hr = S_FALSE;
    HANDLE                      handle = INVALID_HANDLE_VALUE;
    CWsbStringPtr               path;
    ULONG                       desiredAccess;
    IO_STATUS_BLOCK             ioStatusBlock;
    FILE_EA_INFORMATION         eaInformation;
 
    try {

        // Create the real file name we need to open, under the covers this
        // allocates the buffer since the path pointer is null
        WsbAffirmHr(GetFullPathAndName(OLESTR("\\\\?\\"), NULL, &path, 0));
        //WsbAffirmHr(GetFullPathAndName(NULL, NULL, &path, 0));
    
        // Open the file to get the attributes
        desiredAccess = FILE_READ_ATTRIBUTES;
        WsbAffirmHr(OpenObject(path, FILE_NON_DIRECTORY_FILE | FILE_NO_INTERMEDIATE_BUFFERING, desiredAccess, SHARE_FLAGS,
                               FILE_OPEN, &ioStatusBlock, &handle));

        // The open worked, our handle should be valid but we check to be
        // safe and sure 
        WsbAssertHandle(handle);
    
        // Get the current attributes of the file.
        WsbAssertNtStatus(NtQueryInformationFile(handle, &ioStatusBlock, (VOID*) &eaInformation, sizeof(eaInformation ), FileEaInformation));
                                                    
        // Close the file since we are done with it and set the handle to invalid
        WsbAssertNtStatus(NtClose(handle));
        handle =  INVALID_HANDLE_VALUE;

        // Are there any EAs present?
        if (eaInformation.EaSize != 0) {
            hr = S_OK;
        }

    } WsbCatch(hr);
    
    // if we opened the file we need to close it
    if (INVALID_HANDLE_VALUE != handle) {
        NtClose(handle);
    }

    return(hr);
}


HRESULT
CFsaScanItem::IsALink(
    void
    )

/*++

Implements:

  IFsaScanItem::IsALink().

--*/
{
    HRESULT         hr = S_FALSE;
    LONGLONG        size;

    //
    // The file is a link if it is a reparse point and it is not our 
    // type. 
    //

    WsbAffirmHr(GetLogicalSize(&size));
    if (((m_findData.dwFileAttributes & BIT_FOR_RP) != 0) &&
        (!(IsManaged(0, size) == S_OK))) {

           hr = S_OK;
    } 

    return(hr);
}


HRESULT
CFsaScanItem::IsManaged(
    IN LONGLONG /*offset*/,
    IN LONGLONG /*size*/
    )

/*++

Implements:

  IFsaScanItem::IsManaged().

--*/
{
    HRESULT         hr = S_FALSE;
    CWsbStringPtr   path;
    HANDLE          handle = INVALID_HANDLE_VALUE;
    IO_STATUS_BLOCK IoStatusBlock;
    UCHAR           ReparseBuffer[MAXIMUM_REPARSE_DATA_BUFFER_SIZE];
    NTSTATUS        ntStatus;
    ULONG           DesiredAccess;
    BOOL            actualOfflineStatus = FALSE;
    BOOL            readReparseData = FALSE;      // Used to know if we got an error reading the reparse data
    BOOL            changeOfflineStatus = FALSE;
    FILE_BASIC_INFORMATION basicInformation;
    CWsbStringPtr           volName;
    HRESULT         saveHr;


    WsbTraceIn(OLESTR("CFsaScanItem::IsManaged"), OLESTR(""));
    //
    // If the file has a reparse point then we need to get the information
    // so we can tell if it is our type. Whether it is premigrated or
    // truncate is not for this function to care, if it is either then
    // the return is S_OK.
    //
    
    //
    // If we already know we manage this file and have the placeholder
    // information then tell caller
    //
    if ( m_gotPlaceholder) {
        hr = S_OK;
        actualOfflineStatus = m_placeholder.isTruncated;
        readReparseData = TRUE;

    //
    // We don't know the answer so lets first check the reparse point bit.
    // If it is not set then this is not managed by us
    //
    } else if ( (m_findData.dwFileAttributes & BIT_FOR_RP) == 0) {
        hr = S_FALSE;
        actualOfflineStatus = FALSE;
        readReparseData = TRUE;  
        
    //
    // So we know it has a reparse point but do not know what kind so 
    // lets get the data and fill in our global if we need
    //
    } else {
        
        try {
            //
            // If the reparse point is not our type we get out now.  This avoids a problem with SIS keeping 
            // the backing file open when one of their link files is open.  Once we open the link file the backing file is 
            // opened by their filter and held open.  If we attempt to migrate it later we get an error because it is open exclusive.
            // This bit of code prevents us from being the one to trigger this condition - there is nothing we can do if some other
            // process caused it to happen.
            //

            if (m_findData.dwReserved0 != IO_REPARSE_TAG_HSM) {
                readReparseData = TRUE;
                WsbThrow(S_FALSE);
            }

            //
            // Create the real file name we need to open, under the 
            // covers this allocates the buffer since the path pointer 
            // is null
            //
            WsbAffirmHr( GetFullPathAndName( OLESTR("\\\\?\\"), NULL, &path, 0));
            //WsbAffirmHr( GetFullPathAndName( NULL, NULL, &path, 0));
        
            //
            // Open the file to read the placeholder information in the reparse point
            //
            //DesiredAccess = FILE_READ_DATA | FILE_READ_ATTRIBUTES ;
            DesiredAccess = FILE_READ_ATTRIBUTES ;
            
            WsbAffirmHr( OpenObject( path, 
                                    FILE_NON_DIRECTORY_FILE | FILE_NO_INTERMEDIATE_BUFFERING,
                                    DesiredAccess,
                                    SHARE_FLAGS,
                                    FILE_OPEN,
                                    &IoStatusBlock,
                                    &handle ) );

            //
            // The open worked, our handle should be valid but we check to be
            // safe and sure 
            //
            WsbAssertHandle( handle );
        
            //
            // Read the placeholder information
            //
            ntStatus = NtFsControlFile( handle,
                                    NULL,
                                    NULL,
                                    NULL,
                                    &IoStatusBlock,
                                    FSCTL_GET_REPARSE_POINT,
                                    NULL,
                                    0,
                                    &ReparseBuffer,
                                    sizeof( ReparseBuffer ) );


            //
            // Verify that the get really worked. NOTE: If the reparse
            // point is not there, it could be that it has been deleted since
            // we last got the bits. We should just indicate that the file
            // is not managed.
            //
            if (STATUS_NOT_A_REPARSE_POINT == ntStatus) {
                readReparseData = TRUE;
                WsbThrow(S_FALSE);
            }
            WsbAssertNtStatus( ntStatus );
 
            //
            // Close the file since we are done with it
            //
            WsbAssertNtStatus( NtClose( handle ) );
            handle =  INVALID_HANDLE_VALUE;
        
            readReparseData = TRUE;

            //
            // Get the pointers setup correctly to this buffer because the 
            // type REPARSE_DATA_BUFFER actually doesn't have any space
            // allocated for the data and that is our own type, so get pointers
            // pointing into the real allocated space so we can use them
            //
            WsbAffirmHrOk( CopyRPToPlaceholder( (PREPARSE_DATA_BUFFER)ReparseBuffer, &m_placeholder ) );

            actualOfflineStatus = m_placeholder.isTruncated;

            //
            // Set flag indicating placeholder found and information in memory
            //
            m_gotPlaceholder = TRUE;
            hr = S_OK;


        } WsbCatch(hr);

        //
        // if we opened the file we need to close it
        //
        if( INVALID_HANDLE_VALUE != handle) {
            NtClose( handle );
        }
    }

    saveHr = hr;

    // Check the actual offline status against the offline bit and fix it if necessary.
    if (readReparseData) {   // If there was no error getting the reparse data

       WsbTrace(OLESTR("CFsaScanItem::IsManaged: Checking offline status %x - actual = %x\n"),
                    m_findData.dwFileAttributes & BIT_FOR_TRUNCATED, actualOfflineStatus );

       switch (actualOfflineStatus) {
           case TRUE:
              if (!(m_findData.dwFileAttributes & BIT_FOR_TRUNCATED)) {
                  // Offline bit is not set and should be - set it.
                  m_findData.dwFileAttributes |= BIT_FOR_TRUNCATED;
                  m_originalAttributes |= BIT_FOR_TRUNCATED;    // Just in case we have changed to read/write;
                  changeOfflineStatus = TRUE;
              } 
              break;
           case FALSE:
              if (m_findData.dwFileAttributes & BIT_FOR_TRUNCATED) {
                  // Offline bit is set and should not be - clear it.
                  m_findData.dwFileAttributes &= ~BIT_FOR_TRUNCATED;
                  m_originalAttributes &= ~BIT_FOR_TRUNCATED;    // Just in case we have changed to read/write;
                  changeOfflineStatus = TRUE;
              } 
              break;
       }

       if (changeOfflineStatus) {
          // Set the new attribute 
          WsbTrace(OLESTR("CFsaScanItem::IsManaged: Changing offline status %x - actual = %x\n"),
                    m_findData.dwFileAttributes & BIT_FOR_TRUNCATED, actualOfflineStatus );
   
          try {
              //
              // Create the real file name we need to open, under the 
              // covers this allocates the buffer since the path pointer 
              // is null
              //
              WsbAffirmHr( GetFullPathAndName( OLESTR("\\\\?\\"), NULL, &path, 0));
          
              //
              // Open the file to set attributes
              //
              DesiredAccess = FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES;
              
              WsbAffirmHr( OpenObject( path, 
                                      FILE_NON_DIRECTORY_FILE | FILE_NO_INTERMEDIATE_BUFFERING,
                                      DesiredAccess,
                                      SHARE_FLAGS,
                                      FILE_OPEN,
                                      &IoStatusBlock,
                                      &handle ) );
    
              //
              // The open worked, our handle should be valid but we check to be
              // safe and sure 
              //
              WsbAssertHandle( handle );
          
              WsbAffirmHr(m_pResource->GetPath(&volName, 0));
              WsbAffirmHr(WsbMarkUsnSource(handle, volName));
   
              // Set the time flags so that when we close the handle the
              // time are not updated on the file and the FileAttributes 
              basicInformation.CreationTime.QuadPart = -1;
              basicInformation.LastAccessTime.QuadPart = -1;
              basicInformation.LastWriteTime.QuadPart = -1;
              basicInformation.ChangeTime.QuadPart = -1;
              basicInformation.FileAttributes = m_findData.dwFileAttributes;
              
              WsbAffirmNtStatus(NtSetInformationFile(handle, &IoStatusBlock, (PVOID)&basicInformation, sizeof(basicInformation), FileBasicInformation));

              //
              // Close the file since we are done with it
              //
              WsbAssertNtStatus( NtClose( handle ) );
              handle =  INVALID_HANDLE_VALUE;
    
    
          } WsbCatch(hr);
    
          //
          // if we opened the file we need to close it
          //
          if( INVALID_HANDLE_VALUE != handle) {
              NtClose( handle );
          }
       }
    }

    hr = saveHr;
    WsbTraceOut(OLESTR("CFsaScanItem::IsManaged"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT
CFsaScanItem::IsPremigrated(
    IN LONGLONG offset,
    IN LONGLONG size
    )

/*++

Implements:

  IFsaScanItem::IsPremigrated().

--*/
{
    HRESULT         hr = S_FALSE;
    HRESULT         hrTest = S_FALSE;

    WsbTraceIn(OLESTR("CFsaScanItem::IsPremigrated"), OLESTR(""));
    // We really need to look at the placeholder information to figure
    // this out (is offline, and is out type of HSM.

    //
    // If the file is NOT truncated AND is a reparse point and is a 
    // managed one then the file is a premigrated file
    //
//  if ( !(m_findData.dwFileAttributes & BIT_FOR_TRUNCATED) && 
//         m_findData.dwFileAttributes & BIT_FOR_RP         &&
//         IsManaged() == S_OK) {

    try  {
        
        if ( m_findData.dwFileAttributes & BIT_FOR_RP )  {
            WsbAffirmHr(hrTest = IsManaged(offset, size));
            if ((S_OK == hrTest) &&
                ( !m_placeholder.isTruncated )) {
                hr = S_OK;
            }
        }

    } WsbCatch (hr);

    WsbTraceOut(OLESTR("CFsaScanItem::IsPremigrated"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT
CFsaScanItem::IsTruncated(
    IN LONGLONG offset,
    IN LONGLONG size
    )

/*++

Implements:

  IFsaScanItem::IsTruncated().

--*/
{
    HRESULT         hr = S_FALSE;
    HRESULT         hrTest = S_FALSE;

    WsbTraceIn(OLESTR("CFsaScanItem::IsTruncated"), OLESTR(""));
    // 
    // If the bit is on that indicates we have truncated the file AND
    // the file is a reparse point AND the reparse point is one of
    // our types (i.e. it really is our information stuffed away in
    // there the it really is a truncated file
    //
//  if ( // ???? m_findData.dwFileAttributes & BIT_FOR_TRUNCATED && 
//         m_findData.dwFileAttributes & BIT_FOR_RP        &&
//         IsManaged() == S_OK && RP_FILE_IS_TRUNCATED( m_placeholder.bitFlags ) ) {
    try  {
        
        if ( m_findData.dwFileAttributes & BIT_FOR_RP )  {
            WsbAffirmHr(hrTest = IsManaged(offset, size));
            if ((S_OK == hrTest) &&
                ( m_placeholder.isTruncated )) {
                hr = S_OK;
            }
        }

    } WsbCatch (hr);

    WsbTraceOut(OLESTR("CFsaScanItem::IsTruncated"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT
CFsaScanItem::GetVersionId(
    LONGLONG *fileVersionId
    )  

/*++

Implements:

  IFsaScanItem::GetVersionId().

--*/
{
    HRESULT         hr = E_FAIL;
    HANDLE          handle = INVALID_HANDLE_VALUE;
    CWsbStringPtr   path;
    ULONG           DesiredAccess;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_BASIC_INFORMATION       basicInformation;
 
    try {
        //
        // Create the real file name we need to open, under the covers this
        // allocates the buffer since the path pointer is null
        //
        WsbAffirmHr( GetFullPathAndName(  OLESTR("\\\\?\\"), NULL, &path, 0));
        //WsbAffirmHr( GetFullPathAndName(  NULL, NULL, &path, 0));
    
        //
        // Open the file to get the attributes
        //
        DesiredAccess = FILE_READ_ATTRIBUTES ;
        WsbAffirmHr( OpenObject( path, 
                                FILE_NON_DIRECTORY_FILE | FILE_NO_INTERMEDIATE_BUFFERING,
                                DesiredAccess,
                                SHARE_FLAGS,
                                FILE_OPEN,
                                &IoStatusBlock,
                                &handle ) );
        //
        // The open worked, our handle should be valid but we check to be
        // safe and sure 
        //
        WsbAssertHandle( handle );
    
        //
        // Get the current attributes of the file and the times
        //
        WsbAssertNtStatus( NtQueryInformationFile( handle,
                                                    &IoStatusBlock,
                                                    (PVOID)&basicInformation,
                                                    sizeof( basicInformation ),
                                                    FileBasicInformation ) );
                                                    
        //
        // Close the file since we are done with it and set the handle to invalid
        //
        WsbAssertNtStatus( NtClose( handle ) );
        handle =  INVALID_HANDLE_VALUE;

        *fileVersionId = basicInformation.LastWriteTime.QuadPart;
        hr = S_OK;
    } WsbCatch( hr );
    
    //
    // if we opened the file we need to close it
    //
    if( INVALID_HANDLE_VALUE != handle) {
        NtClose( handle );
    }

    return( hr );
}


HRESULT
CFsaScanItem::MakeReadWrite(
    )  

/*++

Routine Description:

    Make the file attributes read/write if they aren't already.

Arguments:

    pUsn - Pointer to File USN to check (if != 0) and to be returned after the change.

Return Value:

    S_OK   - success

--*/
{
    HRESULT                 hr = S_OK;
    CWsbStringPtr           path;
    IO_STATUS_BLOCK         IoStatusBlock;
    HANDLE                  handle = INVALID_HANDLE_VALUE;
    FILE_BASIC_INFORMATION  basicInformation;
 
    if (S_OK == IsReadOnly()) {
    
        try {
        
            // NOTE: MakeReadOnly(), IsReadOnly(), and RestoreAttributes() seem like dangerous implementations, since
            // the used cached information and reset all the attirbutes. It is also assuming that the
            // application wants the file reset to read only after FindNext() or the destructor. This
            // may not be true for a general purpose application. Unfortunately, it seems to risky to
            // try to change this implementation now.
        
            // Create the real file name we need to open, under the covers this
            // allocates the buffer since the path pointer is null
            WsbAffirmHr(GetFullPathAndName(OLESTR("\\\\?\\"), NULL, &path, 0));
            
            // Open the file.   
            WsbAffirmHr(OpenObject(path, FILE_NON_DIRECTORY_FILE, FILE_WRITE_ATTRIBUTES | FILE_READ_ATTRIBUTES, EXCLUSIVE_FLAG, FILE_OPEN, &IoStatusBlock, &handle));

            // The open worked, our handle should be valid but we check to be
            // safe and sure 
            WsbAffirmHandle(handle);
        
            // Get the current attributes of the file and the times
            WsbAffirmNtStatus(NtQueryInformationFile(handle, &IoStatusBlock, (PVOID)&basicInformation, sizeof(basicInformation), FileBasicInformation));
        
            // Make sure it is still read only.
            if ((basicInformation.FileAttributes & FILE_ATTRIBUTE_READONLY) != 0) {
            
                m_originalAttributes = basicInformation.FileAttributes;
                
                // Set the time flags so that when we close the handle the
                // time are not updated on the file and the FileAttributes 
                basicInformation.CreationTime.QuadPart = -1;
                basicInformation.LastAccessTime.QuadPart = -1;
                basicInformation.LastWriteTime.QuadPart = -1;
                basicInformation.ChangeTime.QuadPart = -1;
                basicInformation.FileAttributes &= ~FILE_ATTRIBUTE_READONLY;
                basicInformation.FileAttributes |= FILE_ATTRIBUTE_NORMAL;  // Just in case result was zero (then no attributes would be set)
                
                WsbAffirmNtStatus(NtSetInformationFile(handle, &IoStatusBlock, (PVOID)&basicInformation, sizeof(basicInformation), FileBasicInformation));
                
                m_changedAttributes = TRUE;
            }
            
            // Close the file
            NtClose(handle);
            handle = INVALID_HANDLE_VALUE;
            
        } WsbCatch(hr);

    
        // Close the file for sure
        if (INVALID_HANDLE_VALUE != handle) {
            NtClose(handle);
        }
    }   
    
    return(hr);
}



HRESULT
CFsaScanItem::PrepareForManage(
    IN LONGLONG offset,
    IN LONGLONG size
    )  

/*++

Implements:

  IFsaScanItem::PrepareForManage().

--*/
{
    UNREFERENCED_PARAMETER(offset);
    UNREFERENCED_PARAMETER(size);
    
    return S_OK;
}



HRESULT
CFsaScanItem::RestoreAttributes(
    )  

/*++

Implements:

  IFsaScanItem::RestoreAttributes

--*/
{
    HRESULT                 hr = E_FAIL;
    CWsbStringPtr           path;
    IO_STATUS_BLOCK         IoStatusBlock;
    HANDLE                  handle = INVALID_HANDLE_VALUE;
    FILE_BASIC_INFORMATION  basicInformation;
 
    try {
    
        // NOTE: MakeReadOnly(), IsReadOnly(), and RestoreAttributes() seem like dangerous implementations, since
        // the used cached information and reset all the attirbutes. It is also assuming that the
        // application wants the file reset to read only after FindNext() or the destructor. This
        // may not be true for a general purpose application. Unfortunately, it seems to risky to
        // try to change this implementation now.
        
    
        // Create the real file name we need to open, under the covers this
        // allocates the buffer since the path pointer is null
        WsbTrace(OLESTR("CFsaScanItem::RestoreAttributes - Restoring attributes to %x"), m_originalAttributes);
        WsbAffirmHr(GetFullPathAndName(  OLESTR("\\\\?\\"), NULL, &path, 0));
        
        
        // Open the file.   
        WsbAffirmHr(OpenObject(path, FILE_NON_DIRECTORY_FILE, FILE_WRITE_ATTRIBUTES | FILE_READ_ATTRIBUTES, EXCLUSIVE_FLAG, FILE_OPEN, &IoStatusBlock, &handle));

        // The open worked, our handle should be valid but we check to be
        // safe and sure 
        WsbAffirmHandle(handle);
    
        // Get the current attributes of the file and the times
        WsbAffirmNtStatus(NtQueryInformationFile(handle, &IoStatusBlock, (PVOID)&basicInformation, sizeof(basicInformation), FileBasicInformation));
    
        // Set the time flags so that when we close the handle the
        // time are not updated on the file and the FileAttributes 
        basicInformation.CreationTime.QuadPart = -1;
        basicInformation.LastAccessTime.QuadPart = -1;
        basicInformation.LastWriteTime.QuadPart = -1;
        basicInformation.ChangeTime.QuadPart = -1;
        basicInformation.FileAttributes = m_originalAttributes;
        
        WsbAffirmNtStatus(NtSetInformationFile(handle, &IoStatusBlock, (PVOID)&basicInformation, sizeof(basicInformation), FileBasicInformation));
            
        
        // Close the file
        NtClose(handle);
        handle = INVALID_HANDLE_VALUE;
        
        m_changedAttributes = FALSE;
                
    } WsbCatch(hr);
    
    // Close the file for sure
    if (INVALID_HANDLE_VALUE != handle) {
        NtClose(handle);
    }
        
    return(hr);
}


HRESULT
CFsaScanItem::Truncate(
    IN LONGLONG offset,
    IN LONGLONG size
    )  

/*++

Implements:

  IFsaScanItem::Truncate().

--*/
{
    HRESULT         hr = S_OK;
    BOOL            fileIsTruncated = FALSE;
    LONGLONG        usn = 0;

    WsbTraceIn(OLESTR("CFsaScanItem::Truncate"), OLESTR(""));
    try {

        // call the engine
        if (IsManaged(offset, size) == S_OK) {
            WsbAffirmHr(m_pResource->ValidateForTruncate((IFsaScanItem*) this, offset, size, usn));
        }    

    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CFsaScanItem::Truncate"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT
CFsaScanItem::TruncateValidated(
    IN LONGLONG offset,
    IN LONGLONG size
    )  

/*++

Implements:

  IFsaScanItem::TruncateValidated().

--*/
{
    HRESULT         hr = S_OK;
    HRESULT         truncateHr = S_OK;

    WsbTraceIn(OLESTR("CFsaScanItem::TruncateValidated"), OLESTR(""));
    try {
        IFsaScanItem* pMe = this;

        truncateHr = TruncateInternal(offset, size);

        //
        // Note: Must check for S_OK since TruncateInternal may return FSA_E_ITEMCHANGED or FSA_E_ITEMINUSE
        // Both are "Success hr", but imply no truncation was done
        //
        if (S_OK == truncateHr) {
            WsbAffirmHr(m_pResource->RemovePremigrated(pMe, offset, size));
            WsbAffirmHr(m_pResource->AddTruncated(pMe, offset, size));
        }
    } WsbCatch(hr);

    // The important hr to return to the caller is the actual result of the truncation
    hr = truncateHr;
    
    WsbTraceOut(OLESTR("CFsaScanItem::TruncateValidated"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}




HRESULT
CFsaScanItem::TruncateInternal(
    IN LONGLONG offset,
    IN LONGLONG size
    )  

/*++

Implements:

  IFsaScanItem::TruncateInternal().

--*/
{
    HRESULT         hr = E_FAIL;
    CWsbStringPtr   path;
    ULONG           DesiredAccess;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS        ntStatus;
    FILE_END_OF_FILE_INFORMATION sizeInformation;
    FILE_BASIC_INFORMATION       basicInformation;
    PREPARSE_DATA_BUFFER    pReparseBuffer;
    UCHAR                   ReparseBuffer[sizeof(REPARSE_DATA_BUFFER) + sizeof(RP_DATA) + 10];
    CWsbStringPtr           fileName;
    CWsbStringPtr           jobName;
    LONGLONG                fileVersionId;
    ULONG                   i = 0;
    CWsbStringPtr           volName;


    WsbTraceIn(OLESTR("CFsaScanItem::TruncateInternal"), OLESTR(""));

// Putting these statistics in the registry is probably not the best
// place for them, but it's the easiest solution for now
#define TEMPORARY_TRUNCATE_STATISTICS 1
#if defined(TEMPORARY_TRUNCATE_STATISTICS)
    //  Try to increment the truncate-attempt count in the registry
    WsbIncRegistryValueDWORD(NULL, FSA_REGISTRY_PARMS,
            OLESTR("TruncateCalls"));
#endif
    
    // Get strings for tracing and error logging (ignore errors?!)
    GetFullPathAndName( 0, 0, &fileName, 0);
    m_pSession->GetName(&jobName, 0);

    m_handleVerify = INVALID_HANDLE_VALUE;
    
    try {
        LONGLONG    fileUsn1 = 0, fileUsn2 = 0;
        
        // If the file is not migrated, then we can't truncate it
        if (S_OK != IsPremigrated(offset, size)) {
            if (S_OK != IsManaged(offset, size)) {
                hr = FSA_E_NOTMANAGED;
                WsbLogEvent(FSA_MESSAGE_TRUNCSKIPPED_ISNOTMANAGED, 0, NULL,  
                        (OLECHAR*) jobName, WsbAbbreviatePath(fileName, 120), 
                        WsbHrAsString(hr), NULL);
                WsbThrow(hr);
            } else {
                //
                // Do not bother to log an event here as this should only 
                // happen if someone uses rstest or some other program 
                // to truncate a file that is already truncated.
                WsbThrow(FSA_E_FILE_ALREADY_MANAGED);
            }
        }

        WsbAssert( m_gotPlaceholder, E_UNEXPECTED );
        
        //
        // Setup the reparse point data with that which was on the file
        // with the bit in the data indicating it is truncated
        //
        pReparseBuffer = (PREPARSE_DATA_BUFFER)ReparseBuffer;
        WsbAffirmHr( CopyPlaceholderToRP( &m_placeholder, pReparseBuffer, TRUE ) );

        //
        // Create the real file name we need to open, under the covers this
        // allocates the buffer since the path pointer is null
        //
        WsbAffirmHr( GetFullPathAndName(  OLESTR("\\\\?\\"), NULL, &path, 0));

        //
        // Open the file exclusively for read-only so we can get the usn before and  after
        // making the file R/W, without letting anybody to make a "real" change in the middle
        //
        DesiredAccess = FILE_READ_DATA | FILE_READ_ATTRIBUTES;
        WsbAffirmHr( OpenObject( path, 
                                FILE_NON_DIRECTORY_FILE,
                                DesiredAccess,
                                EXCLUSIVE_FLAG,
                                FILE_OPEN,
                                &IoStatusBlock,
                                &m_handleVerify ) );

        WsbAssertHandle( m_handleVerify );

        //
        // Get usn before making R/W
        // This usn is used to compare with the usn which we kept in the premigrated list.
        // MakeReadWrite may chnage the usn so we need to get it before 
        //
        if (S_OK != WsbGetUsnFromFileHandle(m_handleVerify, FALSE, &fileUsn1))  {
            fileUsn1 = 0;
        }

        // Make sure it is read/write
        WsbAffirmHr( MakeReadWrite() );

        //
        // Get usn after making R/W
        // This usn will be use to compare with the usn of the file after we'll open it for R/W. We need
        // this comparison in order to ensure that nobody changed the file before we opened it again for R/W.
        //
        if (S_OK != WsbGetUsnFromFileHandle(m_handleVerify, TRUE, &fileUsn2))  {
            fileUsn2 = 0;
        }

        // Close the file
        NtClose( m_handleVerify );
        m_handleVerify = INVALID_HANDLE_VALUE;

        //
        // Open the file (for R/W)
        //
        DesiredAccess = FILE_READ_DATA | FILE_WRITE_DATA | FILE_WRITE_ATTRIBUTES | FILE_READ_ATTRIBUTES ;
        WsbAffirmHr( OpenObject( path, 
                                FILE_NON_DIRECTORY_FILE | FILE_WRITE_THROUGH,
                                DesiredAccess,
                                EXCLUSIVE_FLAG,
                                FILE_OPEN,
                                &IoStatusBlock,
                                &m_handleVerify ) );

        //
        // The open worked, our handle should be valid but we check to be
        // safe and sure 
        //
        WsbAssertHandle( m_handleVerify );

        //
        // Tell the USN journal that we are the source of the changes.
        //
        WsbAffirmHr(m_pResource->GetPath(&volName, 0));
        WsbAffirmHr(WsbMarkUsnSource(m_handleVerify, volName));

        //
        // Get the current attributes of the file and the times
        //
        WsbAffirmNtStatus( NtQueryInformationFile( m_handleVerify,
                                                   &IoStatusBlock,
                                                   (PVOID)&basicInformation,
                                                   sizeof( basicInformation ),
                                                   FileBasicInformation ) );
        
        fileVersionId = basicInformation.LastWriteTime.QuadPart;

        //
        // Set the time flags so that when we close the handle the
        // times are not updated on the file and the FileAttributes 
        // indicate the file is offline
        //
        basicInformation.CreationTime.QuadPart = -1;
        basicInformation.LastAccessTime.QuadPart = -1;
        basicInformation.LastWriteTime.QuadPart = -1;
        basicInformation.ChangeTime.QuadPart = -1;
        basicInformation.FileAttributes = 0;   // Do not change attributes yet
        WsbAffirmNtStatus( NtSetInformationFile( m_handleVerify,
                                                 &IoStatusBlock,
                                                 (PVOID)&basicInformation,
                                                 sizeof( basicInformation ),
                                                 FileBasicInformation ) );

        //
        // Do the check to see if the file changed
        //
        hr = VerifyInternal(offset, size, fileUsn1, fileUsn2);

        //
        // Note: Must check for S_OK since VerifyInternal may return FSA_E_ITEMCHANGED or FSA_E_ITEMINUSE
        //       Both are "Success hr", but should cause no truncation !!
        //
        if (S_OK != hr) {
            WsbThrow(hr);
        }

        //
        // Change the in memory flags for this scan item
        //
        m_findData.dwFileAttributes |= BIT_FOR_TRUNCATED;
        
        //
        // Rewrite the reparse point with the new flag
        //
        ntStatus = NtFsControlFile( m_handleVerify,
                                NULL,
                                NULL,
                                NULL,
                                &IoStatusBlock,
                                FSCTL_SET_REPARSE_POINT,
                                pReparseBuffer,
                                FIELD_OFFSET(REPARSE_DATA_BUFFER, GenericReparseBuffer)
                                    + pReparseBuffer->ReparseDataLength,
                                NULL,
                                0 );
    
        //
        // Check the return code
        //
        WsbAffirmNtStatus( ntStatus );

        //
        // It really happened so we need to flip the in memory copy of the
        // isTruncated flag so it reflects reality
        //
        m_placeholder.isTruncated = TRUE;
        
        //
        // Set the file size to zero to truncate the file
        sizeInformation.EndOfFile.QuadPart  = 0 ;
        WsbAffirmNtStatus( NtSetInformationFile( m_handleVerify, 
                              &IoStatusBlock, 
                              &sizeInformation,
                              sizeof( sizeInformation ),
                              FileEndOfFileInformation ) );

        //
        // Set the logical file size to the original size
        sizeInformation.EndOfFile.QuadPart  = m_placeholder.dataStreamSize;
        WsbAffirmNtStatus( NtSetInformationFile( m_handleVerify, 
                              &IoStatusBlock, 
                              &sizeInformation,
                              sizeof( sizeInformation ),
                              FileEndOfFileInformation ) );

        //
        // Now that the truncation is complete we set the OFFLINE attribute.  
        //
        basicInformation.CreationTime.QuadPart = -1;        // Make sure we do nothing with dates
        basicInformation.LastAccessTime.QuadPart = -1;
        basicInformation.LastWriteTime.QuadPart = -1;
        basicInformation.ChangeTime.QuadPart = -1;
        basicInformation.FileAttributes = m_findData.dwFileAttributes;
        WsbAffirmNtStatus(NtSetInformationFile( m_handleVerify,
                                                 &IoStatusBlock,
                                                 (PVOID)&basicInformation,
                                                 sizeof( basicInformation ),
                                                 FileBasicInformation ));

        // Since we have restored the original attributes we can reset the flag that was possibly set by MakeReadWrite
        m_changedAttributes = FALSE;
        

        hr = S_OK;
    } WsbCatch(hr);

    //
    // if we opened the file we need to close it
    //
    if( INVALID_HANDLE_VALUE != m_handleVerify) {
        NtClose( m_handleVerify );
        m_handleVerify = INVALID_HANDLE_VALUE;
    }

    // If the file data had changed (so we didn't truncate it) log event and 
    // remove placeholder info
    if (FSA_E_ITEMCHANGED == hr) {
        WsbLogEvent(FSA_MESSAGE_TRUNCSKIPPED_ISCHANGED, 0, NULL, 
                (OLECHAR*) jobName, WsbAbbreviatePath(fileName, 80), 
                WsbHrAsString(hr), NULL);
        
        DeletePlaceholder(offset, size);  
    }

    
    WsbTraceOut(OLESTR("CFsaScanItem::TruncateInternal"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}



HRESULT
CFsaScanItem::Verify(
    IN LONGLONG offset,
    IN LONGLONG size
    )  

/*++

Implements:

  IFsaScanItem::Verify().


--*/
{
    HRESULT         hr = E_FAIL;
    CWsbStringPtr   path;
    ULONG           DesiredAccess;
    IO_STATUS_BLOCK IoStatusBlock;


    WsbTraceIn(OLESTR("CFsaScanItem::Verify"), OLESTR(""));

    m_handleVerify = INVALID_HANDLE_VALUE;
    
    try {
        WsbAssert( m_gotPlaceholder, E_UNEXPECTED );
        
        //
        // Create the real file name we need to open, under the covers this
        // allocates the buffer since the path pointer is null
        //
        WsbAffirmHr( GetFullPathAndName(  OLESTR("\\\\?\\"), NULL, &path, 0));
    
        //
        // Open the file
        //
        DesiredAccess = FILE_READ_DATA | FILE_WRITE_DATA | FILE_WRITE_ATTRIBUTES | FILE_READ_ATTRIBUTES ;
        WsbAffirmHr( OpenObject( path, 
                                FILE_NON_DIRECTORY_FILE | FILE_WRITE_THROUGH,
                                DesiredAccess,
                                EXCLUSIVE_FLAG,
                                FILE_OPEN,
                                &IoStatusBlock,
                                &m_handleVerify ) );

        //
        // The open worked, our handle should be valid but we check to be
        // safe and sure 
        //
        WsbAssertHandle( m_handleVerify );
    
        //
        // Do the check to see if the file changed
        // Note that it throws rather than affirms because FSA_E_ITEMCHANGED is a success 
        WsbThrow(VerifyInternal(offset, size, 0, 0));

    } WsbCatch(hr);

    //
    // if we opened the file we need to close it
    //
    if( INVALID_HANDLE_VALUE != m_handleVerify) {
        NtClose( m_handleVerify );
        m_handleVerify = INVALID_HANDLE_VALUE;
    }

    
    WsbTraceOut(OLESTR("CFsaScanItem::Verify"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}



HRESULT
CFsaScanItem::VerifyInternal(
    IN LONGLONG offset,
    IN LONGLONG size,
    IN LONGLONG compareUsn1,
    IN LONGLONG compareUsn2
    )  

/*++

Implements:

  IFsaScanItem::VerifyInternal().


   Note:  This requires that m_handleVerify is set up with a handle to the file being verified.

--*/
{
    HRESULT         hr = E_FAIL;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_BASIC_INFORMATION       basicInformation;
    CWsbStringPtr           fileName;
    CWsbStringPtr           jobName;
    LONGLONG                fileVersionId;
    ULONG                   i = 0;
    CWsbStringPtr           volName;
    LONGLONG                realFileSize;
    RP_MSG                  in, out;
    DWORD                   outSize;


    WsbTraceIn(OLESTR("CFsaScanItem::VerifyInternal"), OLESTR(""));

    // Get strings for tracing and error logging (ignore errors?!)
    GetFullPathAndName( 0, 0, &fileName, 0);
    m_pSession->GetName(&jobName, 0);
    
    try {
        BOOL     DoCRC = FALSE;
        BOOL     DoUsnCheck = FALSE;
        LONGLONG premigListUsn;
        LONGLONG fileUsn;
        


        WsbAffirmHr(GetLogicalSize(&realFileSize));
        //
        // Currently, avoid offset and size verification:
        // - Since we are not doing partial file migration, offset is always 0.
        // - Size in Validate would always be the same since it is taken from GetLogicalSize as well.
        // - Size in case of auto-truncation is not reliable since it is taken from the premigrated db,
        //   where there could be bogus records from previous migrations of the file
        //
/***        if ( (realFileSize != size) || (offset != 0) ) {
            WsbThrow(FSA_E_ITEMCHANGED);
        }   ***/
        UNREFERENCED_PARAMETER(size);
        
        //
        WsbAssertHandle( m_handleVerify );
    
        //
        // Get the USN from the premigration list and the USN from the file.
        // We need to get the USN from the file now, before any NtSetInformationFile
        // is called because this changes the USN value.
        // If we have trouble getting the USN, just set them
        // to 0 and go on, we check for 0 as a special case.
        //
        if (S_OK != GetPremigratedUsn(&premigListUsn))  {
            premigListUsn = 0;
        }
        if (S_OK != WsbGetUsnFromFileHandle(m_handleVerify, FALSE, &fileUsn))  {
            fileUsn = 0;
        }
        
        WsbTrace(OLESTR("CFsaScanItem::VerifyInternal: premig USN <%I64d>, file USN <%I64d>\n"),
                    premigListUsn, fileUsn );
        WsbTrace(OLESTR("CFsaScanItem::VerifyInternal: Compare1 USN <%I64d>, Compare2 USN <%I64d>\n"),
                    compareUsn1, compareUsn2 );
        //
        // Get the current attributes of the file and the times
        //
        WsbAssertNtStatus( NtQueryInformationFile( m_handleVerify,
                                                   &IoStatusBlock,
                                                   (PVOID)&basicInformation,
                                                   sizeof( basicInformation ),
                                                   FileBasicInformation ) );
        
        fileVersionId = basicInformation.LastWriteTime.QuadPart;

        //
        // Verify that the modify date & time has not changed since we 
        // took the data
        //
        if( fileVersionId != m_placeholder.fileVersionId ) {
            WsbThrow(FSA_E_ITEMCHANGED);
        } 
        
        //
        // If the file is memory mapped by another process and the original handle was closed we
        // are still able to open it for exclusive access here.  We have to determine if the file
        // is mapped and if so we cannot truncate it.  The only way to do this is from kernel
        // mode so we call our filter to do the check.
        //
        in.inout.command = RP_CHECK_HANDLE;
        WsbAssertStatus(DeviceIoControl(m_handleVerify, FSCTL_HSM_MSG, &in,
                               sizeof(RP_MSG), &out, sizeof(RP_MSG), &outSize, NULL));
                               
        if (!out.msg.hRep.canTruncate) {
            hr = FSA_E_ITEMINUSE;
            WsbLogEvent(FSA_MESSAGE_TRUNCSKIPPED_ISMAPPED, 0, NULL,  (OLECHAR*) jobName, WsbAbbreviatePath(fileName, 120), WsbHrAsString(hr), NULL);
            WsbThrow(hr);
        }
        
        
        // If the USN's don't match, then we need to check the
        // journal for changes

        // premigListUsn: The usn of the file immediately after it was migrated
        // compareUsn1: If not 0, the usn of the file before we (possibly) removed a read-only attribute
        // compareUsn2: If not 0,  
        //

        if ((0 == fileUsn) || (0 == premigListUsn)) {
            //  We don't have USN Journal info so force a CRC comparison
            DoCRC = TRUE;
        } else if ((compareUsn1 != 0) && (compareUsn2 != 0))  {
            // Need to compare with these input usn instead of a direct compare
            if ((premigListUsn != compareUsn1) || (fileUsn != compareUsn2)) {
                DoUsnCheck = TRUE;
            }
        } else if (fileUsn != premigListUsn)  {
            DoUsnCheck = TRUE;
        }

        // Current usn indicates that file may have changed
        if (DoUsnCheck)  {
            BOOL     UsnChanged = FALSE;

            hr = CheckUsnJournalForChanges(premigListUsn, fileUsn, &UsnChanged);
            if (S_OK == hr) {
                if (UsnChanged) {
                    // File changed, skip it
                    WsbThrow(FSA_E_ITEMCHANGED);
                }
            } else {
                // Something failed, force a CRC comparison
                DoCRC = TRUE;
                WsbLogEvent(FSA_MESSAGE_USN_CHECK_FAILED, 0, NULL,  
                        WsbAbbreviatePath(fileName,120), 
                        WsbHrAsString(hr), NULL);
                hr = S_OK;
            }
        }
        
        // If the USNJ indicated a possible change, then we need to CRC 
        // the data.
        if (DoCRC)  {
            //
            // Check to be sure that the CRC in the placeholder matches 
            // that of the file
            //
            ULONG currentCRC;

#if defined(TEMPORARY_TRUNCATE_STATISTICS)
            //  Try to increment the truncate-CRC count in the registry
            WsbIncRegistryValueDWORD(NULL, FSA_REGISTRY_PARMS,
                    OLESTR("TruncateCRCs"));
#endif
            
            WsbAffirmHr(CalculateCurrentCRCInternal(m_handleVerify, offset, realFileSize, &currentCRC));
            WsbTrace(OLESTR("CFsaScanItem::VerifyInternal: Current CRC <%ul>, Reparse CRC <%ls>\n"),
                    currentCRC, WsbLonglongAsString( m_placeholder.dataStreamCRC ) );
            if (currentCRC != m_placeholder.dataStreamCRC)  {
                //
                // The file has changed since we migrated it so
                // don't truncate it.
                WsbThrow(FSA_E_ITEMCHANGED);
            }
        } 


        hr = S_OK;
    } WsbCatch(hr);


    // If the file data had changed (so we didn't truncate it) log event  
    // (cannot remove placeholder with DeletePlaceholder since the file is already opened exclusively
    if (FSA_E_ITEMCHANGED == hr) {
        WsbLogEvent(FSA_MESSAGE_TRUNCSKIPPED_ISCHANGED, 0, NULL, 
                (OLECHAR*) jobName, WsbAbbreviatePath(fileName, 120), 
                WsbHrAsString(hr), NULL);
    }

    
    WsbTraceOut(OLESTR("CFsaScanItem::VerifyInternal"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}




HRESULT
CFsaScanItem::CheckIfSparse(
    IN LONGLONG offset,
    IN LONGLONG size
    )  

/*++

Implements:

  IFsaScanItem::CheckIfSparse()

    Determines if the specified section is on disk or not (is sparse)
    FSA_E_FILE_IS_TOTALLY_SPARSE - There are no resident portions of the section
    FSA_E_FILE_IS_PARTIALLY_SPARSE - The section of the file has some resident/some sparse
                                     sections
    FSA_E_FILE_IS_NOT_SPARSE - The section is totally resident
    any others - error and we don't know the state of the file

--*/
{
    HRESULT                         hr = E_FAIL;
    HANDLE                          handle = INVALID_HANDLE_VALUE;
    CWsbStringPtr                   path;
    ULONG                           DesiredAccess;
    IO_STATUS_BLOCK                 IoStatusBlock;
    NTSTATUS                        ntStatus;
    FILE_ALLOCATED_RANGE_BUFFER     inRange;
#define NUM_RANGE 10
    FILE_ALLOCATED_RANGE_BUFFER     outRange[NUM_RANGE];
    PFILE_ALLOCATED_RANGE_BUFFER    cRange;
    int                             idx;

    WsbTraceIn(OLESTR("CFsaScanItem::CheckIfSparse"), OLESTR("offset = <%I64d>, size = <%I64d>"),
                    offset, size);
    //
    // If the file is really managed then we can check the allocation map
    // Otherwise we indicate that the data is all resident
    //
    try {
        //
        // Create the real file name we need to open, under the covers this
        // allocates the buffer since the path pointer is null
        //
        WsbAffirmHr( GetFullPathAndName(  OLESTR("\\\\?\\"), NULL, &path, 0));
        //WsbAffirmHr( GetFullPathAndName(  NULL, NULL, &path, 0));
        
            //
            // Open the file to check the allocation
            //
            DesiredAccess = FILE_READ_ATTRIBUTES | FILE_READ_DATA;
            WsbAffirmHr( OpenObject( path, 
                                    FILE_NON_DIRECTORY_FILE | FILE_NO_INTERMEDIATE_BUFFERING,
                                    DesiredAccess,
                                    SHARE_FLAGS,
                                    FILE_OPEN,
                                    &IoStatusBlock,
                                    &handle ) );

        //
        // The open worked, our handle should be valid but we check to be
        // safe and sure 
        //
        WsbAssertHandle( handle );
   
        memset(&outRange, 0, sizeof(FILE_ALLOCATED_RANGE_BUFFER) * NUM_RANGE);

        //
        // Check the allocation of the specified range
        //
        inRange.FileOffset.QuadPart = offset;
        inRange.Length.QuadPart = size;
        ntStatus = NtFsControlFile( handle,
                                   NULL,
                                   NULL,
                                   NULL,
                                   &IoStatusBlock,
                                   FSCTL_QUERY_ALLOCATED_RANGES,
                                   &inRange,
                                   sizeof(FILE_ALLOCATED_RANGE_BUFFER),
                                   &outRange,
                                   sizeof(FILE_ALLOCATED_RANGE_BUFFER) * NUM_RANGE);
   
        //
        // Check the return code but STATUS_SUCCESS or STATUS_BUFFER_OVERFLOW are valid
        //
        if ( STATUS_SUCCESS != ntStatus && STATUS_BUFFER_OVERFLOW != ntStatus ) {
            WsbAssertNtStatus( ntStatus );
        }

    
        cRange = (PFILE_ALLOCATED_RANGE_BUFFER) &outRange;
        for (idx = 0; idx < NUM_RANGE; idx++) {
            if (cRange->Length.QuadPart != 0) {
                WsbTrace(OLESTR("CFsaScanItem::CheckIfSparse - Resident range %u Offset: %I64u, length: %I64u\n"), 
                        idx, cRange->FileOffset.QuadPart, cRange->Length.QuadPart);
            }
            cRange++;
        }

        //
        // Close the file since we are done with it and set the handle to invalid
        //
        NtClose(handle);
        handle =  INVALID_HANDLE_VALUE;

        //
        // If the initial allocated range does begin where we said to start and the length of the
        // allocated area is equal to the length we asked about then none of the data is sparse 
        //
        if ( (outRange[0].FileOffset.QuadPart == offset) && (outRange[0].Length.QuadPart == size) ) {
            hr = FSA_E_FILE_IS_NOT_SPARSE;
        } else if  (outRange[0].Length.QuadPart == 0)  {
                hr = FSA_E_FILE_IS_TOTALLY_SPARSE;
        } else  {
                hr = FSA_E_FILE_IS_PARTIALLY_SPARSE;
        }

    } WsbCatch(hr);

    //
    // if we opened the file we need to close it
    //
    if( INVALID_HANDLE_VALUE != handle) {
        NtClose( handle );
    }
    
    WsbTraceOut(OLESTR("CFsaScanItem::CheckIfSparse"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT
CFsaScanItem::CheckIfDiskFull(
    void
    )  

/*++

Implements:

  CFsaScanItem::CheckIfDiskFull()

    Determines whether a disk is full or not - will consider full if free-space is below X,
    where X default is 10 MB

    Returns:
        S_OK    Disk is full
        S_FALSE Disk is not full
        other   Unexpected error
    
--*/
{
    HRESULT                         hr = S_OK;

    WsbTraceIn(OLESTR("CFsaScanItem::CheckIfDiskFull"), OLESTR(""));

    try {
        ULARGE_INTEGER FreeBytesAvailableToCaller;
        ULARGE_INTEGER TotalNumberOfBytes;
        ULARGE_INTEGER TotalNumberOfFreeBytes;

        // Get volume free space
        CWsbStringPtr volumePath;
        WsbAffirmHr(m_pResource->GetPath(&volumePath, 0));

        WsbAffirmStatus(GetDiskFreeSpaceEx(volumePath, 
            &FreeBytesAvailableToCaller, &TotalNumberOfBytes, &TotalNumberOfFreeBytes));

        // Get default from the Registry and compare
        ULONG maxSizeDiskFullKB = FSA_MAX_SIZE_DISK_FULL_DEFAULT;
        WsbAffirmHr(WsbRegistryValueUlongAsString(NULL, FSA_REGISTRY_PARMS, FSA_MAX_SIZE_DISK_FULL,
                &maxSizeDiskFullKB));

        if (maxSizeDiskFullKB == 0) {
            // This means turning off quota check, i.e. always condiser disk as full
            hr = S_OK;
        } else if (TotalNumberOfFreeBytes.QuadPart <= (ULONGLONG )(maxSizeDiskFullKB * 1024)) {
            // Disk is considered full
            hr = S_OK;
        } else {
            // Disk free space is above the threshold
            hr = S_FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaScanItem::CheckIfDiskFull"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\fsa\fsarcvy.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    fsarcvy.h

Abstract:

    Header file for the diaster recovery class.

Author:

    Ron White   [ronw]   8-Sep-1997

Revision History:

--*/

#ifndef _FSARCVY_
#define _FSARCVY_


#include "resource.h"       // main symbols
#include "wsbdb.h"
#include "fsa.h"
#include "fsaprv.h"
#include "fsaprem.h"

// FSA_RECOVERY_FLAG_* - status flags for Recovery records
#define FSA_RECOVERY_FLAG_TRUNCATING      0x00000001
#define FSA_RECOVERY_FLAG_RECALLING       0x00000002


/////////////////////////////////////////////////////////////////////////////
// CFsaRecoveryRec

class CFsaRecoveryRec : 
    public CWsbDbEntity,
    public IFsaRecoveryRec,
    public CComCoClass<CFsaRecoveryRec,&CLSID_CFsaRecoveryRec>
{
public:
    CFsaRecoveryRec() {}
BEGIN_COM_MAP(CFsaRecoveryRec)
    COM_INTERFACE_ENTRY(IFsaRecoveryRec)
    COM_INTERFACE_ENTRY2(IWsbDbEntity, CWsbDbEntity)
    COM_INTERFACE_ENTRY(IWsbDbEntityPriv)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
END_COM_MAP()

//DECLARE_NO_REGISTRY()
DECLARE_REGISTRY_RESOURCEID(IDR_FsaRecoveryRec)

// IFsaRecoveryRec
public:
    STDMETHOD(FinalConstruct)(void);
    STDMETHOD(FinalRelease)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* /*pSize*/) {
            return(E_NOTIMPL); }
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbDbEntity
public:
    STDMETHOD(Print)(IStream* pStream);
    STDMETHOD(UpdateKey)(IWsbDbKey *pKey);
    WSB_FROM_CWSBDBENTITY;

// IWsbTestable
    STDMETHOD(Test)(USHORT* /*passed*/, USHORT* /*failed*/) {
        return(E_NOTIMPL); }

// IFsaRecoveryRec
public:
    STDMETHOD(GetBagId)(GUID* pId);
    STDMETHOD(GetBagOffset)(LONGLONG* pOffset);
    STDMETHOD(GetFileId)(LONGLONG* pFileId);
    STDMETHOD(GetOffsetSize)(LONGLONG *pOffset, LONGLONG* pSize);
    STDMETHOD(GetPath)(OLECHAR** ppPath, ULONG bufferSize);
    STDMETHOD(GetRecoveryCount)(LONG* pCount);
    STDMETHOD(GetStatus)(ULONG* pStatus);
    STDMETHOD(SetBagId)(GUID id);
    STDMETHOD(SetBagOffset)(LONGLONG offset);
    STDMETHOD(SetFileId)(LONGLONG FileId);
    STDMETHOD(SetOffsetSize)(LONGLONG Offset, LONGLONG Size);
    STDMETHOD(SetPath)(OLECHAR* pPath);
    STDMETHOD(SetRecoveryCount)(LONG Count);
    STDMETHOD(SetStatus)(ULONG Status);

private:
    GUID           m_BagId;
    LONGLONG       m_BagOffset;
    LONGLONG       m_FileId;
    LONGLONG       m_Offset;
    CWsbStringPtr  m_Path;
    LONG           m_RecoveryCount;
    LONGLONG       m_Size;
    ULONG          m_Status;  // FSA_RECOVERY_FLAG_* flags
};


#endif // _FSARCVY_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\fsa\fsaprem.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    fsaprem.h

Abstract:

    Header file for the premigrated list classes.

Author:

    Ron White   [ronw]   18-Feb-1997

Revision History:

--*/

#ifndef _FSAPREM_
#define _FSAPREM_


#include "resource.h"       // main symbols
#include "wsbdb.h"
#include "fsa.h"
#include "fsaprv.h"

#define PREMIGRATED_REC_TYPE                1
#define PREMIGRATED_BAGID_OFFSETS_KEY_TYPE  1
#define PREMIGRATED_ACCESS_TIME_KEY_TYPE    2
#define PREMIGRATED_SIZE_KEY_TYPE           3
#define RECOVERY_REC_TYPE                   2
#define RECOVERY_KEY_TYPE                   1

#define RECOVERY_KEY_SIZE  (IDB_MAX_KEY_SIZE - 1)

// This may be problem if longer path names are used:
#define PREMIGRATED_MAX_PATH_SIZE           65536

/////////////////////////////////////////////////////////////////////////////
// CFsaPremigratedDb

class CFsaPremigratedDb : 
    public IFsaPremigratedDb,
    public CWsbDb,
    public CComCoClass<CFsaPremigratedDb,&CLSID_CFsaPremigratedDb>
{
public:
    CFsaPremigratedDb() {}
BEGIN_COM_MAP(CFsaPremigratedDb)
    COM_INTERFACE_ENTRY(IFsaPremigratedDb)
    COM_INTERFACE_ENTRY2(IWsbDb, IFsaPremigratedDb)
    COM_INTERFACE_ENTRY(IWsbDbPriv)
    COM_INTERFACE_ENTRY(IPersistStream)
END_COM_MAP()

//DECLARE_NO_REGISTRY()
DECLARE_REGISTRY_RESOURCEID(IDR_FsaPremigratedDb)

DECLARE_PROTECT_FINAL_CONSTRUCT();

// IWsbDb
    WSB_FROM_CWSBDB;

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pclsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize) {
            return(CWsbDb::GetSizeMax(pSize)); }
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IFsaPremigrated
public:
    STDMETHOD(FinalConstruct)(void);
    STDMETHOD(FinalRelease)(void);
    STDMETHOD(Init)(OLECHAR* name, IWsbDbSys* pDbSys, BOOL* pCreated);

private:
};                                                                           




/////////////////////////////////////////////////////////////////////////////
// CFsaPremigratedRec

class CFsaPremigratedRec : 
    public CWsbDbEntity,
    public IFsaPremigratedRec,
    public CComCoClass<CFsaPremigratedRec,&CLSID_CFsaPremigratedRec>
{
public:
    CFsaPremigratedRec() {}
BEGIN_COM_MAP(CFsaPremigratedRec)
    COM_INTERFACE_ENTRY(IFsaPremigratedRec)
    COM_INTERFACE_ENTRY2(IWsbDbEntity, CWsbDbEntity)
    COM_INTERFACE_ENTRY(IWsbDbEntityPriv)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
END_COM_MAP()

//DECLARE_NO_REGISTRY()
DECLARE_REGISTRY_RESOURCEID(IDR_FsaPremigratedRec)

// IFsaPremigratedRec
public:
    STDMETHOD(FinalConstruct)(void);
    STDMETHOD(FinalRelease)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbDbEntity
public:
    STDMETHOD(Print)(IStream* pStream);
    STDMETHOD(UpdateKey)(IWsbDbKey *pKey);
    WSB_FROM_CWSBDBENTITY;

// IWsbTestable
    STDMETHOD(Test)(USHORT* /*passed*/, USHORT* /*failed*/) {
        return(E_NOTIMPL); }

// IFsaPremigratedRec
public:
    STDMETHOD(GetAccessTime)(FILETIME* pAccessTime);
    STDMETHOD(GetBagId)(GUID* pId);
    STDMETHOD(GetBagOffset)(LONGLONG* pOffset);
    STDMETHOD(GetFileId)(LONGLONG* pFileId);
    STDMETHOD(GetFileUSN)(LONGLONG* pFileUSN);
    STDMETHOD(GetOffset)(LONGLONG* pOffset);
    STDMETHOD(GetPath)(OLECHAR** ppPath, ULONG bufferSize);
    STDMETHOD(GetRecallTime)(FILETIME* pTime);
    STDMETHOD(GetSize)(LONGLONG* pSize);
    STDMETHOD(IsWaitingForClose)(void);
    STDMETHOD(SetAccessTime)(FILETIME AccessTime);
    STDMETHOD(SetBagId)(GUID id);
    STDMETHOD(SetBagOffset)(LONGLONG offset);
    STDMETHOD(SetFileId)(LONGLONG FileId);
    STDMETHOD(SetFileUSN)(LONGLONG FileUSN);
    STDMETHOD(SetFromScanItem)(IFsaScanItem* pScanItem, LONGLONG offset, LONGLONG size, BOOL isWaitingForClose);
    STDMETHOD(SetIsWaitingForClose)(BOOL isWaiting);
    STDMETHOD(SetOffset)(LONGLONG offset);
    STDMETHOD(SetPath)(OLECHAR* pPath);
    STDMETHOD(SetRecallTime)(FILETIME Time);
    STDMETHOD(SetSize)(LONGLONG Size);

private:
    FILETIME        m_AccessTime;
    GUID            m_BagId;
    LONGLONG        m_BagOffset;         // fileStart in the placeholder
    LONGLONG        m_FileId;
    BOOL            m_IsWaitingForClose;
    LONGLONG        m_Offset;            // dataStreamStart in the placeholder
    CWsbStringPtr   m_Path;
    FILETIME        m_RecallTime;
    LONGLONG        m_Size;
    LONGLONG        m_FileUSN;  // USN Journal number
};

#endif  // _FSAPREM_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\fsa\fsapost.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    fsapost.cpp

Abstract:

    This class contains represents a post it - a unit of work
    that is exchanged between the FSA and the HSM engine.

Author:

    Cat Brant   [cbrant]   1-Apr-1997

Revision History:

--*/

#include "stdafx.h"

#undef  WSB_TRACE_IS
#define WSB_TRACE_IS        WSB_TRACE_BIT_FSA

#include "wsb.h"
#include "fsa.h"
#include "fsapost.h"

//  Module data
static USHORT iCount = 0;  // Count of existing objects


HRESULT
CFsaPostIt::CompareTo(
    IN IUnknown* pUnknown,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbCollectable::CompareTo().

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IFsaPostIt> pPostIt;

    WsbTraceIn(OLESTR("CFsaPostIt::CompareTo"), OLESTR(""));
    
    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pUnknown, E_POINTER);

        // We need the IFsaPostIt interface to get the value of the object.
        WsbAffirmHr(pUnknown->QueryInterface(IID_IFsaPostIt, (void**) &pPostIt));

        // Compare the rules.
        hr = CompareToIPostIt(pPostIt, pResult);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmPostIt::CompareTo"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CFsaPostIt::CompareToIPostIt(
    IN IFsaPostIt* pPostIt,
    OUT SHORT* pResult
    )

/*++

Implements:

  IFsaPostIt::CompareToIPostIt().

--*/
{
    HRESULT         hr = S_OK;
    CWsbStringPtr   path;
    CWsbStringPtr   name;

    WsbTraceIn(OLESTR("CFsaPostIt::CompareToIPostIt"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pPostIt, E_POINTER);
        
        //
        // Not used - not implemented
        //
        hr = E_NOTIMPL;

// Compare the PostIt

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPostIt::CompareToIPostIt"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CFsaPostIt::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPostIt::FinalConstruct"), OLESTR(""));
    
    try {

        WsbAffirmHr(CWsbObject::FinalConstruct());

        m_pSession           = 0;
        m_storagePoolId      = GUID_NULL;
        m_mode               = 0;
        m_requestAction      = FSA_REQUEST_ACTION_NONE;
        m_resultAction       = FSA_RESULT_ACTION_NONE;
        m_fileVersionId      = 0;
        m_requestOffset      = 0;
        memset (&m_placeholder, 0, sizeof(FSA_PLACEHOLDER));
        m_path               = OLESTR("");
        m_usn                = 0;
        m_hr                 = S_OK;

    } WsbCatch(hr);

    iCount++;
    WsbTraceOut(OLESTR("CFsaPostIt::FinalConstruct"),OLESTR("hr = <%ls>, Count is <%d>"),
                WsbHrAsString(hr), iCount);

    return(hr);
}


void
CFsaPostIt::FinalRelease(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalRelease().

--*/
{
    WsbTraceIn(OLESTR("CFsaPostIt::FinalRelease"),OLESTR(""));

    // Let the parent class do his thing.   
    CWsbObject::FinalRelease();

    iCount--;
    WsbTraceOut(OLESTR("CFsaPostIt::FinalRelease"),OLESTR("Count is <%d>"), iCount);
}


HRESULT
CFsaPostIt::GetFileVersionId(
    OUT LONGLONG  *pFileVersionId
    )

/*++

Implements:

  IFsaPostIt::GetFileVersionId().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPostIt::GetFileVersionId"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pFileVersionId, E_POINTER);
        *pFileVersionId = m_fileVersionId;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPostIt::GetFileVersionId"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CFsaPostIt::GetFilterRecall(
    IFsaFilterRecall** ppRecall
    )

/*++

Implements:

  IFsaPostIt::GetFilterRecall().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPostIt::GetFilterRecall"), OLESTR(""));

    try {

        // Did they give us a valid item.
        WsbAssert(0 != ppRecall, E_POINTER);

        *ppRecall = m_pFilterRecall;
        m_pFilterRecall.p->AddRef();

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPostIt::GetFilterRecall"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaPostIt::GetMode(
    OUT ULONG *pMode    
    )

/*++

Implements:

  IFsaPostIt::GetMode().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPostIt::GetMode"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pMode, E_POINTER);
        *pMode = m_mode;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPostIt::GetMode"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaPostIt::GetPath(
    OLECHAR **pPath,
    IN ULONG bufferSize
    )           

/*++

Implements:

  IFsaPostIt::GetPath().

--*/
{
    HRESULT         hr = S_OK;
    CWsbStringPtr   path;

    WsbTraceIn(OLESTR("CFsaPostIt::GetPath"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pPath, E_POINTER);
        WsbAffirmHr(m_path.CopyTo(pPath, bufferSize));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPostIt::GetPath"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaPostIt::GetPlaceholder(
    FSA_PLACEHOLDER  *pPlaceholder
    )

/*++

Implements:

  IFsaPostIt::GetPlaceholder().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPostIt::GetPlaceholder"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pPlaceholder, E_POINTER);
        memcpy(pPlaceholder, &m_placeholder, sizeof(FSA_PLACEHOLDER));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPostIt::GetPlaceholder"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CFsaPostIt::GetRequestAction(
    FSA_REQUEST_ACTION  *pRequestAction
    )

/*++

Implements:

  IFsaPostIt::GetRequestAction().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPostIt::GetRequestAction"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pRequestAction, E_POINTER);
        *pRequestAction = m_requestAction;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPostIt::GetRequestAction"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaPostIt::GetRequestOffset(
    LONGLONG  *pRequestOffset
    )

/*++

Implements:

  IFsaPostIt::GetRequestOffset().

--*/
{
    HRESULT         hr = S_OK;
    CWsbStringPtr   path;
    CWsbStringPtr   name;

    WsbTraceIn(OLESTR("CFsaPostIt::GetRequestOffset"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pRequestOffset, E_POINTER);
        *pRequestOffset = m_requestOffset;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPostIt::GetRequestOffset"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaPostIt::GetRequestSize(
    LONGLONG  *pRequestSize
    )

/*++

Implements:

  IFsaPostIt::GetRequestSize().

--*/
{
    HRESULT         hr = S_OK;
    CWsbStringPtr   path;
    CWsbStringPtr   name;

    WsbTraceIn(OLESTR("CFsaPostIt::GetRequestSize"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pRequestSize, E_POINTER);
        *pRequestSize = m_requestSize;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPostIt::GetRequestSize"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaPostIt::GetResult(
    HRESULT  *pHr
    )

/*++

Implements:

  IFsaPostIt::GetResult().

--*/
{
    HRESULT         hr = S_OK;
    CWsbStringPtr   path;
    CWsbStringPtr   name;

    WsbTraceIn(OLESTR("CFsaPostIt::GetResult"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pHr, E_POINTER);
        *pHr = m_hr;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPostIt::GetResultAction"), OLESTR("hr = <%ls>, result = <%ls>"), 
            WsbHrAsString(hr), WsbHrAsString(*pHr));

    return(hr);
}

HRESULT
CFsaPostIt::GetResultAction(
    FSA_RESULT_ACTION  *pResultAction
    )

/*++

Implements:

  IFsaPostIt::GetResultAction().

--*/
{
    HRESULT         hr = S_OK;
    CWsbStringPtr   path;
    CWsbStringPtr   name;

    WsbTraceIn(OLESTR("CFsaPostIt::GetResultAction"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pResultAction, E_POINTER);
        *pResultAction = m_resultAction;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPostIt::GetResultAction"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaPostIt::GetSession(
    IHsmSession  **ppSession
    )

/*++

Implements:

  IFsaPostIt::GetSession().

--*/
{
    HRESULT         hr = S_OK;
    CWsbStringPtr   path;
    CWsbStringPtr   name;

    WsbTraceIn(OLESTR("CFsaPostIt::GetSession"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != ppSession, E_POINTER);
        *ppSession = m_pSession;
        m_pSession.p->AddRef();

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPostIt::GetSession"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaPostIt::GetStoragePoolId(
    GUID  *pStoragePoolId
    )

/*++

Implements:

  IFsaPostIt::GetStoragePoolId().

--*/
{
    HRESULT         hr = S_OK;
    CWsbStringPtr   path;
    CWsbStringPtr   name;

    WsbTraceIn(OLESTR("CFsaPostIt::GetStoragePoolId"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pStoragePoolId, E_POINTER);
        memcpy(pStoragePoolId, &m_storagePoolId, sizeof(GUID));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPostIt::GetStoragePoolId"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CFsaPostIt::GetUSN(
    LONGLONG  *pUsn
    )

/*++

Implements:

  IFsaPostIt::GetUSN().

--*/
{
    HRESULT         hr = S_OK;
    CWsbStringPtr   path;
    CWsbStringPtr   name;

    WsbTraceIn(OLESTR("CFsaPostIt::GetUSN"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pUsn, E_POINTER);
        *pUsn = m_usn;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPostIt::GetUSN"), OLESTR("hr = <%ls>, USN = <%ls>"), 
            WsbHrAsString(hr), WsbPtrToLonglongAsString(pUsn));

    return(hr);
}


HRESULT
CFsaPostIt::GetThreadId(
    DWORD  *pThreadId
    )

/*++

Implements:

  IFsaPostIt::GetThreadId().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPostIt::GetThreadId"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pThreadId, E_POINTER);
        *pThreadId = m_threadId;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPostIt::GetThreadId"), OLESTR("hr = <%ls>, threadId = <%ls>"), 
            WsbHrAsString(hr), WsbPtrToLongAsString((PLONG)pThreadId));

    return(hr);
}

HRESULT
CFsaPostIt::SetFileVersionId(
    LONGLONG  fileVersionId
    )

/*++

Implements:

  IFsaPostIt::SetFileVersionId().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPostIt::SetFileVersionId"), OLESTR(""));

    m_fileVersionId = fileVersionId;

    WsbTraceOut(OLESTR("CFsaPostIt::SetFileVersionId"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaPostIt::SetFilterRecall(
    IN IFsaFilterRecall*    pRecall
    )

/*++

Implements:

  IFsaPostIt::SetFilterRecall().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPostIt::SetFilterRecall"), OLESTR(""));

    m_pFilterRecall = pRecall;

    WsbTraceOut(OLESTR("CFsaPostIt::SetFilterRecall"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaPostIt::SetMode(
    ULONG mode
    )

/*++

Implements:

  IFsaPostIt::SetMode().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPostIt::SetMode"), OLESTR(""));

    m_mode = mode;

    WsbTraceOut(OLESTR("CFsaPostIt::SetMode"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
                                                                         
    return(hr);
}


HRESULT
CFsaPostIt::SetPath(
    OLECHAR *path
    )

/*++

Implements:

  IFsaPostIt::SetPath().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPostIt::SetPath"), OLESTR(""));

    m_path = path;

    WsbTraceOut(OLESTR("CFsaPostIt::SetPath"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaPostIt::SetPlaceholder(
    FSA_PLACEHOLDER *pPlaceholder
    )

/*++

Implements:

  IFsaPostIt::SetPlaceholder().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPostIt::SetPlaceholder"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        memcpy(&m_placeholder, pPlaceholder, sizeof(FSA_PLACEHOLDER));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPostIt::SetPlaceholder"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaPostIt::SetRequestAction(
    FSA_REQUEST_ACTION requestAction
    )

/*++

Implements:

  IFsaPostIt::SetRequestAction().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPostIt::SetRequestAction"), OLESTR(""));

    m_requestAction = requestAction;

    WsbTraceOut(OLESTR("CFsaPostIt::SetRequestAction"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaPostIt::SetRequestOffset(
    LONGLONG  requestOffset
    )

/*++

Implements:

  IFsaPostIt::SetRequestOffset().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPostIt::SetRequestOffset"), OLESTR(""));

    m_requestOffset = requestOffset;

    WsbTraceOut(OLESTR("CFsaPostIt::SetRequestOffset"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaPostIt::SetRequestSize(
    LONGLONG  requestSize
    )

/*++

Implements:

  IFsaPostIt::SetRequestSize().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPostIt::SetRequestSize"), OLESTR(""));

    m_requestSize = requestSize;

    WsbTraceOut(OLESTR("CFsaPostIt::SetRequestSize"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CFsaPostIt::SetResult(
    HRESULT result
    )

/*++

Implements:

  IFsaPostIt::SetResult().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPostIt::SetResult"), OLESTR("result = <%ls>"), WsbHrAsString(result));

    m_hr =  result;

    WsbTraceOut(OLESTR("CFsaPostIt::SetResult"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaPostIt::SetResultAction(
    FSA_RESULT_ACTION  resultAction
    )

/*++

Implements:

  IFsaPostIt::SetResultAction().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPostIt::SetResultAction"), OLESTR(""));

    m_resultAction =  resultAction;

    WsbTraceOut(OLESTR("CFsaPostIt::SetResultAction"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CFsaPostIt::SetSession(
    IHsmSession *pSession
    )

/*++

Implements:

  IFsaPostIt::SetSession().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPostIt::SetSession"), OLESTR(""));

    if (m_pSession != 0) {
        m_pSession = 0;
    }

    m_pSession = pSession;

    WsbTraceOut(OLESTR("CFsaPostIt::SetSession"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaPostIt::SetStoragePoolId(
    GUID  StoragePoolId
    )

/*++

Implements:

  IFsaPostIt::SetStoragePoolId().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPostIt::SetStoragePoolId"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        memcpy(&m_storagePoolId, &StoragePoolId, sizeof(GUID));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPostIt::SetStoragePoolId"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaPostIt::SetUSN(
    LONGLONG  usn
    )

/*++

Implements:

  IFsaPostIt::SetUSN().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPostIt::SetUSN"), OLESTR("USN = <%ls>"), WsbLonglongAsString(usn));

    m_usn = usn;

    WsbTraceOut(OLESTR("CFsaPostIt::SetUSN"), OLESTR("hr = <%ls>"),  WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaPostIt::SetThreadId(
    DWORD threadId
    )

/*++

Implements:

  IFsaPostIt::SetThreadId().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPostIt::SetThreadId"), OLESTR("ThreadId = <%ls>"), WsbLongAsString(threadId));

    m_threadId = threadId;

    WsbTraceOut(OLESTR("CFsaPostIt::SetThreadId"), OLESTR("hr = <%ls>"),  WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaPostIt::Test(
    USHORT* passed,
    USHORT* failed
    )

/*++

Implements:

  IWsbTestable::Test().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != passed, E_POINTER);
        WsbAssert(0 != failed, E_POINTER);

        *passed = 0;
        *failed = 0;

    } WsbCatch(hr);

    return(hr);
}


HRESULT CFsaPostIt::GetClassID
(
    OUT LPCLSID pclsid
    ) 
/*++

Routine Description:

  See IPerist::GetClassID()

Arguments:

  See IPerist::GetClassID()

Return Value:

    See IPerist::GetClassID()

--*/

{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPostIt::GetClassID"), OLESTR(""));


    try {
        WsbAssert(0 != pclsid, E_POINTER);

        *pclsid = CLSID_CFsaPostIt;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPostIt::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pclsid));
    return(hr);
}

HRESULT CFsaPostIt::GetSizeMax
(
    OUT ULARGE_INTEGER* pcbSize
    ) 
/*++

Routine Description:

  See IPersistStream::GetSizeMax().

Arguments:

  See IPersistStream::GetSizeMax().

Return Value:

  See IPersistStream::GetSizeMax().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPostIt::GetSizeMax"), OLESTR(""));

    try {
        
        WsbAssert(0 != pcbSize, E_POINTER);

        pcbSize->QuadPart = 0;
        hr = E_NOTIMPL;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPostIt::GetSizeMax"), 
        OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), 
        WsbPtrToUliAsString(pcbSize));

    return(hr);
}

HRESULT CFsaPostIt::Load
(
    IN IStream* /*pStream*/
    ) 
/*++

Routine Description:

  See IPersistStream::Load().

Arguments:

  See IPersistStream::Load().

Return Value:

  See IPersistStream::Load().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPostIt::Load"), OLESTR(""));

    try {
        hr = E_NOTIMPL;

    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CFsaPostIt::Load"), OLESTR("hr = <%ls>"),   WsbHrAsString(hr));

    return(hr);
}

HRESULT CFsaPostIt::Save
(
    IN IStream* pStream, 
    IN BOOL clearDirty
    ) 
/*++

Routine Description:

  See IPersistStream::Save().

Arguments:

  See IPersistStream::Save().

Return Value:

  See IPersistStream::Save().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPostIt::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));

    try {
        WsbAssert(0 != pStream, E_POINTER);
        hr = E_NOTIMPL;

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPostIt::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\fsa\fsarsc.cpp ===
/*++

(c) 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    fsarsc.cpp

Abstract:

    This class represents a file system resource (i.e. volume)
    for NTFS 5.0.

Author:

    Chuck Bardeen   [cbardeen]   1-Dec-1996

--*/


#include "stdafx.h"

#define WSB_TRACE_IS        WSB_TRACE_BIT_FSA

#include "wsb.h"
#include "fsa.h"
#include "fsaprem.h"
#include "fsaprv.h"
#include "fsarcvy.h"
#include "fsarsc.h"
#include "fsasrvr.h"
#include "engine.h"
#include "HsmConn.h"
#include "job.h"
#include "task.h"
#include "mstask.h"
#include <shlobj.h>

static short g_InstanceCount = 0;
static DWORD g_ThreadId;


DWORD FsaStartOnStateChange(
    void* pVoid
    )
/*++

    Note: This is done as a separate thread to avoid a deadlock situation

--*/
{
    ((CFsaResource*) pVoid)->OnStateChange();
    return(0);
}


HRESULT
CFsaResource::AddPremigrated(
    IN IFsaScanItem* pScanItem,
    IN LONGLONG offset,
    IN LONGLONG size,
    IN BOOL isWaitingForClose,
    IN LONGLONG usn
    )

/*++

Implements:

  IFsaResource::AddPremigrated().

--*/
{
    HRESULT                         hr = S_OK;
    CComPtr<IWsbDbSession>          pDbSession;
    CComPtr<IFsaPremigratedRec>     pRec;

    WsbTraceIn(OLESTR("CFsaResource::AddPremigrated"), OLESTR("offset = %I64d, size = %I64d, waiting = <%ls>, usn = <%I64d>"),
            offset, size, WsbBoolAsString(isWaitingForClose), usn);

    try {

        WsbAssert(0 != pScanItem, E_POINTER);
        WsbAffirm(m_pPremigrated != NULL, E_UNEXPECTED);
        WsbAffirm(m_isDbInitialized, S_FALSE);  // Not an necessarily an error

        // Open the data base
        WsbAffirmHr(m_pPremigrated->Open(&pDbSession));

        try {

            WsbAffirmHr(m_pPremigrated->GetEntity(pDbSession, PREMIGRATED_REC_TYPE, IID_IFsaPremigratedRec, (void**) &pRec));
            WsbAffirmHr(pRec->UseKey(PREMIGRATED_BAGID_OFFSETS_KEY_TYPE));
            WsbAffirmHr(pRec->SetFromScanItem(pScanItem, offset, size, isWaitingForClose));
            WsbAffirmHr(pRec->SetFileUSN(usn));

            // If the key doesn't exist, then create it.
            if (FAILED(pRec->FindEQ())) {
                WsbAffirmHr(pRec->MarkAsNew());
                WsbAffirmHr(pRec->Write());

                // Add the size of the section migrated to the amount of premigrated data.
                m_premigratedSize += size;
            }

            // Otherwise, update it.
            else {
                LONGLONG        itemSize;

                WsbAffirmHr(pRec->GetSize(&itemSize));
                WsbAffirmHr(pRec->SetFromScanItem(pScanItem, offset, size, isWaitingForClose));
                WsbAffirmHr(pRec->Write());
                if (m_isDoingValidate) {
                    m_premigratedSize += size;
                } else if (itemSize != size) {
                    m_premigratedSize = max(0, (m_premigratedSize - itemSize) + size);
                }
            }
            m_isDirty = TRUE;

        } WsbCatch(hr);

        // Close the data base
        WsbAffirmHr(m_pPremigrated->Close(pDbSession));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::AddPremigrated"),
            OLESTR("hr = <%ls>, m_premigratedSize = %I64d"), WsbHrAsString(hr),
            m_premigratedSize);

    return(hr);
}


HRESULT
CFsaResource::AddPremigratedSize(
    IN LONGLONG size
    )

/*++

Implements:

  IFsaResourcePriv::AddPremigratedSize().

--*/
{
    WsbTraceIn(OLESTR("CFsaResource::AddPremigratedSize"), OLESTR("m_premigratedSize = %I64d"), m_premigratedSize);

    m_isDirty = TRUE;
    m_premigratedSize += size;

    WsbTraceOut(OLESTR("CFsaResource::AddPremigratedSize"), OLESTR("m_premigratedSize = %I64d"), m_premigratedSize);
    return(S_OK);
}


HRESULT
CFsaResource::AddTruncated(
    IN IFsaScanItem* /*pScanItem*/,
    IN LONGLONG /*offset*/,
    IN LONGLONG size
    )

/*++

Implements:

  IFsaResource::AddTruncated().

--*/
{
    HRESULT                         hr = S_OK;

    WsbTraceIn(OLESTR("CFsaResource::AddTruncated"), OLESTR(""));

    try {

        m_truncatedSize += size;
        m_isDirty = TRUE;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::AddTruncated"),
            OLESTR("hr = <%ls>, m_truncatedSize = %I64d"), WsbHrAsString(hr),
            m_truncatedSize);

    return(hr);
}


HRESULT
CFsaResource::AddTruncatedSize(
    IN LONGLONG size
    )

/*++

Implements:

  IFsaResource::AddTruncatedSize().

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaResource::AddTruncatedSize"), OLESTR(""));

    try {

        m_truncatedSize += size;
        m_isDirty = TRUE;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::AddTruncatedSize"), OLESTR("hr = <%ls>, m_truncatedSize = %I64d"), WsbHrAsString(hr), m_truncatedSize);

    return(hr);
}


HRESULT
CFsaResource::BeginSession(
    IN OLECHAR* name,
    IN ULONG logControl,
    IN ULONG runId,
    IN ULONG subRunId,
    OUT IHsmSession** ppSession
    )

/*++

Implements:

  IFsaResource::BeginSession().

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IHsmSession>    pSession;
    BOOL                    bLog = TRUE;

    WsbTraceIn(OLESTR("CFsaResource::BeginSession"), OLESTR("name = <%ls>, Log = <%lu>, runId = <%lu>, subRunId = <%lu>"),
            (OLECHAR *)name, logControl, runId, subRunId);
    try {

        WsbAssert(0 != ppSession, E_POINTER);
        *ppSession = 0;

        // Create and Initialize a session object.
        WsbAffirmHr(CoCreateInstance(CLSID_CHsmSession, 0, CLSCTX_SERVER, IID_IHsmSession, (void**) &pSession));
        WsbAffirmHr(pSession->Start(name, logControl, m_managingHsm, 0, (IFsaResource*) this, runId, subRunId));

        // Since begin sesson doesn't use a formal scan, indicate that the scan phase has
        // started.
        WsbAffirmHr(pSession->ProcessState(HSM_JOB_PHASE_SCAN, HSM_JOB_STATE_STARTING, OLESTR(""),bLog));

        // Return the session to the caller.
        *ppSession = pSession;
        pSession.p->AddRef();

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::BeginSession"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT
CFsaResource::BeginValidate(
    void
    )

/*++

Implements:

  IFsaResource::BeginValidate().

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CFsaResource::BeginValidate"),
            OLESTR("PremigratedSize = %I64d, TruncatedSize = %I64d"),
            m_premigratedSize, m_truncatedSize);

    try {

        m_oldPremigratedSize = m_premigratedSize;
        m_premigratedSize = 0;
        m_oldTruncatedSize = m_truncatedSize;
        m_truncatedSize = 0;
        m_isDoingValidate = TRUE;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::BeginValidate"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT
CFsaResource::CheckForJournal(
    BOOL *pValidateNeeded
    )

/*++

Implements:

  IFsaResource::CheckForJournal

--*/
{
    HRESULT         hr = S_OK;
    ULONGLONG       usnSize, usnId;
    DWORD           spc, bps, freeC, totalC;
    CWsbStringPtr   name;


    WsbTraceIn(OLESTR("CFsaResource::CheckForJournal"),OLESTR("volume = %ls"), m_path);
    //
    // First we check the USN journal and determine if it is out of date.
    //
    try {
        hr = WsbGetUsnJournalId(m_path, &usnId);

        if (S_OK == hr) {
            WsbTrace(OLESTR("CFsaResource::CheckForJournal - USN Journal ID = %I64x\n"),
                usnId);
            if (0 != m_usnJournalId && usnId != m_usnJournalId) {
                WsbTrace(OLESTR("CFsaResource::CheckForJournal - USN Journal ID changed from %I64\n"),
                        m_usnJournalId);
                *pValidateNeeded = TRUE;        // No match - we must validate
                // WsbAffirmHr(E_FAIL);
            }
        } else if (WSB_E_NOTFOUND == hr) {

            hr = S_OK;

            //  The journal is not active, try to create it.
            //  Make the max USN journal 1/64 the volume size.
            //
            WsbTrace(OLESTR("CFsaResource::CheckForJournal - Failed to get the journal ID for %ws\n"), m_path);

            name = m_path;
            WsbAffirmHr(name.Prepend(OLESTR("\\\\?\\")));
            if (GetDiskFreeSpace(name, &spc, &bps, &freeC, &totalC)) {
                ULONGLONG   freeBytes, totalBytes;
                ULONGLONG   minSize, maxSize;
                ULONG       freeSpaceFraction, totalSpaceFraction, minSizeMB, maxSizeMB;

                WsbTrace(OLESTR("CFsaResource::CheckForJournal - Got disk free space\n"));

                freeBytes = (ULONGLONG) spc * (ULONGLONG) bps * (ULONGLONG) freeC;
                totalBytes = (ULONGLONG) spc * (ULONGLONG) bps * (ULONGLONG) totalC;

                // Get constants for USN size calculation
                minSizeMB = FSA_USN_MIN_SIZE_DEFAULT;
                WsbAffirmHr(WsbRegistryValueUlongAsString(NULL, FSA_REGISTRY_PARMS, FSA_USN_MIN_SIZE,
                        &minSizeMB));
                minSize = (ULONGLONG)minSizeMB * (ULONGLONG)0x100000;

                maxSizeMB = FSA_USN_MAX_SIZE_DEFAULT;
                WsbAffirmHr(WsbRegistryValueUlongAsString(NULL, FSA_REGISTRY_PARMS, FSA_USN_MAX_SIZE,
                        &maxSizeMB));
                maxSize = (ULONGLONG)maxSizeMB * (ULONGLONG)0x100000;

                freeSpaceFraction = FSA_USN_FREE_SPACE_FRACTION_DEFAULT;
                WsbAffirmHr(WsbRegistryValueUlongAsString(NULL, FSA_REGISTRY_PARMS, FSA_USN_FREE_SPACE_FRACTION,
                        &freeSpaceFraction));

                totalSpaceFraction = FSA_USN_TOTAL_SPACE_FRACTION_DEFAULT;
                WsbAffirmHr(WsbRegistryValueUlongAsString(NULL, FSA_REGISTRY_PARMS, FSA_USN_TOTAL_SPACE_FRACTION,
                        &totalSpaceFraction));

                // Get a max value out of fraction-of-free=space and a constant
                //  This ensures that volume with little free space still gets a decent journal size
                usnSize = MAX( (freeBytes / freeSpaceFraction) , minSize );

                // Get a min value out of fraction-of-total-bytes and previous number
                //  This ensures that small volumes don't allocate unproportional size for the journal
                usnSize = MIN ( (totalBytes / totalSpaceFraction) , usnSize);

                // Get a min of an NTFS upper-limit const and previous number
                //  This ensures that large empty volumes don't allocate a too large journal
                usnSize = MIN ( maxSize , usnSize);

                WsbTrace(OLESTR("CFsaResource::CheckForJournal - Create USN journal - %u\n"), usnSize);

                WsbAffirmHr(WsbCreateUsnJournal(m_path, usnSize));
                WsbAffirmHr(WsbGetUsnJournalId(m_path, &m_usnJournalId));
                WsbTrace(OLESTR("CFsaResource::CheckForJournal - USN Journal ID = %I64x\n"),
                    m_usnJournalId);
            } else {
                DWORD   lErr;

                lErr = GetLastError();
                WsbTrace(OLESTR("CFsaResource::CheckForJournal - GetDiskFreeSpace failed - %x\n"), lErr);
                hr = E_FAIL;
            }
        }
    } WsbCatch(hr);


    if (hr != S_OK) {
        //
        // Problem - could not find or create the USN journal - we refuse to
        // run without it
        //
        WsbTrace(OLESTR("CFsaResource::CheckForJournal - ERROR creating/accessing the USN journal for %ws\n"),
                m_path);
        if (WSB_E_USNJ_CREATE_DISK_FULL == hr) {
            WsbLogEvent(FSA_MESSAGE_CANNOT_CREATE_USNJ_DISK_FULL, 0, NULL,
                        (OLECHAR *) m_path, NULL);
        } else if (WSB_E_USNJ_CREATE == hr) {
            WsbLogEvent(FSA_MESSAGE_CANNOT_CREATE_USNJ, 0, NULL,
                        (OLECHAR *) m_path, NULL);
        } else {
            WsbLogEvent(FSA_MESSAGE_CANNOT_ACCESS_USNJ, 0, NULL,
                        WsbHrAsString(hr), (OLECHAR *) m_path, NULL);
        }
        m_usnJournalId = (ULONGLONG) 0;

    }

    WsbTraceOut(OLESTR("CFsaResource::CheckForJournal"),OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaResource::CheckForValidate(BOOL bForceValidate)

/*++

Implements:

  IFsaResource::CheckForValidate

--*/
{
    HRESULT         hr = S_OK;
    SYSTEMTIME      sysTime;
    FILETIME        curTime;
    LARGE_INTEGER   ctime;
    CWsbStringPtr   tmpString;
    BOOL            validateNeeded = FALSE;     // Start out assuming no validate needed

    WsbTraceIn(OLESTR("CFsaResource::CheckForValidate"),OLESTR("bForceValidate"),
            WsbBoolAsString(bForceValidate));

    try {

        //
        // First we check the USN journal and determine if it is out of date.
        //
        WsbAffirmHr(CheckForJournal(&validateNeeded));

        //
        // Check the registry to see if a validate job needs to be run.  If the filter detected
        // a HSM reparse point getting set and it was not by us it sets a registry value to
        // indicate it.
        //
        try {

            WsbAffirmHr(tmpString.Alloc(32));
            swprintf((OLECHAR *) tmpString, L"%x", m_serial);
            WsbTrace(L"CFsaResource::CheckForValidate - Checking registry for validate - %ws\\%ws\n",
                FSA_VALIDATE_LOG_KEY_NAME, (OLECHAR *) tmpString);

            hr = WsbGetRegistryValueData(NULL, FSA_VALIDATE_LOG_KEY_NAME,
                    tmpString, (BYTE *) &ctime, sizeof(ctime), NULL);

            if ((hr == S_OK) || validateNeeded || bForceValidate) {
                //
                // Regardless of what value the registry entry was we set up the job for 2 hours from now.
                // The actual event may have been well in the past and the task scheduler will not like a
                // time in the past as the start time.
                //
                GetLocalTime(&sysTime);
                WsbAffirmStatus(SystemTimeToFileTime(&sysTime, &curTime));
                ctime.LowPart = curTime.dwLowDateTime;
                ctime.HighPart = curTime.dwHighDateTime;

                if (validateNeeded || bForceValidate) {
                    ctime.QuadPart += WSB_FT_TICKS_PER_MINUTE * 5;  // 5 Minutes from now if the USN journal changed
                } else {
                    ctime.QuadPart += WSB_FT_TICKS_PER_HOUR * 2;    // 2 Hours from now if restore activity took place
                }
                curTime.dwLowDateTime = ctime.LowPart;
                curTime.dwHighDateTime = ctime.HighPart;
                WsbAffirmStatus(FileTimeToSystemTime(&curTime, &sysTime));
                WsbAffirmHr(SetupValidateJob(sysTime));
                WsbLogEvent(FSA_MESSAGE_AUTO_VALIDATE, 0, NULL,
                        (OLECHAR *) m_path, NULL);
            } else {
                WsbTrace(L"CFsaResource::CheckForValidate - Registry entry not there - %ws\n", WsbHrAsString(hr));
            }
            hr = S_OK;
        } WsbCatchAndDo(hr,
            //
            // Log an event if we fail to set up the job
            //
            WsbTrace(L"CFsaResource::CheckForValidate - Failed to set the job - %x\n", hr);
            WsbLogEvent(FSA_MESSAGE_AUTOVALIDATE_SCHEDULE_FAILED, 0, NULL, WsbAbbreviatePath(m_path, 120), NULL);

        );

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::CheckForValidate"),OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CFsaResource::CompareBy(
    FSA_RESOURCE_COMPARE by
    )

/*++

Implements:

  IFsaResource::CompareBy().

--*/
{
    HRESULT                 hr = S_OK;

    m_compareBy = by;

    m_isDirty = TRUE;

    return(hr);
}


HRESULT
CFsaResource::CompareTo(
    IN IUnknown* pUnknown,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbCollectable::CompareTo().

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IFsaResource>   pResource;

    WsbTraceIn(OLESTR("CFsaResource::CompareTo"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pUnknown, E_POINTER);

        // We need the IFsaResource interface to get the value of the object.
        WsbAffirmHr(pUnknown->QueryInterface(IID_IFsaResource, (void**) &pResource));

        // Compare the rules.
        hr = CompareToIResource(pResource, pResult);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::CompareTo"), OLESTR("hr = <%ls>, result = <%ls>"),
                        WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CFsaResource::CompareToAlternatePath(
    IN OLECHAR* path,
    OUT SHORT* pResult
    )

/*++

Implements:

  IFsaResource::CompareToAlternatePath().

--*/
{
    HRESULT     hr = S_OK;
    SHORT       aResult = 0;

    WsbTraceIn(OLESTR("CFsaResource::CompareToAlternatePath"), OLESTR("path = <%ls>"), (OLECHAR *)path);

    try {

        WsbTrace(OLESTR("CFsaResource::CompareToAlternatePath - Compare %ls to %ls\n"),
            (WCHAR *) m_alternatePath, (WCHAR *) path);

        // Compare the path.
        aResult = WsbSign( _wcsicmp(m_alternatePath, path) );

        if (0 != aResult) {
            hr = S_FALSE;
        }

        if (0 != pResult) {
            *pResult = aResult;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::CompareToAlternatePath"), OLESTR("hr = <%ls>, result = <%u>"), WsbHrAsString(hr), aResult);

    return(hr);
}


HRESULT
CFsaResource::CompareToIdentifier(
    IN GUID id,
    OUT SHORT* pResult
    )

/*++

Implements:

  IFsaResource::CompareToIdentifier().

--*/
{
    HRESULT     hr = S_OK;
    SHORT       aResult = 0;

    WsbTraceIn(OLESTR("CFsaResource::CompareToIdentifier"), OLESTR(""));

    try {

        aResult = WsbSign( memcmp(&m_id, &id, sizeof(GUID)) );

        if (0 != aResult) {
            hr = S_FALSE;
        }

        if (0 != pResult) {
            *pResult = aResult;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::CompareToIdentifier"), OLESTR("hr = <%ls>, result = <%u>"), WsbHrAsString(hr), aResult);

    return(hr);
}


HRESULT
CFsaResource::CompareToIResource(
    IN IFsaResource* pResource,
    OUT SHORT* pResult
    )

/*++

Implements:

  IFsaResource::CompareToIResource().

--*/
{
    HRESULT         hr = S_OK;
    CWsbStringPtr   name;
    GUID            id;
    ULONG           serial;

    WsbTraceIn(OLESTR("CFsaResource::CompareToIResource"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pResource, E_POINTER);

        // Either compare the name or the id.
        if (m_compareBy == FSA_RESOURCE_COMPARE_PATH) {
            WsbAffirmHr(pResource->GetPath(&name, 0));
            hr = CompareToPath(name, pResult);
        } else if (m_compareBy == FSA_RESOURCE_COMPARE_ALTERNATEPATH) {
            WsbAffirmHr(pResource->GetAlternatePath(&name, 0));
            hr = CompareToAlternatePath(name, pResult);
        } else if (m_compareBy == FSA_RESOURCE_COMPARE_ID) {
            WsbAffirmHr(pResource->GetIdentifier(&id));
            hr = CompareToIdentifier(id, pResult);
        } else if (m_compareBy == FSA_RESOURCE_COMPARE_NAME) {
            WsbAffirmHr(pResource->GetName(&name, 0));
            hr = CompareToName(name, pResult);
        } else if (m_compareBy == FSA_RESOURCE_COMPARE_SERIAL) {
            WsbAffirmHr(pResource->GetSerial(&serial));
            hr = CompareToSerial(serial, pResult);
        } else if (m_compareBy == FSA_RESOURCE_COMPARE_USER_NAME) {
            WsbAffirmHr(pResource->GetUserFriendlyName(&name, 0));
            hr = CompareToUserName(name, pResult);
        } else if (m_compareBy == FSA_RESOURCE_COMPARE_STICKY_NAME) {
            WsbAffirmHr(pResource->GetStickyName(&name, 0));
            hr = CompareToStickyName(name, pResult);
        } else {
            WsbAssert(FALSE, E_FAIL);
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::CompareToIResource"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CFsaResource::CompareToName(
    IN OLECHAR* name,
    OUT SHORT* pResult
    )

/*++

Implements:

  IFsaResource::CompareToName().

--*/
{
    HRESULT     hr = S_OK;
    SHORT       aResult = 0;

    WsbTraceIn(OLESTR("CFsaResource::CompareToName"), OLESTR(""));

    try {

        // Compare the path.
        aResult = WsbSign( _wcsicmp(m_name, name) );

        if (0 != aResult) {
            hr = S_FALSE;
        }

        if (0 != pResult) {
            *pResult = aResult;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::CompareToName"), OLESTR("hr = <%ls>, result = <%u>"), WsbHrAsString(hr), aResult);

    return(hr);
}


HRESULT
CFsaResource::CompareToUserName(
    IN OLECHAR* name,
    OUT SHORT* pResult
    )

/*++

Implements:

  IFsaResource::CompareToUserName().

--*/
{
    HRESULT     hr = S_OK;
    SHORT       aResult = 0;

    WsbTraceIn(OLESTR("CFsaResource::CompareToUserName"), OLESTR(""));

    try {

        // Compare the path.
        aResult = WsbSign( _wcsicmp(m_userName, name) );

        if (0 != aResult) {
            hr = S_FALSE;
        }

        if (0 != pResult) {
            *pResult = aResult;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::CompareToUserName"), OLESTR("hr = <%ls>, result = <%u>"), WsbHrAsString(hr), aResult);

    return(hr);
}


HRESULT
CFsaResource::CompareToPath(
    IN OLECHAR* path,
    OUT SHORT* pResult
    )

/*++

Implements:

  IFsaResource::CompareToPath().

--*/
{
    HRESULT     hr = S_OK;
    SHORT       aResult = 0;

    WsbTraceIn(OLESTR("CFsaResource::CompareToPath"), OLESTR(""));

    try {

        // Compare the path.
        aResult = WsbSign( _wcsicmp(m_path, path) );

        if (0 != aResult) {
            hr = S_FALSE;
        }

        if (0 != pResult) {
            *pResult = aResult;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::CompareToPath"), OLESTR("hr = <%ls>, result = <%u>"), WsbHrAsString(hr), aResult);

    return(hr);
}


HRESULT
CFsaResource::CompareToSerial(
    IN ULONG serial,
    OUT SHORT* pResult
    )

/*++

Implements:

  IFsaResource::CompareToSerial().

--*/
{
    HRESULT     hr = S_OK;
    SHORT       aResult = 0;

    WsbTraceIn(OLESTR("CFsaResource::CompareToSerial"), OLESTR(""));

    try {

        WsbTrace(OLESTR("CFsaResource::CompareToSerial - Compare %lu to %lu\n"),
            m_serial, serial);

        // Compare the path.
        if (m_serial == serial) {
            aResult = 0;
        } else {
            aResult = 1;
        }

        if (0 != aResult) {
            hr = S_FALSE;
        }

        if (0 != pResult) {
            *pResult = aResult;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::CompareToSerial"), OLESTR("hr = <%ls>, result = <%u>"), WsbHrAsString(hr), aResult);

    return(hr);
}


HRESULT
CFsaResource::CompareToStickyName(
    IN OLECHAR* name,
    OUT SHORT* pResult
    )

/*++

Implements:

  IFsaResource::CompareToStickyName().

--*/
{
    HRESULT     hr = S_OK;
    SHORT       aResult = 0;

    WsbTraceIn(OLESTR("CFsaResource::CompareToStickyName"), OLESTR(""));

    try {

        WsbTrace(OLESTR("CFsaResource::CompareToStickyName - Compare %ws to %ws\n"),
            (WCHAR *) m_stickyName, name);

        aResult = WsbSign( _wcsicmp(m_stickyName, name) );

        if (0 != aResult) {
            hr = S_FALSE;
        }

        if (0 != pResult) {
            *pResult = aResult;
        }

        if (0 != pResult) {
            *pResult = aResult;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::CompareToStickyName"), OLESTR("hr = <%ls>, result = <%u>"), WsbHrAsString(hr), aResult);

    return(hr);
}

static
HRESULT
AddExclusion(
    const OLECHAR*         DrivePath,
    IWsbIndexedCollection* pDefaultRules,
    const OLECHAR*         ExcludePath,
    BOOL                   UserRule
)
{
    HRESULT hr = S_OK;
    try {

        // If this is resource matches the drive of the folder path, exclude the path.
        if( _wcsnicmp( DrivePath, ExcludePath, 1 ) == 0 ) {

            CComPtr<IHsmRule>               pRule;
            CComPtr<IWsbCollection>         pCollection;
            CComPtr<IHsmCriteria>           pCriteria;

            WsbAffirmHr( CoCreateInstance( CLSID_CHsmRule, NULL, CLSCTX_SERVER, IID_IHsmRule, (void**) &pRule ) );
            WsbAffirmHr( pRule->SetIsInclude( FALSE ) );
            WsbAffirmHr( pRule->SetIsUserDefined( UserRule ) );
            WsbAffirmHr( pRule->SetPath( (OLECHAR*) &ExcludePath[2] ) );
            WsbAffirmHr( pRule->SetName( OLESTR("*") ) );
    
            WsbAssertHr( CoCreateInstance( CLSID_CHsmCritAlways, NULL, CLSCTX_SERVER, IID_IHsmCriteria, (void**) &pCriteria ) );
            WsbAssertHr( pRule->Criteria( &pCollection ) );
            WsbAssertHr( pCollection->Add( pCriteria ) );
    
            WsbAffirmHr( pDefaultRules->Append( pRule ) );
            WsbTrace( L"Excluding <%ls>, <%ls>\n", ExcludePath, UserRule ? "UserRule" : "SystemRule" );

        }

    } WsbCatch( hr );
    return( hr );
}


static
HRESULT
AddShellFolderExclusion(
    const OLECHAR*         DrivePath,
    IWsbIndexedCollection* pDefaultRules,
    int                    FolderId,
    BOOL                   UserRule
)
{
    HRESULT hr = S_OK;
    try {

        OLECHAR folderPath[_MAX_PATH] = L"";
        WsbAffirmHrOk( SHGetFolderPath( 0, FolderId, 0, 0, folderPath ) );
        WsbAffirmHr( AddExclusion( DrivePath, pDefaultRules, folderPath, UserRule ) );

    } WsbCatch( hr );
    return( hr );
}


static
HRESULT
AddRegistryPathExclusion(
    const OLECHAR*         DrivePath,
    IWsbIndexedCollection* pDefaultRules,
    HKEY                   hKeyRoot,
    const OLECHAR*         KeyName,
    const OLECHAR*         ValueName,
    BOOL                   UserRule
)
{
    HRESULT hr = S_OK;
    try {

        DWORD   pathSize = 0;
        CWsbStringPtr folderPath, regValue;

        //
        // Open the Key
        //
        CRegKey key;
        WsbAffirmWin32( key.Open( hKeyRoot, KeyName, KEY_QUERY_VALUE ) );

        //
        // Get the size of the value's data and allocatate buffer
        //
        WsbAffirmWin32( key.QueryValue( 0, ValueName, &pathSize ) );
        WsbAffirmHr( regValue.Alloc( ( pathSize / sizeof( OLECHAR ) ) + 1 ) );

        //
        // Get the data and expand any environment variables
        //
        WsbAffirmWin32( key.QueryValue( regValue, ValueName, &pathSize ) );

        pathSize = ExpandEnvironmentStrings( regValue, 0, 0 );
        WsbAffirmHr( folderPath.Alloc( pathSize ) );
        pathSize = ExpandEnvironmentStrings( regValue, folderPath, pathSize );
        WsbAffirmStatus( pathSize > 0 );

        //
        // And finally add the exclusion
        //
        WsbAffirmHr( AddExclusion( DrivePath, pDefaultRules, folderPath, UserRule ) );

    } WsbCatch( hr );
    return( hr );
}


HRESULT
CFsaResource::CreateDefaultRules(
    void
    )

/*++

Implements:

  IFsaResource::CreateDefaultRules().

--*/
{
    HRESULT                         hr = S_OK;
    CComPtr<IHsmRule>               pRule;
    CComPtr<IWsbCollection>         pCollection;
    CComPtr<IWsbIndexedCollection>  pDefaultRules;
    CComPtr<IHsmCriteria>           pCriteria;

    WsbTraceIn(OLESTR("CFsaResource::CreateDefaultRules"), OLESTR(""));
    try {

        // Since we are recreating back to the default rules, remove all the existing default
        // rules.
        //
        // NOTE: This will cause any extra rules (non-default) to be removed.
        WsbAffirmHr(m_pDefaultRules->RemoveAllAndRelease());

        // We need to preserve the order of the rules, so use the indexed collection interface.
        WsbAffirmHr(m_pDefaultRules->QueryInterface(IID_IWsbIndexedCollection, (void**) &pDefaultRules));

        // Create rules to exclude the following file types:
        //  *.cur   -   cursors
        //  *.ico   -   icons
        //  *.lnk   -   shortcuts
        WsbAffirmHr(CoCreateInstance(CLSID_CHsmRule, NULL, CLSCTX_SERVER, IID_IHsmRule, (void**) &pRule));
        WsbAffirmHr(pRule->SetIsInclude(FALSE));
        WsbAffirmHr(pRule->SetIsUserDefined(FALSE));
        WsbAffirmHr(pRule->SetPath(OLESTR("\\")));
        WsbAffirmHr(pRule->SetName(OLESTR("*.cur")));

        WsbAssertHr(CoCreateInstance(CLSID_CHsmCritAlways, NULL, CLSCTX_SERVER, IID_IHsmCriteria, (void**) &pCriteria));
        WsbAssertHr(pRule->Criteria(&pCollection));
        WsbAssertHr(pCollection->Add(pCriteria));

        WsbAffirmHr(pDefaultRules->Append(pRule));
        pCollection = 0;
        pCriteria = 0;
        pRule = 0;

        WsbAffirmHr(CoCreateInstance(CLSID_CHsmRule, NULL, CLSCTX_SERVER, IID_IHsmRule, (void**) &pRule));
        WsbAffirmHr(pRule->SetIsInclude(FALSE));
        WsbAffirmHr(pRule->SetIsUserDefined(FALSE));
        WsbAffirmHr(pRule->SetPath(OLESTR("\\")));
        WsbAffirmHr(pRule->SetName(OLESTR("*.ico")));

        WsbAssertHr(CoCreateInstance(CLSID_CHsmCritAlways, NULL, CLSCTX_SERVER, IID_IHsmCriteria, (void**) &pCriteria));
        WsbAssertHr(pRule->Criteria(&pCollection));
        WsbAssertHr(pCollection->Add(pCriteria));

        WsbAffirmHr(pDefaultRules->Append(pRule));
        pCollection = 0;
        pCriteria = 0;
        pRule = 0;

        WsbAffirmHr(CoCreateInstance(CLSID_CHsmRule, NULL, CLSCTX_SERVER, IID_IHsmRule, (void**) &pRule));
        WsbAffirmHr(pRule->SetIsInclude(FALSE));
        WsbAffirmHr(pRule->SetIsUserDefined(FALSE));
        WsbAffirmHr(pRule->SetPath(OLESTR("\\")));
        WsbAffirmHr(pRule->SetName(OLESTR("*.lnk")));

        WsbAssertHr(CoCreateInstance(CLSID_CHsmCritAlways, NULL, CLSCTX_SERVER, IID_IHsmCriteria, (void**) &pCriteria));
        WsbAssertHr(pRule->Criteria(&pCollection));
        WsbAssertHr(pCollection->Add(pCriteria));

        WsbAffirmHr(pDefaultRules->Append(pRule));
        pCollection = 0;
        pCriteria = 0;
        pRule = 0;

        WsbAffirmHr( AddShellFolderExclusion( m_path, pDefaultRules, CSIDL_WINDOWS, FALSE ) );
        WsbAffirmHr( AddShellFolderExclusion( m_path, pDefaultRules, CSIDL_PROGRAM_FILES, TRUE ) );\

        WsbAffirmHr( AddRegistryPathExclusion( m_path, pDefaultRules,
                                               HKEY_LOCAL_MACHINE,
                                               WSB_PROFILELIST_REGISTRY_KEY,
                                               WSB_PROFILES_DIR_REGISTRY_VALUE,
                                               TRUE ) );
        // If this is the boot drive (i.e. C), then exclude everything in the root, since most of
        // these files are important to boot the system (better safe than sorry, fewer rules).
        if (_wcsnicmp(m_path, OLESTR("C"), 1) == 0) {

            WsbAffirmHr(CoCreateInstance(CLSID_CHsmRule, NULL, CLSCTX_SERVER, IID_IHsmRule, (void**) &pRule));
            WsbAffirmHr(pRule->SetIsInclude(FALSE));
            WsbAffirmHr(pRule->SetIsUserDefined(FALSE));
            WsbAffirmHr(pRule->SetIsUsedInSubDirs(FALSE));
            WsbAffirmHr(pRule->SetPath(OLESTR("\\")));
            WsbAffirmHr(pRule->SetName(OLESTR("*")));

            WsbAssertHr(CoCreateInstance(CLSID_CHsmCritAlways, NULL, CLSCTX_SERVER, IID_IHsmCriteria, (void**) &pCriteria));
            WsbAssertHr(pRule->Criteria(&pCollection));
            WsbAssertHr(pCollection->Add(pCriteria));

            WsbAffirmHr(pDefaultRules->Append(pRule));
            pCollection = 0;
            pCriteria = 0;
            pRule = 0;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::CreateDefaultRules"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT
CFsaResource::DoRecovery(
    void
    )

/*++

Implements:

  IFsaResourcePriv::DoRecovery().

--*/
{
    HRESULT                     hr = S_OK;
    HRESULT                     hrFindFile;
    HRESULT                     hrFindRec;
    HRESULT                     hrLoop = S_OK;
    LONGLONG                    Offset;
    GUID                        bagId;
    LONGLONG                    bagOffset;
    LONGLONG                    fileId;
    OLECHAR *                   pPath = NULL;
    LONG                        RecCount;
    ULONG                       RecStatus;
    LONGLONG                    Size;
    FSA_PLACEHOLDER             placeholder;
    CComPtr<IWsbDbSession>      pDbSession;
    CComPtr<IFsaPremigratedRec> pPremRec;
    CComPtr<IFsaScanItem>       pScanItem;
    CComPtr<IFsaScanItemPriv>   pScanItemPriv;
    CComPtr<IFsaRecoveryRec>    pRecRec;
    CComPtr<IHsmSession>        pSession;

    WsbTraceIn(OLESTR("CFsaResource::DoRecovery"), OLESTR("Path = <%ls>"), WsbAbbreviatePath(m_path,120));

    try {

        // Don't bother if we already did recovery
        WsbAffirm(!m_isRecovered, S_FALSE);

        // Don't bother if this volume isn't managed
        WsbAffirm(S_OK == IsManaged(), S_FALSE);

        // Don't bother if we don't have a premigration-list DB (since it
        // contains the recovery records)
        if (!m_isDbInitialized) {
            // Set recovered flag so we don't end up in here again
            m_isRecovered = TRUE;
            WsbThrow(S_FALSE);
        }

        // Create and Initialize a session object.
        WsbAffirmHr(CoCreateInstance(CLSID_CHsmSession, 0, CLSCTX_SERVER, IID_IHsmSession, (void**) &pSession));
        WsbAffirmHr(pSession->Start(OLESTR(""), HSM_JOB_LOG_NONE, m_managingHsm, 0, (IFsaResource*) this, 0, 0));

        //  Loop over recovery records and fix any problems
        WsbAffirmHr(m_pPremigrated->Open(&pDbSession));
        WsbAffirmHr(m_pPremigrated->GetEntity(pDbSession, RECOVERY_REC_TYPE, IID_IFsaRecoveryRec, (void**) &pRecRec));

        WsbAffirmHr(m_pPremigrated->GetEntity(pDbSession, PREMIGRATED_REC_TYPE, IID_IFsaPremigratedRec, (void**) &pPremRec));
        WsbAffirmHr(pPremRec->UseKey(PREMIGRATED_BAGID_OFFSETS_KEY_TYPE));

        WsbAffirmHr(pRecRec->First());

        while (TRUE) {

            //  Get record data
            WsbAffirmHr(pRecRec->GetBagId(&bagId));
            WsbAffirmHr(pRecRec->GetBagOffset(&bagOffset));
            WsbAffirmHr(pRecRec->GetFileId(&fileId));
            WsbAffirmHr(pRecRec->GetPath(&pPath, 0));
            WsbAffirmHr(pRecRec->GetStatus(&RecStatus));
            WsbAffirmHr(pRecRec->GetOffsetSize(&Offset, &Size));
            WsbAffirmHr(pRecRec->GetRecoveryCount(&RecCount));
            WsbTrace(OLESTR("CFsaResource::DoRecovery, FileId = %I64u, File = <%ls>, RecStatus = %lx, RecCount = %ld\n"), fileId, WsbAbbreviatePath(pPath, 120), RecStatus, RecCount);

            RecCount++;
            WsbAffirmHr(pRecRec->SetRecoveryCount(RecCount));

            //  Mark the record as being recovered (in case we crash here)
            WsbAffirmHr(pRecRec->Write());

            try {

                //  Create a scan item for this file
                hrFindFile = FindFileId(fileId, pSession, &pScanItem);

                if (SUCCEEDED(hrFindFile) && (pScanItem->IsManaged(Offset, Size) != S_FALSE)) {
                    WsbAffirmHr(pScanItem->GetPlaceholder(Offset, Size, &placeholder));
                }

                WsbAffirmHr(pPremRec->SetBagId(bagId));
                WsbAffirmHr(pPremRec->SetBagOffset(bagOffset));
                WsbAffirmHr(pPremRec->SetOffset(Offset));

                hrFindRec = pPremRec->FindEQ();

                // If the file has been deleted, is not managed by HSM or its BAG data is
                // different from the RP data, then it shouldn't be in the premigration list.
                if ( (WSB_E_NOTFOUND == hrFindFile) ||
                     (SUCCEEDED(hrFindFile) && (pScanItem->IsManaged(Offset, Size) != S_OK)) ||
                     (SUCCEEDED(hrFindFile) && (pScanItem->IsManaged(Offset, Size) == S_OK) && 
                      ((bagId != placeholder.bagId) || (bagOffset != placeholder.fileStart))) ) {

                    // If the record is in the list, then remove it and adjust the sizes.
                    // Note: The removal is not protected within a transaction since the
                    // recovery is done only during initialization or when a new volume is 
                    // managed. In both cases, the auto-truncator does not run yet.
                    if (S_OK == hrFindRec) {
                        WsbAffirmHr(pPremRec->Remove());
                        WsbAffirmHr(RemovePremigratedSize(Size));
                    } else {
                        WsbAffirmHr(RemoveTruncatedSize(Size));
                    }
                }

                else {

                    WsbAffirmHr(hrFindFile);

                    //  Check the status of the file according to the reparse point
                    if (S_OK == pScanItem->IsTruncated(Offset, Size)) {

                        //  Force a truncate, just in case
                        WsbAffirmHr(pScanItem->QueryInterface(IID_IFsaScanItemPriv, (void**)&pScanItemPriv));
                        hrLoop = pScanItemPriv->TruncateInternal(Offset, Size);

                        //  Remove from premigrated list if there
                        if (S_OK == hrFindRec) {
                            if ((S_OK == hrLoop) || (FSA_E_ITEMCHANGED == hrLoop)) {
                                WsbAffirmHr(pPremRec->Remove());
                                WsbAffirmHr(RemovePremigratedSize(Size));
                                if (S_OK == hrLoop) {
                                    WsbAffirmHr(AddTruncatedSize(Size));
                                }
                            }
                        }
                    }

                    else if (S_OK == pScanItem->IsPremigrated(Offset, Size)) {

                        //  Add to premigrated list if not there
                        if (WSB_E_NOTFOUND == hrFindRec) {
                            WsbAffirmHr(RemoveTruncatedSize(Size));
                            WsbAffirmHr(AddPremigratedSize(Size));
                            WsbAffirmHr(pPremRec->MarkAsNew());
                            WsbAffirmHr(pPremRec->Write());
                        }
                    }
                }

            } WsbCatch(hrLoop);

            if (FAILED(hrLoop)) {

                if ((RecStatus & FSA_RECOVERY_FLAG_TRUNCATING) != 0) {
                    WsbLogEvent(FSA_MESSAGE_TRUNCATE_RECOVERY_FAIL, 0, NULL, WsbAbbreviatePath(pPath, 120), WsbHrAsString(hr), 0);
                } else if ((RecStatus & FSA_RECOVERY_FLAG_RECALLING) != 0) {
                    WsbLogEvent(FSA_MESSAGE_RECALL_RECOVERY_FAIL, 0, NULL, WsbAbbreviatePath(pPath, 120), WsbHrAsString(hr), 0);
                }

                //  If we have tried enough, then get rid of the record.
                if (RecCount > 2) {
                    WsbTrace(OLESTR("CFsaResource::DoRecovery, unable to do recovery - too many attempts already\n"));
                    WsbAffirmHr(pRecRec->Remove());
                }

            } else {

                //  Log an event to commemorate our success
                WsbTrace(OLESTR("CFsaResource::DoRecovery, recovered <%ls>\n"), WsbAbbreviatePath(pPath, 120));
                if ((RecStatus & FSA_RECOVERY_FLAG_TRUNCATING) != 0) {
                    WsbLogEvent(FSA_MESSAGE_TRUNCATE_RECOVERY_OK, 0, NULL, WsbAbbreviatePath(pPath, 120), 0);
                } else if ((RecStatus & FSA_RECOVERY_FLAG_RECALLING) != 0) {
                    WsbLogEvent(FSA_MESSAGE_RECALL_RECOVERY_OK, 0, NULL, WsbAbbreviatePath(pPath, 120), 0);
                }

                //  Remove this record from the DB
                WsbAffirmHr(pRecRec->Remove());
            }

            //  Get the next one
            WsbAffirmHr(pRecRec->FindGT());

            //  Release any objects we may have created
            //  this time through the loop
            pScanItem = 0;
            pScanItemPriv = 0;

            hrLoop = S_OK;
        }

    } WsbCatch(hr);

    if (WSB_E_NOTFOUND == hr) {
        hr = S_OK;
    }

    if (pDbSession != 0) {
        m_pPremigrated->Close(pDbSession);
    }

    m_isRecovered = TRUE;

    // Now that everything is done, see if we need to start the truncator.
    WsbTrace(OLESTR("CFsaResource::DoRecovery, IsManaged = %ls, isActive = %ls\n"),
            WsbQuickString(WsbBoolAsString(IsManaged() == S_OK)),
            WsbQuickString(WsbBoolAsString(m_isActive)));

    // Make sure the truncator is started
    WsbAffirmHr(InitializePremigrationList(FALSE));

    WsbTraceOut(OLESTR("CFsaResource::DoRecovery"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaResource::EndSession(
    IN IHsmSession* pSession
    )

/*++

Implements:

  IFsaResource::EndSession().

--*/
{
    HRESULT                 hr = S_OK;
    BOOL                    bLog = TRUE;

    WsbTraceIn(OLESTR("CFsaResource::EndSession"), OLESTR(""));
    try {

        WsbAssert(0 != pSession, E_POINTER);

        // Tell the session that the scan is done.
        WsbAffirmHr(pSession->ProcessState(HSM_JOB_PHASE_SCAN, HSM_JOB_STATE_DONE, OLESTR(""), bLog));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::EndSession"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT
CFsaResource::EndValidate(
    HSM_JOB_STATE state
    )

/*++

Implements:

  IFsaResource::EndValidate().

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CFsaResource::EndValidate"),
            OLESTR("state = %ld, new PremigratedSize = %I64d, new TruncatedSize = %I64d"),
            (LONG)state, m_premigratedSize, m_truncatedSize);

    try {

        if (HSM_JOB_STATE_DONE != state) {
            m_premigratedSize = m_oldPremigratedSize;
            m_truncatedSize = m_oldTruncatedSize;
        }
        m_isDoingValidate = FALSE;

        // Make sure the truncator is running
        WsbAffirmHr(InitializePremigrationList(FALSE));
        WsbAffirmHr(m_pTruncator->KickStart());

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::EndValidate"),
            OLESTR("hr = <%ls>, PremigratedSize = %I64d, TruncatedSize = %I64d"),
            WsbQuickString(WsbHrAsString(hr)), m_premigratedSize, m_truncatedSize);
    return(hr);
}


HRESULT
CFsaResource::EnumDefaultRules(
    OUT IWsbEnum** ppEnum
    )

/*++

Implements:

  IFsaResource::EnumDefaultRules().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != ppEnum, E_POINTER);

        WsbAffirmHr(m_pDefaultRules->Enum(ppEnum));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaResource::FilterSawOpen(
    IN IHsmSession* pSession,
    IN IFsaFilterRecall* pRecall,
    IN OLECHAR* path,
    IN LONGLONG fileId,
    IN LONGLONG requestOffset,
    IN LONGLONG requestSize,
    IN FSA_PLACEHOLDER* pPlaceholder,
    IN ULONG mode,
    IN FSA_RESULT_ACTION resultAction,
    IN DWORD    threadId
    )

/*++

Implements:

  IFsaResource::FilterSawOpen().

--*/
{
    HRESULT                     hr = S_OK;
    HRESULT                     hrFind;
    CComPtr<IFsaPostIt>         pWorkItem;
    CComPtr<IHsmFsaTskMgr>      pEngine;
    CComPtr<IWsbDbSession>      pDbSession;
    CComPtr<IFsaRecoveryRec>    pRecRec;

    WsbTraceIn(OLESTR("CFsaResource::FilterSawOpen"),
            OLESTR("path = <%ls>, requestOffset = %I64d, requestSize = %I64d"),
            path, requestOffset, requestSize);
    try {

        WsbAssert(0 != pSession, E_POINTER);
        WsbAssert(0 != pRecall, E_POINTER);
        WsbAssert(0 != path, E_POINTER);
        WsbAssert(0 != pPlaceholder, E_POINTER);
        WsbAffirmHr(CoCreateInstance(CLSID_CFsaPostIt, 0, CLSCTX_SERVER, IID_IFsaPostIt, (void**) &pWorkItem));

        // Remember which recall is being used to track the open.
        WsbAffirmHr(pWorkItem->SetFilterRecall(pRecall));

        //
        // Set the session for others to know
        //
        WsbAffirmHr(pWorkItem->SetSession(pSession));
        WsbAffirmHr(pWorkItem->SetMode(mode));
        WsbAffirmHr(pWorkItem->SetFileVersionId(pPlaceholder->fileVersionId));

        //
        // Set the transfer size
        //
        WsbAffirmHr(pWorkItem->SetRequestOffset(requestOffset));
        WsbAffirmHr(pWorkItem->SetRequestSize(requestSize));
        WsbAffirmHr(pWorkItem->SetPlaceholder(pPlaceholder));

        //
        // Get a new copy of the path into the workitem
        //
        WsbAffirmHr(pWorkItem->SetPath(path));

        //
        // Need to check the mode to set the right result action. For now
        // just set it to OPEN.
        //
        WsbAffirmHr(pWorkItem->SetResultAction(resultAction));
        WsbAffirmHr(pWorkItem->SetThreadId(threadId));

        //
        // Send the request to the task manager. If the file was archived by someone other
        // than the managing HSM, then that HSM will need to be looked up.
        //
        if ( GUID_NULL != m_managingHsm &&
             memcmp(&m_managingHsm, &(pPlaceholder->hsmId), sizeof(GUID)) == 0) {
            WsbAffirmHr(GetHsmEngine(&pEngine));
        } else {
            CComPtr<IHsmServer>     pHsmServer;

            WsbAssertHr(HsmConnectFromId(HSMCONN_TYPE_HSM, (pPlaceholder->hsmId), IID_IHsmServer, (void**) &pHsmServer));
            WsbAffirmHr(pHsmServer->GetHsmFsaTskMgr(&pEngine));
        }

        //
        // Fill in the rest of the work
        //
        if (mode & FILE_OPEN_NO_RECALL) {
            WsbAffirmHr(pWorkItem->SetRequestAction(FSA_REQUEST_ACTION_FILTER_READ));
        } else {

            WsbAffirmHr(pWorkItem->SetRequestAction(FSA_REQUEST_ACTION_FILTER_RECALL));

            if (m_isDbInitialized) {
                //  Save a recovery record in case anything goes wrong
                WsbAffirmHr(m_pPremigrated->Open(&pDbSession));
                WsbAffirmHr(m_pPremigrated->GetEntity(pDbSession, RECOVERY_REC_TYPE, IID_IFsaRecoveryRec, (void**) &pRecRec));
                WsbAffirmHr(pRecRec->SetPath(path));

                // If the record already exists rewrite it, otherwise create a new record.
                hrFind = pRecRec->FindEQ();
                if (WSB_E_NOTFOUND == hrFind) {
                    WsbAffirmHr(pRecRec->MarkAsNew());
                } else if (FAILED(hrFind)) {
                    WsbThrow(hrFind);
                }

                WsbAffirmHr(pRecRec->SetFileId(fileId));
                WsbAffirmHr(pRecRec->SetOffsetSize(requestOffset, requestSize));
                WsbAffirmHr(pRecRec->SetStatus(FSA_RECOVERY_FLAG_RECALLING));
                WsbAffirmHr(pRecRec->Write());
            }
        }

        // If anything that follows fails, then we need to delete the recovery record.
        try {

            WsbTrace(OLESTR("CFsaResource::FilterSawOpen calling DoFsaWork\n"));
            WsbAffirmHr(pEngine->DoFsaWork(pWorkItem));

        } WsbCatchAndDo(hr,
            if (pRecRec != 0) {
                hrFind = pRecRec->FindEQ();
                if (hrFind == S_OK)  {
                    WsbAffirmHr(pRecRec->Remove());
                }
            }
        );

    } WsbCatch(hr);

    if (pDbSession != 0) {
        m_pPremigrated->Close(pDbSession);
    }

    WsbTraceOut(OLESTR("CFsaResource::FilterSawOpen"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT
CFsaResource::FilterSawDelete(
    IN GUID /*filterId*/,
    IN OLECHAR* path,
    IN LONGLONG /*size*/,
    IN FSA_PLACEHOLDER* pPlaceholder
    )

/*++

Implements:

  IFsaResource::FilterSawDelete().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CFsaResource::FilterSawDelete"), OLESTR("path = <%ls>"), (OLECHAR *)path);
    try {

        WsbAssert(0 != path, E_POINTER);
        WsbAssert(0 != pPlaceholder, E_POINTER);

        hr = E_NOTIMPL;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::FilterSawDelete"), OLESTR(""));
    return(hr);
}


HRESULT
CFsaResource::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaResource::FinalConstruct"), OLESTR(""));
    try {

        WsbAffirmHr(CWsbCollectable::FinalConstruct());

        m_id = GUID_NULL;
        m_compareBy = FSA_RESOURCE_COMPARE_ID;
        m_managingHsm = GUID_NULL;
        m_isActive = TRUE;
        m_isAvailable = TRUE;
        m_isDeletePending = FALSE;
        m_isRecovered = FALSE;
        m_hsmLevel = 0;
        m_premigratedSize = 0;
        m_truncatedSize = 0;
        m_isDoingValidate = FALSE;
        m_usnJournalId = (ULONGLONG) 0;
        m_lastUsnId = (LONGLONG) 0;         // Not used yet but persisted for possible future use.

        // Default Criteria (12Kb, 180 days old)
        m_manageableItemLogicalSize = 12288;
        m_manageableItemAccessTimeIsRelative = TRUE;
        m_manageableItemAccessTime = WsbLLtoFT(180 * WSB_FT_TICKS_PER_DAY);

        m_manageableItemMaxSize = 0;

        m_isUnmanageDbInitialized = FALSE;

        //Create the default rule list.
        WsbAffirmHr(CoCreateInstance(CLSID_CWsbOrderedCollection, NULL, CLSCTX_SERVER, IID_IWsbCollection, (void**) &m_pDefaultRules));

        // Create the premigrated list DB
        WsbAffirmHr(CoCreateInstance(CLSID_CFsaPremigratedDb, NULL, CLSCTX_SERVER, IID_IFsaPremigratedDb, (void**) &m_pPremigrated));
        m_isDbInitialized = FALSE;

        // Create the object for the auto truncator.
        WsbAffirmHr(CoCreateInstance(CLSID_CFsaTruncatorNTFS, NULL, CLSCTX_SERVER, IID_IFsaTruncator, (void**) &m_pTruncator));


    } WsbCatch(hr);

    if (hr == S_OK)  {
        g_InstanceCount++;
    }
    WsbTrace(OLESTR("CFsaResource::FinalConstruct: this = %p, instance count = %d\n"),
            this, g_InstanceCount);
    WsbTraceOut(OLESTR("CFsaResource::FinalConstruct"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT
CFsaResource::FinalRelease(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalRelease

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaResource::FinalRelease"), OLESTR(""));
    try {
        HSM_SYSTEM_STATE SysState;

        // Terminate Unmanage Db (If it wasn't created, nothing happens...) 
        TerminateUnmanageDb();
        m_isUnmanageDbInitialized = FALSE;
        m_pUnmanageDb = NULL;

        // Shutdown resource
        SysState.State = HSM_STATE_SHUTDOWN;
        ChangeSysState(&SysState);
        CWsbCollectable::FinalRelease();

        // Free String members
        // Note: Member objects held in smart-pointers are freed when the 
        // smart-pointer destructor is being called (as part of this object destruction)
        m_oldPath.Free();
        m_path.Free();
        m_alternatePath.Free();
        m_name.Free();
        m_fsName.Free();

    } WsbCatch(hr);

    if (hr == S_OK)  {
        g_InstanceCount--;
    }
    WsbTrace(OLESTR("CFsaResource::FinalRelease: this =  %p, instance count = %d\n"),
            this, g_InstanceCount);
    WsbTraceOut(OLESTR("CFsaResource::FinalRelease"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT
CFsaResource::FindFirst(
    IN OLECHAR* path,
    IN IHsmSession* pSession,
    OUT IFsaScanItem** ppScanItem
    )

/*++

Implements:

  IFsaResource::FindFirst().

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IFsaScanItemPriv>   pScanItem;

    try {

        WsbAssert(0 != path, E_POINTER);
        WsbAssert(0 != ppScanItem, E_POINTER);

        // Create an FsaScanItem that will scan for us.
        WsbAffirmHr(CoCreateInstance(CLSID_CFsaScanItemNTFS, NULL, CLSCTX_SERVER, IID_IFsaScanItemPriv, (void**) &pScanItem));

        // Scan starting at the specified path.
        WsbAffirmHr(pScanItem->FindFirst((IFsaResource*) this, path, pSession));

        // If we found something, then return the scan item.
        WsbAffirmHr(pScanItem->QueryInterface(IID_IFsaScanItem, (void**) ppScanItem));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaResource::FindFirstInRPIndex(
    IN IHsmSession* pSession,
    OUT IFsaScanItem** ppScanItem
    )

/*++

Implements:

  IFsaResource::FindFirstInRPIndex

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IFsaScanItemPriv>   pScanItem;

    try {

        WsbAssert(0 != ppScanItem, E_POINTER);

        // Create an FsaScanItem that will scan for us.
        WsbAffirmHr(CoCreateInstance(CLSID_CFsaScanItemNTFS, NULL, CLSCTX_SERVER, IID_IFsaScanItemPriv, (void**) &pScanItem));

        // Scan starting at the specified path.
        WsbAffirmHr(pScanItem->FindFirstInRPIndex((IFsaResource*) this, pSession));

        // If we found something, then return the scan item.
        WsbAffirmHr(pScanItem->QueryInterface(IID_IFsaScanItem, (void**) ppScanItem));

    } WsbCatch(hr);

    return(hr);
}

HRESULT
CFsaResource::FindFirstInDbIndex(
    IN IHsmSession* pSession,
    OUT IFsaScanItem** ppScanItem
    )

/*++

Implements:

  IFsaResource::FindFirstInDbIndex

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IFsaScanItemPriv>   pScanItem;

    try {

        WsbAssert(0 != ppScanItem, E_POINTER);

        // Create an FsaScanItem that will scan for us.
        WsbAffirmHr(CoCreateInstance(CLSID_CFsaScanItemNTFS, NULL, CLSCTX_SERVER, IID_IFsaScanItemPriv, (void**) &pScanItem));

        // Scan starting at the specified path.
        WsbAffirmHr(pScanItem->FindFirstInDbIndex((IFsaResource*) this, pSession));

        // If we found something, then return the scan item.
        WsbAffirmHr(pScanItem->QueryInterface(IID_IFsaScanItem, (void**) ppScanItem));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaResource::FindNext(
    IN IFsaScanItem* pScanItem
    )

/*++

Implements:

  IFsaResource::FindNext().

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IFsaScanItemPriv>   pPriv;

    try {

        WsbAssert(0 != pScanItem, E_POINTER);

        // Continue the scan.
        WsbAffirmHr(pScanItem->QueryInterface(IID_IFsaScanItemPriv, (void**) &pPriv))
        WsbAffirmHr(pPriv->FindNext());

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaResource::FindNextInRPIndex(
    IN IFsaScanItem* pScanItem
    )

/*++

Implements:

  IFsaResource::FindNextInRPIndex

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IFsaScanItemPriv>   pPriv;

    try {

        WsbAssert(0 != pScanItem, E_POINTER);

        // Continue the scan.
        WsbAffirmHr(pScanItem->QueryInterface(IID_IFsaScanItemPriv, (void**) &pPriv))
        WsbAffirmHr(pPriv->FindNextInRPIndex());

    } WsbCatch(hr);

    return(hr);
}

HRESULT
CFsaResource::FindNextInDbIndex(
    IN IFsaScanItem* pScanItem
    )

/*++

Implements:

  IFsaResource::FindNextInDbIndex

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IFsaScanItemPriv>   pPriv;

    try {

        WsbAssert(0 != pScanItem, E_POINTER);

        // Continue the scan.
        WsbAffirmHr(pScanItem->QueryInterface(IID_IFsaScanItemPriv, (void**) &pPriv))
        WsbAffirmHr(pPriv->FindNextInDbIndex());

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaResource::FindFileId(
    IN LONGLONG fileId,
    IN IHsmSession* pSession,
    OUT IFsaScanItem** ppScanItem
    )

/*++

Implements:

  IFsaResource::FindFileId().

    Creates a scan item for the given file ID.

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IFsaScanItemPriv>   pScanItem;
    CWsbStringPtr               VolumePath;
    CWsbStringPtr               filePath;
    HANDLE                      File = INVALID_HANDLE_VALUE;
    HANDLE                      VolumeHandle = INVALID_HANDLE_VALUE;
    IO_STATUS_BLOCK             IoStatusBlock;
    NTSTATUS                    Status;
    NTSTATUS                    GetNameStatus;
    OBJECT_ATTRIBUTES           ObjectAttributes;
    UNICODE_STRING              str;
    PFILE_NAME_INFORMATION      FileName;
    DWORD                       pathSize;
    OLECHAR                     *buffer = NULL;

    WsbTraceIn(OLESTR("CFsaResource::FindFileId"), OLESTR("File ID = %I64x"), fileId);

    try {
        WsbAssert(0 != ppScanItem, E_POINTER);

        // If we were passed an existing scan item (special internal code),
        // use it; otherwise, create one.
        if (NULL != *ppScanItem) {
            WsbAffirmHr((*ppScanItem)->QueryInterface(IID_IFsaScanItemPriv,
                    (void**) &pScanItem));
        } else {
            WsbAffirmHr(CoCreateInstance(CLSID_CFsaScanItemNTFS, NULL,
                    CLSCTX_SERVER, IID_IFsaScanItemPriv, (void**) &pScanItem));
        }

        //
        // Get the file path from the ID
        //


        //
        //  Open by File Reference Number (FileID),
        //  Relative opens from the Volume Handle.
        //

        VolumePath = L"\\\\.\\";
        //VolumePath = L"";
        WsbAffirmHr(VolumePath.Append(m_path));
        ((OLECHAR *) VolumePath)[wcslen(VolumePath) - 1] = L'\0';

        WsbTrace(OLESTR("CFsaResource::FindFileId - Volume path is <%ls>\n"),
                static_cast<WCHAR*>(VolumePath));

        VolumeHandle = CreateFileW( VolumePath,
                                    GENERIC_READ,
                                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                                    NULL,
                                    OPEN_EXISTING,
                                    0,
                                    NULL );

        WsbAffirmHandle(VolumeHandle);

        RtlInitUnicodeString(&str, (WCHAR *) &fileId);
        str.Length = 8;
        str.MaximumLength = 8;

        InitializeObjectAttributes( &ObjectAttributes,
                                    &str,
                                    OBJ_CASE_INSENSITIVE,
                                    VolumeHandle,
                                    NULL );

        Status = NtCreateFile(&File,
                              FILE_READ_ATTRIBUTES,
                              &ObjectAttributes,
                              &IoStatusBlock,
                              NULL,                  // AllocationSize
                              FILE_ATTRIBUTE_NORMAL,
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              FILE_OPEN,
                              FILE_OPEN_FOR_BACKUP_INTENT | FILE_OPEN_BY_FILE_ID | FILE_OPEN_REPARSE_POINT,
                              NULL,                  // EaBuffer
                              0);

        WsbTrace(OLESTR("CFsaResource::FindFileId - NtCreateFile status = %lx\n"),
                static_cast<LONG>(Status));
        if (STATUS_INVALID_PARAMETER == Status) {
            //  This seems to be the error we get if the file is missing so
            //  we translate it to something our code will understand
            WsbThrow(WSB_E_NOTFOUND);
        }
        WsbAffirmNtStatus(Status);

        GetNameStatus = STATUS_BUFFER_OVERFLOW;
        //
        // Take a guess at the path length to start with
        //
        pathSize = 256 + sizeof(FILE_NAME_INFORMATION);
        //
        // Keep trying for the name until we get an error other than buffer overflow or success.
        //

        WsbAffirmPointer((buffer = (OLECHAR *) malloc(pathSize)));

        do {
            FileName = (PFILE_NAME_INFORMATION) buffer;

            GetNameStatus = NtQueryInformationFile( File,
                                                &IoStatusBlock,
                                                FileName,
                                                pathSize - sizeof(WCHAR),  // leave room for the NULL we add
                                                FileNameInformation );

            WsbTrace(OLESTR("CFsaResource::FindFileId - NtQueryInformationFile status = %ld\n"),
                    static_cast<LONG>(GetNameStatus));

            if (GetNameStatus == STATUS_BUFFER_OVERFLOW) {
                pathSize += 256;
                LPVOID pTemp = realloc(buffer, pathSize);
                WsbAffirm(0 != pTemp, E_OUTOFMEMORY);
                buffer = (OLECHAR *)pTemp;
            }
        } while (GetNameStatus == STATUS_BUFFER_OVERFLOW);

        WsbAffirmNtStatus(GetNameStatus);

        FileName->FileName[FileName->FileNameLength / sizeof(WCHAR)] = L'\0';
        filePath = FileName->FileName;

        // Scan starting at the specified path.
        WsbAffirmHr(pScanItem->FindFirst((IFsaResource*) this, filePath, pSession));

        // If we found something, then return the scan item.
        WsbAffirmHr(pScanItem->QueryInterface(IID_IFsaScanItem, (void**) ppScanItem));

    } WsbCatch(hr);

    // Make sure we clean up
    if (INVALID_HANDLE_VALUE != VolumeHandle) {
        CloseHandle(VolumeHandle);
    }

    if (INVALID_HANDLE_VALUE != File) {
        NtClose(File);
    }

    if (buffer != NULL) {
        free(buffer);
    }

    WsbTraceOut(OLESTR("CFsaResource::FindFileId"), OLESTR("hr = <%ls>"),
            WsbHrAsString(hr));

    return(hr);
}



HRESULT
CFsaResource::FindObjectId(
    IN LONGLONG objIdHi,
    IN LONGLONG objIdLo,
    IN IHsmSession* pSession,
    OUT IFsaScanItem** ppScanItem
    )

/*++

Implements:

  IFsaResource::FindObjectId().

    Creates a scan item for the given object Id.

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IFsaScanItemPriv>   pScanItem;
    CWsbStringPtr               VolumePath;
    HANDLE                      File = INVALID_HANDLE_VALUE;
    IO_STATUS_BLOCK             IoStatusBlock;
    NTSTATUS                    Status;
    OBJECT_ATTRIBUTES           ObjectAttributes;
    LONG                        pathLength;
    WCHAR                       unicodeStringBuffer[100];
    UNICODE_STRING              unicodeString;
    FILE_INTERNAL_INFORMATION   iInfo;
    LONGLONG                    fileId;

    WsbTraceIn(OLESTR("CFsaResource::FindObjectId"), OLESTR("Object ID = %I64x %I64x"), objIdHi, objIdLo);
    try {
        WsbAssert(0 != ppScanItem, E_POINTER);

        // Create an FsaScanItem that will scan for us.
        WsbAffirmHr(CoCreateInstance(CLSID_CFsaScanItemNTFS, NULL, CLSCTX_SERVER, IID_IFsaScanItemPriv, (void**) &pScanItem));


        //
        //  Open by object ID
        //  Relative opens from the Volume Handle.
        //

        VolumePath = L"\\??\\";
        //VolumePath = L"";

        WsbAffirmHr(VolumePath.Append((WCHAR *) m_path));


        WsbTrace(OLESTR("CFsaResource::FindObjectId - Volume path is %ws.\n"), (OLECHAR *) VolumePath);
        WsbTrace(OLESTR("CFsaResource::FindObjectId - Object ID = %I64x %I64x.\n"), objIdHi, objIdLo);

        pathLength = wcslen(VolumePath);
        RtlInitUnicodeString(&unicodeString, unicodeStringBuffer);
        unicodeString.Length  = (USHORT)((pathLength * sizeof(WCHAR)) + (sizeof(LONGLONG) * 2));
        RtlCopyMemory(&unicodeString.Buffer[0], VolumePath, pathLength * sizeof(WCHAR));
        RtlCopyMemory(&unicodeString.Buffer[pathLength], &objIdHi, sizeof(LONGLONG));
        RtlCopyMemory(&unicodeString.Buffer[pathLength + (sizeof(LONGLONG) / sizeof(WCHAR))], &objIdLo, sizeof(LONGLONG));

        InitializeObjectAttributes( &ObjectAttributes,
                                    &unicodeString,
                                    OBJ_CASE_INSENSITIVE,
                                    0,
                                    NULL );

        WsbAffirmNtStatus(Status = NtCreateFile( &File,
                               FILE_READ_ATTRIBUTES,
                               &ObjectAttributes,
                               &IoStatusBlock,
                               NULL,                  // AllocationSize
                               FILE_ATTRIBUTE_NORMAL,
                               FILE_SHARE_READ | FILE_SHARE_WRITE,
                               FILE_OPEN,
                               FILE_OPEN_BY_FILE_ID | FILE_OPEN_REPARSE_POINT,
                               NULL,                  // EaBuffer
                               0 ));


        //
        // Get the file id from the object ID
        //
        WsbAffirmHr(NtQueryInformationFile(File, &IoStatusBlock, &iInfo, sizeof(FILE_INTERNAL_INFORMATION), FileInternalInformation));
        fileId = iInfo.IndexNumber.QuadPart;

        WsbAffirmNtStatus(NtClose(File));
        File = INVALID_HANDLE_VALUE;

        // Now open by file id.
        WsbAffirmHr(FindFileId(fileId, pSession, ppScanItem));

    } WsbCatch(hr);

    // Make sure we clean up.
    if (INVALID_HANDLE_VALUE != File) {
        NtClose( File );
    }

    WsbTraceOut(OLESTR("CFsaResource::FindObjectId"), OLESTR("hr = <%ls>"),
            WsbHrAsString(hr));
    return(hr);
}




HRESULT
CFsaResource::GetAlternatePath(
    OUT OLECHAR** pPath,
    IN ULONG bufferSize
    )

/*++

Implements:

  IFsaResource::GetAlternatePath().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != pPath, E_POINTER);
        WsbAffirmHr(m_alternatePath.CopyTo(pPath, bufferSize));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaResource::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaResource::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CFsaResourceNTFS;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}



HRESULT
CFsaResource::GetDbPath(
    OUT OLECHAR** pPath,
    IN ULONG bufferSize
    )

/*++

Implements:

  IFsaResource::GetDbPath().

--*/
{
    HRESULT         hr = S_OK;
    CWsbStringPtr   tmpString;

    WsbTraceIn(OLESTR("CFsaResource::GetDbPath"), OLESTR(""));
    try {

        WsbAssert(0 != pPath, E_POINTER);

        // Use a relative path under the install directory.
        WsbAffirmHr(m_pFsaServer->GetIDbPath(&tmpString, 0));
        tmpString.Append(OLESTR("\\"));

        CWsbStringPtr strGuid;
        WsbAffirmHr(WsbSafeGuidAsString(m_id, strGuid));
        tmpString.Append(strGuid);

        WsbAffirmHr(tmpString.CopyTo(pPath, bufferSize));

    } WsbCatch(hr);
    WsbTraceOut(OLESTR("CFsaResource::GetDbPath"), OLESTR("hr = <%ls>, path = <%ls)"),
        WsbHrAsString(hr), WsbPtrToStringAsString(pPath));

    return(hr);
}

HRESULT
CFsaResource::GetUnmanageDbPath(
    OUT OLECHAR** pPath,
    IN ULONG bufferSize
    )

/*++

Implements:

  IFsaResource::GetDbPath().

--*/
{
    HRESULT         hr = S_OK;
    CWsbStringPtr   tmpString;

    WsbTraceIn(OLESTR("CFsaResource::GetUnmanageDbPath"), OLESTR(""));
    try {
        WsbAssert(0 != pPath, E_POINTER);

        // Use a relative path under the install directory.
        WsbAffirmHr(m_pFsaServer->GetUnmanageIDbPath(&tmpString, 0));
        tmpString.Append(OLESTR("\\"));
        tmpString.Append(UNMANAGE_DB_PREFIX);

        CWsbStringPtr strGuid;
        WsbAffirmHr(WsbSafeGuidAsString(m_id, strGuid));
        tmpString.Append(strGuid);

        WsbAffirmHr(tmpString.CopyTo(pPath, bufferSize));

    } WsbCatch(hr);
    WsbTraceOut(OLESTR("CFsaResource::GetUnmanageDbPath"), OLESTR("hr = <%ls>, path = <%ls)"),
        WsbHrAsString(hr), WsbPtrToStringAsString(pPath));

    return(hr);
}


HRESULT
CFsaResource::GetDefaultRules(
    OUT IWsbCollection** ppCollection
    )

/*++

Implements:

  IFsaResource::GetDefaultRules().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != ppCollection, E_POINTER);

        *ppCollection = m_pDefaultRules;
        m_pDefaultRules.p->AddRef();

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaResource::GetFreeLevel(
    OUT ULONG* pLevel
    )

/*++

Implements:

  IFsaResource::GetFreeLevel().

--*/
{
    HRESULT         hr = S_OK;
    LONGLONG        total;
    LONGLONG        free;

    try {

        WsbAssert(0 != pLevel, E_POINTER);

        // Get the capacities for this resource.
        WsbAffirmHr(GetSizes(&total, &free, 0, 0));
        *pLevel = (ULONG) (((double)free / (double)total) * (double)FSA_HSMLEVEL_100);

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaResource::GetFsName(
    OUT OLECHAR** pFsName,
    IN ULONG bufferSize
    )

/*++

Implements:

  IFsaResource::GetFsName().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != pFsName, E_POINTER);
        WsbAffirmHr(m_fsName.CopyTo(pFsName, bufferSize));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaResource::GetHsmEngine(
    IHsmFsaTskMgr** ppEngine
    )

/*++

Implements:

  IFsaResource::GetHsmEngine().

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IHsmServer>     pHsmServer;

    WsbTraceIn(OLESTR("CFsaResource::GetHsmEngine"), OLESTR(""));
    try {
        WsbAssert(0 != ppEngine, E_POINTER);

        if (m_pHsmEngine != 0) {
            //
            // See if the connection is still valid
            //
            CComPtr<IHsmFsaTskMgr>  pTestInterface;
            hr = m_pHsmEngine->ContactOk();
            if (hr != S_OK) {
                // We don't have a valid
                WsbTrace(OLESTR("CHsmServer::GetHsmEngine - Current connection invalid.\n"));
                hr = S_OK;
                m_pHsmEngine = 0;
            }
        }
        // If we haven't already looked it up, then do so now.
        if (m_pHsmEngine == 0) {
            WsbAffirm(IsManaged() == S_OK, E_FAIL);
            WsbAffirmHr(HsmConnectFromId(HSMCONN_TYPE_HSM, m_managingHsm, IID_IHsmServer, (void**) &pHsmServer));
            WsbAffirmHr(pHsmServer->GetHsmFsaTskMgr(&m_pHsmEngine));
        }

        // Return the pointer that we have stored.
        *ppEngine = m_pHsmEngine;
        m_pHsmEngine.p->AddRef();

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::GetHsmEngine"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT
CFsaResource::GetHsmLevel(
    OUT ULONG* pLevel
    )

/*++

Implements:

  IFsaResource::GetHsmLevel().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != pLevel, E_POINTER);

        *pLevel = m_hsmLevel;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaResource::GetIdentifier(
    OUT GUID* pId
    )

/*++

Implements:

  IFsaResource::GetIdentifier().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != pId, E_POINTER);

        *pId = m_id;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaResource::GetLogicalName(
    OUT OLECHAR** pName,
    IN ULONG bufferSize
    )

/*++

Implements:

  IFsaResource::GetLogicalName().

--*/
{
    HRESULT         hr = S_OK;
    CWsbStringPtr   tmpString;
    CWsbStringPtr   name;

    try {

        WsbAssert(0 != pName, E_POINTER);
        WsbAssert(m_pFsaServer != 0, E_POINTER);

        WsbAffirmHr(tmpString.TakeFrom(*pName, bufferSize));

        try {

            // This is an arbitrary choice for the naming convention. Nothing has been
            // decided upon.
            WsbAffirmHr(m_pFsaServer->GetLogicalName(&tmpString, 0));
            WsbAffirmHr(GetPath(&name, 0));
            //
            // Strip off trailing \ if there
            if (name[(int) wcslen((WCHAR *) name) - 1] == L'\\') {
                name[(int) wcslen((WCHAR *) name) - 1] = L'\0';
            }
            WsbAffirmHr(tmpString.Append(OLESTR("\\")));
            WsbAffirmHr(tmpString.Append(name));

        } WsbCatch(hr);

        WsbAffirmHr(tmpString.GiveTo(pName));

    } WsbCatch(hr);

    return(hr);
}

HRESULT
CFsaResource::GetMaxFileLogicalSize(
    OUT LONGLONG* pSize
    )

/*++

Implements:

  IFsaResourcePriv::GetMaxFileLogicalSize().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != pSize, E_POINTER);

        *pSize = m_manageableItemMaxSize;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaResource::GetManageableItemLogicalSize(
    OUT LONGLONG* pSize
    )

/*++

Implements:

  IFsaResource::GetManageableItemLogicalSize().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != pSize, E_POINTER);

        *pSize = m_manageableItemLogicalSize;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaResource::GetManageableItemAccessTime(
    OUT BOOL* pIsRelative,
    OUT FILETIME* pTime
    )

/*++

Implements:

  IFsaResource::GetManageableItemAccessTime().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != pIsRelative, E_POINTER);
        WsbAssert(0 != pTime, E_POINTER);

        *pIsRelative = m_manageableItemAccessTimeIsRelative;
        *pTime = m_manageableItemAccessTime;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaResource::GetManagingHsm(
    GUID* pId
    )

/*++

Implements:

  IFsaResource::GetManagingHsm().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != pId, E_POINTER);

        *pId = m_managingHsm;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaResource::GetName(
    OUT OLECHAR** pName,
    IN ULONG bufferSize
    )

/*++

Implements:

  IFsaResource::GetName().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CFsaResource::GetName"), OLESTR(""));
    try {

        WsbAssert(0 != pName, E_POINTER);
        WsbAffirmHr(m_name.CopyTo(pName, bufferSize));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::GetName"), OLESTR("hr = <%ls>, name = <%ls>"),
        WsbHrAsString(hr), (OLECHAR *)m_name);
    return(hr);
}


HRESULT
CFsaResource::GetOldPath(
    OUT OLECHAR** pPath,
    IN ULONG bufferSize
    )

/*++

Implements:

  IFsaResource::GetOldPath().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != pPath, E_POINTER);
        WsbAffirmHr(m_oldPath.CopyTo(pPath, bufferSize));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaResource::GetPath(
    OUT OLECHAR** pPath,
    IN ULONG bufferSize
    )

/*++

Implements:

  IFsaResource::GetPath().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != pPath, E_POINTER);
        WsbAffirmHr(m_path.CopyTo(pPath, bufferSize));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaResource::GetStickyName(
    OUT OLECHAR** pPath,
    IN ULONG bufferSize
    )

/*++

Implements:

  IFsaResource::GetStickyName().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != pPath, E_POINTER);
        WsbAffirmHr(m_stickyName.CopyTo(pPath, bufferSize));

    } WsbCatch(hr);

    return(hr);
}




HRESULT
CFsaResource::GetUserFriendlyName(
    OUT OLECHAR** pPath,
    IN ULONG bufferSize
    )

/*++

Implements:

  IFsaResource::GetUserFriendlyName().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != pPath, E_POINTER);
        WsbAffirmHr(m_userName.CopyTo(pPath, bufferSize));

    } WsbCatch(hr);

    return(hr);
}



HRESULT
CFsaResource::GetPremigrated(
    IN  REFIID   riid,
    OUT void**   ppDb
    )

/*++

Implements:

  IFsaResourcePriv::GetPremigrated

--*/
{
    HRESULT         hr = S_OK;

    try {
        WsbAssert(0 != ppDb, E_POINTER);
        if (m_isDbInitialized) {
            WsbAffirmHr(m_pPremigrated->QueryInterface(riid, ppDb));
            hr = S_OK;
        } else {
            hr = WSB_E_RESOURCE_UNAVAILABLE;
        }
    } WsbCatch(hr);

    return(hr);
}

HRESULT
CFsaResource::GetUnmanageDb(
    IN  REFIID   riid,
    OUT void**   ppDb
    )

/*++

Implements:

  IFsaResourcePriv::GetUnmanageDb

--*/
{
    HRESULT         hr = S_OK;

    try {
        WsbAssert(0 != ppDb, E_POINTER);
        if ((m_isUnmanageDbInitialized) && (m_pUnmanageDb != NULL)) {
            WsbAffirmHr(m_pUnmanageDb->QueryInterface(riid, ppDb));
            hr = S_OK;
        } else {
            hr = WSB_E_RESOURCE_UNAVAILABLE;
        }
    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaResource::GetSerial(
    OUT ULONG *serial
    )

/*++

Implements:

  IFsaResourcePriv:GetSerial

--*/
{
    HRESULT                 hr = S_OK;


    WsbTraceIn(OLESTR("CFsaResource::GetSerial"), OLESTR(""));

    try {

        WsbAssert(0 != serial, E_POINTER);

        *serial = m_serial;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::GetSerial"), OLESTR("hr = <%ls>, Serial = %u"), WsbHrAsString(hr), m_serial);

    return(hr);
}


HRESULT
CFsaResource::GetSizeMax(
    OUT ULARGE_INTEGER* pSize
    )

/*++

Implements:

  IPersistStream::GetSizeMax().

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IPersistStream> pPersistStream;
    ULARGE_INTEGER          entrySize;


    WsbTraceIn(OLESTR("CFsaResource::GetSizeMax"), OLESTR(""));

    try {

        WsbAssert(0 != pSize, E_POINTER);

        // Determine the size for a rule with no criteria.
        pSize->QuadPart = WsbPersistSize((wcslen(m_name) + 1) * sizeof(OLECHAR)) +
            WsbPersistSize((wcslen(m_fsName) + 1) * sizeof(OLECHAR)) +
            WsbPersistSize((wcslen(m_path) + 1) * sizeof(OLECHAR)) +
            WsbPersistSize((wcslen(m_alternatePath) + 1) * sizeof(OLECHAR)) +
            3 * WsbPersistSizeOf(LONGLONG) +
            WsbPersistSizeOf(FILETIME) +
            WsbPersistSizeOf(BOOL) +
            3 * WsbPersistSizeOf(ULONG) +
            WsbPersistSizeOf(FSA_RESOURCE_COMPARE) +
            2 * WsbPersistSizeOf(GUID);

        // Now allocate space for the default rules list.
        WsbAffirmHr((m_pDefaultRules)->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->GetSizeMax(&entrySize));
        pSize->QuadPart += entrySize.QuadPart;
        pPersistStream = 0;

        // Now allocate space for the premigration list.
        WsbAffirmHr(((IWsbDb*)m_pPremigrated)->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->GetSizeMax(&entrySize));
        pSize->QuadPart += entrySize.QuadPart;
        pPersistStream = 0;

        // Now allocate space for truncator.
        WsbAffirmHr(m_pTruncator->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->GetSizeMax(&entrySize));
        pSize->QuadPart += entrySize.QuadPart;
        pPersistStream = 0;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pSize));

    return(hr);
}


HRESULT
CFsaResource::GetSizes(
    OUT LONGLONG* pTotal,
    OUT LONGLONG* pFree,
    OUT LONGLONG* pPremigrated,
    OUT LONGLONG* pTruncated
    )

/*++

Implements:

  IFsaResource::GetSizes().

--*/
{
    HRESULT         hr = S_OK;
    CWsbStringPtr   path;
    ULARGE_INTEGER  freeCaller;
    ULARGE_INTEGER  total;
    ULARGE_INTEGER  free;


    try {

        if ((0 != pTotal)  || (0 != pFree)) {

            WsbAffirmHr(GetPath(&path, 0));
            WsbAffirmHr(path.Prepend("\\\\?\\"));
            WsbAffirmStatus(GetDiskFreeSpaceEx(path, &freeCaller, &total, &free));

            if (0 != pTotal) {
                *pTotal = total.QuadPart;
            }

            if (0 != pFree) {
                *pFree = free.QuadPart;
            }
        }

        if (0 != pPremigrated) {
            *pPremigrated = m_premigratedSize;
        }

        if (0 != pTruncated) {
            *pTruncated = m_truncatedSize;
        }

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaResource::GetTruncator(
    IFsaTruncator** ppTruncator
    )

/*++

Implements:

  IFsaResource::GetTruncator().

--*/
{
    HRESULT                 hr = S_OK;

    try {

        WsbAssert(0 != ppTruncator, E_POINTER);

        // Return the pointer that we have stored.
        *ppTruncator = m_pTruncator;
        if (m_pTruncator != 0)  {
            m_pTruncator.p->AddRef();
        }

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaResource::GetUncPath(
    OUT OLECHAR** pPath,
    IN ULONG bufferSize
    )

/*++

Implements:

  IFsaResource::GetUncPath().

    // Returns system generated UNC path if there is one.  If not it returns WSB_E_NOTFOUND


--*/
{
    HRESULT         hr = S_OK;
    CWsbStringPtr   tmpString;
    OLECHAR         driveName[3];

    try {

        WsbAssert(0 != pPath, E_POINTER);

        // The path is either "d:\" where d is a drive letter or "Volume{GUID}" for an
        // unnamed drive. So make sure we have at least that many characters.
        //
        if (wcslen(m_path) >= 3) {

            // There is no system created UNC path to a volume without a drive letter so
            // see if the path has form of "Volume{GUID}". For a volume with no drive letter we
            // store this PNP (sticky) name as the path also.

            if (wcsstr(m_path, OLESTR("Volume{")) != 0) {
                WsbAffirmHr(tmpString.GiveTo(pPath));   // give caller an empty string back.
            }
            else {
                // The UNC path is \\ssss\d$, where ssss is the server name and d is the drive
                // letter.
                WsbAffirmHr(tmpString.TakeFrom(*pPath, bufferSize));

                WsbAffirmHr(m_pFsaServer->GetName(&tmpString, 0));
                WsbAffirmHr(tmpString.Prepend(OLESTR("\\\\")));
                WsbAffirmHr(tmpString.Append(OLESTR("\\")));
                driveName[0] = m_path[0];
                driveName[1] = L'$';
                driveName[2] = 0;

                WsbAffirmHr(tmpString.Append(driveName));

                WsbAffirmHr(tmpString.GiveTo(pPath));
            }
        } else {
            hr = WSB_E_NOTFOUND;
        }

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaResource::GetUsnId(
    OUT ULONGLONG   *usnId
    )

/*++

Implements:

  IFsaResource::GetUsnId().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != usnId, E_POINTER);

        *usnId = m_usnJournalId;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaResource::Init(
    IN IFsaServer* pFsaServer,
    IN OLECHAR* path,
    IN OLECHAR* dosName
    )

/*++

Implements:

  IFsaResourcePriv::Init().

Routine Description:

    This routine implements the COM method for testing a resource to see if it is
    'manageable' by the HSM (Remote Storage) system.  (Only NTFS-formatted
    volumes which support sparse files and reparse points are considered to be
    manageable by Sakkara.)  If the resource is manageable, it initializes the
    resource object.

Arguments:

    pFsaServer - Interface pointer to the FSA service that is scanning this resource.

    path - The long ugly PNP name that can be used if there is no drive letter for
            the resource being tested (i.e., it is mounted as a volume without a
            drive letter).

    dosName - The drive letter (if there is one) of the resource being tested.

Return Value:

    S_OK - The call succeeded (the resource being tested was found to be manageable,
            and the resource object was initialized).

    FSA_E_UNMANAGEABLE - Thrown if the resource being tested for manageability is
            found to be unmanageable.

    FSA_E_NOMEDIALOADED - Thrown if the resource being tested for manageability is
            a removable type of drive and no media is presently loaded.

    E_POINTER - Thrown if the path argument passed in is null.

    Any other value - The call failed because one of the Remote Storage or Win32 API
            calls contained internally in this method failed.  The error value returned
            is specific to the API call which failed.

--*/

{
    HRESULT         hr = FSA_E_UNMANAGABLE;
    UINT            type;
    UINT            lastErrorMode;
    BOOL            gotInfo = FALSE;
    OLECHAR         alternatePath[256];
    CWsbStringPtr   queryPath;

    WsbTraceIn(OLESTR("CFsaResource::Init"), OLESTR("path = <%ls>, dosName = <%ls>"),
                                                (OLECHAR *)path, (OLECHAR *)dosName);
    try {

        WsbAssert(0 != path, E_POINTER);

        // Determine type of drive (removable, fixed, CD-ROM, RAM or network).
        type = GetDriveType(path);

        // Only FIXED or removable media are candidates for management
        // (ignore network drives, ...).
        //
        // NOTE: For now, it has been decided not to allow removable media.
        // if ((type == DRIVE_FIXED) || (type == DRIVE_REMOVABLE)) {
        if (type == DRIVE_FIXED) {

            // Get more information about the resource. For removable drives, we want to
            // fail if no volume is located.
            m_name.Realloc(128);    // volume name
            m_fsName.Realloc(128);  // volume file system type (e.g., FAT, NTFS)

            if (type == DRIVE_REMOVABLE) {
                // Suppress OS message asking to install a volume in the drive if it is
                // found to be missing.

                // First get the current error-mode bit flags by clearing them.
                lastErrorMode = SetErrorMode(0);
                // Reset error-mode bit flags by 'or'ing them with the value which
                // suppresses critical error messages.
                SetErrorMode(lastErrorMode | SEM_FAILCRITICALERRORS);

                gotInfo = GetVolumeInformation(path, m_name, 128, &m_serial,
                                    &m_maxComponentLength, &m_fsFlags, m_fsName, 128);

                // Got resource info, reset error-mode bit flags to original setting.
                SetErrorMode(lastErrorMode);

                // Throw and abort if no volume loaded.
                WsbAffirm(gotInfo, FSA_E_NOMEDIALOADED);

            } else { // if drive is a fixed drive type:

                // This call can fail.  This should just cause a message to be logged
                // and the resource to be skipped.
                try {
                    WsbAffirmStatus(GetVolumeInformation(path, m_name, 128, &m_serial,
                                        &m_maxComponentLength, &m_fsFlags, m_fsName, 128));
                } WsbCatchAndDo(hr,
                    WsbLogEvent(FSA_MESSAGE_RSCFAILEDINIT, 0, NULL, WsbHrAsString(hr),
                                    WsbAbbreviatePath(path, 120), 0);
                    WsbThrow(FSA_E_UNMANAGABLE);
                );
            }

            // Trace out info about the volume.
            CWsbStringPtr       traceString;

            traceString = m_fsName;

            traceString.Append(OLESTR("  file system, supports ... "));

            // Note that MS removed support for Remote Storage bit flag.
            if ((m_fsFlags & FILE_SUPPORTS_REPARSE_POINTS) != 0) {
                traceString.Append(OLESTR("reparse points ... "));
            }
            if ((m_fsFlags & FILE_SUPPORTS_SPARSE_FILES) != 0) {
                traceString.Append(OLESTR("sparse files ... "));
            }

            traceString.Append(OLESTR("\n"));

            WsbTrace(traceString);

            // Currently, we only support NTFS volumes that support sparse files and
            // reparse points (since support for Remote Storage bit flag was removed).
            if ((_wcsicmp(m_fsName, OLESTR("NTFS")) == 0) &&
                ((m_fsFlags & FILE_SUPPORTS_SPARSE_FILES) != 0) &&
                ((m_fsFlags & FILE_SUPPORTS_REPARSE_POINTS) != 0)) {

                // Indicate this is a manageable volume.
                hr = S_OK;

                // Store the parent FSA, but since it is a weak reference, do not AddRef().
                m_pFsaServer = pFsaServer;

                // Store the "sticky" name - this is the long ugly PNP name that can be
                // used if there is no drive letter.  (skip the prefix - \\?\)
                m_stickyName = &path[4];

                // Store the path to the resource.  Use the drive letter if it is present
                // (dosName != NULL and contains drive letter), else store it to be the same as the "sticky name".
                if (NULL != dosName) {
                    if ((wcslen(dosName) == 2) && (dosName[wcslen(dosName)-1] == L':')) {
                        m_path = dosName;
                        m_path.Append(OLESTR("\\"));
                    } else {
                        // It is a mount point path
                        m_path = &path[4];
                    }
                } else {
                    m_path = &path[4];
                }
                WsbTrace(OLESTR("CFsaResource::Init - m_path = %ws\n"), (WCHAR *) m_path);

                // Now save the "User Friendly" name for the resource.  If there is a
                // drive letter it is used.  If it is an unnamed volume then there is
                // no user friendly name and a NULL string is stored.  The volume name
                // should also be shown in this case.
                if (NULL != dosName) {
                    m_userName = dosName;
                    m_userName.Append(OLESTR("\\"));
                } else {

                    m_userName = L"";
                }

                WsbTrace(OLESTR("CFsaResource::Init - UserPath = %ws\n"), (WCHAR *) m_userName);

                // Get the alternate path to the resource.  This requires removing the '\'
                // from the path.
                queryPath = &path[4];
                if (L'\\' == queryPath[(int) wcslen((WCHAR *) queryPath) - 1]) {
                    queryPath[(int) wcslen((WCHAR *) queryPath) - 1] = L'\0';
                }

                WsbTrace(OLESTR("CFsaResource::Init - QueryPath = %ws\n"),
                                (WCHAR *) queryPath);

                WsbAffirm(QueryDosDevice(queryPath, alternatePath, 256) != 0,
                                HRESULT_FROM_WIN32(GetLastError()));
                m_alternatePath = alternatePath;
                //
                // Get the unique id for the volume
                //
                WsbAffirmHr(ReadIdentifier());
            }
        }

        m_isDirty = TRUE;

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CFsaResource::Init"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT
CFsaResource::InitializePremigrationList(
    BOOL bStartValidateJob
    )

/*++

Routine Description:

    If this volume is managed & active & available: create or 
    open the premigration-list DB; schedule a validate job if requested; 
    if recovery is also done, start the truncator running.

Arguments:

    bStartValidateJob - If TRUE, schedule a validate job on this volume
        if we just created a new DB

Return Value:

    S_OK    - The call succeeded.
    S_FALSE - The actions were skipped because some condition was not met
    E_*     - An error occurred.

--*/
{
    HRESULT                           hr = S_OK;


    WsbTraceIn(OLESTR("CFsaResource::InitializePremigrationList"), 
            OLESTR("m_managingHsm = %ls, m_isActive = %ls, m_isAvailable = %ls, m_isDbInitialized = %ls, m_isRecovered = %ls"),
            WsbGuidAsString(m_managingHsm), WsbBoolAsString(m_isActive), 
            WsbBoolAsString(m_isAvailable), WsbBoolAsString(m_isDbInitialized),
            WsbBoolAsString(m_isRecovered));
    try {
        if ((S_OK == IsManaged()) && m_isActive && m_isAvailable) {

            // Create/open the DB if not done already
            if (!m_isDbInitialized) {
                BOOL            bCreated;
                CWsbStringPtr   dbPath;
                CComPtr<IWsbDbSys>  pDbSys;

                WsbAffirmHr(m_pFsaServer->GetIDbSys(&pDbSys));
                WsbAffirmHr(GetDbPath(&dbPath, 0));
                WsbAffirmHr(m_pPremigrated->Init(dbPath, pDbSys, &bCreated));
                m_isDbInitialized = TRUE;
                if (bCreated) {
                    // Can't have recovery records if we just created
                    // the DB
                    m_isRecovered = TRUE;
                }

                if (bCreated && bStartValidateJob) {
                    LARGE_INTEGER           ctime;
                    FILETIME                curTime;
                    SYSTEMTIME              sysTime;
                    CWsbStringPtr           tmpString;

                    // Determine if the Engine is up and running.  If it isn't
                    // we have to set a value in the registry that the Engine 
                    // will find when it comes up and it will schedule the
                    // validate job.  If the Engine is up, we can take care of
                    // scheduling the validate job ourselves.  (If we don't, the
                    // Engine won't do it until the next time it starts up.)
                    hr = WsbCheckService(NULL, APPID_RemoteStorageEngine);
                    if (S_OK != hr) {
                        //  "Schedule" a validate job to rebuild the premigration list.
                        //  This is done by putting a value in the registry since the Engine
                        //  may not be running right now so we can't set up a job.
                        WsbLogEvent(FSA_MESSAGE_PREMIGRATION_LIST_MISSING, 0, NULL,
                                (OLECHAR *) m_path, NULL);
                        WsbAffirmHr(tmpString.Alloc(32));
                        swprintf((OLECHAR *) tmpString, L"%x", m_serial);
                        GetSystemTime( &sysTime );
                        WsbAffirmStatus(SystemTimeToFileTime(&sysTime, &curTime));
                        ctime.LowPart = curTime.dwLowDateTime;
                        ctime.HighPart = curTime.dwHighDateTime;
                        WsbAffirmHr( WsbEnsureRegistryKeyExists( 0, FSA_VALIDATE_LOG_KEY_NAME ) );
                        WsbAffirmHr(WsbSetRegistryValueData(NULL, FSA_VALIDATE_LOG_KEY_NAME,
                            tmpString, (BYTE *) &ctime, sizeof(ctime)));
                    } else {
                        WsbAffirmHr(CheckForValidate(TRUE));
                    }
                }
            }

            // Start the auto-truncator if recovery is done
            if (m_pTruncator && m_isRecovered) {

                // Try starting the truncator; ignore errors (we get one if
                // truncator is already started)
                m_pTruncator->Start((IFsaResource*) this);
            }
        }
    } WsbCatch(hr);
    WsbTraceOut(OLESTR("CFsaResource::InitializePremigrationList"), OLESTR("hr = <%ls>"), 
            WsbHrAsString(hr));

    return(hr);
}

HRESULT
CFsaResource::InitializeUnmanageDb(
    void
    )

/*++

Implements:

  IFsaResourcePriv::InitializeUnmanageDb().

--*/
{
    HRESULT                           hr = S_OK;


    WsbTraceIn(OLESTR("CFsaResource::InitializeUnmanageDb"), 
            OLESTR("m_isActive = %ls, m_isAvailable = %ls, m_isUnmanageDbInitialized = %ls"), 
            WsbBoolAsString(m_isActive), WsbBoolAsString(m_isAvailable), WsbBoolAsString(m_isUnmanageDbInitialized));
    try {
        if ((S_OK == IsManaged()) && m_isActive && m_isAvailable) {
            if (! m_pUnmanageDb) {
                WsbAffirmHr(CoCreateInstance(CLSID_CFsaUnmanageDb, NULL, CLSCTX_SERVER, IID_IFsaUnmanageDb, (void**) &m_pUnmanageDb));
            }
            if (! m_isUnmanageDbInitialized) {
                BOOL                bCreated;
                CWsbStringPtr       dbPath;
                CComPtr<IWsbDbSys>  pDbSys;

                // Get (and init if necessary) the idb instance
                WsbAffirmHr(m_pFsaServer->GetUnmanageIDbSys(&pDbSys));

                // Initialize the db 
                WsbAffirmHr(GetUnmanageDbPath(&dbPath, 0));
                WsbAffirmHr(m_pUnmanageDb->Init(dbPath, pDbSys, &bCreated));

                // Init succeeded means DB must have been created 
                WsbAssert(bCreated, E_UNEXPECTED);

                m_isUnmanageDbInitialized = TRUE;
            }
        } else {
            hr = WSB_E_RESOURCE_UNAVAILABLE;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::InitializeUnmanageDb"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CFsaResource::TerminateUnmanageDb(
    void
    )

/*++

Implements:

  IFsaResourcePriv::TerminateUnmanageDb().

--*/
{
    HRESULT                           hr = S_OK;


    WsbTraceIn(OLESTR("CFsaResource::TerminateUnmanageDb"), 
            OLESTR("m_isUnmanageDbInitialized = %ls"), WsbBoolAsString(m_isUnmanageDbInitialized));
    try {
        if (m_isUnmanageDbInitialized) {
            WsbTrace(OLESTR("CFsaResource::TerminateUnmanageDb: Deleting Unmanage Db\n"));
            hr = m_pUnmanageDb->Delete(NULL, IDB_DELETE_FLAG_NO_ERROR);
            WsbTrace(OLESTR("CFsaResource::TerminateUnmanageDb: Deleting of Unmanage Db complete, hr = <%ls>\n"),
                WsbHrAsString(hr));
            if (SUCCEEDED(hr)) {
                m_isUnmanageDbInitialized = FALSE;
                m_pUnmanageDb = NULL;
            }
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::TerminateUnmanageDb"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaResource::IsActive(
    void
    )

/*++

Implements:

  IFsaResource::IsActive().

--*/
{
    return(m_isActive ? S_OK : S_FALSE);
}


HRESULT
CFsaResource::IsAvailable(
    void
    )

/*++

Implements:

  IFsaResource::IsAvailable().

--*/
{
    return(m_isAvailable ? S_OK : S_FALSE);
}


HRESULT
CFsaResource::IsDeletePending(
    void
    )

/*++

Implements:

  IFsaResource::IsDeletePending().

--*/
{
    return(m_isDeletePending ? S_OK : S_FALSE);
}



HRESULT
CFsaResource::IsManaged(
    void
    )

/*++

Implements:

  IFsaResource::IsManaged().

--*/
{
    HRESULT         hr = S_OK;

    if (memcmp(&m_managingHsm, &GUID_NULL, sizeof(GUID)) == 0) {
        hr = S_FALSE;
    }

    return(hr);
}


HRESULT
CFsaResource::Load(
    IN IStream* pStream
    )

/*++

Implements:

  IPersistStream::Load().

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IPersistStream>     pPersistStream;
    CComPtr<IWsbCollectable>    pCollectable;

    WsbTraceIn(OLESTR("CFsaResource::Load"), OLESTR(""));

    try {
        ULONG  tmp;

        WsbAssert(0 != pStream, E_POINTER);

        // Do the easy stuff, but make sure that this order matches the order
        // in the save method.
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_oldPath, 0));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_alternatePath, 0));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_name, 0));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_stickyName, 0));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_fsName, 0));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_maxComponentLength));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_fsFlags));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_id));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_isActive));
        WsbAffirmHr(WsbLoadFromStream(pStream, &tmp));
        m_compareBy = (FSA_RESOURCE_COMPARE)tmp;
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_managingHsm));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_hsmLevel));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_premigratedSize));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_truncatedSize));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_manageableItemLogicalSize));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_manageableItemAccessTimeIsRelative));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_manageableItemAccessTime));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_usnJournalId));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_lastUsnId));


        // Load the default rules list
        WsbAffirm(m_pDefaultRules != NULL, E_UNEXPECTED);
        WsbAffirmHr((m_pDefaultRules)->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Load(pStream));
        pPersistStream = 0;

        // Load the premigration list DB
        WsbAffirm(m_pPremigrated != NULL, E_UNEXPECTED);
        WsbAffirmHr(((IWsbDb*)m_pPremigrated)->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        hr = pPersistStream->Load(pStream);
        WsbTrace(OLESTR("CFsaResource::Load, DB load hr = <%ls>\n"), WsbHrAsString(hr));
        if (S_OK == hr) {
            m_isDbInitialized = TRUE;
        } else {
            m_isDbInitialized = FALSE;
            hr = S_OK;
        }

        pPersistStream = 0;

        // Load the truncator.
        WsbAffirm(m_pTruncator != NULL, E_UNEXPECTED);
        WsbAffirmHr(m_pTruncator->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Load(pStream));
        pPersistStream = 0;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaResource::Manage(
    IN IFsaScanItem* pScanItem,
    IN LONGLONG /*offset*/,
    IN LONGLONG /*size*/,
    IN GUID storagePoolId,
    IN BOOL truncate
    )

/*++

Implements:

  IFsaResource::Manage().

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IFsaPostIt>     pWorkItem;
    CComPtr<IHsmFsaTskMgr>  pEngine;
    CComPtr<IHsmSession>    pSession;
    CWsbStringPtr           tmpString;
    LONGLONG                fileVersionId;
    LONGLONG                requestSize;

    WsbTraceIn(OLESTR("CFsaResource::Manage"), OLESTR(""));

    try {

        // Make sure the  Scan Item interface is OK
        WsbAssert(pScanItem != 0, E_POINTER);
        WsbAffirmHr(CoCreateInstance(CLSID_CFsaPostIt, 0, CLSCTX_SERVER, IID_IFsaPostIt, (void**) &pWorkItem));

        // Get the data from the scan item.
        WsbAffirmHr(pScanItem->GetSession(&pSession));
        WsbAffirmHr(pWorkItem->SetSession(pSession));

        WsbAffirmHr(pScanItem->GetPathAndName(0, &tmpString, 0));
        WsbAffirmHr(pScanItem->GetVersionId(&fileVersionId));
        WsbAffirmHr(pWorkItem->SetFileVersionId(fileVersionId));

        // Currently, we only can ask for the whole file.
        WsbAffirmHr(pWorkItem->SetRequestOffset(0));
        WsbAffirmHr(pScanItem->GetLogicalSize(&requestSize));
        WsbAffirmHr(pWorkItem->SetRequestSize(requestSize));

        // Fill in the rest of the work
        WsbAffirmHr(pWorkItem->SetStoragePoolId(storagePoolId));

        WsbAffirmHr(pWorkItem->SetRequestAction(FSA_REQUEST_ACTION_PREMIGRATE));
        if (truncate) {
            WsbAffirmHr(pWorkItem->SetResultAction(FSA_RESULT_ACTION_TRUNCATE));
        } else {
            WsbAffirmHr(pWorkItem->SetResultAction(FSA_RESULT_ACTION_LIST));
        }

        // Send the request to the task manager
        WsbAffirmHr(GetHsmEngine(&pEngine));
        WsbAffirmHr(pWorkItem->SetPath(tmpString));
        WsbAffirmHr(pScanItem->PrepareForManage(0, requestSize));
        WsbAffirmHr(pEngine->DoFsaWork(pWorkItem));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::Manage"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaResource::ManagedBy(
    IN GUID hsmId,
    IN ULONG hsmLevel,
    IN BOOL release
    )

/*++

Implements:

  IFsaResource::ManagedBy().

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IHsmSession>    pSession;
    HANDLE                  threadHandle;

    WsbTraceIn(OLESTR("CFsaResource::ManagedBy"), OLESTR("HsmId - <%ls>, hsmLevel - <%lu>, release = <%ls>"),
                        WsbGuidAsString(hsmId), hsmLevel, WsbBoolAsString(release));
    try {

        // Are we releasing or acquiring a managing HSM?
        if (release) {

            // We can only release if we are the orignal owner. This is to prevent two HSMs from thinking they
            // manage the same resource at the same time. We may want a better way to do this.
            WsbAffirm(memcmp(&m_managingHsm, &hsmId, sizeof(GUID)) == 0, FSA_E_RSCALREADYMANAGED);

            // If the truncator is running, then ask it to stop.
            WsbAffirmHr(m_pTruncator->GetSession(&pSession));
            if (pSession != 0) {
                WsbAffirmHr(pSession->ProcessEvent(HSM_JOB_PHASE_ALL, HSM_JOB_EVENT_CANCEL));
            }

            // Clear out the managing Hsm.
            m_managingHsm = GUID_NULL;
            m_pHsmEngine = 0;
            m_isDeletePending = FALSE;
            threadHandle = CreateThread(0, 0, FsaStartOnStateChange, (void*) this, 0, &g_ThreadId);
            if (threadHandle != NULL) {
               CloseHandle(threadHandle);
            }

        } else {
            // Make sure there is a journal
            // At this point we don't care about the need to
            // validate
            BOOL validateNeeded;
            WsbAffirmHr(CheckForJournal(&validateNeeded));

            // Is the id changing?
            if (memcmp(&m_managingHsm, &hsmId, sizeof(GUID)) != 0) {

                // Make sure that they set it to something valid.
                WsbAssert(memcmp(&GUID_NULL, &hsmId, sizeof(GUID)) != 0, E_INVALIDARG);

                // If the truncator is running, then ask it to stop.
                WsbAffirmHr(m_pTruncator->GetSession(&pSession));
                if (pSession != 0) {
                    WsbAffirmHr(pSession->ProcessEvent(HSM_JOB_PHASE_ALL, HSM_JOB_EVENT_CANCEL));
                }

                // Create/Recreate the default rules.
                WsbAffirmHr(CreateDefaultRules());

                // Store the Id and level.
                m_managingHsm = hsmId;
                m_hsmLevel = hsmLevel;
                m_pHsmEngine = 0;

                // Do recovery (if needed) and start truncator
                if (m_isActive) {
                    if (m_isDbInitialized && !m_isRecovered) {
                        // DoRecovery will start truncator when it is done
                        WsbAffirmHr(DoRecovery());
                    } else {
                        WsbAffirmHr(InitializePremigrationList(TRUE));
                    }
                }

                threadHandle = CreateThread(0, 0, FsaStartOnStateChange, (void*) this, 0, &g_ThreadId);
                if (threadHandle != NULL) {
                   CloseHandle(threadHandle);
                }

            } else {
                BOOL DoKick = FALSE;

                if (m_hsmLevel < hsmLevel) {
                    DoKick = TRUE;
                }
                m_hsmLevel = hsmLevel;

                // Create/Recreate the default rules.
                WsbAffirmHr(CreateDefaultRules());

                // Wake up the AutoTruncator if the new level is higher
                if (DoKick) {
                    WsbAffirmHr(m_pTruncator->KickStart());
                }
            }
        }

        m_isDirty = TRUE;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::ManagedBy"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT
CFsaResource::NeedsRepair(
    void
    )

/*++

Implements:

  IFsaResource::NeedsRepair().

--*/
{
    HRESULT             hr = S_OK;
    ULONG               flag;
    IO_STATUS_BLOCK     Iosb;
    CWsbStringPtr       volumePath;
    HANDLE              volumeHandle = INVALID_HANDLE_VALUE;

    WsbTraceIn(OLESTR("CFsaResource::NeedsRepair"), OLESTR(""));

    try {

        volumePath = L"\\\\.\\";
        WsbAffirmHr(volumePath.Append(m_path));
        ((OLECHAR *) volumePath)[wcslen(volumePath) - 1] = L'\0';
        WsbAffirmHandle(volumeHandle = CreateFileW(volumePath, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL));
        WsbAffirmNtStatus(NtFsControlFile(volumeHandle, NULL, NULL, NULL, &Iosb, FSCTL_IS_VOLUME_DIRTY, NULL, 0, &flag, sizeof(flag)));
        WsbAffirmNtStatus(Iosb.Status);

        if ((flag & VOLUME_IS_DIRTY) == 0) {
            hr = S_FALSE;
        }

    } WsbCatch(hr);

    if (INVALID_HANDLE_VALUE != volumeHandle) {
        CloseHandle(volumeHandle);
    }

    WsbTraceOut(OLESTR("CFsaResource::NeedsRepair"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaResource::ProcessResult(
    IN IFsaPostIt*      pResult
    )

/*++

Implements:

  IFsaResource::ProcessResult().

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IFsaScanItem>       pScanItem;
    CComPtr<IHsmSession>        pSession;
    FILETIME                    currentTime;
    FSA_RESULT_ACTION           resultAction = FSA_RESULT_ACTION_NONE;
    FSA_PLACEHOLDER             placeholder;
    CWsbStringPtr               path;
    LONGLONG                    offset;
    LONGLONG                    size;
    ULONG                       mode;
    HRESULT                     resultHr;
    CComPtr<IFsaFilterRecall>   pRecall;
    ULONG                       completionSent = FALSE;
    LONGLONG                    usn;
    LONGLONG                    afterPhUsn;


    WsbTraceIn(OLESTR("CFsaResource::ProcessResult"), OLESTR(""));

    try {
        BOOL    wasPremigrated = FALSE;
        BOOL    wasTruncated   = FALSE;

        // Several of the actions need to know the current time, so calculate it now.
        GetSystemTimeAsFileTime(&currentTime);

        // Since the workItem session is IUnknown, QI for what we want.
        WsbAffirmHr(pResult->GetSession(&pSession));


        // Now perform the required action.
        WsbAffirmHr(pResult->GetResultAction(&resultAction));
        WsbAffirmHr(pResult->GetPlaceholder(&placeholder));
        WsbAffirmHr(pResult->GetPath(&path, 0));
        WsbAffirmHr(pResult->GetRequestOffset(&offset));
        WsbAffirmHr(pResult->GetRequestSize(&size));
        WsbAffirmHr(pResult->GetMode(&mode));
        WsbAffirmHr(pResult->GetUSN(&usn));
        WsbTrace(OLESTR("CFsaResource::ProcessResult, path = <%ls>, requestOffset = %I64d, requestSize = %I64d\n"),
            WsbAbbreviatePath(path, 120), offset, size);

        switch(resultAction) {

        case FSA_RESULT_ACTION_DELETE:
            WsbTrace(OLESTR("CFsaResource::ProcessResult - Delete\n"));
            WsbAffirmHr(FindFirst(path, pSession, &pScanItem));
            if (S_OK == pScanItem->IsPremigrated(offset, size)) {
                wasPremigrated = TRUE;
            } else if (S_OK == pScanItem->IsTruncated(offset, size)) {
                wasTruncated = TRUE;
            }
            WsbAffirmHr(pScanItem->Delete());
            if (wasPremigrated) {
                WsbAffirmHr(RemovePremigrated(pScanItem, offset, size));
            } else if (wasTruncated) {
                WsbAffirmHr(RemoveTruncated(pScanItem, offset, size));
            }
            break;

        case FSA_RESULT_ACTION_DELETEPLACEHOLDER:
            WsbTrace(OLESTR("CFsaResource::ProcessResult - Delete Placeholder\n"));
            WsbAffirmHr(FindFirst(path, pSession, &pScanItem));

            //  We shouldn't have gotten to here if the file isn't managed,
            //  but it's been known to happen
            if (S_OK == pScanItem->IsManaged(offset, size)) {
                HRESULT hrRemove = S_OK;

                if (S_OK == pScanItem->IsPremigrated(offset, size)) {
                    wasPremigrated = TRUE;
                } else if (S_OK == pScanItem->IsTruncated(offset, size)) {
                    wasTruncated = TRUE;
                }

                // RemovePremigrated needs to get some information from the placeholder, therefore, remove
                // from premigrated db first and then (regardless of the result), delete the placeholder
                if (wasPremigrated) {
                    hrRemove = RemovePremigrated(pScanItem, offset, size);
                } else if (wasTruncated) {
                    hrRemove = RemoveTruncated(pScanItem, offset, size);
                }
                WsbAffirmHr(pScanItem->DeletePlaceholder(offset, size));
                WsbAffirmHr(hrRemove);
            }

            //  Remove the recovery record if we created one
            if (m_isDbInitialized) {
                BOOL bOpenDb = FALSE;
                CComPtr<IWsbDbSession>   pDbSession;
                CComPtr<IFsaRecoveryRec> pRecRec;

                try {
                    WsbAffirmHr(m_pPremigrated->Open(&pDbSession));
                    bOpenDb = TRUE;
                    WsbAffirmHr(m_pPremigrated->GetEntity(pDbSession, RECOVERY_REC_TYPE,
                            IID_IFsaRecoveryRec, (void**) &pRecRec));
                    WsbAffirmHr(pRecRec->SetPath(path));
                    if (S_OK == pRecRec->FindEQ()) {
                        WsbAffirmHr(pRecRec->Remove());
                    }
                } WsbCatch(hr);
                if (bOpenDb) {
                    WsbAffirmHr(m_pPremigrated->Close(pDbSession));
                }
            }
            break;

        case FSA_RESULT_ACTION_LIST:
            WsbTrace(OLESTR("CFsaResource::ProcessResult - Truncate / Add to Premigration List\n"));
            WsbAffirmHr(FindFirst(path, pSession, &pScanItem));
            (placeholder).isTruncated = FALSE;
            (placeholder).migrationTime = currentTime;
            hr = pScanItem->CreatePlaceholder(offset, size, placeholder, TRUE, usn, &afterPhUsn);

            if (SUCCEEDED(hr) && (FSA_E_REPARSE_NOT_WRITTEN_FILE_CHANGED != hr)) {
                //
                // Add the file to the premigration list.  If this fails, log and error
                // and request that the validation code be run to hopefully correct this
                // problem.   This problem should not stop processing, so return OK
                //
                hr = AddPremigrated(pScanItem, offset, size, FALSE, afterPhUsn);
                if (!SUCCEEDED(hr))  {
                    WsbLogEvent(FSA_MESSAGE_FILE_NOT_IN_PREMIG_LIST, 0, NULL,  WsbAbbreviatePath(path, 120), WsbHrAsString(hr), NULL);
                    //
                    // TBD - launch validate job
                    //
                    hr = S_OK;
                }
                //
                // Tell the truncator that we have added something to the list in case we are over the level.
                // This will kick start the truncator to insure quick response.
                //
                WsbAffirmHr(m_pTruncator->KickStart());
            }

            break;

        case FSA_RESULT_ACTION_NONE:
            WsbTrace(OLESTR("CFsaResource::ProcessResult - None\n"));
            break;

        case FSA_RESULT_ACTION_OPEN:
            WsbTrace(OLESTR("CFsaResource::ProcessResult - Open (No longer placeholder)\n"));

            // If it succeeded, then update the placeholder information.
            WsbAffirmHr(pResult->GetResult(&resultHr));
            WsbAffirmHr(pResult->GetFilterRecall(&pRecall));
            WsbAssert(pRecall != 0, E_POINTER);

            if (SUCCEEDED(resultHr)) {
                WsbAffirmHr(FindFirst(path, pSession, &pScanItem));

                // The placeholder info is updated by the filter now.
            //    placeholder.recallTime = currentTime;
            //    placeholder.recallCount++;
            //    placeholder.isTruncated = FALSE;
            //    placeholder.truncateOnClose = FALSE;
            //    placeholder.premigrateOnClose = FALSE;
            //    WsbAffirmHr(pScanItem->CreatePlaceholder(offset, size, placeholder, TRUE, usn, &afterPhUsn));
            }

            // If it had succeeded, then add the file in the premigration list.
            // (This used to be done after communicating with the filter to
            // give the client time to open the file before the truncator would
            // try to retruncate it.  This is no longer needed since we do the
            // recall on first I/O not on the open.  Leaving that order created
            // a new problem: the file would have a reparse point saying it was
            // premigrated and test code could then try to retruncate it, but it
            // wouldn't be in the premigration list yet.)
            if (SUCCEEDED(resultHr)) {
                //
                // We do not need to fail the recall if we cannot add the file to the premigration list.
                // Just log a warning, if appropriate, and continue
                //
                try {
                   WsbAffirmHr(RemoveTruncated(pScanItem, offset, size));
                   WsbAffirmHr(pScanItem->GetFileUsn(&afterPhUsn));
                   WsbAffirmHr(AddPremigrated(pScanItem, offset, size, TRUE, afterPhUsn));
                } WsbCatchAndDo(hr,
                   //
                   // We failed to add it to the premigration list.  In some cases this is not an error worth
                   // reporting.  For instance, when a file is moved to another volume it is copied (causing a recall) and then
                   // deleted.  We can get an error here if the delete is pending or has completed and the failure to
                   // add the original file to the premigration list is not an error since the file is now gone.
                   //
                   if ( (hr != WSB_E_NOTFOUND) &&
                        ((hr & ~(FACILITY_NT_BIT)) != STATUS_DELETE_PENDING) ) {
                         //
                         // Log all other errors
                         //
                         WsbLogEvent(FSA_MESSAGE_FILE_NOT_IN_PREMIG_LIST, 0, NULL,
                            (OLECHAR *) m_path, WsbQuickString(WsbHrAsString(hr)), NULL);
                   }
                );
            }

            // Tell the filter that the recall attempt finished.
            hr = pRecall->HasCompleted(resultHr);
            completionSent = TRUE;

            //  Remove the recovery record if we created one
            if (m_isDbInitialized) {
                BOOL bOpenDb = FALSE;
                CComPtr<IWsbDbSession>   pDbSession;
                CComPtr<IFsaRecoveryRec> pRecRec;

                try {
                    WsbAffirmHr(m_pPremigrated->Open(&pDbSession));
                    bOpenDb = TRUE;
                    WsbAffirmHr(m_pPremigrated->GetEntity(pDbSession, RECOVERY_REC_TYPE,
                            IID_IFsaRecoveryRec, (void**) &pRecRec));
                    WsbAffirmHr(pRecRec->SetPath(path));
                    if (S_OK == pRecRec->FindEQ()) {
                        WsbAffirmHr(pRecRec->Remove());
                    }
                } WsbCatch(hr);
                if (bOpenDb) {
                    WsbAffirmHr(m_pPremigrated->Close(pDbSession));
                }
            }
            break;

        case FSA_RESULT_ACTION_PEEK:
        case FSA_RESULT_ACTION_REPARSE:
            WsbTrace(OLESTR("CFsaResource::ProcessResult - Peek/Reparse\n"));
            hr = E_NOTIMPL;
            break;

        case FSA_RESULT_ACTION_TRUNCATE:
            WsbTrace(OLESTR("CFsaResource::ProcessResult - Truncate\n"));
            WsbAffirmHr(FindFirst(path, pSession, &pScanItem));
            placeholder.isTruncated = FALSE;
            placeholder.migrationTime = currentTime;
            hr = pScanItem->CreatePlaceholder(offset, size, placeholder, TRUE, usn, &afterPhUsn);
            if (SUCCEEDED(hr) && (FSA_E_REPARSE_NOT_WRITTEN_FILE_CHANGED != hr)) {
                WsbAffirmHr(pScanItem->Truncate(offset, size));
            }
            break;

        case FSA_RESULT_ACTION_REWRITEPLACEHOLDER:
            WsbTrace(OLESTR("CFsaResource::ProcessResult - Rewrite Placeholder\n"));
            WsbAffirmHr(FindFirst(path, pSession, &pScanItem));
            WsbAffirmHr(pScanItem->CreatePlaceholder(offset, size, placeholder, TRUE, usn, &afterPhUsn));
            break;

        case FSA_RESULT_ACTION_RECALLEDDATA:
            WsbTrace(OLESTR("CFsaResource::ProcessResult - Recalled\n"));
            WsbAffirmHr(FindFirst(path, pSession, &pScanItem));
            placeholder.isTruncated = FALSE;
            placeholder.recallTime = currentTime;
            placeholder.recallCount++;
            WsbAffirmHr(pScanItem->CreatePlaceholder(offset, size, placeholder, TRUE, usn, &afterPhUsn));
            WsbAffirmHr(RemoveTruncated(pScanItem, offset, size));
            WsbAffirmHr(AddPremigrated(pScanItem, offset, size, FALSE, afterPhUsn));

            //  Remove the recovery record if we created one
            if (m_isDbInitialized) {
                BOOL bOpenDb = FALSE;
                CComPtr<IWsbDbSession>   pDbSession;
                CComPtr<IFsaRecoveryRec> pRecRec;

                try {
                    WsbAffirmHr(m_pPremigrated->Open(&pDbSession));
                    bOpenDb = TRUE;
                    WsbAffirmHr(m_pPremigrated->GetEntity(pDbSession, RECOVERY_REC_TYPE,
                            IID_IFsaRecoveryRec, (void**) &pRecRec));
                    WsbAffirmHr(pRecRec->SetPath(path));
                    if (S_OK == pRecRec->FindEQ()) {
                        WsbAffirmHr(pRecRec->Remove());
                    }
                } WsbCatch(hr);
                if (bOpenDb) {
                    WsbAffirmHr(m_pPremigrated->Close(pDbSession));
                }
            }
            break;

        case FSA_RESULT_ACTION_NORECALL:
            WsbTrace(OLESTR("CFsaResource::ProcessResult - Open without recall\n"));
            // Tell the filter that the recall attempt finished.
            WsbAffirmHr(pResult->GetResult(&resultHr));
            WsbAffirmHr(pResult->GetFilterRecall(&pRecall));
            WsbAssert(pRecall != 0, E_POINTER);
            hr = pRecall->HasCompleted(resultHr);
            completionSent = TRUE;
            break;

        case FSA_RESULT_ACTION_VALIDATE_BAD:
            WsbTrace(OLESTR("CFsaResource::ProcessResult - Validate Bad\n"));
            WsbAffirmHr(pResult->GetResult(&resultHr));
            WsbAffirmHr(FindFirst(path, pSession, &pScanItem));
            if (S_OK == pScanItem->IsPremigrated(offset, size)) {
                WsbLogEvent(FSA_MESSAGE_VALIDATE_UNMANAGED_FILE_ENGINE, 0, NULL,  WsbAbbreviatePath(path, 120), (OLECHAR *)m_path, WsbHrAsString(resultHr), WsbQuickString(WsbHrAsString(resultHr)), NULL);
                WsbAffirmHr(pScanItem->DeletePlaceholder(offset, size));
            } else if (S_OK == pScanItem->IsTruncated(offset, size)) {
                //
                //  We no longer delete bad placeholders here - let the diagnostic tool clean them up
                //  The message that is logged here has been changed to indicate that the file did not validate
                //  and will not be recallable until the problem is fixed.
                //WsbAffirmHr(pScanItem->Delete());
                WsbLogEvent(FSA_MESSAGE_VALIDATE_DELETED_FILE_ENGINE, 0, NULL,  WsbAbbreviatePath(path, 120), (OLECHAR *) m_path, WsbHrAsString(resultHr), WsbQuickString(WsbHrAsString(resultHr)), NULL);
            }
            break;

        case FSA_RESULT_ACTION_VALIDATE_OK:
            WsbTrace(OLESTR("CFsaResource::ProcessResult - Validate OK\n"));
            if (m_isDoingValidate) {
                WsbAffirmHr(FindFirst(path, pSession, &pScanItem));
                if (S_OK == pScanItem->IsPremigrated(offset, size)) {
                    WsbAffirmHr(AddPremigrated(pScanItem, offset, size, FALSE, usn));
                } else if (S_OK == pScanItem->IsTruncated(offset, size)) {
                    WsbAffirmHr(AddTruncated(pScanItem, offset, size));
                }
            }
            break;

        case FSA_RESULT_ACTION_VALIDATE_FOR_TRUNCATE_BAD:
            WsbTrace(OLESTR("CFsaResource::ProcessResult - Validate for truncate Bad\n"));
            //
            // The file did not validate - make it back into a real file
            //
            WsbAffirmHr(FindFirst(path, pSession, &pScanItem));
            if (S_OK == pScanItem->IsPremigrated(offset, size)) {
                WsbAffirmHr(pScanItem->DeletePlaceholder(offset, size));
            }
            break;

        case FSA_RESULT_ACTION_VALIDATE_FOR_TRUNCATE_OK:
            WsbTrace(OLESTR("CFsaResource::ProcessResult - Validate for truncate OK\n"));
            //
            // The file validated - go ahead and truncate it (if it has not changed)
            //
            WsbAffirmHr(FindFirst(path, pSession, &pScanItem));
            WsbAffirmHr(pScanItem->TruncateValidated(offset, size));
            break;

        default:
            WsbAssert(FALSE, E_FAIL);
            break;
        }

    } WsbCatchAndDo(hr,
        if (completionSent == FALSE) {
            switch(resultAction) {
                //
                //If it was a demand recall we must make all effort to let them know it failed
                //
                case FSA_RESULT_ACTION_OPEN:
                case FSA_RESULT_ACTION_NORECALL:
                    WsbTrace(OLESTR("CFsaResource::ProcessResult - Open (No longer placeholder)\n"));
                    // Tell the filter that the recall attempt finished.
                    pRecall = 0;        // Just in case we already had the interfae we deref it here.
                    hr = pResult->GetFilterRecall(&pRecall);
                    if (hr == S_OK) {
                        hr = pRecall->HasCompleted(E_FAIL);
                    }
                    break;
                default:
                    break;
            }
        }
    );

    WsbTraceOut(OLESTR("CFsaResource::ProcessResult"), OLESTR("hr = %ls"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaResource::ReadIdentifier(
    void
    )

/*++


--*/
{
    HRESULT                           hr = S_OK;
    CWsbStringPtr                     tmpString;
    HANDLE                            aHandle;
    ULONG                             size;
    UCHAR                             bytes[sizeof(m_id)];
    PUCHAR                            bytePtr;
    UCHAR                             buffer[sizeof(FILE_FS_VOLUME_INFORMATION)+MAX_PATH];
    PFILE_FS_VOLUME_INFORMATION       volInfo;
    NTSTATUS                          status = STATUS_SUCCESS;
    IO_STATUS_BLOCK                   ioStatus;
    WCHAR *                           wString = NULL;

    try {

        //
        // The identifier is composed of:
        //
        // 15     14       13    12    11    10    9     8   7    6     5    4    3       2    1     0
        // 0      0        0      0    <---------Volume Creation Time-------->    <Volume Serial Number>
        // We need to open a handle to the volume
        //
        tmpString = m_path;
        WsbAffirmHr(tmpString.Prepend("\\\\?\\"));

        tmpString.CopyTo(&wString);
        //
        // Remove trailing backslash in the path
        //
        wString[wcslen(wString)-1] = L'\0';

        WsbAffirmHandle(aHandle = CreateFile(wString,
                                             GENERIC_READ,
                                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                                             0,
                                             OPEN_EXISTING,
                                             FILE_ATTRIBUTE_NORMAL,
                                             0));
        WsbFree(wString);
        wString = NULL;

        try {

            volInfo = (PFILE_FS_VOLUME_INFORMATION) buffer;
            bytePtr = bytes;

            status = NtQueryVolumeInformationFile(
                                    aHandle,
                                    &ioStatus,
                                    buffer,
                                    sizeof(buffer),
                                    FileFsVolumeInformation);

            WsbAffirmNtStatus(status);
            //
            // Volume serial number forms the lower 4 bytes of the GUID
            //
            WsbAffirmHr(WsbConvertToBytes(bytePtr, volInfo->VolumeSerialNumber, &size));
            WsbAffirm(size == sizeof(volInfo->VolumeSerialNumber), E_FAIL);
            //
            // Volume creation time forms the next 8 bytes
            //
            bytePtr += size;
            WsbAffirmHr(WsbConvertToBytes(bytePtr, volInfo->VolumeCreationTime.QuadPart, &size));
            WsbAffirm(size == sizeof(volInfo->VolumeCreationTime.QuadPart), E_FAIL);
            //
            // Next 4 bytes: 0's are good as any
            //
            bytePtr += size;
            WsbAffirmHr(WsbConvertToBytes(bytePtr, (ULONG) 0, &size));
            WsbAffirm(size == sizeof(ULONG), E_FAIL);

            WsbAffirmHr(WsbConvertFromBytes(bytes, &m_id, &size));
            WsbAffirm(size == sizeof(m_id), E_FAIL);

        } WsbCatch(hr);

        WsbAffirmStatus(CloseHandle(aHandle));

        m_isDirty = TRUE;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaResource::Recall(
    IN IFsaScanItem* pScanItem,
    IN LONGLONG offset,
    IN LONGLONG size,
    IN BOOL deletePlaceholder
    )

/*++

Implements:

  IFsaResource::Recall().

--*/
{
    HRESULT                     hr = S_OK;
    HRESULT                     hrFind;
    CComPtr<IFsaPostIt>         pWorkItem;
    LONGLONG                    fileId;
    CComPtr<IHsmFsaTskMgr>      pEngine;
    CComPtr<IHsmSession>        pSession;
    CComPtr<IWsbDbSession>      pDbSession;
    CComPtr<IFsaRecoveryRec>    pRecRec;
    CWsbStringPtr               tmpString;
    FSA_PLACEHOLDER             placeholder;
    LONGLONG                    fileVersionId;


    WsbTraceIn(OLESTR("CFsaResource::Recall"), OLESTR(""));
    try {

        // Make sure the  Scan Item interface is OK
        WsbAssert(pScanItem != 0, E_FAIL);
        WsbAffirmHr(CoCreateInstance(CLSID_CFsaPostIt, 0, CLSCTX_SERVER, IID_IFsaPostIt, (void**) &pWorkItem));

        // Get the data from the scan item.
        WsbAffirmHr(pScanItem->GetSession((IHsmSession**) &(pSession)));
        WsbAffirmHr(pWorkItem->SetSession(pSession));

        WsbAffirmHr(pScanItem->GetPathAndName(0, &tmpString, 0));
        WsbAffirmHr(pWorkItem->SetPath(tmpString));

        WsbAffirmHr(pWorkItem->SetRequestOffset(offset));
        WsbAffirmHr(pWorkItem->SetRequestSize(size));

        WsbAffirmHr(pScanItem->GetPlaceholder(offset, size, &placeholder));
        WsbAffirmHr(pWorkItem->SetPlaceholder(&placeholder));

        WsbAffirmHr(pScanItem->GetVersionId(&fileVersionId));
        WsbAffirmHr(pWorkItem->SetFileVersionId(fileVersionId));


        // Fill in the rest of the work
        WsbAffirmHr(pWorkItem->SetRequestAction(FSA_REQUEST_ACTION_RECALL));
        if (deletePlaceholder) {
            WsbAffirmHr(pWorkItem->SetResultAction(FSA_RESULT_ACTION_DELETEPLACEHOLDER));
        } else {
            WsbAffirmHr(pWorkItem->SetResultAction(FSA_RESULT_ACTION_RECALLEDDATA));
        }

        // Send the request to the task manager. If the file was archived by someone other
        // than the managing HSM, then that HSM will need to be looked up.
        if ( GUID_NULL != m_managingHsm &&
             memcmp(&m_managingHsm, &(placeholder.hsmId), sizeof(GUID)) == 0) {
            WsbAffirmHr(GetHsmEngine(&pEngine));
        } else {
            CComPtr<IHsmServer>     pHsmServer;

            WsbAssertHr(HsmConnectFromId(HSMCONN_TYPE_HSM, placeholder.hsmId, IID_IHsmServer, (void**) &pHsmServer));
            WsbAffirmHr(pHsmServer->GetHsmFsaTskMgr(&pEngine));
        }

        WsbAffirmHr(pScanItem->GetFileId(&fileId));

        if (m_isDbInitialized) {
            //  Save a recovery record in case anything goes wrong
            WsbAffirmHr(m_pPremigrated->Open(&pDbSession));
            WsbAffirmHr(m_pPremigrated->GetEntity(pDbSession, RECOVERY_REC_TYPE, IID_IFsaRecoveryRec, (void**) &pRecRec));
            WsbAffirmHr(pRecRec->SetPath(tmpString));

            // If the record already exists rewrite it, otherwise create a new record.
            hrFind = pRecRec->FindEQ();
            if (WSB_E_NOTFOUND == hrFind) {
                WsbAffirmHr(pRecRec->MarkAsNew());
            } else if (FAILED(hrFind)) {
                WsbThrow(hrFind);
            }

            WsbAffirmHr(pRecRec->SetFileId(fileId));
            WsbAffirmHr(pRecRec->SetOffsetSize(offset, size));
            WsbAffirmHr(pRecRec->SetStatus(FSA_RECOVERY_FLAG_RECALLING));
            WsbAffirmHr(pRecRec->Write());
        }

        try {
            WsbAffirmHr(pEngine->DoFsaWork(pWorkItem));
        } WsbCatchAndDo(hr,
            // This FindEQ seems unnecessary, but we can't assume the
            // the Remove will work
            if (pRecRec) {
                if (SUCCEEDED(pRecRec->FindEQ())) {
                    hr = pRecRec->Remove();
                }
            }
        );

    } WsbCatch(hr);

    if (pDbSession != 0) {
        m_pPremigrated->Close(pDbSession);
    }

    WsbTraceOut(OLESTR("CFsaResource::Recall"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT
CFsaResource::RemovePremigrated(
    IN IFsaScanItem* pScanItem,
    IN LONGLONG offset,
    IN LONGLONG size
    )

/*++

Implements:

  IFsaResource::RemovePremigrated().

--*/
{
    HRESULT                     hr = S_OK;
    CWsbStringPtr               path;
    CComPtr<IWsbDbSession>      pDbSession;
    CComPtr<IFsaPremigratedRec> pRec;

    WsbTraceIn(OLESTR("CFsaResource::RemovePremigrated"), OLESTR(""));

    try {

        WsbAssert(0 != pScanItem, E_POINTER);
        WsbAffirm(m_pPremigrated != NULL, E_UNEXPECTED);

        // Open the database.
        WsbAffirmHr(m_pPremigrated->Open(&pDbSession));

        // Protect the removal with Jet transaction since the auto-truncator thread 
        // may try to remove the same record at the same time
        WsbAffirmHr(pDbSession->TransactionBegin());

        try {
            LONGLONG        itemSize;
            HRESULT         hrTemp;

            // Find the record using the bag/offsets key.
            WsbAffirmHr(m_pPremigrated->GetEntity(pDbSession, PREMIGRATED_REC_TYPE, IID_IFsaPremigratedRec, (void**) &pRec));
            WsbAffirmHr(pRec->UseKey(PREMIGRATED_BAGID_OFFSETS_KEY_TYPE));
            WsbAffirmHr(pRec->SetFromScanItem(pScanItem, offset, size, FALSE));

            // The record may already been deleted by the auto-truncator
            hrTemp = pRec->FindEQ();
            if (hrTemp == WSB_E_NOTFOUND) {
                hr = S_OK;
                WsbThrow(hr);
            }
            WsbAffirmHr(hrTemp);

            WsbAffirmHr(pRec->GetSize(&itemSize));

            // the record may be involved with another transaction with delete pending
            hrTemp = pRec->Remove();
            if (hrTemp == WSB_E_IDB_UPDATE_CONFLICT) {
                hr = S_OK;
                WsbThrow(hr);
            }
            WsbAffirmHr(hrTemp);

            // Remove the size of the section from the amount of premigrated data.
            RemovePremigratedSize(itemSize);
            m_isDirty = TRUE;

        } WsbCatch(hr);

        WsbAffirmHr(pDbSession->TransactionEnd());

        WsbAffirmHr(m_pPremigrated->Close(pDbSession));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::RemovePremigrated"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaResource::RemoveTruncated(
    IN IFsaScanItem* /*pScanItem*/,
    IN LONGLONG /*offset*/,
    IN LONGLONG size
    )

/*++

Implements:

  IFsaResource::RemoveTruncated().

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaResource::RemoveTruncated"), OLESTR(""));

    try {

        WsbAffirmHr(RemoveTruncatedSize(size));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::RemoveTruncated"),
            OLESTR("hr = <%ls>, m_truncatedSize = %I64d"), WsbHrAsString(hr),
            m_truncatedSize);

    return(hr);
}


HRESULT
CFsaResource::RemoveTruncatedSize(
    IN LONGLONG size
    )

/*++

Implements:

  IFsaResource::RemoveTruncatedSize().

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaResource::RemoveTruncatedSize"), OLESTR(""));

    try {

        m_truncatedSize = max(0, m_truncatedSize - size);
        m_isDirty = TRUE;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::RemoveTruncatedSize"),
            OLESTR("hr = <%ls>, m_truncatedSize = %I64d"), WsbHrAsString(hr),
            m_truncatedSize);

    return(hr);
}


HRESULT
CFsaResource::RemovePremigratedSize(
    IN LONGLONG size
    )

/*++

Implements:

  IFsaResourcePriv::RemovePremigratedSize().

--*/
{
    WsbTraceIn(OLESTR("CFsaResource::RemovePremigratedSize"),
            OLESTR("m_premigratedSize = %I64d"), m_premigratedSize);

    m_isDirty = TRUE;
    if (size > m_premigratedSize) {
        m_premigratedSize = 0;
    } else {
        m_premigratedSize -= size;
    }
    WsbTraceOut(OLESTR("CFsaResource::RemovePremigratedSize"),
            OLESTR("m_premigratedSize = %I64d"), m_premigratedSize);

    return(S_OK);
}


HRESULT
CFsaResource::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )

/*++

Implements:

  IPersistStream::Save().

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IPersistStream> pPersistStream;

    WsbTraceIn(OLESTR("CFsaResource::Save"), OLESTR("clearDirty = <%ls>"),
                                                WsbBoolAsString(clearDirty));

    try {
        WsbAssert(0 != pStream, E_POINTER);

        // Do the easy stuff, but make sure that this order matches the order
        // in the Load() method.

        // Save the path by which this resource is/was last known.  Note the
        // Load() method reads it back into the resource's 'm_oldPath' field.
        if ( m_path == NULL ) {
            WsbAffirmHr(WsbSaveToStream(pStream, m_oldPath));
        }
        else {
            WsbAffirmHr(WsbSaveToStream(pStream, m_path));
        }
        WsbAffirmHr(WsbSaveToStream(pStream, m_alternatePath));
        WsbAffirmHr(WsbSaveToStream(pStream, m_name));
        WsbAffirmHr(WsbSaveToStream(pStream, m_stickyName));
        WsbAffirmHr(WsbSaveToStream(pStream, m_fsName));
        WsbAffirmHr(WsbSaveToStream(pStream, m_maxComponentLength));
        WsbAffirmHr(WsbSaveToStream(pStream, m_fsFlags));
        WsbAffirmHr(WsbSaveToStream(pStream, m_id));
        WsbAffirmHr(WsbSaveToStream(pStream, m_isActive));
        WsbAffirmHr(WsbSaveToStream(pStream, (ULONG) m_compareBy));
        WsbAffirmHr(WsbSaveToStream(pStream, m_managingHsm));
        WsbAffirmHr(WsbSaveToStream(pStream, m_hsmLevel));
        WsbAffirmHr(WsbSaveToStream(pStream, m_premigratedSize));
        WsbAffirmHr(WsbSaveToStream(pStream, m_truncatedSize));
        WsbAffirmHr(WsbSaveToStream(pStream, m_manageableItemLogicalSize));
        WsbAffirmHr(WsbSaveToStream(pStream, m_manageableItemAccessTimeIsRelative));
        WsbAffirmHr(WsbSaveToStream(pStream, m_manageableItemAccessTime));
        WsbAffirmHr(WsbSaveToStream(pStream, m_usnJournalId));
        WsbAffirmHr(WsbSaveToStream(pStream, m_lastUsnId));

        // Save off the default rules.
        WsbAffirmHr(m_pDefaultRules->QueryInterface(IID_IPersistStream,
                    (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Save(pStream, clearDirty));
        pPersistStream = 0;

        // Save off the premigration list.
        WsbAffirmHr(((IWsbDb*)m_pPremigrated)->QueryInterface(IID_IPersistStream,
                    (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Save(pStream, clearDirty));
        pPersistStream = 0;

        // Save off the truncator.
        WsbAffirmHr(m_pTruncator->QueryInterface(IID_IPersistStream,
                    (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Save(pStream, clearDirty));
        pPersistStream = 0;

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaResource::SetAlternatePath(
    IN OLECHAR* path
    )

/*++

Implements:

  IFsaResourcePriv::SetAlternatePath().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != path, E_POINTER);
        m_alternatePath = path;

        m_isDirty = TRUE;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaResource::SetHsmLevel(
    IN ULONG level
    )

/*++

Implements:

  IFsaResource::SetHsmLevel().

--*/
{
    BOOL            DoKick = FALSE;
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CFsaResource::SetHsmLevel"),
            OLESTR("current level = %lx, new level = %lx"), m_hsmLevel, level);

    if (m_hsmLevel < level) {
        DoKick = TRUE;
    }
    m_hsmLevel = level;

    // Wake up the AutoTruncator if the new level is higher
    if (DoKick) {
        WsbAffirmHr(m_pTruncator->KickStart());
    }

    m_isDirty = TRUE;

    WsbTraceOut(OLESTR("CFsaResource::SetHsmLevel"), OLESTR("hr = <%ls>"),
            WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaResource::SetIdentifier(
    IN GUID id
    )

/*++

Implements:

  IFsaResourcePriv::SetIdentifier().

--*/
{
    HRESULT         hr = S_OK;

    m_id = id;

    m_isDirty = TRUE;

    return(hr);
}


HRESULT
CFsaResource::SetIsActive(
    BOOL isActive
    )

/*++

Implements:

  IFsaResource::SetIsActive().

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IHsmSession>        pSession;

    WsbTraceIn(OLESTR("CFsaResource::SetIsActive"), OLESTR(""));
    // If the flag is changing values, then we may need to do something to the truncator.
    try  {
        if (m_isActive != isActive) {

            // Change the flag.
            m_isActive = isActive;

            // If we are becoming active, then we need to start the truncator. Otherwise we need to stop it.
            if (m_isActive) {

                // If we are managed & done with recovery, then the truncator should be running.
                if (IsManaged() == S_OK && m_isRecovered) {

                    // Try to start the truncator
                    WsbAffirmHr(InitializePremigrationList(TRUE));
                }
            } else {

                // If the truncator is running, then ask it to stop.
                WsbAffirmHr(m_pTruncator->GetSession(&pSession));
                if (pSession != 0) {
                    WsbAffirmHr(pSession->ProcessEvent(HSM_JOB_PHASE_ALL, HSM_JOB_EVENT_CANCEL));
                }
            }

        } else {
            m_isActive = isActive;
        }

        m_isDirty = TRUE;
    } WsbCatch( hr );

    WsbTraceOut(OLESTR("CFsaResource::SetIsActive"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT
CFsaResource::SetIsAvailable(
    BOOL isAvailable
    )

/*++

Implements:

  IFsaResource::SetIsAvailable().

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaResource::SetIsAvailable"), OLESTR(""));

    // Change the flag.
    m_isAvailable = isAvailable;

    WsbTraceOut(OLESTR("CFsaResource::SetIsAvailable"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}



HRESULT
CFsaResource::SetIsDeletePending(
    BOOL isDeletePending
    )

/*++

Implements:

  IFsaResource::SetIsDeletePending().

--*/
{
    HRESULT                     hr = S_OK;
    HANDLE                      threadHandle;

    WsbTraceIn(OLESTR("CFsaResource::SetIsDeletePending"), OLESTR(""));

    // Change the flag.
    m_isDeletePending = isDeletePending;

    threadHandle = CreateThread(0, 0, FsaStartOnStateChange, (void*) this, 0, &g_ThreadId);
    if (threadHandle != NULL) {
       CloseHandle(threadHandle);
    }

    WsbTraceOut(OLESTR("CFsaResource::SetIsDeletePending"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT
CFsaResource::SetManageableItemLogicalSize(
    IN LONGLONG size
    )

/*++

Implements:

  IFsaResource::SetManageableItemLogicalSize().

--*/
{
    m_manageableItemLogicalSize = size;

    return(S_OK);
}


HRESULT
CFsaResource::SetManageableItemAccessTime(
    IN BOOL isRelative,
    IN FILETIME time
    )

/*++

Implements:

  IFsaResource::SetManageableItemAccessTime().

--*/
{
    m_manageableItemAccessTimeIsRelative = isRelative;
    m_manageableItemAccessTime = time;

    return(S_OK);
}


HRESULT
CFsaResource::SetName(
    IN OLECHAR* name
    )

/*++

Implements:

  IFsaResourcePriv::SetName().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != name, E_POINTER);
        m_name = name;

        m_isDirty = TRUE;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaResource::SetOldPath(
    IN OLECHAR* oldPath
    )

/*++

Implements:

  IFsaResourcePriv::SetOldPath().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != oldPath, E_POINTER);
        m_oldPath = oldPath;

        m_isDirty = TRUE;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaResource::SetPath(
    IN OLECHAR* path
    )

/*++

Implements:

  IFsaResourcePriv::SetPath().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != path, E_POINTER);
        m_path = path;

        m_isDirty = TRUE;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaResource::SetSerial(
    IN ULONG serial
    )

/*++

Implements:

  IFsaResourcePriv::SetSerial().

--*/
{
    HRESULT         hr = S_OK;

    try {

        m_serial = serial;

        m_isDirty = TRUE;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaResource::SetStickyName(
    IN OLECHAR* name
    )

/*++

Implements:

  IFsaResourcePriv::SetStickyName().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != name, E_POINTER);
        m_stickyName = name;

        m_isDirty = TRUE;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaResource::SetUserFriendlyName(
    IN OLECHAR* name
    )

/*++

Implements:

  IFsaResourcePriv::SetUserFriendlyName().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != name, E_POINTER);
        m_userName = name;

        m_isDirty = TRUE;

    } WsbCatch(hr);

    return(hr);
}



HRESULT
CFsaResource::ChangeSysState(
    IN OUT HSM_SYSTEM_STATE* pSysState
    )

/*++

Implements:

  IHsmSystemState::ChangeSysState().

--*/

{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaResource::ChangeSysState"), OLESTR(""));

    try {

        //
        // Make sure the truncater is stopped so it won't
        // try to use the database
        //
        if (m_pTruncator) {
            CComPtr<IHsmSession>    pSession;

            WsbAffirmHr(m_pTruncator->GetSession(&pSession));
            if (pSession != 0) {
                if (pSysState->State & HSM_STATE_SHUTDOWN) {
                    WsbAffirmHr(pSession->ProcessEvent(HSM_JOB_PHASE_ALL, HSM_JOB_EVENT_CANCEL));
                }
            }
            m_pTruncator->ChangeSysState(pSysState);
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::ChangeSysState"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaResource::StartJob(
    IN OLECHAR* startingPath,
    IN IHsmSession* pSession
    )

/*++

Implements:

  IFsaResource::StartJob().

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IHsmScanner>    pScanner;

    WsbTraceIn(OLESTR("CFsaResource::StartJob"), OLESTR("starting path = %ls"), startingPath);

    try {

        WsbAssert(0 != pSession, E_POINTER);

        // Get file-max-size (this is updated in the Registry by the Engine according to max media size)
        DWORD dwMaxSize = 0;
        if (WsbGetRegistryValueDWORD(NULL, HSM_ENGINE_REGISTRY_STRING, HSM_MAX_FILE_TO_MIGRATE, &dwMaxSize) == S_OK) {
            // Trunslate to bytes
            WsbTrace(OLESTR("CFsaResource::StartJob: Setting maximum size for manageable files to %lu MB\n"), dwMaxSize);
            m_manageableItemMaxSize = ((LONGLONG)dwMaxSize) * 1024 * 1024;
        }

        // Create an initialize the scanner.
        WsbAffirmHr(CoCreateInstance(CLSID_CHsmScanner, 0, CLSCTX_SERVER, IID_IHsmScanner, (void**) &pScanner));
        WsbAffirmHr(pScanner->Start(pSession, startingPath));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::StartJob"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CFsaResource::StartJobSession(
    IN IHsmJob* pJob,
    IN ULONG subRunId,
    OUT IHsmSession** ppSession
    )

/*++

Implements:

  IFsaResource::StartJobSession().

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IHsmSession>    pSession;
    GUID                    hsmId;
    ULONG                   runId;
    CWsbStringPtr           name;

    WsbTraceIn(OLESTR("CFsaResource::StartJobSession"), OLESTR(""));

    try {

        WsbAssert(0 != pJob, E_POINTER);
        WsbAssert(0 != ppSession, E_POINTER);
        *ppSession = 0;

        // Create and Initialize a session object.
        WsbAffirmHr(CoCreateInstance(CLSID_CHsmSession, 0, CLSCTX_SERVER, IID_IHsmSession, (void**) &pSession));

        WsbAffirmHr(pJob->GetHsmId(&hsmId));
        WsbAffirmHr(pJob->GetRunId(&runId));
        WsbAffirmHr(pJob->GetName(&name, 0));
        WsbAffirmHr(pSession->Start(name, HSM_JOB_LOG_NORMAL, hsmId, pJob, (IFsaResource*) this, runId, subRunId));

        // Return the session to the caller.
        *ppSession = pSession;
        pSession.p->AddRef();

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::StartJobSession"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CFsaResource::SetupValidateJob(SYSTEMTIME runTime)
{

    HRESULT hr = S_OK;
    CComPtr<IWsbCreateLocalObject>  pLocalObject;
    CComPtr <IWsbIndexedCollection> pJobs;
    CComPtr<IHsmJob>                pExistJob;
    CComPtr<IHsmJob>                pNewJob;
    CComPtr<IHsmServer>             pHsmServer;
    CWsbStringPtr                   pszExistJobName;
    CWsbStringPtr                   szJobName;
    CWsbStringPtr                   parameters;
    CWsbStringPtr                   commentString;
    CWsbStringPtr                   tmpString;
    CWsbStringPtr                   formatString;
    TASK_TRIGGER_TYPE               jobTriggerType;
    BOOL                            scheduledJob;


    WsbTraceIn(OLESTR("CFsaResource::SetupValidateJob"), OLESTR(""));

    try {

        // Get the volume name
        CWsbStringPtr szWsbVolumeName;
        WsbAffirmHr (GetLogicalName ( &szWsbVolumeName, 0));

        // Create a job name
        CWsbStringPtr volumeString;
        WsbAffirmHr( volumeString.Alloc( 128 ) );

        // For now, ignore the user name if it's not a drive letter
        CWsbStringPtr userName = m_userName;
        size_t userLen = 0;
        if ((WCHAR *)userName) {
            userLen = wcslen(userName);
        }
        if ((userLen != 3) || (userName[1] != L':')) {
            userName = L"";
        }

        if( ! userName || userName.IsEqual ( L"" ) ) {

            //
            // No drive letter - use the volume name and serial number instead
            //
            if( ! m_name || m_name.IsEqual( L"" ) ) {

                //
                // No name, no drive letter - just have serial number
                //
                swprintf( volumeString, L"%8.8lx", m_serial );

            } else {

                swprintf( volumeString, L"%ls-%8.8lx", (OLECHAR*)m_name, m_serial );

            }

        } else {

            //
            // Just want the drive letter (first character)
            //
            volumeString = userName;
            volumeString[1] = L'\0';

        }

        WsbAffirmHr(formatString.LoadFromRsc(_Module.m_hInst, IDS_JOB_NAME_PREFIX));
        WsbAffirmHr(szJobName.Alloc(512));
        swprintf((OLECHAR *) szJobName, formatString, (OLECHAR*)volumeString);

        // Get a pointer to the HSM server
        WsbAffirm(IsManaged() == S_OK, E_FAIL);
        WsbAffirmHr(HsmConnectFromId(HSMCONN_TYPE_HSM, m_managingHsm, IID_IHsmServer,
            (void**) &pHsmServer));

        // Get a CreateLocalObject interface with which to create the job
        WsbAffirmHr (pHsmServer->QueryInterface( IID_IWsbCreateLocalObject,
            (void **) &pLocalObject));

        // Create the new job in the engine
        WsbAffirmHr (pLocalObject->CreateInstance( CLSID_CHsmJob, IID_IHsmJob,
            (void**) &pNewJob));
        WsbAffirmHr (pNewJob->InitAs(
            szJobName, NULL, HSM_JOB_DEF_TYPE_VALIDATE, GUID_NULL,
            pHsmServer, TRUE, this));

        // Get the jobs collection from the engine
        WsbAffirmHr (pHsmServer->GetJobs (&pJobs));

        // If any jobs exist with this name, delete them
        ULONG cCount;
        WsbAffirmHr (pJobs->GetEntries (&cCount));
        for (UINT i = 0; i < cCount; i++) {
            WsbAffirmHr (pJobs->At (i, IID_IHsmJob, (void **) &pExistJob));
            WsbAffirmHr (pExistJob->GetName (&pszExistJobName, 0));
            if (pszExistJobName.Compare (szJobName) == 0) {
                WsbAffirmHr (pJobs->RemoveAndRelease(pExistJob));
                i--; cCount--;
            }
            pExistJob = 0;      // make sure we release this interface.
        }

        // Add the new job to the engine collection
        WsbAffirmHr (pJobs->Add(pNewJob));

        // Set up to call the Engine to create an entry in the NT Task Scheduler

        // Create the parameter string for the program NT Scheduler
        // will run (for Sakkara this is RsLaunch) by putting the
        // job name in as the parameter.  This is how RsLaunch knows
        // which job in the Engine to run.
        WsbAffirmHr(parameters.Alloc(256));
        swprintf((OLECHAR *)parameters, L"run \"%ls\"", (OLECHAR *) szJobName);

        // Create the comment string for the NT Scheduler entry
        WsbAffirmHr(formatString.LoadFromRsc(_Module.m_hInst, IDS_JOB_AUTOVALIDATE_COMMENT));
        WsbAffirmHr(commentString.Alloc(512));
        swprintf((OLECHAR *) commentString, formatString, (OLECHAR *) szWsbVolumeName);

        // Declare and initialize the schedule components passed to
        // the Engine.
        jobTriggerType = TASK_TIME_TRIGGER_ONCE;

        // Indicate this is a scheduled job
        scheduledJob = TRUE;

        // Create the task
        WsbAffirmHr( pHsmServer->CreateTaskEx( szJobName, parameters,
                                               commentString, jobTriggerType,
                                               runTime, 0,
                                               scheduledJob ) );
        //
        // Remove the registry value if it is there.
        //
        WsbAffirmHr(tmpString.Alloc(32));
        swprintf((OLECHAR *) tmpString, L"%x", m_serial);
        (void) WsbRemoveRegistryValue(NULL, FSA_VALIDATE_LOG_KEY_NAME, tmpString);

    } WsbCatch( hr );

    WsbTraceOut( L"CFsaResource::SetupValidateJob", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}



HRESULT
CFsaResource::Test(
    USHORT* passed,
    USHORT* failed
    )

/*++

Implements:

  IWsbTestable::Test().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != passed, E_POINTER);
        WsbAssert(0 != failed, E_POINTER);

        *passed = 0;
        *failed = 0;

    } WsbCatch(hr);

    return(hr);
}



HRESULT
CFsaResource::UpdateFrom(
    IN IFsaServer* pServer,
    IN IFsaResource* pResource
    )

/*++

Implements:

  IFsaResourcePriv::UpdateFrom().

Routine Description:

    This routine implements the COM method for updating a resource object from another.
    It is generally used to update a resource contained in the manageable resources
    collection from a 'working' resource which was just created during a scan for
    resources.  Note that both source and target resource objects must represent the
    same physical resource.

    To capture the latest information about the resource, only the owning FSA and path
    info is updated from the source resource object.  All other resource info is
    updated via a direct query contained within this method.  This technique allows
    for capturing any updates made by the user since the scan was run.

Arguments:

    pServer - Interface pointer to the FSA service that is updating this resource.

    pResource - Interface pointer to the resource used as the source during the update.

Return Value:

    S_OK - The call succeeded (the resource being tested was found to be manageable,
            and the resource object was initialized).

    E_UNEXPECTED - Thrown if the id's (Guids) for the resource to updated and the
            source resource do not match.

    Any other value - The call failed because one of the Remote Storage or Win32 API
            calls contained internally in this method failed.  The error value returned
            is specific to the API call which failed.

--*/

{
    HRESULT         hr = S_OK;
    GUID            id;
    CWsbStringPtr   tmpString;
    CWsbStringPtr   volPath;

    WsbTraceIn(OLESTR("CFsaResource::UpdateFrom"), OLESTR(""));
    try {

        // The identifiers must be the same! (Meaning both resource objects must
        // represent the same physical resource.)
        WsbAffirmHr(pResource->GetIdentifier(&id));
        WsbAssert(m_id == id, E_UNEXPECTED);

        // Update (store) the owning FSA interface.  However, since this is a weak
        // reference, do not AddRef() it.
        m_pFsaServer = pServer;

        // Update the path specific information, preserving the last known path (if any).
        // If the 'path' of this resource is null, set it to the 'path' of the resource
        // we are updating from. Else, compare the 2 'path' fields. If different, copy
        // this resource's path to 'old path', then update 'path' from the resource we are
        // updating from. If the 2 resources' paths are not null and the same, do nothing.
        //
        WsbAffirmHr(pResource->GetPath(&tmpString, 0));
        if (m_path == 0) {
            WsbAffirmHr(SetPath(tmpString));
        }
        else if (wcscmp(tmpString, m_path) != 0) {
            // copy path to 'old path' field, then update 'path' field.
            WsbAffirmHr(m_path.CopyTo(&m_oldPath, 0));
            WsbAffirmHr(SetPath(tmpString));
        }

        // Update 'user friendly' name of this resource from the resource we are updating
        // from.
        WsbAffirmHr(pResource->GetUserFriendlyName(&tmpString, 0));
        WsbTrace(OLESTR("CFsaResource::UpdateFrom - setting user friendly name to %ws\n"),
            (WCHAR *) tmpString);
        WsbAffirmHr(SetUserFriendlyName(tmpString));

        // Update 'sticky' (long, ugly PNP) name of this resource from the resource we are
        // updating from.
        WsbAffirmHr(pResource->GetStickyName(&tmpString, 0));
        WsbAffirmHr(SetStickyName(tmpString));

        // Since the other data that we would like to refresh is not exposed by an interface,
        // we will query for it again.
        //
        // NOTE: fsFlags and maxComponentLength are the real issues, since name and fsName
        // are done via exposed interfaces.
        //
        // NOTE: To keep every update from making the item seem dirty, we may want to
        // compare all the fields first. (Idea for later enhancement)
        m_name.Realloc(128);    // volume name
        m_fsName.Realloc(128);  // volume file system type (e.g., FAT, NTFS)
        HRESULT hrAvailable;
        WsbAffirmHr( hrAvailable = pResource->IsAvailable( ) );
        m_isAvailable = S_OK == hrAvailable ? TRUE : FALSE;

        // Reformat resource's path for 'GetVolumeInfo' call below.
        volPath = m_path;
        WsbAffirmHr(volPath.Prepend("\\\\?\\"));

        WsbAffirm(GetVolumeInformation(volPath, m_name, 128, &m_serial,
                            &m_maxComponentLength, &m_fsFlags, m_fsName, 128), E_FAIL);

        // Now that everything is updated, initialize the
        // premigration list if necessary
        WsbAffirmHr(InitializePremigrationList(TRUE));

        m_isDirty = TRUE;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::UpdateFrom"), OLESTR("hr = <%ls>"),
                                                            WsbHrAsString(hr));
    return(hr);
}



HRESULT
CFsaResource::Validate(
    IN IFsaScanItem* pScanItem,
    IN LONGLONG offset,
    IN LONGLONG size,
    IN LONGLONG usn
    )

/*++

Implements:

  IFsaResource::Validate().

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IFsaPostIt>     pWorkItem;
    CComPtr<IHsmFsaTskMgr>  pEngine;
    CWsbStringPtr           tmpString;
    CComPtr<IHsmSession>    pSession;
    FSA_PLACEHOLDER         placeholder;

    WsbTraceIn(OLESTR("CFsaResource::Validate"), OLESTR("offset = %I64d, size = %I64d, usn = <%I64d>"),
                offset, size, usn);
    try {

        // Make sure the  Scan Item interface is OK
        WsbAssert(pScanItem != 0, E_POINTER);
        WsbAffirmHr(CoCreateInstance(CLSID_CFsaPostIt, 0, CLSCTX_SERVER, IID_IFsaPostIt, (void**) &pWorkItem));

        // Get the data from the scan item.
        WsbAffirmHr(pScanItem->GetSession(&pSession));
        WsbAffirmHr(pWorkItem->SetSession(pSession));

        WsbAffirmHr(pScanItem->GetPathAndName(0, &tmpString, 0));
        WsbAffirmHr(pWorkItem->SetPath(tmpString));

        WsbAffirmHr(pWorkItem->SetRequestOffset(offset));
        WsbAffirmHr(pWorkItem->SetRequestSize(size));

        WsbAffirmHr(pScanItem->GetPlaceholder(offset, size, &(placeholder)));
        WsbAffirmHr(pWorkItem->SetPlaceholder(&placeholder));

        // Fill in the rest of the work
        WsbAffirmHr(pWorkItem->SetRequestAction(FSA_REQUEST_ACTION_VALIDATE));
        WsbAffirmHr(pWorkItem->SetResultAction(FSA_RESULT_ACTION_NONE));

        // Fill in the USN
        WsbAffirmHr(pWorkItem->SetUSN(usn));

        // Send the request to the task manager
        WsbAffirmHr(GetHsmEngine(&pEngine));
        WsbAffirmHr(pEngine->DoFsaWork(pWorkItem));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::Validate"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}



HRESULT
CFsaResource::ValidateForTruncate(
    IN IFsaScanItem* pScanItem,
    IN LONGLONG offset,
    IN LONGLONG size,
    IN LONGLONG usn
    )

/*++

Implements:

  IFsaResource::ValidateForTruncate().

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IFsaPostIt>     pWorkItem;
    CComPtr<IHsmFsaTskMgr>  pEngine;
    CWsbStringPtr           tmpString;
    CComPtr<IHsmSession>    pSession;
    FSA_PLACEHOLDER         placeholder;

    WsbTraceIn(OLESTR("CFsaResource::ValidateForTruncate"), OLESTR("offset = %I64d, size = %I64d, usn = <%I64d>"),
                offset, size, usn);
    try {

        // Make sure the  Scan Item interface is OK
        WsbAssert(pScanItem != 0, E_POINTER);
        WsbAffirmHr(CoCreateInstance(CLSID_CFsaPostIt, 0, CLSCTX_SERVER, IID_IFsaPostIt, (void**) &pWorkItem));

        // Get the data from the scan item.
        WsbAffirmHr(pScanItem->GetSession(&pSession));
        WsbAffirmHr(pWorkItem->SetSession(pSession));

        WsbAffirmHr(pScanItem->GetPathAndName(0, &tmpString, 0));
        WsbAffirmHr(pWorkItem->SetPath(tmpString));

        WsbAffirmHr(pWorkItem->SetRequestOffset(offset));
        WsbAffirmHr(pWorkItem->SetRequestSize(size));

        WsbAffirmHr(pScanItem->GetPlaceholder(offset, size, &(placeholder)));
        WsbAffirmHr(pWorkItem->SetPlaceholder(&placeholder));

        // Fill in the rest of the work
        WsbAffirmHr(pWorkItem->SetRequestAction(FSA_REQUEST_ACTION_VALIDATE_FOR_TRUNCATE));
        WsbAffirmHr(pWorkItem->SetResultAction(FSA_RESULT_ACTION_NONE));

        // Fill in the USN
        WsbAffirmHr(pWorkItem->SetUSN(usn));

        // Send the request to the task manager
        WsbAffirmHr(GetHsmEngine(&pEngine));
        WsbAffirmHr(pEngine->DoFsaWork(pWorkItem));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::ValidateForTruncate"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}



HRESULT
CFsaResource::WriteIdentifier(
    void
    )

/*++

    This code is no longer called, in time it will be removed

--*/
{
#if 0
    HRESULT                           hr = S_OK;
    CWsbStringPtr                     tmpString;
    HANDLE                            aHandle;
    ULONG                             size;
    ULONG                             bytesWritten;
    FILE_FS_OBJECT_ID_INFORMATION     objectId;
    NTSTATUS                          status = STATUS_SUCCESS;
    IO_STATUS_BLOCK                   ioStatus;

    WsbTraceIn(OLESTR("CFsaResource::WriteIdentifier"), OLESTR(""));
    try {

        // For now, we will create a file in the root of the volume.
        tmpString = m_path;
        WsbAffirmHr(tmpString.Prepend("\\\\?\\"));
        // WsbAffirmHr(tmpString.Append(":MSHSM_FSAID"));

        WsbAffirmHandle(aHandle = CreateFile(tmpString,
                                             GENERIC_WRITE,
                                             0,
                                             0,
                                             OPEN_EXISTING,
                                             FILE_ATTRIBUTE_NORMAL,
                                             0));

        try {

            WsbAffirmHr(WsbConvertToBytes(objectId.ObjectId, m_id, &size));

            status = NtSetVolumeInformationFile(
                                    aHandle,
                                    &ioStatus,
                                    &objectId,
                                    sizeof(objectId),
                                    FileFsObjectIdInformation);

            WsbAffirmNtStatus(status);

            WsbAffirm(bytesWritten == size, E_FAIL);

        } WsbCatch(hr);

        WsbAffirmStatus(CloseHandle(aHandle));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::WriteIdentifier"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);

#else
    return  S_OK;
#endif
}


void CFsaResource::OnStateChange( )
/*++

    Note:  This function is run in a separate thread to avoid a deadlock situation

--*/
{
    IConnectionPointImpl<CFsaResource, &IID_IHsmEvent, CComDynamicUnkArray>* p = this;
    Lock();
    HRESULT hr = S_OK;
    IUnknown** pp = p->m_vec.begin();
    while (pp < p->m_vec.end() && hr == S_OK)
    {
        if (*pp != NULL)
        {
            IHsmEvent* pIHsmEvent = (IHsmEvent*)*pp;
            hr = pIHsmEvent->OnStateChange( );
        }
        pp++;
    }
    Unlock();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\fsa\fsapost.h ===
#ifndef _FSAPOST_
#define _FSAPOST_

/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    FSAPOST.cpp

Abstract:

    This class contains represents a post it - a unit of work
    that is exchanged between the FSA and the HSM engine.

Author:

    Cat Brant   [cbrant]   1-Apr-1997

Revision History:

--*/

#include "resource.h"       // main symbols

#include "job.h"
#include "fsa.h"
#include "fsaprv.h"

/*++

Class Name:
    
    CFsaScanItem

Class Description:


--*/


class CFsaPostIt : 
    public CWsbObject,
    public IFsaPostIt,
    public CComCoClass<CFsaPostIt,&CLSID_CFsaPostIt>
{
public:
    CFsaPostIt() {}
BEGIN_COM_MAP(CFsaPostIt)
    COM_INTERFACE_ENTRY(IFsaPostIt)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbPersistStream)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_FsaPostIt)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);
    void FinalRelease(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IUnknown* pUnknown, SHORT* pResult);
    WSB_FROM_CWSBOBJECT;

// IWsbTestable
    STDMETHOD(Test)(USHORT *passed, USHORT* failed);

// IFsaPostItPriv
public:

// IFsaPostIt
public:
    STDMETHOD(CompareToIPostIt)(IFsaPostIt* pPostIt, SHORT* pResult);

    STDMETHOD(GetFileVersionId)(LONGLONG  *pFileVersionId);
    STDMETHOD(GetFilterRecall)(IFsaFilterRecall** ppRecall);            
    STDMETHOD(GetMode)(ULONG *pMode);
    STDMETHOD(GetPath)(OLECHAR ** pPath, ULONG bufferSize);             
    STDMETHOD(GetPlaceholder)(FSA_PLACEHOLDER *pPlaceholder);       
    STDMETHOD(GetRequestAction)(FSA_REQUEST_ACTION *pRequestAction);    
    STDMETHOD(GetRequestOffset)(LONGLONG  *pRequestOffset);
    STDMETHOD(GetRequestSize)(LONGLONG *pRequestSize);
    STDMETHOD(GetResult)(HRESULT *pHr);
    STDMETHOD(GetResultAction)(FSA_RESULT_ACTION *pResultAction);
    STDMETHOD(GetSession)(IHsmSession **pSession);          
    STDMETHOD(GetStoragePoolId)(GUID  *pStoragePoolId); 
    STDMETHOD(GetUSN)(LONGLONG  *pUsn); 
    STDMETHOD(GetThreadId)(DWORD *threadId);   

    STDMETHOD(SetFileVersionId)(LONGLONG  fileVersionId);
    STDMETHOD(SetFilterRecall)(IFsaFilterRecall* pRecall);          
    STDMETHOD(SetMode)(ULONG mode);
    STDMETHOD(SetPath)(OLECHAR * path);             
    STDMETHOD(SetPlaceholder)(FSA_PLACEHOLDER *pPlaceholder);       
    STDMETHOD(SetRequestAction)(FSA_REQUEST_ACTION requestAction);  
    STDMETHOD(SetRequestOffset)(LONGLONG  requestOffset);
    STDMETHOD(SetRequestSize)(LONGLONG requestSize);
    STDMETHOD(SetResult)(HRESULT hr);
    STDMETHOD(SetResultAction)(FSA_RESULT_ACTION pResultAction);
    STDMETHOD(SetSession)(IHsmSession *pSession);           
    STDMETHOD(SetStoragePoolId)(GUID  storagePoolId);   
    STDMETHOD(SetUSN)(LONGLONG  usn);   
    STDMETHOD(SetThreadId)(DWORD threadId);   

protected:
    CComPtr<IFsaFilterRecall>   m_pFilterRecall;     // FSA filter recall that is tracking this recall
    CComPtr<IHsmSession>        m_pSession;          // HSM session that generated the PostIt
    GUID                        m_storagePoolId;     // Storage pool to receive data (manage only)
    ULONG                       m_mode;              // File open mode (filter recall only)
    FSA_REQUEST_ACTION          m_requestAction;     // Action for engine to take
    FSA_RESULT_ACTION           m_resultAction;      // Action for FSA to take when engine is done
    LONGLONG                    m_fileVersionId;     // Version of the file (manage and recall)
    LONGLONG                    m_requestOffset;     // The starting offset of the section to be managed (manage and recall)
    LONGLONG                    m_requestSize;       // The length of the section to be managed (manage and recall)
    FSA_PLACEHOLDER             m_placeholder;       // File placeholder information
    CWsbStringPtr               m_path;              // Path of file name from root of resource, callee must free this memory
    HRESULT                     m_hr;                // Result of the FSA_REQUEST_ACTION
    LONGLONG                    m_usn;               // USN of the file
    DWORD                       m_threadId; // id of thread causing recall
};

#endif  // _FSAPOST_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\fsa\fsarsc.h ===
#ifndef _FSARSC_
#define _FSARSC_

/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    fsarsc.h

Abstract:

    This module represents a file system resource (i.e. volume)
    for NTFS 5.0.

Author:

    Chuck Bardeen   [cbardeen]   1-Dec-1996

Revision History:

--*/

#include "resource.h"       // main symbols

#include "fsa.h"
#include "task.h"


#define FSA_VALIDATE_LOG_KEY_NAME OLESTR("SYSTEM\\CurrentControlSet\\Services\\Remote_Storage_File_System_Agent\\Validate")

// Usn journal Registry parameters
#define FSA_USN_MIN_SIZE                        OLESTR("UsnMinSize")    
#define FSA_USN_MAX_SIZE                        OLESTR("UsnMaxSize")    
#define FSA_USN_FREE_SPACE_FRACTION             OLESTR("UsnSizeFreeSpaceFraction")    
#define FSA_USN_TOTAL_SPACE_FRACTION            OLESTR("UsnSizeTotalSpaceFraction")      

// Usn journal defaults
#define FSA_USN_MIN_SIZE_DEFAULT                100                                 // in MB
#define FSA_USN_MAX_SIZE_DEFAULT                4096                                // in MB (4 GB)
#define FSA_USN_FREE_SPACE_FRACTION_DEFAULT     64                                  // 1/64 out of current free space
#define FSA_USN_TOTAL_SPACE_FRACTION_DEFAULT    64                                  // 1/64 out of total volume space

#define UNMANAGE_DB_PREFIX       OLESTR("Unmanage_")

/*++

Class Name:
    
    CFsaResource

Class Description:

    This class represents a file system resource (i.e. volume)
    for NTFS 5.0.

--*/

class CFsaResource : 
    public CWsbCollectable,
    public IFsaResource,
    public IFsaResourcePriv,
    public IConnectionPointContainerImpl<CFsaResource>,
    public IConnectionPointImpl<CFsaResource, &IID_IHsmEvent, CComDynamicUnkArray>,
    public CComCoClass<CFsaResource,&CLSID_CFsaResourceNTFS>
{
public:
    CFsaResource() {}
BEGIN_COM_MAP(CFsaResource)
    COM_INTERFACE_ENTRY(IFsaResource)
    COM_INTERFACE_ENTRY(IFsaResourcePriv)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbTestable)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_FsaResource)

// Connection Point
    BEGIN_CONNECTION_POINT_MAP(CFsaResource)
        CONNECTION_POINT_ENTRY(IID_IHsmEvent)
    END_CONNECTION_POINT_MAP()

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);
    STDMETHOD(FinalRelease)(void);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IUnknown* pUnknown, SHORT* pResult);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbTestable
    STDMETHOD(Test)(USHORT *passed, USHORT* failed);

// IHsmSystemState
    STDMETHOD( ChangeSysState )( HSM_SYSTEM_STATE* pSysState );

// IFsaResourcePriv
public:
    STDMETHOD(AddPremigratedSize)(LONGLONG size);
    STDMETHOD(AddTruncatedSize)(LONGLONG size);
    STDMETHOD(DoRecovery)(void);
    STDMETHOD(FilterSawOpen)(IHsmSession* pSession, IFsaFilterRecall* pRecall, 
                             OLECHAR* path, LONGLONG fileId,
                             LONGLONG requestOffset, LONGLONG requestSize, 
                             FSA_PLACEHOLDER* pPlaceholder, ULONG mode, 
                             FSA_RESULT_ACTION resultAction, DWORD threadId);
    STDMETHOD(FilterSawDelete)(GUID filterId, OLECHAR* path, LONGLONG size, 
                               FSA_PLACEHOLDER* pPlaceholder);
    STDMETHOD(GetPremigrated)(REFIID riid, void** ppDb);
    STDMETHOD(GetUnmanageDb)(REFIID riid, void** ppDb);
    STDMETHOD(Init)(IFsaServer* pFsaServer, OLECHAR* path, OLECHAR *dosName);
    STDMETHOD(RemovePremigratedSize)(LONGLONG size);
    STDMETHOD(RemoveTruncatedSize)(LONGLONG size);
    STDMETHOD(SetAlternatePath)(OLECHAR* name);
    STDMETHOD(SetIdentifier)(GUID id);
    STDMETHOD(SetName)(OLECHAR* name);
    STDMETHOD(SetOldPath)(OLECHAR* oldPath);
    STDMETHOD(SetPath)(OLECHAR* name);
    STDMETHOD(SetUserFriendlyName)(OLECHAR* name);
    STDMETHOD(SetStickyName)(OLECHAR* name);
    STDMETHOD(UpdateFrom)(IFsaServer* pServer, IFsaResource* pResource);
    STDMETHOD(InitializeUnmanageDb)(void);
    STDMETHOD(TerminateUnmanageDb)(void);
    STDMETHOD(GetMaxFileLogicalSize)(LONGLONG* pSize);

// IFsaResource
public:
    STDMETHOD(AddPremigrated)(IFsaScanItem* pScanItem, LONGLONG offset, LONGLONG size, 
                              BOOL isWaitingForClose, LONGLONG usn);
    STDMETHOD(AddTruncated)(IFsaScanItem* pScanItem, LONGLONG offset, LONGLONG size);
    STDMETHOD(BeginSession)(OLECHAR* name, ULONG logControl, ULONG runId, ULONG subRunId, 
                            IHsmSession** ppSession);
    STDMETHOD(BeginValidate)(void);
    STDMETHOD(CompareBy)(FSA_RESOURCE_COMPARE by);
    STDMETHOD(CompareToAlternatePath)(OLECHAR* name, SHORT* pResult);
    STDMETHOD(CompareToIdentifier)(GUID id, SHORT* pResult);
    STDMETHOD(CompareToIResource)(IFsaResource* pResource, SHORT* pResult);
    STDMETHOD(CompareToName)(OLECHAR* name, SHORT* pResult);
    STDMETHOD(CompareToUserName)(OLECHAR* userName, SHORT* pResult);
    STDMETHOD(CompareToPath)(OLECHAR* name, SHORT* pResult);
    STDMETHOD(CompareToSerial)(ULONG serial, SHORT* pResult);
    STDMETHOD(CompareToStickyName)(OLECHAR* name, SHORT* pResult);
    STDMETHOD(CreateDefaultRules)(void);
    STDMETHOD(EndSession)(IHsmSession* pSession);
    STDMETHOD(EndValidate)(HSM_JOB_STATE state);
    STDMETHOD(EnumDefaultRules)(IWsbEnum** ppEnum);
    STDMETHOD(FindFirst)(OLECHAR* path, IHsmSession* pSession, IFsaScanItem** ppScanItem);
    STDMETHOD(FindFirstInRPIndex)(IHsmSession* pSession, IFsaScanItem** ppScanItem);
    STDMETHOD(FindFirstInDbIndex)(IHsmSession* pSession, IFsaScanItem** ppScanItem);
    STDMETHOD(FindNext)(IFsaScanItem* pScanItem);
    STDMETHOD(FindNextInRPIndex)(IFsaScanItem* pScanItem);
    STDMETHOD(FindNextInDbIndex)(IFsaScanItem* pScanItem);
    STDMETHOD(FindFileId)(LONGLONG fileId, IHsmSession* pSession, 
                          IFsaScanItem** ppScanItem);
    STDMETHOD(FindObjectId)(LONGLONG objIdHi, LONGLONG objIdLo, IHsmSession* pSession, 
                            IFsaScanItem** ppScanItem);
    STDMETHOD(GetAlternatePath)(OLECHAR** pPath, ULONG bufferSize);
    STDMETHOD(GetDefaultRules)(IWsbCollection** ppCollection);
    STDMETHOD(GetDbPath)(OLECHAR** pPath, ULONG bufferSize);
    STDMETHOD(GetUnmanageDbPath)(OLECHAR** pPath, ULONG bufferSize);
    STDMETHOD(GetFreeLevel)(ULONG* pLevel);
    STDMETHOD(GetFsName)(OLECHAR** pName, ULONG bufferSize);
    STDMETHOD(GetHsmEngine)(IHsmFsaTskMgr** ppEngine);
    STDMETHOD(GetHsmLevel)(ULONG* pLevel);
    STDMETHOD(GetIdentifier)(GUID* pId);
    STDMETHOD(GetLogicalName)(OLECHAR** pName, ULONG bufferSize);
    STDMETHOD(GetManageableItemLogicalSize)(LONGLONG* pSize);
    STDMETHOD(GetManageableItemAccessTime)(BOOL* isRelative, FILETIME* pTime);
    STDMETHOD(GetManagingHsm)(GUID* pId);
    STDMETHOD(GetName)(OLECHAR** pName, ULONG bufferSize);
    STDMETHOD(GetOldPath)(OLECHAR** pPath, ULONG bufferSize);
    STDMETHOD(GetPath)(OLECHAR** pPath, ULONG bufferSize);
    STDMETHOD(GetSerial)(ULONG *serial);
    STDMETHOD(GetSizes)(LONGLONG* pTotal, LONGLONG* pFree, LONGLONG* pPremigrated, 
                        LONGLONG* pTruncated);
    STDMETHOD(GetTruncator)(IFsaTruncator** ppTruncator);
    STDMETHOD(GetUncPath)(OLECHAR** pPath, ULONG bufferSize);
    STDMETHOD(GetUserFriendlyName)(OLECHAR** pName, ULONG bufferSize);
    STDMETHOD(GetStickyName)(OLECHAR** pName, ULONG bufferSize);
    STDMETHOD(IsActive)(void);
    STDMETHOD(IsAvailable)(void);
    STDMETHOD(IsDeletePending)(void);
    STDMETHOD(IsManaged)(void);
    STDMETHOD(Manage)(IFsaScanItem* pScanItem, LONGLONG offset, LONGLONG size, 
                      GUID storagePoolId, BOOL truncate);
    STDMETHOD(ManagedBy)(GUID hsmId, ULONG hsmLevel, BOOL release);
    STDMETHOD(NeedsRepair)(void);
    STDMETHOD(ProcessResult)(IFsaPostIt* pResult);
    STDMETHOD(Recall)(IFsaScanItem* pScanItem, LONGLONG offset, LONGLONG size, 
                      BOOL deletePlaceholder);
    STDMETHOD(RemovePremigrated)(IFsaScanItem* pScanItem, LONGLONG offset, LONGLONG size);
    STDMETHOD(RemoveTruncated)(IFsaScanItem* pScanItem, LONGLONG offset, LONGLONG size);
    STDMETHOD(SetHsmLevel)(ULONG level);
    STDMETHOD(SetIsActive)(BOOL isActive);
    STDMETHOD(SetIsAvailable)(BOOL isAvailable);
    STDMETHOD(SetIsDeletePending)(BOOL isDeletePending);
    STDMETHOD(SetManageableItemLogicalSize)(LONGLONG pSize);
    STDMETHOD(SetManageableItemAccessTime)(BOOL isRelative, FILETIME pTime);
    STDMETHOD(SetSerial)(ULONG serial);
    STDMETHOD(StartJob)(OLECHAR* startingPath, IHsmSession* pSession);
    STDMETHOD(StartJobSession)(IHsmJob* pJob, ULONG subRunId, IHsmSession** ppSession);
    STDMETHOD(Validate)(IFsaScanItem* pScanItem, LONGLONG offset, LONGLONG size, 
                        LONGLONG usn);
    STDMETHOD(SetupValidateJob)(SYSTEMTIME runtime);
    STDMETHOD(CheckForValidate)(BOOL bForceValidate);
    STDMETHOD(GetUsnId)(ULONGLONG *usnId);
    STDMETHOD(ValidateForTruncate)(IFsaScanItem* pScanItem, LONGLONG offset, LONGLONG size, 
                        LONGLONG usn);

// Local Methods
    void OnStateChange( void );
protected:
    STDMETHOD(CheckForJournal)(BOOL *pValidateNeeded);
    STDMETHOD(InitializePremigrationList)(BOOL bStartValidateJob);
    HRESULT ReadIdentifier(void);
    HRESULT WriteIdentifier(void);

protected:
    GUID                        m_id;
    CWsbStringPtr               m_oldPath;      // Previous value for 'm_path'.
    CWsbStringPtr               m_path;         // Drive letter (with backslash) if named 
                                                // volume, otherwise same as m_stickyName.
    CWsbStringPtr               m_alternatePath;
    CWsbStringPtr               m_name;         // Volume name.
    CWsbStringPtr               m_userName;     // Drive letter (with backslash) if named 
                                                // volume, otherwise NULL.
    CWsbStringPtr               m_stickyName;   // Long ugly PNP name (without \\?\ prefix)
    CWsbStringPtr               m_fsName;       // File system type (e.g., NTFS).
    BOOL                        m_isActive;
    BOOL                        m_isAvailable;  // If volume is manageable.
    BOOL                        m_isDeletePending;
    BOOL                        m_isRecovered;
    BOOL                        m_isDbInitialized;
    ULONG                       m_maxComponentLength;
    ULONG                       m_fsFlags;
    FSA_RESOURCE_COMPARE        m_compareBy;
    GUID                        m_managingHsm;
    ULONG                       m_hsmLevel;
    LONGLONG                    m_premigratedSize;
    LONGLONG                    m_truncatedSize;
    LONGLONG                    m_oldPremigratedSize;
    LONGLONG                    m_oldTruncatedSize;
    BOOL                        m_isDoingValidate;
    LONGLONG                    m_manageableItemLogicalSize;
    BOOL                        m_manageableItemAccessTimeIsRelative;
    FILETIME                    m_manageableItemAccessTime;
    LONGLONG                    m_manageableItemMaxSize;
    ULONGLONG                   m_usnJournalId;
    LONGLONG                    m_lastUsnId;
    IFsaServer*                 m_pFsaServer;       // Parent Pointer, Weak Reference
                                                    // (do not AddRef() it)
    unsigned long               m_serial;           // Serial number of volume 
    CComPtr<IFsaPremigratedDb>  m_pPremigrated;
    CComPtr<IHsmFsaTskMgr>      m_pHsmEngine;
    CComPtr<IFsaTruncator>      m_pTruncator;
    CComPtr<IWsbCollection>     m_pDefaultRules;

    CComPtr<IFsaUnmanageDb>     m_pUnmanageDb;
    BOOL                        m_isUnmanageDbInitialized;
};

#endif  // _FSARSC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\fsa\fsaprem.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    fsaprem.cpp

Abstract:

    Defines the functions for the premigrated list classes.

Author:

    Ron White   [ronw]   18-Feb-1997

Revision History:

--*/


#include "stdafx.h"
#include "wsb.h"


#include "fsaprem.h"

#define WSB_TRACE_IS        WSB_TRACE_BIT_FSA

static USHORT iCountPrem = 0;  // Count of existing objects


HRESULT 
CFsaPremigratedDb::FinalConstruct(
    void
    ) 
/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;

    try {
        WsbAssertHr(CWsbDb::FinalConstruct());
        m_version = 1;
    } WsbCatch(hr);

    return(hr);
}


HRESULT 
CFsaPremigratedDb::FinalRelease(
    void
    ) 
/*++

Implements:

  CComObjectRoot::FinalRelease

--*/
{
    HRESULT     hr = S_OK;

    CWsbDb::FinalRelease();
    return(hr);
}



HRESULT
CFsaPremigratedDb::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    try {
        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CFsaPremigratedDb;
    } WsbCatch(hr);
    
    return(hr);
}


HRESULT
CFsaPremigratedDb::Init(
    IN  OLECHAR* path,
    IN  IWsbDbSys* pDbSys, 
    OUT BOOL*    pCreated
    )

/*++

Implements:

  IFsaPremigrated::Init

--*/
{
    BOOL             created = FALSE;
    HRESULT          hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPremigratedDb::Init"),OLESTR(""));
    try {
        int            i = 0;

        m_pWsbDbSys = pDbSys;
        WsbAffirmPointer(m_pWsbDbSys);

        //  Attempt to find the DB
        hr = Locate(path);

        if (S_OK != hr) {
            WsbTrace(OLESTR("CFsaPremigratedDb::Init: db Locate failed\n"));
            if (STG_E_FILENOTFOUND != hr) {
                // Got some error; try deleting the DB and recreating it
                WsbTrace(OLESTR("CFsaPremigratedDb::Init: deleting DB\n"));
                WsbAffirmHr(Delete(path));
                hr = STG_E_FILENOTFOUND;
            }
        }

        if (STG_E_FILENOTFOUND == hr){
            ULONG memSize;

            hr = S_OK;
            m_nRecTypes = 2;

            memSize = m_nRecTypes * sizeof(IDB_REC_INFO);
            m_RecInfo = (IDB_REC_INFO*)WsbAlloc(memSize);
            WsbAffirm(0 != m_RecInfo, E_FAIL);
            ZeroMemory(m_RecInfo, memSize);

            //  Premigrated file record type
            m_RecInfo[0].Type = PREMIGRATED_REC_TYPE;
            m_RecInfo[0].EntityClassId = CLSID_CFsaPremigratedRec;
            m_RecInfo[0].Flags = IDB_REC_FLAG_VARIABLE;
            m_RecInfo[0].MinSize = (2 * WsbPersistSizeOf(FILETIME)) +
                    (5 * WsbPersistSizeOf(LONGLONG)) +
                    WsbPersistSizeOf(GUID) + 4 + WsbPersistSizeOf(BOOL);
            m_RecInfo[0].MaxSize = m_RecInfo[0].MinSize + PREMIGRATED_MAX_PATH_SIZE;

            m_RecInfo[0].nKeys = 3;

            memSize = m_RecInfo[0].nKeys * sizeof(IDB_KEY_INFO);
            m_RecInfo[0].Key = (IDB_KEY_INFO*)WsbAlloc(memSize);
            WsbAffirm(0 != m_RecInfo[0].Key, E_FAIL);
            ZeroMemory(m_RecInfo[0].Key, memSize);

            //  This is the default key used after a GetEntity call
            m_RecInfo[0].Key[0].Type = PREMIGRATED_ACCESS_TIME_KEY_TYPE;
            m_RecInfo[0].Key[0].Size = WSB_BYTE_SIZE_BOOL + WSB_BYTE_SIZE_FILETIME + WSB_BYTE_SIZE_LONGLONG + WSB_BYTE_SIZE_GUID;
            m_RecInfo[0].Key[0].Flags = IDB_KEY_FLAG_DUP_ALLOWED;

            //  This is the primary key, which controls how the records are
            //  arranged in the DB
            m_RecInfo[0].Key[1].Type = PREMIGRATED_BAGID_OFFSETS_KEY_TYPE;
            m_RecInfo[0].Key[1].Size = WSB_BYTE_SIZE_BOOL + 2 * WSB_BYTE_SIZE_LONGLONG + WSB_BYTE_SIZE_GUID;
            m_RecInfo[0].Key[1].Flags = IDB_KEY_FLAG_PRIMARY;

            m_RecInfo[0].Key[2].Type = PREMIGRATED_SIZE_KEY_TYPE;
            m_RecInfo[0].Key[2].Size = WSB_BYTE_SIZE_BOOL + WSB_BYTE_SIZE_LONGLONG + WSB_BYTE_SIZE_LONGLONG + WSB_BYTE_SIZE_GUID;
            m_RecInfo[0].Key[2].Flags = IDB_KEY_FLAG_DUP_ALLOWED;

            WsbAffirm(m_RecInfo[0].nKeys <= IDB_MAX_KEYS_PER_REC, E_FAIL);

            //  Recovery record type
            m_RecInfo[1].Type = RECOVERY_REC_TYPE;
            m_RecInfo[1].EntityClassId = CLSID_CFsaRecoveryRec;
            m_RecInfo[1].Flags = IDB_REC_FLAG_VARIABLE;
            m_RecInfo[1].MinSize = 4 * WsbPersistSizeOf(LONGLONG) + 
                    WsbPersistSizeOf(LONG) + WsbPersistSizeOf(ULONG) + WsbPersistSizeOf(GUID) + 4;
            m_RecInfo[1].MaxSize = m_RecInfo[1].MinSize + PREMIGRATED_MAX_PATH_SIZE;

            m_RecInfo[1].nKeys = 1;

            memSize = m_RecInfo[1].nKeys * sizeof(IDB_KEY_INFO);
            m_RecInfo[1].Key = (IDB_KEY_INFO*)WsbAlloc(memSize);
            WsbAffirm(0 != m_RecInfo[1].Key, E_FAIL);
            ZeroMemory(m_RecInfo[1].Key, memSize);

            //  This is the default and primary key
            m_RecInfo[1].Key[0].Type = RECOVERY_KEY_TYPE;
            m_RecInfo[1].Key[0].Size = RECOVERY_KEY_SIZE;
            m_RecInfo[1].Key[0].Flags = IDB_KEY_FLAG_PRIMARY;

            //  Attempt to create the DB
            WsbAssertHr(Create(path));
            created = TRUE;
        } else {
            WsbAffirmHr(hr);
        }
    } WsbCatch(hr);

    if (pCreated) {
        *pCreated = created;
    }
    WsbTraceOut(OLESTR("CFsaPremigratedDb::Init"),
        OLESTR("hr = <%ls>, Created = %ls"), WsbHrAsString(hr),
        WsbBoolAsString(created));
    return(hr);
}


HRESULT
CFsaPremigratedDb::Load(
    IN IStream* pStream
    )

/*++

Implements:

  IPersistStream::Load().

--*/
{
    HRESULT             hr = S_OK;

    hr = CWsbDb::Load(pStream);

    if (S_OK != hr && STG_E_FILENOTFOUND != hr) {
        // Got some error; delete the DB (we'll recreate it later if
        // we need it
        WsbTrace(OLESTR("CFsaPremigratedDb::Load: deleting DB\n"));
        if (S_OK == Delete(NULL)) {
            hr = STG_E_FILENOTFOUND;
        }
    }

    return(hr);
}


HRESULT
CFsaPremigratedDb::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )

/*++

Implements:

  IPersistStream::Save().

--*/
{
    HRESULT             hr = S_OK;

    try {
        WsbAffirmHr(CWsbDb::Save(pStream, clearDirty));
    } WsbCatch(hr);

    return(hr);
}



HRESULT 
CFsaPremigratedRec::GetAccessTime(
    OUT FILETIME* pAccessTime 
    ) 
/*++

Implements:

  IFsaPremigratedRec::GetAccessTime

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPremigratedRec::GetAccessTime"),OLESTR(""));

    try {
        WsbAssert(0 != pAccessTime, E_POINTER);
        *pAccessTime = m_AccessTime;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPremigratedRec::GetAccessTime"),
        OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CFsaPremigratedRec::GetBagId(
    OUT GUID* pId 
    ) 
/*++

Implements:

  IFsaPremigratedRec::GetBagId

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPremigratedRec::GetBagId"),OLESTR(""));

    try {
        WsbAssert(0 != pId, E_POINTER);

        *pId = m_BagId;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPremigratedRec::GetBagId"), OLESTR("hr = <%ls> Id = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pId));

    return(hr);
}


HRESULT 
CFsaPremigratedRec::GetBagOffset(
    OUT LONGLONG* pOffset 
    ) 
/*++

Implements:

  IFsaPremigratedRec::GetBagOffset

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPremigratedRec::GetBagOffset"),OLESTR(""));

    try {
        WsbAssert(0 != pOffset, E_POINTER);
        *pOffset = m_BagOffset;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPremigratedRec::GetBagOffset"), OLESTR("hr = <%ls> Offset = <%ls>"), WsbHrAsString(hr), WsbLonglongAsString(*pOffset));

    return(hr);
}


HRESULT 
CFsaPremigratedRec::GetFileId(
    OUT LONGLONG* pFileId 
    ) 
/*++

Implements:

  IFsaPremigratedRec::GetFileId

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPremigratedRec::GetFileId"),OLESTR(""));

    try {
        WsbAssert(0 != pFileId, E_POINTER);
        *pFileId = m_FileId;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPremigratedRec::GetFileId"),
        OLESTR("hr = <%ls> FileId = <%ls>"), WsbHrAsString( hr ), WsbLonglongAsString( *pFileId ) );

    return(hr);
}


HRESULT 
CFsaPremigratedRec::GetFileUSN(
    OUT LONGLONG* pFileUSN 
    ) 
/*++

Implements:

  IFsaPremigratedRec::GetFileUSN

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPremigratedRec::GetFileUSN"),OLESTR(""));

    try {
        WsbAssert(0 != pFileUSN, E_POINTER);
        *pFileUSN = m_FileUSN;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPremigratedRec::GetFileUSN"),
        OLESTR("hr = <%ls> File USN = <%ls>"), WsbHrAsString( hr ), WsbLonglongAsString( *pFileUSN ) );

    return(hr);
}


HRESULT 
CFsaPremigratedRec::GetOffset(
    OUT LONGLONG* pOffset 
    ) 
/*++

Implements:

  IFsaPremigratedRec::GetOffset

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPremigratedRec::GetOffset"),OLESTR(""));

    try {
        WsbAssert(0 != pOffset, E_POINTER);
        *pOffset = m_Offset;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPremigratedRec::GetOffset"),
        OLESTR("hr = <%ls> Offset = <%ls>"), WsbHrAsString( hr ), WsbLonglongAsString( *pOffset ) );

    return(hr);
}


HRESULT 
CFsaPremigratedRec::GetPath(
    OUT OLECHAR** ppPath,
    IN  ULONG     bufferSize
    ) 
/*++

Implements:

  IFsaPremigratedRec::GetPath

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPremigratedRec::GetPath"),OLESTR(""));

    try {
        WsbAssert(0 != ppPath, E_POINTER);
        WsbAffirmHr(m_Path.CopyTo(ppPath, bufferSize));
        WsbTrace( OLESTR("CFsaPremigratedRec::GetPath path = <%ls>\n"), *ppPath );
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPremigratedRec::GetPath"),
        OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CFsaPremigratedRec::GetRecallTime(
    OUT FILETIME* pTime 
    ) 
/*++

Implements:

  IFsaPremigratedRec::GetRecallTime

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPremigratedRec::GetRecallTime"),OLESTR(""));

    try {
        WsbAssert(0 != pTime, E_POINTER);
        *pTime = m_RecallTime;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPremigratedRec::GetRecallTime"),
        OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CFsaPremigratedRec::GetSize(
    OUT LONGLONG* pSize 
    ) 
/*++

Implements:

  IFsaPremigratedRec::GetSize

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPremigratedRec::GetSize"),OLESTR(""));

    try {
        WsbAssert(0 != pSize, E_POINTER);
        *pSize = m_Size;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPremigratedRec::GetSize"),
        OLESTR("hr = <%ls> Size = <%ls>"), WsbHrAsString( hr ), WsbLonglongAsString( *pSize ) );

    return(hr);
}


HRESULT 
CFsaPremigratedRec::FinalConstruct(
    void
    ) 
/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssertHr(CWsbDbEntity::FinalConstruct());

        m_AccessTime.dwLowDateTime = 0;
        m_AccessTime.dwHighDateTime = 0;
        m_BagOffset = 0;
        m_BagId = GUID_NULL;
        m_FileId = 0;
        m_IsWaitingForClose = FALSE;
        m_Size = 0;
        m_Offset = 0;
        m_FileUSN = 0;

    } WsbCatch(hr);

    iCountPrem++;

    return(hr);
}


HRESULT 
CFsaPremigratedRec::FinalRelease(
    void
    ) 
/*++

Implements:

  CComObjectRoot::FinalRelease

--*/
{
    HRESULT     hr = S_OK;

    CWsbDbEntity::FinalRelease();

    iCountPrem--;

    return(hr);
}


HRESULT CFsaPremigratedRec::GetClassID
(
    OUT LPCLSID pclsid
    ) 
/*++

Implements:

  IPerist::GetClassID

--*/

{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPremigratedRec::GetClassID"), OLESTR(""));


    try {
        WsbAssert(0 != pclsid, E_POINTER);
        *pclsid = CLSID_CFsaPremigratedRec;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CSecRec::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pclsid));
    return(hr);
}


HRESULT CFsaPremigratedRec::GetSizeMax
(
    OUT ULARGE_INTEGER* pcbSize
    ) 
/*++

Routine Description:

  See IPersistStream::GetSizeMax().

Arguments:

  See IPersistStream::GetSizeMax().

Return Value:

  See IPersistStream::GetSizeMax().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPremigratedRec::GetSizeMax"), OLESTR(""));

    try {
        
        WsbAssert(0 != pcbSize, E_POINTER);

        pcbSize->QuadPart = WsbPersistSizeOf(FILETIME) + 
                            WsbPersistSizeOf(BOOL)  + 
                            WsbPersistSizeOf(GUID)  + 
                            4 * WsbPersistSizeOf(LONGLONG)  + 
                            WsbPersistSize((wcslen(m_Path) + 1) * sizeof(OLECHAR));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPremigratedRec::GetSizeMax"), 
        OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), 
        WsbPtrToUliAsString(pcbSize));

    return(hr);
}


HRESULT 
CFsaPremigratedRec::IsWaitingForClose(
    void
    ) 
/*++

Implements:

  IFsaPremigratedRec::IsWaitingForClose

--*/
{
    
    HRESULT     hr = S_FALSE;

    WsbTraceIn(OLESTR("CFsaPremigratedRec::IsWaitingForClose"),OLESTR(""));

    if (m_IsWaitingForClose) {
        hr = S_OK;
    }

    WsbTraceOut(OLESTR("CFsaPremigratedRec::IsWaitingForClose"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT CFsaPremigratedRec::Load
(
    IN IStream* pStream
    ) 
/*++

Implements:

  IPersistStream::Load

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPremigratedRec::Load"), OLESTR(""));

    try {
        WsbAssert(0 != pStream, E_POINTER);
        WsbAssertHr(WsbLoadFromStream(pStream, &m_AccessTime));
        WsbAssertHr(WsbLoadFromStream(pStream, &m_BagId));
        WsbAssertHr(WsbLoadFromStream(pStream, &m_BagOffset));
        WsbAssertHr(WsbLoadFromStream(pStream, &m_FileId));
        WsbAssertHr(WsbLoadFromStream(pStream, &m_IsWaitingForClose));
        WsbAssertHr(WsbLoadFromStream(pStream, &m_Offset));
        WsbAssertHr(WsbLoadFromStream(pStream, &m_Path, 0));
        WsbAssertHr(WsbLoadFromStream(pStream, &m_Size));
        WsbAssertHr(WsbLoadFromStream(pStream, &m_RecallTime));
        WsbAssertHr(WsbLoadFromStream(pStream, &m_FileUSN));

    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CFsaPremigratedRec::Load"), 
        OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT CFsaPremigratedRec::Print
(
    IN IStream* pStream
    ) 
/*++

Implements:

  IWsbDbEntity::Print

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPremigratedRec::Print"), OLESTR(""));

    try {
        WsbAssert(0 != pStream, E_POINTER);
        CWsbStringPtr strGuid;
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" AccessTime = %ls"), 
                WsbFiletimeAsString(FALSE, m_AccessTime)));
        WsbAffirmHr(WsbSafeGuidAsString(m_BagId, strGuid));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" BagId = %ls"), 
                (WCHAR *)strGuid));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(", BagOffset = %ls"), 
                WsbLonglongAsString(m_BagOffset)));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(", FileId = %ls"), 
                WsbLonglongAsString(m_FileId)));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" Waiting for close = %ls"), 
                WsbBoolAsString(m_IsWaitingForClose)));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(", Offset = %ls"), 
                WsbLonglongAsString(m_Offset)));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(", Path = %ls"), 
                static_cast<OLECHAR*>(m_Path)));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(", Size = %ls"), 
                WsbLonglongAsString(m_Size)));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" RecallTime = %ls"), 
                WsbFiletimeAsString(FALSE, m_RecallTime)));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(", File USN = %ls"), 
                WsbLonglongAsString(m_FileUSN)));
        WsbAffirmHr(CWsbDbEntity::Print(pStream));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPremigratedRec::Print"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT CFsaPremigratedRec::Save
(
    IN IStream* pStream, 
    IN BOOL clearDirty
    ) 
/*++

Implements:

  IPersistStream::Save

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPremigratedRec::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));

    try {
        WsbAssert(0 != pStream, E_POINTER);
        WsbAssertHr(WsbSaveToStream(pStream, m_AccessTime));
        WsbAssertHr(WsbSaveToStream(pStream, m_BagId));
        WsbAssertHr(WsbSaveToStream(pStream, m_BagOffset));
        WsbAssertHr(WsbSaveToStream(pStream, m_FileId));
        WsbAssertHr(WsbSaveToStream(pStream, m_IsWaitingForClose));
        WsbAssertHr(WsbSaveToStream(pStream, m_Offset));
        WsbAssertHr(WsbSaveToStream(pStream, m_Path));
        WsbAssertHr(WsbSaveToStream(pStream, m_Size));
        WsbAssertHr(WsbSaveToStream(pStream, m_RecallTime));
        WsbAssertHr(WsbSaveToStream(pStream, m_FileUSN));

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPremigratedRec::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT 
CFsaPremigratedRec::SetAccessTime(
    IN FILETIME AccessTime 
    ) 
/*++

Implements:

  IFsaPremigratedRec::SetAccessTime

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPremigratedRec::SetAccessTime"),OLESTR(""));

    try {
        m_AccessTime = AccessTime;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPremigratedRec::SetAccessTime"),
        OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CFsaPremigratedRec::SetFromScanItem(
    IN IFsaScanItem* pScanItem,
    IN LONGLONG offset,
    IN LONGLONG size,
    IN BOOL isWaitingForClose
    ) 
/*++

Implements:

  IFsaPremigratedRec::SetFromScanItem

--*/
{
    
    HRESULT             hr = S_OK;
    FSA_PLACEHOLDER     placeholder;

    WsbTraceIn(OLESTR("CFsaPremigratedRec::SetFromScanItem"),OLESTR(""));

    try {
        WsbAssert(0 != pScanItem, E_POINTER);

        // Get the name of the file
        WsbAffirmHr(pScanItem->GetPathAndName(0, &m_Path, 0));
        WsbTrace(OLESTR("CFsaPremigratedRec::SetFromScanItem: path = %ls\n"),
                static_cast<WCHAR*>(m_Path));

        // Get the file id.
        WsbAffirmHr(pScanItem->GetFileId(&m_FileId));

        // Get the access time, offset, and size.
        WsbAffirmHr(pScanItem->GetAccessTime(&m_AccessTime));
        WsbTrace(OLESTR("CFsaPremigratedRec::SetFromScanItem: access time = %ls\n"),
                WsbFiletimeAsString(FALSE, m_AccessTime));
        m_Offset = offset;
        m_Size = size;
        m_IsWaitingForClose = isWaitingForClose;

        // Get the bag id and offset.
        WsbAffirmHr(pScanItem->GetPlaceholder(offset, size, &placeholder));
        m_BagId = placeholder.bagId;
        m_BagOffset = placeholder.fileStart;
        m_RecallTime = placeholder.recallTime;
        WsbTrace(OLESTR("CFsaPremigratedRec::SetFromScanItem: recall time = %ls\n"),
                WsbFiletimeAsString(FALSE, m_RecallTime));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPremigratedRec::SetFromScanItem"),
        OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CFsaPremigratedRec::SetBagId(
    IN GUID BagId
    ) 
/*++

Implements:

  IFsaPremigratedRec::SetBagId

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPremigratedRec::SetBagId"),OLESTR(""));

    m_BagId = BagId;

    WsbTraceOut(OLESTR("CFsaPremigratedRec::SetBagId"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CFsaPremigratedRec::SetBagOffset(
    IN LONGLONG BagOffset 
    ) 
/*++

Implements:

  IFsaPremigratedRec::SetBagOffset

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPremigratedRec::SetBagOffset"),OLESTR(""));

    m_BagOffset = BagOffset;

    WsbTraceOut(OLESTR("CFsaPremigratedRec::SetBagOffset"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CFsaPremigratedRec::SetFileId(
    IN LONGLONG FileId 
    ) 
/*++

Implements:

  IFsaPremigratedRec::SetFileId

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPremigratedRec::SetFileId"),OLESTR("FileId = %ls"),
            WsbLonglongAsString(FileId));

    try {
        m_FileId = FileId;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPremigratedRec::SetFileId"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CFsaPremigratedRec::SetFileUSN(
    IN LONGLONG FileUSN 
    ) 
/*++

Implements:

  IFsaPremigratedRec::SetFileUSN

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPremigratedRec::SetFileUSN"),OLESTR("File USN = %ls"),
            WsbLonglongAsString(FileUSN));

    try {
        m_FileUSN = FileUSN;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPremigratedRec::SetFileUSN"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CFsaPremigratedRec::SetIsWaitingForClose(
    IN BOOL isWaiting
    ) 
/*++

Implements:

  IFsaPremigratedRec::SetIsWaitingForClose

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPremigratedRec::SetIsWaitingForClose"),OLESTR(""));

    m_IsWaitingForClose = isWaiting;

    WsbTraceOut(OLESTR("CFsaPremigratedRec::SetIsWaitingForClose"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CFsaPremigratedRec::SetOffset(
    IN LONGLONG Offset 
    ) 
/*++

Implements:

  IFsaPremigratedRec::SetOffset

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPremigratedRec::SetOffset"),OLESTR(""));

    try {
        m_Offset = Offset;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPremigratedRec::SetOffset"),
        OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CFsaPremigratedRec::SetPath(
    IN OLECHAR* Path 
    ) 
/*++

Implements:

  IFsaPremigratedRec::SetPath

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPremigratedRec::SetPath"),OLESTR(""));

    try {
        m_Path = Path;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPremigratedRec::SetPath"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CFsaPremigratedRec::SetRecallTime(
    IN FILETIME time 
    ) 
/*++

Implements:

  IFsaPremigratedRec::SetRecallTime

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPremigratedRec::SetRecallTime"),OLESTR(""));

    try {
        m_RecallTime = time;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPremigratedRec::SetRecallTime"),
        OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CFsaPremigratedRec::SetSize(
    IN LONGLONG Size 
    ) 
/*++

Implements:

  IFsaPremigratedRec::SetSize

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPremigratedRec::SetSize"),OLESTR(""));

    try {
        m_Size = Size;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPremigratedRec::SetSize"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CFsaPremigratedRec::UpdateKey(
    IWsbDbKey *pKey
    ) 
/*++

Implements:

  IWsbDbEntity::UpdateKey

--*/
{ 
    HRESULT     hr = S_OK; 

    try {
        ULONG    KeyType;

        WsbAffirmHr(pKey->GetType(&KeyType));
        switch (KeyType) {
        case PREMIGRATED_ACCESS_TIME_KEY_TYPE:
            WsbAffirmHr(pKey->SetToBool(m_IsWaitingForClose));
            WsbAffirmHr(pKey->AppendFiletime(m_AccessTime));
            WsbAffirmHr(pKey->AppendGuid(m_BagId));
            WsbAffirmHr(pKey->AppendLonglong(m_BagOffset));
            break;

        case PREMIGRATED_BAGID_OFFSETS_KEY_TYPE:
            WsbAffirmHr(pKey->SetToGuid(m_BagId));
            WsbAffirmHr(pKey->AppendLonglong(m_BagOffset));
            WsbAffirmHr(pKey->AppendLonglong(m_Offset));
            break;

        case PREMIGRATED_SIZE_KEY_TYPE:
            WsbAffirmHr(pKey->SetToBool(m_IsWaitingForClose));
            WsbAffirmHr(pKey->AppendLonglong(m_Size));
            WsbAffirmHr(pKey->AppendGuid(m_BagId));
            WsbAffirmHr(pKey->AppendLonglong(m_BagOffset));
            break;
        }
    } WsbCatch(hr);

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\fsa\fsarcvy.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    fsarcvy.cpp

Abstract:

    Defines the functions for the recovery record class.

Author:

    Ron White   [ronw]   8-Sep-1997

Revision History:

    Steve Wimmer    [stevew]    30-July-1998
        - updated CFsaRecoveryRec::GetClassId's WsbTraceOut to hold 
            the proper function name

--*/


#include "stdafx.h"
#include "wsb.h"


#include "fsarcvy.h"

#define WSB_TRACE_IS        WSB_TRACE_BIT_FSA


HRESULT 
CFsaRecoveryRec::GetBagId(
    OUT GUID* pId 
    ) 
/*++

Implements:

  IFsaRecoveryRec::GetBagId

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaRecoveryRec::GetBagId"),OLESTR(""));

    try {
        WsbAssert(0 != pId, E_POINTER);

        *pId = m_BagId;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaRecoveryRec::GetBagId"),    OLESTR("hr = <%ls> Id = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pId));

    return(hr);
}


HRESULT 
CFsaRecoveryRec::GetBagOffset(
    OUT LONGLONG* pOffset 
    ) 
/*++

Implements:

  IFsaRecoveryRec::GetBagOffset

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaRecoveryRec::GetBagOffset"),OLESTR(""));

    try {
        WsbAssert(0 != pOffset, E_POINTER);
        *pOffset = m_BagOffset;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaRecoveryRec::GetBagOffset"),    OLESTR("hr = <%ls> Offset = <%ls>"), WsbHrAsString(hr), WsbLonglongAsString(*pOffset));

    return(hr);
}


HRESULT 
CFsaRecoveryRec::GetFileId(
    OUT LONGLONG* pFileId 
    ) 
/*++

Implements:

  IFsaRecoveryRec::GetFileId

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaRecoveryRec::GetFileId"),OLESTR(""));

    try {
        WsbAssert(0 != pFileId, E_POINTER);
        *pFileId = m_FileId;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaRecoveryRec::GetFileId"),
        OLESTR("hr = <%ls> Size = <%ls>"), WsbHrAsString( hr ), WsbLonglongAsString( *pFileId ) );

    return(hr);
}


HRESULT 
CFsaRecoveryRec::GetOffsetSize(
    OUT LONGLONG* pOffset,
    OUT LONGLONG* pSize
    ) 
/*++

Implements:

  IFsaRecoveryRec::GetOffsetSize

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaRecoveryRec::GetOffsetSize"),OLESTR(""));

    try {
        WsbAssertPointer(pOffset);
        WsbAssertPointer(pSize);
        *pOffset = m_Offset;
        *pSize   = m_Size;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaRecoveryRec::GetOffsetSize"), OLESTR("hr = <%ls> Offset = %I64d, Size = %I64d"), 
        WsbHrAsString(hr), *pOffset, *pSize);

    return(hr);
}


HRESULT 
CFsaRecoveryRec::GetPath(
    OUT OLECHAR** ppPath,
    IN  ULONG     bufferSize
    ) 
/*++

Implements:

  IFsaRecoveryRec::GetPath

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaRecoveryRec::GetPath"),OLESTR(""));

    try {
        WsbAssert(0 != ppPath, E_POINTER);
        WsbAffirmHr(m_Path.CopyTo(ppPath, bufferSize));
        WsbTrace( OLESTR("CFsaRecoveryRec::GetPath path = <%ls>\n"), *ppPath );
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaRecoveryRec::GetPath"),
        OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CFsaRecoveryRec::GetRecoveryCount(
    OUT LONG* pRecoveryCount 
    ) 
/*++

Implements:

  IFsaRecoveryRec::GetRecoveryCount

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaRecoveryRec::GetRecoveryCount"),OLESTR(""));

    try {
        WsbAssertPointer(pRecoveryCount);
        *pRecoveryCount = m_RecoveryCount;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaRecoveryRec::GetRecoveryCount"), OLESTR("hr = <%ls> RecoveryCount = %ld"), 
        WsbHrAsString(hr), *pRecoveryCount);

    return(hr);
}


HRESULT 
CFsaRecoveryRec::GetStatus(
    OUT ULONG* pStatus 
    ) 
/*++

Implements:

  IFsaRecoveryRec::GetStatus

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaRecoveryRec::GetStatus"),OLESTR(""));

    try {
        WsbAssertPointer(pStatus);
        *pStatus = m_Status;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaRecoveryRec::GetStatus"), OLESTR("hr = <%ls> Status = %lx"), 
        WsbHrAsString(hr), *pStatus);

    return(hr);
}


HRESULT 
CFsaRecoveryRec::FinalConstruct(
    void
    ) 
/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssertHr(CWsbDbEntity::FinalConstruct());

        m_BagId = GUID_NULL;
        m_BagOffset = 0;
        m_FileId = 0;
        m_Offset = 0;
        m_RecoveryCount = 0;
        m_Size   = 0;
        m_Status = 0;

    } WsbCatch(hr);

    return(hr);
}


HRESULT 
CFsaRecoveryRec::FinalRelease(
    void
    ) 
/*++

Implements:

  CComObjectRoot::FinalRelease

--*/
{
    HRESULT     hr = S_OK;

    CWsbDbEntity::FinalRelease();

    return(hr);
}


HRESULT CFsaRecoveryRec::GetClassID
(
    OUT LPCLSID pclsid
    ) 
/*++

Implements:

  IPerist::GetClassID

--*/

{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaRecoveryRec::GetClassID"), OLESTR(""));


    try {
        WsbAssertPointer(pclsid);
        *pclsid = CLSID_CFsaRecoveryRec;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaRecoveryRec::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pclsid));
    return(hr);
}


HRESULT CFsaRecoveryRec::Load
(
    IN IStream* pStream
    ) 
/*++

Implements:

  IPersistStream::Load

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaRecoveryRec::Load"), OLESTR(""));

    try {
        OLECHAR* pPath = NULL;

        WsbAssertPointer(pStream);
        WsbAssertHr(WsbLoadFromStream(pStream, &m_BagId));
        WsbAssertHr(WsbLoadFromStream(pStream, &m_BagOffset));
        WsbAssertHr(WsbLoadFromStream(pStream, &m_FileId));
        WsbAssertHr(WsbLoadFromStream(pStream, &m_Offset));
        WsbAssertHr(WsbLoadFromStream(pStream, &m_Path, 0));
        WsbAssertHr(WsbLoadFromStream(pStream, &m_RecoveryCount));
        WsbAssertHr(WsbLoadFromStream(pStream, &m_Size));
        WsbAssertHr(WsbLoadFromStream(pStream, &m_Status));

    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CFsaRecoveryRec::Load"), 
        OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT CFsaRecoveryRec::Print
(
    IN IStream* pStream
    ) 
/*++

Implements:

  IWsbDbEntity::Print

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaRecoveryRec::Print"), OLESTR(""));

    try {
        WsbAssertPointer(pStream);
        CWsbStringPtr strGuid;
        WsbAffirmHr(WsbSafeGuidAsString(m_BagId, strGuid));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" BagId = %ls"), (WCHAR *)strGuid));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" BagOffset = %I64d"), m_BagOffset));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" FileId = %I64d"), m_FileId));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" Offset = %I64d"), m_Offset));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" Size = %I64d"), m_Size));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" RecoveryCount = %ld"), 
                m_RecoveryCount));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" Status = %lx"), m_Status));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(", Path = %ls"), 
                static_cast<OLECHAR*>(m_Path)));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaRecoveryRec::Print"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT CFsaRecoveryRec::Save
(
    IN IStream* pStream, 
    IN BOOL clearDirty
    ) 
/*++

Implements:

  IPersistStream::Save

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaRecoveryRec::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));

    try {
        WsbAssertPointer(pStream);
        WsbAssertHr(WsbSaveToStream(pStream, m_BagId));
        WsbAssertHr(WsbSaveToStream(pStream, m_BagOffset));
        WsbAssertHr(WsbSaveToStream(pStream, m_FileId));
        WsbAssertHr(WsbSaveToStream(pStream, m_Offset));
        WsbAssertHr(WsbSaveToStream(pStream, m_Path));
        WsbAssertHr(WsbSaveToStream(pStream, m_RecoveryCount));
        WsbAssertHr(WsbSaveToStream(pStream, m_Size));
        WsbAssertHr(WsbSaveToStream(pStream, m_Status));

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaRecoveryRec::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CFsaRecoveryRec::SetBagId(
    IN GUID BagId
    ) 
/*++

Implements:

  IFsaRecoveryRec::SetBagId

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaRecoveryRec::SetBagId"),OLESTR(""));

    m_BagId = BagId;

    WsbTraceOut(OLESTR("CFsaRecoveryRec::SetBagId"),    OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CFsaRecoveryRec::SetBagOffset(
    IN LONGLONG BagOffset 
    ) 
/*++

Implements:

  IFsaRecoveryRec::SetBagOffset

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaRecoveryRec::SetBagOffset"),OLESTR(""));

    m_BagOffset = BagOffset;

    WsbTraceOut(OLESTR("CFsaRecoveryRec::SetBagOffset"),    OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CFsaRecoveryRec::SetFileId(
    IN LONGLONG FileId 
    ) 
/*++

Implements:

  IFsaRecoveryRec::SetFileId

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaRecoveryRec::SetFileId"),OLESTR(""));

    try {
        m_FileId = FileId;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaRecoveryRec::SetFileId"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CFsaRecoveryRec::SetOffsetSize(
    IN LONGLONG Offset,
    IN LONGLONG Size
    ) 
/*++

Implements:

  IFsaRecoveryRec::SetOffsetSize

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaRecoveryRec::SetOffsetSize"),OLESTR("Offset = %I64d, Size = %I64d"),
            Offset, Size);

    m_Offset = Offset;
    m_Size   = Size;

    WsbTraceOut(OLESTR("CFsaRecoveryRec::SetOffsetSize"),   OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CFsaRecoveryRec::SetPath(
    IN OLECHAR* Path 
    ) 
/*++

Implements:

  IFsaRecoveryRec::SetPath

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaRecoveryRec::SetPath"),OLESTR("Path = <%ls>"),
            Path);

    try {
        m_Path = Path;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaRecoveryRec::SetPath"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CFsaRecoveryRec::SetRecoveryCount(
    IN LONG RecoveryCount 
    ) 
/*++

Implements:

  IFsaRecoveryRec::SetRecoveryCount

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaRecoveryRec::SetRecoveryCount"),OLESTR("RecoveryCount = %ld"),
            RecoveryCount);

    m_RecoveryCount = RecoveryCount;

    WsbTraceOut(OLESTR("CFsaRecoveryRec::SetRecoveryCount"),    OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CFsaRecoveryRec::SetStatus(
    IN ULONG Status 
    ) 
/*++

Implements:

  IFsaRecoveryRec::SetStatus

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaRecoveryRec::SetStatus"),OLESTR("Status = %lx"),
            Status);

    m_Status = Status;

    WsbTraceOut(OLESTR("CFsaRecoveryRec::SetStatus"),   OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CFsaRecoveryRec::UpdateKey(
    IWsbDbKey *pKey
    ) 
/*++

Implements:

  IWsbDbEntity::UpdateKey

--*/
{ 
    HRESULT     hr = E_FAIL; 

    try {
        UCHAR    FileKey[RECOVERY_KEY_SIZE + 1];
        ULONG    KeyType;

        WsbAffirmHr(pKey->GetType(&KeyType));
        if (RECOVERY_KEY_TYPE == KeyType) {
            WsbAffirmHr(SquashFilepath(m_Path, FileKey, RECOVERY_KEY_SIZE));
            WsbAffirmHr(pKey->SetToBytes(FileKey, RECOVERY_KEY_SIZE));
            hr = S_OK;
        }
    } WsbCatch(hr);

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\fsa\fsatrunc.h ===
#ifndef _FSATRUNC_
#define _FSATRUNC_

/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    fsatrunc.h

Abstract:

    This class handles the automatic truncation of files that have already been premigrated.

Author:

    Chuck Bardeen   [cbardeen]   20-Feb-1997

Revision History:

--*/

#include "resource.h"       // main symbols

#include "fsa.h"


#define FSA_REGISTRY_TRUNCATOR_INTERVAL     OLESTR("TruncatorInterval")
#define FSA_REGISTRY_TRUNCATOR_FILES        OLESTR("TruncatorFiles")

extern DWORD FsaStartTruncator(void* pVoid);


/*++

Class Name:
    
    CFsaTruncator

Class Description:

    This class handles the automatic truncation of files that have already been premigrated.

--*/

class CFsaTruncator : 
    public CWsbPersistStream,
    public IHsmSessionSinkEveryEvent,
    public IFsaTruncator,
    public CComCoClass<CFsaTruncator, &CLSID_CFsaTruncatorNTFS>
{
public:
    CFsaTruncator() {}
BEGIN_COM_MAP(CFsaTruncator)
    COM_INTERFACE_ENTRY(IFsaTruncator)
    COM_INTERFACE_ENTRY(IHsmSessionSinkEveryEvent)
    COM_INTERFACE_ENTRY(IPersist)
    COM_INTERFACE_ENTRY(IPersistStream)
END_COM_MAP()

//DECLARE_NO_REGISTRY()
DECLARE_REGISTRY_RESOURCEID(IDR_FsaTruncator)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);
    STDMETHOD(FinalRelease)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// CFsaTruncator
    STDMETHOD(Cancel)(HSM_JOB_EVENT event);
    STDMETHOD(LowerPriority)(void);
    STDMETHOD(Pause)(void);
    STDMETHOD(RaisePriority)(void);
    STDMETHOD(Resume)(void);
    STDMETHOD(SetState)(HSM_JOB_STATE state);
    STDMETHOD(StartScan)(void);

// IHsmSessionSinkEveryEvent
    STDMETHOD(ProcessSessionEvent)(IHsmSession* pSession, HSM_JOB_PHASE phase, HSM_JOB_EVENT event);

// IHsmSystemState
    STDMETHOD( ChangeSysState )( HSM_SYSTEM_STATE* pSysState );

// IFsaTruncator
public:
    STDMETHOD(GetKeepRecallTime)(FILETIME* pTime);
    STDMETHOD(GetMaxFilesPerRun)(LONGLONG* pMaxFiles);
    STDMETHOD(GetPremigratedSortOrder)(FSA_PREMIGRATED_SORT_ORDER* pSortOrder);
    STDMETHOD(GetRunInterval)(ULONG* pMilliseconds);
    STDMETHOD(GetSession)(IHsmSession** ppSession);
    STDMETHOD(SetKeepRecallTime)(FILETIME time);
    STDMETHOD(SetMaxFilesPerRun)(LONGLONG maxFiles);
    STDMETHOD(SetPremigratedSortOrder)(FSA_PREMIGRATED_SORT_ORDER SortOrder);
    STDMETHOD(SetRunInterval)(ULONG milliseconds);
    STDMETHOD(Start)(IFsaResource* pResource);
    STDMETHOD(KickStart)(void);

protected:
    HSM_JOB_STATE               m_state;
    HSM_JOB_PRIORITY            m_priority;
    HANDLE                      m_threadHandle;
    DWORD                       m_threadId;
    HRESULT                     m_threadHr;
    CComPtr<IHsmSession>        m_pSession;
    LONGLONG                    m_maxFiles;
    ULONG                       m_runInterval;
    ULONG                       m_runId;
    FSA_PREMIGRATED_SORT_ORDER  m_SortOrder;
    ULONG                       m_subRunId;
    CWsbStringPtr               m_currentPath;
    FILETIME                    m_keepRecallTime;
    DWORD                       m_cookie;
    HANDLE                      m_event;
};

#endif  // _FSATRUNC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\fsa\fsatrace.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    FsaTrace.cpp

Abstract:

    These functions are used to provide an ability to trace the flow
    of the application for FSA debugging purposes.

Author:

    Cat Brant   [cbrant]   7-Dec-1996

Revision History:

--*/

#include "stdafx.h"
#include "stdio.h"

#include "fsa.h"


const OLECHAR*
FsaRequestActionAsString(
    FSA_REQUEST_ACTION  requestAction
    )

/*++

Routine Description:

    This routine provides a string repesentation (e.g. FSA_REQUSEST_ACTION_MIGRATE) for
    the value of the request action supplied.
    
    NOTE: This method does not support localization of the strings.

Arguments:

    requestAction       - An FSA_REQUEST_ACTION value.

Return Value:

    A string representation of the value of the request action.

--*/
{
    static OLECHAR  returnString[60];

    switch (requestAction) {
    case FSA_REQUEST_ACTION_DELETE:
        swprintf(returnString, OLESTR("FSA_REQUEST_ACTION_DELETE"));
            break;
    case FSA_REQUEST_ACTION_FILTER_RECALL:
        swprintf(returnString, OLESTR("FSA_REQUEST_ACTION_FIILTER_RECALL"));
            break;
    case FSA_REQUEST_ACTION_PREMIGRATE:
        swprintf(returnString, OLESTR("FSA_REQUEST_ACTION_PREMIGRATE"));
            break;
    case FSA_REQUEST_ACTION_RECALL:
        swprintf(returnString, OLESTR("FSA_REQUEST_ACTION_RECALL"));
            break;
    case FSA_REQUEST_ACTION_VALIDATE:
        swprintf(returnString, OLESTR("FSA_REQUEST_ACTION_VALIDATE"));
            break;
    default:
        swprintf(returnString, OLESTR("UNKNOWN FSA_REQUEST_ACTION_?????"));
            break;
    }

    return(returnString);
}


const OLECHAR*
FsaResultActionAsString(
    FSA_RESULT_ACTION  resultAction
    )

/*++

Routine Description:

    This routine provides a string repesentation (e.g. FSA_RESULT_ACTION_TRUNCATE) for
    the value of the result action supplied.
    
    NOTE: This method does not support localization of the strings.

Arguments:

    resultAction        - An FSA_RESULT_ACTION value.

Return Value:

    A string representation of the value of the result action.

--*/
{
    static OLECHAR  returnString[60];

    switch (resultAction) {
    case FSA_RESULT_ACTION_DELETE:
        swprintf(returnString, OLESTR("FSA_RESULT_ACTION_DELETE"));
            break;
    case FSA_RESULT_ACTION_DELETEPLACEHOLDER:
        swprintf(returnString, OLESTR("FSA_RESULT_ACTION_DELETEPLACEHOLDER"));
            break;
    case FSA_RESULT_ACTION_LIST:
        swprintf(returnString, OLESTR("FSA_RESULT_ACTION_LIST"));
            break;
    case FSA_RESULT_ACTION_OPEN:
        swprintf(returnString, OLESTR("FSA_RESULT_ACTION_OPEN"));
            break;
    case FSA_RESULT_ACTION_PEEK:
        swprintf(returnString, OLESTR("FSA_RESULT_ACTION_PEEK"));
            break;
    case FSA_RESULT_ACTION_REPARSE:
        swprintf(returnString, OLESTR("FSA_RESULT_ACTION_REPARSE"));
            break;
    case FSA_RESULT_ACTION_TRUNCATE:
        swprintf(returnString, OLESTR("FSA_RESULT_ACTION_TRUNCATE"));
            break;
    case FSA_RESULT_ACTION_REWRITEPLACEHOLDER:
        swprintf(returnString, OLESTR("FSA_RESULT_ACTION_REWRITEPLACEHOLDER"));
            break;
    case FSA_RESULT_ACTION_RECALLEDDATA:
        swprintf(returnString, OLESTR("FSA_RESULT_ACTION_RECALLEDDATA"));
            break;
    case FSA_RESULT_ACTION_NONE:
        swprintf(returnString, OLESTR("FSA_RESULT_ACTION_NONE"));
            break;
    default:
        swprintf(returnString, OLESTR("UNKNOWN FSA_RESULT_ACTION_?????"));
            break;
    }

    return(returnString);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\fsa\fsatrunc.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    fsatrunc.cpp

Abstract:

    This class handles the automatic truncation of files that have already 
    been premigrated.

Author:

    Chuck Bardeen   [cbardeen]   20-Feb-1997

Revision History:

--*/

#include "stdafx.h"

#define WSB_TRACE_IS        WSB_TRACE_BIT_FSA

#include "wsb.h"
#include "fsa.h"
#include "fsaprem.h"
#include "fsarcvy.h"
#include "fsasrvr.h"
#include "fsatrunc.h"
#include "job.h"

#define DEFAULT_MAX_FILES_PER_RUN  10000
#define DEFAULT_RUN_INTERVAL       (15 * 60 * 1000)  // 15 minutes in milliseconds

#define STRINGIZE(_str) (OLESTR( #_str ))
#define RETURN_STRINGIZED_CASE(_case) \
case _case:                           \
    return ( STRINGIZE( _case ) );


static const OLECHAR *
FsaStateAsString (
    IN  HSM_JOB_STATE  state
    )

/*++

Routine Description:

    Gives back a static string representing the connection state. 

Arguments:

    state - the state to return a string for.

Return Value:

    NULL - invalid state passed in.

    Otherwise, a valid char *.

--*/

{
    //
    // Do the Switch
    //

    switch ( state ) {

    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_ACTIVE );
    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_CANCELLED );
    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_CANCELLING );
    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_DONE );
    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_FAILED );
    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_IDLE );
    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_PAUSED );
    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_PAUSING );
    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_RESUMING );
    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_SKIPPED );
    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_STARTING );
    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_SUSPENDED );
    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_SUSPENDING );

    default:

        return ( OLESTR("Invalid Value") );

    }
}


static const OLECHAR *
FsaEventAsString (
    IN HSM_JOB_EVENT event
    )

/*++

Routine Description:

    Gives back a static string representing the connection event. 

Arguments:

    event - the event to return a string for.

Return Value:

    NULL - invalid event passed in.

    Otherwise, a valid char *.

--*/

{
    //
    // Do the Switch
    //

    switch ( event ) {

    RETURN_STRINGIZED_CASE( HSM_JOB_EVENT_CANCEL );
    RETURN_STRINGIZED_CASE( HSM_JOB_EVENT_FAIL );
    RETURN_STRINGIZED_CASE( HSM_JOB_EVENT_LOWER_PRIORITY );
    RETURN_STRINGIZED_CASE( HSM_JOB_EVENT_PAUSE );
    RETURN_STRINGIZED_CASE( HSM_JOB_EVENT_RAISE_PRIORITY );
    RETURN_STRINGIZED_CASE( HSM_JOB_EVENT_RESUME );
    RETURN_STRINGIZED_CASE( HSM_JOB_EVENT_START );
    RETURN_STRINGIZED_CASE( HSM_JOB_EVENT_SUSPEND );

    default:

        return ( OLESTR("Invalid Value") );

    }
}



static const OLECHAR *
FsaSortOrderAsString (
    IN FSA_PREMIGRATED_SORT_ORDER SortOrder
    )

/*++

Routine Description:

    Gives back a static string representing the connection SortOrder. 

Arguments:

    SortOrder - the SortOrder to return a string for.

Return Value:

    NULL - invalid SortOrder passed in.

    Otherwise, a valid char *.

--*/

{
    //
    // Do the Switch
    //

    switch ( SortOrder ) {

    RETURN_STRINGIZED_CASE( FSA_SORT_PL_BY_ACCESS_TIME );
    RETURN_STRINGIZED_CASE( FSA_SORT_PL_BY_SIZE );
    RETURN_STRINGIZED_CASE( FSA_SORT_PL_BY_PATH_NAME );
    RETURN_STRINGIZED_CASE( FSA_SORT_PL_BY_SIZE_AND_TIME );

    default:

        return ( OLESTR("Invalid Value") );

    }
}


DWORD FsaStartTruncator(
    void* pVoid
    )

/*++


--*/
{
    return(((CFsaTruncator*) pVoid)->StartScan());
}




HRESULT
CFsaTruncator::Cancel(
    HSM_JOB_EVENT       event
    )

/*++

Implements:

  IFsaTruncator::Cancel().

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CFsaTruncator::Cancel"), OLESTR("event = <%ls>"), FsaEventAsString( event ));

    //  Lock this object to avoid having the state change between testing its value
    //  and setting it to a new value
    Lock();
    try {

        // If we have started, but haven't finished, then change the state of the job. The thread
        // will exit on it's own.
        if ((HSM_JOB_STATE_IDLE != m_state) &&
            (HSM_JOB_STATE_DONE != m_state) &&
            (HSM_JOB_STATE_FAILED != m_state) &&
            (HSM_JOB_STATE_CANCELLED != m_state)) {

            if (HSM_JOB_EVENT_CANCEL == event) {
                WsbAffirmHr(SetState(HSM_JOB_STATE_CANCELLED));
            } else if (HSM_JOB_EVENT_SUSPEND == event) {
                WsbAffirmHr(SetState(HSM_JOB_STATE_SUSPENDED));
            } else if (HSM_JOB_EVENT_FAIL == event) {
                WsbAffirmHr(SetState(HSM_JOB_STATE_FAILED));
            } else {
                WsbAssert(FALSE, E_UNEXPECTED);
            }
        }

    } WsbCatch(hr);
    Unlock();

    WsbTraceOut(OLESTR("CFsaTruncator::Cancel"), OLESTR("hr = <%ls> m_state = <%ls>"), WsbHrAsString(hr), FsaStateAsString( m_state ) );
    return(hr);
}


HRESULT
CFsaTruncator::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT                     hr = S_OK;
    
    WsbTraceIn(OLESTR("CFsaTruncator::FinalConstruct"), OLESTR(""));

    try {

        WsbAffirmHr(CWsbPersistStream::FinalConstruct());

        m_state = HSM_JOB_STATE_IDLE;
        m_priority = HSM_JOB_PRIORITY_NORMAL;
        m_threadHandle = 0;
        m_threadId = 0;
        m_threadHr = S_OK;
        m_maxFiles = DEFAULT_MAX_FILES_PER_RUN;
        m_runInterval = DEFAULT_RUN_INTERVAL;
        m_runId = 0;
        m_subRunId = 0;
        m_pSession = 0;
        m_SortOrder = FSA_SORT_PL_BY_ACCESS_TIME;
        m_keepRecallTime = WsbLLtoFT(WSB_FT_TICKS_PER_MINUTE);
        m_event = 0;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaTruncator::FinalConstruct"), OLESTR(""));

    return(hr);
}


HRESULT
CFsaTruncator::FinalRelease(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalRelease().

--*/
{
    HRESULT          hr = S_OK;
    HSM_SYSTEM_STATE SysState;

    WsbTraceIn(OLESTR("CFsaTruncator::FinalRelease"), OLESTR(""));

    SysState.State = HSM_STATE_SHUTDOWN;
    ChangeSysState(&SysState);

    CWsbPersistStream::FinalRelease();

    // Free String members
    // Note: Member objects held in smart-pointers are freed when the 
    // smart-pointer destructor is being called (as part of this object destruction)
    m_currentPath.Free();

    WsbTraceOut(OLESTR("CFsaTruncator::FinalRelease"), OLESTR(""));

    return(hr);

}


HRESULT
CFsaTruncator::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaTruncator::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CFsaTruncatorNTFS;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaTruncator::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CFsaTruncator::GetKeepRecallTime(
    OUT FILETIME* pTime
    )

/*++

Implements:

  IFsaTruncator::GetKeepRecallTime().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaTruncator::GetKeepRecallTime"), OLESTR(""));

    try {

        WsbAssert(0 != pTime, E_POINTER);
        *pTime = m_keepRecallTime;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaTruncator::GetKeepRecallTime"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaTruncator::GetMaxFilesPerRun(
    OUT LONGLONG* pMaxFiles
    )

/*++

Implements:

  IFsaTruncator::GetMaxFilesPerRun().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaTruncator::GetMaxFilesPerRun"), OLESTR(""));

    try {

        WsbAssert(0 != pMaxFiles, E_POINTER);
        *pMaxFiles = m_maxFiles;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaTruncator::GetMaxFilesPerRun"), OLESTR("hr = <%ls> maxFiles = <%ls>"), WsbHrAsString(hr), WsbLonglongAsString( *pMaxFiles ) );

    return(hr);
}


HRESULT
CFsaTruncator::GetPremigratedSortOrder(
    OUT FSA_PREMIGRATED_SORT_ORDER* pSortOrder
    )

/*++

Implements:

  IFsaTruncator::GetPremigratedSortOrder().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaTruncator::GetPremigratedSortOrder"), OLESTR(""));

    try {

        WsbAssert(0 != pSortOrder, E_POINTER);
        *pSortOrder = m_SortOrder;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaTruncator::GetPremigratedSortOrder"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaTruncator::GetRunInterval(
    OUT ULONG* pMilliseconds
    )

/*++

Implements:

  IFsaTruncator::GetRunInterval().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaTruncator::GetRunInterval"), OLESTR(""));

    try {

        WsbAssert(0 != pMilliseconds, E_POINTER);
        *pMilliseconds = m_runInterval;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaTruncator::GetRunInterval"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaTruncator::GetSession(
    OUT IHsmSession** ppSession
    )

/*++

Implements:

  IFsaTruncator::GetSession().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaTruncator::GetSession"), OLESTR(""));

    try {

        WsbAssert(0 != ppSession, E_POINTER);
        *ppSession = m_pSession;
        if (m_pSession != 0) {
            m_pSession.p->AddRef();
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaTruncator::GetSession"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaTruncator::GetSizeMax(
    OUT ULARGE_INTEGER* pSize
    )

/*++

Implements:

  IPersistStream::GetSizeMax().

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CFsaTruncator::GetSizeMax"), OLESTR(""));

    try {

        WsbAssert(0 != pSize, E_POINTER);

        // Determine the size for a rule with no criteria.
        pSize->QuadPart = WsbPersistSizeOf(LONGLONG) + 3 * WsbPersistSizeOf(ULONG) + WsbPersistSizeOf(FILETIME);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaTruncator::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pSize));

    return(hr);
}



HRESULT
CFsaTruncator::KickStart(
    void
    )

/*++

Implements:

  IFsaTruncator:KickStart

    Data was just moved for this volume - wake up the truncator thread in case we need space.

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IFsaResource>   pResource;
    ULONG                   freeLevel;
    ULONG                   hsmLevel;


    WsbTraceIn(OLESTR("CFsaTruncator::KickStart"), OLESTR(""));

    try {
        if (m_pSession) {
            WsbAffirmHr(m_pSession->GetResource(&pResource));

            // If the truncator is running and the resource does not have enough free space
            // check to see if the resource is over the threshold and truncation is needed.
            WsbAffirmHr(pResource->GetHsmLevel(&hsmLevel));
            WsbAffirmHr(pResource->GetFreeLevel(&freeLevel));

            if (freeLevel < hsmLevel) {
                WsbTrace(OLESTR("CFsaTruncator::KickStarting truncator.\n"));
                SetEvent(m_event);
            }
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaTruncator::KickStart"), OLESTR("hr = <%ls>>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaTruncator::Load(
    IN IStream* pStream
    )

/*++

Implements:

  IPersistStream::Load().

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaTruncator::Load"), OLESTR(""));

    try {
        USHORT us_tmp;
        ULONG  ul_tmp;

        WsbAssert(0 != pStream, E_POINTER);
        
        // Do the easy stuff, but make sure that this order matches the order
        // in the save method.
        WsbAffirmHr(WsbLoadFromStream(pStream, &ul_tmp));
        m_priority = static_cast<HSM_JOB_PRIORITY>(ul_tmp);
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_maxFiles));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_runInterval));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_runId));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_keepRecallTime));
        WsbAffirmHr(WsbLoadFromStream(pStream, &us_tmp));
        m_SortOrder = static_cast<FSA_PREMIGRATED_SORT_ORDER>(us_tmp);
        
        // Check to see if values for maxFiles and runInterval are specified in the registry.
        // If so, use these values instead of the ones stored.
        {
            DWORD               sizeGot;
            CWsbStringPtr       tmpString;
            
            WsbAffirmHr(tmpString.Alloc(256));
            
            if (SUCCEEDED(WsbGetRegistryValueString(NULL, FSA_REGISTRY_PARMS, FSA_REGISTRY_TRUNCATOR_INTERVAL, tmpString, 256, &sizeGot))) {
                m_runInterval = 1000 * wcstoul(tmpString, NULL, 10);
            } else {
                m_runInterval = DEFAULT_RUN_INTERVAL;
            }

            if (SUCCEEDED(WsbGetRegistryValueString(NULL, FSA_REGISTRY_PARMS, FSA_REGISTRY_TRUNCATOR_FILES, tmpString, 256, &sizeGot))) {
                m_maxFiles = (LONGLONG) wcstoul(tmpString, NULL, 10);
            } else {
                m_maxFiles = DEFAULT_MAX_FILES_PER_RUN;
            }
        }
            
    } WsbCatch(hr);                                        

    WsbTraceOut(OLESTR("CFsaTruncator::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaTruncator::LowerPriority(
    void
    )

/*++


--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CFsaTruncator::LowerPriority"), OLESTR(""));
    try {

        WsbAssert(0 != m_threadHandle, E_UNEXPECTED);
        WsbAssert(m_pSession != 0, E_UNEXPECTED);

        switch(m_priority) {
            case HSM_JOB_PRIORITY_IDLE:
                WsbAffirm(FALSE, E_UNEXPECTED);
                break;

            case HSM_JOB_PRIORITY_LOWEST:
                WsbAffirmStatus(SetThreadPriority(m_threadHandle, THREAD_PRIORITY_IDLE));
                m_priority = HSM_JOB_PRIORITY_IDLE;
                break;

            case HSM_JOB_PRIORITY_LOW:
                WsbAffirmStatus(SetThreadPriority(m_threadHandle, THREAD_PRIORITY_LOWEST));
                m_priority = HSM_JOB_PRIORITY_LOWEST;
                break;

            case HSM_JOB_PRIORITY_NORMAL:
                WsbAffirmStatus(SetThreadPriority(m_threadHandle, THREAD_PRIORITY_BELOW_NORMAL));
                m_priority = HSM_JOB_PRIORITY_LOW;
                break;

            case HSM_JOB_PRIORITY_HIGH:
                WsbAffirmStatus(SetThreadPriority(m_threadHandle, THREAD_PRIORITY_NORMAL));
                m_priority = HSM_JOB_PRIORITY_NORMAL;
                break;

            case HSM_JOB_PRIORITY_HIGHEST:
                WsbAffirmStatus(SetThreadPriority(m_threadHandle, THREAD_PRIORITY_ABOVE_NORMAL));
                m_priority = HSM_JOB_PRIORITY_HIGH;
                break;

            default:
            case HSM_JOB_PRIORITY_CRITICAL:
                WsbAffirmStatus(SetThreadPriority(m_threadHandle, THREAD_PRIORITY_HIGHEST));
                m_priority = HSM_JOB_PRIORITY_HIGHEST;
                break;
        }

        WsbAffirmHr(m_pSession->ProcessPriority(HSM_JOB_PHASE_SCAN, m_priority));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaTruncator::LowerPriority"), OLESTR("hr = <%ls>"), WsbHrAsString(hr) );
    return(hr);
}


HRESULT
CFsaTruncator::Pause(
    void
    )

/*++

Implements:

  IFsaTruncator::Pause().

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CFsaTruncator::Pause"), OLESTR("state = %ls"),
            FsaStateAsString(m_state));

    //  Lock this object to avoid having the state change between testing its value
    //  and setting it to a new value
    Lock();
    try {

        // If we are running, then suspend the thread.
        WsbAssert(HSM_JOB_STATE_ACTIVE == m_state, E_UNEXPECTED);

        // Set the state & the active thread will not do any work
        WsbAffirmHr(SetState(HSM_JOB_STATE_PAUSING));

        // We would like to wait until the thread is really inactive, but that's
        // hard to tell because it could be in a sleep interval

    } WsbCatch(hr);
    Unlock();

    WsbTraceOut(OLESTR("CFsaTruncator::Pause"), OLESTR("hr = <%ls>"), WsbHrAsString(hr) );

    return(hr);
}


HRESULT
CFsaTruncator::ProcessSessionEvent(
    IN IHsmSession* pSession,
    IN HSM_JOB_PHASE phase,
    IN HSM_JOB_EVENT event
    )

/*++

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CFsaTruncator::ProcessSessionEvent"), OLESTR(""));

    try {
        
        WsbAssert(0 != pSession, E_POINTER);

        // If the phase applies to use (SCAN or ALL), then do any work required by the
        // event.
        if ((HSM_JOB_PHASE_ALL == phase) || (HSM_JOB_PHASE_SCAN == phase)) {

            switch(event) {

                case HSM_JOB_EVENT_SUSPEND:
                case HSM_JOB_EVENT_CANCEL:
                case HSM_JOB_EVENT_FAIL:
                    WsbAffirmHr(Cancel(event));
                    break;

                case HSM_JOB_EVENT_PAUSE:
                    WsbAffirmHr(Pause());
                    break;

                case HSM_JOB_EVENT_RESUME:
                    WsbAffirmHr(Resume());
                    break;

                case HSM_JOB_EVENT_RAISE_PRIORITY:
                    WsbAffirmHr(RaisePriority());
                    break;

                case HSM_JOB_EVENT_LOWER_PRIORITY:
                    WsbAffirmHr(LowerPriority());
                    break;

                default:
                case HSM_JOB_EVENT_START:
                    WsbAssert(FALSE, E_UNEXPECTED);
                    break;
            }
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaTruncator::ProcessSessionEvent"), OLESTR("hr = <%ls>"), WsbHrAsString(hr) );

    return(S_OK);
}


HRESULT
CFsaTruncator::RaisePriority(
    void
    )

/*++


--*/
{
    HRESULT                 hr = S_OK;

    try {

        WsbAssert(0 != m_threadHandle, E_UNEXPECTED);
        WsbAssert(m_pSession != 0, E_UNEXPECTED);

        switch(m_priority) {

            case HSM_JOB_PRIORITY_IDLE:
                WsbAffirmStatus(SetThreadPriority(m_threadHandle, THREAD_PRIORITY_LOWEST));
                m_priority = HSM_JOB_PRIORITY_LOWEST;
                break;

            case HSM_JOB_PRIORITY_LOWEST:
                WsbAffirmStatus(SetThreadPriority(m_threadHandle, THREAD_PRIORITY_BELOW_NORMAL));
                m_priority = HSM_JOB_PRIORITY_LOW;
                break;

            case HSM_JOB_PRIORITY_LOW:
                WsbAffirmStatus(SetThreadPriority(m_threadHandle, THREAD_PRIORITY_NORMAL));
                m_priority = HSM_JOB_PRIORITY_NORMAL;
                break;

            case HSM_JOB_PRIORITY_NORMAL:
                WsbAffirmStatus(SetThreadPriority(m_threadHandle, THREAD_PRIORITY_ABOVE_NORMAL));
                m_priority = HSM_JOB_PRIORITY_HIGH;
                break;

            case HSM_JOB_PRIORITY_HIGH:
                WsbAffirmStatus(SetThreadPriority(m_threadHandle, THREAD_PRIORITY_HIGHEST));
                m_priority = HSM_JOB_PRIORITY_HIGHEST;
                break;

            case HSM_JOB_PRIORITY_HIGHEST:
                WsbAffirmStatus(SetThreadPriority(m_threadHandle, THREAD_PRIORITY_TIME_CRITICAL));
                m_priority = HSM_JOB_PRIORITY_CRITICAL;
                break;

            default:
            case HSM_JOB_PRIORITY_CRITICAL:
                WsbAffirm(FALSE, E_UNEXPECTED);
                break;
        }

        WsbAffirmHr(m_pSession->ProcessPriority(HSM_JOB_PHASE_SCAN, m_priority));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaTruncator::Resume(
    void
    )

/*++

Implements:

  IFsaTruncator::Resume().

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CFsaTruncator::Resume"), OLESTR("state = %ls"),
            FsaStateAsString(m_state));

    //  Lock this object to avoid having the state change between testing its value
    //  and setting it to a new value
    Lock();
    try {

        // We should only see a resume from a paused state, so ignore the resume if we are
        // in some other state. NOTE: This used to be an assert, but it scared people since it
        // can occur occassionally.
        if ((HSM_JOB_STATE_PAUSING == m_state) || (HSM_JOB_STATE_PAUSED == m_state)) {
            WsbAffirmHr(SetState(HSM_JOB_STATE_ACTIVE));
        }

    } WsbCatch(hr);
    Unlock();

    WsbTraceOut(OLESTR("CFsaTruncator::Resume"), OLESTR("hr = <%ls>"), WsbHrAsString(hr) );

    return(hr);
}


HRESULT
CFsaTruncator::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )

/*++

Implements:

  IPersistStream::Save().

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CFsaTruncator::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));
    
    try {
        WsbAssert(0 != pStream, E_POINTER);
        
        // Do the easy stuff, but make sure that this order matches the order
        // in the save method.
        WsbAffirmHr(WsbSaveToStream(pStream, static_cast<ULONG>(m_priority)));
        WsbAffirmHr(WsbSaveToStream(pStream, m_maxFiles));
        WsbAffirmHr(WsbSaveToStream(pStream, m_runInterval));
        WsbAffirmHr(WsbSaveToStream(pStream, m_runId));
        WsbAffirmHr(WsbSaveToStream(pStream, m_keepRecallTime));
        WsbAffirmHr(WsbSaveToStream(pStream, static_cast<USHORT>(m_SortOrder)));

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaTruncator::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaTruncator::SetKeepRecallTime(
    IN FILETIME time
    )

/*++

Implements:

  IFsaTruncator::SetKeepRecallTime().

--*/
{
    WsbTraceIn(OLESTR("CFsaTruncator::SetKeepRecallTime"), OLESTR(""));

    m_keepRecallTime = time;

    WsbTraceOut(OLESTR("CFsaTruncator::SetKeepRecallTime"), OLESTR("hr = <%ls>"), WsbHrAsString(S_OK));

    return(S_OK);
}


HRESULT
CFsaTruncator::SetMaxFilesPerRun(
    IN LONGLONG maxFiles
    )

/*++

Implements:

  IFsaTruncator::SetMaxFilesPerRun().

--*/
{
    WsbTraceIn(OLESTR("CFsaTruncator::SetMaxFilesPerRun"), OLESTR(""));

    m_maxFiles = maxFiles;

    WsbTraceOut(OLESTR("CFsaTruncator::SetMaxFilesPerRun"), OLESTR("hr = <%ls>"), WsbHrAsString(S_OK));

    return(S_OK);
}


HRESULT
CFsaTruncator::SetPremigratedSortOrder(
    IN FSA_PREMIGRATED_SORT_ORDER SortOrder
    )

/*++

Implements:

  IFsaTruncator::SetSortOrder().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaTruncator::SetPremigratedSortOrder"), OLESTR("SortOrder = <%ls>"), FsaSortOrderAsString( SortOrder ) );

    // This key has not been implmented yet.
    if (FSA_SORT_PL_BY_SIZE_AND_TIME == SortOrder) {
        hr = E_NOTIMPL;
    } else {
        m_SortOrder = SortOrder;
    }

    WsbTraceOut(OLESTR("CFsaTruncator::SetPremigratedSortOrder"), OLESTR("hr = <%ls> m_SortOrder = <%ls>"), WsbHrAsString(S_OK) , FsaSortOrderAsString( m_SortOrder ) );

    return(hr);
}


HRESULT
CFsaTruncator::SetRunInterval(
    IN ULONG milliseconds
    )

/*++

Implements:

  IFsaTruncator::SetRunInterval().

--*/
{
    BOOL   DoKick = FALSE;

    WsbTraceIn(OLESTR("CFsaTruncator::SetRunInterval"), OLESTR("milliseconds = <%ls>"), WsbPtrToUlongAsString( &milliseconds ) );

    if (milliseconds < m_runInterval) {
        DoKick = TRUE;
    }
    m_runInterval = milliseconds;

    //  Wake up the Truncator if the interval has decreased
    if (DoKick) {
        KickStart();
    }

    WsbTraceOut(OLESTR("CFsaTruncator::SetRunInterval"), OLESTR("hr = <%ls> m_runInterval = <%ls>"), WsbHrAsString(S_OK), WsbPtrToUlongAsString( &m_runInterval ) );

    return(S_OK);
}


HRESULT
CFsaTruncator::SetState(
    IN HSM_JOB_STATE state
    )

/*++

--*/
{
    HRESULT         hr = S_OK;
    BOOL            bLog = FALSE;

    WsbTraceIn(OLESTR("CFsaTruncator::SetState"), OLESTR("state = <%ls>"), FsaStateAsString( state ) );
 
    // Change the state and report the change to the session.
    Lock();
    m_state = state;
    Unlock();
    hr = m_pSession->ProcessState(HSM_JOB_PHASE_SCAN, m_state, m_currentPath, bLog);

    WsbTraceOut(OLESTR("CFsaTruncator::SetState"), OLESTR("hr = <%ls> m_state = <%ls>"), WsbHrAsString(hr), FsaStateAsString( m_state ) );

    return(hr);
}


HRESULT 
CFsaTruncator::ChangeSysState( 
    IN OUT HSM_SYSTEM_STATE* pSysState 
    )

/*++

Implements:

  IHsmSystemState::ChangeSysState().

--*/

{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaTruncator::ChangeSysState"), OLESTR("thread is %ls"),
        (m_threadHandle ? OLESTR("active") : OLESTR("inactive")));

    try {
        if (pSysState->State & HSM_STATE_SUSPEND) {
            if (HSM_JOB_STATE_ACTIVE == m_state) {
                Pause();
            }
        } else if (pSysState->State & HSM_STATE_RESUME) {
            if ((HSM_JOB_STATE_PAUSING == m_state) || 
                    (HSM_JOB_STATE_PAUSED == m_state)) {
                Resume();
            }
        } else if (pSysState->State & HSM_STATE_SHUTDOWN) {
            //  Make sure the thread is stopped
            if (m_threadHandle) {
                m_state = HSM_JOB_STATE_DONE;
                if (m_event) {
                    SetEvent(m_event);
                }

                //  Wait for the thread to end
                if (m_threadHandle) {
                    WsbTrace(OLESTR("CFsaTruncator::ChangeSysState, waiting for truncator thread to end\n"));
                    switch (WaitForSingleObject(m_threadHandle, 120000)) {
                    case WAIT_FAILED:
                        WsbTrace(OLESTR("CFsaTruncator::ChangeSysState, WaitforSingleObject returned error %lu\n"),
                            GetLastError());
                        break;
                    case WAIT_TIMEOUT:
                        WsbTrace(OLESTR("CFsaTruncator::ChangeSysState, timeout.\n"));
                        break;
                    default:
                        break;
                    }
                }

                //  If the thread is still active, terminate it
                if (m_threadHandle) {
                    WsbTrace(OLESTR("CFsaTruncator::ChangeSysState: calling TerminateThread\n"));
                    if (!TerminateThread(m_threadHandle, 0)) {
                        WsbTrace(OLESTR("CFsaTruncator::ChangeSysState: TerminateThread returned error %lu\n"),
                            GetLastError());
                    }
                }
            }

            if (m_event) {
                CloseHandle(m_event);
                m_event = 0;
            }
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaTruncator::ChangeSysState"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaTruncator::Start(
    IFsaResource* pResource
    )

/*++

Implements:

  IFsaTruncator::Start().

--*/
{
    HRESULT                             hr = S_OK;
    CComPtr<IHsmSession>                pSession;
    CComPtr<IConnectionPointContainer>  pCPC;
    CComPtr<IConnectionPoint>           pCP;
    CComPtr<IHsmSessionSinkEveryEvent>  pSink;
    CWsbStringPtr                       name;

    WsbTraceIn(OLESTR("CFsaTruncator::Start"), OLESTR("m_state = <%ls>"), FsaStateAsString( m_state ) );

    try {
        if (0 == m_threadId)  {
            //
            // If the thread is dead, start one.
            //
            // Make sure that we don't already have a session, and that we haven't started already.
            WsbAssert(m_pSession == 0, E_UNEXPECTED);
            WsbAssert( (HSM_JOB_STATE_IDLE == m_state) || (HSM_JOB_STATE_DONE == m_state) || 
                    (HSM_JOB_STATE_CANCELLED == m_state) || (HSM_JOB_STATE_FAILED == m_state), E_UNEXPECTED);

            // Get the name for the session, increment the runId, and reset the subRunId.
            WsbAffirmHr(name.LoadFromRsc(_Module.m_hInst, IDS_FSA_TRUNCATOR_NAME));
            m_runId++;
            m_subRunId = 0;

            // Begin a Session.
            WsbAffirmHr(pResource->BeginSession(name, HSM_JOB_LOG_NONE, m_runId, m_subRunId, &pSession));
            m_pSession = pSession;

            // Ask the session to advise of every event.
            WsbAffirmHr(pSession->QueryInterface(IID_IConnectionPointContainer, (void**) &pCPC));
            WsbAffirmHr(pCPC->FindConnectionPoint(IID_IHsmSessionSinkEveryEvent, &pCP));
            WsbAffirmHr(((IUnknown*) (IFsaTruncator*) this)->QueryInterface(IID_IHsmSessionSinkEveryEvent, (void**) &pSink));
            WsbAffirmHr(pCP->Advise(pSink, &m_cookie));

            try {
                if (0 == m_event) {
                    WsbAssertHandle(m_event = CreateEvent(NULL, FALSE, FALSE, NULL));
                }
        
                // Now that we have prepared, create the thread that will do the scanning!
                WsbAffirm((m_threadHandle = CreateThread(0, 0, FsaStartTruncator, (void*) this, 0, &m_threadId)) != 0, HRESULT_FROM_WIN32(GetLastError()));

            } WsbCatchAndDo(hr, SetState(HSM_JOB_STATE_FAILED););
        } else  {
            // The thread is still alive, just keep it going. If it is in a state that would
            // cause it to exit, then make it active again.
            WsbAssert(m_pSession != 0, E_UNEXPECTED);
            if ((HSM_JOB_STATE_ACTIVE != m_state) && (HSM_JOB_STATE_PAUSING != m_state) &&
                (HSM_JOB_STATE_PAUSED != m_state) && (HSM_JOB_STATE_RESUMING != m_state)) {
                WsbAffirmHr(SetState(HSM_JOB_STATE_ACTIVE));
            }
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaTruncator::Start"), OLESTR("hr = <%ls> m_state = <%ls>"), WsbHrAsString(hr), FsaStateAsString( m_state ) );

    return(hr);
}


HRESULT
CFsaTruncator::StartScan(
    void
    )

/*++


--*/
{
    ULONG                               adjustedFreeLevel = 0;
    HRESULT                             hr = S_OK;
    HRESULT                             hr2;
    LONGLONG                            itemOffset;
    LONGLONG                            itemSize = 0;
    LONGLONG                            fileId;
    ULONG                               freeLevel;
    ULONG                               hsmLevel;
    BOOL                                skipFile;
    BOOL                                dummy;
    LONGLONG                            llLastTruncTime = 0;
    LONGLONG                            llRunIntervalTicks;
    FILETIME                            recallTime, currentTime, accessTime, criteriaTime, premRecAccessTime;
    LONGLONG                            totalVolumeSpace;
    CComPtr<IFsaResource>               pResource;
    CComPtr<IFsaResourcePriv>           pResourcePriv;
    CComPtr<IFsaScanItem>               pScanItem;
    CComPtr<IFsaPremigratedRec>         pPremRec;
    CComPtr<IConnectionPointContainer>  pCPC;
    CComPtr<IConnectionPoint>           pCP;
 
    try {

        WsbTrace(OLESTR("CFsaTruncator::StartScan - starting loop\n"));

        // Increment the ref count so this object (or its session) doesn't 
        // get released before this thread ends
        ((IUnknown *)(IFsaTruncator *)this)->AddRef();

        WsbAssert(m_pSession != 0, E_POINTER);

        // The thread is running.
        WsbAffirmHr(SetState(HSM_JOB_STATE_ACTIVE));

        // Get the resource
        WsbAffirmHr(m_pSession->GetResource(&pResource));
        WsbAffirmHr(pResource->QueryInterface(IID_IFsaResourcePriv, (void**) &pResourcePriv));
        WsbAffirmHr(pResource->GetSizes(&totalVolumeSpace, NULL, NULL, NULL));

        // Start with the first path.
        while ((HSM_JOB_STATE_ACTIVE == m_state) || (HSM_JOB_STATE_PAUSING == m_state) || 
               (HSM_JOB_STATE_PAUSED == m_state) || (HSM_JOB_STATE_RESUMING == m_state)) {

            WsbTrace(OLESTR("CFsaTruncator::StartScan, top of outside while loop, state = <%ls>\n"), 
                    FsaStateAsString( m_state ) );

            // If the truncator is running and the resource does not have enough free space
            // check to see if the resource is over the threshold and truncation is needed.
            WsbAffirmHr(pResource->GetHsmLevel(&hsmLevel));
            WsbAffirmHr(pResource->GetFreeLevel(&freeLevel));

            // Because the truncation is asynchronous (FsaPostIt is sent to Engine for
            // verification and then returned to FSA for actual truncation), the 
            // measured freeLevel may not be very accurate if there are truncations
            // pending.  To compensate for this, we keep an adjustedFreeLevel which
            // attempts to take into account the pending truncates.  We synchronize the
            // adjustedFreeLevel to the measured freeLevel the first time through and
            // after we have slept for a while (on the assumption that the pending
            // truncates have had time to be performed).  This still leaves open the possiblility
            // that the measured freeLevel is wrong (because truncates are pending), but
            // should be an improvement over just using the measured freeLevel.
            llRunIntervalTicks = m_runInterval * (WSB_FT_TICKS_PER_SECOND / 1000);
            GetSystemTimeAsFileTime(&currentTime);
            if (0 == adjustedFreeLevel || 
                    ((WsbFTtoLL(currentTime) - llLastTruncTime) > llRunIntervalTicks)) {
                adjustedFreeLevel = freeLevel;
                WsbTrace(OLESTR("CFsaTruncator::StartScan, resetting adjusted free level, RunInterval = %ls, time diff = %ls\n"), 
                        WsbQuickString(WsbLonglongAsString(llRunIntervalTicks)),
                        WsbQuickString(WsbLonglongAsString(WsbFTtoLL(currentTime) - llLastTruncTime)));
            }

            WsbTrace(OLESTR("CFsaTruncator::StartScan, desired level = %u, free level = %u, adjusted free level = %u\n"), 
                    hsmLevel, freeLevel, adjustedFreeLevel);

            if (adjustedFreeLevel < hsmLevel && HSM_JOB_STATE_ACTIVE == m_state) {
                CComPtr<IWsbDbSession>      pDbSession;
                CComPtr<IFsaPremigratedDb>  pPremDb;

                // Open the premigration list, and set the order in which it will be scanned.
                WsbAffirmHr(pResourcePriv->GetPremigrated(IID_IFsaPremigratedDb, 
                        (void**) &pPremDb));
                WsbAffirmHr(pPremDb->Open(&pDbSession));

                try  {
                    WsbAffirmHr(pPremDb->GetEntity(pDbSession, PREMIGRATED_REC_TYPE, IID_IFsaPremigratedRec, (void**) &pPremRec));

                    //  Set the order to get items from the Premigrated List
                    switch (m_SortOrder) {
                    case FSA_SORT_PL_BY_SIZE:
                        WsbAffirmHr(pPremRec->UseKey(PREMIGRATED_SIZE_KEY_TYPE));
                        break;

                    case FSA_SORT_PL_BY_PATH_NAME:
                        //  We use the BagId and offsets instead
                        WsbAffirmHr(pPremRec->UseKey(PREMIGRATED_BAGID_OFFSETS_KEY_TYPE));
                        break;

                    case FSA_SORT_PL_BY_SIZE_AND_TIME:
                        //  We don't know how to handle this one yet
                        WsbThrow(E_UNEXPECTED);
                        break;

                    case FSA_SORT_PL_BY_ACCESS_TIME:
                    default:
                        WsbAffirmHr(pPremRec->UseKey(PREMIGRATED_ACCESS_TIME_KEY_TYPE));
                        break;
                    }

                    // Make a pass through the list of premigrated files until the 
                    // desired level has been reached. Some items that are on the
                    // list may be in a state that causes them to be skipped, but left on the list.
                    WsbAffirmHr(pPremRec->First());

                    while ((adjustedFreeLevel < hsmLevel) && (HSM_JOB_STATE_ACTIVE == m_state)) {
                        CComPtr<IFsaRecoveryRec>       pRecRec;

                        WsbTrace(OLESTR("CFsaTruncator::StartScan (top of inside while loop) desired level = %u, adjusted free level = %u\n"), 
                                hsmLevel, adjustedFreeLevel);
                                                          
                        try {
                            skipFile = FALSE;

                            //
                            // Get the access time as recorded in the premigrated record
                            // Note that the real access time cannot be older than the one 
                            // in the premigrated list but it can be newer
                            //
                            WsbAffirmHr(pPremRec->GetAccessTime(&premRecAccessTime));
                            WsbAffirmHr(pResource->GetManageableItemAccessTime(&dummy, &criteriaTime));

                            if (WsbCompareFileTimes(premRecAccessTime, criteriaTime, TRUE, FALSE)  < 0 )  {
                                if (pPremRec->IsWaitingForClose() == S_FALSE) {
                                    //
                                    // Can skip the current file but NOT break out of the loop since
                                    // files with access time old enough and WaitingForClose flag set
                                    // may still exists in the list
                                    //
                                    skipFile = TRUE;
                                } else {
                                    //
                                    // The access time in the prem. rec is within the window.
                                    // This means there aren't any other records which are outside the
                                    // user-desired last access window. So break out
                                    //
                                    WsbTrace(OLESTR("CFsaTruncator::StartScan: breaking out of auto-truncator, encountered item with access time not within criteria\n"));
                                    hr = WSB_E_NOTFOUND;
                                    break;
                                }
                            }

                            // Get information about the file that could be truncated.
                            WsbAffirmHr(pPremRec->GetFileId(&fileId));
                            WsbAffirmHr(pPremRec->GetOffset(&itemOffset));
                            WsbAffirmHr(pPremRec->GetSize(&itemSize));
                            m_currentPath.Free();
                            WsbAffirmHr(pPremRec->GetPath(&m_currentPath, 0));
                            WsbAffirmHr(pPremRec->GetRecallTime(&recallTime));

                            GetSystemTimeAsFileTime(&currentTime);

                            // Make sure that this file wasn't recently recalled. For now,
                            // this will check for 1 minute.
                            if ((! skipFile) &&
                                ( (pPremRec->IsWaitingForClose() == S_FALSE) || 
                                    ((WsbFTtoLL(currentTime) > WsbFTtoLL(recallTime)) && 
                                    (WsbCompareFileTimes(recallTime, m_keepRecallTime, TRUE, FALSE) >= 0)) )) {

                                hr = pResource->FindFileId(fileId, m_pSession, &pScanItem);
                                if (hr == WSB_E_NOTFOUND) {
                                    //
                                    // The file does not exist anymore - remove the record from the list.
                                    //
                                    WsbAffirmHr(pDbSession->TransactionBegin());
                                    try {
                                        // Make sure the record is still in the DB
                                        WsbAffirmHr(pPremRec->FindEQ());
                                        WsbAffirmHr(pPremRec->Remove());
                                        WsbAffirmHr(pResourcePriv->RemovePremigratedSize(itemSize));
                                    } WsbCatch(hr);
                                    WsbAffirmHr(pDbSession->TransactionEnd());
                                    WsbThrow(hr);
                                } else if (hr != S_OK) {
                                    //
                                    // Any other error is unexpected - log it and continue 
                                    //
                                    WsbLogEvent(FSA_E_ACCESS_ERROR, 0, NULL, m_currentPath, WsbHrAsString(hr), NULL);
                                    WsbThrow(hr);
                                }
                              
                                //
                                // Verify that the file is still in a premigrated state
                                //
                                if (S_OK == pScanItem->IsPremigrated(itemOffset, itemSize)) {
                                    

                                    WsbAffirmHr(pScanItem->GetAccessTime(&accessTime));
                                    //
                                    // accessTime is the last access time for the file
                                    // criteriaTime is the 'not accessed in so many ticks' criteria for truncating
                                    // the file. 
                                    // So if (currentTime - accessTime) >= criteriaTime, then the file is ok to be truncated
                                    //
                                    if (WsbCompareFileTimes(accessTime, criteriaTime, TRUE, FALSE) >=0 )  {
                                        //
                                        // The file was not accessed within the last access window 
                                        //
                                         WsbTrace(OLESTR("CFsaTruncator::StartScan, truncating file <%ls>\n"),
                                                 (WCHAR *)m_currentPath);
          
                                         // Try to truncate the file.
                                         try {
                                             //  Create and save a recovery record in case something goes wrong
                                             WsbAffirmHr(pPremDb->GetEntity(pDbSession, RECOVERY_REC_TYPE, IID_IFsaRecoveryRec, (void**) &pRecRec));
                                             WsbAffirmHr(pRecRec->SetPath(m_currentPath));
      
                                             // If the record already exists rewrite it, otherwise create a new record.
                                             hr2 = pRecRec->FindEQ();
                                             if (WSB_E_NOTFOUND == hr2) {
                                                 hr2 = S_OK;
                                                 WsbAffirmHr(pRecRec->MarkAsNew());
                                             } else if (FAILED(hr2)) {
                                                 WsbThrow(hr2);
                                             }
      
                                             WsbAffirmHr(pRecRec->SetFileId(fileId));
                                             WsbAffirmHr(pRecRec->SetOffsetSize(itemOffset, itemSize));
                                             WsbAffirmHr(pRecRec->SetStatus(FSA_RECOVERY_FLAG_TRUNCATING));
                                             WsbAffirmHr(pRecRec->Write());
                                             //
                                             // Set the waiting for close flag to prevent this file
                                             // from being selected again while the engine is
                                             // processing the truncate.  Set the recall time to
                                             // now plus 1 hour so we are sure not to retry this
                                             // until we have had a chance to truncate it.
                                             //
                                             WsbAffirmHr(pPremRec->SetIsWaitingForClose(TRUE));
                                             WsbAffirmHr(pPremRec->SetRecallTime(WsbLLtoFT(WsbFTtoLL(currentTime) + WSB_FT_TICKS_PER_HOUR)));

                                             hr2 = pPremRec->Write();

                                             // Special code to deal with a problem that has been seen
                                             // but isn't understood
                                             if (WSB_E_IDB_PRIMARY_KEY_CHANGED == hr2) {
                                                 WsbAffirmHr(pPremRec->Remove());
                                                 WsbAffirmHr(pResourcePriv->RemovePremigratedSize(itemSize));
                                                 // Ignore result from DeletePlaceholder since there's nothing we
                                                 // can do anyway.
                                                 pScanItem->DeletePlaceholder(itemOffset, itemSize);
                                                 WsbThrow(FSA_E_SKIPPED);
                                             } else {
                                                 WsbAffirmHr(hr2);
                                             }

                                            //
                                            // Set IsWaitingForClose back to false so that the FindGt done later gets the next record.
                                            // This affects the in memory record only and not the persisted record.
                                            //
                                            WsbAffirmHr(pPremRec->SetIsWaitingForClose(FALSE));

                                            WsbAffirmHr(pScanItem->Truncate(itemOffset, itemSize));
                                            llLastTruncTime = WsbFTtoLL(currentTime);

                                            // Add the file size to the adjustedFreeLevel so we know when to
                                            // stop doing truncations.  Unfortunately, the itemSize is in 
                                            // bytes but adjustedFreeLevl is a fixed-point percentage so we
                                            // have to do a calculation to convert the itemSize
                                            adjustedFreeLevel += (ULONG) (((double)itemSize / 
                                                                 (double)totalVolumeSpace) * 
                                                                 (double)FSA_HSMLEVEL_100);
    
                                        } WsbCatchAndDo(hr,
    
                                         // Do we need to skip this file for the time being?
                                         if (FSA_E_SKIPPED == hr) {
                                             // Do nothing
                                         }  else if ((FSA_E_ITEMCHANGED != hr)  && (FSA_E_NOTMANAGED != hr)) {
                                             // Something unexpected happened, so report the error.
                                             WsbAffirmHr(m_pSession->ProcessHr(HSM_JOB_PHASE_FSA_ACTION, 0, 0, hr));
                                         }
                                        );
                                  }  else { 
                                      //
                                      // File is premigrated, but skipped because the last access was too recent
                                      //
                                      WsbTrace(OLESTR("CFsaTruncator::StartScan, skipping file <%ls> which is premigrated but last access is too recent\n"),
                                                 (WCHAR *)m_currentPath);

                                      hr = FSA_E_SKIPPED;

                                      //
                                      // Update the access time in the db for this file
                                      //
                                      WsbAffirmHr(pPremRec->SetAccessTime(accessTime));
                                      //
                                      // Commit this
                                      //
                                      WsbAffirmHr(pPremRec->Write());
                                      //
                                      // Revert the in-memory accessTime to the old access time to
                                      // let the enumeration continue (so that FindGT will fetch the next record)
                                      //
                                      WsbAffirmHr(pPremRec->SetAccessTime(premRecAccessTime));
                                  }

                                }  else {
                                    //
                                    // If the file is no longer managed by HSM or truncated (may have been modified
                                    // after it was premigrated) - we remove the record from the list.
                                    // Note that if we reached this else close, the condition below should be TRUE
                                    //
                                    if ( (S_FALSE == pScanItem->IsManaged(itemOffset, itemSize)) ||
                                         (S_OK == pScanItem->IsTruncated(itemOffset, itemSize)) ) {
                                        WsbAffirmHr(pDbSession->TransactionBegin());
                                        try {
                                            // Make sure the record is still in the DB
                                            WsbAffirmHr(pPremRec->FindEQ());
                                            WsbAffirmHr(pPremRec->Remove());
                                            WsbAffirmHr(pResourcePriv->RemovePremigratedSize(itemSize));
                                        } WsbCatch(hr);
                                        WsbAffirmHr(pDbSession->TransactionEnd());

                                        // Ignore hr of the removal itself (truncated files may have been removed by another thread)
                                        hr = WSB_E_NOTFOUND;
                                        WsbThrow(hr);
                                    }
                                }

                                // Tell the session we saw the file, and whether we were able to truncate it.
                                WsbAffirmHr(m_pSession->ProcessItem(HSM_JOB_PHASE_FSA_ACTION, HSM_JOB_ACTION_TRUNCATE, pScanItem, hr));
                            
                                // Don't let this errors stop us from continuing to process the list.
                                hr = S_OK;

                            } else {
                                //
                                // File is premigrated, but skipped because the last access was too recent or 
                                // because it was recalled recently
                                //
                                WsbTrace(OLESTR("CFsaTruncator::StartScan, skipping file <%ls> since its last access time is too recent or recently recalled\n"),
                                                 (WCHAR *)m_currentPath);

                                hr = FSA_E_SKIPPED;
                            }

                        } WsbCatchAndDo(hr, 

                            if (WSB_E_NOTFOUND != hr) {
                                m_pSession->ProcessHr(HSM_JOB_PHASE_FSA_ACTION, __FILE__, __LINE__, hr);
                            }

                            // Don't let this errors stop us from continuing to process the list.
                            hr = S_OK;
                        );

                        // If item is skipped - set hr to OK (this is not really an error)
                        if (FSA_E_SKIPPED == hr) {
                            hr = S_OK;
                        }

                        //  Remove recovery record
                        if (pRecRec) {
                            WsbAffirmHr(pRecRec->FindEQ());
                            WsbAffirmHr(pRecRec->Remove());
                            pRecRec = NULL;
                        }

                        // Get the desired level again in case it changed
                        WsbAffirmHr(pResource->GetHsmLevel(&hsmLevel));

                        // Free the scan item.
                        pScanItem = 0;

                        // Whether we removed or skipped the item, go on to the next item.
                        WsbAffirmHr(pPremRec->FindGT());

                        WsbTrace(OLESTR("CFsaTruncator::StartScan, bottom of inside while loop, state = <%ls>\n"), 
                                FsaStateAsString( m_state ) );
                    } // inner while 
                    
                } WsbCatch(hr);

                // Free the premigrated record object and close the data base.
                try {
                    pPremRec = 0;
                    WsbAffirmHr(pPremDb->Close(pDbSession));
                } WsbCatchAndDo(hr2,
                    m_pSession->ProcessHr(HSM_JOB_PHASE_ALL, __FILE__, __LINE__, hr2);
                );
            }

            // Sleep or wait for an event signal.
            // If the event is signaled it means that data was just moved for this 
            // volume and there should be something to do.
            if (SUCCEEDED(hr) || WSB_E_NOTFOUND == hr) {
                ULONG   l_runInterval;
                
                // If we got to the end of the list, then wait a little longer. This
                // is because we probably won't be able to do anything when we retry.
                if (WSB_E_NOTFOUND == hr) {
                    l_runInterval = m_runInterval * 10;
                } else {
                    l_runInterval = m_runInterval;
                }
                WsbTrace(OLESTR("CFsaTruncator::StartScan, sleeping for %lu msec\n"), l_runInterval);
                switch(WaitForSingleObject(m_event, l_runInterval)) {
                    case WAIT_FAILED:
                        WsbTrace(OLESTR("CFsaTruncator::StartScan, Wait for Single Object returned error %lu\n"),
                            GetLastError());
                        break;
                    case WAIT_TIMEOUT:
                        WsbTrace(OLESTR("CFsaTruncator::StartScan, Awakened by timeout.\n"));
                        // Set adjustedFreeLevel to zero so it will get reset to current freeLevel;
                        adjustedFreeLevel = 0;
                        break;
                    default:
                        WsbTrace(OLESTR("CFsaTruncator::StartScan, Awakened by kick start.\n"));
                        break;
                }
            } else {
                WsbThrow(hr);
            }
            WsbTrace(OLESTR("CFsaTruncator::StartScan, bottom of outside while loop, state = <%ls>\n"), 
                    FsaStateAsString( m_state ) );
        }

    } WsbCatch(hr);
    m_threadHr = hr;

    // The thread is exiting, so tell the session.
    if (FAILED(hr)) {
        hr2 = SetState(HSM_JOB_STATE_FAILED);
    } else {
        hr2 = SetState(HSM_JOB_STATE_DONE);
    }
    if (FAILED(hr2)) {
        m_pSession->ProcessHr(HSM_JOB_PHASE_ALL, __FILE__, __LINE__, hr2);
    }

    // Regardless of how this thread is exiting, we need to unadvise from the session.
    // Indicate that we no longer want to be advised of events.
    if ((m_pSession != 0) && (m_cookie != 0)) {
        try {
            WsbAffirmHr(m_pSession->QueryInterface(IID_IConnectionPointContainer, (void**) &pCPC));
            WsbAffirmHr(pCPC->FindConnectionPoint(IID_IHsmSessionSinkEveryEvent, &pCP));
            pCP->Unadvise(m_cookie);
            m_cookie = 0;
        } WsbCatch(hr);
    }
    
    // Since we have terminated, we should release the session.
    m_pSession = 0;

    // Clean up after this thread.
    CloseHandle(m_threadHandle);
    m_threadId = 0;
    m_threadHandle = 0;

    // Decrement ref count so this object can be release
    ((IUnknown *)(IFsaTruncator *)this)->Release();

    WsbTrace(OLESTR("CFsaTruncator::StartScan - terminating, hr = <%ls>, m_state = <%ls>\n"), 
        WsbHrAsString(hr), FsaStateAsString( m_state ) );

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\fsa\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by fsa.rc
//
#define IDR_FsaScanItem                 1
#define IDR_FsaResource                 2
#define IDR_FsaServer                   3
#define IDR_FsaFilter                   4
#define IDR_FsaFilterClient             5
#define IDR_FsaFilterRecall             6
#define IDR_FsaTruncator                7
#define IDR_FsaPremigratedDb            8
#define IDR_FsaPremigratedRec           9
#define IDR_FsaPostIt                   10
#define IDR_FsaRecoveryRec              11
#define IDR_FsaUnmanageDb               12
#define IDR_FsaUnmanageRec              13
#define IDS_FSA_TRUNCATOR_NAME          50
#define IDS_FSA_RECALL_NAME             51
#define IDS_SERVICE_KEY_NAME_SECURE     100
#define IDR_FsaSecure                   100
#define IDS_SERVICE_DISPLAY_NAME_SECURE 101
#define IDS_SERVICE_DESCRIPTION_SECURE  105
#define IDS_PRODUCT_NAME                106
#define IDS_JOB_NAME_PREFIX             107
#define IDS_JOB_AUTOVALIDATE_COMMENT    109
#define IDS_FSAPOSTIT_DESC              200

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\fsa\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\fsa\fsasrvr.h ===
#ifndef _FSASRVR_
#define _FSASRVR_

/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    fsasvr.h

Abstract:

    This module represents the root object for an FSA service for NTFS50.

Author:

    Chuck Bardeen   [cbardeen]   1-Dec-1996

Revision History:

--*/

#define FSA_DB_DIRECTORY        OLESTR("FsaDb")
#define UNMANAGE_DB_DIRECTORY   OLESTR("UnmanageDb")

/*++

Class Name:
    
    CFsaServer

Class Description:

    This class represents the root object for an FSA service for NTFS50.

--*/

class CFsaServer : 
    public CWsbPersistable,
    public IWsbCreateLocalObject,
    public IFsaServer,
    public IWsbServer,
    public CComCoClass<CFsaServer,&CLSID_CFsaServerNTFS>
{
public:
    CFsaServer() {}
BEGIN_COM_MAP(CFsaServer)
    COM_INTERFACE_ENTRY(IFsaServer)
    COM_INTERFACE_ENTRY(IWsbServer)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IPersistFile)
    COM_INTERFACE_ENTRY(IWsbPersistable)
    COM_INTERFACE_ENTRY(IWsbCreateLocalObject)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE( CFsaServer) 

DECLARE_REGISTRY_RESOURCEID(IDR_FsaServer)
DECLARE_PROTECT_FINAL_CONSTRUCT()

// CFsaServer
    STDMETHOD(Autosave)(void);
    STDMETHOD(IsUpdatingAccessDates)(void);
    STDMETHOD(SetIsUpdatingAccessDates)(BOOL isUpdating);

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);
    void FinalRelease(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbCreateLocalServer
    STDMETHOD(CreateInstance)(REFCLSID rclsid, REFIID riid, void **ppv);

// IWsbServer
public:
    STDMETHOD( GetBuildVersion )( ULONG *pBuildVersion );
    STDMETHOD( GetNtProductVersion )( OLECHAR **pNtProductVersion, ULONG bufferSize );
    STDMETHOD( GetNtProductBuild )( ULONG *pNtProductBuild );
    STDMETHOD( GetDatabaseVersion )( ULONG *pDatabaseVersion );
    STDMETHOD( GetId )( GUID* pId );
    STDMETHOD( GetRegistryName )( OLECHAR **pRegistryName, ULONG bufferSize );
    STDMETHOD( SetId )( GUID  id );
    STDMETHOD( SaveAll )( void );
    STDMETHOD( Unload )( void );
    STDMETHOD( CheckAccess )( WSB_ACCESS_TYPE AccessType );
    STDMETHOD( GetTrace )( OUT IWsbTrace ** ppTrace );
    STDMETHOD( SetTrace )( IN IWsbTrace *pTrace );
    STDMETHOD( DestroyObject )( void );

// IHsmSystemState
    STDMETHOD( ChangeSysState )( HSM_SYSTEM_STATE* pSysState );

// IFsaServer
public:
    STDMETHOD(EnumResources)(IWsbEnum** ppEnum);
    STDMETHOD(FindResourceByAlternatePath)(OLECHAR* path, IFsaResource** ppResource);
    STDMETHOD(FindResourceById)(GUID id, IFsaResource** ppResource);
    STDMETHOD(FindResourceByName)(OLECHAR* name, IFsaResource** ppResource);
    STDMETHOD(FindResourceByPath)(OLECHAR* path, IFsaResource** ppResource);
    STDMETHOD(FindResourceBySerial)(ULONG serial, IFsaResource** ppResource);
    STDMETHOD(FindResourceByStickyName)(OLECHAR* name, IFsaResource** ppResource);
    STDMETHOD(GetAutosave)(ULONG* pMilliseconds);
    STDMETHOD(GetDbPath)(OLECHAR** pPath, ULONG bufferSize);
    STDMETHOD(GetDbPathAndName)(OLECHAR** pPath, ULONG bufferSize);
    STDMETHOD(GetIDbPath)(OLECHAR** pPath, ULONG bufferSize);
    STDMETHOD(GetUnmanageIDbPath)(OLECHAR** pPath, ULONG bufferSize);
    STDMETHOD(GetIDbSys)(IWsbDbSys** ppDbSys);
    STDMETHOD(GetUnmanageIDbSys)(IWsbDbSys** ppDbSys);
    STDMETHOD(GetFilter)(IFsaFilter** ppFilter);
    STDMETHOD(GetIdentifier)(GUID* pId);
    STDMETHOD(GetLogicalName)(OLECHAR** pName, ULONG bufferSize);
    STDMETHOD(GetName)(OLECHAR** pName, ULONG bufferSize);
    STDMETHOD(Init)(void);
    STDMETHOD(ScanForResources)(void);
    STDMETHOD(SetAutosave)(ULONG milliseconds);

//  Internal functions
private:
    STDMETHOD(DoRecovery)(void);
    void StopAutosaveThread(void);
    STDMETHOD(CreateMetadataSaveEvent)(void);

protected:
    ULONG                       m_autosaveInterval;  // Autosave interval in milliseconds; 
                                                     // zero turns if off.
    HANDLE                      m_autosaveThread;
    HANDLE                      m_terminateEvent;    // An event for signaling termination to the autosave thread
    HANDLE                      m_savingEvent;       // An event for synchronizing saving of persistent data
    BOOL                        m_Suspended;
    BOOL                        m_isUnmanageDbSysInitialized;
    GUID                        m_id;
    CWsbStringPtr               m_dbPath;
    CWsbStringPtr               m_name;
    CComPtr<IWsbCollection>     m_pResources;        // persisted collection of manageable
                                                     // resources.
    CComPtr<IFsaFilter>         m_pFilter;
    CComPtr<IWsbDbSys>          m_pDbSys;
    CComPtr<IWsbDbSys>          m_pUnmanageDbSys;
    CComPtr<IWsbTrace>          m_pTrace;

    ULONG                       m_buildVersion;
    ULONG                       m_databaseVersion;

};

#endif  // _FSASRVR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\fsa\fsasrvr.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    fsasrvr.cpp

Abstract:

    This class contains represents a file system for NTFS.

Author:

    Chuck Bardeen   [cbardeen]   1-Dec-1996

Revision History:

    Chris Timmes    [ctimmes]   31-Dec-1997  
    
    - basically rewrote the ScanForResources() method to fix RAID bug 117412 
      (volumes which were once manageable but are now unmanageable still show as 
      manageable in the UI).

--*/

#include "stdafx.h"

#include "job.h"
#include "fsa.h"
#include "fsaprv.h"
#include "fsasrvr.h"
#include "HsmConn.h"
#include "wsbdb.h"
#include "wsbtrak.h"
#include "wsbvol.h"
#include "task.h"
#include "rsbuild.h"
#include "rsevents.h"
#include "ntverp.h"
#include <winioctl.h>
#include <setupapi.h>
#include <objbase.h>
#include <stdio.h>
#include <initguid.h>
#include <mountmgr.h>
#include <aclapi.h>



static short g_InstanceCount = 0;


//  Non-member function initially called for autosave thread
static DWORD FsaStartAutosave(
    void* pVoid
    )
{
    return(((CFsaServer*) pVoid)->Autosave());
}


HRESULT
CFsaServer::Autosave(
    void
    )

/*++

Routine Description:

  Implements an autosave loop.

Arguments:

  None.
  
Return Value:

  Doesn't matter.


--*/
{

    HRESULT         hr = S_OK;
    ULONG           l_autosaveInterval = m_autosaveInterval;
    BOOL            exitLoop = FALSE;

    WsbTraceIn(OLESTR("CFsaServer::Autosave"), OLESTR(""));

    try {
        while (m_autosaveInterval && (! exitLoop)) {

            // Wait for termination event, if timeout occurs, check if we can perform Autosave
            switch (WaitForSingleObject(m_terminateEvent, l_autosaveInterval)) {
                case WAIT_OBJECT_0:
                    // Need to terminate
                    WsbTrace(OLESTR("CFsaServer::Autosave: signaled to terminate\n"));
                    exitLoop = TRUE;
                    break;

                case WAIT_TIMEOUT: 
                    // Check if backup need to be performed
                    WsbTrace(OLESTR("CFsaServer::Autosave: Autosave awakened\n"));

                    //  Don't do this if we're suspended
                    if (!m_Suspended) {
                        //  Save data
                        //  NOTE: Because this is a separate thread, there is the possibility
                        //  of a conflict if the main thread is changing some data at the same
                        //  time we're trying to save it.
                        //  If a save is already happening, just skip this one and
                        //  go back to sleep
                        hr = SaveAll();
    
                        //  If the save fails, increase the sleep time to avoid filling
                        //  the event log
                        if (!SUCCEEDED(hr)) {
                            if ((MAX_AUTOSAVE_INTERVAL / 2) < l_autosaveInterval) {
                                l_autosaveInterval = MAX_AUTOSAVE_INTERVAL;
                            } else {
                                l_autosaveInterval *= 2;
                            }
                        } else {
                            l_autosaveInterval = m_autosaveInterval;
                        }
                    }

                    break;  // end of timeout case

                case WAIT_FAILED:
                default:
                    WsbTrace(OLESTR("CFsaServer::Autosave: WaitForSingleObject returned error %lu\n"), GetLastError());
                    exitLoop = TRUE;
                    break;

            } // end of switch

        } // end of while

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaServer::Autosave"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CFsaServer::CreateInstance( 
    REFCLSID rclsid, 
    REFIID riid, 
    void **ppv 
    )
{
    HRESULT     hr = S_OK;
    
    hr = CoCreateInstance(rclsid, NULL, CLSCTX_SERVER, riid, ppv);

    return hr;
}


HRESULT
CFsaServer::DoRecovery(
    void
    )

/*++

Routine Description:

  Do recovery.

Arguments:

  None.
  
Return Value:

  S_OK  - Success.


--*/
{

    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaServer::DoRecovery"), OLESTR(""));

    try {
        CComPtr<IWsbEnum>           pEnum;
        CComPtr<IFsaResourcePriv>   pResourcePriv;
        CComPtr<IFsaResource>       pResource;

        //  Loop over resources and tell them to do their own recovery
        WsbAffirmPointer(m_pResources);
        WsbAffirmHr(m_pResources->Enum(&pEnum));
        hr = pEnum->First(IID_IFsaResourcePriv, (void**)&pResourcePriv);
        while (S_OK == hr) {
        
            WsbAffirmHr(pResourcePriv->QueryInterface(IID_IFsaResource, (void**) &pResource));
            
            if ((pResource->IsActive() == S_OK) && (pResource->IsAvailable() == S_OK)) {
                hr = pResourcePriv->DoRecovery();
                // Log event if (S_OK != hr) ???
            }

            //  Release this resource and get the next one
            pResource = 0;
            pResourcePriv = 0;
            
            hr = pEnum->Next(IID_IFsaResourcePriv, (void**)&pResourcePriv);
        }
        if (WSB_E_NOTFOUND == hr) {
            hr = S_OK;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaServer::DoRecovery"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaServer::EnumResources(
    OUT IWsbEnum** ppEnum
    )

/*++

Implements:

  IFsaServer::EnumResources().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != ppEnum, E_POINTER);
        
        //
        // We can't trust that the resource information 
        // that we have is current so redo the scan.  This 
        // is expensive and should be changed once we
        // know how NT can tell us when things have 
        // changed
        //
        try  {
            WsbAffirmHr(ScanForResources());
        } WsbCatch( hr );
        
        WsbAffirmHr(m_pResources->Enum(ppEnum));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaServer::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaServer::FinalConstruct"), OLESTR(""));


    hr = CWsbPersistable::FinalConstruct();

    // Keep it simple, most of the work is done in Init();
    m_terminateEvent = NULL;
    m_savingEvent = NULL;
    m_id = GUID_NULL;
    m_Suspended = FALSE;
    m_isUnmanageDbSysInitialized = FALSE;

    if (hr == S_OK)  {
        g_InstanceCount++;
    }

    WsbTrace(OLESTR("CFsaServer::FinalConstruct: Instance count = %d\n"), g_InstanceCount);
    WsbTraceOut(OLESTR("CFsaServer::FinalConstruct"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


void
CFsaServer::FinalRelease(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalRelease().

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IPersistFile>   pPersistFile;

    WsbTraceIn(OLESTR("CFsaServer::FinalRelease"), OLESTR(""));

    try {
        HSM_SYSTEM_STATE SysState;

        SysState.State = HSM_STATE_SHUTDOWN;
        ChangeSysState(&SysState);

    } WsbCatch(hr)
    
    // Let the parent class do his thing.   
    CWsbPersistable::FinalRelease();

    // Free String members
    // Note: Member objects held in smart-pointers are freed when the 
    // smart-pointer destructor is being called (as part of this object destruction)
    m_dbPath.Free();
    m_name.Free();

    // Free autosave terminate event 
    if (m_terminateEvent != NULL) {
        CloseHandle(m_terminateEvent);
        m_terminateEvent = NULL;
    }

    // Clean up database system
    if (m_pDbSys != NULL) {
        m_pDbSys->Terminate();
    }

    if (m_isUnmanageDbSysInitialized) {
        m_pUnmanageDbSys->Terminate();
        m_isUnmanageDbSysInitialized = FALSE;
    }

    if (m_savingEvent != NULL) {
        CloseHandle(m_savingEvent);
        m_savingEvent = NULL;
    }

    if (hr == S_OK)  {
        g_InstanceCount--;
    }
    WsbTrace(OLESTR("CFsaServer::FinalRelease: Instance count = %d\n"), g_InstanceCount);

    WsbTraceOut(OLESTR("CFsaServer::FinalRelease"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
}



HRESULT
CFsaServer::FindResourceByAlternatePath(
    IN OLECHAR* path,
    OUT IFsaResource** ppResource
    )

/*++

Implements:

  IFsaServer::FindResourceByAlternatePath().

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IFsaResourcePriv>   pResourcePriv;
    CComPtr<IFsaResource>       pResource;

    WsbTraceIn(OLESTR("CFsaServer::FindResourceByAlternatePath"), OLESTR("path = <%ls>"), path);

    try {

        WsbAssert(0 != path, E_POINTER);
        WsbAssert(0 != ppResource, E_POINTER);
        WsbAffirmPointer(m_pResources);

        // Create an FsaResource that will scan for us.
        WsbAffirmHr(CoCreateInstance(CLSID_CFsaResourceNTFS, NULL, CLSCTX_SERVER, IID_IFsaResourcePriv, (void**) &pResourcePriv));

        WsbAffirmHr(pResourcePriv->SetAlternatePath(path));
        WsbAffirmHr(pResourcePriv->QueryInterface(IID_IFsaResource, (void**) &pResource));
        WsbAffirmHr(pResource->CompareBy(FSA_RESOURCE_COMPARE_ALTERNATEPATH));
        WsbAffirmHr(m_pResources->Find(pResource, IID_IFsaResource, (void**) ppResource));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaServer::FindResourceByAlternatePath"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaServer::FindResourceById(
    IN GUID id,
    OUT IFsaResource** ppResource
    )

/*++

Implements:

  IFsaServer::FindResourceById().

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IFsaResourcePriv>   pResourcePriv;
    CComPtr<IFsaResource>       pResource;

    WsbTraceIn(OLESTR("CFsaServer::FindResourceById"), OLESTR("id = <%ls>"), WsbGuidAsString(id));

    try {

        WsbAssert(0 != ppResource, E_POINTER);
        WsbAffirmPointer(m_pResources);

        // Create an FsaResource that will scan for us.
        WsbAffirmHr(CoCreateInstance(CLSID_CFsaResourceNTFS, NULL, CLSCTX_SERVER, IID_IFsaResourcePriv, (void**) &pResourcePriv));

        WsbAffirmHr(pResourcePriv->SetIdentifier(id));
        WsbAffirmHr(pResourcePriv->QueryInterface(IID_IFsaResource, (void**) &pResource));
        WsbAffirmHr(pResource->CompareBy(FSA_RESOURCE_COMPARE_ID));
        WsbAffirmHr(m_pResources->Find(pResource, IID_IFsaResource, (void**) ppResource));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaServer::FindResourceById"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CFsaServer::FindResourceByName(
    IN OLECHAR* name,
    OUT IFsaResource** ppResource
    )

/*++

Implements:

  IFsaServer::FindResourceByName().

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IFsaResourcePriv>   pResourcePriv;
    CComPtr<IFsaResource>       pResource;

    WsbTraceIn(OLESTR("CFsaServer::FindResourceByName"), OLESTR("name = <%ls>"), name);

    try {

        WsbAssert(0 != ppResource, E_POINTER);
        WsbAffirmPointer(m_pResources);

        // Create an FsaResource that will scan for us.
        WsbAffirmHr(CoCreateInstance(CLSID_CFsaResourceNTFS, NULL, CLSCTX_SERVER, IID_IFsaResourcePriv, (void**) &pResourcePriv));

        WsbAffirmHr(pResourcePriv->SetName(name));
        WsbAffirmHr(pResourcePriv->QueryInterface(IID_IFsaResource, (void**) &pResource));
        WsbAffirmHr(pResource->CompareBy(FSA_RESOURCE_COMPARE_NAME));
        WsbAffirmHr(m_pResources->Find(pResource, IID_IFsaResource, (void**) ppResource));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaServer::FindResourceByName"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaServer::FindResourceByPath(
    IN OLECHAR* path,
    OUT IFsaResource** ppResource
    )

/*++

Implements:

  IFsaServer::FindResourceByPath().

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IFsaResourcePriv>   pResourcePriv;
    CComPtr<IFsaResource>       pResource;

    WsbTraceIn(OLESTR("CFsaServer::FindResourceByPath"), OLESTR("path = <%ls>"), path);

    try {

        WsbAssert(0 != path, E_POINTER);
        WsbAssert(0 != ppResource, E_POINTER);
        WsbAffirmPointer(m_pResources);

        // Create an FsaResource that will scan for us.
        WsbAffirmHr(CoCreateInstance(CLSID_CFsaResourceNTFS, NULL, CLSCTX_SERVER, IID_IFsaResourcePriv, (void**) &pResourcePriv));

        //WsbAffirmHr(pResourcePriv->SetPath(path));

        WsbAffirmHr(pResourcePriv->SetUserFriendlyName(path));

        WsbAffirmHr(pResourcePriv->QueryInterface(IID_IFsaResource, (void**) &pResource));

        //WsbAffirmHr(pResource->CompareBy(FSA_RESOURCE_COMPARE_PATH));
        WsbAffirmHr(pResource->CompareBy(FSA_RESOURCE_COMPARE_USER_NAME));

        WsbAffirmHr(m_pResources->Find(pResource, IID_IFsaResource, (void**) ppResource));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaServer::FindResourceByPath"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaServer::FindResourceBySerial(
    IN ULONG serial,
    OUT IFsaResource** ppResource
    )

/*++

Implements:

  IFsaServer::FindResourceBySerial().

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IFsaResourcePriv>   pResourcePriv;
    CComPtr<IFsaResource>       pResource;

    WsbTraceIn(OLESTR("CFsaServer::FindResourceBySerial"), OLESTR("serial = <%lu>"), serial);

    try {

        WsbAssert(0 != ppResource, E_POINTER);
        WsbAffirmPointer(m_pResources);

        // Create an FsaResource that will scan for us.
        WsbAffirmHr(CoCreateInstance(CLSID_CFsaResourceNTFS, NULL, CLSCTX_SERVER, IID_IFsaResourcePriv, (void**) &pResourcePriv));

        WsbAffirmHr(pResourcePriv->SetSerial(serial));
        WsbAffirmHr(pResourcePriv->QueryInterface(IID_IFsaResource, (void**) &pResource));
        WsbAffirmHr(pResource->CompareBy(FSA_RESOURCE_COMPARE_SERIAL));
        WsbAffirmHr(m_pResources->Find(pResource, IID_IFsaResource, (void**) ppResource));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaServer::FindResourceBySerial"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaServer::FindResourceByStickyName(
    IN OLECHAR* name,
    OUT IFsaResource** ppResource
    )

/*++

Implements:

  IFsaServer::FindResourceByStickyName().

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IFsaResourcePriv>   pResourcePriv;
    CComPtr<IFsaResource>       pResource;

    WsbTraceIn(OLESTR("CFsaServer::FindResourceByStickyName"), OLESTR("name = <%ls>"), name);

    try {

        WsbAssert(0 != ppResource, E_POINTER);
        WsbAffirmPointer(m_pResources);

        // Create an FsaResource that will scan for us.
        WsbAffirmHr(CoCreateInstance(CLSID_CFsaResourceNTFS, NULL, CLSCTX_SERVER, IID_IFsaResourcePriv, (void**) &pResourcePriv));

        WsbAffirmHr(pResourcePriv->SetStickyName(name));
        WsbAffirmHr(pResourcePriv->QueryInterface(IID_IFsaResource, (void**) &pResource));
        WsbAffirmHr(pResource->CompareBy(FSA_RESOURCE_COMPARE_STICKY_NAME));
        WsbAffirmHr(m_pResources->Find(pResource, IID_IFsaResource, (void**) ppResource));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaServer::FindResourceByStickyName"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaServer::GetAutosave(
    OUT ULONG* pMilliseconds
    )

/*++

Implements:

  IFsaServer::GetAutosave().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaServer::GetAutosave"), OLESTR(""));

    try {

        WsbAssert(0 != pMilliseconds, E_POINTER);
        *pMilliseconds = m_autosaveInterval;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaServer::GetAutosave"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaServer::GetBuildVersion( 
    ULONG *pBuildVersion
    )

/*++

Implements:

  IWsbServer::GetBuildVersion().

--*/
{
    HRESULT       hr = S_OK;
    WsbTraceIn(OLESTR("CFsaServer::GetBuildVersion"), OLESTR(""));
   
    try {
        WsbAssertPointer(pBuildVersion);

        *pBuildVersion = m_buildVersion;

    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CFsaServer::GetBuildVersion"), OLESTR("hr = <%ls>, Version = <%ls)"),
        WsbHrAsString(hr), RsBuildVersionAsString(m_buildVersion));
    return ( hr );
}

HRESULT
CFsaServer::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaServer::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CFsaServerNTFS;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaServer::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CFsaServer::GetDatabaseVersion( 
    ULONG *pDatabaseVersion
    )

/*++

Implements:

  IWsbServer::GetDatabaseVersion().

--*/
{
    HRESULT       hr = S_OK;
    WsbTraceIn(OLESTR("CFsaServer::GetDatabaseVersion"), OLESTR(""));
    
    *pDatabaseVersion = m_databaseVersion;
    
    WsbTraceOut(OLESTR("CFsaServer::GetDatabaseVersion"), OLESTR("hr = <%ls>, Version = <%ls)"),
        WsbHrAsString(hr), WsbPtrToUlongAsString(pDatabaseVersion));
    return ( hr );
}

HRESULT
CFsaServer::GetDbPath(
    OUT OLECHAR** pPath,
    IN ULONG bufferSize
    )

/*++

Implements:

  IFsaServer::GetDbPath().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CFsaServer::GetDbPath"), OLESTR(""));
    try {

        WsbAssert(0 != pPath, E_POINTER); 

        // Right now it is hard coded. This will probably change to something from the registry.
        WsbAffirmHr(m_dbPath.CopyTo(pPath, bufferSize));

    } WsbCatch(hr);
    WsbTraceOut(OLESTR("CFsaServer::GetDbPath"), OLESTR("hr = <%ls>, path = <%ls)"),
        WsbHrAsString(hr), WsbPtrToStringAsString(pPath));

    return(hr);
}


HRESULT
CFsaServer::GetDbPathAndName(
    OUT OLECHAR** pPath,
    IN ULONG bufferSize
    )

/*++

Implements:

  IFsaServer::GetDbPathAndName().

--*/
{
    HRESULT         hr = S_OK;
    CWsbStringPtr   tmpString;

    try {

        WsbAssert(0 != pPath, E_POINTER); 

        tmpString = m_dbPath;
        tmpString.Append(OLESTR("\\RsFsa.col"));
        WsbAffirmHr(tmpString.CopyTo(pPath, bufferSize));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaServer::GetIDbPath(
    OUT OLECHAR** pPath,
    IN ULONG bufferSize
    )

/*++

Implements:

  IFsaServer::GetIDbPath().

--*/
{
    HRESULT         hr = S_OK;
    CWsbStringPtr   tmpString;

    try {

        WsbAssert(0 != pPath, E_POINTER); 

        WsbAffirmHr(GetDbPath(&tmpString, 0));

        tmpString.Append(OLESTR("\\"));
        tmpString.Append(FSA_DB_DIRECTORY);

        WsbAffirmHr(tmpString.CopyTo(pPath, bufferSize));

    } WsbCatch(hr);

    return(hr);
}

HRESULT
CFsaServer::GetUnmanageIDbPath(
    OUT OLECHAR** pPath,
    IN ULONG bufferSize
    )

/*++

Implements:

  IFsaServer::GetIDbPath().

--*/
{
    HRESULT         hr = S_OK;
    CWsbStringPtr   tmpString;

    try {

        WsbAssert(0 != pPath, E_POINTER); 

        WsbAffirmHr(GetDbPath(&tmpString, 0));

        tmpString.Append(OLESTR("\\"));
        tmpString.Append(FSA_DB_DIRECTORY);
        tmpString.Append(OLESTR("\\"));
        tmpString.Append(UNMANAGE_DB_DIRECTORY);

        WsbAffirmHr(tmpString.CopyTo(pPath, bufferSize));

    } WsbCatch(hr);

    return(hr);
}

HRESULT
CFsaServer::GetIDbSys(
    OUT IWsbDbSys** ppDbSys
    )

/*++

Implements:

  IFsaServer::GetIDbSys().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != ppDbSys, E_POINTER);

        *ppDbSys = m_pDbSys;
        m_pDbSys.p->AddRef();

    } WsbCatch(hr);

    return(hr);
}

HRESULT
CFsaServer::GetUnmanageIDbSys(
    OUT IWsbDbSys** ppDbSys
    )

/*++

Implements:

  IFsaServer::GetUnmanageIDbSys().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CFsaServer::GetUnmanageIDbSys"), OLESTR(""));

    try {
        CWsbStringPtr   tmpString;

        WsbAssert(0 != ppDbSys, E_POINTER);

        // Unlike the premigarted db-sys-instance, we initialize the unamange db-sys-instance 
        // only when it is required for the first time
        if (! m_isUnmanageDbSysInitialized) {
            WsbAffirmHr(CoCreateInstance(CLSID_CWsbDbSys, NULL, CLSCTX_SERVER, IID_IWsbDbSys, (void**) &m_pUnmanageDbSys));

            WsbAffirmHr(GetUnmanageIDbPath(&tmpString, 0));
            WsbAffirmHr(m_pUnmanageDbSys->Init(tmpString, IDB_SYS_INIT_FLAG_NO_LOGGING | 
                        IDB_SYS_INIT_FLAG_SPECIAL_ERROR_MSG | IDB_SYS_INIT_FLAG_NO_BACKUP));

            m_isUnmanageDbSysInitialized = TRUE;
        }

        *ppDbSys = m_pUnmanageDbSys;
        m_pUnmanageDbSys.p->AddRef();

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaServer::GetUnmanageIDbSys"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaServer::GetId(
    OUT GUID* pId
    )

/*++

Implements:

  IWsbServer::GetId().

--*/
{
    return(GetIdentifier(pId));
}

HRESULT
CFsaServer::GetIdentifier(
    OUT GUID* pId
    )

/*++

Implements:

  IFsaServer::GetIdentifier().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != pId, E_POINTER);

        *pId = m_id;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaServer::GetFilter(
    OUT IFsaFilter** ppFilter
    )

/*++

Implements:

  IFsaServer::GetFilter().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != ppFilter, E_POINTER);

        *ppFilter = m_pFilter;
        m_pFilter.p->AddRef();

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaServer::GetLogicalName(
    OUT OLECHAR** pName,
    IN ULONG bufferSize
    )

/*++

Implements:

  IFsaServer::GetLogicalName().

--*/
{
    HRESULT         hr = S_OK;
    CWsbStringPtr   tmpString;

    try {

        WsbAssert(0 != pName, E_POINTER); 

        WsbAffirmHr(tmpString.TakeFrom(*pName, bufferSize));

        try {

            // This is an arbitrary choice for the naming convention. Nothing has been
            // decided upon.
            tmpString = m_name;
            WsbAffirmHr(tmpString.Append(OLESTR("\\NTFS")));

        } WsbCatch(hr);

        WsbAffirmHr(tmpString.GiveTo(pName));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaServer::GetName(
    OUT OLECHAR** pName,
    IN ULONG bufferSize
    )

/*++

Implements:

  IFsaServer::GetName().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != pName, E_POINTER); 
        WsbAffirmHr(m_name.CopyTo(pName, bufferSize));

    } WsbCatch(hr);

    return(hr);
}


HRESULT CFsaServer::GetRegistryName ( 
    OLECHAR **pName, 
    ULONG bufferSize
    )  
/*++

Implements:

  IWsbServer::GetRegistryName().

--*/
{

    HRESULT hr = S_OK;
    
    try  {
        CWsbStringPtr tmpString;
        
        WsbAssert(0 != pName,  E_POINTER);
        
        tmpString = FSA_REGISTRY_NAME;
        WsbAffirmHr(tmpString.CopyTo(pName, bufferSize));
        
    } WsbCatch( hr );
    
    return (hr);
}


HRESULT
CFsaServer::GetSizeMax(
    OUT ULARGE_INTEGER* pSize
    )

/*++

Implements:

  IPersistStream::GetSizeMax().

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IPersistStream> pPersistStream;
    ULARGE_INTEGER          entrySize;

    WsbTraceIn(OLESTR("CFsaServer::GetSizeMax"), OLESTR(""));

    try {

        WsbAssert(0 != pSize, E_POINTER);

        // Determine the size for a rule with no criteria.
        pSize->QuadPart = WsbPersistSize((wcslen(m_name) + 1) * sizeof(OLECHAR)) + WsbPersistSizeOf(GUID);

        // Now allocate space for the resource collection.
        WsbAffirmPointer(m_pResources);
        WsbAffirmHr(m_pResources->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->GetSizeMax(&entrySize));
        pSize->QuadPart += entrySize.QuadPart;
        pPersistStream = 0;

        // Now allocate space for the filter.
        WsbAffirmHr(m_pFilter->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->GetSizeMax(&entrySize));
        pSize->QuadPart += entrySize.QuadPart;
        pPersistStream = 0;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaServer::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pSize));

    return(hr);
}


HRESULT
CFsaServer::Init(
    void
    )

/*++

Implements:

  CFsaServer::Init().

--*/
{

    HRESULT                     hr = S_OK;
    CComPtr<IPersistFile>       pPersistFile;
    CComPtr<IWsbServer>         pWsbServer;
    CComPtr<IFsaFilterPriv>     pFilterPriv;
    CWsbStringPtr               tmpString;
    HANDLE                      pHandle;
    LUID                        backupValue;
    HANDLE                      tokenHandle;
    TOKEN_PRIVILEGES            newState;
    DWORD                       lErr;
    

    WsbTraceIn(OLESTR("CFsaServer::Init"), OLESTR(""));

    try {

        // Store of the name of the server and path to meta data
        WsbAffirmHr(WsbGetComputerName(m_name));
        WsbAffirmHr(WsbGetMetaDataPath(m_dbPath));

        // Set the build and database parameters
        m_databaseVersion = FSA_CURRENT_DB_VERSION;
        m_buildVersion = RS_BUILD_VERSION;

        // Set the autosave parameters.
        m_autosaveInterval = DEFAULT_AUTOSAVE_INTERVAL;
        m_autosaveThread = 0;

        // Enable the backup operator privilege.  This is required to insure that we 
        // have full access to all resources on the system.
        pHandle = GetCurrentProcess();
        WsbAffirmStatus(OpenProcessToken(pHandle, MAXIMUM_ALLOWED, &tokenHandle));

        // adjust backup token privileges
        WsbAffirmStatus(LookupPrivilegeValueW(NULL, L"SeBackupPrivilege", &backupValue));
        newState.PrivilegeCount = 1;
        newState.Privileges[0].Luid = backupValue;
        newState.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
        WsbAffirmStatus(AdjustTokenPrivileges(tokenHandle, FALSE, &newState, (DWORD)0, NULL, NULL));

        // Note that AdjustTokenPrivileges may return success even if it did not assign all privileges.
        // We check last error here to insure everything was set.
        if ((lErr = GetLastError()) != ERROR_SUCCESS) {
            // Not backup user or some other error
            //
            // TODO: Should we fail here or just log something?
            WsbLogEvent( FSA_MESSAGE_SERVICE_UNABLE_TO_SET_BACKUP_PRIVILEGE, 0, NULL,
                         WsbHrAsString(HRESULT_FROM_WIN32(lErr)), NULL );
        }

        WsbAffirmStatus(LookupPrivilegeValueW(NULL, L"SeRestorePrivilege", &backupValue));
        newState.PrivilegeCount = 1;
        newState.Privileges[0].Luid = backupValue;
        newState.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
        WsbAffirmStatus(AdjustTokenPrivileges(tokenHandle, FALSE, &newState, (DWORD)0, NULL, NULL));

        // Note that AdjustTokenPrivileges may return success even if it did not assign all privileges.
        // We check last error here to insure everything was set.
        if ((lErr = GetLastError()) != ERROR_SUCCESS) {
            // Not backup user or some other error
            //
            // TODO: Should we fail here or just log something?
            WsbLogEvent( FSA_MESSAGE_SERVICE_UNABLE_TO_SET_RESTORE_PRIVILEGE, 0, NULL,
                         WsbHrAsString(HRESULT_FROM_WIN32(lErr)), NULL );
        }
        CloseHandle(tokenHandle);

        // Check to see if trtacking of last access dates is enabled. If not,
        // we don't want to start the service. However, Microsoft wants us to
        // start it anyway, so we will log a warning.
        if (IsUpdatingAccessDates() != S_OK) {
            WsbLogEvent(FSA_MESSAGE_NOT_UPDATING_ACCESS_DATES, 0, NULL, NULL);
        }
        
        //  Create the event that synchronize saving of persistent data with snapshots
        WsbAffirmHr(CreateMetadataSaveEvent());

        // Create the IDB system for this process
        WsbAffirmHr(CoCreateInstance(CLSID_CWsbDbSys, NULL, CLSCTX_SERVER, IID_IWsbDbSys, (void**) &m_pDbSys));

        // Initialize the IDB system
        WsbAffirmHr(GetIDbPath(&tmpString, 0));
        WsbAffirmHr(m_pDbSys->Init(tmpString, IDB_SYS_INIT_FLAG_LIMITED_LOGGING | 
                        IDB_SYS_INIT_FLAG_SPECIAL_ERROR_MSG | IDB_SYS_INIT_FLAG_NO_BACKUP));

        // Create the resource collection (with no items).
        WsbAffirmHr(CoCreateInstance(CLSID_CWsbOrderedCollection, NULL, CLSCTX_SERVER, IID_IWsbCollection, (void**) &m_pResources));

        // Create the Filter.
        WsbAffirmHr(CoCreateInstance(CLSID_CFsaFilterNTFS, NULL, CLSCTX_SERVER, IID_IFsaFilter, (void**) &m_pFilter));
        WsbAffirmHr(m_pFilter->QueryInterface(IID_IFsaFilterPriv, (void**) &pFilterPriv));
        WsbAffirmHr(pFilterPriv->Init((IFsaServer*) this));
        
        // Try to load the server from stored information. If this fails, then store out the current state.
        WsbAffirmHr(((IUnknown*) (IFsaServer*) this)->QueryInterface(IID_IWsbServer, (void**) &pWsbServer));
        WsbAffirmHr(WsbServiceSafeInitialize(pWsbServer, TRUE, FALSE, NULL));
        
        // Register the FSA Service.
        WsbAffirmHr(GetLogicalName(&tmpString, 0));
        WsbAffirmHr(HsmPublish(HSMCONN_TYPE_FSA, tmpString, m_id, m_name, CLSID_CFsaServerNTFS));

        // Update our information about the available resources, and save it out.
        WsbAffirmHr(ScanForResources());

        // Save updated information
        hr = SaveAll();
        // S_FALSE just means that FSA is already saving...
        if ((S_OK != hr) && (S_FALSE != hr)) {
            WsbAffirmHr(hr);
        }

        // Check if recovery is needed
        WsbAffirmHr(DoRecovery());

        // If the filter is enabled, then start it.
        if (m_pFilter->IsEnabled() == S_OK) {
            WsbAffirmHr(m_pFilter->Start());
        }

        // Create termination event for auto-backup thread
        WsbAffirmHandle((m_terminateEvent = CreateEvent(NULL, FALSE, FALSE, NULL)));

        // If the autosave interval is non-zero, start the autosave thread
        if (m_autosaveInterval) {
            ULONG  interval = m_autosaveInterval;

            WsbAffirm(0 == m_autosaveThread, E_FAIL);
            m_autosaveInterval = 0;

            //  Trick SetAutosave into starting the thread
            WsbAffirmHr(SetAutosave(interval));
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaServer::Init"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);

}


HRESULT
CFsaServer::IsUpdatingAccessDates(
    void
    )

/*++

Implements:

  IFsaServer::IsUpdatingAccessDates().

--*/
{
    HRESULT         hr = S_OK;
    DWORD           value = 0;
    
    // See if the appropriate registry entry has been created and has the
    // specified value of 1. This disables access time updating.
    if ((WsbGetRegistryValueDWORD(NULL, OLESTR("SYSTEM\\CurrentControlSet\\Control\\FileSystem"), OLESTR("NtfsDisableLastAccessUpdate"), &value) == S_OK) &&
        (0 != value)) {
        hr = S_FALSE;
    }

    return(hr);    
}


HRESULT
CFsaServer::Load(
    IN IStream* pStream
    )

/*++

Implements:

  IPersistStream::Load().

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IPersistStream>     pPersistStream;

    WsbTraceIn(OLESTR("CFsaServer::Load"), OLESTR(""));

    try {
        WsbAssert(0 != pStream, E_POINTER);
        
        // Do the easy stuff, but make sure that this order matches the order
        // in the save method.
        
        //
        // Make sure this is the right version of the database to load
        //
        ULONG tmpDatabaseVersion;
        WsbAffirmHr(WsbLoadFromStream(pStream, &tmpDatabaseVersion));
        if (tmpDatabaseVersion != m_databaseVersion)  {
            //
            // The database version this server is expecting does not
            // match that of the saved database - so error out.
            WsbLogEvent( FSA_MESSAGE_DATABASE_VERSION_MISMATCH, 0, NULL, WsbQuickString(WsbPtrToUlongAsString(&m_databaseVersion)),
                         WsbQuickString(WsbPtrToUlongAsString(&tmpDatabaseVersion)), NULL );
            WsbThrow(FSA_E_DATABASE_VERSION_MISMATCH);
        }
        //
        // Now read in the build version but don't do anything with it.  It is in the
        // databases for dump programs to display
        //
        ULONG tmpBuildVersion;
        WsbAffirmHr(WsbLoadFromStream(pStream, &tmpBuildVersion));
        
        
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_id));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_name, 0));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_autosaveInterval));

        // Load the resource collection.
        WsbAffirmPointer(m_pResources);
        WsbAffirmHr(m_pResources->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Load(pStream));
        pPersistStream = 0;

        // Load the filter.
        WsbAffirmHr(m_pFilter->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Load(pStream));
        pPersistStream = 0;

    } WsbCatch(hr);                                        

    WsbTraceOut(OLESTR("CFsaServer::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaServer::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )

/*++

Implements:

  IPersistStream::Save().

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IPersistStream> pPersistStream;

    WsbTraceIn(OLESTR("CFsaServer::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));
    
    try {
        WsbAssert(0 != pStream, E_POINTER);
        
        // Do the easy stuff, but make sure that this order matches the order
        // in the load method.
        WsbAffirmHr(WsbSaveToStream(pStream, m_databaseVersion));
        WsbAffirmHr(WsbSaveToStream(pStream, m_buildVersion));
        
        WsbAffirmHr(WsbSaveToStream(pStream, m_id));
        WsbAffirmHr(WsbSaveToStream(pStream, m_name));
        WsbAffirmHr(WsbSaveToStream(pStream, m_autosaveInterval));

        // Save off the resource collections.
        WsbAffirmPointer(m_pResources);
        WsbAffirmHr(m_pResources->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Save(pStream, clearDirty));
        pPersistStream = 0;

        // Save off the filter.
        WsbAffirmHr(m_pFilter->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Save(pStream, clearDirty));
        pPersistStream = 0;

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaServer::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaServer::SaveAll(
    void
    )

/*++

Implements:

  IwsbServer::SaveAll

Return Value:
    S_OK     - Success
    S_FALSE  - Already saving
    Other    - Error

--*/
{

    HRESULT                     hr = S_OK;
    static BOOL                 saving = FALSE;

    WsbTraceIn(OLESTR("CFsaServer::SaveAll"), OLESTR(""));

    try {
        DWORD   status, errWait;
        CComPtr<IPersistFile>       pPersistFile;

        WsbAffirm(!saving, S_FALSE);

        // Synchronize saving of persistent data with snapshot signaling event
        saving = TRUE;
        status = WaitForSingleObject(m_savingEvent, EVENT_WAIT_TIMEOUT);
        
        // Save anyway, then report if the Wait function returned an unexpected error
        errWait = GetLastError();
        
        // Note: Don't throw exception here because even if saving fails, we still need 
        //  to set the saving event and reset the saving flag.
        hr = (((IUnknown*) (IFsaServer*) this)->QueryInterface(IID_IPersistFile, (void**) &pPersistFile));
        if (SUCCEEDED(hr)) {
            hr = WsbSafeSave(pPersistFile);
        }

        // Check Wait status... Note that hr remains OK because the saving itself completed fine
        switch (status) {
            case WAIT_OBJECT_0: 
                // The expected case
                if (! SetEvent(m_savingEvent)) {
                    // Don't abort, just trace error
                    WsbTraceAlways(OLESTR("CFsaServer::SaveAll: SetEvent returned unexpected error %lu\n"), GetLastError());
                }
                break;

            case WAIT_TIMEOUT: 
                // TEMPORARY: Should we log somethig here? This might happen if snapshot process 
                //  takes too long for some reason, but logging seems to just confuse the user
                //  and he really can not (and should not) do anything...
                WsbTraceAlways(OLESTR("CFsaServer::SaveAll: Wait for Single Object timed out after %lu ms\n"), EVENT_WAIT_TIMEOUT);
                break;

            case WAIT_FAILED:
                WsbTraceAlways(OLESTR("CFsaServer::SaveAll: Wait for Single Object returned error %lu\n"), errWait);
                break;

            default:
                WsbTraceAlways(OLESTR("CFsaServer::SaveAll: Wait for Single Object returned unexpected status %lu\n"), status);
                break;
        }         

        saving = FALSE;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaServer::SaveAll"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CFsaServer::ScanForResources(
    void
    )

/*++

Implements:

  IFsaServer::ScanForResources().

Routine Description:

    This routine implements the COM method for creating (on the first call) or 
    updating (on all subsequent calls) the persisted ('master') collection of 
    resources (i.e., drives/volumes) which are MANAGEABLE by this HSM system.

    The method contains 3 phases (sections).  The first phase creates a 'working' 
    resource collection, which it then populates with all manageable resources it 
    finds after scanning all resources on this computer.  (Only NTFS-formatted 
    volumes which support sparse files and reparse points are considered to be 
    manageable by Sakkara.)  The second phase then correlates, or 'synchronizes', 
    the contents of the 'working' collection with those of the 'master' collection.  
    This synchronization consists of adding to the 'master' collection any resources 
    contained in the 'working' collection which are not in the 'master' collection, 
    and updating any resources already in the master collection from the resources 
    in the working collection. The third phase 'synchronizes' (compares) the contents 
    of the master collection to those in the working collection.  Any resources in 
    the master collection which are not in the working collection are marked as 'not 
    available' so those resources do not appear in any list of manageable 
    resources presented to the user.

    NOTE that the method does not end by explicitly releasing the working resource 
    collection.  This is because the interface pointer to the working collection is 
    contained within a smart pointer, which automatically calls Release() on itself 
    when it goes out of scope.  The working collection derives from the 
    CWsbIndexedCollection class, which contains a Critical Section.  This section is 
    destroyed on a Release() call, so subsequent calls to Release() would fail 
    (normally with an Access Violation in NTDLL.dll) due to the non-existence of the 
    Critical Section.  For this reason the working collection is allowed to auto-
    garbage collect itself when it goes out of scope at method end (which also 
    releases all the resources contained in the working collection).

Arguments:

    none.

Return Value:

    S_OK - The call succeeded (the persisted collection of manageable resources on 
            this computer was either created or updated).

    E_FAIL - The call to get the logical names of all drives (resources) on this 
            computer failed.

    E_UNEXPECTED - Thrown if the total number of either working collection or master
            collection resources were not processed during the synchronization phases.

    Any other value - The call failed because one of the Remote Storage API calls 
            contained internally in this method failed.  The error value returned is
            specific to the API call which failed.
            
--*/

{
    HRESULT                     hr = S_OK;
    HRESULT                     searchHr = E_FAIL;
    CComPtr<IWsbCollection>     pWorkingResourceCollection;
    CComPtr<IWsbEnum>           pEnum;
    CComPtr<IFsaResource>       pScannedResource;
    CComPtr<IFsaResourcePriv>   pScannedResourcePriv;
    CComPtr<IFsaResource>       pWorkingResource;
    CComPtr<IFsaResource>       pMasterResource;
    CComPtr<IFsaResourcePriv>   pMasterResourcePriv;
    GUID                        id = GUID_NULL;
    DWORD                       i = 0;
    DWORD                       j = 0;
    ULONG                       nbrResources = 0;
    ULONG                       nbrResourcesSynced  = 0;
    ULONG                       nbrResourcesUpdated = 0;
    ULONG                       nbrResourcesAdded   = 0;
    CWsbStringPtr               tmpString;
// The below variables are used in support of the code which scans all resources known 
// by this computer in building the working collection of manageable resources (the 
// code contained in Phase 1 below).  The code is written to discover ALL resources, 
// including those mounted without drive letters.
    BOOL                        b;
    PWSTR                       dosName;            // Pointer to a null-terminated Unicode
                                                    // character string.
    HANDLE                      hVol;
    WCHAR                       volName[2*MAX_PATH];
    WCHAR                       driveName[10];
    WCHAR                       driveNameWOBack[10];
    WCHAR                       driveLetter;
    WCHAR                       otherName[MAX_PATH];

    WsbTraceIn(OLESTR("CFsaServer::ScanForResources"), OLESTR(""));

    try {
        WsbAffirmPointer(m_pResources);

        //
        // First phase: Scan all resources, load manageable ones in a 'working' collection.
        //
        
        // Create the 'working' resource collection (with no items).
        // This is where the results of this scan will be stored.  
        WsbAffirmHr(CoCreateInstance(CLSID_CWsbOrderedCollection, NULL, 
                                     CLSCTX_SERVER, IID_IWsbCollection, 
                                     (void**) &pWorkingResourceCollection));

        // Begin code added to use new API's which discover all volumes, including those 
        // mounted without drive letters (new feature to NT5) - added by Mike Lotz
        driveName[1] = ':';
        driveName[2] = '\\';
        driveName[3] = 0;
        // drive name without back slash
        driveNameWOBack[1] = ':';
        driveNameWOBack[2] = 0;
    
        // Find the first volume on this computer.  Call returns the long, ugly PNP name.
        hVol = FindFirstVolume( volName, MAX_PATH );
        if ( INVALID_HANDLE_VALUE != hVol ) {
            do {
        
                // Release the current interface pointers that will be reused in this loop.  
                // This drops the ref count to 0, releasing memory, object (if it was not 
                // added to the collection), and the interface pointer itself, but not the 
                // smart pointer instance.
                //
                // Do first so we gaurantee cleanup before reuse
                //
                pScannedResource = 0;
                pScannedResourcePriv = 0;
                // The long, ugly PNP name.
                tmpString = volName;

                // Initialize
                dosName = NULL;

                WsbTrace(OLESTR("CFsaServer::ScanForResources - Searching for %ws\n"),
                                tmpString);

                // Loop through this computer's volumes/resources until we find the one 
                // that 'FindFirstVolume' or 'FindNextVolume' returned to us.  (Note they 
                // are not returned in drive letter order, but in PNP name order.)  We do 
                // this since we need the drive letter for the resource (if there is one), 
                // and currently neither of the above calls returns it.
                for (driveLetter = L'C'; driveLetter <= L'Z'; driveLetter++) {

                    driveName[0] = driveLetter;
                    driveNameWOBack[0] = driveLetter;
                    b = GetVolumeNameForVolumeMountPoint(driveName, otherName,
                                                         MAX_PATH);
                    // If unable to get a volume name for the mount point (if 'driveLetter'
                    // volume doesn't exist) jump back to the 'top' of the for loop.
                    if (!b) {
                        continue;
                    }

                    WsbTrace(OLESTR("CFsaServer::ScanForResources - for drive letter %ws "
                                L"volume name is %ws\n"),
                                driveName, otherName);

                    // if 'tmpString' (the long, ugly PNP volume name returned by the 
                    // 'Find[First/Next]Volume' call) and 'otherName' (also the PNP 
                    // volume name, but is returned by the 'GetVolumeNameFor...
                    // VolumeMountPoint call) ARE equal (lstrcmpi returns 0 if the 2 
                    // strings it compares are equal), set 'dosName' and break out of 
                    // the for loop, continuing thru the do-while.
                    if (!lstrcmpi(tmpString, otherName)) {
                        dosName = driveNameWOBack;
                        break;
                    }
                } // end for loop

                if (NULL != dosName) {
                    WsbTrace(OLESTR("CFsaServer::ScanForResources - DOS name is %ws "
                                L"Volume name to use is %ws\n"),
                                dosName, (WCHAR *)tmpString);
                } else {
                    WsbTrace(OLESTR("CFsaServer::ScanForResources - No DOS name, "
                                L"Volume name to use is %ws\n"),
                                (WCHAR *)tmpString);
                    
                    // Find if the volume is mounted in a mount point other than drive letter
                    HRESULT hrMount = WsbGetFirstMountPoint(tmpString, otherName, MAX_PATH);
                    if (S_OK == hrMount) {
                        if (wcslen(otherName) > 1) {
                            // Remove trailing backslash
                            dosName = otherName;
                            dosName[wcslen(otherName)-1] = 0;
                            WsbTrace(OLESTR("CFsaServer::ScanForResources - Mount path is %ws\n"),
                                        dosName);
                        }
                    } else {
                        WsbTrace(OLESTR("CFsaServer::ScanForResources - no Mount path found, hr = <%ls>\n"),
                                WsbHrAsString(hrMount));                                
                    }
                }
                // end of code added to support volumes without drive letters.

                WsbTrace(OLESTR("CFsaServer::ScanForResources - Checking resource %ls "
                                L"for manageability\n"), 
                                (WCHAR *) tmpString);


                // Create Resource instance to be used to test volume manageability.  Get
                // 'private' (non-exposed) interface since test method (Init()) is there.
                WsbAffirmHr(CoCreateInstance(CLSID_CFsaResourceNTFS, NULL, 
                                             CLSCTX_SERVER, IID_IFsaResourcePriv, 
                                             (void**) &pScannedResourcePriv));
                
                try {
                    
                    // Test volume for manageability.  If so, get and store volume info, 
                    // assign a Guid to the volume (if not already done), and create and/or 
                    // locate the Premigrated DB.
                    WsbAffirmHr(pScannedResourcePriv->Init((IFsaServer*) this, tmpString, 
                                                            dosName));
                    // We have a manageable volume (resource).  Get 'public' interface for 
                    // the resource since this is what is stored in the collection.
                    WsbAffirmHr(pScannedResourcePriv->QueryInterface(IID_IFsaResource, 
                                                             (void**) &pScannedResource));

                    // Add the manageable resource to the 'working' collection.
                    WsbAffirmHr( pWorkingResourceCollection->Add( pScannedResource ) );
                    WsbAffirmHr(pScannedResource->GetIdentifier( &id ) );
                    WsbTrace
                      (OLESTR("CFsaServer::ScanForResources - Added <%ls> to working list "
                                L"(id = %ls)\n"),
                                (WCHAR *) tmpString, WsbGuidAsString(id));

                // Test if Init() call above failed.  If so, skip this volume, go on to next.
                } WsbCatchAndDo(hr, if ((FSA_E_UNMANAGABLE == hr) || 
                                        (FSA_E_NOMEDIALOADED == hr)) {hr = S_OK;} 
                                        else {
                                            if (NULL != dosName) {
                                                WsbLogEvent(FSA_MESSAGE_BAD_VOLUME, 0, NULL, 
                                                  (WCHAR *) dosName, WsbHrAsString(hr), 0);
                                                        
                                            } else {
                                                WsbLogEvent(FSA_MESSAGE_BAD_VOLUME, 0, NULL, 
                                                (WCHAR *) tmpString, WsbHrAsString(hr), 0);
                                            }
                                        //
                                        // Do not fail just because one volume got an error
                                        hr = S_OK;
                                        });

            // end do-while; process next resource on this computer
            } while ( FindNextVolume( hVol, volName, MAX_PATH ) );

            // close the handle
            FindVolumeClose( hVol );

        } // if INVALID_HANDLE_VALUE != hVol

        // If first phase didn't complete Ok abort this method (with Trace & Logging).
        WsbAssertHrOk( hr );


        //
        // Second phase: Correlate/synchronize resources in 'working' collection with 
        // those in the 'master' (persisted) collection.
        //
        
        // Get number of resources stored in the working collection.
        WsbAffirmHr( pWorkingResourceCollection->GetEntries( &nbrResources ) );

        // Get iterator to working collection.
        WsbAffirmHr( pWorkingResourceCollection->Enum( &pEnum ) );

        // For each resource in the 'working' collection, search the 'master' collection 
        // to see if the resource is listed.  If so, update the master resource's state 
        // from the working resource.  If not, add it.
    
        for ( hr = pEnum->First( IID_IFsaResource, (void**) &pWorkingResource ); 
              SUCCEEDED( hr ); 
              hr = pEnum->Next( IID_IFsaResource, (void**) &pWorkingResource ) ) {

            // Release reused interface pointers for next loop iteration.
            // Do first to gaurantee clean pointer before use
            pMasterResource = 0;
            pMasterResourcePriv = 0;

            // Search for this resource in master collection.  (There is no need to 
            // set the 'working' resource's 'compare by' field since it is constructed 
            // with the 'compare by id' value and we haven't changed it.)
            searchHr = m_pResources->Find( pWorkingResource, IID_IFsaResource, 
                                             (void**) &pMasterResource );

            try {
                if ( SUCCEEDED( searchHr ) ) {
                    // A matching resource entry has been found in the master 
                    // collection, so update it.

                    // Get the 'private' interface to the master resource & update it 
                    // from the working resource.

                    WsbAffirmHr(pMasterResource->QueryInterface( IID_IFsaResourcePriv, 
                                                      (void**) &pMasterResourcePriv ) );
                    WsbAffirmHr(pMasterResourcePriv->UpdateFrom( (IFsaServer*) this, 
                                                             pWorkingResource ) );

                    /*/ *** TEMP TRACE - remove from normal code path for efficiency.
                    CWsbStringPtr   workingRsc;
                    CWsbStringPtr   masterRsc;
                    GUID            workingRscId = GUID_NULL;
                    
                    // First get the path (root of volume) & id of the 'working' resource.
                    WsbAffirmHr(pWorkingResource->GetPath( &workingRsc, 0 ) );
                    WsbAffirmHr(pWorkingResource->GetIdentifier( &workingRscId ) );
                    // then that of the 'master' resource.
                    WsbAffirmHr(pMasterResource->GetPath( &masterRsc, 0 ) );

                    WsbTrace(OLESTR("CFsaServer::ScanForResources - "   
                        L"Master resource <%ls> updated from working resource <%ls>"
                        L" (id = <%ls>).\n"),
                                    (OLECHAR*)masterRsc, (OLECHAR*)workingRsc,
                                    WsbGuidAsString( workingRscId ) );
                    // *** End TEMP TRACE  */
        
                    nbrResourcesUpdated += 1;
                
                }
                else if ( WSB_E_NOTFOUND == searchHr ) { 
                    // No matching entry found in the master collection, add it, indicate 
                    // synchronization success.
                    WsbAffirmHr( m_pResources->Add( pWorkingResource ) );

                    /*/ *** TEMP TRACE - remove from normal code path for efficiency.
                    CWsbStringPtr   workingRsc;
                    GUID            workingRscId = GUID_NULL;
                    
                    // Get the path (root of volume) and id of the 'working' resource.
                    WsbAffirmHr(pWorkingResource->GetPath( &workingRsc, 0 ) );
                    WsbAffirmHr(pWorkingResource->GetIdentifier( &workingRscId ) );

                    WsbTrace(OLESTR("CFsaServer::ScanForResources - "   
                        L"Working resource <%ls> added to master collection "
                        L"(id = <%ls>.\n"),
                                    workingRsc, WsbGuidAsString( workingRscId ) );
                    // *** End TEMP TRACE  */
        
                    nbrResourcesAdded += 1;
                    searchHr = S_OK;
                }
                
                // Trap any unexpected search failure: Trace, Log, Throw; skip to next rsc.
                WsbAssertHrOk( searchHr );

                // This volume has been synchronized in the master collection, register 
                // or update the FSA Resource in Directory Services as necessary.
                WsbAffirmHr(pWorkingResource->GetLogicalName(&tmpString, 0));
                WsbAffirmHr(HsmPublish(HSMCONN_TYPE_RESOURCE, tmpString, id, 0, m_id));

            } WsbCatch( hr );
            
            // Done with this Resource. Increment count of resources synchronized and 
            // release interface pointer for next iteration.
            nbrResourcesSynced += 1;
            pWorkingResource = 0;

        } // end 'for'

        // Ensure all resources in working collection were processed.  If not,
        // Trace, Log and Throw and abort the method.
        WsbAssert( nbrResources == nbrResourcesSynced, E_UNEXPECTED );

        // Ensure we are at the end of the working collection.  If not, abort.
        WsbAssert( WSB_E_NOTFOUND == hr, hr );
        
        hr = S_OK;

        WsbTrace(OLESTR("CFsaServer::ScanForResources - "   
                        L"2nd phase (1st search): Total working resources %lu. "
                        L"Resources updated %lu, resources added %lu.\n"),
                        nbrResources, nbrResourcesUpdated, nbrResourcesAdded);
        

        //
        // Third phase: Correlate/synchronize resources in 'master' collection with 
        // those in the 'working' collection.
        //
        
        // Reset counters for next for loop
        nbrResourcesSynced = 0;
        nbrResourcesUpdated = 0;

        // Get number of volumes stored in the 'master' Resource collection.
        WsbAffirmHr( m_pResources->GetEntries( &nbrResources ) );

        // Release the collection enumerator since we are about to reuse it.
        pEnum = 0;
        
        // Get an iterator to the 'master' collection
        WsbAffirmHr( m_pResources->Enum( &pEnum ) );

        /*/ *** TEMP TRACE - remove from normal code path for efficiency.
        CWsbStringPtr   masterResource;
        GUID            masterResourceId = GUID_NULL;
        // *** End TEMP TRACE  */

        // For each volume in the 'master' collection, search the 'working' collection 
        // to see if the resource is listed.  If so, skip to the next resource.  If not 
        // (this indicates this resource is no longer manageable), mark it as not available
        // in the 'master' collection's resource, which prevents the resource from  
        // being displayed whenever the list of manageable resources is presented.
        pMasterResource = 0;
        for ( hr = pEnum->First( IID_IFsaResource, (void**) &pMasterResource ); 
              SUCCEEDED( hr ); 
              pMasterResource = 0, hr = pEnum->Next( IID_IFsaResource, (void**) &pMasterResource ) ) {

            pMasterResourcePriv = 0;
            pWorkingResource = 0;

            // Set the search key, then search for this resource in working collection.
            // (Even though resource objects are constructed with their 'compare by' field 
            // set to 'compare by id', reset it here in case it has changed.)
            WsbAffirmHr( pMasterResource->CompareBy( FSA_RESOURCE_COMPARE_ID ) );
            searchHr = pWorkingResourceCollection->Find( pMasterResource, IID_IFsaResource,
                                                    (void**) &pWorkingResource );


            try {
                if ( WSB_E_NOTFOUND == searchHr ) { 
                    // No matching entry found in the 'working' collection, so this 
                    // resource is no longer manageable.  Mark it as not-available.

                    /*/ *** TEMP TRACE - remove from normal code path for efficiency.
                    CWsbStringPtr   masterRsc;
                    GUID            masterRscId = GUID_NULL;
                    
                    // Get the path (root of volume) and GUID of the 'master' resource 
                    // before it is nulled.
                    WsbAffirmHr(pMasterResource->GetPath( &masterRsc, 0 ) );
                    WsbAffirmHr(pMasterResource->GetIdentifier( &masterRscId ) );
                    // *** End TEMP TRACE  */

                    //
                    // Make it not available and null out the path, sticky name, and user friendly name so 
                    // it is not confused with another resource with the same name.
                    //
                    WsbAffirmHr(pMasterResource->QueryInterface( IID_IFsaResourcePriv, 
                                                      (void**) &pMasterResourcePriv ) );
                    WsbAffirmHr(pMasterResource->SetIsAvailable(FALSE));
                    WsbAffirmHr(pMasterResourcePriv->SetPath(OLESTR("")));
                    WsbAffirmHr(pMasterResourcePriv->SetStickyName(OLESTR("")));
                    WsbAffirmHr(pMasterResourcePriv->SetUserFriendlyName(OLESTR("")));

                    // Indicate synchronization success (for Assert below)
                    searchHr = S_OK;

                    /*/ *** TEMP TRACE - remove from normal code path for efficiency.
                    WsbTrace(OLESTR("CFsaServer::ScanForResources - "   
                        L"Master resource <%ls> (path = <%ls>) was marked unavailable.\n"),
                                    WsbGuidAsString( masterRscId ), masterRsc );
                    // *** End TEMP TRACE  */
        
                    nbrResourcesUpdated += 1;
                }

                // Trap any unexpected search failure: Trace, Log, Throw; skip to next rsc.
                WsbAssertHrOk( searchHr );

            } WsbCatch( hr );
            
            // Done with this Resource. Increment count of resources synchronized and 
            // release interface pointer for next iteration.
            nbrResourcesSynced += 1;

            /*/ *** TEMP TRACE - remove from normal code path for efficiency.
            // Get the path of the 'master' resource.
            WsbAffirmHr(pMasterResource->GetPath( &masterResource, 0 ) );
            WsbAffirmHr(pMasterResource->GetIdentifier( &masterResourceId ) );
            WsbTrace(OLESTR("CFsaServer::ScanForResources - "   
                    L"Processed Master resource <%ls> (path = <%ls>), "
                    L"moving on to next Master...\n"),
                                WsbGuidAsString( masterResourceId ), masterResource );
            // *** End TEMP TRACE  */

            pMasterResource = 0;
        
        } // end 'for'

        // Ensure all resources in master collection were processed.  If not,
        // Trace, Log and Throw and abort the method.
        WsbAssert( nbrResources == nbrResourcesSynced, E_UNEXPECTED );

        // Ensure we are at the end of the master collection.  If not, abort.
        WsbAssert( WSB_E_NOTFOUND == hr, hr );
        
        hr = S_OK;

        WsbTrace(OLESTR("CFsaServer::ScanForResources - "   
                        L"3rd phase (2nd search): Total master resources %lu. "
                        L"Resources marked as not available: %lu.\n"),
                        nbrResources, nbrResourcesUpdated );
        
    } WsbCatch( hr );

    // Scan done. Again, DO NOT explicitly release the 'working' collection due to 
    // the reasons listed in the final paragraph under "Routine Description" above.
    // Both the working resource collection, and all the resources it contains, will 
    // be released implicitly at method end.

    WsbTraceOut(OLESTR("CFsaServer::ScanForResources"), OLESTR("hr = <%ls>"), 
                                                        WsbHrAsString(hr));
    return( hr );
}



HRESULT
CFsaServer::SetAutosave(
    IN ULONG milliseconds
    )

/*++

Implements:

  IFsaServer::SetAutosave().

--*/
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CFsaServer::SetAutosave"), OLESTR("milliseconds = <%ls>"), WsbPtrToUlongAsString( &milliseconds ) );

    try {
        //  Don't do anything if interval isn't changing
        if (milliseconds != m_autosaveInterval) {
            //  Close the current thread
            if (m_autosaveThread) {
                StopAutosaveThread();
            }
            m_autosaveInterval = milliseconds;

            //  Start/restart the autosave thread
            if (m_autosaveInterval) {
                DWORD  threadId;

                WsbAffirm((m_autosaveThread = CreateThread(0, 0, FsaStartAutosave, (void*) this, 0, &threadId)) != 0, HRESULT_FROM_WIN32(GetLastError()));
            }
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaServer::SetAutosave"), OLESTR("hr = <%ls> m_runInterval = <%ls>"), WsbHrAsString(hr), WsbPtrToUlongAsString( &m_autosaveInterval ) );

    return(hr);
}


HRESULT CFsaServer::SetId(
    GUID  id
    )
/*++

Implements:

  IWsbServer::SetId().

--*/
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CFsaServer::SetId"), OLESTR("id = <%ls>"), WsbGuidAsString( id ) );
    m_id = id;
    WsbTraceOut(OLESTR("CFsaServer::SetId"), OLESTR("hr = <%ls>"), WsbHrAsString( hr ) );
    return( hr );
}


HRESULT
CFsaServer::SetIsUpdatingAccessDates(
    BOOL isUpdating
    )

/*++

Implements:

  IFsaServer::IsUpdatingAccessDates().

--*/
{
    HRESULT         hr = S_OK;
   
    try { 

        // Removing the key allows for updating access times, and setting it
        // to 1 causes updating to be stopped.      
        if (isUpdating) {
            WsbAffirmHr(WsbRemoveRegistryValue(NULL, OLESTR("SYSTEM\\CurrentControlSet\\Control\\FileSystem"), OLESTR("NtfsDisableLastAccessUpdate")));
        } else {
            WsbAffirmHr(WsbSetRegistryValueDWORD(NULL, OLESTR("SYSTEM\\CurrentControlSet\\Control\\FileSystem"), OLESTR("NtfsDisableLastAccessUpdate"), 1));
        }

    } WsbCatch(hr);
    
    return(hr);    
}


HRESULT 
CFsaServer::ChangeSysState( 
    IN OUT HSM_SYSTEM_STATE* pSysState 
    )

/*++

Implements:

  IHsmSystemState::ChangeSysState().

--*/

{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaServer::ChangeSysState"), OLESTR(""));

    try {
        if (pSysState->State & HSM_STATE_SUSPEND) {
            if (!m_Suspended) {
                m_Suspended = TRUE;

                // Save data
                SaveAll();
            }
        } else if (pSysState->State & HSM_STATE_RESUME) {
            m_Suspended = FALSE;
        } else if (pSysState->State & HSM_STATE_SHUTDOWN) {

            //  Close the autosave thread
            StopAutosaveThread();

            if (m_pFilter != NULL) {
                //
                // Kill the filter thread and cancel the IOCTLS pending in the kernel filter
                //
                m_pFilter->StopIoctlThread();
            }
        }

        //  Notify resources
        if (m_pResources) {
            //
            // Scan through the resources and notify
            //
            CComPtr<IWsbEnum>         pEnum;
            CComPtr<IFsaResourcePriv> pResourcePriv;

            WsbAffirmHr(m_pResources->Enum(&pEnum));
            hr = pEnum->First(IID_IFsaResourcePriv, (void**)&pResourcePriv);
            while (S_OK == hr) {
                hr = pResourcePriv->ChangeSysState(pSysState);
                pResourcePriv = 0;
                hr = pEnum->Next(IID_IFsaResourcePriv, (void**)&pResourcePriv);
            }
            if (WSB_E_NOTFOUND == hr) {
                hr = S_OK;
            }
        }

        if (pSysState->State & HSM_STATE_SHUTDOWN) {

            //  Dump object table info
            WSB_OBJECT_TRACE_TYPES;
            WSB_OBJECT_TRACE_POINTERS(WSB_OTP_STATISTICS | WSB_OTP_ALL);
         }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaServer::ChangeSysState"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaServer::Unload(
    void
    )

/*++

Implements:

  IwsbServer::Unload

Return Value:
    S_OK     - Success
    Other    - Error

--*/
{

    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaServer::Unload"), OLESTR(""));

    try {

        //  We only need to release what may have gotten set/created by
        //  a failed Load attempt.

        if (m_pResources) {
            WsbAffirmHr(m_pResources->RemoveAllAndRelease());
        }

        m_name.Free();

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaServer::Unload"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CFsaServer::DestroyObject(
    void
    )
/*++

Implements:

  IWsbServer::DestroyObject

Return Value:
    S_OK     - Success

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaServer::DestroyObject"), OLESTR(""));

    CComObject<CFsaServer> *pFsaDelete = (CComObject<CFsaServer> *)this;
    delete pFsaDelete;

    WsbTraceOut(OLESTR("CFsaServer::DestroyObject"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CFsaServer::GetNtProductVersion ( 
    OLECHAR **pNtProductVersion, 
    ULONG bufferSize
    )  
/*++

Implements:

  IWsbServer::GetNtProductVersion().

--*/

{

    HRESULT hr = S_OK;
    
    try  {
        CWsbStringPtr tmpString;
        
        WsbAssert(0 != pNtProductVersion,  E_POINTER);
        
        tmpString = VER_PRODUCTVERSION_STRING;
        WsbAffirmHr(tmpString.CopyTo(pNtProductVersion, bufferSize));
        
    } WsbCatch( hr );
    
    return (hr);
}

HRESULT
CFsaServer::GetNtProductBuild( 
    ULONG *pNtProductBuild
    )

/*++

Implements:

  IWsbServer::GetNtProductBuild().

--*/
{
    HRESULT       hr = S_OK;
    WsbTraceIn(OLESTR("CFsaServer::GetNtProductBuild"), OLESTR(""));
   
    *pNtProductBuild = VER_PRODUCTBUILD;
    
    WsbTraceOut(OLESTR("CFsaServer::GetNtProductBuild"), OLESTR("hr = <%ls>, Version = <%ls)"),
        WsbHrAsString(hr), WsbLongAsString(VER_PRODUCTBUILD));
    return ( hr );
}


HRESULT
CFsaServer::CheckAccess(
    WSB_ACCESS_TYPE AccessType
    )
/*++

Implements:

  IWsbServer::CheckAccess().

--*/
{
    WsbTraceIn(OLESTR("CFsaServer::CheckAccess"), OLESTR(""));
    HRESULT hr = S_OK;
    
    try  {

        //
        // Do the impersonation
        //
        WsbAffirmHr( CoImpersonateClient() );

        hr = WsbCheckAccess( AccessType );
    
        CoRevertToSelf();
        
    } WsbCatchAndDo( hr,

        //
        // Handle case where there is no COM context to check against
        // in which case we are the service so any security is allowed.
        //
        if( ( hr == RPC_E_NO_CONTEXT ) || ( hr != RPC_E_CALL_COMPLETE ) ) {
        
            hr = S_OK;
        
        }                      

    );
    
    WsbTraceOut(OLESTR("CFsaServer::CheckAccess"), OLESTR("hr = <%ls>"), WsbHrAsString( hr ) );
    return( hr );
}


HRESULT
CFsaServer::GetTrace(
    OUT IWsbTrace ** ppTrace
    )
/*++

Implements:

  IWsbServer::GetTrace().

--*/
{
    WsbTraceIn(OLESTR("CFsaServer::GetTrace"), OLESTR("ppTrace = <0x%p>"), ppTrace);
    HRESULT hr = S_OK;
    
    try {

        WsbAffirmPointer(ppTrace);
        *ppTrace = 0;

        WsbAffirmPointer(m_pTrace);
        
        *ppTrace = m_pTrace;
        (*ppTrace)->AddRef();
        
    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CFsaServer::GetTrace"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT
CFsaServer::SetTrace(
    OUT IWsbTrace * pTrace
    )
/*++

Implements:

  IWsbServer::SetTrace().

--*/
{
    WsbTraceIn(OLESTR("CFsaServer::SetTrace"), OLESTR("pTrace = <0x%p>"), pTrace);
    HRESULT hr = S_OK;
    
    try {

        WsbAffirmPointer(pTrace);

        m_pTrace = pTrace;

    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CFsaServer::SetTrace"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

void
CFsaServer::StopAutosaveThread(
    void
    )
/*++

Routine Description:

  Stop the Autosave thread:
    First try gracefully, using the termination event
    If doesn't work, just terminate the thread

Arguments:

  None.
  
Return Value:

  S_OK  - Success.

--*/
{

    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaServer::StopAutosaveThread"), OLESTR(""));

    try {
        // Terminate the autosave thread
        if (m_autosaveThread) {
            // Signal thread to terminate
            SetEvent(m_terminateEvent);

            // Wait for the thread, if it doesn't terminate gracefully - kill it
            switch (WaitForSingleObject(m_autosaveThread, 20000)) {
                case WAIT_FAILED: {
                    WsbTrace(OLESTR("CFsaServer::StopAutosaveThread: WaitForSingleObject returned error %lu\n"), GetLastError());
                }
                // fall through...

                case WAIT_TIMEOUT: {
                    WsbTrace(OLESTR("CFsaServer::StopAutosaveThread: force terminating of autosave thread.\n"));

                    DWORD dwExitCode;
                    if (GetExitCodeThread( m_autosaveThread, &dwExitCode)) {
                        if (dwExitCode == STILL_ACTIVE) {   // thread still active
                            if (!TerminateThread (m_autosaveThread, 0)) {
                                WsbTrace(OLESTR("CFsaServer::StopAutosaveThread: TerminateThread returned error %lu\n"), GetLastError());
                            }
                        }
                    } else {
                        WsbTrace(OLESTR("CFsaServer::StopAutosaveThread: GetExitCodeThread returned error %lu\n"), GetLastError());
                    }

                    break;
                }

                default:
                    // Thread terminated gracefully
                    WsbTrace(OLESTR("CFsaServer::StopAutosaveThread: Autosave thread terminated gracefully\n"));
                    break;
            }

            // Best effort done for terminating auto-backup thread
            CloseHandle(m_autosaveThread);
            m_autosaveThread = 0;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaServer::StopAutosaveThread"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
}

HRESULT
CFsaServer::CreateMetadataSaveEvent(
    void
    )
/*++

Implements:

  CFsaServer::CreateMetadataSaveEvent().

--*/
{
    WsbTraceIn(OLESTR("CFsaServer::CreateMetadataSaveEvent"), OLESTR(""));
    HRESULT hr = S_OK;

    PSID pSystemSID = NULL;
    PACL pACL = NULL;
    PSECURITY_DESCRIPTOR pSD = NULL;
#define     WRITER_EVENTS_NUM_ACE      1
    EXPLICIT_ACCESS ea[WRITER_EVENTS_NUM_ACE];
    SID_IDENTIFIER_AUTHORITY SIDAuthNT = SECURITY_NT_AUTHORITY;
    SECURITY_ATTRIBUTES sa;
    
    try {
        // Create an SD with ACL for local-system only
        // Create an SD with ACL for local-system only
        memset(ea, 0, sizeof(EXPLICIT_ACCESS) * WRITER_EVENTS_NUM_ACE);


        WsbAssertStatus( AllocateAndInitializeSid( &SIDAuthNT, 1,
                             SECURITY_LOCAL_SYSTEM_RID,
                             0, 0, 0, 0, 0, 0, 0,
                             &pSystemSID) );
        ea[0].grfAccessPermissions = FILE_ALL_ACCESS;
        ea[0].grfAccessMode = SET_ACCESS;
        ea[0].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
        ea[0].Trustee.pMultipleTrustee = NULL;
        ea[0].Trustee.MultipleTrusteeOperation  = NO_MULTIPLE_TRUSTEE;
        ea[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;
        ea[0].Trustee.TrusteeType = TRUSTEE_IS_USER;
        ea[0].Trustee.ptstrName  = (LPTSTR) pSystemSID;

        WsbAffirmNoError(SetEntriesInAcl(WRITER_EVENTS_NUM_ACE, ea, NULL, &pACL));

        pSD = (PSECURITY_DESCRIPTOR) WsbAlloc(SECURITY_DESCRIPTOR_MIN_LENGTH); 
        WsbAffirmPointer(pSD);
        WsbAffirmStatus(InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION));
 
        WsbAffirmStatus(SetSecurityDescriptorDacl(
                            pSD, 
                            TRUE,     // fDaclPresent flag   
                            pACL, 
                            FALSE));   // not a default DACL 

        sa.nLength = sizeof (SECURITY_ATTRIBUTES);
        sa.lpSecurityDescriptor = pSD;
        sa.bInheritHandle = FALSE;

        // Create the event that synchronize saving of persistent data with snapshots
        WsbAffirmHandle(m_savingEvent = CreateEvent(&sa, FALSE, TRUE, HSM_FSA_STATE_EVENT));

    } WsbCatch(hr);
    
    if (pSystemSID) {
        FreeSid(pSystemSID);
    }
    if (pACL) {
        LocalFree(pACL);
    }
    if (pSD) {
        WsbFree(pSD);
    }

    WsbTraceOut(OLESTR("CFsaServer::CreateMetadataSaveEvent"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\fsa\fsaunmdb.h ===
/*++

Module Name:

    fsaunmdb.h

Abstract:

    Header file for the Unmanage Db classes (db and rec)

Author:

    Ran Kalach   [rankala]   05-Dec-2000

Revision History:

--*/

#ifndef _FSAUNMDB_
#define _FSAUNMDB_


#include "resource.h"       
#include "wsbdb.h"

// Simple Db - one rec type with one index
#define UNMANAGE_KEY_TYPE                   1

/////////////////////////////////////////////////////////////////////////////
// CFsaUnmanageDb

class CFsaUnmanageDb : 
    public IFsaUnmanageDb,
    public CWsbDb,
    public CComCoClass<CFsaUnmanageDb,&CLSID_CFsaUnmanageDb>
{
public:
    CFsaUnmanageDb() {}
BEGIN_COM_MAP(CFsaUnmanageDb)
    COM_INTERFACE_ENTRY(IFsaUnmanageDb)
    COM_INTERFACE_ENTRY2(IWsbDb, IFsaUnmanageDb)
    COM_INTERFACE_ENTRY(IWsbDbPriv)
    COM_INTERFACE_ENTRY(IPersistStream)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_FsaUnmanageDb)

DECLARE_PROTECT_FINAL_CONSTRUCT();

    STDMETHOD(FinalConstruct)(void);
    STDMETHOD(FinalRelease)(void);

// IWsbDb
    WSB_FROM_CWSBDB;

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pclsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize) {
            return(CWsbDb::GetSizeMax(pSize)); }
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IFsaUnmanageDb
public:
    STDMETHOD(Init)(OLECHAR* name, IWsbDbSys* pDbSys, BOOL* pCreated);

private:
};                                                                           




/////////////////////////////////////////////////////////////////////////////
// CFsaUnmanageRec

class CFsaUnmanageRec : 
    public CWsbDbEntity,
    public IFsaUnmanageRec,
    public CComCoClass<CFsaUnmanageRec,&CLSID_CFsaUnmanageRec>
{
public:
    CFsaUnmanageRec() {}
BEGIN_COM_MAP(CFsaUnmanageRec)
    COM_INTERFACE_ENTRY(IFsaUnmanageRec)
    COM_INTERFACE_ENTRY2(IWsbDbEntity, CWsbDbEntity)
    COM_INTERFACE_ENTRY(IWsbDbEntityPriv)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
END_COM_MAP()

//DECLARE_NO_REGISTRY()
DECLARE_REGISTRY_RESOURCEID(IDR_FsaUnmanageRec)

    STDMETHOD(FinalConstruct)(void);
    STDMETHOD(FinalRelease)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbDbEntity
public:
    STDMETHOD(Print)(IStream* pStream);
    STDMETHOD(UpdateKey)(IWsbDbKey *pKey);
    WSB_FROM_CWSBDBENTITY;

// IWsbTestable
    STDMETHOD(Test)(USHORT* /*passed*/, USHORT* /*failed*/) {
        return(E_NOTIMPL); }

// IFsaUnmanageRec
public:
    STDMETHOD(GetMediaId)(GUID* pId);
    STDMETHOD(GetFileOffset)(LONGLONG* pOffset);
    STDMETHOD(GetFileId)(LONGLONG* pFileId);
    STDMETHOD(SetMediaId)(GUID id);
    STDMETHOD(SetFileOffset)(LONGLONG offset);
    STDMETHOD(SetFileId)(LONGLONG FileId);

private:
    GUID            m_MediaId;          // id of media where the file resides  
    LONGLONG        m_FileOffset;       // absolute offset of the file on media
    LONGLONG        m_FileId;           // file id 
};

#endif  // _FSAUNMDB_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\fsa\fsaunmdb.cpp ===
/*++


Module Name:

    fsaunmdb.cpp

Abstract:

    Defines the functions for the Unmanage Db & record classes.

Author:

    Ran Kalach   [rankala]   05-Dec-2000

Revision History:

--*/


#include "stdafx.h"
#include "wsb.h"


#include "fsaunmdb.h"

#define WSB_TRACE_IS        WSB_TRACE_BIT_FSA

static USHORT iCountUnmRec = 0;  // Count of existing objects

HRESULT 
CFsaUnmanageDb::FinalConstruct(
    void
    ) 
/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;

    try {
        WsbAssertHr(CWsbDb::FinalConstruct());
        m_version = 1;
    } WsbCatch(hr);

    return(hr);
}

HRESULT 
CFsaUnmanageDb::FinalRelease(
    void
    ) 
/*++

Implements:

  CComObjectRoot::FinalRelease

--*/
{
    HRESULT     hr = S_OK;

    CWsbDb::FinalRelease();
    return(hr);
}

HRESULT
CFsaUnmanageDb::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    try {
        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CFsaUnmanageDb;
    } WsbCatch(hr);
    
    return(hr);
}

HRESULT
CFsaUnmanageDb::Init(
    IN  OLECHAR* path,
    IN  IWsbDbSys* pDbSys, 
    OUT BOOL*    pCreated
    )

/*++

Implements:

  IFsaUnmanageDb::Init

--*/
{
    BOOL             created = FALSE;
    HRESULT          hr = S_OK;

    WsbTraceIn(OLESTR("CFsaUnmanageDb::Init"),OLESTR(""));

    try {
        m_pWsbDbSys = pDbSys;
        WsbAffirmPointer(m_pWsbDbSys);

        // Attempt to find the DB
        // If we find it - delete it, since we always want to start with a new db !!
        hr = Locate(path);

        if (STG_E_FILENOTFOUND == hr) {
            // Expected...
            WsbTrace(OLESTR("CFsaUnmanageDb::Init: db Locate failed with not-found, will create a new one...\n"));
            hr = S_OK;
        } else if (S_OK == hr) {
            // Cleanup wasn't done in previous run
            WsbTrace(OLESTR("CFsaUnmanageDb::Init: db Locate succeeded - will delete so a new one can be created\n"));

            WsbAffirmHr(Delete(path, IDB_DELETE_FLAG_NO_ERROR));
        } else {
            // Still try to delete and continue...
            // (Db could be corrupted for example due to abnormal termination of previous run -
            //  we don't care since all we want is to always try creating a new one).
            WsbTrace(OLESTR("CFsaUnmanageDb::Init: db Locate failed with <%ls> - will try to delete and continue\n"),
                        WsbHrAsString(hr));

            // Ignore Delete errors...
            hr = Delete(path, IDB_DELETE_FLAG_NO_ERROR);
            WsbTrace(OLESTR("CFsaUnmanageDb::Init: db Delete finished with <%ls> - will try to create a new db\n"),
                        WsbHrAsString(hr));
            hr = S_OK;
        }

        // If we got that far, it means that the Unmanage Db doesn't exist and we can re-create
        ULONG memSize;

        m_nRecTypes = 1;

        memSize = m_nRecTypes * sizeof(IDB_REC_INFO);
        m_RecInfo = (IDB_REC_INFO*)WsbAlloc(memSize);
        WsbAffirm(0 != m_RecInfo, E_OUTOFMEMORY);
        ZeroMemory(m_RecInfo, memSize);

        //  Unmanage record type
        m_RecInfo[0].Type = UNMANAGE_REC_TYPE;
        m_RecInfo[0].EntityClassId = CLSID_CFsaUnmanageRec;
        m_RecInfo[0].Flags = 0;
        m_RecInfo[0].MinSize = (WSB_BYTE_SIZE_GUID      +             // media id
                                WSB_BYTE_SIZE_LONGLONG  +             // file offset on media
                                WSB_BYTE_SIZE_LONGLONG);              // file id
        m_RecInfo[0].MaxSize = m_RecInfo[0].MinSize;
        m_RecInfo[0].nKeys = 1;

        memSize = m_RecInfo[0].nKeys * sizeof(IDB_KEY_INFO);
        m_RecInfo[0].Key = (IDB_KEY_INFO*)WsbAlloc(memSize);
        WsbAffirm(0 != m_RecInfo[0].Key, E_OUTOFMEMORY);
        ZeroMemory(m_RecInfo[0].Key, memSize);

        m_RecInfo[0].Key[0].Type = UNMANAGE_KEY_TYPE;
        m_RecInfo[0].Key[0].Size = WSB_BYTE_SIZE_GUID + WSB_BYTE_SIZE_LONGLONG;;
        m_RecInfo[0].Key[0].Flags = IDB_KEY_FLAG_DUP_ALLOWED;   
        // same key possible on tape if a placeholder is restored to a new location on the same volume.
        // same key is common in optical
        // TEMPORARY - check if we shouldn't use IDB_KEY_FLAG_PRIMARY for performance (even if it means not allow dup !!
        //             (==> add one more part to the index, maybe auto-increment-coloumn, so it is always uniqe)

        //  Attempt to create the DB
        WsbAssertHr(Create(path, (IDB_CREATE_FLAG_NO_TRANSACTION | IDB_CREATE_FLAG_FIXED_SCHEMA)));
        created = TRUE;

    } WsbCatch(hr);

    if (pCreated) {
        *pCreated = created;
    }

    WsbTraceOut(OLESTR("CFsaUnmanageDb::Init"), OLESTR("hr = <%ls>, Created = %ls"), 
        WsbHrAsString(hr), WsbBoolAsString(created));

    return(hr);
}

HRESULT
CFsaUnmanageDb::Load(
    IN IStream* pStream
    )

/*++

Implements:

  IPersistStream::Load().

Note:
  This database is not expected to be persistent by the using class.
  However, the base class CWsbDb is persistable so we need to implement this 

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CFsaUnmanageDb::Load"),OLESTR(""));

    hr = CWsbDb::Load(pStream);

    if (S_OK != hr && STG_E_FILENOTFOUND != hr) {
        // Got some error; delete the DB (we'll recreate it later if
        // we need it
        WsbTrace(OLESTR("CFsaUnmanageDb::Load: deleting DB\n"));
        if (S_OK == Delete(NULL, IDB_DELETE_FLAG_NO_ERROR)) {
            hr = STG_E_FILENOTFOUND;
        }
    }

    WsbTraceOut(OLESTR("CFsaUnmanageDb::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CFsaUnmanageDb::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )

/*++

Implements:

  IPersistStream::Save().

Note:
  This database is not expected to be persistent by the using class.
  However, the base class CWsbDb is persistable so we need to implement this 

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CFsaUnmanageDb::Save"),OLESTR(""));

    try {
        WsbAffirmHr(CWsbDb::Save(pStream, clearDirty));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaUnmanageDb::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT 
CFsaUnmanageRec::GetMediaId(
    OUT GUID* pId 
    ) 
/*++

Implements:

  IFsaUnmanageRec::GetMediaId

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaUnmanageRec::GetMediaId"),OLESTR(""));

    try {
        WsbAssert(0 != pId, E_POINTER);

        *pId = m_MediaId;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaUnmanageRec::GetMediaId"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CFsaUnmanageRec::GetFileOffset(
    OUT LONGLONG* pOffset 
    ) 
/*++

Implements:

  IFsaUnmanageRec::GetFileOffset

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaUnmanageRec::GetFileOffset"),OLESTR(""));

    try {
        WsbAssert(0 != pOffset, E_POINTER);
        *pOffset = m_FileOffset;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaUnmanageRec::GetFileOffset"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CFsaUnmanageRec::GetFileId(
    OUT LONGLONG* pFileId 
    ) 
/*++

Implements:

  IFsaUnmanageRec::GetFileId

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaUnmanageRec::GetFileId"),OLESTR(""));

    try {
        WsbAssert(0 != pFileId, E_POINTER);
        *pFileId = m_FileId;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaUnmanageRec::GetFileId"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT 
CFsaUnmanageRec::SetMediaId(
    IN GUID id
    ) 
/*++

Implements:

  IFsaUnmanageRec::SetMediaId

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaUnmanageRec::SetMediaId"),OLESTR(""));

    m_MediaId = id;

    WsbTraceOut(OLESTR("CFsaUnmanageRec::SetMediaId"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT 
CFsaUnmanageRec::SetFileOffset(
    IN LONGLONG offset 
    ) 
/*++

Implements:

  IFsaUnmanageRec::SetFileOffset

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaUnmanageRec::SetFileOffset"),OLESTR(""));

    m_FileOffset = offset;

    WsbTraceOut(OLESTR("CFsaUnmanageRec::SetFileOffset"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT 
CFsaUnmanageRec::SetFileId(
    IN LONGLONG FileId 
    ) 
/*++

Implements:

  IFsaUnmanageRec::SetFileId

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaUnmanageRec::SetFileId"),OLESTR(""));

    m_FileId = FileId;

    WsbTraceOut(OLESTR("CFsaUnmanageRec::SetFileId"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT 
CFsaUnmanageRec::FinalConstruct(
    void
    ) 
/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssertHr(CWsbDbEntity::FinalConstruct());

        m_MediaId = GUID_NULL;
        m_FileOffset = 0;
        m_FileId = 0;

    } WsbCatch(hr);

    iCountUnmRec++;

    return(hr);
}


HRESULT 
CFsaUnmanageRec::FinalRelease(
    void
    ) 
/*++

Implements:

  CComObjectRoot::FinalRelease

--*/
{
    HRESULT     hr = S_OK;

    CWsbDbEntity::FinalRelease();

    iCountUnmRec--;

    return(hr);
}


HRESULT CFsaUnmanageRec::GetClassID
(
    OUT LPCLSID pclsid
    ) 
/*++

Implements:

  IPerist::GetClassID

--*/

{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaUnmanageRec::GetClassID"), OLESTR(""));


    try {
        WsbAssert(0 != pclsid, E_POINTER);
        *pclsid = CLSID_CFsaUnmanageRec;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaUnmanageRec::GetClassID"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT CFsaUnmanageRec::GetSizeMax
(
    OUT ULARGE_INTEGER* pcbSize
    ) 
/*++

Implements:

  IPersistStream::GetSizeMax().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaUnmanageRec::GetSizeMax"), OLESTR(""));

    try {
        
        WsbAssert(0 != pcbSize, E_POINTER);

        pcbSize->QuadPart = WsbPersistSizeOf(GUID)      + 
                            WsbPersistSizeOf(LONGLONG)  + 
                            WsbPersistSizeOf(LONGLONG);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaUnmanageRec::GetSizeMax"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT CFsaUnmanageRec::Load
(
    IN IStream* pStream
    ) 
/*++

Implements:

  IPersistStream::Load

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaUnmanageRec::Load"), OLESTR(""));

    try {
        WsbAssert(0 != pStream, E_POINTER);

        WsbAssertHr(WsbLoadFromStream(pStream, &m_MediaId));
        WsbAssertHr(WsbLoadFromStream(pStream, &m_FileOffset));
        WsbAssertHr(WsbLoadFromStream(pStream, &m_FileId));

    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CFsaUnmanageRec::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT CFsaUnmanageRec::Print
(
    IN IStream* pStream
    ) 
/*++

Implements:

  IWsbDbEntity::Print

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaUnmanageRec::Print"), OLESTR(""));

    try {
        WsbAssert(0 != pStream, E_POINTER);
        CWsbStringPtr strGuid;

        WsbAffirmHr(WsbSafeGuidAsString(m_MediaId, strGuid));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" MediaId = %ls"), 
                (WCHAR *)strGuid));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(", FileOffset = %ls"), 
                WsbLonglongAsString(m_FileOffset)));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(", FileId = %ls"), 
                WsbLonglongAsString(m_FileId)));

        WsbAffirmHr(CWsbDbEntity::Print(pStream));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaUnmanageRec::Print"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT CFsaUnmanageRec::Save
(
    IN IStream* pStream, 
    IN BOOL clearDirty
    ) 
/*++

Implements:

  IPersistStream::Save

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaUnmanageRec::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));

    try {
        WsbAssert(0 != pStream, E_POINTER);
        WsbAssertHr(WsbSaveToStream(pStream, m_MediaId));
        WsbAssertHr(WsbSaveToStream(pStream, m_FileOffset));
        WsbAssertHr(WsbSaveToStream(pStream, m_FileId));

        if (clearDirty) {
            m_isDirty = FALSE;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaUnmanageRec::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT 
CFsaUnmanageRec::UpdateKey(
    IWsbDbKey *pKey
    ) 
/*++

Implements:

  IWsbDbEntity::UpdateKey

--*/
{ 
    HRESULT     hr = S_OK; 

    try {
        WsbAffirmHr(pKey->SetToGuid(m_MediaId));
        WsbAffirmHr(pKey->AppendLonglong(m_FileOffset));
    } WsbCatch(hr);

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\fsa\dll\makefile.inc ===
$(O)\fsa.res: ..\fsaitem.rgs   \
              ..\fsarsc.rgs    \
              ..\fsasvr.rgs    \
              ..\fsafltr.rgs   \
              ..\fsaftrcl.rgs  \
              ..\fsaftclt.rgs  \
              ..\fsatrunc.rgs  \
              ..\fsapost.rgs   \
              ..\fsapremd.rgs  \
              ..\fsapremr.rgs  \
              ..\fsarcvy.rgs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\about.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    About.h

Abstract:

    Definition of the CAbout class.

Author:

    Art Bragg [abragg]   12-Aug-1997

Revision History:

--*/

#ifndef _ABOUT_H
#define _ABOUT_H

/////////////////////////////////////////////////////////////////////////////
// CAbout

class ATL_NO_VTABLE CAbout : 
    public ISnapinAbout,        // Supplies information to the About Box
    public CComObjectRoot,
    public CComCoClass<CAbout,&CLSID_CAbout>
{
public:
    CAbout();
    virtual ~CAbout();

BEGIN_COM_MAP(CAbout)
    COM_INTERFACE_ENTRY(ISnapinAbout)
END_COM_MAP()
DECLARE_NOT_AGGREGATABLE(CAbout) 

DECLARE_REGISTRY_RESOURCEID(IDR_About)

// ISnapinAbout methods
public:
    STDMETHOD(GetSnapinDescription)(LPOLESTR* lpDescription);
    STDMETHOD(GetProvider)(LPOLESTR* lpName);
    STDMETHOD(GetSnapinVersion)(LPOLESTR* lpVersion);
    STDMETHOD(GetSnapinImage)(HICON* hAppIcon);
    STDMETHOD(GetStaticFolderImage)(HBITMAP* hSmallImage, 
                                    HBITMAP* hSmallImageOpen, 
                                    HBITMAP* hLargeImage, 
                                    COLORREF* cLargeMask);
private:
    HRESULT AboutHelper(UINT nID, LPOLESTR* lpPtr);
    void DestroyBitmapObjects();
    void DestroyIconObject();

// Data members
private:
    HBITMAP	m_hSmallImage;
    HBITMAP	m_hLargeImage;
    HBITMAP	m_hSmallImageOpen;

    HICON m_hAppIcon;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\fsa\service\makefile.inc ===
$(O)\fsa.res: ..\fsa.rgs       \
              ..\fsaitem.rgs   \
              ..\fsarsc.rgs    \
              ..\fsasvr.rgs    \
              ..\fsafltr.rgs   \
              ..\fsaftrcl.rgs  \
              ..\fsaftclt.rgs  \
              ..\fsatrunc.rgs  \
              ..\fsapost.rgs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\about.cpp ===
/*++

(c) 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    About.cpp

Abstract:

    This component implements the ISnapinAbout
    interface for the Remote Storage Snapin.

Author:

    Art Bragg [abragg]   04-Aug-1997

Revision History:

--*/

#include "stdafx.h"

#include <NtVerP.h>
#include "RsBuild.h"

#include "About.h"

/////////////////////////////////////////////////////////////////////////////
//

///////////////////////////////////////////////////////////////////////
//                  ISnapinAbout
///////////////////////////////////////////////////////////////////////

CAbout::CAbout()
{
    m_hSmallImage = NULL;
    m_hSmallImageOpen = NULL;
    m_hLargeImage = NULL;
    m_hAppIcon = NULL;
}

CAbout::~CAbout()
{
	DestroyBitmapObjects();
	DestroyIconObject();
}

void CAbout::DestroyBitmapObjects(void)
{
    if (NULL != m_hSmallImage) {
		DeleteObject(m_hSmallImage);
        m_hSmallImage = NULL;
    }
    if (NULL != m_hSmallImageOpen) {
		DeleteObject(m_hSmallImageOpen);
        m_hSmallImageOpen = NULL;
    }
    if (NULL != m_hLargeImage) {
		DeleteObject(m_hLargeImage);
        m_hLargeImage = NULL;
    }
}

void CAbout::DestroyIconObject(void)
{
    if (NULL != m_hAppIcon) {
		DestroyIcon(m_hAppIcon);
        m_hAppIcon = NULL;
    }
}

HRESULT CAbout::AboutHelper(UINT nID, LPOLESTR* lpPtr)
{
    WsbTraceIn( L"CAbout::AboutHelper", L"lpPtr = <0x%p>", lpPtr );

    HRESULT hr = S_OK;

    try {

        WsbAffirmPointer( lpPtr );
        
        CWsbStringPtr s;
        s.LoadFromRsc( _Module.m_hInst, nID );

        *lpPtr = 0;
        WsbAffirmHr( s.CopyTo( lpPtr ) );
        
    } WsbCatch( hr );

    WsbTraceOut( L"CAbout::AboutHelper", L"hr = <%ls>, *lpPtr = <%ls>", WsbHrAsString( hr ), WsbPtrToStringAsString( lpPtr ) );
    return( hr );
}


STDMETHODIMP CAbout::GetSnapinDescription(LPOLESTR* lpDescription)
{
    WsbTraceIn( L"CAbout::GetSnapinDescription", L"lpDescription = <0x%p>", lpDescription );

    HRESULT hr = AboutHelper(IDS_DESCRIPTION, lpDescription);

    WsbTraceOut( L"CAbout::GetSnapinDescription", L"hr = <%ls>, *lpDescription = <%ls>", WsbHrAsString( hr ), WsbPtrToStringAsString( lpDescription ) );
    return( hr );
}


STDMETHODIMP CAbout::GetProvider(LPOLESTR* lpName)
{
    WsbTraceIn( L"CAbout::GetProvider", L"lpName = <0x%p>", lpName );

    HRESULT hr = AboutHelper(IDS_COMPANY, lpName);

    WsbTraceOut( L"CAbout::GetProvider", L"hr = <%ls>, *lpName = <%ls>", WsbHrAsString( hr ), WsbPtrToStringAsString( lpName ) );
    return( hr );
}


STDMETHODIMP CAbout::GetSnapinVersion(LPOLESTR* lpVersion)
{
    WsbTraceIn( L"CAbout::GetSnapinVersion", L"lpVersion = <0x%p>", lpVersion );

    HRESULT hr = S_OK;

    try {

        *lpVersion = 0;

        CWsbStringPtr s;
        s.Alloc( 100 );
        swprintf( s, L"%hs.%d [%ls]", VER_PRODUCTVERSION_STRING, VER_PRODUCTBUILD, RS_BUILD_VERSION_STRING );

        WsbAffirmHr( s.CopyTo( lpVersion ) );

    } WsbCatch( hr );

    WsbTraceOut( L"CAbout::GetSnapinVersion", L"hr = <%ls>, *lpVersion = <%ls>", WsbHrAsString( hr ), WsbPtrToStringAsString( lpVersion ) );
    return( hr );
}


STDMETHODIMP CAbout::GetSnapinImage(HICON* hAppIcon)
{
    WsbTraceIn( L"CAbout::GetSnapinImage", L"hAppIcon = <0x%p>", hAppIcon );

    AFX_MANAGE_STATE( AfxGetStaticModuleState());
    HRESULT hr = S_OK;

    try {

        WsbAffirmPointer( hAppIcon )

        DestroyIconObject();

        m_hAppIcon =        LoadIcon( AfxGetInstanceHandle(), MAKEINTRESOURCE( IDI_BLUESAKKARA ) );
        *hAppIcon = m_hAppIcon;
        WsbAffirmPointer( *hAppIcon );

    } WsbCatch( hr );

    WsbTraceOut( L"CAbout::GetSnapinImage", L"hr = <%ls>, *lpVersion = <%ls>", WsbHrAsString( hr ), WsbPtrToPtrAsString( (void**)hAppIcon ) );
    return( hr );
}


STDMETHODIMP
CAbout::GetStaticFolderImage(
    HBITMAP* hSmallImage, 
    HBITMAP* hSmallImageOpen,
    HBITMAP* hLargeImage, 
    COLORREF* cLargeMask
    )
{
    WsbTraceIn( L"CAbout::GetStaticFolderImage", L"" );

    AFX_MANAGE_STATE( AfxGetStaticModuleState());
    HRESULT hr = S_OK;
    
    try {
        DestroyBitmapObjects();

        m_hSmallImage =     LoadBitmap( AfxGetInstanceHandle(), MAKEINTRESOURCE( IDB_SMALL_SAKKARA ) );
        *hSmallImage =     m_hSmallImage;
        WsbAffirmStatus( 0 != *hSmallImage );

        m_hSmallImageOpen = LoadBitmap( AfxGetInstanceHandle(), MAKEINTRESOURCE( IDB_SMALL_SAKKARA ) );
        *hSmallImageOpen = m_hSmallImageOpen;
        WsbAffirmStatus( 0 != *hSmallImageOpen );

        m_hLargeImage =     LoadBitmap( AfxGetInstanceHandle(), MAKEINTRESOURCE( IDB_LARGE_SAKKARA ) );
        *hLargeImage =     m_hLargeImage;
        WsbAffirmStatus( 0 != *hLargeImage );

        *cLargeMask =      RGB( 0xFF, 0x00, 0xFF ); // Magenta

    } WsbCatch( hr );

    WsbTraceOut( L"CAbout::GetStaticFolderImage", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\fsa\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently
#ifndef _STDAFX_H
#define _STDAFX_H

//
// These NT header files must be included before any Win32 stuff or you
// get lots of compiler errors
//
extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#define WSB_TRACE_IS WSB_TRACE_BIT_FSA


#include <wsb.h>

#include <fsa.h>
#include <mover.h>
#include <mvrint.h>

#include "resource.h"
#include "esent.h"

// Fsa is running under RsServ serivce, these settings may change or become dynamic for a C/S HSM
#define FSA_REGISTRY_NAME       OLESTR("Remote_Storage_Server")
#define FSA_REGISTRY_PARMS      OLESTR("SYSTEM\\CurrentControlSet\\Services\\Remote_Storage_Server\\Parameters\\Fsa")

#ifndef MAX
#define MAX(a,b) ((a) > (b) ? (a) : (b))
#endif

#ifndef MIN
#define MIN(a,b) ((a) > (b) ? (b) : (a))
#endif

#endif // _STDAFX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\choohsm.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    ChooHsm.cpp

Abstract:

    Initial property page Wizard implementation. Allows the setting
    of who the snapin will manage.

Author:

    Rohde Wakefield [rohde]   12-Aug-1997

Revision History:

--*/

#include "stdafx.h"
#include "ChooHsm.h"

/////////////////////////////////////////////////////////////////////////////
// CChooseHsmDlg property page


CChooseHsmDlg::CChooseHsmDlg(
    CWnd* /*pParent*/ /*=NULL*/
    )
    : CPropertyPage( )
{
    WsbTraceIn( L"CChooseHsmDlg::CChooseHsmDlg", L"" );

    //{{AFX_DATA_INIT( CChooseHsmDlg )
    //}}AFX_DATA_INIT

    Construct( IDD_CHOOSE_HSM_2 );

    WsbTraceOut( L"CChooseHsmDlg::CChooseHsmDlg", L"" );
}

CChooseHsmDlg::~CChooseHsmDlg(
    )
{
    
}

void
CChooseHsmDlg::DoDataExchange(
    CDataExchange* pDX
    )
{
    CPropertyPage::DoDataExchange( pDX );
    //{{AFX_DATA_MAP( CChooseHsmDlg )
    DDX_Control( pDX, IDC_MANAGE_LOCAL,  m_ManageLocal );
    DDX_Control( pDX, IDC_MANAGE_REMOTE, m_ManageRemote );
    DDX_Text( pDX, IDC_MANAGE_NAME, m_ManageName );
    DDV_MaxChars( pDX, m_ManageName, 15 );
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP( CChooseHsmDlg, CPropertyPage )
//{{AFX_MSG_MAP( CChooseHsmDlg )
ON_BN_CLICKED( IDC_MANAGE_LOCAL, OnManageLocal )
ON_BN_CLICKED( IDC_MANAGE_REMOTE, OnManageRemote )
//}}AFX_MSG_MAP
END_MESSAGE_MAP( )

BOOL CChooseHsmDlg::OnInitDialog( ) {
    WsbTraceIn( L"CChooseHsmDlg::OnInitDialog", L"" );
    AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );

    CPropertyPage::OnInitDialog( );

    HRESULT hr = S_OK;
    try {

        SetButtons( CHOOSE_LOCAL );

//      m_WizardAnim.Seek( Use256ColorBitmap( ) ? 0 : 1 );
//      m_WizardAnim.Play( 0, -1, -1 );

    }WsbCatch( hr );

    WsbTraceOut( L"CChooseHsmDlg::OnInitDialog", L"" );
    return( FALSE );
}

// Set the finish button correctly based on the validity of the contents of the
// controls in this dialog page.
void
CChooseHsmDlg::SetButtons(
    CHOOSE_STATE state
    )
{
    WsbTraceIn( L"CChooseHsmDlg::SetButtons", L"" );

    ::PropSheet_SetWizButtons( GetParent( )->m_hWnd, PSWIZB_FINISH );

#define CTL_ENABLE( _id,_enable ) GetDlgItem( _id )->EnableWindow( _enable )
#define CTL_SHOW( _id,_show ) GetDlgItem( _id )->ShowWindow( ( _show ) ? SW_SHOWNA : SW_HIDE )

    CTL_ENABLE( IDC_MANAGE_NAME,   state & CHOOSE_REMOTE );
    CTL_ENABLE( IDC_MANAGE_BROWSE, state & CHOOSE_REMOTE );

    if( state & CHOOSE_LOCAL ) {

        if( ! m_ManageLocal.GetCheck( ) ) {

            m_ManageLocal.SetCheck( 1 );
            m_ManageRemote.SetCheck( 0 );

        }

//      m_WizardAnim.Open( m_AllowSetup ? IDR_WIZARD_AVI : IDR_LOCAL_AVI );
//      m_WizardAnim.Seek( Use256ColorBitmap( ) ? 0 : 1 );
//      m_WizardAnim.Play( 0, -1, -1 );

    } else {

        if( ! m_ManageRemote.GetCheck( ) ) {

            m_ManageRemote.SetCheck( 1 );
            m_ManageLocal.SetCheck( 0 );

        }

//      m_WizardAnim.Open( IDR_REMOTE_AVI );
//      m_WizardAnim.Seek( Use256ColorBitmap( ) ? 0 : 1 );
//      m_WizardAnim.Play( 0, -1, -1 );

    }

    WsbTraceOut( L"CChooseHsmDlg::SetButtons", L"" );
}

BOOL
CChooseHsmDlg::OnWizardFinish(
    )
{
    WsbTraceIn( L"CChooseHsmDlg::OnWizardFinish", L"" );

    AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );

//  m_WizardAnim.Stop( );

    //
    // Otherwise connect
    //

    if( m_ManageRemote.GetCheck( ) ) {

        GetDlgItemText( IDC_MANAGE_NAME, *m_pHsmName );

        while( *m_pHsmName[0] == '\\' ) {

            *m_pHsmName = m_pHsmName->Right( m_pHsmName->GetLength( ) - 1 );

        }

    } else {

        *m_pManageLocal = TRUE;

    }

    BOOL retval = CPropertyPage::OnWizardFinish( );

    WsbTraceOut( L"CChooseHsmDlg::OnWizardFinish", L"" );
    return( retval );
}


void
CChooseHsmDlg::OnManageLocal(
    )
{
    SetButtons( CHOOSE_LOCAL ); 
}

void
CChooseHsmDlg::OnManageRemote(
    )
{
    SetButtons( CHOOSE_REMOTE );    
}

/////////////////////////////////////////////////////////////////////////////
// CChooseHsmQuickDlg dialog


CChooseHsmQuickDlg::CChooseHsmQuickDlg( CWnd* pParent /*=NULL*/ )
: CDialog( CChooseHsmQuickDlg::IDD, pParent )
{
    //{{AFX_DATA_INIT( CChooseHsmQuickDlg )
    // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
    
}


void
CChooseHsmQuickDlg::DoDataExchange(
    CDataExchange* pDX
    )
{
    CDialog::DoDataExchange( pDX );
    //{{AFX_DATA_MAP( CChooseHsmQuickDlg )
    // NOTE: the ClassWizard will add DDX and DDV calls here
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP( CChooseHsmQuickDlg, CDialog )
//{{AFX_MSG_MAP( CChooseHsmQuickDlg )
//}}AFX_MSG_MAP
END_MESSAGE_MAP( )

/////////////////////////////////////////////////////////////////////////////
// CChooseHsmQuickDlg message handlers

BOOL
CChooseHsmQuickDlg::OnInitDialog(
    )
{
    CDialog::OnInitDialog( );

    //
    // ??? At some point do we want to store in the registry
    // or the console the last machine contact was attempted to?
    //

    return( TRUE );
}

void
CChooseHsmQuickDlg::OnOK(
    )
{
    GetDlgItemText( IDC_MANAGE_NAME, *m_pHsmName );

    while( *m_pHsmName[0] == '\\' ) {

        *m_pHsmName = m_pHsmName->Right( m_pHsmName->GetLength( ) - 1 );

    }

    CDialog::OnOK( );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\basehsm.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    BaseHSM.cpp

Abstract:

    Implementation of ISakNode interface.

Author:

    Rohde Wakefield [rohde]   04-Mar-1997

Revision History:

--*/

#include "stdafx.h"
#include "CSakData.h"
#include "CSakSnap.h"

/////////////////////////////////////////////////////////////////////////////
//
// CoComObjectRoot
//
/////////////////////////////////////////////////////////////////////////////
//---------------------------------------------------------------------------
//
//         FinalConstruct
//
//  Initialize this level of the object hierarchy
//

HRESULT CSakNode::FinalConstruct( )
{
    WsbTraceIn( L"CSakNode::FinalConstruct", L"" );

    // Connection point variables
    m_Advise                        = 0;
    m_bEnumState                    = FALSE;
    m_scopeID                       = UNINITIALIZED;
    m_bChildrenAreValid             = FALSE;
    m_bHasDynamicChildren           = FALSE;
    m_cChildProps                   = 0;
    m_cChildPropsShow               = 0;
    m_bSupportsPropertiesNoEngine   = FALSE;
    m_bSupportsPropertiesSingle     = FALSE;
    m_bSupportsPropertiesMulti      = FALSE;
    m_bSupportsRefreshNoEngine      = FALSE;
    m_bSupportsRefreshSingle        = FALSE;
    m_bSupportsRefreshMulti         = FALSE;
    m_bSupportsDeleteSingle         = FALSE;
    m_bSupportsDeleteMulti          = FALSE;
    m_PrivateData                   = 0;

    // Initialize toolbar stuff.  If not overrided,
    // node does not have a toolbar

    m_ToolbarBitmap             = UNINITIALIZED;
    m_cToolbarButtons           = 0;
    INT i;
    for( i = 0; i < MAX_TOOLBAR_BUTTONS; i++ ) {

        m_ToolbarButtons[i].nBitmap = UNINITIALIZED;
        m_ToolbarButtons[i].idCommand = UNINITIALIZED;
        m_ToolbarButtons[i].fsState = TBSTATE_ENABLED;
        m_ToolbarButtons[i].fsType = TBSTYLE_BUTTON;
        m_ToolbarButtons[i].idButtonText = UNINITIALIZED;
        m_ToolbarButtons[i].idTooltipText = UNINITIALIZED;

    }

    // Do not initialize m_nOpenIcon and m_nCloseIcon. The derived classes 
    // will do that.

    HRESULT hr = CComObjectRoot::FinalConstruct( );

    WsbTraceOut( L"CSakNode::FinalConstruct", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT CSakNode::OnToolbarButtonClick( IDataObject * /* pDataObject */, long /* cmdId */ )
{
    return S_OK;
}

//---------------------------------------------------------------------------
//
//         FinalRelease
//
//  Clean up this level of the object hierarchy
//

void CSakNode::FinalRelease( )
{
    WsbTraceIn( L"CSakNode::FinalRelease", L"" );

    //
    // Free the children of this node.
    //
    DeleteAllChildren( );

    //
    // Free the child properties list and their widths.
    //
    FreeChildProps();

    CComObjectRoot::FinalRelease( );

    WsbTraceOut( L"CSakNode::FinalRelease", L"" );
}

void CSakNode::SetConnection( IUnknown *pUnkConnection )
{
    WsbTraceIn( L"CSakNode::SetConnection", L"" );
    HRESULT hr = S_OK;

    try {

        WsbAffirmPointer ( pUnkConnection );
        m_pUnkConnection = pUnkConnection;

        //
        // Set up the connection point
        //
        WsbAffirmHr( AtlAdvise( pUnkConnection, (IUnknown *) (ISakNode*) this, IID_IHsmEvent, &m_Advise ) );

    } WsbCatch ( hr );

    WsbTraceOut( L"CSakNode::SetConnection", L"" );
}

// Connection point "callback"
STDMETHODIMP CSakNode::OnStateChange( )
{
    WsbTraceIn( L"CSakNode::OnStateChange", L"" );
    HRESULT hr = S_OK;

    try {

        WsbAffirmHr( m_pSakSnapAsk->UpdateAllViews( this ) );

    } WsbCatch( hr );

    WsbTraceOut( L"CSakNode::OnStateChange", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( S_OK );
}
/////////////////////////////////////////////////////////////////////////////
//
// ISakNode
//
/////////////////////////////////////////////////////////////////////////////

//---------------------------------------------------------------------------
//
//         get/put_DisplayName
//
//  Give back the 'DisplayName' property.
//

STDMETHODIMP CSakNode::get_DisplayName( BSTR *pName )
{
    WsbTraceIn( L"CSakNode::get_DisplayName", L"pName = <0x%p>", pName );
    HRESULT hr = S_OK;

    try {

        WsbAffirmPointer( pName );
        *pName = 0;

        BSTR name = 0;
        if( m_szName ) {

            name = SysAllocString( m_szName );
            WsbAffirmAlloc( name );

        }
        *pName = name;

    } WsbCatch( hr );

    WsbTraceOut( L"CSakNode::get_DisplayName", L"hr = <%ls>, *pName = <%ls>", WsbHrAsString( hr ), WsbPtrToStringAsString( pName ) );
    return( hr );
}

STDMETHODIMP CSakNode::put_DisplayName( OLECHAR *pszName )
{
    WsbTraceIn( L"CSakNode::put_DisplayName", L"pszName = <%ls>", pszName );

    HRESULT hr = S_OK;
    m_szName = pszName;

    WsbTraceOut( L"CSakNode::put_DisplayName", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

STDMETHODIMP CSakNode::get_DisplayName_SortKey( BSTR *pName )
{
    WsbTraceIn( L"CSakNode::get_DisplayName_SortKey", L"pName = <0x%p>", pName );
    HRESULT hr = S_OK;

    try {

        WsbAffirmPointer( pName );
        *pName = 0;

        BSTR name = 0;
        if( m_szName_SortKey ) {

            name = SysAllocString( m_szName_SortKey );
            WsbAffirmAlloc( name );

        } else if( m_szName ) {

            name = SysAllocString( m_szName );
            WsbAffirmAlloc( name );

        }

        *pName = name;

    } WsbCatch( hr );

    WsbTraceOut( L"CSakNode::get_DisplayName_SortKey", L"hr = <%ls>, *pName = <%ls>", WsbHrAsString( hr ), WsbPtrToStringAsString( pName ) );
    return( hr );
}


STDMETHODIMP CSakNode::put_DisplayName_SortKey( OLECHAR *pszName )
{
    WsbTraceIn( L"CSakNode::put_DisplayName_SortKey", L"pszName = <%ls>", pszName );

    HRESULT hr = S_OK;
    m_szName_SortKey = pszName;

    WsbTraceOut( L"CSakNode::put_DisplayName_SortKey", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

//---------------------------------------------------------------------------
//
//         get/put_Type
//
//  Give back the 'Type' property.
//

STDMETHODIMP CSakNode::get_Type( BSTR *pType )
{
    WsbTraceIn( L"CSakNode::get_Type", L"pType = <0x%p>", pType );
    HRESULT hr = S_OK;

    try {

        WsbAffirmPointer( pType );
        *pType = 0;

        BSTR type = 0;
        if( m_szType ) {

            type = SysAllocString( m_szType );
            WsbAffirmAlloc( type );

        }
        *pType = type;

    } WsbCatch( hr );

    WsbTraceOut( L"CSakNode::get_Type", L"hr = <%ls>, *pType = <%ls>", WsbHrAsString( hr ), WsbPtrToStringAsString( pType ) );
    return( hr );
}

STDMETHODIMP CSakNode::put_Type( OLECHAR *pszType )
{
    WsbTraceIn( L"CSakNode::put_Type", L"pszType = <%ls>", pszType );

    HRESULT hr = S_OK;
    m_szType = pszType;

    WsbTraceOut( L"CSakNode::put_Type", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

STDMETHODIMP CSakNode::get_Type_SortKey( BSTR *pType )
{
    WsbTraceIn( L"CSakNode::get_Type_SortKey", L"pType = <0x%p>", pType );
    HRESULT hr = S_OK;

    try {

        WsbAffirmPointer( pType );
        *pType = 0;

        BSTR type = 0;
        if( m_szType ) {

            type = SysAllocString( m_szType );
            WsbAffirmAlloc( type );

        }
        *pType = type;

    } WsbCatch( hr );

    WsbTraceOut( L"CSakNode::get_Type_SortKey", L"hr = <%ls>, *pType = <%ls>", WsbHrAsString( hr ), WsbPtrToStringAsString( pType ) );
    return( hr );
}

//---------------------------------------------------------------------------
//
//         get/put_Description
//
//  Give back the 'Description' property.
//

STDMETHODIMP CSakNode::get_Description( BSTR *pDesc )
{
    WsbTraceIn( L"CSakNode::get_Description", L"pDesc = <0x%p>", pDesc );
    HRESULT hr = S_OK;

    try {

        WsbAffirmPointer( pDesc );
        *pDesc = 0;

        BSTR desc = 0;
        if( m_szDesc ) {

            desc = SysAllocString( m_szDesc );
            WsbAffirmAlloc( desc );

        }
        *pDesc = desc;


    } WsbCatch( hr );


    WsbTraceOut( L"CSakNode::get_Description", L"hr = <%ls>, *pDesc = <%ls>", WsbHrAsString( hr ), WsbPtrToStringAsString( pDesc ) );
    return( hr );
}

STDMETHODIMP CSakNode::put_Description( OLECHAR *pszDesc )
{
    WsbTraceIn( L"CSakNode::put_Description", L"pszDesc = <%ls>", pszDesc );

    HRESULT hr = S_OK;
    m_szDesc = pszDesc;

    WsbTraceOut( L"CSakNode::put_Description", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

STDMETHODIMP CSakNode::get_Description_SortKey( BSTR *pDesc )
{
    WsbTraceIn( L"CSakNode::get_Description_SortKey", L"pDesc = <0x%p>", pDesc );
    HRESULT hr = S_OK;

    try {

        WsbAffirmPointer( pDesc );
        *pDesc = 0;

        BSTR desc = 0;
        if( m_szDesc ) {

            desc = SysAllocString( m_szDesc );
            WsbAffirmAlloc( desc );

        }
        *pDesc = desc;


    } WsbCatch( hr );


    WsbTraceOut( L"CSakNode::get_Description_SortKey", L"hr = <%ls>, *pDesc = <%ls>", WsbHrAsString( hr ), WsbPtrToStringAsString( pDesc ) );
    return( hr );
}

//---------------------------------------------------------------------------
//
//         ChildrenAreValid
//
//  Report if node's current list of children are valid. Things that can make the
//  children invalid are: 
//  1) They have not yet been discovered.
//  2) Something has occurred in the "external" world to cause them to become out-of-date.
//

STDMETHODIMP CSakNode::ChildrenAreValid( void )
{
    WsbTraceIn( L"CSakNode::ChildrenAreValid", L"" );

    HRESULT hr = m_bChildrenAreValid ? S_OK : S_FALSE;

    WsbTraceOut( L"CSakNode::ChildrenAreValid", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

//---------------------------------------------------------------------------
//
//         InvalidateChildren
//

STDMETHODIMP CSakNode::InvalidateChildren( void )
{
    WsbTraceIn( L"CSakNode::InvalidateChildren", L"" );
    HRESULT hr = S_OK;

    m_bChildrenAreValid = FALSE;

    WsbTraceOut( L"CSakNode::InvalidateChildren", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


//---------------------------------------------------------------------------
//
//         GetEnumState / SetEnumState
//
//  Report if node's children have already been enumerated once. This is a convenience
//  function to help users of nodes from needlessly enumerating children if it has already
//  been done.
//
//  !! future work - if the hsm engine changes the children of a node, making re-enumeration
//     necessary, this switch could be turned back to FALSE so that the next time a node
//     is queried as to its enumeration state, it would show up as needing enumeration.
//

STDMETHODIMP CSakNode::GetEnumState( BOOL* pState )
{
    WsbTraceIn( L"CSakNode::GetEnumState", L"pState = <0x%p>", pState );

    HRESULT hr = S_OK;
    *pState = m_bEnumState;

    WsbTraceOut( L"CSakNode::GetEnumState", L"hr = <%ls>, *pState = <%ls>", WsbHrAsString( hr ), WsbPtrToBoolAsString( pState ) );
    return( hr );
}

STDMETHODIMP CSakNode::SetEnumState( BOOL state )
{
    WsbTraceIn( L"CSakNode::SetEnumState", L"state = <%ls>", WsbBoolAsString( state ) );

    HRESULT hr = S_OK;
    m_bEnumState = state;

    WsbTraceOut( L"CSakNode::SetEnumState", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

//---------------------------------------------------------------------------
//
//         GetHsmObj
//
//  Return a pointer to the underlying Hsm Object that the CBaseHsm 
//  object encapsulates.
//
STDMETHODIMP CSakNode::GetHsmObj( IUnknown** ppHsmObj )
{
    WsbTraceIn( L"CSakNode::GetHsmObj", L"ppHsmObj = <0x%p>", ppHsmObj );

    HRESULT hr = S_OK;
    m_pHsmObj.CopyTo( ppHsmObj );

    WsbTraceOut( L"CSakNode::GetHsmObj", L"hr = <%ls>, *ppHsmObj = <%ls>", WsbHrAsString( hr ), WsbPtrToPtrAsString( (void**)ppHsmObj ) );
    return( hr );
}


//---------------------------------------------------------------------------
//
//         GetParent
//
//  Return the cookie of the parent node
//
STDMETHODIMP CSakNode::GetParent( ISakNode** ppParent )
{
    WsbTraceIn( L"CSakNode::GetParent", L"ppParent = <0x%p>", ppParent );

    HRESULT hr = S_OK;
    
    try {

        WsbAffirmPointer( ppParent );
        m_pParent.CopyTo( ppParent );

    } WsbCatch( hr );

    WsbTraceOut( L"CSakNode::GetParent", L"hr = <%ls>, *ppParent = <0x%p>", WsbHrAsString( hr ), WsbPtrToPtrAsString( (void**)ppParent ) );
    return( hr );
}

//---------------------------------------------------------------------------
//
//         GetScopeID / SetScopeID
//
//  Put and set the scopeview ID for this item into the node, itself.
//

STDMETHODIMP CSakNode::GetScopeID( HSCOPEITEM* pid )
{
    WsbTraceIn( L"CSakNode::GetScopeID", L"pid = <0x%p>", pid );

    HRESULT hr = S_OK;
    *pid = m_scopeID;

    if( m_scopeID == UNINITIALIZED ) {

        hr = E_PENDING;

    }

    WsbTraceOut( L"CSakNode::GetScopeID", L"hr = <%ls>, *pid = <0x%p>", WsbHrAsString( hr ), *pid );
    return( hr );
}

STDMETHODIMP CSakNode::SetScopeID( HSCOPEITEM id )
{
    WsbTraceIn( L"CSakNode::SetScopeID", L"id = <0x%p>", id );

    HRESULT hr = S_OK;
    m_scopeID = id;

    WsbTraceOut( L"CSakNode::SetScopeID", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

//---------------------------------------------------------------------------
//
//         EnumChildren
//
//  Create an enumerator and return the children.
//

STDMETHODIMP CSakNode::EnumChildren( IEnumUnknown ** ppEnum )
{
    WsbTraceIn( L"CSakNode::EnumChildren", L"ppEnum = <0x%p>", ppEnum );

    HRESULT hr = S_OK;
    CEnumUnknown * pEnum = 0;

    try {

        WsbAffirmPointer( ppEnum );
        *ppEnum = 0;

        //
        // New an ATL enumerator
        //
        pEnum = new CEnumUnknown;
        WsbAffirmAlloc( pEnum );
        
        //
        // Initialize it to copy the current child interface pointers
        //
        WsbAffirmHr( pEnum->FinalConstruct() );
        if( m_Children.begin( ) ) {

            WsbAffirmHr( pEnum->Init( (IUnknown**)m_Children.begin( ), (IUnknown**)m_Children.end( ), NULL, AtlFlagCopy ) );

        } else {

            static IUnknown* pUnkDummy;
            WsbAffirmHr( pEnum->Init( &pUnkDummy, &pUnkDummy, NULL, AtlFlagCopy ) );
        }
        WsbAffirmHr( pEnum->QueryInterface( IID_IEnumUnknown, (void**)ppEnum ) );

    } WsbCatchAndDo( hr,

        if( pEnum ) delete pEnum;

    );

    WsbTraceOut( L"CSakNode::EnumChildren", L"hr = <%ls>, *ppEnum = <%ls>", WsbHrAsString( hr ), WsbPtrToPtrAsString( (void**)ppEnum ) );
    return( hr );
}


//---------------------------------------------------------------------------
//
//         EnumChildDisplayPropWidths
//
//  Enumerate back the widths for the properties of my children that should be 
//  shown in the result pane view.
//

STDMETHODIMP CSakNode::EnumChildDisplayPropWidths( IEnumString** ppEnum )
{
    WsbTraceIn( L"CSakNode::EnumChildDisplayPropWidths", L"ppEnum = <0x%p>", ppEnum );

    HRESULT hr = S_OK;
    
    CEnumString * pEnum = 0;
    
    try {

        WsbAffirmPointer( ppEnum );
        WsbAffirm( m_cChildPropsShow > 0, S_FALSE );

        *ppEnum = 0;

        //
        // New an ATL enumerator
        //
        pEnum = new CEnumString;
        WsbAffirmAlloc( pEnum );

        WsbAffirmHr( pEnum->FinalConstruct( ) );
        WsbAffirmHr( pEnum->Init( &m_rgszChildPropWidths[0], &m_rgszChildPropWidths[m_cChildPropsShow], NULL, AtlFlagCopy ) );
        WsbAffirmHr( pEnum->QueryInterface( IID_IEnumString, (void**)ppEnum ) );
        
    } WsbCatchAndDo( hr,
        
        if( pEnum ) delete pEnum;
        
    );

    WsbTraceOut( L"CSakNode::EnumChildDisplayPropWidths", L"hr = <%ls>, *ppEnum = <%ls>", WsbHrAsString( hr ), WsbPtrToPtrAsString( (void**)ppEnum ) );
    return( hr );
}

//---------------------------------------------------------------------------
//
//         EnumChildDisplayProps
//
//  Enumerate back the properties of my children that should be shown in the
//  result pane view.
//

STDMETHODIMP CSakNode::EnumChildDisplayProps( IEnumString ** ppEnum )
{
    WsbTraceIn( L"CSakNode::EnumChildDisplayProps", L"ppEnum = <0x%p>", ppEnum );

    HRESULT hr = S_OK;
    
    CEnumString * pEnum = 0;
    
    try {

        WsbAffirmPointer( ppEnum );
        WsbAffirm( m_cChildPropsShow > 0, S_FALSE );

        *ppEnum = 0;

        //
        // New an ATL enumerator
        //
        pEnum = new CEnumString;
        WsbAffirmAlloc( pEnum );

        WsbAffirmHr( pEnum->FinalConstruct( ) );
        WsbAffirmHr( pEnum->Init( &m_rgszChildPropIds[0], &m_rgszChildPropIds[m_cChildPropsShow], NULL, AtlFlagCopy ) );
        WsbAffirmHr( pEnum->QueryInterface( IID_IEnumString, (void**)ppEnum ) );
        
    } WsbCatchAndDo( hr,
        
        if( pEnum ) delete pEnum;
        
    );

    WsbTraceOut( L"CSakNode::EnumChildDisplayProps", L"hr = <%ls>, *ppEnum = <%ls>", WsbHrAsString( hr ), WsbPtrToPtrAsString( (void**)ppEnum ) );
    return( hr );
}

//---------------------------------------------------------------------------
//
//         EnumChildDisplayTitles
//
//  Enumerate back the properties of my children that should be shown in the
//  result pane view.
//

STDMETHODIMP CSakNode::EnumChildDisplayTitles( IEnumString ** ppEnum )
{
    WsbTraceIn( L"CSakNode::EnumChildDisplayTitles", L"ppEnum = <0x%p>", ppEnum );

    HRESULT hr = S_OK;
    
    CEnumString * pEnum = 0;
    
    try {

        WsbAffirmPointer( ppEnum );
        WsbAffirm( m_cChildPropsShow > 0, S_FALSE );

        *ppEnum = 0;

        //
        // New an ATL enumerator
        //
        pEnum = new CEnumString;
        WsbAffirmAlloc( pEnum );

        WsbAffirmHr( pEnum->FinalConstruct( ) );
        WsbAffirmHr( pEnum->Init( &m_rgszChildPropTitles[0], &m_rgszChildPropTitles[m_cChildPropsShow], NULL, AtlFlagCopy ) );
        WsbAffirmHr( pEnum->QueryInterface( IID_IEnumString, (void**)ppEnum ) );
        
    } WsbCatchAndDo( hr,
        
        if( pEnum ) delete pEnum;
        
    );

    WsbTraceOut( L"CSakNode::EnumChildDisplayTitles", L"hr = <%ls>, *ppEnum = <%ls>", WsbHrAsString( hr ), WsbPtrToPtrAsString( (void**)ppEnum ) );
    return( hr );
}


/////////////////////////////////////////////////////////////////////////////
//
//         Helper Functions for derived classes
//
/////////////////////////////////////////////////////////////////////////////


//---------------------------------------------------------------------------
//
//         LoadContextMenu
//
//  Loads the specified menu resource and returns the first 
//  popup menu in it - used for context menus
//

HRESULT CSakNode::LoadContextMenu( UINT nId, HMENU *phMenu )
{
    WsbTraceIn( L"CSakNode::LoadContextMenu", L"nId = <%u>, phMenu = <0x%p>", nId, phMenu );

    *phMenu = LoadMenu ( _Module.m_hInst, MAKEINTRESOURCE( nId ) );
    HRESULT hr = *phMenu ? S_OK : E_FAIL;

    WsbTraceOut( L"CSakNode::LoadContextMenu", L"hr = <%ls>, *phMenu = <0x%p>", WsbHrAsString( hr ), *phMenu );
    return( hr );
}

//---------------------------------------------------------------------------
//
//         FindNodeOfType
//
//  Recursive search through nodes. Give back the IUnknown* interface of the 
// "nodetype" object (JobDefLst, JobPolLst, etc).
//

STDMETHODIMP 
CSakNode::FindNodeOfType(REFGUID nodetype, ISakNode** ppNode)
{
    WsbTraceIn( L"CSakNode::FindNodeOfType", L"nodetype = <%ls>, ppNode = <0x%p>", WsbGuidAsString( nodetype ), ppNode );

    HRESULT hr = S_FALSE;

    // check if this is the node we are looking for.
    if( IsEqualGUID( *m_rTypeGuid, nodetype ) ) {

        *ppNode = (ISakNode*)this;
        (*ppNode)->AddRef( );

        hr = S_OK;

    } else {

        // Search for correct node in this node's children.
        try {

            ISakNode** ppNodeEnum;
            for( ppNodeEnum = m_Children.begin( ); ppNodeEnum < m_Children.end( ); ppNodeEnum++ )  {
        
                if( *ppNodeEnum ) {

                    hr = (*ppNodeEnum)->FindNodeOfType( nodetype, ppNode );
                    if( hr == S_OK ) {
        
                        break;
                    }
                }
            }
        
        } WsbCatch( hr );
    }

    WsbTraceOut( L"CSakNode::FindNodeOfType", L"hr = <%ls>, *ppNode = <%ls>", WsbHrAsString( hr ), WsbPtrToPtrAsString( (void**)ppNode ) );
    return( hr );
}


//-----------------------------------------------------------------------------
//
//          SetChildProps
//
// Set the result view column properties
//

HRESULT
CSakNode::SetChildProps (
    const TCHAR* ResIdPropsIds,
    LONG         ResIdPropsTitles,
    LONG         ResIdPropsWidths
    )
/*++

Routine Description:

    Set the result view Ids, Titles, and Width strings from the 
    given resource Ids.

Arguments:


Return Value:

    S_OK - All added fine - continue.

    E_UNEXPECTED - Some error occurred. 

--*/

{
    WsbTraceIn( L"CSakNode::SetChildProps", L"ResIdPropsIds = <%ls>, ResIdPropsTitles = <%ld>, ResIdPropsWidths = <%ld>", ResIdPropsIds, ResIdPropsTitles, ResIdPropsWidths );

    CString szResource;
    CWsbStringPtr szWsbData;
    OLECHAR* szData;
    HRESULT hr = S_OK;
    INT i = 0;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    try {

        // First clean up the current properties (if any)
        FreeChildProps();

        // Properties Ids
        szWsbData = ResIdPropsIds;
        szData = szWsbData;
        szData = wcstok( szData, L":" );
        while( szData ) {

            m_rgszChildPropIds[m_cChildProps] = SysAllocString( szData );
            WsbAffirmAlloc( m_rgszChildPropIds[m_cChildProps] );
            szData = wcstok( NULL, L":" );
            m_cChildProps++;

        }

        // Property Titles
        i = 0;
        szResource.LoadString (ResIdPropsTitles);
        szWsbData = szResource;
        szData = szWsbData;
        szData = wcstok( szData, L":" );
        while( szData ) {

            m_rgszChildPropTitles[i] = SysAllocString( szData );
            WsbAffirmAlloc( m_rgszChildPropTitles[i] );
            szData = wcstok( NULL, L":" );
            i++;

        }

        // Properties Widths
        i = 0;
        szResource.LoadString( ResIdPropsWidths );
        szWsbData = szResource;
        szData = szWsbData;
        szData = wcstok( szData, L":" );
        while( szData ) {

            m_rgszChildPropWidths[i] = SysAllocString( szData );
            WsbAffirmAlloc( m_rgszChildPropWidths[i] );
            szData = wcstok( NULL, L":" );
            i++;

        }

        //
        // By default, show all props
        //

        m_cChildPropsShow = m_cChildProps;

    } WsbCatch( hr );

    WsbTraceOut( L"CSakNode::SetChildProps", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

//-------------------------------------------------------------------------------
//
//              FreeChildProps
//
// free up the old child properties and widths
//

HRESULT
CSakNode::FreeChildProps()
{
    WsbTraceIn( L"CSakNode::FreeChildProps", L"" );

    HRESULT hr = S_OK;

    for( INT i = 0; i < m_cChildProps; i++ ) {

        if( m_rgszChildPropIds[i]   )   SysFreeString( m_rgszChildPropIds[i] );
        if( m_rgszChildPropTitles[i])   SysFreeString( m_rgszChildPropTitles[i] );
        if( m_rgszChildPropWidths[i])   SysFreeString( m_rgszChildPropWidths[i] );

    }

    m_cChildProps     = 0;
    m_cChildPropsShow = 0;

    WsbTraceOut( L"CSakNode::FreeChildProps", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

//---------------------------------------------------------------------------------
//
//              RefreshObject
//
//  Fetch up-to-date information for the object.  Implemented in derived
//  classes
//
STDMETHODIMP 
CSakNode::RefreshObject ()
{
    WsbTraceIn( L"CSakNode::RefreshObject", L"" );

    HRESULT hr = S_OK;

    WsbTraceOut( L"CSakNode::RefreshObject", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

//---------------------------------------------------------------------------------
//
//              DeleteObject
//
//  Fetch up-to-date information for the object.  Implemented in derived
//  classes
//
STDMETHODIMP 
CSakNode::DeleteObject ()
{
    WsbTraceIn( L"CSakNode::DeleteObject", L"" );

    HRESULT hr = S_OK;

    WsbTraceOut( L"CSakNode::DeleteObject", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

/////////////////////////////////////////////////////////////////////////////
//
// Local utility functions
//
/////////////////////////////////////////////////////////////////////////////




STDMETHODIMP 
CSakNode::GetMenuHelp (
    LONG sCmd,
    BSTR * szHelp
    )

/*++

Routine Description:

    Retrieve .

Arguments:

    pDataObject - identifies the node to be worked on.

    pContextMenuCallback - The MMC menu interface to use.

Return Value:

    S_OK - All added fine - continue.

    E_UNEXPECTED - Some error occurred. 

--*/

{
    WsbTraceIn( L"CSakNode::GetMenuHelp", L"sCmd = <%ld>, szHelp = <0x%p>", sCmd, szHelp );

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = S_OK;
    CString string;

    try  {

        if ( string.LoadString ( sCmd ) ) {
        
            *szHelp = string.AllocSysString ( );
        
        } else {
        
            //
            // Must not be a help string - return S_FALSE
            //
        
            *szHelp = 0;
            hr = S_FALSE;
        
        }

    } catch ( CMemoryException *pException ) {
        pException->Delete();

        //
        // If out of memory, return as such
        //

        *szHelp = 0;
        hr = E_OUTOFMEMORY;

    }

    WsbTraceOut( L"CSakNode::GetMenuHelp", L"hr = <%ls>, *szHelp = <%ls>", WsbHrAsString( hr ), WsbPtrToStringAsString( szHelp ) );
    return( hr );
}

STDMETHODIMP CSakNode::SupportsProperties ( BOOL bMultiSelect )
{
    WsbTraceIn( L"CSakNode::SupportsProperties", L"" );
    HRESULT hr = S_OK;

    if( bMultiSelect ) {

        hr = m_bSupportsPropertiesMulti ? S_OK : S_FALSE;

    } else {

        hr = m_bSupportsPropertiesSingle ? S_OK : S_FALSE;

    }

    WsbTraceOut( L"CSakNode::SupportsProperties", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

STDMETHODIMP CSakNode::SupportsPropertiesNoEngine (  )
{
    WsbTraceIn( L"CSakNode::SupportsPropertiesNoEngine", L"" );
    HRESULT hr = S_OK;
    hr = m_bSupportsPropertiesNoEngine ? S_OK : S_FALSE;

    WsbTraceOut( L"CSakNode::SupportsPropertiesNoEngine", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}



STDMETHODIMP CSakNode::SupportsRefresh ( BOOL bMultiSelect )
{
    WsbTraceIn( L"CSakNode::SupportsRefresh", L"" );
    HRESULT hr = S_OK;
    if( bMultiSelect ) {

        hr = m_bSupportsRefreshMulti ? S_OK : S_FALSE;

    } else {

        hr = m_bSupportsRefreshSingle ? S_OK : S_FALSE;

    }

    WsbTraceOut( L"CSakNode::SupportsRefresh", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

STDMETHODIMP CSakNode::SupportsRefreshNoEngine (  )
{
    WsbTraceIn( L"CSakNode::SupportsRefreshNoEngine", L"" );
    HRESULT hr = S_OK;
    hr = m_bSupportsRefreshNoEngine ? S_OK : S_FALSE;

    WsbTraceOut( L"CSakNode::SupportsRefreshNoEngine", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

STDMETHODIMP CSakNode::SupportsDelete ( BOOL bMultiSelect )
{
    WsbTraceIn( L"CSakNode::SupportsDelete", L"" );
    HRESULT hr = S_OK;

    if( bMultiSelect ) {

        hr = m_bSupportsDeleteMulti ? S_OK : S_FALSE;

    } else {

        hr = m_bSupportsDeleteSingle ? S_OK : S_FALSE;

    }

    WsbTraceOut( L"CSakNode::SupportsDelete", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

STDMETHODIMP CSakNode::IsContainer (void )
{
    WsbTraceIn( L"CSakNode::IsContainer", L"" );

    HRESULT hr = m_bIsContainer ? S_OK : S_FALSE;

    WsbTraceOut( L"CSakNode::IsContainer", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

STDMETHODIMP CSakNode::HasDynamicChildren( void )
{
    WsbTraceIn( L"CSakNode::HasDynamicChildren", L"" );

    HRESULT hr = m_bHasDynamicChildren ? S_OK : S_FALSE;

    WsbTraceOut( L"CSakNode::HasDynamicChildren", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

STDMETHODIMP CSakNode::IsValid( void )
{
    WsbTraceIn( L"CSakNode::IsValid", L"" );

    HRESULT hr = S_OK;

    WsbTraceOut( L"CSakNode::IsValid", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


STDMETHODIMP CSakNode::GetNodeType ( GUID* pGuid )
{
    WsbTraceIn( L"CSakNode::GetNodeType", L"pGuid = <0x%p>", pGuid );

    HRESULT hr = S_OK;
    *pGuid = *m_rTypeGuid;

    WsbTraceOut( L"CSakNode::GetNodeType", L"hr = <%ls>, *pGuid = <%ls>", WsbHrAsString( hr ), WsbPtrToGuidAsString( pGuid ) );
    return( hr );
}

STDMETHODIMP CSakNode::AddPropertyPages( RS_NOTIFY_HANDLE /*handle*/, IUnknown* /*pUnkPropSheetCallback*/, IEnumGUID* /*pEnumObjectId*/, IEnumUnknown* /*pEnumUnkNode*/ )
{
    //
    // CSakNode does not implement prop sheets. However, some
    // derived nodes also do not implement, so we provide a default
    // not impl here
    //

    WsbTraceIn( L"CSakNode::AddPropertyPages", L"" );

    HRESULT hr = S_OK;

    WsbTraceOut( L"CSakNode::AddPropertyPages", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

STDMETHODIMP CSakNode::GetObjectId( GUID *pObjectId)
{

    HRESULT hr = S_OK;
    WsbTraceIn( L"CSakNode::GetObjectId", L"" );

    *pObjectId = m_ObjectId;

    WsbTraceOut( L"CSakNode::GetObjectId", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

STDMETHODIMP CSakNode::SetObjectId( GUID pObjectId)
{
    HRESULT hr = S_OK;
    WsbTraceIn( L"CSakNode::SetObjectId", L"" );

    m_ObjectId = pObjectId;

    WsbTraceOut( L"CSakNode::SetObjectId", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


STDMETHODIMP CSakNode::GetPrivateData( RS_PRIVATE_DATA *pData )
{
    WsbTraceIn( L"CSakNode::GetPrivateData", L"" );
    HRESULT hr = S_OK;

    try {

        WsbAffirmPointer( pData );
        *pData = m_PrivateData;

    } WsbCatch( hr );

    WsbTraceOut( L"CSakNode::GetPrivateData", L"hr = <%ls>, *pData = <%ls>", WsbHrAsString( hr ), WsbPtrToPtrAsString( (void**)pData ) );
    return( hr );
}

STDMETHODIMP CSakNode::SetPrivateData( RS_PRIVATE_DATA Data )
{
    WsbTraceIn( L"CSakNode::SetPrivateData", L"pData = <0x%p>", Data );
    HRESULT hr = S_OK;

    m_PrivateData = Data;

    WsbTraceOut( L"CSakNode::SetPrivateData", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


//---------------------------------------------------------------------------
//
//         CSakNode::ActivateView
//
//  Activate a result pane view - not supported in CSakNode.
//

STDMETHODIMP 
CSakNode::ActivateView( OLE_HANDLE )
{
    WsbTraceIn( L"CSakNode::ActivateView", L"" );

    HRESULT hr = S_FALSE;

    WsbTraceOut( L"CSakNode::ActivateView", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

STDMETHODIMP 
CSakNode::HasToolbar( ) 
{
    return ( m_cToolbarButtons > 0 ) ? S_OK : S_FALSE;
}

STDMETHODIMP
CSakNode::SetupToolbar( IToolbar *pToolbar )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CBitmap *pBmpToolbar;
    HRESULT hr = S_OK;
    MMCBUTTON mmcButton;

    if( ( m_cToolbarButtons > 0 ) && ( m_ToolbarBitmap != UNINITIALIZED ) ) {

        try {

            //
            // Add the bitmap
            //
            pBmpToolbar = new ::CBitmap;
            pBmpToolbar->LoadBitmap(m_ToolbarBitmap);
            WsbAffirmHr ( pToolbar->AddBitmap(m_cToolbarButtons, *pBmpToolbar, 16, 16, RGB(255, 0, 255)) );

            //
            // Convert the RS button format to MMCBUTTON
            //
            for( INT i = 0; i < m_cToolbarButtons; i++ ) {

                mmcButton.nBitmap   = m_ToolbarButtons[i].nBitmap; 
                mmcButton.idCommand = m_ToolbarButtons[i].idCommand;
                mmcButton.fsState   = m_ToolbarButtons[i].fsState;
                mmcButton.fsType    = m_ToolbarButtons[i].fsType;

                CString szButtonText;
                szButtonText.Format( m_ToolbarButtons[i].idButtonText );
                mmcButton.lpButtonText = szButtonText.GetBuffer(0);

                CString szTooltipText;
                szTooltipText.Format( m_ToolbarButtons[i].idTooltipText );
                mmcButton.lpTooltipText = szTooltipText.GetBuffer(0);

                WsbAffirmHr( pToolbar->AddButtons( 1, &mmcButton ) );

            }

        } WsbCatch( hr );

    } else {

        hr = S_FALSE;

    }
    return hr;
}

//------------------------------------------------------------------------------
//
//          RefreshScopePane
//
//  Refreshes the scope pane from this node down
//
//

HRESULT CSakNode::RefreshScopePane( )
{
    WsbTraceIn( L"CSakNode::RefreshScopePane", L"" );

    HRESULT hr = S_OK;
    try {

        //
        // Refresh the scope pane
        //
        WsbAffirmHr( m_pSakSnapAsk->UpdateAllViews( (ISakNode*)this ) );

    } WsbCatch( hr );

    WsbTraceOut( L"CSakNode::RefreshScopePane", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

ULONG
CSakNode::InternalAddRef(
    )
{
    WsbTraceIn( L"CSakNode::InternalAddRef", L"m_Name = <%ls>", m_szName );

    ULONG retval = CComObjectRoot::InternalAddRef( );

    WsbTraceOut( L"CSakNode::InternalAddRef", L"retval = <%lu>, type = <%ls>", retval, GetClassNameFromNodeType( *m_rTypeGuid ) );
    return( retval );
}

ULONG
CSakNode::InternalRelease(
    )
{
    WsbTraceIn( L"CSakNode::InternalRelease", L"m_Name = <%ls>", m_szName );

    ULONG retval = CComObjectRoot::InternalRelease( );

    WsbTraceOut( L"CSakNode::InternalRelease", L"retval = <%lu>, type = <%ls>", retval, GetClassNameFromNodeType( *m_rTypeGuid ) );
    return( retval );
}

int
CSakNode::AddResultImage( UINT nId )
{
    return( CSakSnap::AddImage( nId ) );
}

int
CSakNode::AddScopeImage( UINT nId )
{
    return( CSakData::AddImage( nId ) );
}

HRESULT
CSakNode::AddChild( ISakNode* pChild )
{
    HRESULT hr = S_OK;

    try {

        WsbAffirmPointer( pChild );

        WsbAffirmHr( m_Children.Add( pChild ) );

    } WsbCatch( hr );

    return( hr );
}

BSTR CSakNode::SysAlloc64BitSortKey( LONGLONG Number )
{
    BSTR retval = 0;

    CString sortKey;
    sortKey.Format( L"%16.16I64X", Number );
    retval = SysAllocString( sortKey );

    return( retval );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\basehsm.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    BaseHSM.h

Abstract:

    Implementation of CSakNode. This is the base class for any
    of the node implementations, providing common functionality.

Author:

    Rohde Wakefield [rohde]   12-Aug-1997

Revision History:

--*/

#ifndef _BASEHSM_H
#define _BASEHSM_H

#define BHSM_MAX_CHILD_PROPS      15
#define BHSM_MAX_NAME             40
#define BHSM_MAX_REG_NAME         512
#define BHSM_MAX_NODE_TYPES       10

// Toolbar buttons for all nodes
#define TB_CMD_VOLUME_SETTINGS      100
#define TB_CMD_VOLUME_TOOLS         101
#define TB_CMD_VOLUME_RULES         102

#define TB_CMD_VOLUME_LIST_SCHED    110
#define TB_CMD_VOLUME_LIST_NEW      111

#define TB_CMD_MESE_COPY            120

#define TB_CMD_CAR_COPIES           130

typedef struct  _RS_MMCButton {

    INT nBitmap;
    INT idCommand;
    BYTE fsState;
    BYTE fsType;
    UINT idButtonText;
    UINT idTooltipText;

}   RS_MMCBUTTON;

#define MAX_TOOLBAR_BUTTONS 20

// This is a dataobject-related structure that maintains basic information that needs to be passed
// from one dataobject-taking method to another.
struct INTERNAL {
    DATA_OBJECT_TYPES   m_type;     // What context is the data object.
};

//
// Declare array that can be added to or completely cleared
// Grows as needed
//
class CRsNodeArray : public CArray<ISakNode*, ISakNode*>
{
public:
    CRsNodeArray( )  { SetSize( 0, 10 ); };
    ~CRsNodeArray( ) { Clear( ); };

    ISakNode** begin( )  { return( GetData( ) ); };
    ISakNode** end( )    { return( GetData( ) + length( ) ); } ;
    INT        length( ) { return( (INT)GetUpperBound( ) + 1 ); };

    HRESULT Add( ISakNode* pNode )
    {
        HRESULT hr = S_OK;
        try {

            CWsbBstrPtr keyAdd, keyEnum;
            CComPtr<ISakNodeProp> pNodeProp, pEnumProp;
            WsbAffirmHr( RsQueryInterface( pNode, ISakNodeProp, pNodeProp ) );
            WsbAffirmHr( pNodeProp->get_DisplayName_SortKey( &keyAdd ) );
            ISakNode*pNodeEnum;
            INT index;
            for( index = 0; index < length( ); index++ ) { 
                pNodeEnum = GetAt( index );
                if( pNodeEnum ) {
                    keyEnum.Free( );
                    pEnumProp.Release( );
                    if( SUCCEEDED( RsQueryInterface( pNodeEnum, ISakNodeProp, pEnumProp ) ) ) {
                        if( SUCCEEDED( pEnumProp->get_DisplayName_SortKey( &keyEnum ) ) ) {
                            if( _wcsicmp( keyAdd, keyEnum ) <= 0 ) {
                                break;
                            }
                        }
                    }
                }
            }
            try {
                CArray<ISakNode*, ISakNode*>::InsertAt( index, pNode );
            } catch( CMemoryException* pException ) {
                pException->Delete();
                WsbThrow( E_OUTOFMEMORY );
            }
            pNode->AddRef( );
        } WsbCatch( hr );
        return( hr );
    };

    void Clear( void )
    {
        ISakNode*pNode;
        for( int index = 0; index < length( ); index++ ) {
            pNode = GetAt( index );
            SetAt( index, 0 );
            if( pNode ) pNode->Release( );
        }
        RemoveAll( );
    };

    HRESULT CopyTo( int Index, ISakNode** ppNode )
    {
        if( !ppNode ) return( E_POINTER );
        *ppNode = GetAt( Index );
        if( *ppNode )  (*ppNode)->AddRef( );
        return S_OK;
    };

};

class ATL_NO_VTABLE CSakNode :
    public CComObjectRoot,
    public ISakNode,
    public IHsmEvent,
    public CComDualImpl<ISakNodeProp, &IID_ISakNodeProp, &LIBID_HSMADMINLib>,
    public IDataObject
{
public:
    CSakNode( ) : m_rTypeGuid(&(GUID_NULL)) {}

    HRESULT FinalConstruct( void );
    void    FinalRelease( void );

    ULONG InternalAddRef( );
    ULONG InternalRelease( );

// ISakNode methods
    STDMETHOD( InitNode )                   ( ISakSnapAsk* pSakSnapAsk, IUnknown* pHsmObj, ISakNode* pParent );
    STDMETHOD( TerminateNode )              ( void );
    STDMETHOD( GetPrivateData )             ( OUT RS_PRIVATE_DATA* pData );
    STDMETHOD( SetPrivateData )             ( IN RS_PRIVATE_DATA Data );
    STDMETHOD( GetHsmObj )                  ( IUnknown** ppHsmObj );
    STDMETHOD( GetNodeType )                ( GUID *pNodeType );
    STDMETHOD( FindNodeOfType )             ( REFGUID nodetype, ISakNode** ppNode );
    STDMETHOD( GetEnumState )               ( BOOL* pState );
    STDMETHOD( SetEnumState )               ( BOOL State );
    STDMETHOD( GetScopeID )                 ( HSCOPEITEM* pid );
    STDMETHOD( SetScopeID )                 ( HSCOPEITEM id );
    STDMETHOD( GetParent )                  ( ISakNode ** ppParent );
    STDMETHOD( IsContainer )                ( void );
    STDMETHOD( CreateChildren )             ( void );
    STDMETHOD( EnumChildren )               ( IEnumUnknown ** ppEnum );
    STDMETHOD( DeleteChildren )             ( void );
    STDMETHOD( DeleteAllChildren )          ( void );
    STDMETHOD( ChildrenAreValid )           ( void );
    STDMETHOD( InvalidateChildren )         ( void );
    STDMETHOD( HasDynamicChildren )         ( void );
    STDMETHOD( EnumChildDisplayProps )      ( IEnumString ** ppEnum );
    STDMETHOD( EnumChildDisplayTitles )     ( IEnumString ** ppEnum );
    STDMETHOD( EnumChildDisplayPropWidths ) ( IEnumString ** ppEnum );
    STDMETHOD( GetMenuHelp )                ( LONG sCmd, BSTR * szHelp );
    STDMETHOD( SupportsPropertiesNoEngine ) ( void );
    STDMETHOD( SupportsProperties )         ( BOOL bMutliSelec );
    STDMETHOD( SupportsRefresh )            ( BOOL bMutliSelect );
    STDMETHOD( SupportsRefreshNoEngine )    (  );
    STDMETHOD( SupportsDelete )             ( BOOL bMutliSelec );
    STDMETHOD( AddPropertyPages )           ( RS_NOTIFY_HANDLE handle, IUnknown* pUnkPropSheetCallback, IEnumGUID *pEnumGuid, IEnumUnknown *pEnumUnkNode);
    STDMETHOD( ActivateView )               ( OLE_HANDLE );
    STDMETHOD( RefreshObject )              ( void );
    STDMETHOD( DeleteObject )               ( void );
    STDMETHOD( GetObjectId )                ( GUID *pObjectId );
    STDMETHOD( SetObjectId )                ( GUID pObjectId );
    STDMETHOD( SetupToolbar )               ( IToolbar *pToolbar );
    STDMETHOD( HasToolbar )                 ( void );
    STDMETHOD( OnToolbarButtonClick )       ( IDataObject *pDataObject, long cmdId );
    STDMETHOD( IsValid )                    ( );

// IHsmEvent methods
    STDMETHOD( OnStateChange )              ( void );


// ISakNodeProp methods
    STDMETHOD( get_DisplayName )            ( BSTR *pszName );
    STDMETHOD( put_DisplayName )            ( OLECHAR *pszName );
    STDMETHOD( get_DisplayName_SortKey )    ( BSTR *pszName );
    STDMETHOD( put_DisplayName_SortKey )    ( OLECHAR *pszName );
    STDMETHOD( get_Type )                   ( BSTR *pszType );
    STDMETHOD( put_Type )                   ( OLECHAR *pszType );
    STDMETHOD( get_Type_SortKey )           ( BSTR *pszType );
    STDMETHOD( get_Description )            ( BSTR *pszDesc );
    STDMETHOD( put_Description )            ( OLECHAR *pszDesc );
    STDMETHOD( get_Description_SortKey )    ( BSTR *pszDesc );


// IDataObject methods
public:
// Implemented
    STDMETHOD( SetData )         ( LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease );
    STDMETHOD( GetData )         ( LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium );
    STDMETHOD( GetDataHere )     ( LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium );
    STDMETHOD( EnumFormatEtc )   ( DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc );

// IDataObject methods that are Not Implemented
private:
    STDMETHOD( QueryGetData )              ( LPFORMATETC /*lpFormatetc*/ )
    { return E_NOTIMPL; };

    STDMETHOD( GetCanonicalFormatEtc )     ( LPFORMATETC /*lpFormatetcIn*/, LPFORMATETC /*lpFormatetcOut*/ )
    { return E_NOTIMPL; };

    STDMETHOD( DAdvise )                   ( LPFORMATETC /*lpFormatetc*/, DWORD /*advf*/, LPADVISESINK /*pAdvSink*/, LPDWORD /*pdwConnection*/ )
    { return E_NOTIMPL; };

    STDMETHOD( DUnadvise )                 ( DWORD /*dwConnection*/ )
    { return E_NOTIMPL; };

    STDMETHOD( EnumDAdvise )               ( LPENUMSTATDATA* /*ppEnumAdvise*/ )
    { return E_NOTIMPL; };

// Implementation
public:
    CRsNodeArray m_Children;                                // Child nodes
    BOOL        m_bEnumState;                               // TRUE if children have been enumerated
    HSCOPEITEM  m_scopeID;                                  // MMC scope item id.
    BOOL        m_bChildrenAreValid;                        // TRUE if list of children is up-to-date
    CWsbBstrPtr m_szName;                                   // name of node
    CWsbBstrPtr m_szName_SortKey;                           // name of node
    CWsbBstrPtr m_szType;                                   // type of node
    CWsbBstrPtr m_szDesc;                                   // description of node
    BSTR        m_rgszChildPropIds[BHSM_MAX_CHILD_PROPS];   // array of child node property Ids
    BSTR        m_rgszChildPropTitles[BHSM_MAX_CHILD_PROPS];// array of child node title properties
    BSTR        m_rgszChildPropWidths[BHSM_MAX_CHILD_PROPS];// array of child node width properties
    INT         m_cChildProps;                              // number of child node properties
    INT         m_cChildPropsShow;                          // number of child node properties to show
    CComPtr<ISakNode>    m_pParent;
    CComPtr<ISakSnapAsk> m_pSakSnapAsk;                     // pointer to the saksnap "ask" interface
    CComPtr<IUnknown>    m_pHsmObj;                            // pointer to the underlying HSM COM object this node encapsulates
    const GUID* m_rTypeGuid;                                // pointer to the type guid for this node type
    BOOL        m_bSupportsPropertiesNoEngine;              // TRUE if this node has property pages.
    BOOL        m_bSupportsPropertiesSingle;                // TRUE if this node has property pages.
    BOOL        m_bSupportsPropertiesMulti;                 // TRUE if this node has property pages.
    BOOL        m_bSupportsRefreshSingle;                   // TRUE if this node supports the refresh method.
    BOOL        m_bSupportsRefreshMulti;                    // TRUE if this node supports the refresh method.
    BOOL        m_bSupportsRefreshNoEngine;                 // TRUE if this node supports the refresh method.
    BOOL        m_bSupportsDeleteSingle;                    // TRUE if this node supports the delete method.
    BOOL        m_bSupportsDeleteMulti;                     // TRUE if this node supports the delete method.
    BOOL        m_bIsContainer;                             // TRUE if this node is a container type (as opposed to leaf).
    BOOL        m_bHasDynamicChildren;                      // TRUE if this nodes immediate children change

protected:
    GUID                m_ObjectId;
    RS_PRIVATE_DATA     m_PrivateData;
    INT                 m_ToolbarBitmap;
    INT                 m_cToolbarButtons;
    RS_MMCBUTTON        m_ToolbarButtons[MAX_TOOLBAR_BUTTONS];

// Clipboard formats that are required by the console
public:
    static UINT    m_cfNodeType;
    static UINT    m_cfNodeTypeString;
    static UINT    m_cfDisplayName;
    static UINT    m_cfInternal;
    static UINT    m_cfClassId;
    static UINT    m_cfComputerName;
    static UINT    m_cfEventLogViews;

private:

    // Generic "GetData" which will allocate if told to
    HRESULT GetDataGeneric( LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium, BOOL DoAlloc );

    // methods to retrieve particular "flavors" of data from a dataobject
    HRESULT RetrieveNodeTypeData( LPSTGMEDIUM lpMedium );
    HRESULT RetrieveNodeTypeStringData( LPSTGMEDIUM lpMedium );
    HRESULT RetrieveDisplayName( LPSTGMEDIUM lpMedium );
    HRESULT RetrieveInternal( LPSTGMEDIUM lpMedium );
    HRESULT RetrieveClsid( LPSTGMEDIUM lpMedium );
    HRESULT RetrieveComputerName( LPSTGMEDIUM lpMedium );
    HRESULT RetrieveEventLogViews( LPSTGMEDIUM lpMedium );

    // methods to store particular "flavors" of data from a dataobject
    HRESULT StoreInternal( LPSTGMEDIUM lpMedium );

    // helper method utilized by each of the above
    HRESULT Retrieve(const void* pBuffer, DWORD len, LPSTGMEDIUM lpMedium);
    HRESULT Store(void* pBuffer, DWORD len, LPSTGMEDIUM lpMedium);

    // actual data store in this dataobject.
    INTERNAL m_internal;

    // Maintain a connection point
    CComPtr<IUnknown> m_pUnkConnection;
    DWORD             m_Advise;


protected:
    void SetConnection( IUnknown *pUnkConnection );
    virtual HRESULT RefreshScopePane( );

    // Registry Helper Functions for derived classes. Not a part of any interface.
    static HRESULT LoadRegString( HKEY hKey, OLECHAR * szValName, OLECHAR * sz, OLECHAR * szDefault );
    static HRESULT LoadRegDWord( HKEY hKey, OLECHAR * szValName, DWORD * pdw, DWORD dwDefault );

    // Helper functions for derived classes to set result pane properties from resource strings
    HRESULT FreeChildProps();
    HRESULT SetChildProps (const TCHAR* ResIdPropsIds, LONG resIdPropsTitles, LONG resIdPropsWidths);

    // Helper Functions to create our children.
    static HRESULT NewChild( REFGUID nodetype, IUnknown** ppUnkChild );
    HRESULT InternalDelete( BOOL Recurse );
    HRESULT AddChild( ISakNode* pChild );

    // General Helper functions - not part of any interface.
    static HRESULT LoadContextMenu( UINT nId, HMENU *phMenu );
    static HRESULT GetCLSIDFromNodeType( REFGUID nodetype, const CLSID ** ppclsid );
    static const OLECHAR * CSakNode::GetClassNameFromNodeType( REFGUID Nodetype );
    static int AddScopeImage( UINT nId );
    static int AddResultImage( UINT nId );
    static BSTR SysAlloc64BitSortKey( LONGLONG Number );
};

    // macro for multiple-inheritance (CSakNode and a ISakNode derived interface)
    // Forwards all CSakNode implemented members to CSakNode explicitly
#define FORWARD_BASEHSM_IMPLS \
    STDMETHOD( get_DisplayName )            ( BSTR *pszName )                                { return CSakNode::get_DisplayName( pszName );           } \
    STDMETHOD( put_DisplayName )            ( OLECHAR *pszName )                             { return CSakNode::put_DisplayName( pszName );           } \
    STDMETHOD( get_DisplayName_SortKey )    ( BSTR *pszName )                                { return CSakNode::get_DisplayName_SortKey( pszName );   } \
    STDMETHOD( put_DisplayName_SortKey )    ( OLECHAR *pszName )                             { return CSakNode::put_DisplayName_SortKey( pszName );           } \
    STDMETHOD( get_Type )                   ( BSTR *pszType )                                { return CSakNode::get_Type( pszType );                  } \
    STDMETHOD( put_Type )                   ( OLECHAR *pszType )                             { return CSakNode::put_Type( pszType );                  } \
    STDMETHOD( get_Type_SortKey )           ( BSTR *pszType )                                { return CSakNode::get_Type_SortKey( pszType );          } \
    STDMETHOD( get_Description )            ( BSTR *pszDesc )                                { return CSakNode::get_Description( pszDesc );           } \
    STDMETHOD( put_Description )            ( OLECHAR *pszDesc )                             { return CSakNode::put_Description( pszDesc );           } \
    STDMETHOD( get_Description_SortKey )    ( BSTR *pszDesc )                                { return CSakNode::get_Description_SortKey( pszDesc );   } \

// Typedef of class that implements IEnumUnknown
typedef CComObject<CComEnum<IEnumUnknown, &IID_IEnumUnknown, IUnknown *,
        _CopyInterface<IUnknown> > > CEnumUnknown;

// Typedef of class that implements IEnumVARIANT
typedef CComObject<CComEnum<IEnumVARIANT, &IID_IEnumVARIANT, VARIANT,
        _Copy<VARIANT> > > CEnumVariant;

// Typedef of class that implements IEnumString
typedef CComObject<CComEnum<IEnumString, &IID_IEnumString, LPOLESTR,
        _Copy<LPOLESTR> > > CEnumString;

// Typedef of class that implements IEnumGUID
typedef CComObject<CComEnum<IEnumGUID, &IID_IEnumGUID, GUID,
        _Copy<GUID> > > CEnumGUID;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\cpropsht.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    CPropSht.h

Abstract:

    Implementation of Property-Sheet-Like container object
    for property sheet pages.

Author:

    Art Bragg 10/8/97

Revision History:

--*/

#ifndef _CSAKPROPSHT_H
#define _CSAKPROPSHT_H

class CSakPropertyPage;

class CSakPropertySheet
{
public:
    CSakPropertySheet() :
        m_pEnumObjectIdStream( 0 ),
        m_pHsmObjStream( 0 ),
        m_pSakSnapAskStream( 0 ),
        m_pSakNode( 0 ),
        m_Handle( 0 ),
        m_nPageCount( 0 )
        { };
    HRESULT InitSheet(
            RS_NOTIFY_HANDLE Handle,
            IUnknown*        pUnkPropSheetCallback,
            CSakNode*        pSakNode,
            ISakSnapAsk*     pSakSnapAsk,
            IEnumGUID*       pEnumObjectId,
            IEnumUnknown*    pEnumUnkNode );

    HRESULT SetNode( CSakNode* pSakNode );

    ~CSakPropertySheet();
    virtual void AddPageRef();
    virtual void ReleasePageRef();

protected:
    LPSTREAM m_pEnumObjectIdStream;
    LPSTREAM m_pHsmObjStream;
    LPSTREAM m_pSakSnapAskStream;

public:
    HRESULT AddPropertyPages( );
    HRESULT IsMultiSelect( );
    HRESULT GetSakSnapAsk( ISakSnapAsk **ppAsk );
    HRESULT GetHsmObj( IUnknown **ppHsmObj );
    HRESULT GetHsmServer( IHsmServer **ppHsmServer );
    HRESULT GetFsaServer( IFsaServer **ppHsmServer );
    HRESULT GetFsaFilter( IFsaFilter **ppFsaFilter );
    HRESULT GetRmsServer( IRmsServer **ppHsmServer );
    HRESULT GetNextObjectId( INT *pBookMark, GUID *pObjectId );
    HRESULT GetNextNode( INT *pBookMark, ISakNode **ppNode );
    HRESULT OnPropertyChange( RS_NOTIFY_HANDLE notifyHandle, ISakNode* pNode = 0 );

    HRESULT AddPage( CSakPropertyPage* pPage );


public:
    CSakNode    *m_pSakNode;

protected:
    RS_NOTIFY_HANDLE     m_Handle;
    CComPtr<IPropertySheetCallback> m_pPropSheetCallback;
    CComPtr<ISakSnapAsk> m_pSakSnapAsk;
    CComPtr<IUnknown>    m_pHsmObj;
    BOOL                 m_bMultiSelect;
    INT                  m_nPageCount;

    CArray<GUID, GUID&>  m_ObjectIdList;
    CRsNodeArray         m_UnkNodeList;
};

class CSakPropertyPage : public CRsPropertyPage
{
public:
    CSakPropertyPage( UINT nIDTemplate, UINT nIDCaption = 0 );

public:
    HRESULT SetMMCCallBack( );

    CSakPropertySheet * m_pParent;
    RS_NOTIFY_HANDLE    m_hConsoleHandle; // Handle given to the snap-in by the console

// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CSakWizardPage)
    public:
    //}}AFX_VIRTUAL

protected:
    virtual void OnPageRelease( );

};

class CSakVolPropPage;

class CSakVolPropSheet:public CSakPropertySheet
{
public:
    CSakVolPropSheet() { };
    ~CSakVolPropSheet() { };

public:
    virtual HRESULT GetNextFsaResource( INT *pBookMark, IFsaResource ** ppFsaResource ) = 0;
    HRESULT GetFsaResource( IFsaResource ** ppFsaResource );
    
    HRESULT AddPage( CSakVolPropPage* pPage );
};

class CSakVolPropPage : public CSakPropertyPage
{
public:
    CSakVolPropPage( UINT nIDTemplate, UINT nIDCaption = 0 );

public:
    CSakVolPropSheet * m_pVolParent;

// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CSakWizardPage)
    public:
    //}}AFX_VIRTUAL

};

class CSakWizardPage;

class CSakWizardSheet : 
    public CSakPropertySheet,
    public CComObjectRoot,
    public IDataObject,
    public ISakWizard
{

public:
    CSakWizardSheet( );
    virtual void AddPageRef();
    virtual void ReleasePageRef();

BEGIN_COM_MAP(CSakWizardSheet)
    COM_INTERFACE_ENTRY(IDataObject)
    COM_INTERFACE_ENTRY(ISakWizard)
END_COM_MAP()


public:
    //
    // IDataObject
    STDMETHOD( SetData )                    ( LPFORMATETC /*lpFormatetc*/, LPSTGMEDIUM /*lpMedium*/, BOOL /*bRelease*/ )
    { return( DV_E_CLIPFORMAT ); };
    STDMETHOD( GetData )                    ( LPFORMATETC /*lpFormatetc*/, LPSTGMEDIUM /*lpMedium*/ )
    { return( DV_E_CLIPFORMAT ); };
    STDMETHOD( GetDataHere )                ( LPFORMATETC /*lpFormatetc*/, LPSTGMEDIUM /*lpMedium*/ )
    { return( DV_E_CLIPFORMAT ); };
    STDMETHOD( EnumFormatEtc )              ( DWORD /*dwDirection*/, LPENUMFORMATETC* /*ppEnumFormatEtc*/ )
    { return( E_NOTIMPL ); };               
    STDMETHOD( QueryGetData )               ( LPFORMATETC /*lpFormatetc*/ ) 
    { return( E_NOTIMPL ); };               
    STDMETHOD( GetCanonicalFormatEtc )      ( LPFORMATETC /*lpFormatetcIn*/, LPFORMATETC /*lpFormatetcOut*/ )
    { return( E_NOTIMPL ); };               
    STDMETHOD( DAdvise )                    ( LPFORMATETC /*lpFormatetc*/, DWORD /*advf*/, LPADVISESINK /*pAdvSink*/, LPDWORD /*pdwConnection*/ )
    { return( E_NOTIMPL ); };               
    STDMETHOD( DUnadvise )                  ( DWORD /*dwConnection*/ )
    { return( E_NOTIMPL ); };               
    STDMETHOD( EnumDAdvise )                ( LPENUMSTATDATA* /*ppEnumAdvise*/ )
    { return( E_NOTIMPL ); };

  
    //
    // ISakWizard
    //
  //STDMETHOD( AddWizardPages ) ( IN RS_PCREATE_HANDLE Handle, IN IUnknown* pPropSheetCallback, IN ISakSnapAsk* pSakSnapAsk );
    STDMETHOD( GetWatermarks )  ( OUT HBITMAP* lphWatermark, OUT HBITMAP* lphHeader, OUT HPALETTE* lphPalette,  OUT BOOL* bStretch );
    STDMETHOD( GetTitle )       ( OUT OLECHAR** pTitle );

public:
    //
    // Used by pages
    //
    void SetWizardButtons( DWORD Flags );
    BOOL PressButton( INT Button );
    virtual HRESULT OnFinish( ) { m_HrFinish = S_OK; return( m_HrFinish ); };
    virtual HRESULT OnCancel( ) { return( m_HrFinish ); };

    //
    // Used to check finish status of wizard
    //
    HRESULT         m_HrFinish;

protected:
    HRESULT AddPage( CSakWizardPage* pPage );

    UINT            m_TitleId;
    CString         m_Title;
    INT             m_HeaderId,
                    m_WatermarkId;
    CBitmap         m_Header,
                    m_Watermark;
    CSakWizardPage* m_pFirstPage;

private:
    HRESULT AddPage( CSakPropertyPage* ) { return( E_NOTIMPL ); }


};

class CSakWizardPage : public CRsWizardPage
{
public:
    CSakWizardPage( UINT nIDTemplate, BOOL bExterior = FALSE, UINT nIdTitle = 0, UINT nIdSubtitle = 0 );

public:
    CSakWizardSheet * m_pSheet;
    HRESULT SetMMCCallBack( );

// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CSakWizardPage)
    public:
    virtual BOOL OnWizardFinish();
    virtual void OnCancel();
    //}}AFX_VIRTUAL

protected:
    virtual void OnPageRelease( );
};

#define CSakWizardPage_InitBaseInt( DlgId )  CSakWizardPage( IDD_##DlgId, FALSE, IDS_##DlgId##_TITLE, IDS_##DlgId##_SUBTITLE )
#define CSakWizardPage_InitBaseExt( DlgId )  CSakWizardPage( IDD_##DlgId, TRUE )


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\choohsm.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    ChooHsm.cpp

Abstract:

    Initial property page Wizard implementation. Allows the setting
    of who the snapin will manage.

Author:

    Rohde Wakefield [rohde]   12-Aug-1997

Revision History:

--*/

class CChooseHsmDlg : public CPropertyPage
{
// Construction
public:
    CChooseHsmDlg(CWnd* pParent = NULL);   // standard constructor
    virtual ~CChooseHsmDlg();

// Property page Data
    //{{AFX_DATA(CChooseHsmDlg)
    enum { IDD = IDD_CHOOSE_HSM_2 };
    CButton m_ManageLocal;
    CButton m_ManageRemote;
    CString m_ManageName;
    //}}AFX_DATA

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CChooseHsmDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Operations 
#define CHOOSE_STATE      ULONG
#define CHOOSE_LOCAL      0x1
#define CHOOSE_REMOTE     0x2

    void SetButtons( CHOOSE_STATE );

    // Implementation
public:
    RS_NOTIFY_HANDLE m_hConsoleHandle;     // Handle given to the snap-in by the console
    CString *        m_pHsmName;           // pointer to CSakData's HSM server string.
    BOOL *           m_pManageLocal;       // pointer to CSakData's m_ManageLocal bool.

    BOOL             m_RunningRss;         // 
    BOOL             m_AllowSetup;
    BOOL             m_SkipAccountSetup;

protected:

    // Generated message map functions
    //{{AFX_MSG(CChooseHsmDlg)
    virtual BOOL OnInitDialog();
    virtual BOOL OnWizardFinish();
    afx_msg void OnManageLocal();
    afx_msg void OnManageRemote();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};
/////////////////////////////////////////////////////////////////////////////
// CChooseHsmQuickDlg dialog

class CChooseHsmQuickDlg : public CDialog
{
// Construction
public:
    CChooseHsmQuickDlg(CWnd* pParent = NULL);   // standard constructor

    CString *       m_pHsmName;           // pointer to CSakData's HSM server string.

// Dialog Data
    //{{AFX_DATA(CChooseHsmQuickDlg)
    enum { IDD = IDD_CHOOSE_HSM };
        // NOTE: the ClassWizard will add data members here
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CChooseHsmQuickDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CChooseHsmQuickDlg)
    virtual BOOL OnInitDialog();
    virtual void OnOK();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\hsm\gui\hsmadmin\csakdata.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    CSakData.cpp

Abstract:

    This component implements the IComponentData interface for
    the snapin. Primarily it is responsible for handling the
    scope view panes.

Author:

    Rohde Wakefield [rohde]   04-Mar-1997

Revision History:

--*/

#include "stdafx.h"
#include "HsmConn.h"
#include "CSakSnap.h"
#include "CSakData.h"
#include "ChooHsm.h"
#include "WzQstart.h"


UINT CSakData::m_cfDisplayName    = RegisterClipboardFormat(CCF_DISPLAY_NAME); 
UINT CSakData::m_cfNodeType       = RegisterClipboardFormat(CCF_NODETYPE);
UINT CSakData::m_cfNodeTypeString = RegisterClipboardFormat(CCF_SZNODETYPE);  
UINT CSakData::m_cfClassId        = RegisterClipboardFormat(CCF_SNAPIN_CLASSID);  
UINT CSakData::m_cfObjectTypes    = RegisterClipboardFormat(CCF_OBJECT_TYPES_IN_MULTI_SELECT);  
UINT CSakData::m_cfMultiSelect    = RegisterClipboardFormat(CCF_MULTI_SELECT_SNAPINS);  

UINT CSakData::m_nImageArray[RS_SCOPE_IMAGE_ARRAY_MAX];
INT  CSakData::m_nImageCount = 0;


///////////////////////////////////////////////////////////////////////
// CSakData
//
// CSakData plays several roles in the snapin:
//
//   1) Provides the single entry into the HSM Admin Snapin by
//      implementing IComponentData
//
//   2) Provides the "Interface" for scopeview activities within MMC
//
//   3) Owns the node tree / objects
//
//   4) Provides a layer between MMC and the node objects
//
//   5) Act as its own data object for MMC's node manager,
//
//   6) Manages our portion of the MMC image lists.
//
///////////////////////////////////////////////////////////////////////


const CString CSakData::CParamParse::m_DsFlag = TEXT( "ds:" );

void CSakData::CParamParse::ParseParam( LPCTSTR lpszParam, BOOL bFlag, BOOL /* bLast */ )
{
    CString cmdLine = lpszParam;

    WsbTraceIn( L"CSakData::CParamParse::ParseParam", L"cmdLine = \"%ls\"\n", (LPCTSTR)cmdLine );

    if( bFlag ) {

        //  This is the "correct" code, but currently we don't get the DsFlag parameter
        //  passed on the command line via Directory Services
        if( cmdLine.Left( m_DsFlag.GetLength( ) ) == m_DsFlag ) {
        
            CString dsToken;
            CWsbStringPtr computerName;
            dsToken = cmdLine.Mid( m_DsFlag.GetLength( ) );

            if( SUCCEEDED( HsmGetComputerNameFromADsPath( dsToken, &computerName ) ) ) {

                m_HsmName               = computerName;
                m_ManageLocal           = FALSE;
                m_PersistManageLocal    = FALSE;
                m_SetHsmName            = TRUE;
                m_SetManageLocal        = TRUE;
                m_SetPersistManageLocal = TRUE;

            }
        }
    } else {

        //  This code is our stopgap measure until Directory Services starts
        //  working the way it should
        if( cmdLine.Left( 5 ) == TEXT("LDAP:") ) {
        
            CWsbStringPtr computerName;

            if( SUCCEEDED( HsmGetComputerNameFromADsPath( cmdLine, &computerName ) ) ) {

                WsbTrace(L"CSakData::CParamParse::ParseParam: computerName = \"%ls\"\n", (OLECHAR*)computerName);
                m_HsmName               = computerName;
                m_ManageLocal           = FALSE;
                m_PersistManageLocal    = FALSE;
                m_SetHsmName            = TRUE;
                m_SetManageLocal        = TRUE;
                m_SetPersistManageLocal = TRUE;

            }
        }
    }

    WsbTraceOut( L"CSakData::CParamParse::ParseParam", L"" );
}

HRESULT
CSakData::FinalConstruct(
    void
    )
/*++

Routine Description:

    Called during initial CSakData construction to initialize members.

Arguments:

    none.

Return Value:

    S_OK            - Initialized correctly.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    WsbTraceIn( L"CSakData::FinalConstruct", L"" );

    HRESULT hr = S_OK;

    AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );

    try {

        //
        // Init values
        //
        m_ManageLocal         = FALSE;
        m_PersistManageLocal  = TRUE;
        m_IsDirty             = TRUE;
        m_State               = FALSE;
        m_FirstTime           = TRUE;
        m_Disabled            = FALSE;
        m_RootNodeInitialized = FALSE;
        m_HrRmsConnect        = S_FALSE;
        
        //
        // Create the hidden window so we can post messages back to self
        //
        m_pWnd = new CSakDataWnd;
        WsbAffirmPointer( m_pWnd );
        WsbAffirmStatus( m_pWnd->Create( this ) );
        
        //
        // Finally do low level ATL construct
        //
        WsbAffirmHr( CComObjectRoot::FinalConstruct( ) );

    } WsbCatch( hr );

    WsbTraceOut( L"CSakData::FinalConstruct", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}



void
CSakData::FinalRelease(
    void
    )
/*++

Routine Description:

    Called on final release in order to clean up all members.

Arguments:

    none.

Return Value:

    none.

--*/
{
    WsbTraceIn( L"CSakData::FinalRelease", L"" );
    AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );

    HRESULT hr = S_OK;
    try {

        if( m_pWnd ) {

            m_pWnd->DestroyWindow( );
            m_pWnd = 0;

        }
    
    } WsbCatch( hr );


    WsbTraceOut( L"CSakData::FinalRelease", L"" );
}


///////////////////////////////////////////////////////////////////////
//                 IComponentData                                    //
///////////////////////////////////////////////////////////////////////


STDMETHODIMP 
CSakData::Initialize(
    IN  IUnknown * pUnk
    )
/*++

Routine Description:

    Called when the user first adds a snapin.

Arguments:

    pUnk            - Base IUnknown of console

Return Value:

    S_OK            - Correctly initialized.

    E_xxxxxxxxxxx   - Unable to initialize.

--*/
{
    WsbTraceIn( L"CSakData::Initialize", L"pUnk = <0x%p>", pUnk );
    AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );

    HRESULT hr = S_OK;
    try {
        //
        // validity check on parameters
        //

        WsbAffirmPointer( pUnk );

        //
        // QI and Save interfaces
        //
        WsbAffirmHr( RsQueryInterface( pUnk, IConsole,          m_pConsole ) );
        WsbAffirmHr( RsQueryInterface( pUnk, IConsoleNameSpace, m_pNameSpace ) );

        //
        // Get the scope image list only and store it in the snapin.
        // It is AddRef'ed by the console
        //

        WsbAffirmHr( m_pConsole->QueryScopeImageList( &m_pImageScope ) );

        // Create the root node (make sure not already set)

        WsbAffirmPointer( !m_pRootNode );
        WsbAffirmHr( m_pRootNode.CoCreateInstance( CLSID_CUiHsmCom ) );


        //
        // If the Hsm name has not been set (by choose Hsm), 
        // do not initialize the node here.  Allow
        // IPersistStream::Load to initialize it, or to be grabbed
        // from the extension's parent
        //

        if( m_ManageLocal || ( m_HsmName != "" ) ) {

            //
            // Make sure no changes from command line
            //
            InitFromCommandLine( );

            //
            // Set the Hsm name in sakData and HsmCom objectds
            //
            WsbAffirmHr( InitializeRootNode( ) );

        }

        WsbAffirmHr( OnAddImages() );
    } WsbCatch( hr);

    WsbTraceOut( L"CSakData::Initialize", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


STDMETHODIMP
CSakData::Notify(
    IN  IDataObject*    pDataObject,
    IN  MMC_NOTIFY_TYPE event,
    IN  LPARAM            arg,
    IN  LPARAM            param
    )
/*++

Routine Description:

    Handle user clicks on nodes in the treeview, along with other
    MMC notices.

Arguments:

    pDataObject     - Data Object for which event occured

    event           - The event type

    arg, param      - Info for event (depend on type)

Return Value:

    S_OK            - Notification handled without error.

    E_xxxxxxxxxxx   - Unable to register server.

--*/
{
    WsbTraceIn( L"CSakData::Notify", L"pDataObject = <0x%p>, event = <%ls>, arg = <%ld><0x%p>, param = <%ld><0x%p>", pDataObject, RsNotifyEventAsString( event ), arg, arg, param, param );
    HRESULT hr = S_OK;

    try {

        switch( event ) {

        //
        // This node was selected or deselected in the scope pane (the user clicked
        // on the expansion/contraction button)
        //
        case MMCN_EXPAND:
            WsbAffirmHr( OnFolder(pDataObject, arg, param) );
            break;
        
        //
        // This node was expanded or contracted in the scope pane (the user 
        // clicked on the actual node
        //
        case MMCN_SHOW:
            WsbAffirmHr( OnShow( pDataObject, arg, param ) );
            break;
        
        // Not implemented
        case MMCN_SELECT:
            WsbAffirmHr( OnSelect( pDataObject, arg, param ) );
            break;
        
        // Not implemented
        case MMCN_MINIMIZED:
            WsbAffirmHr( OnMinimize( pDataObject, arg, param ) );
            break;
        
        case MMCN_ADD_IMAGES:
            WsbAffirmHr( OnAddImages() );
            break;

        case MMCN_PROPERTY_CHANGE:
            {
                CComPtr<ISakNode> pNode;
                WsbAffirmHr( GetBaseHsmFromCookie( (MMC_COOKIE) param, &pNode ) );
                WsbAffirmHr( UpdateAllViews( pNode ) );
            }
            break;

        case MMCN_CONTEXTHELP:
            WsbAffirmHr( OnContextHelp( pDataObject, arg, param ) );
            break;

        case MMCN_REMOVE_CHILDREN:
            WsbAffirmHr( OnRemoveChildren( pDataObject ) );
            break;

        // Note - Future expansion of notify types possible
        default:
            break;

        }

    } WsbCatch( hr );

    WsbTraceOut( L"CSakData::Notify", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


STDMETHODIMP
CSakData::Destroy(
    void
    )
/*++

Routine Description:

    Called to force the release of any owned objects and
    to clear all views.

Arguments:

    none.

Return Value:

    S_OK            - Correctly tore down.

    E_xxxxxxxxxxx   - Failure occurred (not meaningful).

--*/
{
    WsbTraceIn( L"CSakData::Destroy", L"" );
    HRESULT hr = S_OK;

    try {

        // Release the interfaces that we QI'ed
        if( m_pConsole != NULL ) {

            //
            // Tell the console to release the header control interface
            //

            m_pNameSpace.Release();
            m_pImageScope.Release();

            //
            // Release the IConsole interface last
            //
            m_pConsole.Release();


        }

        // Recursive delete list of UI nodes, including the root node.
        if( m_pRootNode ) {

            m_pRootNode->DeleteAllChildren( );
            m_pRootNode->TerminateNode( );
            m_pRootNode.Release( );

        }

        m_pHsmServer.Release( );
        m_pFsaServer.Release( );
        m_pRmsServer.Release( );

    } WsbCatch( hr );

    WsbTraceOut( L"CSakData::Destroy", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


STDMETHODIMP
CSakData::QueryDataObject(
    IN  MMC_COOKIE              cookie,
    IN  DATA_OBJECT_TYPES type, 
    OUT IDataObject**     ppDataObject
    )
/*++

Routine Description:

    Called by the console when it needs data for a particular node.
    Since each node is a data object, its IDataObject interface is
    simply returned. The console will later pass in this dataobject to 
    SakSnap help it establish the context under which it is being called.

Arguments:

    cookie          - Node which is being queried.

    type            - The context under which a dataobject is being requested.

    ppDataObject    - returned data object.

Return Value:

    S_OK            - Data Object found and returned.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    WsbTraceIn( L"CSakData::QueryDataObject", L"cookie = <0x%p>, type = <%d>, ppDataObject = <0x%p>", cookie, type, ppDataObject );
    HRESULT hr = S_OK;
    try {

        //
        // We return ourself if needing a root for the node manager
        //

        if( ( ( 0 == cookie ) || ( EXTENSION_RS_FOLDER_PARAM == cookie ) ) && ( CCT_SNAPIN_MANAGER == type ) ) {

            WsbAffirmHr( _InternalQueryInterface( IID_IDataObject, (void**)ppDataObject ) );

        } else {

            WsbAffirmHr( GetDataObjectFromCookie ( cookie, ppDataObject ) );
            WsbAffirmHr( SetContextType( *ppDataObject, type ) );

        }

    } WsbCatch ( hr )

    WsbTraceOut( L"CSakData::QueryDataObject", L"hr = <%ls>, *ppDataObject = <%ls>", WsbHrAsString( hr ), WsbPtrToPtrAsString( (void**)ppDataObject ) );
    return ( hr );
}


STDMETHODIMP
CSakData::CompareObjects(
    IN  IDataObject* pDataObjectA,
    IN  IDataObject* pDataObjectB
    )
/*++

Routine Description:

    Compare data objects for MMC

Arguments:

    pDataObjectA,     - Data object refering to node.
    pDataObjectB

Return Value:

    S_OK            - Objects represent the same node.

    S_FALSE         - Objects do not represent the same node.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    WsbTraceIn( L"CSakData::CompareObjects", L"pDataObjectA = <0x%p>, pDataObjectB = <0x%p>", pDataObjectA, pDataObjectB );

    HRESULT hr = S_OK;
    try {

        WsbAssertPointer ( pDataObjectA );
        WsbAssertPointer ( pDataObjectB );

        //
        // Since only one dataobject exists for any given node,
        // the QI's for IUnknown should match. (object identity)
        //

        CComPtr<IUnknown> pUnkA, pUnkB;
        WsbAssertHr( RsQueryInterface( pDataObjectA, IUnknown, pUnkA ) );
        WsbAssertHr( RsQueryInterface( pDataObjectB, IUnknown, pUnkB ) );

        if ( (IUnknown*)pUnkA != (IUnknown*)pUnkB ) {

            hr = S_FALSE;

        }

    } WsbCatch( hr );

    WsbTraceOut( L"CSakData::CompareObjects", L"hr = <%ls>", WsbHrAsString( hr ) );
    return ( hr );
}


STDMETHODIMP
CSakData::CreateComponent(
    OUT  IComponent** ppComponent
    )
/*++

Routine Description:

    Creates a new Component object for MMC - our
    CSakSnap object.

Arguments:

    ppComponent     - Return value of the Component.

Return Value:

    S_OK            - Created successfully.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    WsbTraceIn( L"CSakData::CreateComponent", L"ppComponent = <0x%p>", ppComponent );
    HRESULT hr = S_OK;

    try {

        WsbAffirmPointer( ppComponent );

        //
        // Create the Snapin Component as C++ object so we can init.
        //

        CSakSnap * pSnapin = new CComObject<CSakSnap>;

        WsbAffirmPointer( pSnapin );

        //
        // Following code is based on ATL's CreateInstance
        //

        pSnapin->SetVoid( NULL );
        pSnapin->InternalFinalConstructAddRef();
        HRESULT hRes = pSnapin->FinalConstruct();
        pSnapin->InternalFinalConstructRelease();

        if( FAILED( hRes ) ) {

            delete pSnapin;
            pSnapin = NULL;
            WsbThrow( hRes );

        }

        //
        // And QI for right interface
        //

        WsbAffirmHr ( pSnapin->_InternalQueryInterface( IID_IComponent, (void**)ppComponent ) );

        //
        // Initialize internal pointer to CSakData
        //

        pSnapin->m_pSakData = this;

    } WsbCatch( hr );

    WsbTraceOut( L"CSakData::CreateComponent", L"hr = <%ls>, *ppComponent = <%ls>", WsbHrAsString( hr ), WsbPtrToPtrAsString( (void**)ppComponent ) );
    return( hr );
}


STDMETHODIMP
CSakData::GetDisplayInfo(
    IN OUT SCOPEDATAITEM* pScopeItem
    )
/*++

Routine Description:

    When MMC is told to call back concerning scope items,
    we receive a call here to fill in missing information.

    Currently we do not use this capability.

Arguments:

    pScopeItem      - SCOPEDATAITEM structure representing state of the node
                      in the scope treeview.

Return Value:

    S_OK            - Struct filled in.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    static CWsbStringPtr tmpString;

    WsbTraceIn( L"CSakData::GetDisplayInfo", L"cookie = <0x%p>, pScopeItem->mask = <0x%p>", pScopeItem->lParam, pScopeItem->mask );

    HRESULT hr = S_OK;
    try {

        CComPtr<ISakNode> pNode;
        CComPtr<ISakNodeProp> pNodeProp;
        WsbAffirmHr( GetBaseHsmFromCookie( pScopeItem->lParam, &pNode ) );

        WsbAffirmHr( pNode.QueryInterface( &pNodeProp ) );

        if( pScopeItem->mask & SDI_IMAGE ) {

            WsbAffirmHr( pNode->GetScopeOpenIcon( m_State, &pScopeItem->nImage ) );

        }

        if( SDI_STR & pScopeItem->mask ) {

            //
            // Go to the node and get the display name.
            // Following the example of the snapin framework, we
            // copy the name into a static string pointer and
            // return a pointer to this.
            //

            CWsbBstrPtr bstr;

            WsbAffirmHr( pNodeProp->get_DisplayName( &bstr ) );

            tmpString = bstr;
            pScopeItem->displayname = tmpString;
        }
    } WsbCatch( hr );

    WsbTraceOut( L"CSakData::GetDisplayInfo", L"hr = <%ls>, pScopeItem->displayname = <%ls>", WsbHrAsString( hr ), (SDI_STR & pScopeItem->mask) ? pScopeItem->displayname : L"N/A" );
    return( hr );
}

///////////////////////////////////////////////////////////////////////
//                 IExtendPropertySheet                              //
///////////////////////////////////////////////////////////////////////


STDMETHODIMP
CSakData::CreatePropertyPages(
    IN  IPropertySheetCallback* pPropSheetCallback, 
    IN  RS_NOTIFY_HANDLE        handle,
    IN  IDataObject*            pDataObject
    )
/*++

Routine Description:

    Console calls this when it is building a property sheet to
    show for a node. It is also called for the data object given
    to represent the snapin to the snapin manager, and should 
    show the initial selection page at that point.

Arguments:

    pPropSheetCallback - MMC interface to use to add page.

    handle          - Handle to MMC to use to add the page.

    pDataObject     - Data object refering to node.

Return Value:

    S_OK            - Pages added.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    WsbTraceIn( L"CSakData::CreatePropertyPages", L"pPropSheetCallback = <0x%p>, handle = <0x%p>, pDataObject = <0x%p>", pPropSheetCallback, handle, pDataObject );

    AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );
    HRESULT hr = S_OK;

    try {

        //
        // Confirm parameters.
        //
        WsbAffirmPointer( pPropSheetCallback );
//      WsbAffirmPointer( handle ); // Can be zero
        WsbAffirmPointer( pDataObject );


        //
        // If DataObject is CSakData, we need to present user
        // with page for machine. Do this by checking for
        // support of IComponentData interface.
        //

        CComPtr<IComponentData> pData;
        CComPtr<ISakWizard>     pWizard;

        if( SUCCEEDED( RsQueryInterface( pDataObject, IComponentData, pData ) ) ) {

            //
            // Create the Hsm Choose property page.
            //

            HPROPSHEETPAGE hPage = 0; // Windows property page handle

            CChooseHsmDlg * pChooseDlg = new CChooseHsmDlg( );
            WsbAffirmPointer( pChooseDlg );

            pChooseDlg->m_hConsoleHandle = handle;
            pChooseDlg->m_pHsmName       = &m_HsmName;
            pChooseDlg->m_pManageLocal   = &m_ManageLocal;

            WsbAffirmHr( MMCPropPageCallback( &(pChooseDlg->m_psp) ) );
            hPage = CreatePropertySheetPage( &pChooseDlg->m_psp );
            WsbAffirmPointer( hPage );
            pPropSheetCallback->AddPage( hPage );
 
        } else if( SUCCEEDED( RsQueryInterface( pDataObject, ISakWizard, pWizard ) ) ) {

            WsbAffirmHr( pWizard->AddWizardPages( handle, pPropSheetCallback, this ) );

        } else {

            //
            // Get node out of the dataobject.
            //
            CComPtr<ISakNode> pNode;
            CComPtr<IEnumGUID> pEnumObjectId;
            CComPtr<IEnumUnknown> pEnumUnkNode;

            //
            // Get the base hsm pointer depending on the data object type
            //
            WsbAffirmHr( GetBaseHsmFromDataObject( pDataObject, &pNode, &pEnumObjectId, &pEnumUnkNode ) );
            
            //
            // Tell the node to add its property pages.  pEnumObjectId will be NULL if
            // we are processing single-select.
            //
            WsbAffirmHr( pNode->AddPropertyPages( handle, pPropSheetCallback, pEnumObjectId, pEnumUnkNode ) );

        }

    } WsbCatch ( hr );

    WsbTraceOut( L"CSakData::CreatePropertyPages", L"hr = <%ls>", WsbHrAsString( hr ) );
    return ( hr );
}


STDMETHODIMP
CSakData::QueryPagesFor(
    IN  IDataObject* pDataObject
    )
/*++

Routine Description:

    This method is called by MMC when it wants to find out if this node
    supports property pages. The answer is yes if:

    1) The MMC context is either for the scope pane or result pane, AND

    2) The node actually DOES have property pages.

    OR

    1) The Data Object is acquired by the snapin manager.

    OR

    1) It is a wizard data object

    Return S_OK if it DOES have pages, and S_FALSE if it does NOT have pages.

Arguments:

    pDataObject     - Data object refering to node.

Return Value:

    S_OK            - Pages exist.

    S_FALSE         - No property pages.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    WsbTraceIn( L"CSakData::QueryPagesFor", L"pDataObject = <0x%p>", pDataObject );

    HRESULT hr = S_FALSE;

    try {

        //
        // Confirm parameter.
        //
        WsbAffirmPointer( pDataObject );


        //
        // If DataObject is CSakData, we need to present user
        // with page for machine. Do this by checking for
        // support of IComponentData interface, which is only
        // supported by CSakData.
        //

        CComPtr<IComponentData> pData;
        CComPtr<ISakWizard>     pWizard;

        if( SUCCEEDED( RsQueryInterface( pDataObject, IComponentData, pData ) ) ||
            SUCCEEDED( RsQueryInterface( pDataObject, ISakWizard, pWizard ) ) ) {

            hr = S_OK;
            
        } else {

            //
            // Get node out of the dataobject.
            //

            CComPtr<ISakNode> pBaseHsm;
            WsbAffirmHr( GetBaseHsmFromDataObject( pDataObject, &pBaseHsm ) );
            
            //
            // Ask the node if it has property pages.
            // Ensure we did not get an error.
            //

            hr = pBaseHsm->SupportsProperties( FALSE );
            WsbAffirmHr( hr );

        }

    } WsbCatch ( hr );

    WsbTraceOut( L"CSakData::QueryPagesFor", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}



///////////////////////////////////////////////////////////////////////
//                 IDataObject methods
///////////////////////////////////////////////////////////////////////



STDMETHODIMP
CSakData::GetDataHere(
    IN  LPFORMATETC lpFormatetc,
    IN  LPSTGMEDIUM lpMedium
    )
/*++

Routine Description:

    Retrieve information FROM the dataobject and put INTO lpMedium.

Arguments:

    lpFormatetc     - Format to retreive.

    lpMedium        - Storage to put information into.

Return Value:

    S_OK            - Storage filled in.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    WsbTraceIn( L"CSakData::GetDataHere", L"lpFormatetc->cfFormat = <%ls>", RsClipFormatAsString( lpFormatetc->cfFormat ) );
    HRESULT hr = DV_E_CLIPFORMAT;

    //
    // Based on the CLIPFORMAT write data to "lpMedium" in the correct format.
    //
    const CLIPFORMAT cf = lpFormatetc->cfFormat;

    //
    // clip format is the Display Name
    //

    if( cf == m_cfDisplayName ) {

        hr = RetrieveDisplayName( lpMedium );

    }
    
    //
    // clip format is the Node Type
    //

    else if( cf == m_cfNodeType ) {

        hr = RetrieveNodeTypeData( lpMedium );

    }

    //
    // clip format is the Node Type
    //

    else if( cf == m_cfNodeTypeString ) {

        hr = RetrieveNodeTypeStringData( lpMedium );

    }

    //
    // clip format is the ClassId
    //

    else if( cf == m_cfClassId ) {

        hr = RetrieveClsid( lpMedium );

    }

    WsbTraceOut( L"CSakData::GetDataHere", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


STDMETHODIMP
CSakData::SetData(
    IN  LPFORMATETC lpFormatetc,
    IN  LPSTGMEDIUM /*lpMedium*/,
    IN  BOOL /*fRelease*/
    )
/*++

Routine Description:

    Put data INTO a dataobject FROM the information in the lpMedium.
    We do not allow any data to be set.

Arguments:

    lpFormatetc     - Format to set.

    lpMedium        - Storage to get information from.

    fRelease        - Indicates who owns storage after call.

Return Value:

    S_OK            - Storage retreived.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    WsbTraceIn( L"CSakData::SetData", L"lpFormatetc->cfFormat = <%ls>", RsClipFormatAsString( lpFormatetc->cfFormat ) );

    HRESULT hr = DV_E_CLIPFORMAT;

    WsbTraceOut( L"CSakData::SetData", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


///////////////////////////////////////////////////////////////////////
// Note - CSakData does not implement these
///////////////////////////////////////////////////////////////////////

STDMETHODIMP CSakData::GetData(LPFORMATETC lpFormatetcIn, LPSTGMEDIUM /*lpMedium*/)
{
    WsbTraceIn( L"CSakData::GetData", L"lpFormatetc->cfFormat = <%ls>", RsClipFormatAsString( lpFormatetcIn->cfFormat ) );

    HRESULT hr = E_NOTIMPL;

    WsbTraceOut( L"CSakData::GetData", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

STDMETHODIMP CSakData::EnumFormatEtc(DWORD /*dwDirection*/, LPENUMFORMATETC* /*ppEnumFormatEtc*/)
{
    WsbTraceIn( L"CSakData::EnumFormatEtc", L"" );

    HRESULT hr = E_NOTIMPL;

    WsbTraceOut( L"CSakData::EnumFormatEtc", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


HRESULT
CSakData::RetrieveDisplayName(
    OUT LPSTGMEDIUM lpMedium
    )
/*++

Routine Description:

    Retrieve from a dataobject with the display named used in the scope pane

Arguments:

    lpMedium        - Storage to set information into.

Return Value:

    S_OK            - Storage set.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );

    HRESULT hr = S_OK;

    try {

        //
        // Load the name the data object
        //

        CString fullTitle;

        if(  m_ManageLocal ) {

            fullTitle.LoadString( IDS_MANAGE_LOCAL );
        
        } else if( !m_HsmName.IsEmpty( ) ) {

            AfxFormatString1( fullTitle, IDS_HSM_NAME_PREFIX, m_HsmName );
    
        } else {

            fullTitle = HSMADMIN_NO_HSM_NAME;

        }

        WsbAffirmHr( Retrieve( fullTitle, ((wcslen( fullTitle ) + 1) * sizeof(wchar_t)), lpMedium ) );

    } WsbCatch( hr );

    return( hr );
}


HRESULT
CSakData::RetrieveNodeTypeData(
    LPSTGMEDIUM lpMedium
    )
/*++

Routine Description:

    Retrieve from a dataobject with the NodeType (GUID) data in it.

Arguments:

    lpMedium        - Storage to set information into.

Return Value:

    S_OK            - Storage set.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    return Retrieve( (const void*)(&cGuidHsmCom), sizeof(GUID), lpMedium );
}
 
HRESULT
CSakData::RetrieveClsid(
    LPSTGMEDIUM lpMedium
    )
/*++

Routine Description:

    Retrieve from a dataobject with the CLSID data in it.

Arguments:

    lpMedium        - Storage to set information into.

Return Value:

    S_OK            - Storage set.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    GUID guid = GetCoClassID();
    return Retrieve( (const void*) &guid, sizeof(CLSID), lpMedium );
}

HRESULT
CSakData::RetrieveNodeTypeStringData(
    LPSTGMEDIUM lpMedium
    )
/*++

Routine Description:

    Retrieve from a dataobject with the node type object in GUID string format

Arguments:

    lpMedium        - Storage to set information into.

Return Value:

    S_OK            - Storage set.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    CWsbStringPtr guidString = cGuidHsmCom;
    return Retrieve( guidString, ((wcslen( guidString ) + 1 ) * sizeof(wchar_t)), lpMedium );
}


HRESULT
CSakData::Retrieve(
    IN  const void* pBuffer,
    IN  DWORD       len,
    OUT LPSTGMEDIUM lpMedium)
/*++

Routine Description:

    Retrieve FROM a dataobject INTO a lpMedium. The data object can be one of
    several types of data in it (nodetype, nodetype string, display name).
    This function moves data from pBuffer to the lpMedium->hGlobal

Arguments:

    pBuffer         - Buffer to copy contents out of.

    len             - Length of buffer in bytes.

    lpMedium        - Storage to set information into.

Return Value:

    S_OK            - Storage set.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    HRESULT hr = S_OK;

    try {

        //
        // Check Parameters
        //

        WsbAffirmPointer( pBuffer );
        WsbAffirmPointer( lpMedium );
        WsbAffirm( lpMedium->tymed == TYMED_HGLOBAL, E_FAIL );

        //
        // Create the stream on the hGlobal passed in. When we write to the stream,
        // it simultaneously writes to the hGlobal the same information.
        //

        CComPtr<IStream> lpStream;
        WsbAffirmHr( CreateStreamOnHGlobal( lpMedium->hGlobal, FALSE, &lpStream ) );

        //
        // Write 'len' number of bytes from pBuffer into the stream. When we write
        // to the stream, it simultaneously writes to the global memory we
        // associated it with above.
        //

        ULONG numBytesWritten;
        WsbAffirmHr( lpStream->Write( pBuffer, len, &numBytesWritten ) );

    } WsbCatch( hr );

    return( hr );
}




///////////////////////////////////////////////////////////////////////
//                 ISakSnapAsk
///////////////////////////////////////////////////////////////////////


STDMETHODIMP
CSakData::GetHsmName(
    OUT OLECHAR ** pszName OPTIONAL
    )
/*++

Routine Description:

    Retrieves the IUnknown pointer of a UI node given the node type.
    This will return the first node found of this type.

Arguments:

    pszName - Return of the name of the computer (can be NULL).

Return Value:

    S_OK - Managing remote machine - computer name given.

    S_FALSE - Managing local machine - *pszName set to local name.

--*/
{
    WsbTraceIn( L"CSakData::GetHsmName", L"pszName = <0x%p>", pszName );

    HRESULT hr = S_OK;

    try {

        CWsbStringPtr name = m_HsmName;

        if( m_ManageLocal ) {

            hr = S_FALSE;

        }

        if( pszName ) {

            WsbAffirmHr( name.GiveTo( pszName ) );

        }

    } WsbCatch( hr );

    WsbTraceOut( L"CSakData::GetHsmName", L"hr = <%ls>, *pszName = <%ls>", WsbHrAsString( hr ), WsbPtrToStringAsString( pszName ) );
    return( hr );
}


STDMETHODIMP
CSakData::GetNodeOfType(
    IN  REFGUID nodetype,
    OUT ISakNode** ppNode
    )
/*++

Routine Description:

    Retrieves the IUnknown pointer of a UI node given the node type.
    This will return the first node found of this type.

Arguments:

    nodetype - The GUID node type to look for.

    ppUiNode - returned IUnknown interface.

Return Value:

    S_OK - Found.

    S_FALSE - No Error, not found.

    E_UNEXPECTED - Some error occurred. 

--*/
{
    WsbTraceIn( L"CSakData::GetNodeOfType", L"nodetype = <%ls>, ppUiNode = <0x%p>", WsbGuidAsString( nodetype ), ppNode );

    HRESULT hr = S_OK;

    try {

        //
        // Verify Params
        //

        WsbAffirmPointer( ppNode );

        *ppNode = NULL;

        //
        // Call on base node to search down the node tree.
        // Save result, verify no error
        //
        CComPtr<ISakNode> pBaseHsm;
        WsbAffirmHr( m_pRootNode.QueryInterface( &pBaseHsm ) );

        hr = pBaseHsm->FindNodeOfType( nodetype, ppNode );
        WsbAffirmHr( hr );

    } WsbCatch( hr );

    WsbTraceOut( L"CSakData::GetNodeOfType", L"hr = <%ls>, *ppNode = <%ls>", WsbHrAsString( hr ), WsbPtrToPtrAsString( (void**)ppNode ) );
    return( hr );
}


STDMETHODIMP
CSakData::GetHsmServer(
    OUT IHsmServer** ppHsmServer
    )
/*++

Routine Description:

    Retrieve an interface pointer to the HSM server the snapin
    is managing.

Arguments:

    ppHsmServer - returned HSM server interface pointer.

Return Value:

    S_OK - Return fine.

    E_UNEXPECTED - Some error occurred. 

--*/
{
    WsbTraceIn( L"CSakData::GetHsmServer", L"ppHsmServer = <0x%p>", ppHsmServer );

    HRESULT hr = S_OK;

    try {

        //
        // Check Params
        //
        WsbAffirmPointer( ppHsmServer );
        *ppHsmServer = 0;

        WsbAffirmHrOk( AffirmServiceConnection( HSMCONN_TYPE_HSM ) );

        //
        // The connection should now be valid
        //
        WsbAffirmPointer( m_pHsmServer );

        //
        // Return the connection to the caller
        //
        m_pHsmServer.CopyTo( ppHsmServer );

    } WsbCatch( hr );

    WsbTraceOut( L"CSakData::GetHsmServer", L"hr = <%ls>, *ppHsmServer = <%ls>", WsbHrAsString( hr ), WsbPtrToPtrAsString( (void**)ppHsmServer ) );
    return( hr );
}


STDMETHODIMP
CSakData::GetRmsServer(
    OUT IRmsServer** ppRmsServer
    )
/*++

Routine Description:

    Retrieve an interface pointer to the RMS server the snapin
    is managing.

Arguments:

    ppRmsServer - returned HSM server interface pointer.

Return Value:

    S_OK - Return fine.

    E_UNEXPECTED - Some error occurred. 

--*/
{
    WsbTraceIn( L"CSakData::GetRmsServer", L"ppRmsServer = <0x%p>", ppRmsServer );

    HRESULT hr = S_OK;

    try {

        //
        // Check Params
        //

        WsbAffirmPointer( ppRmsServer );
        *ppRmsServer = 0;

        WsbAffirmHrOk( AffirmServiceConnection( HSMCONN_TYPE_RMS ) );

        //
        // We should now be connected
        //
        WsbAffirmPointer( m_pRmsServer );
        m_pRmsServer.CopyTo( ppRmsServer );

    } WsbCatch ( hr );

    WsbTraceOut( L"CSakData::GetRmsServer", L"hr = <%ls>, *ppRmsServer = <%ls>", WsbHrAsString( hr ), WsbPtrToPtrAsString( (void**)ppRmsServer ) );
    return( hr );
}

STDMETHODIMP
CSakData::GetFsaServer(
    OUT IFsaServer** ppFsaServer
    )
/*++

Routine Description:

    Retrieve an interface pointer to the Fsa server the snapin
    is managing.

Arguments:

    ppFsaServer - returned HSM server interface pointer.

Return Value:

    S_OK - Return fine.

    E_UNEXPECTED - Some error occurred. 

--*/
{
    WsbTraceIn( L"CSakData::GetFsaServer", L"ppFsaServer = <0x%p>", ppFsaServer );

    HRESULT hr = S_OK;

    try {

        //
        // Check Params
        //

        WsbAffirmPointer( ppFsaServer );
        *ppFsaServer = 0;

        WsbAffirmHrOk( AffirmServiceConnection( HSMCONN_TYPE_FSA ) );

        WsbAffirmPointer( m_pFsaServer );
        m_pFsaServer.CopyTo( ppFsaServer );

    } WsbCatch ( hr );

    WsbTraceOut( L"CSakData::GetFsaServer", L"hr = <%ls>, *ppFsaServer = <%ls>", WsbHrAsString( hr ), WsbPtrToPtrAsString( (void**)ppFsaServer ) );
    return( hr );
}

STDMETHODIMP
CSakData::ShowPropertySheet(
    IN ISakNode* pNode,
    IN IDataObject* pDataObject,
    IN INT       initialPage
    )
/*++

Routine Description:

    Create a property sheet for this node with the given page displayed
    on top

Arguments:

    pNode - node to show property sheet for

    initialPage - 0 based index of initial page to show

Return Value:

    S_OK - Return fine.

    E_UNEXPECTED - Some error occurred. 

--*/
{
    WsbTraceIn( L"CSakData::ShowPropertySheet", L"pNode = <0x%p>, initialPage = <%d>", pNode, initialPage );

    HRESULT hr = S_OK;
    HRESULT hrInternal = S_OK;

    try {

        WsbAffirmPointer( pNode );

        //
        // Get the property sheet provider interface from IConsole
        //
        CComPtr <IPropertySheetProvider> pProvider;
        WsbAffirmHr( m_pConsole.QueryInterface( &pProvider ) );

        //
        // Get the component data pointer
        //
        CComPtr <IComponent> pComponent;
        pComponent     = (IComponent *) this;

        //
        // If the sheet is already loaded, just show it
        //
        hrInternal = pProvider->FindPropertySheet( 0, pComponent, pDataObject );

        if( hrInternal != S_OK ) {

            //
            // Not loaded, create it
            //
            CComPtr<ISakNodeProp> pNodeProp;
            WsbAffirmHr( RsQueryInterface( pNode, ISakNodeProp, pNodeProp ) );

            CWsbBstrPtr pszName;
            WsbAffirmHr( pNodeProp->get_DisplayName( &pszName ) );

            //
            // If multiselect, append ellipses
            //
            if( IsDataObjectMultiSelect( pDataObject ) == S_OK ) {

                pszName.Append( L", ...");

            }

            //
            // Create the property sheet
            //
            WsbAffirmHr( pProvider->CreatePropertySheet (pszName, TRUE, 0, pDataObject, 0 ) );

            //
            // Tell the IComponentData interface to add pages
            //
            CComPtr <IUnknown> pUnkComponentData;
            pUnkComponentData = (IUnknown *) (IComponentData*) this;
            
            WsbAffirmHr( pProvider->AddPrimaryPages( pUnkComponentData, TRUE, 0, TRUE ) );
            WsbAffirmHr( pProvider->Show( 0, initialPage ) );
        }
    } WsbCatch ( hr );

    WsbTraceOut( L"CSakData::ShowPropertySheet", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


STDMETHODIMP
CSakData::RefreshNode(
    IN ISakNode* pNode
    )
/*++

Routine Description:

    Refresh scope pane from this node on down

Arguments:

    pNode - node to refresh

Return Value:

    S_OK - Return fine.

    E_UNEXPECTED - Some error occurred. 

--*/
{
    WsbTraceIn( L"CSakData::RefreshNode", L"pNode = <0x%p>", pNode );

    HRESULT hr = S_OK;

    try {

        WsbAffirmPointer( m_pWnd->GetSafeHwnd( ) );

        //
        // Post it to handle later
        //
        MMC_COOKIE cookie;
        WsbAffirmHr( GetCookieFromBaseHsm( pNode, &cookie ) );
        m_pWnd->PostRefreshNode( cookie );

    } WsbCatch ( hr );

    WsbTraceOut( L"CSakData::RefreshNode", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT
CSakData::InternalRefreshNode(
    IN MMC_COOKIE Cookie
    )
/*++

Routine Description:

    Refresh scope pane from this node on down.

Arguments:

    pNode - node to refresh

Return Value:

    S_OK - Return fine.

    E_UNEXPECTED - Some error occurred. 

--*/
{
    WsbTraceIn( L"CSakData::InternalRefreshNode", L"Cookie = <0x%p>", Cookie );

    HRESULT hr = S_OK;

    try {

        //
        // Decode the node, make sure still exists
        //
        CComPtr<ISakNode> pNode;
        WsbAffirmHr( GetBaseHsmFromCookie( Cookie, &pNode ) );

        //
        // Recursively update tree
        //
        WsbAffirmHr( RefreshNodeEx( pNode ) );

    } WsbCatch ( hr );

    WsbTraceOut( L"CSakData::InternalRefreshNode", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT
CSakData::RefreshNodeEx(
    IN ISakNode* pNode
    )
/*++

Routine Description:

    Refresh scope pane from this node on down. This is recursively called.

Arguments:

    pNode - node to refresh

Return Value:

    S_OK - Return fine.

    E_UNEXPECTED - Some error occurred. 

--*/
{
    WsbTraceIn( L"CSakData::RefreshNodeEx", L"pNode = <0x%p>", pNode );

    HRESULT hr = S_OK;

    try {

        //
        // Refresh this node
        //
        WsbAffirmHr( pNode->RefreshObject( ) );

        //
        // Refresh Icon and Text if container
        //
        if( S_OK == pNode->IsContainer( ) ) {

            SCOPEDATAITEM sdi;
            ZeroMemory( &sdi, sizeof sdi );
            sdi.mask        = SDI_STR | SDI_IMAGE | SDI_OPENIMAGE;

            WsbAffirmHr( pNode->GetScopeID( &sdi.ID ) );

            sdi.displayname = MMC_CALLBACK;

            WsbAffirmHr( pNode->GetScopeCloseIcon( m_State, &sdi.nImage ) );
            WsbAffirmHr( pNode->GetScopeOpenIcon( m_State, &sdi.nOpenImage ) );

            WsbAffirmHr( m_pNameSpace->SetItem( &sdi ) );

        }
        //
        // If this is a container with dynamic children, then we
        // want to just cause our contents to be recreated
        //
        if( S_OK == pNode->HasDynamicChildren( ) ) {

            WsbAffirmHr( FreeEnumChildren( pNode ) );

            WsbAffirmHr( pNode->InvalidateChildren() )
            WsbAffirmHr( EnsureChildrenAreCreated( pNode ) );

            HSCOPEITEM scopeID;
            WsbAffirmHr( pNode->GetScopeID( &scopeID ) );
            WsbAffirmHr( EnumScopePane( pNode, (HSCOPEITEM)( scopeID ) ) );

        } else {

            //
            // Loop over the children and call
            //
            CComPtr<IEnumUnknown> pEnum;
            if( ( pNode->EnumChildren( &pEnum ) ) == S_OK ) {

                CComPtr<ISakNode> pChildNode;
                CComPtr<IUnknown> pUnk;
                while( S_OK == pEnum->Next( 1, &pUnk, NULL ) ) {

                    WsbAffirmHr( pUnk.QueryInterface( &pChildNode ) );

                    WsbAffirmHr( RefreshNodeEx( pChildNode ) );

                    //
                    // must release even for smart pointer because of re-assign.
                    //
                    pChildNode.Release( );
                    pUnk.Release( );

                }

            }

        }

    } WsbCatch ( hr );

    WsbTraceOut( L"CSakData::RefreshNodeEx", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT
CSakData::InternalUpdateAllViews(
    IN MMC_COOKIE Cookie 
    )
/*++

Routine Description:
    Calls MMC to update all views

Arguments:

    pUnkNode - node to refresh

Return Value:

    S_OK - Return fine.

    E_UNEXPECTED - Some error occurred. 

--*/
{
    WsbTraceIn( L"CSakData::InternalUpdateAllViews", L"Cookie = <0x%p>", Cookie );

    HRESULT hr = S_OK;

    try {

        //
        // Decode the node
        //
        CComPtr <IDataObject> pDataObject;
        WsbAffirmHr( GetDataObjectFromCookie( Cookie, &pDataObject ) );

        //
        // Call MMC
        //
        WsbAffirmHr( m_pConsole->UpdateAllViews( pDataObject, 0L, 0L ) );

    } WsbCatch ( hr );

    WsbTraceOut( L"CSakData::InternalUpdateAllViews", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}




STDMETHODIMP
CSakData::UpdateAllViews (
    IN ISakNode* pNode
    )
/*++

Routine Description:
    Calls MMC to update all views

Arguments:

    pUnkNode - node to refresh

Return Value:

    S_OK - Return fine.

    E_UNEXPECTED - Some error occurred. 

--*/
{
    WsbTraceIn( L"CSakData::UpdateAllViews", L"pNode = <0x%p>", pNode );

    HRESULT hr = S_OK;

    try {

        WsbAffirmPointer( m_pWnd->GetSafeHwnd( ) );

        //
        // Post it to handle later
        //
        MMC_COOKIE cookie;
        WsbAffirmHr( GetCookieFromBaseHsm( pNode, &cookie ) );
        m_pWnd->PostUpdateAllViews( cookie );

    } WsbCatch ( hr );

    WsbTraceOut( L"CSakData::UpdateAllViews", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}







///////////////////////////////////////////////////////////////////////
//                 Node type manipulation routines
///////////////////////////////////////////////////////////////////////


HRESULT
CSakData::GetBaseHsmFromDataObject (
    IN  IDataObject *pDataObject, 
    OUT ISakNode **ppBaseHsm,
    OUT IEnumGUID **ppEnumObjectId,
    OUT IEnumUnknown **ppEnumUnkNode
    )

/*++

Routine Description:

    Retrieves the ISakNode for the object referenced by the 
    given data object.

Arguments:

    pDataObject - identifies the node to be worked on.

    ppBaseHSM - returned IBaseHSM interface.

    ppEnumObjectId - returned interface to enumeration of object Ids. Can be NULL.
        
Return Value:

    S_OK         - Node found and returned.

    E_UNEXPECTED - Some error occurred. 

--*/

{
    WsbTraceIn( L"CSakData::GetBaseHsmFromDataObject",
        L"pDataObject = <0x%p>, ppBaseHsm = <0x%p>, ppEnumObjectId = <0x%p>", 
        pDataObject, ppBaseHsm, ppEnumObjectId );

    HRESULT hr = S_OK;

    try {

        *ppBaseHsm = 0;
        if ( ppEnumObjectId ) *ppEnumObjectId = NULL;

        //
        // Get the base hsm pointer depending on the data object type
        //
        if (IsDataObjectMs( pDataObject ) == S_OK) {

            WsbAffirmHr( GetBaseHsmFromMsDataObject( pDataObject, ppBaseHsm, ppEnumObjectId, ppEnumUnkNode ) );

        } else if (IsDataObjectOt( pDataObject ) == S_OK) {

            WsbAffirmHr( GetBaseHsmFromOtDataObject( pDataObject, ppBaseHsm, ppEnumObjectId, ppEnumUnkNode ) );

        } else { // Assume single select

            WsbAffirmPointer( pDataObject );
            WsbAffirmHr( RsQueryInterface2( pDataObject, ISakNode, ppBaseHsm ) );

        }

    } WsbCatch ( hr );

    WsbTraceOut( L"CSakData::GetBaseHsmFromDataObject", L"hr = <%ls>, *ppBaseHsm = <%ls>", WsbHrAsString( hr ), WsbPtrToPtrAsString( (void**)ppBaseHsm ) );
    return ( hr );
}

HRESULT
CSakData::GetBaseHsmFromMsDataObject (
    IN  IDataObject  *pDataObject, 
    OUT ISakNode     **ppBaseHsm,
    OUT IEnumGUID    **ppEnumObjectId,
    OUT IEnumUnknown **ppEnumUnkNode
    )

/*++

Routine Description:

    Retrieves the ISakNode for the object referenced by the 
    given data object.

Arguments:

    pDataObject - identifies the node to be worked on.

    ppBaseHSM - returned IBaseHSM interface.

Return Value:

    S_OK         - Node found and returned.

    E_UNEXPECTED - Some error occurred. 

--*/

{
    WsbTraceIn( L"CSakData::GetBaseHsmFromMsDataObject", L"pDataObject = <0x%p>, ppBaseHsm = <0x%p>", pDataObject, ppBaseHsm );

    HRESULT hr = S_OK;

    try {

        // We've got an MMC mutli-select data object.  Get the first 
        // data object from it's array of data objects

        FORMATETC fmt = {(CLIPFORMAT)m_cfMultiSelect, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
        STGMEDIUM stgm = {TYMED_HGLOBAL, NULL};

        WsbAffirmHr ( pDataObject->GetData( &fmt, &stgm ) == S_OK );
        DWORD count;
        memcpy( &count, stgm.hGlobal, sizeof (DWORD) );
        if ( count > 0 ) {

            //
            // The following code is admittedly UGLY
            // We have a data stream where we need to skip past the 
            // first DWORD count and grab an interface pointer.
            // Other snapins code does it as follows:

//            IDataObject * pDO;
//            memcpy( &pDO, (DWORD *) stgm.hGlobal + 1, sizeof(IDataObject*) );

            //
            // However, since this code does an indirect cast (via memcpy) 
            // from DWORD to IDataObject*, and does not keep a true reference
            // on the interface pointer, we will use a smart pointer.
            // The (DWORD*) and +1 operation bump our pointer past the count.
            // We then need to grab the next bytes in the buffer and use them
            // as a IDataObject *.
            //
            CComPtr<IDataObject> pOtDataObject;
            pOtDataObject = *( (IDataObject**)( (DWORD *) stgm.hGlobal + 1 ) );

            //
            // Note: When we can be extended we need to check to see if this is one of ours
            //
            WsbAffirmHr( GetBaseHsmFromOtDataObject ( pOtDataObject, ppBaseHsm,  ppEnumObjectId, ppEnumUnkNode ) );
        }
    } WsbCatch ( hr );

    WsbTraceOut( L"CSakData::GetBaseHsmFromMsDataObject", L"hr = <%ls>, *ppBaseHsm = <%ls>", WsbHrAsString( hr ), WsbPtrToPtrAsString( (void**)ppBaseHsm ) );
    return ( hr );
}

HRESULT
CSakData::GetBaseHsmFromOtDataObject (
    IN  IDataObject     *pDataObject, 
    OUT ISakNode        **ppBaseHsm,
    OUT IEnumGUID       **ppEnumObjectId,
    OUT IEnumUnknown    **ppEnumUnkNode
    )

/*++

Routine Description:

    Retrieves the ISakNode for the object referenced by the 
    given data object.

Arguments:

    pDataObject - identifies the node to be worked on.

    ppBaseHSM - returned IBaseHSM interface.

Return Value:

    S_OK         - Node found and returned.

    E_UNEXPECTED - Some error occurred. 

--*/

{
    WsbTraceIn( L"CSakData::GetBaseHsmFromOtDataObject", L"pDataObject = <0x%p>, ppBaseHsm = <0x%p>", pDataObject, ppBaseHsm );

    HRESULT hr = S_OK;

    try {

        // we've got an object types mutli-select data object.  Get the first node selected 
        // from the data object.
        CComPtr<IMsDataObject> pMsDataObject;
        CComPtr<IUnknown>      pUnkNode;
        CComPtr<IEnumUnknown>  pEnumUnkNode;
        CComPtr<ISakNode>      pNode;

        WsbAffirmHr( RsQueryInterface( pDataObject, IMsDataObject, pMsDataObject ) );
        WsbAffirmHr( pMsDataObject->GetNodeEnumerator( &pEnumUnkNode ) );
        WsbAffirmHr( pEnumUnkNode->Next( 1, &pUnkNode, NULL ) );
        WsbAffirmHr( pUnkNode.QueryInterface( &pNode ) );
        WsbAffirmHr( pEnumUnkNode->Reset() );  // This enumeration is passed on, so we must reset it

        if( ppBaseHsm ) {

            pNode.CopyTo( ppBaseHsm );

        }

        if( ppEnumObjectId ) {

            pMsDataObject->GetObjectIdEnumerator( ppEnumObjectId );

        }

        if( ppEnumUnkNode ) {

            pEnumUnkNode.CopyTo( ppEnumUnkNode );

        }

    } WsbCatch ( hr );

    WsbTraceOut( L"CSakData::GetBaseHsmFromOtDataObject", L"hr = <%ls>, *ppBaseHsm = <%ls>", WsbHrAsString( hr ), WsbPtrToPtrAsString( (void**)ppBaseHsm ) );
    return ( hr );
}

HRESULT
CSakData::GetDataObjectFromBaseHsm (
    IN  ISakNode *    pBaseHsm,
    OUT IDataObject* *ppDataObject
    )

/*++

Routine Description:

    Retrieves the dataobject for the object referenced by the 
    given IBaseHSM.

Arguments:

    pBaseHsm - identifies the node to be worked on.

    ppDataObject - returned IDataObject interface.

Return Value:

    S_OK         - Node found and returned.

    E_UNEXPECTED - Some error occurred. 

--*/

{
    WsbTraceIn( L"CSakData::GetDataObjectFromBaseHsm", L"pBaseHsm = <0x%p>, ppDataObject = <0x%p>", pBaseHsm, ppDataObject );

    HRESULT hr = S_OK;

    try {

        *ppDataObject = 0;
        if( pBaseHsm ) {

            WsbAffirmHr( RsQueryInterface2( pBaseHsm, IDataObject, ppDataObject ) );

        }

    } WsbCatch ( hr );

    WsbTraceOut( L"CSakData::GetDataObjectFromBaseHsm", L"hr = <%ls>, *ppDataObject = <%ls>", WsbHrAsString( hr ), WsbPtrToPtrAsString( (void**)ppDataObject ) );
    return ( hr );
}


HRESULT
CSakData::GetBaseHsmFromCookie (
    IN  MMC_COOKIE          Cookie, 
    OUT ISakNode **   ppBaseHsm
    )

/*++

Routine Description:

    Retrieves the ISakNode for the object referenced by the 
    given cookie.

Arguments:

    Cookie       - identifies the node to be worked on.

    ppBaseHsm    - returned ISakNode interface.

Return Value:

    S_OK         - Node found and returned.

    E_UNEXPECTED - Some error occurred. 

--*/
{
    WsbTraceIn( L"CSakData::GetBaseHsmFromCookie", L"Cookie = <0x%p>, ppBaseHsm = <0x%p>", Cookie, ppBaseHsm );

    HRESULT hr = S_OK;

    try {

        //
        // Cookies are pointers to CSakDataNodePrivate classes, which
        // contain smart pointers to their nodes.
        // NULL cookie means root snapin.
        //

        if( ( 0 == Cookie ) || ( EXTENSION_RS_FOLDER_PARAM == Cookie ) ) {

      