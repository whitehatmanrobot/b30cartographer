' />
        /// <devdoc>
        ///    <para>
        ///       User friendly name of the template editing frame (used in the context menu). Read-only property.
        ///    </para>
        /// </devdoc>
        public string Name {
            get {
                return frameName;
            }
        }

        /// <include file='doc\TemplateEditingFrame.uex' path='docs/doc[@for="TemplateEditingFrame.InitialHeight"]/*' />
        public int InitialHeight {
            get {
                return initialHeight;
            }
            set {
                initialHeight = value;
            }
        }

        /// <include file='doc\TemplateEditingFrame.uex' path='docs/doc[@for="TemplateEditingFrame.InitialWidth"]/*' />
        public int InitialWidth {
            get {
                return initialWidth;
            }
            set {
                initialWidth = value;
            }
        }

        /// <include file='doc\TemplateEditingFrame.uex' path='docs/doc[@for="TemplateEditingFrame.TemplateNames"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The names of the templates contained within the frame.
        ///    </para>
        /// </devdoc>
        public string[] TemplateNames {
            get {
                return templateNames;
            }
        }

        /// <include file='doc\TemplateEditingFrame.uex' path='docs/doc[@for="TemplateEditingFrame.TemplateStyles"]/*' />
        public Style[] TemplateStyles {
            get {
                return templateStyles;
            }
        }
        
        /// <include file='doc\TemplateEditingFrame.uex' path='docs/doc[@for="TemplateEditingFrame.VerbIndex"]/*' />
        public TemplateEditingVerb Verb {
            get {
                return verb;
            }
            set {
                // Value cannot be null, and the current verb must be null or must match value
                Debug.Assert((value != null) && ((verb == null) || (verb == value)));

                verb = value;
            }
        }
        
        /// <include file='doc\TemplateEditingFrame.uex' path='docs/doc[@for="TemplateEditingFrame.Close"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Saves all the individual templates present within the frame and hides it.
        ///    </para>
        /// </devdoc>
        public void Close(bool saveChanges) {
            if (saveChanges) {
                Save();
            }
            ShowInternal(false);
        }

        private string CreateFrameContent() {
            StringBuilder sb = new StringBuilder(1024);

            string frameStyleString = String.Empty;
            if (initialWidth > 0) {
                frameStyleString = "width:" + initialWidth + "px;";
            }
            if (initialHeight > 0) {
                frameStyleString += "height:" + initialHeight + "px;";
            }

            sb.Append(String.Format(TemplateFrameHeaderContent,
                                    owner.Component.GetType().Name,
                                    Name,
                                    TemplateInfoIcon,
                                    TemplateInfoToolTip,
                                    frameStyleString));

            string controlStyleString = String.Empty;
            if (controlStyle != null) {
                controlStyleString = StyleToCss(controlStyle);
            }
            
            string templateStyleString = String.Empty;
            for (int i = 0; i < templateNames.Length; i++) {
                sb.Append(TemplateFrameSeparatorContent);

                if (templateStyles != null)
                    templateStyleString = StyleToCss(templateStyles[i]);
                sb.Append(String.Format(TemplateFrameTemplateContent,
                                        templateNames[i],
                                        controlStyleString,
                                        templateStyleString));
            }

            sb.Append(TemplateFrameFooterContent);

            return sb.ToString();
        }

        /// <include file='doc\TemplateEditingFrame.uex' path='docs/doc[@for="TemplateEditingFrame.Dispose"]/*' />
        public void Dispose() {
            if ((owner != null) && (owner.InTemplateMode)) {
                owner.ExitTemplateMode(/*fSwitchingTemplates*/ false, /*fNested*/ false, /*fSave*/ false);
            }
            ReleaseParentElement();
            verb = null;
        }
        
        /// <include file='doc\TemplateEditingFrame.uex' path='docs/doc[@for="TemplateEditingFrame.Initialize"]/*' />
        /// <devdoc>
        ///     Initialize from content by creating the necessary HTML element tree structure, etc.
        /// </devdoc>
        private void Initialize() {
            if (this.htmlElemFrame != null) {
                return;
            }
            
            try {
                NativeMethods.IHTMLDocument2 htmlDocument = (NativeMethods.IHTMLDocument2)htmlElemParent.GetDocument();
                
                // Create an HTML element that would represent the entire template frame.
                this.htmlElemFrame = htmlDocument.CreateElement("SPAN");
                
                // Place the provided content within the frame
                htmlElemFrame.SetInnerHTML(this.Content);
                
                // Hold on to the top-level HTML element of the template frame content.
                NativeMethods.IHTMLDOMNode domNodeFrame = (NativeMethods.IHTMLDOMNode)htmlElemFrame;
                if (domNodeFrame != null) {
                    this.htmlElemContent = (NativeMethods.IHTMLElement)domNodeFrame.GetFirstChild();
                }
                
                // Mark the frame as not editable!
                NativeMethods.IHTMLElement3 htmlElement3 = (NativeMethods.IHTMLElement3)htmlElemFrame;
                if (htmlElement3 != null) {
                    htmlElement3.SetContentEditable("false");
                }
                
                // Create an array to hold the HTML elements representing the individual templates.
                templateElements = new object[templateNames.Length];
                
                Object varName;
                Object varIndex = (int)0;
                NativeMethods.IHTMLElementCollection allCollection = (NativeMethods.IHTMLElementCollection)htmlElemFrame.GetAll();
                
                // Obtain all the children of the frame and hold on to the ones representing the templates.
                for (int i = 0; i < templateNames.Length; i++) {
                    try {
                        varName = templateNames[i];
                        NativeMethods.IHTMLElement htmlElemTemplate = (NativeMethods.IHTMLElement)allCollection.Item(varName, varIndex);
                        
                        // Set an expando attribute (on the above HTML element) called "TemplateName"
                        // which contains the name of the template it corresponds to.
                        htmlElemTemplate.SetAttribute("templatename", varName, /*lFlags*/ 0);
                        
                        // Place an editable DIV within the individual templates.
                        // This is needed in order for, say, TABLEs, TRs, TDs, etc., to be editable in a
                        // view-linked markup.
                        string editableDIV = "<DIV contentEditable=\"true\" style=\"padding:1;height:100%;width:100%\"></DIV>";
                        htmlElemTemplate.SetInnerHTML(editableDIV);
                        
                        // The first child of the template element will be the above editable SPAN.
                        NativeMethods.IHTMLDOMNode domNodeTemplate = (NativeMethods.IHTMLDOMNode)htmlElemTemplate;
                        if (domNodeTemplate != null) {
                            templateElements[i] = domNodeTemplate.GetFirstChild();
                        }
                    }
                    catch (Exception ex) {
                        Debug.Fail(ex.ToString());
                        templateElements[i] = null;
                    }
                }
                
                // Hold on to the HTML element within which the control name should get displayed.
                // The presence of this element is optional.
                
                varName = "idControlName";
                this.htmlElemControlName = (NativeMethods.IHTMLElement)allCollection.Item(varName, varIndex);

                // Retrieve the HTML element within which the template frame name should be displayed.
                // The presence of this element is optional.
                // We also don't hold on to it, since the name of the template frame can't be changed.

                varName = "idFrameName";
                object objFrameName = allCollection.Item(varName, varIndex);
                if (objFrameName != null) {
                    NativeMethods.IHTMLElement htmlElemFrameName = (NativeMethods.IHTMLElement)objFrameName;
                    htmlElemFrameName.SetInnerText(frameName);
                }

                NativeMethods.IHTMLDOMNode domNodeParent = (NativeMethods.IHTMLDOMNode)htmlElemParent;
                if (domNodeParent == null) {
                    return;
                }

                domNodeParent.AppendChild(domNodeFrame);
            }
            catch (Exception ex) {
                Debug.Fail(ex.ToString());
            }
        }
        
        /// <include file='doc\TemplateEditingFrame.uex' path='docs/doc[@for="TemplateEditingFrame.Open"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Opens this frame for editing in the designer.
        ///    </para>
        /// </devdoc>
        public void Open() {
            NativeMethods.IHTMLElement ownerView = (NativeMethods.IHTMLElement)((IControlDesignerBehavior)owner.Behavior).DesignTimeElementView;
            Debug.Assert(ownerView != null, "Owner doesn't have an associated root view-linked HTML element");
            
            // Reparent the frame when the root element of the view-link tree changes.
            if (this.htmlElemParent != ownerView) {
                ReleaseParentElement();
                htmlElemParent = ownerView;
            }
            
            // Initialize the frame (will return immediately if already initialized).
            Initialize();
            
            try {
                // Place the actual template content (by obtaining it from the owner) within the
                // marked template sections that are editable in the designer.
                for (int i = 0; i < templateNames.Length; i++) {
                    if (templateElements[i] != null) {
                        bool allowEditing = true;
                        NativeMethods.IHTMLElement htmlElemTemplate = (NativeMethods.IHTMLElement)templateElements[i];
                        string templateContent = owner.GetTemplateContent(this, templateNames[i], out allowEditing);

                        htmlElemTemplate.SetAttribute("contentEditable", allowEditing, /*lFlags*/ 0);
                        if (templateContent != null) {
                            // NOTE: (as/urt: 76317) Trident has this weird behavior, where it fails to use the
                            //       context available from htmlElemTemplate, and discards everything in
                            //       templateContent (such as <%# ... %>) until it finds some plain text or some
                            //       html content to create enough context info and conclude that it is parsing html.
                            //
                            //       We can't have this data loss, and they can't fix their bug... so we'll
                            //       have to workaround it... typical!
                            //       Also note that when we save the template, trident does not return the
                            //       surrounding <body> tags, so we don't have to strip them out as part of
                            //       this workaround.
                            // NOTE: (as/urt: 93784): IME's don't get enabled without the extra contentEditable.

                            templateContent = "<body contentEditable=true>" + templateContent + "</body>";
                            htmlElemTemplate.SetInnerHTML(templateContent);
                        }
                    }
                }
                
                // Place the control name in the appropriate section if one was provided earlier
                // in the content.
                if (this.htmlElemControlName != null) {
                    Debug.Assert(owner.Component != null && owner.Component.Site != null,
                        "Invalid component or an invalid component site");
                    htmlElemControlName.SetInnerText(owner.Component.Site.Name);
                }
            }
            catch (Exception ex) {
                Debug.Fail(ex.ToString());
            }
            
            // Finally make the frame visible by inserting it in the live HTML tree.
            ShowInternal(true);
        }
        
        /// <include file='doc\TemplateEditingFrame.uex' path='docs/doc[@for="TemplateEditingFrame.ReleaseParentElement"]/*' />
        /// <devdoc>
        ///     Release the frame HTML element, its parent element and the element containing
        ///     the control name.
        /// </devdoc>
        private void ReleaseParentElement() {
            this.htmlElemParent = null;
            this.htmlElemFrame = null;
            this.htmlElemContent = null;
            this.htmlElemControlName = null;
            
            templateElements = null;
            fVisible = false;
        }
        
        /// <include file='doc\TemplateEditingFrame.uex' path='docs/doc[@for="TemplateEditingFrame.Resize"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Resizes the
        ///       template editing frame.
        ///    </para>
        /// </devdoc>
        public void Resize(int width, int height) {
            if (htmlElemContent != null) {
                NativeMethods.IHTMLStyle htmlStyle = htmlElemContent.GetStyle();
                if (htmlStyle != null) {
                    htmlStyle.SetPixelWidth(width);
                    htmlStyle.SetPixelHeight(height);
                }
            }
        }
        
        /// <include file='doc\TemplateEditingFrame.uex' path='docs/doc[@for="TemplateEditingFrame.Save"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Extracts the current contents for the marked template sections in the live tree,
        ///       and notifies the designer with the updated contents for the individual templates.
        ///    </para>
        /// </devdoc>
        public void Save() {
            try {
                if (templateElements != null) {
                    object[] editable = new object[1];
                    for (int i = 0; i < templateNames.Length; i++) {
                        if (templateElements[i] != null) {
                            NativeMethods.IHTMLElement htmlElemTemplate = (NativeMethods.IHTMLElement)templateElements[i];
                            htmlElemTemplate.GetAttribute("contentEditable", /*lFlags*/ 0, editable);

                            if ((editable[0] != null)  && (editable[0] is string) && (String.Compare((string)editable[0], "true", true, CultureInfo.InvariantCulture) == 0)) {
                                string templateContent = htmlElemTemplate.GetInnerHTML();
                                owner.SetTemplateContent(this, templateNames[i], templateContent);
                            }
                        }
                    }
                }
            }
            catch (Exception ex) {
                Debug.Fail(ex.ToString());
            }
        }
        
        /// <include file='doc\TemplateEditingFrame.uex' path='docs/doc[@for="TemplateEditingFrame.Show"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Shows the individual templates present within the frame in the design surface.
        ///       Toggles the visibility of the frame either by placing it in the view-linked markup
        ///       or by removing it from the live tree.
        ///    </para>
        /// </devdoc>
        public void Show() {
            ShowInternal(true);
        }
        
        /// <devdoc>
        ///    <para>
        ///       Toggles the visibility of the frame either by placing it in the view-linked markup
        ///       or by removing it from the live tree.
        ///    </para>
        /// </devdoc>
        private void ShowInternal(bool fShow) {
            // Return immediately either if no frame HTML element exists or if the visibility
            // of the frame is the same as that of the requested state.
            if (htmlElemFrame == null || (this.fVisible == fShow)) {
                return;
            }
            
            // To show the frame, place it within the root view-linked element.
            // To hide the frame, remove it completely from the view-linked tree. 
            try {
                NativeMethods.IHTMLDOMNode domNodeFrame = (NativeMethods.IHTMLDOMNode)htmlElemFrame;
                NativeMethods.IHTMLElement frameElement = (NativeMethods.IHTMLElement)domNodeFrame;
                NativeMethods.IHTMLStyle frameStyle = frameElement.GetStyle();
                if (fShow) {
                    frameStyle.SetDisplay(String.Empty);
                }
                else {
                    // Clear the template contents when hiding the frame. This will ensure that
                    // any controls within that template are removed from the designer host, etc.
                    if (templateElements != null) {
                        for (int i = 0; i < templateElements.Length; i++) {
                            if (templateElements[i] != null) {
                                NativeMethods.IHTMLElement htmlElemTemplate = (NativeMethods.IHTMLElement)templateElements[i];
                                htmlElemTemplate.SetInnerHTML(String.Empty);
                            }
                        }
                    }

                    frameStyle.SetDisplay("none");
                }
            }
            catch (Exception ex) {
                Debug.Fail(ex.ToString());
            }
            
            this.fVisible = fShow;
        }
        
        private string StyleToCss(Style style) {
            Debug.Assert(style != null);

            StringBuilder sb = new StringBuilder();
            Color c;

            c = style.ForeColor;
            if (!c.IsEmpty) {
                sb.Append("color:");
                sb.Append(ColorTranslator.ToHtml(c));
                sb.Append(";");
            }
            c = style.BackColor;
            if (!c.IsEmpty) {
                sb.Append("background-color:");
                sb.Append(ColorTranslator.ToHtml(c));
                sb.Append(";");
            }

            FontInfo fi = style.Font;
            string s;

            s = fi.Name;
            if (s.Length != 0) {
                sb.Append("font-family:'");
                sb.Append(s);
                sb.Append("';");
            }
            if (fi.Bold) {
                sb.Append("font-weight:bold;");
            }
            if (fi.Italic) {
                sb.Append("font-style:italic;");
            }

            s = String.Empty;
            if (fi.Underline)
                s += "underline";
            if (fi.Strikeout)
                s += " line-through";
            if (fi.Overline)
                s += " overline";
            if (s.Length != 0) {
                sb.Append("text-decoration:");
                sb.Append(s);
                sb.Append(';');
            }

            FontUnit unit = fi.Size;
            if (unit.IsEmpty == false) {
                sb.Append("font-size:");
                sb.Append(unit.ToString());
            }

            return sb.ToString();
        }
        
        /// <include file='doc\TemplateEditingFrame.uex' path='docs/doc[@for="TemplateEditingFrame.UpdateControlName"]/*' />
        public void UpdateControlName(string newName) {
            if (this.htmlElemControlName != null) {
                Debug.Assert(newName != null, "Invalid Name!");
                htmlElemControlName.SetInnerText(newName);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\urleditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="URLEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design {
    
    using System.Runtime.InteropServices;
    using System.Design;

    using System.Diagnostics;
    using System;
    using System.IO;
    using System.Collections;
    using System.ComponentModel;
    using System.Windows.Forms;
    using System.Drawing;
    using System.Drawing.Design;
    
    using System.Windows.Forms.Design;
    using System.Windows.Forms.ComponentModel;

    /// <include file='doc\URLEditor.uex' path='docs/doc[@for="UrlEditor"]/*' />
    /// <devdoc>
    ///    <para>Provides an editor for visually picking an Url.</para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public class UrlEditor : UITypeEditor {
        
        /// <include file='doc\URLEditor.uex' path='docs/doc[@for="UrlEditor.Caption"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the caption for the Url.
        ///    </para>
        /// </devdoc>
        protected virtual string Caption {
            get {
                return SR.GetString(SR.UrlPicker_DefaultCaption);
            }
        }

        /// <include file='doc\URLEditor.uex' path='docs/doc[@for="UrlEditor.Options"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the options for the Url picker.
        ///    </para>
        /// </devdoc>
        protected virtual UrlBuilderOptions Options {
            get {
                return UrlBuilderOptions.None;
            }
        }

        /// <include file='doc\URLEditor.uex' path='docs/doc[@for="UrlEditor.EditValue"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Edits the specified object value using
        ///       the editor style provided by GetEditorStyle.
        ///    </para>
        /// </devdoc>
        public override object EditValue(ITypeDescriptorContext context,  IServiceProvider  provider, object value) {

            if (provider != null) {
                IWindowsFormsEditorService edSvc = (IWindowsFormsEditorService)provider.GetService(typeof(IWindowsFormsEditorService));

                if (edSvc != null) {

                    string url = (string) value;
                    string caption = Caption;
                    string filter = Filter;

                    IComponent component = null;
                    if (context.Instance is IComponent) {
                        component = (IComponent)context.Instance;
                    }
                    else if (context.Instance is object[]) {
                        object[] components = (object[])context.Instance;
                        if (components[0] is IComponent) {
                            component = (IComponent)components[0];
                        }
                    }

                    url = UrlBuilder.BuildUrl(component, null, url, caption, filter, Options);
                    if (url != null) {
                        value = url;
                    }
                }

            }
            return value;
        }

        /// <include file='doc\URLEditor.uex' path='docs/doc[@for="UrlEditor.Filter"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the filter to use.
        ///    </para>
        /// </devdoc>
        protected virtual string Filter {
            get {
                return SR.GetString(SR.UrlPicker_DefaultFilter);
            }
        }

        /// <include file='doc\URLEditor.uex' path='docs/doc[@for="UrlEditor.GetEditStyle"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the editing style of the Edit method.
        ///    </para>
        /// </devdoc>
        public override UITypeEditorEditStyle GetEditStyle(ITypeDescriptorContext context) {
            return UITypeEditorEditStyle.Modal;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\usercontroldesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="UserControlDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design {
    using System.Text;
    using System.Design;
    
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.IO;
    using System.Collections;
    using System.Drawing;
    using System.Reflection;
    using System.Web.UI.Design;
    using System.Web.UI;
    using System.Web.UI.WebControls;    
    using System.ComponentModel.Design;
    using WebUIControl = System.Web.UI.Control;

    /// <include file='doc\UserControlDesigner.uex' path='docs/doc[@for="ControlDesigner"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides the base class for all namespaced or custom server control designers.
    ///    </para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public class ControlDesigner : HtmlControlDesigner {

        private static readonly string PlaceHolderDesignTimeHtmlTemplate =
            @"<table cellpadding=4 cellspacing=0 style=""font:messagebox;color:buttontext;background-color:buttonface;border: solid 1px;border-top-color:buttonhighlight;border-left-color:buttonhighlight;border-bottom-color:buttonshadow;border-right-color:buttonshadow"">
              <tr><td><span style=""font-weight:bold"">{0}</span> - {1}</td></tr>
              <tr><td>{2}</td></tr>
            </table>";

        private bool isWebControl;           // true if the associated component is a WebControl
        private bool readOnly = true;        // read-only/read-write state of the control design surface.
        private bool fDirty = false;         // indicates the dirty state of the control (used during inner content saving).
        private bool fRemoveInitialSize = true;     // ?
        private bool ignoreComponentChanges;

        /// <include file='doc\UserControlDesigner.uex' path='docs/doc[@for="ControlDesigner.AllowResize"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating
        ///       whether or not the control can be resized.
        ///    </para>
        /// </devdoc>
        public virtual bool AllowResize {
            get {
                return IsWebControl;
            }
        }

        /// <include file='doc\UserControlDesigner.uex' path='docs/doc[@for="ControlDesigner.DesignTimeHtmlRequiresLoadComplete"]/*' />
        public virtual bool DesignTimeHtmlRequiresLoadComplete {
            get {
                return false;
            }
        }

        /// <include file='doc\UserControlDesigner.uex' path='docs/doc[@for="ControlDesigner.ID"]/*' />
        /// <devdoc>
        ///    
        /// </devdoc>
        public virtual string ID {
            get {
                return ((WebUIControl)Component).ID; 
            }
           
            set {
                 ISite site = Component.Site;

                 site.Name = value;
                 ((WebUIControl)Component).ID = value.Trim();
            }
        }

        /// <include file='doc\UserControlDesigner.uex' path='docs/doc[@for="ControlDesigner.IsDirty"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating
        ///       whether or not the boolean dirty state of the web control is currently set.
        ///    </para>
        /// </devdoc>
        public bool IsDirty {
            get {
                return fDirty;
            }
            set {
                fDirty = value;
            }
        }

        internal bool IsIgnoringComponentChanges {
            get {
                return ignoreComponentChanges;
            }
        }

        internal bool IsWebControl {
            get {
                return isWebControl;
            }
        }
        
        /// <include file='doc\UserControlDesigner.uex' path='docs/doc[@for="ControlDesigner.ReadOnly"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating
        ///       whether or not the control's associated design surface is set to read-only or not.
        ///    </para>
        /// </devdoc>
        public bool ReadOnly {
            get {
                return readOnly;
            }
            set {
                readOnly = value;
            }
        }

        /// <include file='doc\UserControlDesigner.uex' path='docs/doc[@for="ControlDesigner.DesignTimeElementView"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///   <para>The object on the design surface used to display the visual representation of the control associated with this designer.</para>
        /// </devdoc>
        protected object DesignTimeElementView {
            get {
                IHtmlControlDesignerBehavior behavior = Behavior;
                if (behavior != null) {
                    Debug.Assert(behavior is IControlDesignerBehavior, "Wrong type of behavior");

                    return ((IControlDesignerBehavior)behavior).DesignTimeElementView;
                }
                return null;
            }
        }

        /// <include file='doc\UserControlDesigner.uex' path='docs/doc[@for="ControlDesigner.CreatePlaceHolderDesignTimeHtml"]/*' />
        protected string CreatePlaceHolderDesignTimeHtml() {
            return CreatePlaceHolderDesignTimeHtml(null);
        }

        /// <include file='doc\UserControlDesigner.uex' path='docs/doc[@for="ControlDesigner.CreatePlaceHolderDesignTimeHtml1"]/*' />
        protected string CreatePlaceHolderDesignTimeHtml(string instruction) {
            string typeName = Component.GetType().Name;
            string name = Component.Site.Name;

            if (instruction == null) {
                instruction = String.Empty;
            }

            return String.Format(PlaceHolderDesignTimeHtmlTemplate, typeName, name, instruction);
        }
        
        /// <include file='doc\UserControlDesigner.uex' path='docs/doc[@for="ControlDesigner.GetDesignTimeHtml"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the HTML to be used for the design time representation of the control runtime.
        ///    </para>
        /// </devdoc>
        public virtual string GetDesignTimeHtml() {
            StringWriter strWriter = new StringWriter();
            HtmlTextWriter htmlWriter = new HtmlTextWriter(strWriter);
            IComponent component = Component;
            string designTimeHTML = null;

            Debug.Assert(ReadOnly, "GetDesignTimeHTML should be called only for R/O controls");

            WebUIControl control = (WebUIControl)Component;
            bool visibleChanged = false;
            bool oldVisible = true;

            try {
                oldVisible = control.Visible;
                if (oldVisible == false) {
                    control.Visible = true;
                    visibleChanged = true;
                }
                
                control.RenderControl(htmlWriter);
                designTimeHTML = strWriter.ToString();
            }
            catch (Exception ex) {
                designTimeHTML = GetErrorDesignTimeHtml(ex);
            }
            finally {
                if (visibleChanged) {
                    control.Visible = oldVisible;
                }
            }

            if ((designTimeHTML == null) || (designTimeHTML.Length == 0)) {
                designTimeHTML = GetEmptyDesignTimeHtml();
            }
            return designTimeHTML;
        }

        /// <include file='doc\UserControlDesigner.uex' path='docs/doc[@for="ControlDesigner.GetEmptyDesignTimeHtml"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the HTML to be used at design time as the representation of the
        ///       control when the control runtime does not return any rendered
        ///       HTML. The default behavior is to return a string containing the name of the
        ///       component.
        ///    </para>
        /// </devdoc>
        protected virtual string GetEmptyDesignTimeHtml() {
            string typeName = Component.GetType().Name;
            string name = Component.Site.Name;

            if ((name != null) && (name.Length > 0)) {
                return "[ " + typeName + " \"" + name + "\" ]";
            }
            else {
                return "[ " + typeName + " ]";
            }
        }

        /// <include file='doc\UserControlDesigner.uex' path='docs/doc[@for="ControlDesigner.GetErrorDesignTimeHtml"]/*' />
        /// <devdoc>
        /// </devdoc>
        protected virtual string GetErrorDesignTimeHtml(Exception e) {
            Debug.Fail(e.ToString());
            return String.Empty;
        }

        /// <include file='doc\UserControlDesigner.uex' path='docs/doc[@for="ControlDesigner.GetPersistInnerHtml"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the persistable inner HTML.
        ///    </para>
        /// </devdoc>
        public virtual string GetPersistInnerHtml() {
            if (IsWebControl) {
                // Remove any existing width & height attributes after mapping them to their
                // respective properties in the control OM.
                RemoveSizeAttributes();
            }
            
            if (!IsDirty) {
                // Note: Returning a null string will prevent the actual save.
                return null;
            }
            
            IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
            Debug.Assert(host != null, "Did not get a valid IDesignerHost reference");

            this.IsDirty = false;
            return ControlPersister.PersistInnerProperties(Component, host);
        }

        internal void IgnoreComponentChanges(bool ignore) {
            ignoreComponentChanges = ignore;
        }
        
        /// <include file='doc\UserControlDesigner.uex' path='docs/doc[@for="ControlDesigner.Initialize"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes the designer using
        ///       the specified component.
        ///    </para>
        /// </devdoc>
        public override void Initialize(IComponent component) {
            Debug.Assert(component is WebUIControl, "ControlDesigner::Initialize - Invalid Control");
            base.Initialize(component);

            isWebControl = (component is WebControl);
        }
        
        /// <include file='doc\UserControlDesigner.uex' path='docs/doc[@for="ControlDesigner.IsPropertyBound"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether a particular property (identified by its name) is data bound.
        ///    </para>
        /// </devdoc>
        public bool IsPropertyBound(string propName) {
            return (DataBindings[propName] != null);
        }

        /// <include file='doc\UserControlDesigner.uex' path='docs/doc[@for="ControlDesigner.OnBehaviorAttached"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Notification that is called when the designer is attached to the behavior.
        ///    </para>
        /// </devdoc>
        protected override void OnBehaviorAttached() {
            base.OnBehaviorAttached();
            if (IsWebControl) {
                RemoveSizeAttributes();
            
                // Remove the position, left and top style attributes from the runtime control
                // in order for it to render w.r.t to the view-linked master element.
                WebControl control = (WebControl)Component;
                if (control.Style != null) {
                    // CONSIDER: The runtime is currently case sensitive, maybe that should change...
                    control.Style.Remove("POSITION");
                    control.Style.Remove("LEFT");
                    control.Style.Remove("TOP");
                    control.Style.Remove("WIDTH");
                    control.Style.Remove("HEIGHT");
                    control.Style.Remove("position");
                    control.Style.Remove("left");
                    control.Style.Remove("top");
                    control.Style.Remove("width");
                    control.Style.Remove("height");
                }
            }
        }

        private static readonly Attribute[] emptyAttrs = new Attribute[0];
        private static readonly Attribute[] nonBrowsableAttrs = new Attribute[] { BrowsableAttribute.No };

        /// <include file='doc\UserControlDesigner.uex' path='docs/doc[@for="ControlDesigner.PreFilterProperties"]/*' />
        /// <devdoc>
        /// </devdoc>
        protected override void PreFilterProperties(IDictionary properties) {
            base.PreFilterProperties(properties);

            PropertyDescriptor prop;

            // Handle shadowed properties
            prop = (PropertyDescriptor)properties["ID"];
            if (prop != null) {
                properties["ID"] = TypeDescriptor.CreateProperty(GetType(), prop, emptyAttrs);
            }

            // Hide some properties...
            prop = (PropertyDescriptor)properties["DynamicProperties"];
            if (prop != null) {
                properties["DynamicProperties"] = TypeDescriptor.CreateProperty(prop.ComponentType, prop, nonBrowsableAttrs);
            }
        }

        /// <include file='doc\UserControlDesigner.uex' path='docs/doc[@for="ControlDesigner.OnBindingsCollectionChanged"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Delegate to
        ///       handle bindings collection changed event.
        ///    </para>
        /// </devdoc>
        protected override void OnBindingsCollectionChanged(string propName) {
            if (Behavior == null)
                return;

            DataBindingCollection bindings = DataBindings;

            if (propName != null) {
                DataBinding db = bindings[propName];

                string persistPropName = propName.Replace('.', '-');

                if (db == null) {
                    Behavior.RemoveAttribute(persistPropName, true);
                }
                else {
                    string bindingExpr = "<%# " + db.Expression + " %>";
                    Behavior.SetAttribute(persistPropName, bindingExpr, true);

                    if (persistPropName.IndexOf('-') < 0) {
                        // We only reset top-level properties to be consistent with
                        // what we do the other way around, i.e., when a databound
                        // property value is set to some value
                        ResetPropertyValue(persistPropName);
                    }
                }
            }
            else {
                string[] removedBindings = bindings.RemovedBindings;
                foreach (string s in removedBindings) {
                    string persistPropName = s.Replace('.', '-');
                    Behavior.RemoveAttribute(persistPropName, true);
                }

                foreach (DataBinding db in bindings) {
                    string bindingExpr = "<%# " + db.Expression + " %>";
                    string persistPropName = db.PropertyName.Replace('.', '-');

                    Behavior.SetAttribute(persistPropName, bindingExpr, true);
                    if (persistPropName.IndexOf('-') < 0) {
                        // We only reset top-level properties to be consistent with
                        // what we do the other way around, i.e., when a databound
                        // property value is set to some value
                        ResetPropertyValue(persistPropName);
                    }
                }
            }
        }

        /// <include file='doc\UserControlDesigner.uex' path='docs/doc[@for="ControlDesigner.OnComponentChanged"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Delegate to handle component changed event.
        ///    </para>
        /// </devdoc>
        public virtual void OnComponentChanged(object sender, ComponentChangedEventArgs ce) {
            if (IsIgnoringComponentChanges) {
                return;
            }
            
            IComponent component = Component;
            Debug.Assert(ce.Component == component, "ControlDesigner::OnComponentChanged - Called from an unknown/invalid source object");

            if (DesignTimeElement == null) {
                return;
            }

            MemberDescriptor member = ce.Member;

            if (member != null) {
                // CONSIDER: Figure out a better and more correct way than looking for internal types...
                Type t = Type.GetType("System.ComponentModel.ReflectPropertyDescriptor, " + AssemblyRef.System);

                if ((member.GetType() != t) ||
                    (ce.NewValue != null && ce.NewValue == ce.OldValue)) {
                    // HACK: ideally, we would prevent the property descriptor from firing this change.
                    // This would tear large holes in the WFC architecture. Instead, we do the
                    // filtering ourselves in this evil fashion.

                    Debug.WriteLineIf(CompModSwitches.UserControlDesigner.TraceInfo, "    ...ignoring property descriptor of type: " + member.GetType().Name);
                    return;
                }

                if (((PropertyDescriptor)member).SerializationVisibility != DesignerSerializationVisibility.Hidden) {
                    // Set the dirty state upon changing persistable properties.
                    this.IsDirty = true;

                    PersistenceModeAttribute persistenceType = (PersistenceModeAttribute)member.Attributes[typeof(PersistenceModeAttribute)];
                    PersistenceMode mode = persistenceType.Mode;

                    if ((mode == PersistenceMode.Attribute) ||
                        (mode == PersistenceMode.InnerDefaultProperty) ||
                        (mode == PersistenceMode.EncodedInnerDefaultProperty)) {
                        string propName = member.Name;

                        // Check to see whether the property that was changed is data bound.
                        // If it is we need to remove it...
                        // For this rev, we're only doing this for the properties on the Component itself
                        // as we can't distinguish which subproperty of a complex type changed.
                        if (IsPropertyBound(propName) && (ce.Component == Component)) {
                            DataBindings.Remove(propName, false);
                            Behavior.RemoveAttribute(propName, true);
                        }
                    }
                    if (mode == PersistenceMode.Attribute) {
                        // For tag level properties ...

                        string propName = member.Name;

                        PersistProperties(propName, ce.Component, (PropertyDescriptor)member);
                        PersistAttribute((PropertyDescriptor)member, ce.Component, propName);
                    }
                }
            }
            else {
                // member is null, meaning that the whole component
                // could have changed and not just a single member.
                // This happens when a component is edited through a ComponentEditor.

                // Set the dirty state if more than one property is changed.
                this.IsDirty = true;

                PersistProperties(string.Empty, ce.Component, null);
                OnBindingsCollectionChanged(null);
            }

            // Update the WYSIWYG HTML.
            UpdateDesignTimeHtml();
        }
        
        /// <include file='doc\UserControlDesigner.uex' path='docs/doc[@for="ControlDesigner.OnControlResize"]/*' />
        /// <devdoc>
        ///     Notification from the identity behavior upon resizing the control in the designer.
        ///     This is only called when a user action causes the control to be resized.
        ///     Note that this method may be called several times during a resize process so as
        ///     to enable live-resize of the contents of the control.
        /// </devdoc>
        protected virtual void OnControlResize() {
        }
        
        /// <include file='doc\UserControlDesigner.uex' path='docs/doc[@for="ControlDesigner.PersistProperties"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Enumerates and persists all properties of a control
        ///       including sub properties.
        ///    </para>
        /// </devdoc>
        private string PersistProperties(string strPrefix, object parent, PropertyDescriptor propDesc) {    
            try {
                // Obtain the HTML element to which the associated behavior is attached to.
                Debug.Assert(parent != null, "parent is null");

                StringBuilder sb = new StringBuilder(strPrefix);     // property name of the parent property
                object objValue =  null;

                PropertyDescriptorCollection properties;

                // get all sub properties for parent property
                if (propDesc == null) {
                    objValue = parent;
                    properties = TypeDescriptor.GetProperties(parent,
                                                                   new Attribute[]{
                                                                       PersistenceModeAttribute.Attribute
                                                                   });
                }
                else {
                    objValue = propDesc.GetValue(parent); // value object for parent property
                    if (propDesc.SerializationVisibility != DesignerSerializationVisibility.Content) {
                        return sb.ToString();
                    }

                    properties = TypeDescriptor.GetProperties(propDesc.PropertyType,
                                                                   new Attribute[]{
                                                                       PersistenceModeAttribute.Attribute
                                                                       });
                }

                for (int i=0; i < properties.Count; i++) {

                    // Only deal with attributes that need to be persisted
                    if (properties[i].SerializationVisibility == DesignerSerializationVisibility.Hidden) {
                        continue;
                    }

                    // Skip design-time only properties such as DefaultModifiers
                    DesignOnlyAttribute doAttr = (DesignOnlyAttribute)properties[i].Attributes[typeof(DesignOnlyAttribute)];
                    if ((doAttr != null) && doAttr.IsDesignOnly) {
                        continue;
                    }
                    
                    // We don't want to persist these designer properties on a control
                    if (parent is WebUIControl) {
                        if (properties[i].Name.Equals("ID")) {
                            continue;
                        }
                    }

                    // The "objNewValue" is being moved to PersistAttributes(), but we leave
                    // this variable here in order to test if this is a System.Strings[] and
                    // break out of the for loop (which cannot be done from inside
                    // PersistAttributes()
                    
                    object objNewValue = properties[i].GetValue(objValue);

                    if (sb.Length != 0) {
                        sb.Append("-");
                    }

                    sb.Append(properties[i].Name);
                    sb = new StringBuilder(PersistProperties(sb.ToString(), objValue, properties[i]));

                    // check if this property has subproperties, if not, persist it as an attribute. Need to check 
                    // for NotifyParentPropertyAttribute to ensure it's really a bottom property
                    PropertyDescriptorCollection array = TypeDescriptor.GetProperties(properties[i].PropertyType,
                                                                    new Attribute[]{
                                                                       PersistenceModeAttribute.Attribute,
                                                                       NotifyParentPropertyAttribute.Yes  
                                                                       });
                    if (array == null || array.Count == 0 ) {
                        try {
                            PersistAttribute(properties[i], objValue, sb.ToString());
                        }
                        catch (Exception) {
                          //  Debug.Fail(e.ToString());
                        }
                    }

                    sb = new StringBuilder(strPrefix);
                }

                return sb.ToString();

            }
            catch(Exception e) {
                Debug.Fail(e.ToString());
                return string.Empty;
            }
        }
        
        /// <include file='doc\UserControlDesigner.uex' path='docs/doc[@for="ControlDesigner.PersistAttribute"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Persists individual attributes into HTML.
        ///    </para>
        /// </devdoc>
        private void PersistAttribute(PropertyDescriptor pd, object component, string strPropertyName) {
                            
              
            // if this is a parent property with sub property, don't bother to persist it
            PropertyDescriptorCollection properties = TypeDescriptor.GetProperties(pd.PropertyType,
                                                                       new Attribute[]{
                                                                           PersistenceModeAttribute.Attribute,
                                                                           NotifyParentPropertyAttribute.Yes
                                                                           });
            if (properties != null && properties.Count > 0) 
                return;

            object objNewValue = pd.GetValue(component);
            string strNewValue = null;
            if (objNewValue != null ) {
                if (pd.PropertyType.IsEnum) {
                    strNewValue = Enum.Format(pd.PropertyType, objNewValue, "G");
                }
                else {
                    TypeConverter converter = pd.Converter;
                    if (converter != null) {
                        strNewValue = converter.ConvertToInvariantString(null, objNewValue);
                    }
                    else {
                        strNewValue = objNewValue.ToString();
                    }
                }
            }

            // if this is the same as default value, don't persist it
            DefaultValueAttribute defAttr = (DefaultValueAttribute)pd.Attributes[typeof(DefaultValueAttribute)];
                                        
            // BUG: if user delete the property value from properties window and the default value is not empty,
            // we want to persist this empty string. However, since trident does not allow setting empty string value for
            // SetAttribute, we  pass in a white space for now....
            if ((objNewValue == null || strNewValue.Equals("")) && (defAttr != null && defAttr.Value != null && ShouldPersistBlankValue(defAttr.Value, pd.PropertyType))) {
                 Behavior.SetAttribute(strPropertyName, " ", true);
            }
            else {
                if (objNewValue == null ||
                    (defAttr != null && objNewValue.Equals(defAttr.Value)) ||
                    strNewValue == null || strNewValue.Length == 0 || strNewValue.Equals("NotSet") ||
                    (pd.PropertyType.IsArray && strNewValue.Length == 0)) {
                    Behavior.RemoveAttribute(strPropertyName, true);
                }
                else {
                    Behavior.SetAttribute(strPropertyName, strNewValue, true);
                }
            }
        }


        /// <devdoc>
        ///    <para>
        ///       Indicates whether we want to persist a blank string in the tag. We only want to do this for some types.
        ///    </para>
        /// </devdoc>
        private bool ShouldPersistBlankValue(object defValue, Type type) {
            Debug.Assert(defValue != null && type != null, "default value attribute or type can't be null!");
            if (type == typeof(string)) {
                return !defValue.Equals("");
            }
            else if (type == typeof(Color)) {
                return !(((Color)defValue).IsEmpty);
            }
            else if (type == typeof(FontUnit)) {
                return !(((FontUnit)defValue).IsEmpty);
            }
            else if (type == typeof(Unit)) {
                return !defValue.Equals(Unit.Empty);;
            }
            return false;
        }
        
        /// <include file='doc\UserControlDesigner.uex' path='docs/doc[@for="ControlDesigner.RaiseResizeEvent"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void RaiseResizeEvent() {
            OnControlResize();
        }
        
        /// <include file='doc\UserControlDesigner.uex' path='docs/doc[@for="ControlDesigner.RemoveSizeAttributes"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Maps the width, height, left and top style attributes to the respective properties
        ///       on the web control.
        ///    </para>
        /// </devdoc>
        private void RemoveSizeAttributes() {
            Debug.Assert(IsWebControl, "RemoveSizeAttributes should only be called for WebControls");

            NativeMethods.IHTMLElement htmlElement = (NativeMethods.IHTMLElement)DesignTimeElement;
            if (htmlElement == null) {
                return;
            }

            NativeMethods.IHTMLStyle htmlStyle = htmlElement.GetStyle();
            if (htmlStyle == null) {
                return;
            }

            try {

                string cssText = htmlStyle.GetCssText();
                if (cssText == null || cssText.Equals(String.Empty)){
                    return;
                }

                WebControl control = (WebControl)Component;

                // Obtain the left, top and position style attributes from Trident.

                int width = htmlStyle.GetPixelWidth();
                int height = htmlStyle.GetPixelHeight();
                
                if (width > 0) {
                    control.Width = width;
                    htmlElement.SetAttribute("Width", width, 0);
                }
                if (height > 0) {
                    control.Height = height;
                    htmlElement.SetAttribute("Height", height, 0);
                }
            }
            catch (Exception ex) {
                Debug.Fail(ex.ToString());
            }

            // Remove the width and height style attributes.
            htmlStyle.RemoveAttribute("width", /*lFlags*/ 0);
            htmlStyle.RemoveAttribute("height", /*lFlags*/ 0);
        }

        private void ResetPropertyValue(string property) {
            PropertyDescriptor propDesc = TypeDescriptor.GetProperties(Component.GetType())[property];

            if (propDesc != null) {
                IgnoreComponentChanges(true);
                try {
                    propDesc.ResetValue(Component);
                }
                finally {
                    IgnoreComponentChanges(false);
                }
            }
        }

        /// <include file='doc\UserControlDesigner.uex' path='docs/doc[@for="ControlDesigner.UpdateDesignTimeHtml"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Updates the design time HTML.
        ///    </para>
        /// </devdoc>
        public virtual void UpdateDesignTimeHtml() {
            if (IsWebControl && fRemoveInitialSize) {
                fRemoveInitialSize = false;
                RemoveSizeAttributes();
            }
            
            IHtmlControlDesignerBehavior behavior = Behavior;

            if (behavior != null && ReadOnly) {
                Debug.Assert(behavior is IControlDesignerBehavior, "Unexpected type of behavior for custom control");
                ((IControlDesignerBehavior)behavior).DesignTimeHtml = GetDesignTimeHtml();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\webcontroltoolboxitem.cs ===
//------------------------------------------------------------------------------
// <copyright file="WebControlToolBoxItem.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design {

    using System;
    using System.Design;
    using System.Reflection;
    using System.Runtime.Serialization;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Drawing;
    using System.Drawing.Design;
    using System.IO;
    using System.Web.UI;

    /// <include file='doc\WebControlToolBoxItem.uex' path='docs/doc[@for="WebControlToolboxItem"]/*' />
    /// <devdoc>
    /// </devdoc>
    [
    System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode),
    Serializable
    ]
    public class WebControlToolboxItem : ToolboxItem {

        private string toolData = null;
        private int persistChildren = -1;

        /// <include file='doc\WebControlToolBoxItem.uex' path='docs/doc[@for="WebControlToolboxItem.WebControlToolboxItem"]/*' />
        public WebControlToolboxItem() {
        }

        /// <include file='doc\WebControlToolBoxItem.uex' path='docs/doc[@for="WebControlToolboxItem.WebControlToolboxItem1"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.UI.Design.WebControlToolboxItem'/> class.</para>
        /// </devdoc>
        public WebControlToolboxItem(Type type) : base(type) {
            BuildMetadataCache(type);
        }

        private WebControlToolboxItem(SerializationInfo info, StreamingContext context) {
            Deserialize(info, context);
        }

        private void BuildMetadataCache(Type type) {
            toolData = ExtractToolboxData(type);
            persistChildren = ExtractPersistChildrenAttribute(type);
        }
        
        /// <include file='doc\WebControlToolBoxItem.uex' path='docs/doc[@for="WebControlToolboxItem.CreateComponentsCore"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       Creates objects from each Type contained in this <see cref='System.Drawing.Design.ToolboxItem'/>
        ///       , and adds
        ///       them to the specified designer.</para>
        /// </devdoc>
        protected override IComponent[] CreateComponentsCore(IDesignerHost host) {
            throw new Exception(SR.GetString(SR.Toolbox_OnWebformsPage));
        }

        /// <include file='doc\WebControlToolBoxItem.uex' path='docs/doc[@for="WebControlToolboxItem.Deserialize"]/*' />
        /// <internalonly/>
        protected override void Deserialize(SerializationInfo info, StreamingContext context) {
            base.Deserialize(info, context);

            toolData = info.GetString("ToolData");
            Debug.Assert(toolData != null);

            persistChildren = info.GetInt32("PersistChildren");
            Debug.Assert((persistChildren == 0) || (persistChildren == 1));
        }

        /// <devdoc>
        ///   Extracts the value of the PersistChildrenAttribute attribute associated with the tool
        /// </devdoc>
        private static int ExtractPersistChildrenAttribute(Type type) {
            Debug.Assert(type != null);

            if (type != null) {
                object[] attrs = type.GetCustomAttributes(typeof(PersistChildrenAttribute), /*inherit*/ true);
                if ((attrs != null) && (attrs.Length == 1)) {
                    Debug.Assert(attrs[0] is PersistChildrenAttribute);
                    PersistChildrenAttribute pca = (PersistChildrenAttribute)attrs[0];

                    return (pca.Persist ? 1 : 0);
                }
            }
            return (PersistChildrenAttribute.Default.Persist ? 1 : 0);
        }

        /// <devdoc>
        ///   Extracts the value of the ToolboxData attribute associated with the tool
        /// </devdoc>
        private static string ExtractToolboxData(Type type) {
            Debug.Assert(type != null);

            string toolData = String.Empty;
            if (type != null) {
                object[] attrs = type.GetCustomAttributes(typeof(ToolboxDataAttribute), /*inherit*/ false);
                if ((attrs != null) && (attrs.Length == 1)) {
                    Debug.Assert(attrs[0] is ToolboxDataAttribute);
                    ToolboxDataAttribute toolDataAttr = (ToolboxDataAttribute)attrs[0];

                    toolData = toolDataAttr.Data;
                }
                else {
                    string typeName = type.Name;
                    toolData = "<{0}:" + typeName + " runat=\"server\"></{0}:" + typeName + ">";
                }
            }

            return toolData;
        }

        /// <include file='doc\WebControlToolBoxItem.uex' path='docs/doc[@for="WebControlToolboxItem.GetToolAttributeValue"]/*' />
        public object GetToolAttributeValue(IDesignerHost host, Type attributeType) {
            if (attributeType == typeof(PersistChildrenAttribute)) {
                if (persistChildren == -1) {
                    Type toolType = GetToolType(host);
                    persistChildren = ExtractPersistChildrenAttribute(toolType);
                }

                return ((persistChildren == 1) ? true : false);
            }

            throw new ArgumentException("attributeType");
        }

        /// <include file='doc\WebControlToolBoxItem.uex' path='docs/doc[@for="WebControlToolboxItem.GetToolHtml"]/*' />
        /// <devdoc>
        ///    <para>Gets the toolbox HTML that represents the corresponding web control on the design surface.</para>
        /// </devdoc>
        public string GetToolHtml(IDesignerHost host) {
            if (toolData != null) {
                return toolData;
            }

            // Create the HTML data that is to be droppped.
            Type toolType = GetToolType(host);
            toolData = ExtractToolboxData(toolType);

            return toolData;
        }

        /// <include file='doc\WebControlToolBoxItem.uex' path='docs/doc[@for="WebControlToolboxItem.GetToolType"]/*' />
        public Type GetToolType(IDesignerHost host) {
            if (host == null) {
                throw new ArgumentNullException();
            }
                
            return GetType(host, AssemblyName, TypeName, true);
        }

        /// <include file='doc\WebControlToolBoxItem.uex' path='docs/doc[@for="WebControlToolboxItem.Initialize"]/*' />
        public override void Initialize(Type type) {
            base.Initialize(type);
            BuildMetadataCache(type);
        }

        /// <include file='doc\WebControlToolBoxItem.uex' path='docs/doc[@for="WebControlToolboxItem.Serialize"]/*' />
        /// <internalonly/>
        protected override void Serialize(SerializationInfo info, StreamingContext context) {
            base.Serialize(info, context);
            if (toolData != null) {
                info.AddValue("ToolData", toolData);
            }
            if (persistChildren != -1) {
                info.AddValue("PersistChildren", persistChildren);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\webcontrolpersister.cs ===
//------------------------------------------------------------------------------
// <copyright file="WebControlPersister.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design {

    using System;
    using System.Web;
    using System.Web.UI;
    using System.Web.UI.HtmlControls;
    using System.Web.UI.WebControls;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.IO;
    using System.Reflection;
    using System.Text;
    using AttributeCollection = System.Web.UI.AttributeCollection;

    /// <include file='doc\WebControlPersister.uex' path='docs/doc[@for="ControlPersister"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides helper functions used in persisting Controls.
    ///    </para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public sealed class ControlPersister {

        /// <include file='doc\WebControlPersister.uex' path='docs/doc[@for="ControlPersister.ControlPersister"]/*' />
        /// <devdoc>
        ///    We don't want instances of this class to be created, so mark
        ///    the constructor as private.
        /// </devdoc>
        private ControlPersister() {
        }

        /// <include file='doc\WebControlPersister.uex' path='docs/doc[@for="ControlPersister.GetDeclarativeType"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the delarative type for the
        ///       specified type.
        ///    </para>
        /// </devdoc>
        private static string GetDeclarativeType(Type type, IDesignerHost host) {
            Debug.Assert(host != null, "Need an IDesignerHost to create declarative type names");
            string declarativeType = null;

            if (host != null) {
                IWebFormReferenceManager refMgr =
                    (IWebFormReferenceManager)host.GetService(typeof(IWebFormReferenceManager));
                Debug.Assert(refMgr != null, "Did not get back IWebFormReferenceManager service from host.");

                if (refMgr != null) {
                    string tagPrefix = refMgr.GetTagPrefix(type);
                    if ((tagPrefix != null) && (tagPrefix.Length != 0)) {
                        declarativeType = tagPrefix + ":" + type.Name;
                    }
                }
            }

            if (declarativeType == null) {
                declarativeType = type.FullName;
            }

            return declarativeType;
        }

        /// <include file='doc\WebControlPersister.uex' path='docs/doc[@for="ControlPersister.PersistCollectionProperty"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Persists a collection property.
        ///    </para>
        /// </devdoc>
        private static void PersistCollectionProperty(TextWriter sw, object component, PropertyDescriptor propDesc, PersistenceMode persistMode, IDesignerHost host) {
            Debug.Assert(typeof(ICollection).IsAssignableFrom(propDesc.PropertyType),
                "Invalid collection property : " + propDesc.Name);

            ICollection propValue = (ICollection)propDesc.GetValue(component);
            if ((propValue == null) || (propValue.Count == 0))
                return;

            sw.WriteLine();
            if (persistMode == PersistenceMode.InnerProperty) {
                sw.Write('<');
                sw.Write(propDesc.Name);
                sw.WriteLine('>');
            }

            IEnumerator e = propValue.GetEnumerator();
            while (e.MoveNext()) {
                object collItem = e.Current;
                string itemTypeName = GetDeclarativeType(collItem.GetType(), host);
                
                sw.Write("<");
                sw.Write(itemTypeName);
                PersistAttributes(sw, collItem, String.Empty, null);
                sw.Write(">");
                
                if (collItem is Control) {
                    PersistChildrenAttribute pca =
                        (PersistChildrenAttribute)TypeDescriptor.GetAttributes(collItem.GetType())[typeof(PersistChildrenAttribute)];

                    // asurt 106696: ensure the parent control's visibility is set to true.
                    Control parentControl = (Control)collItem;

                    bool oldVisible = parentControl.Visible;
                    try {
                        parentControl.Visible = true;
                        if (pca.Persist == true) {
                            if (parentControl.HasControls()) {
                                PersistChildControls(sw, parentControl.Controls, host);
                            }
                        }
                        else {
                            PersistInnerProperties(sw, collItem, host);
                        }
                    }
                    finally {
                        parentControl.Visible = oldVisible;
                    }
                }
                else {
                    PersistInnerProperties(sw, collItem, host);
                }
                
                sw.Write("</");
                sw.Write(itemTypeName);
                sw.WriteLine(">");
            }

            if (persistMode == PersistenceMode.InnerProperty) {
                sw.Write("</");
                sw.Write(propDesc.Name);
                sw.WriteLine('>');
            }
        }

        /// <include file='doc\WebControlPersister.uex' path='docs/doc[@for="ControlPersister.PersistComplexProperty"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Persists a complex property.
        ///    </para>
        /// </devdoc>
        private static void PersistComplexProperty(TextWriter sw, object component, PropertyDescriptor propDesc, IDesignerHost host) {
            object propValue = propDesc.GetValue(component);

            if (propValue == null) {
                return;
            }

            StringWriter tagProps = new StringWriter();
            StringWriter innerProps = new StringWriter();

            PersistAttributes(tagProps, propValue, String.Empty, null);
            PersistInnerProperties(innerProps, propValue, host);

            // the rule here is that if a complex property has all its subproperties
            // in the default state, then it itself is in the default state.
            // When this is the case, there shouldn't be any tag properties or inner properties
            if ((tagProps.GetStringBuilder().Length != 0) ||
                (innerProps.GetStringBuilder().Length != 0)) {

                sw.WriteLine();
                sw.Write('<');
                sw.Write(propDesc.Name);
                sw.Write(tagProps.ToString());
                sw.WriteLine(">");

                string innerPropsString = innerProps.ToString();
                sw.Write(innerPropsString);
                if (innerPropsString.Length != 0) {
                    sw.WriteLine();
                }

                sw.Write("</");
                sw.Write(propDesc.Name);
                sw.WriteLine('>');
            }
        }

        /// <include file='doc\WebControlPersister.uex' path='docs/doc[@for="ControlPersister.PersistDataBindings"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Persists the data bindings of the specified control using the specified
        ///       string writer.
        ///    </para>
        /// </devdoc>
        private static void PersistDataBindings(TextWriter sw, Control control) {
            DataBindingCollection bindings = ((IDataBindingsAccessor)control).DataBindings;
            IEnumerator bindingEnum = bindings.GetEnumerator();

            while (bindingEnum.MoveNext()) {
                DataBinding db = (DataBinding)bindingEnum.Current;
                string persistPropName = db.PropertyName.Replace('.', '-');

                sw.Write(" ");
                sw.Write(persistPropName);
                sw.Write("='<%# ");
                sw.Write(HttpUtility.HtmlEncode(db.Expression));
                sw.Write(" %>'");
            }
        }

        /// <include file='doc\WebControlPersister.uex' path='docs/doc[@for="ControlPersister.PersistInnerProperties"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a string that can persist the inner properties of a control.
        ///    </para>
        /// </devdoc>
        public static string PersistInnerProperties(object component, IDesignerHost host) {
            StringWriter sw = new StringWriter();

            PersistInnerProperties(sw, component, host);
            return sw.ToString();
        }

        /// <include file='doc\WebControlPersister.uex' path='docs/doc[@for="ControlPersister.PersistInnerProperties1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Persists the inner properties of the control.
        ///    </para>
        /// </devdoc>
        public static void PersistInnerProperties(TextWriter sw, object component, IDesignerHost host) {
            PropertyDescriptorCollection propDescs = TypeDescriptor.GetProperties(component);

            for (int i = 0; i < propDescs.Count; i++) {
                // Only deal with inner attributes that need to be persisted
                if (propDescs[i].SerializationVisibility == DesignerSerializationVisibility.Hidden)
                    continue;

                PersistenceModeAttribute persistenceMode = (PersistenceModeAttribute)propDescs[i].Attributes[typeof(PersistenceModeAttribute)];
                if (persistenceMode.Mode == PersistenceMode.Attribute) {
                    continue;
                }
                    
                if (propDescs[i].PropertyType == typeof(string)) {
                    // String based property...
                    
                    DataBindingCollection dataBindings = null;
                    if (component is IDataBindingsAccessor) {
                        dataBindings = ((IDataBindingsAccessor)component).DataBindings;
                    }
                    if (dataBindings == null || dataBindings[propDescs[i].Name] == null) {
                        PersistenceMode mode = persistenceMode.Mode;
                        if ((mode == PersistenceMode.InnerDefaultProperty) ||
                            (mode == PersistenceMode.EncodedInnerDefaultProperty)) {
                            PersistStringProperty(sw, component, propDescs[i], mode);
                        }
                        else {
                            Debug.Fail("Cannot persist inner string property marked with PersistenceMode.InnerProperty");
                        }
                    }
                }
                else if (typeof(ICollection).IsAssignableFrom(propDescs[i].PropertyType)) {
                    // Collection based property...
                    if ((persistenceMode.Mode == PersistenceMode.InnerProperty) ||
                        (persistenceMode.Mode == PersistenceMode.InnerDefaultProperty)) {
                        PersistCollectionProperty(sw, component, propDescs[i], persistenceMode.Mode, host);
                    }
                    else {
                        Debug.Fail("Cannot persist collection property " + propDescs[i].Name + " not marked with PersistenceMode.InnerProperty or PersistenceMode.InnerDefaultProperty");
                    }
                }
                else if (typeof(ITemplate).IsAssignableFrom(propDescs[i].PropertyType)) {
                    // Template based property...
                    if (persistenceMode.Mode == PersistenceMode.InnerProperty) {
                        PersistTemplateProperty(sw, component, propDescs[i]);
                    }
                    else {
                        Debug.Fail("Cannot persist template property " + propDescs[i].Name + " not marked with PersistenceMode.InnerProperty");
                    }
                }
                else {
                    // Other complex property...
                    if (persistenceMode.Mode == PersistenceMode.InnerProperty) {
                        PersistComplexProperty(sw, component, propDescs[i], host);
                    }
                    else {
                        Debug.Fail("Cannot persist complex property " + propDescs[i].Name + " not marked with PersistenceMode.InnerProperty");
                    }
                }
            }
        }

        /// <include file='doc\WebControlPersister.uex' path='docs/doc[@for="ControlPersister.PersistStringProperty"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Persists the properties of a
        ///       string.
        ///    </para>
        /// </devdoc>
        private static void PersistStringProperty(TextWriter sw, object component, PropertyDescriptor propDesc, PersistenceMode mode) {
            Debug.Assert(propDesc.PropertyType == typeof(string),
                "Invalid string property : " + propDesc.Name);
            Debug.Assert((mode == PersistenceMode.InnerDefaultProperty) || (mode == PersistenceMode.EncodedInnerDefaultProperty),
                         "Inner string properties must be marked as either InnerDefaultProperty or EncodedInnerDefaultProperty");

            object propValue = propDesc.GetValue(component);
            if (propValue == null) {
                return;
            }

            if (mode == PersistenceMode.InnerDefaultProperty) {
                sw.Write((string)propValue);
            }
            else {
                HttpUtility.HtmlEncode((string)propValue, sw);
            }
        }
        
        /// <include file='doc\WebControlPersister.uex' path='docs/doc[@for="ControlPersister.PersistAttributes"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Persists the properties of a tag.
        ///    </para>
        /// </devdoc>
        private static void PersistAttributes(TextWriter sw, object component, string prefix, PropertyDescriptor propDesc) {
            PropertyDescriptorCollection properties;
            string persistPrefix = String.Empty;
            object value = component;

            if (propDesc != null) {
                value = propDesc.GetValue(component);
                properties = TypeDescriptor.GetProperties(propDesc.PropertyType,
                                                               new Attribute[] {
                                                                   PersistenceModeAttribute.Attribute
                                                               });
            }
            else {
                properties = TypeDescriptor.GetProperties(component,
                                                               new Attribute[] {
                                                                   PersistenceModeAttribute.Attribute
                                                               });
            }

            if (value == null)
                return;

            if (prefix.Length != 0)
                persistPrefix = prefix + "-";

            DataBindingCollection dataBindings = null;
            bool isControl = (component is Control);
            if ((component is IDataBindingsAccessor))
                dataBindings = ((IDataBindingsAccessor)component).DataBindings;

            for (int i = 0; i < properties.Count; i++) {
            
                // Skip properties that are hidden to the serializer
                if (properties[i].SerializationVisibility == DesignerSerializationVisibility.Hidden) {
                    continue;
                }

                // Skip design-time only properties such as DefaultModifiers and Name
                DesignOnlyAttribute doAttr = (DesignOnlyAttribute)properties[i].Attributes[typeof(DesignOnlyAttribute)];
                if ((doAttr != null) && doAttr.IsDesignOnly) {
                    continue;
                }
                
                string propName = properties[i].Name;
                Type propType = properties[i].PropertyType;
                
                object obj = properties[i].GetValue(value);
                if (obj == null)
                    continue;

                DefaultValueAttribute defValAttr =
                    (DefaultValueAttribute)properties[i].Attributes[typeof(DefaultValueAttribute)];
                if ((defValAttr != null) && (obj.Equals(defValAttr.Value)))
                    continue;

                string persistName = propName;
                if (prefix.Length != 0)
                    persistName = persistPrefix + persistName;

                PropertyDescriptorCollection subProps = null;
                if (properties[i].SerializationVisibility == DesignerSerializationVisibility.Content) {
                    subProps = TypeDescriptor.GetProperties(propType);
                }
                if ((subProps == null) || (subProps.Count == 0)) {
                    string persistValue = null;

                    // TODO: Use consts or have DataBinding store both OM name and persist name
                    DataBinding db = null;
                    if (dataBindings != null)
                        db = dataBindings[persistName.Replace('.', '-')];
                    
                    if (db == null) {
                        if (propType.IsEnum) {
                            persistValue = Enum.Format(propType, obj, "G");
                        }
                        else if (propType == typeof(string)) {
                            persistValue = HttpUtility.HtmlEncode(obj.ToString());
                        }
                        else {
                            TypeConverter converter = properties[i].Converter;
                            if (converter != null) {
                                persistValue = converter.ConvertToInvariantString(null, obj);
                            }
                            else {
                                persistValue = obj.ToString();
                            }
                            persistValue = HttpUtility.HtmlEncode(persistValue);
                        }

                        if ((persistValue == null) ||
                            (persistValue.Equals("NotSet")) ||
                            (propType.IsArray && (persistValue.Length == 0)))
                            continue;

                        sw.Write(" ");
                        sw.Write(persistName);
                        sw.Write("=\"");

                        sw.Write(persistValue);
                        sw.Write("\"");
                    }
                }
                else {
                    // there are sub properties, don't persist this object, but
                    // recursively persist the subproperties.
                    PersistAttributes(sw, obj, persistName, null);
                }
            }

            // Persist all the databindings on this control
            if (isControl) {
                PersistDataBindings(sw, (Control)component);

                AttributeCollection expandos = null;
                if (component is WebControl) {
                    expandos = ((WebControl)component).Attributes;
                }
                else if (component is HtmlControl) {
                    expandos = ((HtmlControl)component).Attributes;
                }
                else if (component is UserControl) {
                    expandos = ((UserControl)component).Attributes;
                }

                if (expandos != null) {
                    foreach (string key in expandos.Keys) {
                        sw.Write(" ");
                        sw.Write(key);
                        sw.Write("=\"");
                        sw.Write(expandos[key]);
                        sw.Write("\"");
                    }
                }
            }
        }

        /// <include file='doc\WebControlPersister.uex' path='docs/doc[@for="ControlPersister.PersistTemplateProperty"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Persists a template property including the specified persistance mode,
        ///       string writer and property descriptor.
        ///    </para>
        /// </devdoc>
        private static void PersistTemplateProperty(TextWriter sw, object component, PropertyDescriptor propDesc) {
            Debug.Assert(typeof(ITemplate).IsAssignableFrom(propDesc.PropertyType),
                         "Invalid template property : " + propDesc.Name);

            ITemplate template = (ITemplate)propDesc.GetValue(component);
            if (template == null) {
                return;
            }

            string templateContent;
            
            Debug.Assert(template is TemplateBuilder, "Unexpected ITemplate implementation.");
            if (template is TemplateBuilder) {
                templateContent = ((TemplateBuilder)template).Text;
            }
            else {
                templateContent = String.Empty;
            }

            sw.WriteLine();
            sw.Write('<');
            sw.Write(propDesc.Name);
            sw.Write('>');
            if (!templateContent.StartsWith("\r\n")) {
                sw.WriteLine();
            }
            
            sw.Write(templateContent);

            if (!templateContent.EndsWith("\r\n")) {
                sw.WriteLine();
            }
            sw.Write("</");
            sw.Write(propDesc.Name);
            sw.WriteLine('>');
        }

        /// <include file='doc\WebControlPersister.uex' path='docs/doc[@for="ControlPersister.PersistControl"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a string that can
        ///       persist a control.
        ///    </para>
        /// </devdoc>
        public static string PersistControl(Control control) {
            StringWriter sw = new StringWriter();

            PersistControl(sw, control);
            return sw.ToString();
        }

        /// <include file='doc\WebControlPersister.uex' path='docs/doc[@for="ControlPersister.PersistControl1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns a string that can
        ///       persist a control.
        ///    </para>
        /// </devdoc>
        public static string PersistControl(Control control, IDesignerHost host) {
            StringWriter sw = new StringWriter();

            PersistControl(sw, control, host);
            return sw.ToString();
        }

        /// <include file='doc\WebControlPersister.uex' path='docs/doc[@for="ControlPersister.PersistControl2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Persists a control using the
        ///       specified string writer.
        ///    </para>
        /// </devdoc>
        public static void PersistControl(TextWriter sw, Control control) {
            if (control is LiteralControl) {
                PersistLiteralControl(sw, (LiteralControl)control);
                return;
            }
            if (control is DesignerDataBoundLiteralControl) {
                PersistDataBoundLiteralControl(sw, (DesignerDataBoundLiteralControl)control);
                return;
            }

            ISite site = control.Site;
            if (site == null) {
                IComponent baseComponent = (IComponent)control.Page;
                Debug.Assert(baseComponent != null, "Control does not have its Page set!");
                if (baseComponent != null) {
                    site = baseComponent.Site;
                }
            }

            IDesignerHost host = null;
            if (site != null) {
                host = (IDesignerHost)site.GetService(typeof(IDesignerHost));
            }

            Debug.Assert(host != null, "Did not get a valid IDesignerHost reference. Expect persistence problems!");

            PersistControl(sw, control, host);
        }

        /// <include file='doc\WebControlPersister.uex' path='docs/doc[@for="ControlPersister.PersistControl3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Persists a control using the
        ///       specified string writer.
        ///    </para>
        /// </devdoc>
        public static void PersistControl(TextWriter sw, Control control, IDesignerHost host) {
            // Literals and DataBoundLiterals must be handled specially, since they
            // don't have a tag around them
            if (control is LiteralControl) {
                PersistLiteralControl(sw, (LiteralControl)control);
                return;
            }
            if (control is DesignerDataBoundLiteralControl) {
                PersistDataBoundLiteralControl(sw, (DesignerDataBoundLiteralControl)control);
                return;
            }

            Debug.Assert(host != null, "Did not get a valid IDesignerHost reference. Expect persistence problems!");

            string tagName = null;
            bool isUserControl = false;

            if (control is HtmlControl) {
                tagName = ((HtmlControl)control).TagName;
            }
            else if (control is UserControl) {
                tagName = ((IUserControlDesignerAccessor)control).TagName;
                Debug.Assert((tagName != null) && (tagName.Length != 0));
                
                if (tagName.Length == 0) {
                    // not enough information to go any further... no options, other than to throw this control out
                    return;
                }
                
                isUserControl = true;
            }
            else {
                tagName = GetDeclarativeType(control.GetType(), host);
            }

            sw.Write('<');
            sw.Write(tagName);
            sw.Write(" runat=\"server\"");
            PersistAttributes(sw, control, String.Empty, null);
            sw.Write('>');

            if (isUserControl == false) {
                PersistChildrenAttribute pca =
                    (PersistChildrenAttribute)TypeDescriptor.GetAttributes(control.GetType())[typeof(PersistChildrenAttribute)];

                // asurt 106696: Ensure parent control's visibility is true.
                bool oldVisible = control.Visible;

                try {
                    control.Visible = true;
                    if (pca.Persist == true) {
                        if (control.HasControls()) {
                            PersistChildControls(sw, control.Controls, host);
                        }
                    }
                    else {
                        // controls marked with LiteralContent == true shouldn't have
                        // children in their persisted form. They only build children
                        // collections at runtime.

                        PersistInnerProperties(sw, control, host);
                    }
                }
                finally {
                    control.Visible = oldVisible;
                }
            }
            else {
                string innerText = ((IUserControlDesignerAccessor)control).InnerText;
                if ((innerText != null) && (innerText.Length != 0)) {
                    sw.Write(innerText);
                }
            }

            sw.Write("</");
            sw.Write(tagName);
            sw.WriteLine('>');
        }

        /// <include file='doc\WebControlPersister.uex' path='docs/doc[@for="ControlPersister.PersistChildControls"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Persists the child controls of
        ///       the control using the specified string writer.
        ///    </para>
        /// </devdoc>
        private static void PersistChildControls(TextWriter sw, ControlCollection controls, IDesignerHost host) {
            int children = controls.Count;
  
            for (int i = 0; i < children; i++) {
                PersistControl(sw, controls[i], host);
            }
        }

        private static void PersistDataBoundLiteralControl(TextWriter sw, DesignerDataBoundLiteralControl control) {
            Debug.Assert(((IDataBindingsAccessor)control).HasDataBindings == true);

            DataBindingCollection bindings = ((IDataBindingsAccessor)control).DataBindings;
            DataBinding textBinding = bindings["Text"];
            Debug.Assert(textBinding != null, "Did not get a Text databinding from DesignerDataBoundLiteralControl");
            
            if (textBinding != null) {
                sw.Write("<%# ");
                sw.Write(textBinding.Expression);
                sw.Write(" %>");
            }
        }

        private static void PersistLiteralControl(TextWriter sw, LiteralControl control) {
            Debug.Assert(control.Text != null);
            sw.Write(control.Text);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\xmlurleditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlUrlEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design {
    
    using System.Design;
    
    /// <include file='doc\XmlUrlEditor.uex' path='docs/doc[@for="XmlUrlEditor"]/*' />
    /// <devdoc>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public class XmlUrlEditor: UrlEditor {

        /// <include file='doc\XmlUrlEditor.uex' path='docs/doc[@for="XmlUrlEditor.Caption"]/*' />
        /// <devdoc>
        /// </devdoc>
        protected override string Caption {
            get {
                return SR.GetString(SR.UrlPicker_XmlCaption);
            }
        }

        /// <include file='doc\XmlUrlEditor.uex' path='docs/doc[@for="XmlUrlEditor.Filter"]/*' />
        /// <devdoc>
        /// </devdoc>
        protected override string Filter {
            get {
                return SR.GetString(SR.UrlPicker_XmlFilter);
            }
        }

        /// <include file='doc\XmlUrlEditor.uex' path='docs/doc[@for="XmlUrlEditor.Options"]/*' />
        /// <devdoc>
        /// </devdoc>
        protected override UrlBuilderOptions Options {
            get {
                return UrlBuilderOptions.NoAbsolute;
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\xslurleditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="XslUrlEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design {
    
    using System.Design;
    
    /// <include file='doc\XslUrlEditor.uex' path='docs/doc[@for="XslUrlEditor"]/*' />
    /// <devdoc>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public class XslUrlEditor: UrlEditor {

        /// <include file='doc\XslUrlEditor.uex' path='docs/doc[@for="XslUrlEditor.Caption"]/*' />
        /// <devdoc>
        /// </devdoc>
        protected override string Caption {
            get {
                return SR.GetString(SR.UrlPicker_XslCaption);
            }
        }

        /// <include file='doc\XslUrlEditor.uex' path='docs/doc[@for="XslUrlEditor.Filter"]/*' />
        /// <devdoc>
        /// </devdoc>
        protected override string Filter {
            get {
                return SR.GetString(SR.UrlPicker_XslFilter);
            }
        }

        /// <include file='doc\XslUrlEditor.uex' path='docs/doc[@for="XslUrlEditor.Options"]/*' />
        /// <devdoc>
        /// </devdoc>
        protected override UrlBuilderOptions Options {
            get {
                return UrlBuilderOptions.NoAbsolute;
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\xmlfileeditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlFileEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design {
    
    using System.Runtime.InteropServices;

    using System.Diagnostics;
    using System;
    using System.Design;
    using System.IO;
    using System.Collections;
    using System.ComponentModel;
    using System.Windows.Forms;
    using System.Drawing;
    using System.Drawing.Design;
    
    using System.Windows.Forms.Design;
    using System.Windows.Forms.ComponentModel;
    using System.Web.UI.Design.Util;

    /// <include file='doc\XmlFileEditor.uex' path='docs/doc[@for="XmlFileEditor"]/*' />
    /// <devdoc>
    ///    <para>Provides an editor for visually picking an XML File.</para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public class XmlFileEditor : UITypeEditor {

        internal FileDialog fileDialog = null;
        
        /// <include file='doc\XmlFileEditor.uex' path='docs/doc[@for="XmlFileEditor.EditValue"]/*' />
        /// <devdoc>
        ///      Edits the given object value using the editor style provided by
        ///      GetEditorStyle.  A service provider is provided so that any
        ///      required editing services can be obtained.
        /// </devdoc>
        public override object EditValue(ITypeDescriptorContext context,  IServiceProvider  provider, object value) {

            if (provider != null) {
                IWindowsFormsEditorService edSvc = (IWindowsFormsEditorService)provider.GetService(typeof(IWindowsFormsEditorService));

                if (edSvc != null) {
                    if (fileDialog == null) {
                        fileDialog = new OpenFileDialog();
                        fileDialog.Title = SR.GetString(SR.XMLFilePicker_Caption);
                        fileDialog.Filter = SR.GetString(SR.XMLFilePicker_Filter);
                    }

                    fileDialog.FileName = value.ToString();
                    if (fileDialog.ShowDialog() == DialogResult.OK) {
                        value = fileDialog.FileName;
                    }
                }
            }
            return value;
        }

        /// <include file='doc\XmlFileEditor.uex' path='docs/doc[@for="XmlFileEditor.GetEditStyle"]/*' />
        /// <devdoc>
        ///      Retrieves the editing style of the Edit method.  If the method
        ///      is not supported, this will return None.
        /// </devdoc>
        public override UITypeEditorEditStyle GetEditStyle(ITypeDescriptorContext context) {
            return UITypeEditorEditStyle.Modal;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\databindingui\designtimedatabinding.cs ===
//------------------------------------------------------------------------------
// <copyright file="DesignTimeDataBinding.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.DataBindingUI {

    using System;
    using System.Diagnostics;
    using System.Web.UI;
    using System.Globalization;
    
    /// <include file='doc\DesignTimeDataBinding.uex' path='docs/doc[@for="DesignTimeDataBinding"]/*' />
    /// <devdoc>
    /// </devdoc>
    //
    // TODO: Reconcile identifier validation with similar functionality in
    //       code generators...
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class DesignTimeDataBinding {

        private DataBinding runtimeDataBinding;

        private bool parsed;
        private DataBindingType bindingType;

        private string bindingContainer;
        private string bindingPath;
        private string bindingFormat;

        public DesignTimeDataBinding(string propName, Type propType, string expression) {
            this.runtimeDataBinding = new DataBinding(propName, propType, expression);
            this.parsed = false;
        }

        public DesignTimeDataBinding(string propName, Type propType, string reference, bool asReference) {
            Debug.Assert(asReference == true);

            this.runtimeDataBinding = new DataBinding(propName, propType, reference);
            this.bindingType = DataBindingType.Reference;
            this.parsed = true;
        }

        public DesignTimeDataBinding(string propName, Type propType, string bindngContainer, string bindingPath, string bindngFormat) {
            string expression = CreateDataBinderEvalExpression(bindingContainer, bindingPath, bindingFormat);

            this.runtimeDataBinding = new DataBinding(propName, propType, expression);
            this.bindingType = DataBindingType.DataBinderEval;
            this.bindingContainer = bindingContainer;
            this.bindingPath = bindingPath;
            this.bindingFormat = bindingFormat;
            this.parsed = true;
        }

        public DesignTimeDataBinding(DataBinding runtimeDataBinding) {
            this.runtimeDataBinding = runtimeDataBinding;
            this.parsed = false;
        }


        public string BindingContainer {
            get {
                Debug.Assert((parsed == true) && (bindingType == DataBindingType.DataBinderEval),
                             "BindingContainer only makes sense for DataBinder.Eval expressions.");
                return bindingContainer;
            }
        }

        public string BindingFormat {
            get {
                Debug.Assert((parsed == true) && (bindingType == DataBindingType.DataBinderEval),
                             "BindingFormat only makes sense for DataBinder.Eval expressions.");
                return bindingFormat;
            }
        }

        public string BindingPath {
            get {
                Debug.Assert((parsed == true) && (bindingType == DataBindingType.DataBinderEval),
                             "BindingPath only makes sense for DataBinder.Eval expressions.");
                return bindingPath;
            }
        }

        public DataBindingType BindingType {
            get {
                EnsureExpressionParsed();
                return bindingType;
            }
        }
        
        public string Expression {
            get {
                return runtimeDataBinding.Expression;
            }
        }

        public string Reference {
            get {
                Debug.Assert((parsed == true) && (bindingType == DataBindingType.Reference),
                             "Reference only makes sense for DataBinder.Eval expressions.");
                return runtimeDataBinding.Expression;
            }
        }

        public DataBinding RuntimeDataBinding {
            get {
                return runtimeDataBinding;
            }
        }
        

        public static string CreateDataBinderEvalExpression(string bindingContainer, string bindingPath, string bindingFormat) {
            if (bindingFormat.Length == 0) {
                return String.Format("DataBinder.Eval({0}, \"{1}\")",
                                     bindingContainer,
                                     bindingPath);
            }
            else {
                return String.Format("DataBinder.Eval({0}, \"{1}\", \"{2}\")",
                                     bindingContainer,
                                     bindingPath,
                                     bindingFormat);
            }
        }

        private void EnsureExpressionParsed() {
            if (parsed == false) {
                bindingType = DataBindingType.Custom;

                if (ParseDataBinderEvalExpression()) {
                    bindingType = DataBindingType.DataBinderEval;
                }
                else if (ParseReferenceExpression()) {
                    bindingType = DataBindingType.Reference;
                }

                parsed = true;
            }
        }

        private bool IsValidExpression(string expr) {
            Debug.Assert(expr.Length > 0);

            string[] exprParts = expr.Split(new char[] { '.' });
            bool valid = true;

            for (int i = 0; i < exprParts.Length; i++) {
                if ((exprParts[i].Length == 0) ||
                    (IsValidIndexedExpression(exprParts[i]) == false)) {
                    valid = false;
                    break;
                }
            }

            return valid;
        }

        private bool IsValidIdentifier(string word) {
            Debug.Assert(word.Length != 0);

            char ch = word[0];
            if ((Char.IsLetter(ch) == false) && (ch != '_')) {
                return false;
            }

            bool valid = true;
            for (int i = 1; i < word.Length; i++) {
                ch = word[i];

                if ((Char.IsLetterOrDigit(ch) == false) && (ch != '_')) {
                    valid = false;
                    break;
                }
            }

            return valid;
        }

        private bool IsValidIndexedExpression(string expr) {
            Debug.Assert(expr.Length > 0);

            int indexCounter = 0;
            char ch = expr[0];

            if ((Char.IsLetter(ch) == false) && (ch != '_') && (ch != '[') && (ch != '(')) {
                return false;
            }

            if ((ch == '[') || (ch == ')')) {
                indexCounter++;
            }

            bool valid = true;
            for (int i = 1; i < expr.Length; i++) {
                ch = expr[i];

                if ((Char.IsLetterOrDigit(ch) == false) && (ch != '_')) {
                    switch (ch) {
                        case '[':
                        case '(':
                            indexCounter++;
                            if (indexCounter != 1) {
                                // can't deal with nested index expressions
                                valid = false;
                            }
                            break;
                        case ']':
                        case ')':
                            if (indexCounter != 1) {
                                valid = false;
                            }
                            indexCounter--;
                            break;
                        case ' ':
                            if (indexCounter != 1) {
                                // spaces outside an index expression are not allowed
                                valid = false;
                            }
                            break;
                        default:
                            valid = false;
                            break;
                    }
                    if (valid == false)
                        break;
                }
            }

            return valid;
        }

        private bool ParseDataBinderEvalExpression() {
            string expression = this.Expression;
            string param1 = null;
            string param2 = null;
            string param3 = null;

            // must be atleast 'DataBinder.Eval(?,"?")' (case-insensitive comparison)
            if ((expression.Length < 22) ||
                (String.Compare(expression, 0, "DataBinder.Eval(", 0, 16, true, CultureInfo.InvariantCulture) != 0) ||
                (expression.EndsWith(")") == false)) {
                return false;
            }

            // get everything between the parens and ignore surrounding whitespace
            expression = expression.Substring(16, expression.Length - 17).Trim();

            int param1End = expression.IndexOf(',');
            if (param1End < 1)
                return false;

            param1 = expression.Substring(0, param1End);

            // get everything after param1
            expression = expression.Substring(param1End + 1, expression.Length - param1End - 1).Trim();

            int param2End = expression.IndexOf(',');
            if (param2End < 0) {
                // all of it is part of param2
                param2 = expression;

                // must be atleast "?"
                if ((param2.Length < 3) ||
                    (param2[0] != '"') || (param2[param2.Length - 1] != '"')) {
                    return false;
                }
                param2 = param2.Substring(1, param2.Length - 2);
            }
            else {
                param2 = expression.Substring(0, param2End);

                Debug.Assert(param2.Length > 1);
                if ((param2[0] != '"') || (param2[param2.Length - 1] != '"')) {
                    // not a valid string
                    return false;
                }
                param2 = param2.Substring(1, param2.Length - 2);

                // get everything after param2
                param3 = expression.Substring(param2End + 1, expression.Length - param2End - 1).Trim();

                // must be atleast "?" or shouldn't exist
                if ((param3.Length < 3) ||
                    (param3[0] != '"') || (param3[param3.Length - 1] != '"')) {
                    return false;
                }

                param3 = param3.Substring(1, param3.Length - 2);
            }

            Debug.Assert((param1 != null) && (param1.Length > 0));
            Debug.Assert((param2 != null) && (param2.Length > 0));
            Debug.Assert((param3 == null) || (param3.Length > 0));

            // got all the params we need... now see if they are usable

            if (IsValidIdentifier(param1) == false) {
                // for simple binding the first parameter must be a valid identifier
                // with just alphanumerics and '_'
                return false;
            }

            if (IsValidExpression(param2) == false) {
                // for simple binding the second parameter must be just identifiers
                // with optional index expressions
                return false;
            }

            // determined to be a simple DataBinder.Eval expression

            bindingContainer = param1;
            bindingPath = param2;
            bindingFormat = (param3 == null) ? String.Empty : param3;

            runtimeDataBinding.Expression =
                CreateDataBinderEvalExpression(bindingContainer, bindingPath, bindingFormat);

            return true;
        }

        private bool ParseReferenceExpression() {
            string expression = this.Expression;

            if (expression.Length != 0) {
                return IsValidIdentifier(expression);
            }

            return false;
        }

        public void SetDataBinderEvalExpression(string bindingContainer, string bindingPath, string bindingFormat) {
            this.bindingContainer = bindingContainer;
            this.bindingPath = bindingPath;
            this.bindingFormat = bindingFormat;

            this.parsed = true;
            this.bindingType = DataBindingType.DataBinderEval;

            runtimeDataBinding.Expression = CreateDataBinderEvalExpression(bindingContainer, bindingPath, bindingFormat);
        }

        public void SetCustomExpression(string expression) {
            runtimeDataBinding.Expression = expression;
            parsed = false;
        }

        public void SetReferenceExpression(string reference) {
            runtimeDataBinding.Expression = reference;

            this.parsed = true;
            this.bindingType = DataBindingType.Reference;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\databindingui\databindingtype.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataBindingType.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.DataBindingUI {

    /// <include file='doc\DataBindingType.uex' path='docs/doc[@for="DataBindingType"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies IDs for types of data
    ///       bindings recognized by the data binding UI.
    ///    </para>
    /// </devdoc>
    internal enum DataBindingType {

        /// <include file='doc\DataBindingType.uex' path='docs/doc[@for="DataBindingType.Custom"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates a custom, or other type of data binding.
        ///    </para>
        /// </devdoc>
        Custom = 0,

        /// <include file='doc\DataBindingType.uex' path='docs/doc[@for="DataBindingType.DataBinderEval"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates a data binding consisting of a DataBinderEval statement with
        ///       understood references which consist of parseable arguments.
        ///    </para>
        /// </devdoc>
        DataBinderEval = 1,

        /// <include file='doc\DataBindingType.uex' path='docs/doc[@for="DataBindingType.Reference"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates a data binding with a single reference identifier.
        ///    </para>
        /// </devdoc>
        Reference = 2
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\util\grouplabel.cs ===
//------------------------------------------------------------------------------
// <copyright file="GroupLabel.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

// GroupLabel.cs
//
// 6/10/99: nikhilko: created
//

namespace System.Web.UI.Design.Util {
    using System.Runtime.Serialization.Formatters;

    using System.Diagnostics;

    using System;
    using System.Windows.Forms;
    using System.Drawing;
    

    /// <include file='doc\GroupLabel.uex' path='docs/doc[@for="GroupLabel"]/*' />
    /// <devdoc>
    ///    A label control that draws an etched line beyond its text string
    ///    Do not use the AutoSize property with this control
    /// </devdoc>
    /// <internalonly/>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal sealed class GroupLabel : Label {

        /// <include file='doc\GroupLabel.uex' path='docs/doc[@for="GroupLabel.GroupLabel"]/*' />
        /// <devdoc>
        ///    Creates a new GroupLabel
        /// </devdoc>
        public GroupLabel() : base() {
            SetStyle(ControlStyles.UserPaint, true);
        }

        /// <include file='doc\GroupLabel.uex' path='docs/doc[@for="GroupLabel.OnPaint"]/*' />
        /// <devdoc>
        ///    Custom UI is painted here
        /// </devdoc>
        protected override void OnPaint(PaintEventArgs e) {
            Graphics g = e.Graphics;
            Rectangle r = ClientRectangle;
            string text = Text;

            Brush foreBrush = new SolidBrush(ForeColor);
            g.DrawString(text, Font, foreBrush, 0, 0);
            foreBrush.Dispose();

            int etchLeft = r.X;
            if (text.Length != 0) {
                Size sz = Size.Ceiling(g.MeasureString(text, Font));
                etchLeft += 4 + sz.Width;
            }
            int etchTop = r.Height / 2;

            g.DrawLine(SystemPens.ControlDark, etchLeft, etchTop, r.Width, etchTop);

            etchTop++;
            g.DrawLine(SystemPens.ControlLightLight, etchLeft, etchTop, r.Width, etchTop);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\util\colorcombobox.cs ===
//------------------------------------------------------------------------------
// <copyright file="ColorComboBox.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

// ColorComboBox.cs
//
// 12/22/98: Created: NikhilKo
//

namespace System.Web.UI.Design.Util {
    using System.Runtime.Serialization.Formatters;

    using System.Diagnostics;

    using System;
    using Microsoft.Win32;
    using System.ComponentModel;
    using System.Drawing;
    using System.Windows.Forms;
    using System.Globalization;
    
    /// <include file='doc\ColorComboBox.uex' path='docs/doc[@for="ColorComboBox"]/*' />
    /// <devdoc>
    ///   Standard combobox with standard sixteen colors in dropdown and a Color
    ///   property
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal sealed class ColorComboBox : ComboBox {

        private static readonly string[] COLOR_VALUES = new string[] {
            "Aqua", "Black", "Blue", "Fuchsia", "Gray", "Green", "Lime", "Maroon",
            "Navy", "Olive", "Purple", "Red", "Silver", "Teal", "White", "Yellow"
        };

        /// <include file='doc\ColorComboBox.uex' path='docs/doc[@for="ColorComboBox.ColorComboBox"]/*' />
        /// <devdoc>
        ///   Creates a new ColorComboBox
        /// </devdoc>
        public ColorComboBox() : base() {
        }


        /// <include file='doc\ColorComboBox.uex' path='docs/doc[@for="ColorComboBox.Color"]/*' />
        /// <devdoc>
        /// </devdoc>
        public string Color {
            get {
                int index = SelectedIndex;

                if (index != -1)
                    return COLOR_VALUES[index];
                else
                    return Text.Trim();
            }
            set {
                SelectedIndex = -1;
                Text = String.Empty;

                if (value == null) {
                    return;
                }

                string temp = value.Trim();
                if (temp.Length != 0) {
                    for (int i = 0; i < COLOR_VALUES.Length; i++) {
                        if (String.Compare(COLOR_VALUES[i], temp, true, CultureInfo.InvariantCulture) == 0) {
                            temp = COLOR_VALUES[i];
                            break;
                        }
                    }
                    this.Text = temp;
                }
            }
        }


        /// <include file='doc\ColorComboBox.uex' path='docs/doc[@for="ColorComboBox.OnHandleCreated"]/*' />
        /// <devdoc>
        /// </devdoc>
        protected override void OnHandleCreated(EventArgs e) {
            base.OnHandleCreated(e);
            if (!DesignMode && !RecreatingHandle) {
                Items.Clear();
                Items.AddRange(COLOR_VALUES);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\databindingui\databindingform.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataBindingForm.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.DataBindingUI {

    using System;
    using System.Design;
    using System.CodeDom;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Data;
    using System.Diagnostics;
    using System.Drawing;
    using System.Reflection;
    using System.Web.UI;
    using System.Web.UI.Design;
    using System.Web.UI.Design.Util;
    using System.Windows.Forms;
    using System.Windows.Forms.Design;

    using ASPControl = System.Web.UI.Control;
    using DataBinding = System.Web.UI.DataBinding;
    using DesignTimeData = System.Web.UI.Design.DesignTimeData;

    using Control = System.Windows.Forms.Control;
    using System.Globalization;
    
    /// <include file='doc\DataBindingForm.uex' path='docs/doc[@for="DataBindingForm"]/*' />
    /// <devdoc>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal sealed class DataBindingForm : Form {

        private readonly FormatDefinition[] defaultFormats = new FormatDefinition[] {
            FormatDefinition.nullFormat,
            FormatDefinition.generalFormat
        };

        private readonly FormatDefinition[] dateTimeFormats = new FormatDefinition[] {
            FormatDefinition.nullFormat,
            FormatDefinition.generalFormat,
            FormatDefinition.dtShortTime,
            FormatDefinition.dtLongTime,
            FormatDefinition.dtShortDate,
            FormatDefinition.dtLongDate,
            FormatDefinition.dtDateTime,
            FormatDefinition.dtFullDate
        };

        private readonly FormatDefinition[] numericFormats = new FormatDefinition[] {
            FormatDefinition.nullFormat,
            FormatDefinition.generalFormat,
            FormatDefinition.numNumber,
            FormatDefinition.numDecimal,
            FormatDefinition.numFixed,
            FormatDefinition.numCurrency,
            FormatDefinition.numScientific,
            FormatDefinition.numHex
        };

        private readonly FormatDefinition[] decimalFormats = new FormatDefinition[] {
            FormatDefinition.nullFormat,
            FormatDefinition.generalFormat,
            FormatDefinition.numNumber,
            FormatDefinition.numDecimal,
            FormatDefinition.numFixed,
            FormatDefinition.numCurrency,
            FormatDefinition.numScientific
        };


        private TreeView bindablePropsTree;
        private GroupLabel bindingGroup;
        private RadioButton simpleBindingRadio;
        private RadioButton customBindingRadio;
        private TreeView bindableValuesTree;
        private ComboBox formatCombo;
        private TextBox sampleText;
        private TextBox customExprText;
        private Button okButton;
        private Button cancelButton;
        private Button helpButton;

        private bool firstActivate;
        private bool loadingMode;
        private bool formatChanged;

        private ASPControl control;
        private  IServiceProvider  site;
        private Hashtable bindingCollection;
        private bool bindingsDirty;

        private BindablePropertyNode currentNode;
        private DesignTimeDataBinding currentDataBinding;
        private bool currentBindingDirty;

        private BindableValueNode unboundNode;

        private object sampleFormattableObject;

        /// <include file='doc\DataBindingForm.uex' path='docs/doc[@for="DataBindingForm.DataBindingForm"]/*' />
        /// <devdoc>
        /// </devdoc>
        public DataBindingForm(ASPControl control,  IServiceProvider  site) {
            Debug.Assert(control != null, "Null control passed to DataBinding dialog");
            Debug.Assert(site != null, "Null site passed to DataBinding dialog");

            this.control = control;
            this.site = site;

            InitForm();
            firstActivate = true;
        }


        /// <include file='doc\DataBindingForm.uex' path='docs/doc[@for="DataBindingForm.GenerateBindingExpression"]/*' />
        /// <devdoc>
        /// </devdoc>
        private string GenerateBindingExpression() {
            Debug.Assert(simpleBindingRadio.Checked);

            string expression = String.Empty;
            TreeNode selectedNode = bindableValuesTree.SelectedNode;

            if ((selectedNode != null) && !selectedNode.Equals(unboundNode)) {
                BindableValueNode valueNode = (BindableValueNode)selectedNode;

                if (valueNode.BindingType == DataBindingType.DataBinderEval) {
                    string bindingContainer = valueNode.BindingContainer;
                    string bindingPath = valueNode.BindingPath;
                    string bindingFormat = GetCurrentFormatText();

                    expression =
                        DesignTimeDataBinding.CreateDataBinderEvalExpression(bindingContainer,
                                                                         bindingPath,
                                                                         bindingFormat);
                }
                else {
                    Debug.Assert(valueNode.BindingType == DataBindingType.Reference);
                    expression = valueNode.BindingReference;
                }
            }

            return expression;
        }

        /// <include file='doc\DataBindingForm.uex' path='docs/doc[@for="DataBindingForm.GetCurrentFormatText"]/*' />
        /// <devdoc>
        /// </devdoc>
        private string GetCurrentFormatText() {
            string formatText = String.Empty;
            object selFormat = formatCombo.SelectedItem;

            if ((selFormat != null) && (selFormat is FormatDefinition)) {
                FormatDefinition format = (FormatDefinition)selFormat;

                formatText = format.Format;
            }
            else {
                formatText = formatCombo.Text;

                string trimmedText = formatText.Trim();
                if (trimmedText.Length == 0)
                    formatText = trimmedText;
            }

            return formatText;
        }

        /// <include file='doc\DataBindingForm.uex' path='docs/doc[@for="DataBindingForm.InitForm"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void InitForm() {
            Label instructionLabel = new Label();
            Label bindablePropsLabel = new Label();
            this.bindablePropsTree = new TreeView();
            this.bindingGroup = new GroupLabel();
            this.simpleBindingRadio = new RadioButton();
            this.customBindingRadio = new RadioButton();
            this.bindableValuesTree = new TreeView();
            Label formatLabel = new Label();
            this.formatCombo = new ComboBox();
            Label sampleLabel = new Label();
            this.sampleText = new TextBox();
            this.customExprText = new TextBox();
            this.okButton = new Button();
            this.cancelButton = new Button();
            this.helpButton = new Button();
            
            Font f = null;
            IUIService uiService = (IUIService)site.GetService(typeof(IUIService));
            if (uiService != null) {
                f = (Font)uiService.Styles["DialogFont"];
            }
            else {
                f = Control.DefaultFont;
            }

            ISite controlSite = control.Site;
            string controlName = String.Empty;
            if (controlSite != null) {
                controlName = controlSite.Name;
            }
            else {
                controlName = control.GetType().Name;
            }

            instructionLabel.SetBounds(8, 8, 488, 44);
            instructionLabel.Text = SR.GetString(SR.DBForm_Inst);
            instructionLabel.TabIndex = 0;
            instructionLabel.TabStop = false;

            bindablePropsLabel.SetBounds(8, 54, 188, 14);
            bindablePropsLabel.Text = SR.GetString(SR.DBForm_BindableProps);
            bindablePropsLabel.TabIndex = 1;
            bindablePropsLabel.TabStop = false;

            Image bindablePropsBitmap = new Bitmap(this.GetType(), "BindableProps.bmp");
            ImageList bindablePropsImageList = new ImageList();
            bindablePropsImageList.TransparentColor = Color.Teal;
            bindablePropsImageList.Images.AddStrip(bindablePropsBitmap);

            bindablePropsTree.SetBounds(8, 70, 180, 258);
            bindablePropsTree.TabIndex = 2;
            bindablePropsTree.HideSelection = false;
            bindablePropsTree.Indent = 5;
            bindablePropsTree.ImageList = bindablePropsImageList;
            bindablePropsTree.Sorted = true;
            bindablePropsTree.Text = "BindablePropertiesTree";
            bindablePropsTree.AfterSelect += new TreeViewEventHandler(this.OnAfterSelectBindableProps);

            bindingGroup.SetBounds(200, 54, 290, 14);
            bindingGroup.Text = String.Empty;
            bindingGroup.TabStop = false;
            bindingGroup.TabIndex = 3;

            simpleBindingRadio.SetBounds(204, 72, 200, 17);
            simpleBindingRadio.Text = SR.GetString(SR.DBForm_Simple);
            simpleBindingRadio.TabIndex = 4;
            simpleBindingRadio.FlatStyle = FlatStyle.System;
            simpleBindingRadio.CheckedChanged += new EventHandler(this.OnBindingTypeChanged);

            Image bindableValuesBitmap = new Bitmap(this.GetType(), "BindableValues.bmp");
            ImageList bindableValuesImageList = new ImageList();
            bindableValuesImageList.TransparentColor = Color.Teal;
            bindableValuesImageList.Images.AddStrip(bindableValuesBitmap);

            bindableValuesTree.SetBounds(214, 92, 280, 100);
            bindableValuesTree.TabIndex = 5;
            bindableValuesTree.HideSelection = false;
            bindableValuesTree.ImageList = bindableValuesImageList;
            bindableValuesTree.Sorted = true;
            bindableValuesTree.Text = "BindableValuesTree";
            bindableValuesTree.AfterSelect += new TreeViewEventHandler(this.OnAfterSelectBindableValues);
            bindableValuesTree.BeforeExpand += new TreeViewCancelEventHandler(this.OnBeforeExpandBindableValues);

            formatLabel.SetBounds(214, 198, 100, 14);
            formatLabel.Text = SR.GetString(SR.DBForm_Format);
            formatLabel.TabIndex = 6;
            formatLabel.TabStop = false;

            formatCombo.SetBounds(214, 214, 130, 21);
            formatCombo.DropDownWidth = 160;
            formatCombo.TabIndex = 7;
            formatCombo.Enabled = false;
            formatCombo.SelectionChangeCommitted += new EventHandler(this.OnSelChangedFormat);
            formatCombo.TextChanged += new EventHandler(this.OnTextChangedFormat);
            formatCombo.LostFocus += new EventHandler(this.OnLostFocusFormat);

            sampleLabel.SetBounds(358, 198, 100, 14);
            sampleLabel.Text = SR.GetString(SR.DBForm_Sample);
            sampleLabel.TabIndex = 8;
            sampleLabel.TabStop = false;

            sampleText.SetBounds(358, 214, 130, 21);
            sampleText.ReadOnly = true;
            sampleText.TabIndex = 9;
            sampleText.Enabled = false;

            customBindingRadio.SetBounds(204, 246, 200, 17);
            customBindingRadio.Text = SR.GetString(SR.DBForm_Custom);
            customBindingRadio.TabIndex = 10;
            customBindingRadio.FlatStyle = FlatStyle.System;
            customBindingRadio.CheckedChanged += new EventHandler(this.OnBindingTypeChanged);

            customExprText.Multiline = true;
            customExprText.SetBounds(214, 266, 280, 48);
            customExprText.ScrollBars = ScrollBars.Vertical;
            customExprText.TabIndex = 11;
            customExprText.TextChanged += new EventHandler(this.OnTextChangedCustomExpr);

            okButton.SetBounds(258, 332, 75, 23);
            okButton.Text = SR.GetString(SR.DBForm_OK);
            okButton.TabIndex = 12;
            okButton.FlatStyle = FlatStyle.System;
            okButton.Click += new EventHandler(this.OnClickOK);

            cancelButton.SetBounds(338, 332, 75, 23);
            cancelButton.Text = SR.GetString(SR.DBForm_Cancel);
            cancelButton.DialogResult = DialogResult.Cancel;
            cancelButton.TabIndex = 13;
            cancelButton.FlatStyle = FlatStyle.System;

            helpButton.SetBounds(418, 332, 75, 23);
            helpButton.Text = SR.GetString(SR.DBForm_Help);
            helpButton.TabIndex = 14;
            helpButton.FlatStyle = FlatStyle.System;
            helpButton.Click += new EventHandler(this.OnClickHelp);
            
            this.Text = String.Format(SR.GetString(SR.DBForm_Text), controlName);
            this.ClientSize = new Size(500, 364);
            this.FormBorderStyle = FormBorderStyle.FixedDialog;
            this.MaximizeBox = false;
            this.MinimizeBox = false;
            this.ShowInTaskbar = false;
            this.Icon = null;
            this.StartPosition = FormStartPosition.CenterParent;
            this.AutoScaleBaseSize = new Size(5, 13);
            this.Font = f;
            this.AcceptButton = okButton;
            this.CancelButton = cancelButton;
            this.HelpRequested += new HelpEventHandler(this.OnHelpRequested);
            
            this.Controls.Clear();
            this.Controls.AddRange(new Control[] {
                                    helpButton,
                                    cancelButton,
                                    okButton,
                                    customExprText,
                                    customBindingRadio,
                                    sampleText,
                                    sampleLabel,
                                    formatCombo,
                                    formatLabel,
                                    bindableValuesTree,
                                    simpleBindingRadio,
                                    bindingGroup,
                                    bindablePropsTree,
                                    bindablePropsLabel,
                                    instructionLabel
                                });
        }

        /// <include file='doc\DataBindingForm.uex' path='docs/doc[@for="DataBindingForm.LoadBindablePropertiesTree"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void LoadBindablePropertiesTree() {
            Debug.Assert(control != null, "Expected to have a valid control.");

            PropertyDescriptorCollection propDescs = TypeDescriptor.GetProperties(control);
            PropertyDescriptor defaultProperty = TypeDescriptor.GetDefaultProperty(control);
            string defaultPropName = (defaultProperty != null ? defaultProperty.Name : null);

            TreeNodeCollection nodes = bindablePropsTree.Nodes;
            TreeNode selectedNode = null;

            foreach (PropertyDescriptor pd in propDescs) {
                TreeNode node = LoadBindableProperty(pd, String.Empty, control, nodes);
                if (pd.Name.Equals(defaultPropName)) {
                    selectedNode = node;
                }
            }

            if ((selectedNode == null) && (nodes.Count != 0)) {
                int nodeCount = nodes.Count;
                for (int i = 0; i < nodeCount; i++) {
                    BindablePropertyNode node = (BindablePropertyNode)nodes[i];
                    if (node.Bound) {
                        selectedNode = node;
                        break;
                    }
                }
                if (selectedNode == null) {
                    selectedNode = nodes[0];
                }
            }
            if (selectedNode != null) {
                bindablePropsTree.SelectedNode = selectedNode;
            }
            UpdateEnabledState();
        }

        /// <include file='doc\DataBindingForm.uex' path='docs/doc[@for="DataBindingForm.LoadBindableProperty"]/*' />
        /// <devdoc>
        /// </devdoc>
        private TreeNode LoadBindableProperty(PropertyDescriptor propDesc, string parentName, object propContainer, TreeNodeCollection nodes) {
            BindablePropertyNode node = null;

            bool hasSubProperties = (propDesc.SerializationVisibility == DesignerSerializationVisibility.Content);
            string completeName;

            if (parentName.Length != 0)
                completeName = parentName + "." + propDesc.Name;
            else
                completeName = propDesc.Name;

            if (hasSubProperties) {
                node = new BindablePropertyNode(completeName, propDesc, false, false);
            }
            else if (propDesc.IsReadOnly == false) {
                BindableAttribute ba = (BindableAttribute)propDesc.Attributes[typeof(BindableAttribute)];

                if ((ba != null) && ba.Bindable) {
                    object binding = bindingCollection[completeName];
                    bool bound = (binding != null);
                    node = new BindablePropertyNode(completeName, propDesc, true, bound);
                }
            }

            if (node != null) {
                if (hasSubProperties) {
                    object propValue = propDesc.GetValue(propContainer);

                    PropertyDescriptorCollection propDescs = TypeDescriptor.GetProperties(propValue);
                    TreeNodeCollection propNodes = node.Nodes;

                    foreach (PropertyDescriptor pd in propDescs) {
                        LoadBindableProperty(pd, completeName, propValue, propNodes);
                    }

                    if (propNodes.Count != 0) {
                        nodes.Add(node);
                    }
                }
                else {
                    nodes.Add(node);
                }
            }

            return node;
        }

        /// <include file='doc\DataBindingForm.uex' path='docs/doc[@for="DataBindingForm.LoadBindableValuesTree"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void LoadBindableValuesTree() {
            // Add the (Unbound) node
            unboundNode = new UnboundBindableValueNode();
            bindableValuesTree.Nodes.Add(unboundNode);

            // Page node is always available
            PageBindableValueNode pageNode = new PageBindableValueNode();
            bindableValuesTree.Nodes.Add(pageNode);

            // DataSources and Components (only those that aren't controls) in the container
            IContainer container = (IContainer)site.GetService(typeof(IContainer));
            if (container != null) {
                ComponentCollection components = container.Components;
                if (components != null) {
                    int componentCount = components.Count;

                    foreach (IComponent comp in (IEnumerable)components) {
                        if (comp is ASPControl) {
                            // controls do not show up in the tree
                            continue;
                        }
                            
                        ISite componentSite = comp.Site;
                        if (componentSite == null)
                            continue;

                        string componentName = componentSite.Name;
                        if (componentName.Length == 0)
                            continue;

                        // components that should not appear in the designer do not appear in this
                        // dialog either
                        DesignTimeVisibleAttribute dtv =
                            (DesignTimeVisibleAttribute)TypeDescriptor.GetAttributes(comp)[typeof(DesignTimeVisibleAttribute)];
                        if (dtv.Visible == false) {
                            continue;
                        }

                        MemberAttributes modifiers = 0;
                        PropertyDescriptor modifierProp = TypeDescriptor.GetProperties(comp)["Modifiers"];

                        if (modifierProp != null) {
                            modifiers = (MemberAttributes)modifierProp.GetValue(comp);
                        }

                        if ((modifiers & MemberAttributes.AccessMask) == MemberAttributes.Private) {
                            // must be declared as public or protected
                            continue;
                        }

                        if (comp is IEnumerable) {
                            // datasources are special kinds of components
                            BindableValueNode compNode = new DataSourceBindableValueNode((IEnumerable)comp, componentName);
                            bindableValuesTree.Nodes.Add(compNode);
                        }
                        else if (comp is DataSet) {
                            // datasets are also special... design-time data.. yuck!
                            BindableValueNode compNode = new DataSetBindableValueNode((DataSet)comp, componentName);
                            bindableValuesTree.Nodes.Add(compNode);
                        }
                        else {
                            BindableValueNode compNode = new ComponentBindableValueNode(comp, componentName);
                            pageNode.Nodes.Add(compNode);
                        }
                    }
                }
            }

            // 'Container' for controls that are in a template
            string templateName = String.Empty;

            ITemplateEditingService teService = (ITemplateEditingService)site.GetService(typeof(ITemplateEditingService));
            if (teService != null) {
                templateName = teService.GetContainingTemplateName(control);
            }

            if ((templateName != null) && (templateName.Length != 0)) {
                // we're in template mode...

                IDesignerHost designerHost = (IDesignerHost)site.GetService(typeof(IDesignerHost));
                Debug.Assert(designerHost != null);

                ASPControl parentControl = control.Parent;
                IDesigner parentControlDesigner = null;

                if (parentControl != null) {
                    parentControlDesigner = designerHost.GetDesigner(parentControl);
                }

                if ((parentControlDesigner != null) && (parentControlDesigner is TemplatedControlDesigner)) {
                    TemplatedControlDesigner templatedControlDesigner = (TemplatedControlDesigner)parentControlDesigner;

                    Type templatePropParentType = templatedControlDesigner.GetTemplatePropertyParentType(templateName);
                    Debug.Assert(templatePropParentType != null);

                    // the returned type must have a ITemplate property with a TemplateContainerAttribute
                    PropertyDescriptor templateDesc = TypeDescriptor.GetProperties(templatePropParentType)[templateName];

                    if (templateDesc != null) {
                        TemplateContainerAttribute ta =
                            (TemplateContainerAttribute)templateDesc.Attributes[typeof(TemplateContainerAttribute)];

                        if (ta != null) {
                            Type templateContainerType = ta.ContainerType;

                            if (templateContainerType != null) {
                                ContainerBindableValueNode containerNode =
                                    new ContainerBindableValueNode(templateContainerType,
                                                                   templatedControlDesigner,
                                                                   templateName);
                                bindableValuesTree.Nodes.Add(containerNode);
                            }
                        }
                    }
                }
            }
        }

        /// <include file='doc\DataBindingForm.uex' path='docs/doc[@for="DataBindingForm.LoadCurrentDataBinding"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void LoadCurrentDataBinding() {
            Debug.Assert(currentBindingDirty == false, "Must have saved current changes first");

            loadingMode = true;
            try {
                simpleBindingRadio.Checked = true;

                bindableValuesTree.SelectedNode = unboundNode;
                formatChanged = false;
                formatCombo.Text = String.Empty;
                formatCombo.Items.Clear();
                sampleText.Clear();
                customExprText.Clear();

                if (currentNode.Bindable) {
                    bindingGroup.Text = String.Format(SR.GetString(SR.DBForm_BindingGroup),
                                                      currentNode.CompleteName);
                }

                if (currentDataBinding != null) {
                    bool useCustomExpression = (currentDataBinding.BindingType == DataBindingType.Custom);

                    if (useCustomExpression == false) {

                        BindableValueNode node = null;
                        string rootNodeText;

                        if (currentDataBinding.BindingType == DataBindingType.Reference) {
                            rootNodeText = currentDataBinding.Reference;
                        }
                        else {
                            rootNodeText = currentDataBinding.BindingContainer;
                        }

                        int topLevelNodeCount = bindableValuesTree.Nodes.Count;
                        for (int i = 0; i < topLevelNodeCount; i++) {
                            TreeNode currentTopNode = bindableValuesTree.Nodes[i];
                            
                            if (String.Compare(currentTopNode.Text, rootNodeText, true, CultureInfo.InvariantCulture) == 0) {
                                BindableValueNode rootNode = (BindableValueNode)currentTopNode;
                                if (currentDataBinding.BindingType == DataBindingType.Reference) {
                                    node = rootNode;
                                }
                                else {
                                    node = WalkBindableValuesTree(rootNode, currentDataBinding.BindingPath);
                                }
                                break;
                            }
                            else if (currentTopNode.Text.Equals("Page")) {
                                // special case page and loop through its children
                                
                                int pageChildCount = currentTopNode.Nodes.Count;
                                for (int j = 0; j < pageChildCount; j++) {
                                    if (currentTopNode.Nodes[j].Text.Equals(rootNodeText)) {
                                        BindableValueNode rootNode = (BindableValueNode)currentTopNode.Nodes[j];
                                        if (currentDataBinding.BindingType == DataBindingType.Reference) {
                                            node = rootNode;
                                        }
                                        else {
                                            node = WalkBindableValuesTree(rootNode, currentDataBinding.BindingPath);
                                        }
                                        break;
                                    }
                                }
                            }
                        }

                        if (node != null) {
                            bindableValuesTree.SelectedNode = node;
                            node.EnsureVisible();

                            UpdateFormatDefinitions();
                            if (currentDataBinding.BindingType == DataBindingType.DataBinderEval)
                                formatCombo.Text = currentDataBinding.BindingFormat;

                            UpdateBindingExpressionDisplay();
                            UpdateFormatSample();
                        }
                        else {
                            // could not find a matching node... so fallback on custom expression
                            useCustomExpression = true;
                        }
                    }

                    if (useCustomExpression) {
                        customExprText.Text = currentDataBinding.Expression;
                        customBindingRadio.Checked = true;
                    }

                }
            }
            finally {
                loadingMode = false;
            }

            UpdateEnabledState();
        }

        /// <include file='doc\DataBindingForm.uex' path='docs/doc[@for="DataBindingForm.LoadDataBindings"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void LoadDataBindings() {
            bindingCollection = new Hashtable();
            bindingsDirty = false;

            DataBindingCollection dataBindings = ((IDataBindingsAccessor)control).DataBindings;

            foreach (DataBinding db in dataBindings) {
                DesignTimeDataBinding ddb = new DesignTimeDataBinding(db);

                bindingCollection[db.PropertyName] = ddb;
            }
        }

        /// <include file='doc\DataBindingForm.uex' path='docs/doc[@for="DataBindingForm.OnActivated"]/*' />
        /// <devdoc>
        /// </devdoc>
        protected override void OnActivated(EventArgs e) {
            base.OnActivated(e);

            if (firstActivate) {
                firstActivate = false;

                LoadDataBindings();
                LoadBindableValuesTree();
                LoadBindablePropertiesTree();
            }
        }

        /// <include file='doc\DataBindingForm.uex' path='docs/doc[@for="DataBindingForm.OnAfterSelectBindableProps"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void OnAfterSelectBindableProps(object sender, TreeViewEventArgs e) {
            if (currentBindingDirty) {
                SaveCurrentDataBinding();
            }

            currentNode = (BindablePropertyNode)bindablePropsTree.SelectedNode;
            currentDataBinding = null;

            bindingGroup.Text = String.Empty;

            if (currentNode != null) {
                if (currentNode.Bindable) {
                    currentDataBinding = (DesignTimeDataBinding)bindingCollection[currentNode.CompleteName];
                }
                LoadCurrentDataBinding();
            }
        }

        /// <include file='doc\DataBindingForm.uex' path='docs/doc[@for="DataBindingForm.OnAfterSelectBindableValues"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void OnAfterSelectBindableValues(object sender, TreeViewEventArgs e) {
            if (loadingMode)
                return;

            currentBindingDirty = true;
            UpdateBindingExpressionDisplay();
            UpdateFormatDefinitions();
            UpdateFormatSample();
            UpdateEnabledState();
        }

        /// <include file='doc\DataBindingForm.uex' path='docs/doc[@for="DataBindingForm.OnBeforeExpandBindableValues"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void OnBeforeExpandBindableValues(object sender, TreeViewCancelEventArgs e) {
            BindableValueNode node = (BindableValueNode)e.Node;

            node.EnsureChildNodes();
            if (node.Nodes.Count == 0)
                e.Cancel = true;
        }

        /// <include file='doc\DataBindingForm.uex' path='docs/doc[@for="DataBindingForm.OnBindingTypeChanged"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void OnBindingTypeChanged(object sender, EventArgs e) {
            if (loadingMode)
                return;

            currentBindingDirty = true;
            UpdateEnabledState();
        }

        private void ShowHelp() {
            IHelpService helpService = (IHelpService)site.GetService(typeof(IHelpService));
            if (helpService != null) {
                helpService.ShowHelpFromKeyword("net.Asp.DataBindingsDialog");
            }
        }

        /// <include file='doc\DataBindingForm.uex' path='docs/doc[@for="DataBindingForm.OnClickHelp"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void OnClickHelp(object sender, EventArgs e) {
            ShowHelp();
        }

        private void OnHelpRequested(object sender, HelpEventArgs e) {
            ShowHelp();
        }

        /// <include file='doc\DataBindingForm.uex' path='docs/doc[@for="DataBindingForm.OnClickOK"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void OnClickOK(object sender, EventArgs e) {
            if (currentBindingDirty) {
                SaveCurrentDataBinding();
            }

            if (bindingsDirty) {
                SaveDataBindings();
            }

            Close();
            DialogResult = DialogResult.OK;
        }

        /// <include file='doc\DataBindingForm.uex' path='docs/doc[@for="DataBindingForm.OnLostFocusFormat"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void OnLostFocusFormat(object sender, EventArgs e) {
            if (formatChanged) {
                formatChanged = false;

                UpdateBindingExpressionDisplay();
                UpdateFormatSample();
            }
        }

        /// <include file='doc\DataBindingForm.uex' path='docs/doc[@for="DataBindingForm.OnSelChangedFormat"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void OnSelChangedFormat(object sender, EventArgs e) {
            if (loadingMode)
                return;

            currentBindingDirty = true;
            UpdateBindingExpressionDisplay();
            UpdateFormatSample();
            formatChanged = false;

            BeginInvoke(new MethodInvoker(this.UpdateFormatText));
        }

        /// <include file='doc\DataBindingForm.uex' path='docs/doc[@for="DataBindingForm.OnTextChangedCustomExpr"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void OnTextChangedCustomExpr(object sender, EventArgs e) {
            if (loadingMode)
                return;

            currentBindingDirty = true;
        }

        /// <include file='doc\DataBindingForm.uex' path='docs/doc[@for="DataBindingForm.OnTextChangedFormat"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void OnTextChangedFormat(object sender, EventArgs e) {
            if (loadingMode)
                return;

            currentBindingDirty = true;
            formatChanged = true;
        }

        /// <include file='doc\DataBindingForm.uex' path='docs/doc[@for="DataBindingForm.SaveCurrentDataBinding"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void SaveCurrentDataBinding() {
            Debug.Assert(currentBindingDirty, "Unnecessary call to SaveCurrentBinding");
            Debug.Assert(currentNode != null, "Expected a current binding");

            string expression = String.Empty;

            if (customBindingRadio.Checked) {
                expression = customExprText.Text.Trim();
            }
            else {
                expression = GenerateBindingExpression();
            }

            if (expression.Length == 0) {
                if (currentDataBinding != null) {
                    bindingCollection.Remove(currentNode.CompleteName);
                    currentDataBinding = null;
                }

                currentNode.Bound = false;
            }
            else {
                if (currentDataBinding == null) {
                    currentDataBinding = new DesignTimeDataBinding(currentNode.CompleteName, currentNode.PropertyDescriptor.PropertyType, expression);
                    bindingCollection[currentNode.CompleteName] = currentDataBinding;
                }
                else {
                    currentDataBinding.SetCustomExpression(expression);
                }

                currentNode.Bound = true;
            }

            currentBindingDirty = false;
            bindingsDirty = true;
        }

        /// <include file='doc\DataBindingForm.uex' path='docs/doc[@for="DataBindingForm.SaveDataBindings"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void SaveDataBindings() {
            Debug.Assert(bindingsDirty, "Unnecessary call to SaveDataBindings");

            DataBindingCollection dbc = ((IDataBindingsAccessor)control).DataBindings;
            IEnumerator bindingEnum = bindingCollection.Values.GetEnumerator();

            dbc.Clear();
            while (bindingEnum.MoveNext()) {
                DesignTimeDataBinding ddb = (DesignTimeDataBinding)bindingEnum.Current;
                dbc.Add(ddb.RuntimeDataBinding);
            }

            bindingsDirty = false;
        }

        /// <include file='doc\DataBindingForm.uex' path='docs/doc[@for="DataBindingForm.UpdateBindingExpressionDisplay"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void UpdateBindingExpressionDisplay() {
            customExprText.Text = GenerateBindingExpression();
        }
        
        /// <include file='doc\DataBindingForm.uex' path='docs/doc[@for="DataBindingForm.UpdateEnabledState"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void UpdateEnabledState() {
            if ((currentNode == null) || (currentNode.Bindable == false)) {
                simpleBindingRadio.Enabled = false;
                customBindingRadio.Enabled = false;

                bindableValuesTree.Enabled = false;
                formatCombo.Enabled = false;
                sampleText.Enabled = false;
                customExprText.Enabled = false;
            }
            else {
                bool simpleBinding = simpleBindingRadio.Checked;
                bool formattableProperty = false;
                bool boundValueSelected = false;

                simpleBindingRadio.Enabled = true;
                customBindingRadio.Enabled = true;

                bindableValuesTree.Enabled = simpleBinding;
                if (simpleBinding) {
                    TreeNode selectedNode = bindableValuesTree.SelectedNode;

                    boundValueSelected = (selectedNode != null) && !selectedNode.Equals(unboundNode);

                    if (selectedNode != null) {
                        DataBindingType bindingType = ((BindableValueNode)selectedNode).BindingType;

                        formattableProperty = (bindingType == DataBindingType.DataBinderEval) &&
                                              (currentNode.PropertyDescriptor.PropertyType == typeof(string));
                    }
                }
                formatCombo.Enabled = simpleBinding && boundValueSelected && formattableProperty;
                sampleText.Enabled = simpleBinding && boundValueSelected && formattableProperty;
                
                customExprText.Enabled = !simpleBinding;
            }
        }

        /// <include file='doc\DataBindingForm.uex' path='docs/doc[@for="DataBindingForm.UpdateFormatDefinitions"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void UpdateFormatDefinitions() {
            FormatDefinition[] formats = defaultFormats;
            
            sampleFormattableObject = null;
            formatCombo.SelectedIndex = -1;
            formatCombo.Text = String.Empty;

            TreeNode selectedNode = bindableValuesTree.SelectedNode;

            bool boundValueSelected = (selectedNode != null) && !selectedNode.Equals(unboundNode);

            if (boundValueSelected) {
                DataBindingType bindingType = ((BindableValueNode)selectedNode).BindingType;

                if ((bindingType == DataBindingType.DataBinderEval) &&
                    (currentNode.PropertyDescriptor.PropertyType == typeof(string))) {

                    Type valueType = ((BindableValueNode)selectedNode).ValueType;
                    TypeCode typeCode = Type.GetTypeCode(valueType);

                    switch (typeCode) {
                        case TypeCode.Decimal:
                        case TypeCode.Double:
                        case TypeCode.Single:
                            formats = decimalFormats;
                            sampleFormattableObject = 1;
                            break;
                        case TypeCode.Byte:
                        case TypeCode.SByte:
                        case TypeCode.Int16:
                        case TypeCode.Int32:
                        case TypeCode.Int64:
                        case TypeCode.UInt16:
                        case TypeCode.UInt32:
                        case TypeCode.UInt64:
                            formats = numericFormats;
                            sampleFormattableObject = 1;
                            break;
                        case TypeCode.String:
                            sampleFormattableObject = "abc";
                            break;
                        case TypeCode.DateTime:
                            formats = dateTimeFormats;
                            sampleFormattableObject = DateTime.Today;
                            break;
                        case TypeCode.Boolean:
                        case TypeCode.Char:
                        case TypeCode.DBNull:
                        case TypeCode.Object:
                        default:
                            break;
                    }
                }
            }
            else {
                sampleFormattableObject = null;
            }

            formatCombo.Items.Clear();                                 
            formatCombo.Items.AddRange(formats);
        }

        /// <include file='doc\DataBindingForm.uex' path='docs/doc[@for="DataBindingForm.UpdateFormatSample"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void UpdateFormatSample() {
            string sampleValue = String.Empty;

            if (sampleFormattableObject != null) {
                string bindingFormat = GetCurrentFormatText();

                if (bindingFormat.Length != 0) {
                    try {
                        sampleValue = String.Format(bindingFormat, sampleFormattableObject);
                    } catch {
                        sampleValue = SR.GetString(SR.DBForm_InvalidFormat);
                    }
                }
            }

            sampleText.Text = sampleValue;
        }

        /// <include file='doc\DataBindingForm.uex' path='docs/doc[@for="DataBindingForm.UpdateFormatText"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void UpdateFormatText() {
            object selFormat = formatCombo.SelectedItem;

            if ((selFormat != null) && (selFormat is FormatDefinition)) {
                FormatDefinition format = (FormatDefinition)selFormat;
                formatCombo.Text = format.Format;
            }
        }

        /// <include file='doc\DataBindingForm.uex' path='docs/doc[@for="DataBindingForm.WalkBindableValuesTree"]/*' />
        /// <devdoc>
        /// </devdoc>
        private BindableValueNode WalkBindableValuesTree(BindableValueNode rootNode, string bindingPath) {
            Debug.Assert(rootNode != null);
            Debug.Assert(bindingPath.Length > 0);

            BindableValueNode currentRootNode = rootNode;
            int indexPathSeparator = bindingPath.IndexOf('.');
            int currentPathLength;
            
            if (indexPathSeparator < 0) {
                indexPathSeparator = bindingPath.Length;
                currentPathLength = bindingPath.Length;
            }
            else {
                currentPathLength = indexPathSeparator;
                indexPathSeparator++;
            }

            while (currentRootNode != null) {
                currentRootNode.EnsureChildNodes();

                TreeNodeCollection nodes = currentRootNode.Nodes;
                int nodeCount = nodes.Count;

                currentRootNode = null;

                for (int i = 0; i < nodeCount; i++) {
                    string nodeBindingPath = ((BindableValueNode)nodes[i]).BindingPath;

                    if (nodeBindingPath.Length != currentPathLength)
                        continue;

                    if (String.Compare(bindingPath, 0, nodeBindingPath, 0, currentPathLength, true, CultureInfo.InvariantCulture) == 0) {
                        currentRootNode = (BindableValueNode)nodes[i];
                        break;
                    }
                }

                if (indexPathSeparator < bindingPath.Length) {
                    indexPathSeparator = bindingPath.IndexOf('.', indexPathSeparator);
                    if (indexPathSeparator < 0) {
                        indexPathSeparator = bindingPath.Length;
                        currentPathLength = bindingPath.Length;
                    }
                    else {
                        currentPathLength = indexPathSeparator;
                        indexPathSeparator++;
                    }
                }
                else {
                    break;
                }
            }

            return currentRootNode;
        }



        internal const int ILI_UNBOUND = 0;
        internal const int ILI_BOUND = 1;

        /// <include file='doc\DataBindingForm.uex' path='docs/doc[@for="DataBindingForm.BindablePropertyNode"]/*' />
        /// <devdoc>
        /// </devdoc>
        private sealed class BindablePropertyNode : TreeNode {

            private string completeName;
            private PropertyDescriptor propDesc;
            private bool bindable;
            private bool bound;

            public BindablePropertyNode(string completeName, PropertyDescriptor propDesc, bool bindable, bool bound) {
                this.completeName = completeName;
                this.propDesc = propDesc;
                this.bindable = bindable;
                this.bound = bound;

                this.Text = propDesc.Name;
                this.ImageIndex = this.SelectedImageIndex = (bound ? ILI_BOUND : ILI_UNBOUND);
            }

            public bool Bindable {
                get {
                    return bindable;
                }
            }

            public bool Bound {
                get {
                    return bound;
                }
                set {
                    bound = value;
                    this.ImageIndex = this.SelectedImageIndex = (bound ? ILI_BOUND : ILI_UNBOUND);
                }
            }

            public string CompleteName {
                get {
                    return completeName;
                }
            }

            public PropertyDescriptor PropertyDescriptor {
                get {
                    return propDesc;
                }
            }
        }



        internal const int ILI_VALUE_PAGE = 0;
        internal const int ILI_VALUE_CONTAINER = 1;
        internal const int ILI_VALUE_DATAITEM = 2;
        internal const int ILI_VALUE_FIELD = 3;
        internal const int ILI_VALUE_DATASOURCE = 4;
        internal const int ILI_VALUE_COMPONENT = 5;
        internal const int ILI_VALUE_PROPERTY = 6;
        internal const int ILI_VALUE_UNBOUND = 7;

        /// <include file='doc\DataBindingForm.uex' path='docs/doc[@for="DataBindingForm.BindableValueNode"]/*' />
        /// <devdoc>
        /// </devdoc>
        private abstract class BindableValueNode : TreeNode {

            private Type valueType;
            private bool childNodesCreated;

            public BindableValueNode(string text, int imageIndex, Type valueType) : base(text, imageIndex, imageIndex) {
                this.valueType = valueType;
                childNodesCreated = false;
            }

            protected bool ChildNodesCreated {
                get {
                    return childNodesCreated;
                }
                set {
                    Debug.Assert(value);
                    childNodesCreated = value;
                }
            }

            public virtual string BindingContainer {
                get {
                    return String.Empty;
                }
            }

            public virtual string BindingPath {
                get {
                    return String.Empty;
                }
            }

            public virtual string BindingReference {
                get {
                    return String.Empty;
                }
            }

            public abstract DataBindingType BindingType { get; }

            public Type ValueType {
                get {
                    return valueType;
                }
            }

            protected virtual void CreateChildNodes() {
            }

            public void EnsureChildNodes() {
                if (childNodesCreated == false) {
                    Nodes.Clear();

                    CreateChildNodes();
                    childNodesCreated = true;
                }
            }
        }


        /// <include file='doc\DataBindingForm.uex' path='docs/doc[@for="DataBindingForm.DummyBindableValueNode"]/*' />
        /// <devdoc>
        /// </devdoc>
        private class DummyBindableValueNode : BindableValueNode {

            public DummyBindableValueNode() : base("!", 0, null) {
                ChildNodesCreated = true;
            }

            public override DataBindingType BindingType {
                get {
                    return DataBindingType.Reference;
                }
            }
        }

        /// <include file='doc\DataBindingForm.uex' path='docs/doc[@for="DataBindingForm.UnboundBindableValueNode"]/*' />
        /// <devdoc>
        /// </devdoc>
        private class UnboundBindableValueNode : BindableValueNode {

            public UnboundBindableValueNode() : base(SR.GetString(SR.DBForm_UnboundNode), ILI_VALUE_UNBOUND, null) {
                ChildNodesCreated = true;
            }

            public override DataBindingType BindingType {
                get {
                    return DataBindingType.Reference;
                }
            }
        }

        /// <include file='doc\DataBindingForm.uex' path='docs/doc[@for="DataBindingForm.PageBindableValueNode"]/*' />
        /// <devdoc>
        /// </devdoc>
        private class PageBindableValueNode : BindableValueNode {

            public PageBindableValueNode() : base("Page", ILI_VALUE_PAGE, typeof(System.Web.UI.Page)) {
                // page is built with its children added to start with
                ChildNodesCreated = true;
            }

            public override string BindingContainer {
                get {
                    return "Page";
                }
            }

            public override string BindingReference {
                get {
                    return "Page";
                }
            }

            public override DataBindingType BindingType {
                get {
                    return DataBindingType.Reference;
                }
            }
        }

        /// <include file='doc\DataBindingForm.uex' path='docs/doc[@for="DataBindingForm.ComponentBindableValueNode"]/*' />
        /// <devdoc>
        /// </devdoc>
        private class ComponentBindableValueNode : BindableValueNode {

            private IComponent runtimeComponent;

            public ComponentBindableValueNode(IComponent component, string name) : base(name, ILI_VALUE_COMPONENT, component.GetType()) {
                this.runtimeComponent = component;

                this.Nodes.Add(new DummyBindableValueNode());
            }

            public override string BindingContainer {
                get {
                    return this.Text;
                }
            }

            public override string BindingReference {
                get {
                    return this.Text;
                }
            }

            public override DataBindingType BindingType {
                get {
                    return DataBindingType.Reference;
                }
            }

            protected IComponent RuntimeComponent {
                get {
                    return runtimeComponent;
                }
            }

            protected override void CreateChildNodes() {
                Debug.Assert(ValueType != null);

                BindingFlags bf = BindingFlags.Public | BindingFlags.Instance;
                PropertyInfo[] props = ValueType.GetProperties(bf);
                int propCount = props.Length;

                for (int i = 0; i < propCount; i++) {
                    PropertyInfo pi = props[i];

                    BindableValueNode node = new PropertyBindableValueNode(pi);
                    Nodes.Add(node);
                }
            }
        }

        /// <include file='doc\DataBindingForm.uex' path='docs/doc[@for="DataBindingForm.DataSetBindableValueNode"]/*' />
        /// <devdoc>
        /// </devdoc>
        private class DataSetBindableValueNode : ComponentBindableValueNode {

            public DataSetBindableValueNode(IComponent component, string name) : base(component, name) {
                Debug.Assert(component is DataSet);
            }

            protected override void CreateChildNodes() {
                foreach (DataTable table in ((DataSet)RuntimeComponent).Tables) {
                    BindableValueNode node = new DataTableBindableValueNode(table);
                    Nodes.Add(node);
                }
            }
        }

        /// <include file='doc\DataBindingForm.uex' path='docs/doc[@for="DataBindingForm.DataTableBindableValueNode"]/*' />
        /// <devdoc>
        /// </devdoc>
        private class DataTableBindableValueNode : BindableValueNode {

            private DataTable table;

            public DataTableBindableValueNode(DataTable table) : base(table.TableName, ILI_VALUE_DATASOURCE, typeof(DataTable)) {
                this.table = table;
                this.Nodes.Add(new DummyBindableValueNode());
            }

            public override string BindingContainer {
                get {
                    Debug.Assert((Parent != null) && (Parent is BindableValueNode), "Invalid parent node");
                    BindableValueNode parentNode = (BindableValueNode)Parent;

                    return parentNode.BindingContainer;
                }
            }

            public override string BindingPath {
                get {
                    Debug.Assert((Parent != null) && (Parent is BindableValueNode), "Invalid parent node");
                    BindableValueNode parentNode = (BindableValueNode)Parent;

                    if (parentNode.BindingType == DataBindingType.Reference)
                        return "Tables[" + table.TableName + "]";
                    else
                        return parentNode.BindingPath + ".Tables[" + table.TableName + "]";
                }
            }

            public override string BindingReference {
                get {
                    return this.Text;
                }
            }

            public override DataBindingType BindingType {
                get {
                    return DataBindingType.DataBinderEval;
                }
            }

            protected override void CreateChildNodes() {
                BindableValueNode node = new DefaultViewBindableValueNode(table.DefaultView);
                Nodes.Add(node);
            }
        }

        /// <include file='doc\DataBindingForm.uex' path='docs/doc[@for="DataBindingForm.DataSourceBindableValueNode"]/*' />
        /// <devdoc>
        /// </devdoc>
        private class DataSourceBindableValueNode : BindableValueNode {

            private IEnumerable runtimeDataSource;

            public DataSourceBindableValueNode(IEnumerable runtimeDataSource, string name) : base(name, ILI_VALUE_DATASOURCE, typeof(IEnumerable)) {
                this.runtimeDataSource = runtimeDataSource;

                this.Nodes.Add(new DummyBindableValueNode());
            }

            public override string BindingContainer {
                get {
                    return this.Text;
                }
            }

            public override string BindingReference {
                get {
                    return this.Text;
                }
            }

            public override DataBindingType BindingType {
                get {
                    return DataBindingType.Reference;
                }
            }

            protected override void CreateChildNodes() {
                if (SupportsIndexedAccess()) {
                    DataSourceItemBindableValueNode firstItemNode =
                        new DataSourceItemBindableValueNode(Text, runtimeDataSource);

                    Nodes.Add(firstItemNode);
                }
            }

            private bool SupportsIndexedAccess() {
                if (runtimeDataSource is IList) {
                    return true;
                }

                Type dataSourceType = runtimeDataSource.GetType();
                PropertyInfo itemProp = dataSourceType.GetProperty("Item", BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static, null, null, new Type[] { typeof(int) }, null);
                if (itemProp != null) {
                    return true;
                }

                return false;
            }
        }

        /// <include file='doc\DataBindingForm.uex' path='docs/doc[@for="DataBindingForm.DefaultViewBindableValueNode"]/*' />
        /// <devdoc>
        /// </devdoc>
        private class DefaultViewBindableValueNode : DataSourceBindableValueNode {
            public DefaultViewBindableValueNode(IEnumerable runtimeDataSource) : base(runtimeDataSource, "DefaultView") {
            }

            public override string BindingContainer {
                get {
                    Debug.Assert((Parent != null) && (Parent is BindableValueNode), "Invalid parent node");
                    BindableValueNode parentNode = (BindableValueNode)Parent;

                    return parentNode.BindingContainer;
                }
            }

            public override string BindingPath {
                get {
                    Debug.Assert((Parent != null) && (Parent is BindableValueNode), "Invalid parent node");
                    BindableValueNode parentNode = (BindableValueNode)Parent;

                    return parentNode.BindingPath + ".DefaultView";
                }
            }

            public override string BindingReference {
                get {
                    return BindingContainer;
                }
            }

            public override DataBindingType BindingType {
                get {
                    return DataBindingType.DataBinderEval;
                }
            }
        }

        /// <include file='doc\DataBindingForm.uex' path='docs/doc[@for="DataBindingForm.DataSourceItemBindableValueNode"]/*' />
        /// <devdoc>
        /// </devdoc>
        private class DataSourceItemBindableValueNode : BindableValueNode {

            private IEnumerable runtimeDataSource;
            private bool dataItem;

            public DataSourceItemBindableValueNode(string name, IEnumerable runtimeDataSource) : this(name, runtimeDataSource, false) {
            }

            public DataSourceItemBindableValueNode(string name, IEnumerable runtimeDataSource, bool dataItem) : base(String.Empty, ILI_VALUE_DATAITEM, typeof(object)) {
                this.dataItem = dataItem;
                this.runtimeDataSource = runtimeDataSource;

                if (dataItem) {
                    this.Text = name;
                }
                else {
                    this.Text = name + ".[0]";
                }

                this.Nodes.Add(new DummyBindableValueNode());
            }

            public override string BindingContainer {
                get {
                    Debug.Assert((Parent != null) && (Parent is BindableValueNode), "Invalid parent node");
                    BindableValueNode parentNode = (BindableValueNode)Parent;

                    return parentNode.BindingReference;
                }
            }

            public override string BindingPath {
                get {
                    Debug.Assert((Parent != null) && (Parent is BindableValueNode), "Invalid parent node");
                    BindableValueNode parentNode = (BindableValueNode)Parent;

                    if (parentNode.BindingType == DataBindingType.Reference) {
                        return "[0]";
                    }
                    else {
                        return parentNode.BindingPath + ".[0]";
                    }
                }
            }

            public override DataBindingType BindingType {
                get {
                    return DataBindingType.DataBinderEval;
                }
            }

            protected override void CreateChildNodes() {
                if (runtimeDataSource != null) {
                    PropertyDescriptorCollection dataFields = DesignTimeData.GetDataFields(runtimeDataSource);

                    if (dataFields != null) {
                        foreach (PropertyDescriptor fieldDesc in dataFields) {
                            DataSourceFieldBindableValueNode node =
                                new DataSourceFieldBindableValueNode(fieldDesc, runtimeDataSource);
                            Nodes.Add(node);
                        }
                    }
                }
            }
        }

        /// <include file='doc\DataBindingForm.uex' path='docs/doc[@for="DataBindingForm.DataSourceFieldBindableValueNode"]/*' />
        /// <devdoc>
        /// </devdoc>
        private class DataSourceFieldBindableValueNode : BindableValueNode {

            private IEnumerable containingDataSource;
            private PropertyDescriptor fieldDesc;

            public DataSourceFieldBindableValueNode(PropertyDescriptor fieldDesc, IEnumerable containingDataSource) : base(fieldDesc.Name, ILI_VALUE_FIELD, fieldDesc.PropertyType) {

                this.containingDataSource = containingDataSource;
                this.fieldDesc = fieldDesc;

                this.Nodes.Add(new DummyBindableValueNode());
            }

            public override string BindingContainer {
                get {
                    Debug.Assert((Parent != null) && (Parent is BindableValueNode), "Invalid parent node");
                    BindableValueNode parentNode = (BindableValueNode)Parent;

                    return parentNode.BindingContainer;
                }
            }

            public override string BindingPath {
                get {
                    Debug.Assert((Parent != null) && (Parent is BindableValueNode), "Invalid parent node");
                    BindableValueNode parentNode = (BindableValueNode)Parent;

                    return parentNode.BindingPath + "." + this.Text;
                }
            }

            public override DataBindingType BindingType {
                get {
                    return DataBindingType.DataBinderEval;
                }
            }

            protected override void CreateChildNodes() {
                // TODO: Sub-list properties
                // if (typeof(IEnumerable).IsAssignableFrom(fieldDesc.PropertyType)) {
            }
        }

        /// <include file='doc\DataBindingForm.uex' path='docs/doc[@for="DataBindingForm.ContainerBindableValueNode"]/*' />
        /// <devdoc>
        /// </devdoc>
        private class ContainerBindableValueNode : BindableValueNode {

            private TemplatedControlDesigner parentDesigner;
            private string templateName;

            public ContainerBindableValueNode(Type containerType, TemplatedControlDesigner parentDesigner, string templateName) : base("Container", ILI_VALUE_CONTAINER, containerType) {
                this.parentDesigner = parentDesigner;
                this.templateName = templateName;

                this.Nodes.Add(new DummyBindableValueNode());
            }

            public override string BindingContainer {
                get {
                    return "Container";
                }
            }

            public override string BindingReference {
                get {
                    return "Container";
                }
            }

            public override DataBindingType BindingType {
                get {
                    return DataBindingType.Reference;
                }
            }

            protected override void CreateChildNodes() {
                Debug.Assert(ValueType != null);

                BindingFlags bf = BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly;
                PropertyInfo[] props = ValueType.GetProperties(bf);
                int propCount = props.Length;
                string dataItemPropName = parentDesigner.GetTemplateContainerDataItemProperty(templateName);

                for (int i = 0; i < propCount; i++) {
                    PropertyInfo pi = props[i];

                    BindableValueNode node;

                    if ((dataItemPropName.Length != 0) && pi.Name.Equals(dataItemPropName)) {
                        node = new ContainerDataItemBindableValueNode(pi.Name,
                                                                      parentDesigner.GetTemplateContainerDataSource(templateName));
                    }
                    else {
                        node = new PropertyBindableValueNode(pi);
                    }

                    Nodes.Add(node);
                }
            }
        }

        /// <include file='doc\DataBindingForm.uex' path='docs/doc[@for="DataBindingForm.ContainerDataItemBindableValueNode"]/*' />
        /// <devdoc>
        /// </devdoc>
        private class ContainerDataItemBindableValueNode : DataSourceItemBindableValueNode {

            public ContainerDataItemBindableValueNode(string name, IEnumerable runtimeDataSource) : base(name, runtimeDataSource, true) {
            }

            public override string BindingContainer {
                get {
                    Debug.Assert((Parent != null) && (Parent is BindableValueNode), "Invalid parent node");
                    BindableValueNode parentNode = (BindableValueNode)Parent;

                    return parentNode.BindingReference;
                }
            }

            public override string BindingPath {
                get {
                    return "DataItem";
                }
            }

            public override DataBindingType BindingType {
                get {
                    return DataBindingType.DataBinderEval;
                }
            }
        }

        /// <include file='doc\DataBindingForm.uex' path='docs/doc[@for="DataBindingForm.PropertyBindableValueNode"]/*' />
        /// <devdoc>
        /// </devdoc>
        private class PropertyBindableValueNode : BindableValueNode {

            public PropertyBindableValueNode(PropertyInfo pi) : base(pi.Name, ILI_VALUE_PROPERTY, pi.PropertyType) {
                this.Nodes.Add(new DummyBindableValueNode());
            }

            public override string BindingContainer {
                get {
                    Debug.Assert((Parent != null) && (Parent is BindableValueNode), "Invalid parent node");
                    BindableValueNode parentNode = (BindableValueNode)Parent;

                    return parentNode.BindingContainer;
                }
            }

            public override string BindingPath {
                get {
                    Debug.Assert((Parent != null) && (Parent is BindableValueNode), "Invalid parent node");
                    BindableValueNode parentNode = (BindableValueNode)Parent;

                    string parentBindingPath = parentNode.BindingPath;
                    if (parentBindingPath.Length == 0) {
                        return this.Text;
                    }
                    else {
                        return parentBindingPath + "." + this.Text;
                    }
                }
            }

            public override DataBindingType BindingType {
                get {
                    return DataBindingType.DataBinderEval;
                }
            }

            protected override void CreateChildNodes() {
                Debug.Assert(ValueType != null);

                BindingFlags bf = BindingFlags.Public | BindingFlags.Instance;
                PropertyInfo[] props = ValueType.GetProperties(bf);
                int propCount = props.Length;

                for (int i = 0; i < propCount; i++) {
                    PropertyInfo pi = props[i];

                    BindableValueNode node = new PropertyBindableValueNode(pi);
                    Nodes.Add(node);
                }
            }
        }



        /// <include file='doc\DataBindingForm.uex' path='docs/doc[@for="DataBindingForm.FormatDefinition"]/*' />
        /// <devdoc>
        /// </devdoc>
        private class FormatDefinition {
            private readonly string displayText;
            private readonly string format;

            public static readonly FormatDefinition nullFormat = new FormatDefinition(SR.GetString(SR.DBForm_Fmt_None), String.Empty);

            public static readonly FormatDefinition generalFormat = new FormatDefinition(SR.GetString(SR.DBForm_Fmt_General), "{0}");

            public static readonly FormatDefinition dtShortTime = new FormatDefinition(SR.GetString(SR.DBForm_Fmt_ShortTime), "{0:t}");
            public static readonly FormatDefinition dtLongTime = new FormatDefinition(SR.GetString(SR.DBForm_Fmt_LongTime), "{0:T}");
            public static readonly FormatDefinition dtShortDate = new FormatDefinition(SR.GetString(SR.DBForm_Fmt_ShortDate), "{0:d}");
            public static readonly FormatDefinition dtLongDate = new FormatDefinition(SR.GetString(SR.DBForm_Fmt_LongDate), "{0:D}");
            public static readonly FormatDefinition dtDateTime = new FormatDefinition(SR.GetString(SR.DBForm_Fmt_DateTime), "{0:g}");
            public static readonly FormatDefinition dtFullDate = new FormatDefinition(SR.GetString(SR.DBForm_Fmt_FullDate), "{0:G}");

            public static readonly FormatDefinition numNumber = new FormatDefinition(SR.GetString(SR.DBForm_Fmt_Numeric), "{0:N}");
            public static readonly FormatDefinition numDecimal = new FormatDefinition(SR.GetString(SR.DBForm_Fmt_Decimal), "{0:D}");
            public static readonly FormatDefinition numFixed = new FormatDefinition(SR.GetString(SR.DBForm_Fmt_Fixed), "{0:F}");
            public static readonly FormatDefinition numCurrency = new FormatDefinition(SR.GetString(SR.DBForm_Fmt_Currency), "{0:C}");
            public static readonly FormatDefinition numScientific = new FormatDefinition(SR.GetString(SR.DBForm_Fmt_Scientific), "{0:E}");
            public static readonly FormatDefinition numHex = new FormatDefinition(SR.GetString(SR.DBForm_Fmt_Hexadecimal), "0x{0:X}");

            public FormatDefinition(string displayText, string format) {
                this.displayText = String.Format(displayText, format);
                this.format = format;
            }

            public string Format {
                get {
                    return format;
                }
            }

            public override string ToString() {
                return displayText;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\util\numberedit.cs ===
//------------------------------------------------------------------------------
// <copyright file="NumberEdit.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

// NumberEdit.cs
//
// 3/18/99: nikhilko: created
//

namespace System.Web.UI.Design.Util {
    using System.Runtime.Serialization.Formatters;
    using System.Design;
    

    using System.Diagnostics;

    using System;
    using System.ComponentModel;
    using System.Windows.Forms;
    using System.Drawing;

    /// <include file='doc\NumberEdit.uex' path='docs/doc[@for="NumberEdit"]/*' />
    /// <devdoc>
    ///    Provides an edit control that only accepts numbers with addition
    ///    restrictions such as whether negatives and decimals are allowed
    /// </devdoc>
    /// <internalonly/>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal sealed class NumberEdit : TextBox {
        private bool allowNegative = true;
        private bool allowDecimal = true;

        /// <include file='doc\NumberEdit.uex' path='docs/doc[@for="NumberEdit.AllowDecimal"]/*' />
        /// <devdoc>
        ///    Controls whether the edit control allows negative values
        /// </devdoc>
        public bool AllowDecimal {
            get {
                return allowDecimal;
            }
            set {
                allowDecimal = value;
            }
        }

        /// <include file='doc\NumberEdit.uex' path='docs/doc[@for="NumberEdit.AllowNegative"]/*' />
        /// <devdoc>
        ///    Controls whether the edit control allows negative values
        /// </devdoc>
        public bool AllowNegative {
            get {
                return allowNegative;
            }
            set {
                allowNegative = value;
            }
        }


        /// <include file='doc\NumberEdit.uex' path='docs/doc[@for="NumberEdit.WndProc"]/*' />
        /// <devdoc>
        ///    Override of wndProc to listen to WM_CHAR and filter out invalid
        ///    key strokes. Valid keystrokes are:
        ///    0...9,
        ///    '.' (if fractions allowed),
        ///    '-' (if negative allowed),
        ///    BKSP.
        ///    A beep is generated for invalid keystrokes
        /// </devdoc>
        protected override void WndProc(ref Message m) {
            if (m.Msg == NativeMethods.WM_CHAR) {
                char ch = (char)m.WParam;
                if (!(((ch >= '0') && (ch <= '9')) ||
                      ((ch == '.') && allowDecimal) ||
                      ((ch == '-') && allowNegative) ||
                      (ch == (char)8))) {
                    SafeNativeMethods.MessageBeep(unchecked((int)0xFFFFFFFF));
                    return;
                }
            }
            base.WndProc(ref m);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\util\mshtmlhost.cs ===
//------------------------------------------------------------------------------
// <copyright file="MSHTMLHost.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

// MSHTMLHost.cs
//
// 12/17/98: Created: NikhilKo
//

namespace System.Web.UI.Design.Util {
    using System.Runtime.Serialization.Formatters;
    
    using System.Runtime.InteropServices;
    using System.ComponentModel;

    using System.Diagnostics;

    using System;
    using System.Design;
    
    using Microsoft.Win32;    
    using System.Windows.Forms;

    /// <include file='doc\MSHTMLHost.uex' path='docs/doc[@for="MSHTMLHost"]/*' />
    /// <devdoc>
    ///    Control that hosts a Trident DocObject.
    /// </devdoc>
    /// <internalonly/>
    // TODO: Change the interface wrappers to return an HRESULT instead of throwing
    //    exceptions for E_NOTIMPL
    //
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal sealed class MSHTMLHost : Control {
        private TridentSite tridentSite;

        public MSHTMLHost() : base() {
        }

        public NativeMethods.IHTMLDocument2 GetDocument() {
            Debug.Assert(tridentSite != null,
                         "Cannot call getDocument before calling createTrident");

            return tridentSite.GetDocument();
        }

        protected override CreateParams CreateParams {
             get {
                CreateParams cp = base.CreateParams;

                cp.ExStyle |= NativeMethods.WS_EX_STATICEDGE;
                return cp;
            }
        }

        public bool CreateTrident() {
            Debug.Assert(Handle != IntPtr.Zero,
                         "MSHTMLHost must first be created before createTrident is called");

            try {
                tridentSite = new TridentSite(this);
            }
            catch (Exception e) {
                Debug.WriteLine("Exception caught in MSHTMLHost::CreateTrident\n\t" + e.ToString());
                return false;
            }
            return true;
        }

        public void CloseTrident() {
            if (tridentSite != null) {
                tridentSite.Close();
                tridentSite = null;
            }
        }

        public void ActivateTrident() {
            Debug.Assert(tridentSite != null,
                         "cannot call activateTrident before calling createTrident");

            tridentSite.Activate();
        }
    }


    /// <include file='doc\MSHTMLHost.uex' path='docs/doc[@for="TridentSite"]/*' />
    /// <devdoc>
    ///    Implements the client site for Trident DocObject
    /// </devdoc>
    [ClassInterface(ClassInterfaceType.None)]
    internal class TridentSite : NativeMethods.IOleClientSite, NativeMethods.IOleDocumentSite, NativeMethods.IOleInPlaceSite, NativeMethods.IOleInPlaceFrame, NativeMethods.IDocHostUIHandler {

        protected Control parentControl;
        protected NativeMethods.IOleDocumentView tridentView;
        protected NativeMethods.IOleObject tridentOleObject;
        protected NativeMethods.IHTMLDocument2 tridentDocument;

        protected EventHandler resizeHandler;

        public TridentSite(Control parent) {
            Debug.Assert((parent != null) && (parent.Handle != IntPtr.Zero),
                         "Invalid control passed in as parent of Trident window");

            parentControl = parent;
            resizeHandler = new EventHandler(this.OnParentResize);
            parentControl.Resize += resizeHandler;

            CreateDocument();
        }

        public void Close() {
            parentControl.Resize -= resizeHandler;
            CloseDocument();
        }

        public NativeMethods.IHTMLDocument2 GetDocument() {
            return tridentDocument;
        }

        public void Activate() {
            ActivateDocument();
        }

        protected virtual void OnParentResize(object src, EventArgs e) {
            if (tridentView != null) {
                NativeMethods.COMRECT r = new NativeMethods.COMRECT();

                NativeMethods.GetClientRect(parentControl.Handle, r);
                tridentView.SetRect(r);
            }
        }


        ///////////////////////////////////////////////////////////////////////////
        // IOleClientSite Implementation

        public virtual void SaveObject() {
        }

        public virtual object GetMoniker(int dwAssign, int dwWhichMoniker) {
            throw new COMException(String.Empty, NativeMethods.E_NOTIMPL);
        }

        public virtual int GetContainer(out NativeMethods.IOleContainer ppContainer) {
            ppContainer = null;
            return NativeMethods.E_NOINTERFACE;
        }

        public virtual void ShowObject() {
        }

        public virtual void OnShowWindow(int fShow) {
        }

        public virtual void RequestNewObjectLayout() {
        }


        ///////////////////////////////////////////////////////////////////////////
        // IOleDocumentSite Implementation

        public virtual int ActivateMe(NativeMethods.IOleDocumentView pViewToActivate) {
            Debug.Assert(pViewToActivate != null,
                         "Expected the view to be non-null");
            if (pViewToActivate == null)
                return NativeMethods.E_INVALIDARG;

            NativeMethods.COMRECT r = new NativeMethods.COMRECT();

            NativeMethods.GetClientRect(parentControl.Handle, r);

            tridentView = pViewToActivate;
            tridentView.SetInPlaceSite((NativeMethods.IOleInPlaceSite)this);
            tridentView.UIActivate(1);
            tridentView.SetRect(r);
            tridentView.Show(1);

            return NativeMethods.S_OK;
        }


        ///////////////////////////////////////////////////////////////////////////
        // IOleInPlaceSite Implementation

        public virtual IntPtr GetWindow() {
            return parentControl.Handle;
        }

        public virtual void ContextSensitiveHelp(int fEnterMode) {
            throw new COMException(String.Empty, NativeMethods.E_NOTIMPL);
        }

        public virtual int CanInPlaceActivate() {
            return NativeMethods.S_OK;
        }

        public virtual void OnInPlaceActivate() {
        }

        public virtual void OnUIActivate() {
        }

        public virtual void GetWindowContext(out NativeMethods.IOleInPlaceFrame ppFrame, out NativeMethods.IOleInPlaceUIWindow ppDoc, NativeMethods.COMRECT lprcPosRect, NativeMethods.COMRECT lprcClipRect, NativeMethods.tagOIFI lpFrameInfo) {

            ppFrame = (NativeMethods.IOleInPlaceFrame)this;
            ppDoc = null;

            NativeMethods.GetClientRect(parentControl.Handle, lprcPosRect);
            NativeMethods.GetClientRect(parentControl.Handle, lprcClipRect);

            lpFrameInfo.cb = System.Runtime.InteropServices.Marshal.SizeOf(typeof(NativeMethods.tagOIFI));
            lpFrameInfo.fMDIApp = 0;
            lpFrameInfo.hwndFrame = parentControl.Handle;
            lpFrameInfo.hAccel = IntPtr.Zero;
            lpFrameInfo.cAccelEntries = 0;
        }

        public virtual int Scroll(NativeMethods.tagSIZE scrollExtant) {
            return(NativeMethods.E_NOTIMPL);
        }

        public virtual void OnUIDeactivate(int fUndoable) {
            // NOTE, nikhilko, 7/99: Don't return E_NOTIMPL. Somehow doing nothing and returning S_OK
            //    fixes trident hosting in Win2000.
        }

        public virtual void OnInPlaceDeactivate() {
        }

        public virtual void DiscardUndoState() {
            throw new COMException("Not implemented", NativeMethods.E_NOTIMPL);
        }

        public virtual void DeactivateAndUndo() {
        }

        public virtual int OnPosRectChange(NativeMethods.COMRECT lprcPosRect) {
            return NativeMethods.S_OK;
        }


        ///////////////////////////////////////////////////////////////////////////
        // IOleInPlaceFrame Implementation

        public virtual void GetBorder(NativeMethods.COMRECT lprectBorder) {
            throw new COMException(String.Empty, NativeMethods.E_NOTIMPL);
        }

        public virtual void RequestBorderSpace(NativeMethods.COMRECT pborderwidths) {
            throw new COMException(String.Empty, NativeMethods.E_NOTIMPL);
        }

        public virtual void SetBorderSpace(NativeMethods.COMRECT pborderwidths) {
            throw new COMException(String.Empty, NativeMethods.E_NOTIMPL);
        }

        public virtual void SetActiveObject(NativeMethods.IOleInPlaceActiveObject pActiveObject, string pszObjName) {
            // NOTE, nikhilko, 7/99: Don't return E_NOTIMPL. Somehow doing nothing and returning S_OK
            //    fixes trident hosting in Win2000.
            // throw new COMException(String.Empty, NativeMethods.E_NOTIMPL);
        }

        public virtual void InsertMenus(IntPtr hmenuShared, object lpMenuWidths) {
            throw new COMException(String.Empty, NativeMethods.E_NOTIMPL);
        }

        public virtual void SetMenu(IntPtr hmenuShared, IntPtr holemenu, IntPtr hwndActiveObject) {
            throw new COMException(String.Empty, NativeMethods.E_NOTIMPL);
        }

        public virtual void RemoveMenus(IntPtr hmenuShared) {
            throw new COMException(String.Empty, NativeMethods.E_NOTIMPL);
        }

        public virtual void SetStatusText(string pszStatusText) {
        }

        public virtual void EnableModeless(int fEnable) {
        }

        public virtual int TranslateAccelerator(ref NativeMethods.MSG lpmsg, short wID) {
            return NativeMethods.S_FALSE;
        }


        ///////////////////////////////////////////////////////////////////////////
        // IDocHostUIHandler Implementation

        public virtual int ShowContextMenu(int dwID, NativeMethods.POINT pt, object pcmdtReserved, object pdispReserved) {
            return NativeMethods.S_OK;
        }

        public virtual int GetHostInfo(NativeMethods.DOCHOSTUIINFO info) {
            info.dwDoubleClick = NativeMethods.DOCHOSTUIDBLCLICK.DEFAULT;
            info.dwFlags = NativeMethods.DOCHOSTUIFLAG.FLAT_SCROLLBAR |
                           NativeMethods.DOCHOSTUIFLAG.NO3DBORDER |
                           NativeMethods.DOCHOSTUIFLAG.DIALOG |
                           NativeMethods.DOCHOSTUIFLAG.DISABLE_SCRIPT_INACTIVE;

            return NativeMethods.S_OK;
        }

        public virtual int EnableModeless(bool fEnable) {
            return NativeMethods.S_OK;
        }

        public virtual int ShowUI(int dwID, NativeMethods.IOleInPlaceActiveObject activeObject, NativeMethods.IOleCommandTarget commandTarget, NativeMethods.IOleInPlaceFrame frame, NativeMethods.IOleInPlaceUIWindow doc) {
            return NativeMethods.S_OK;
        }

        public virtual int HideUI() {
            return NativeMethods.S_OK;
        }

        public virtual int UpdateUI() {
            return NativeMethods.S_OK;
        }

        public virtual int OnDocWindowActivate(bool fActivate) {
            return NativeMethods.E_NOTIMPL;
        }

        public virtual int OnFrameWindowActivate(bool fActivate) {
            return NativeMethods.E_NOTIMPL;
        }

        public virtual int ResizeBorder(NativeMethods.COMRECT rect, NativeMethods.IOleInPlaceUIWindow doc, bool fFrameWindow) {
            return NativeMethods.E_NOTIMPL;
        }

        public virtual int GetOptionKeyPath(string[] pbstrKey, int dw) {
            pbstrKey[0] = null;
            return NativeMethods.S_OK;
        }

        public virtual int GetDropTarget(NativeMethods.IOleDropTarget pDropTarget, out NativeMethods.IOleDropTarget ppDropTarget) {
            ppDropTarget = null;
            return NativeMethods.S_FALSE;
        }

        public virtual int GetExternal(out object ppDispatch) {
            ppDispatch = null;
            return NativeMethods.S_OK;
        }

        public virtual int TranslateAccelerator(ref NativeMethods.MSG msg, ref Guid group, int nCmdID) {
            return NativeMethods.S_OK;
        }

        public virtual int TranslateUrl(int dwTranslate, string strUrlIn, out string pstrUrlOut) {
            pstrUrlOut = null;
            return NativeMethods.E_NOTIMPL;
        }

        public virtual int FilterDataObject(NativeMethods.IOleDataObject pDO, out NativeMethods.IOleDataObject ppDORet) {
            ppDORet = null;
            return NativeMethods.S_OK;
        }


        ///////////////////////////////////////////////////////////////////////////
        // Implementation

        /// <include file='doc\MSHTMLHost.uex' path='docs/doc[@for="TridentSite.CreateDocument"]/*' />
        /// <devdoc>
        ///     Creates a new instance of mshtml and initializes it as a new document
        ///     using its IPersistStreamInit.
        /// </devdoc>
        protected void CreateDocument() {

            try {
                // Create an instance of Trident
                tridentDocument = (NativeMethods.IHTMLDocument2)new NativeMethods.HTMLDocument();
                tridentOleObject = (NativeMethods.IOleObject)tridentDocument;

                // Initialize its client site
                tridentOleObject.SetClientSite((NativeMethods.IOleClientSite)this);

                // Initialize it
                NativeMethods.IPersistStreamInit psi = (NativeMethods.IPersistStreamInit)tridentDocument;
                psi.InitNew();
            }
            catch (Exception e) {
                Debug.Fail(e.ToString());
                throw e;
            }
        }

        /// <include file='doc\MSHTMLHost.uex' path='docs/doc[@for="TridentSite.CloseDocument"]/*' />
        /// <devdoc>
        ///     Closes the mshtml instance by deactivating and releasing it.
        /// </devdoc>
        protected void CloseDocument() {
            try {
                if (tridentDocument != null) {
                    tridentView = null;
                    tridentDocument = null;

                    tridentOleObject.Close(NativeMethods.OLECLOSE_NOSAVE);
                    tridentOleObject.SetClientSite(null);
                    tridentOleObject = null;
                }
            }
            catch (Exception e) {
                Debug.Fail(e.ToString());
            }
        }

        /// <include file='doc\MSHTMLHost.uex' path='docs/doc[@for="TridentSite.ActivateDocument"]/*' />
        /// <devdoc>
        ///     Activates the mshtml instance
        /// </devdoc>
        protected void ActivateDocument() {
            Debug.Assert(tridentOleObject != null,
                         "How'd we get here when trident is null!");

            try {
                NativeMethods.COMRECT r = new NativeMethods.COMRECT();

                NativeMethods.GetClientRect(parentControl.Handle, r);
                tridentOleObject.DoVerb(NativeMethods.OLEIVERB_UIACTIVATE, IntPtr.Zero, (NativeMethods.IOleClientSite)this, 0, parentControl.Handle, r);
            }
            catch (Exception e) {
                Debug.Fail(e.ToString());
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\util\iconbutton.cs ===
//------------------------------------------------------------------------------
// <copyright file="IconButton.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.Util {

    using System;
    using System.ComponentModel;
    using System.Design;
    using System.Diagnostics;
    using System.Drawing;
    using System.Windows.Forms;

    /// <include file='doc\IconButton.uex' path='docs/doc[@for="IconButton"]/*' />
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal sealed class IconButton : Button {

        private Icon icon;

        public IconButton() {
            FlatStyle = FlatStyle.System;
        }

        protected override CreateParams CreateParams {
            get {
                CreateParams cp = base.CreateParams;
                cp.Style |= NativeMethods.BS_ICON;

                return cp;
            }
        }
        
        public Icon Icon {
            get {
                return icon;
            }
            set {
                icon = value;
                if (IsHandleCreated) {
                    UpdateIcon();
                }
            }
        }

        protected override void OnHandleCreated(EventArgs e) {
            base.OnHandleCreated(e);
            UpdateIcon();
        }
        
        private void UpdateIcon() {
            IntPtr iconHandle = IntPtr.Zero;

            if (icon != null) {
                iconHandle = icon.Handle;
                Debug.Assert(iconHandle != IntPtr.Zero);
            }

            NativeMethods.SendMessage(Handle, NativeMethods.BM_SETIMAGE, (IntPtr)NativeMethods.IMAGE_ICON, iconHandle);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\util\unsettablecombobox.cs ===
//------------------------------------------------------------------------------
// <copyright file="UnsettableComboBox.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

// UnsettableComboBox.cs
//
// 12/22/98: Created: NikhilKo
//

namespace System.Web.UI.Design.Util {

    using System;
    using System.Design;
    using System.ComponentModel;
    using System.Windows.Forms;
    using System.Diagnostics;
    using System.Drawing;
    using System.Web.UI.Design;

    /// <include file='doc\UnsettableComboBox.uex' path='docs/doc[@for="UnsettableComboBox"]/*' />
    /// <devdoc>
    ///   Standard combobox with a "Not Set" item as the first item in its dropdown.
    ///   It also automatically blanks out the "Not Set" item on losing focus.
    /// </devdoc>
    /// <internalonly/>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal sealed class UnsettableComboBox : ComboBox {
        private string notSetText;
        private bool internalChange;

        public UnsettableComboBox() {
            notSetText = SR.GetString(SR.UnsettableComboBox_NotSet);
            Items.Add(notSetText);
        }

        public string NotSetText {
            get {
                return notSetText;
            }
            set {
                notSetText = value;
                Items.RemoveAt(0);
                Items.Insert(0, notSetText);
            }
        }

        public override string Text {
            get {
                if ((this.SelectedIndex == 0) || (this.SelectedIndex == -1))
                    return String.Empty;
                else
                    return base.Text;
            }
            set {
                base.Text = value;
            }
        }

        public void AddItem(object item) {
            Items.Add(item);
        }

        public void EnsureNotSetItem() {
            if (Items.Count == 0) {
                Items.Add(notSetText);
            }
        }

        public bool IsSet() {
            return SelectedIndex > 0;
        }

        protected override void OnLostFocus(EventArgs e) {
            base.OnLostFocus(e);

            if (SelectedIndex == 0) {
                internalChange = true;
                SelectedIndex = -1;
                internalChange = false;
            }
        }

        protected override void OnSelectedIndexChanged(EventArgs e) {
            if (internalChange == false) {
                base.OnSelectedIndexChanged(e);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\webcontrols\adrotatordesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="AdRotatorDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.WebControls {
    using System.ComponentModel;

    using System.Diagnostics;

    using System.Web.UI.WebControls;
    using Microsoft.Win32;    
    using System;
    using System.IO;
    using System.Web.UI;
    using System.Reflection;

    /// <include file='doc\AdRotatorDesigner.uex' path='docs/doc[@for="AdRotatorDesigner"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides design-time support for the <see cref='System.Web.UI.WebControls.AdRotator'/>
    ///       web control.
    ///    </para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public class AdRotatorDesigner : ControlDesigner {

        /// <include file='doc\AdRotatorDesigner.uex' path='docs/doc[@for="AdRotatorDesigner.GetDesignTimeHtml"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the design-time HTML of the <see cref='System.Web.UI.WebControls.AdRotator'/>
        ///       web control
        ///    </para>
        /// </devdoc>

        public override string GetDesignTimeHtml() {

            AdRotator adRotator = (AdRotator) Component;

            StringWriter sw = new StringWriter();
            HtmlTextWriter tw = new HtmlTextWriter(sw);

            // we want to put some properties on the link, and some on the image, so we
            // create temporary objects for rendinger and distribute the properties.
            HyperLink bannerLink = new HyperLink();
            bannerLink.ID = adRotator.ID;
            bannerLink.NavigateUrl = "";
            bannerLink.Target = adRotator.Target;
            bannerLink.AccessKey = adRotator.AccessKey;
            bannerLink.Enabled = adRotator.Enabled;
            bannerLink.TabIndex = adRotator.TabIndex;
            bannerLink.RenderBeginTag(tw);

            Image bannerImage = new Image();
            // apply style copies most style-related properties
            bannerImage.ApplyStyle(adRotator.ControlStyle);
            bannerImage.ImageUrl = "";
            bannerImage.AlternateText = adRotator.ID;
            bannerImage.ToolTip = adRotator.ToolTip;
            bannerImage.RenderControl(tw);

            bannerLink.RenderEndTag(tw);
            
            return sw.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\webcontrols\basedatalistcomponenteditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="BaseDataListComponentEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.WebControls {

    using System;
    using System.Design;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Web.UI.Design.WebControls.ListControls;
    using System.Web.UI.WebControls;
    using System.Windows.Forms;
    using System.Windows.Forms.Design;

    /// <include file='doc\BaseDataListComponentEditor.uex' path='docs/doc[@for="BaseDataListComponentEditor"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides the
    ///       base component editor for Web Forms DataGrid and DataList controls.
    ///    </para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public abstract class BaseDataListComponentEditor : WindowsFormsComponentEditor {

        private int initialPage;

        /// <include file='doc\BaseDataListComponentEditor.uex' path='docs/doc[@for="BaseDataListComponentEditor.BaseDataListComponentEditor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.Web.UI.Design.WebControls.BaseDataListComponentEditor'/>.
        ///    </para>
        /// </devdoc>
        public BaseDataListComponentEditor(int initialPage) {
            this.initialPage = initialPage;
        }

        /// <include file='doc\BaseDataListComponentEditor.uex' path='docs/doc[@for="BaseDataListComponentEditor.EditComponent"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Edits a component.
        ///    </para>
        /// </devdoc>
        public override bool EditComponent(ITypeDescriptorContext context, object obj, IWin32Window parent) {
            bool result = false;
            bool inTemplateMode = false;

            Debug.Assert(obj is IComponent, "Expected obj to be an IComponent");
            IComponent comp = (IComponent)obj;
            ISite compSite = comp.Site;

            if (compSite != null) {
                IDesignerHost designerHost = (IDesignerHost)compSite.GetService(typeof(IDesignerHost));

                IDesigner compDesigner = designerHost.GetDesigner(comp);
                Debug.Assert(compDesigner is TemplatedControlDesigner,
                             "Expected BaseDataList to have a TemplatedControlDesigner");

                TemplatedControlDesigner tplDesigner = (TemplatedControlDesigner)compDesigner;
                inTemplateMode = tplDesigner.InTemplateMode;
            }
            
            if (inTemplateMode == false) {
                result = base.EditComponent(context, obj, parent);
            }
            else {
                MessageBox.Show(SR.GetString(SR.BDL_TemplateModePropBuilder),
                                SR.GetString(SR.BDL_PropertyBuilder),
                                MessageBoxButtons.OK, MessageBoxIcon.Information);
            }
            return result;
        }

        /// <include file='doc\BaseDataListComponentEditor.uex' path='docs/doc[@for="BaseDataListComponentEditor.GetInitialComponentEditorPageIndex"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the index of the initial component editor page.
        ///    </para>
        /// </devdoc>
        protected override int GetInitialComponentEditorPageIndex() {
            return initialPage;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\webcontrols\buttondesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="ButtonDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.WebControls {
    using System.ComponentModel;

    using System.Diagnostics;

    using System;
    using System.Web.UI.WebControls;
    using Microsoft.Win32;

    /// <include file='doc\ButtonDesigner.uex' path='docs/doc[@for="ButtonDesigner"]/*' />
    /// <devdoc>
    ///    <para>
    ///       The designer for the button WebControl.
    ///    </para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public class ButtonDesigner : ControlDesigner {

        /// <include file='doc\ButtonDesigner.uex' path='docs/doc[@for="ButtonDesigner.GetDesignTimeHtml"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the design time HTML of the button control.
        ///    </para>
        /// </devdoc>
        public override string GetDesignTimeHtml() {
            Button b = (Button)Component;
            string originalText  = b.Text;

            Debug.Assert(originalText != null);
            bool blank = (originalText.Trim().Length == 0);

            if (blank) {
                b.Text = "[" + b.ID + "]";
            }

            string html = base.GetDesignTimeHtml();

            if (blank) {
                b.Text = originalText;
            }

            return html;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\webcontrols\basevalidatordesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="BaseValidatorDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.WebControls {
    
    using System.ComponentModel;

    using System.Web.UI.WebControls;

    /// <include file='doc\BaseValidatorDesigner.uex' path='docs/doc[@for="BaseValidatorDesigner"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides
    ///       a designer for controls derived from ValidatorBase.
    ///    </para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public class BaseValidatorDesigner : ControlDesigner {

        /// <include file='doc\BaseValidatorDesigner.uex' path='docs/doc[@for="BaseValidatorDesigner.GetDesignTimeHtml"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the design time HTML of ValidatorBase controls.
        ///    </para>
        /// </devdoc>
        public override string GetDesignTimeHtml() {
            BaseValidator bv = (BaseValidator)Component;
            
            // Set to false to force a render
            bv.IsValid = false;
            
            // Put in dummy text if required
            string originalText  = bv.ErrorMessage;
            ValidatorDisplay validatorDisplay = bv.Display;
            bool blank = (validatorDisplay == ValidatorDisplay.None || (originalText.Trim().Length == 0 && bv.Text.Trim().Length == 0));
            if (blank) {
                bv.ErrorMessage = "[" + bv.ID + "]";
                bv.Display = ValidatorDisplay.Static;
            }

            string html = base.GetDesignTimeHtml();

            // Reset the control state
            if (blank) {
                bv.ErrorMessage = originalText;
                bv.Display = validatorDisplay;
            }

            return html;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\util\unitcontrol.cs ===
//------------------------------------------------------------------------------
// <copyright file="UnitControl.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

// UnitControl.cs
//
// 12/22/98: Created: NikhilKo
//

namespace System.Web.UI.Design.Util {
    using System.Runtime.Serialization.Formatters;

    using System.Diagnostics;

    using System.Globalization;
    using System;
    using System.ComponentModel;
    using System.Windows.Forms;
    using System.Drawing;

    using Microsoft.Win32;

    /// <include file='doc\UnitControl.uex' path='docs/doc[@for="UnitControl"]/*' />
    /// <devdoc>
    ///     UnitControl
    ///     Provides a UI to edit a unit, i.e., its value and type.
    ///     Additionally allows placing restrictions on the types of units that
    ///     that can be entered.
    /// </devdoc>
    /// <internalonly/>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal sealed class UnitControl : Panel {
        ///////////////////////////////////////////////////////////////////////////
        // Constants

        // UI Layout constants
        private const int EDIT_X_SIZE = 44;
        private const int COMBO_X_SIZE = 40;
        private const int SEPARATOR_X_SIZE = 4;
        private const int CTL_Y_SIZE = 21;

        // Units
        public const int UNIT_PX = 0;
        public const int UNIT_PT = 1;
        public const int UNIT_PC = 2;
        public const int UNIT_MM = 3;
        public const int UNIT_CM = 4;
        public const int UNIT_IN = 5;
        public const int UNIT_EM = 6;
        public const int UNIT_EX = 7;
        public const int UNIT_PERCENT = 8;
        public const int UNIT_NONE = 9;

        private static readonly string[] UNIT_VALUES = new string[] {
            "px", "pt", "pc", "mm", "cm", "in", "em", "ex", "%", ""
        };


        ///////////////////////////////////////////////////////////////////////////
        // Members

        private NumberEdit valueEdit;
        private ComboBox unitCombo;

        private bool allowPercent = true;
        private bool allowNonUnit = false;

        private int defaultUnit = UNIT_PT;
        private int minValue = 0;
        private int maxValue = 0xFFFF;
        private bool validateMinMax = false;

        private EventHandler onChangedHandler = null;

        private bool initMode = false;
        private bool internalChange = false;
        private bool valueChanged = false;


        ///////////////////////////////////////////////////////////////////////////
        // Constructor

        /// <include file='doc\UnitControl.uex' path='docs/doc[@for="UnitControl.UnitControl"]/*' />
        /// <devdoc>
        ///     Createa a new UnitControl.
        /// </devdoc>
        public UnitControl() {
            initMode = true;

            Size = new Size((EDIT_X_SIZE + COMBO_X_SIZE + SEPARATOR_X_SIZE),
                             CTL_Y_SIZE);
            InitControl();
            InitUI();

            initMode = false;
        }

        ///////////////////////////////////////////////////////////////////////////
        // Properties

        /// <include file='doc\UnitControl.uex' path='docs/doc[@for="UnitControl.AllowNegativeValues"]/*' />
        /// <devdoc>
        ///     Controls whether the unit value can be negative
        /// </devdoc>
        public bool AllowNegativeValues {
            get {
                return valueEdit.AllowNegative;
            }
            set {
                valueEdit.AllowNegative = value;
            }
        }

        /// <include file='doc\UnitControl.uex' path='docs/doc[@for="UnitControl.AllowNonUnitValues"]/*' />
        /// <devdoc>
        ///     Controls whether the unit value can be a unit-less
        /// </devdoc>
        public bool AllowNonUnitValues {
            get {
                return allowNonUnit;
            }
            set {
                if (value == allowNonUnit)
                    return;

                if (value && !allowPercent) {
                    Debug.Fail("AllowPercentValues must be set to true first");
                    throw new Exception();
                }

                allowNonUnit = value;
                if (allowNonUnit)
                    unitCombo.Items.Add(UNIT_VALUES[UNIT_NONE]);
                else
                    unitCombo.Items.Remove(UNIT_VALUES[UNIT_NONE]);
            }
        }

        /// <include file='doc\UnitControl.uex' path='docs/doc[@for="UnitControl.AllowPercentValues"]/*' />
        /// <devdoc>
        ///     Controls whether the unit value can be a percent value
        /// </devdoc>
        public bool AllowPercentValues {
            get {
                return allowPercent;
            }
            set {
                if (value == allowPercent)
                    return;

                if (!value && allowNonUnit) {
                    Debug.Fail("AllowNonUnitValues must be set to false first");
                    throw new Exception();
                }

                allowPercent = value;
                if (allowPercent)
                    unitCombo.Items.Add(UNIT_VALUES[UNIT_PERCENT]);
                else
                    unitCombo.Items.Remove(UNIT_VALUES[UNIT_PERCENT]);
            }
        }

        /// <include file='doc\UnitControl.uex' path='docs/doc[@for="UnitControl.DefaultUnit"]/*' />
        /// <devdoc>
        ///     The default unit to be used
        /// </devdoc>
        public int DefaultUnit {
            get {
                return defaultUnit;
            }
            set {
                Debug.Assert((value >= UNIT_PX) &&
                             (value <= UNIT_NONE) &&
                             (allowNonUnit || (value != UNIT_NONE)) ||
                             (allowPercent || (value != UNIT_PERCENT)),
                             "Invalid default unit");

                defaultUnit = value;
            }
        }

        public int MaxValue {
            get {
                return maxValue;
            }
            set {
                maxValue = value;
            }
        }

        public int MinValue {
            get {
                return minValue;
            }
            set {
                minValue = value;
            }
        }

        protected override void OnEnabledChanged(EventArgs e) {
            base.OnEnabledChanged(e);

            valueEdit.Enabled = Enabled;
            unitCombo.Enabled = Enabled;
        }

        public bool ValidateMinMax {
            get {
                return validateMinMax;
            }
            set {
                validateMinMax = value;
            }
        }

        /// <include file='doc\UnitControl.uex' path='docs/doc[@for="UnitControl.Value"]/*' />
        /// <devdoc>
        ///     The unit reflecting the value and unit type within the UI.
        ///     Returns null if no unit is selected.
        /// </devdoc>
        public string Value {
            get {
                string value = GetValidatedValue();

                if (value == null) {
                    value = valueEdit.Text;
                }
                else {
                    valueEdit.Text = value;
                    OnValueTextChanged(valueEdit, EventArgs.Empty);
                }

                int unit = unitCombo.SelectedIndex;

                if ((value.Length == 0) || (unit == -1))
                    return null;

                return value + UNIT_VALUES[unit];
            }
            set {
                initMode = true;

                InitUI();
                if (value != null) {
                    string temp = value.Trim().ToLower(CultureInfo.InvariantCulture);
                    int len = temp.Length;

                    int unit = -1;
                    int iLastDigit = -1;
                    char ch;

                    // find the end of the number part
                    for (int i = 0; i < len; i++) {
                        ch = temp[i];
                        if (!(((ch >= '0') && (ch <= '9')) ||
                              (ch == '.') ||
                              (ch == '-') && (valueEdit.AllowNegative)))
                            break;
                        else
                            iLastDigit = i;
                    }
                    if (iLastDigit != -1) {
                        // detect the type of unit
                        if ((iLastDigit + 1) < len) {
                            int maxUnit = allowPercent ? UNIT_PERCENT : UNIT_EX;
                            string unitString = temp.Substring(iLastDigit+1);
                            for (int i = 0; i <= maxUnit; i++) {
                                if (UNIT_VALUES[i].Equals(unitString)) {
                                    unit = i;
                                    break;
                                }
                            }
                        } else if (allowNonUnit)
                            unit = UNIT_NONE;

                        if (unit != -1) {
                            valueEdit.Text = temp.Substring(0, iLastDigit+1);
                            unitCombo.SelectedIndex = unit;
                        }
                    }
                }
                initMode = false;
            }
        }


        ///////////////////////////////////////////////////////////////////////////
        // Events

        public event EventHandler Changed {
            add {
                onChangedHandler += value;
            }
            remove {
                onChangedHandler -= value;
            }
        }


        ///////////////////////////////////////////////////////////////////////////
        // Implementation

        /// <include file='doc\UnitControl.uex' path='docs/doc[@for="UnitControl.GetValidatedValue"]/*' />
        /// <devdoc>
        /// </devdoc>
        private string GetValidatedValue() {
            string validValue = null;
            if (validateMinMax) {
                string value = valueEdit.Text;

                if (value.Length != 0) {
                    try {
                        if (value.IndexOf('.') < 0) {
                            int valueNum = Int32.Parse(value, CultureInfo.InvariantCulture);
                            if (valueNum < minValue)
                                validValue = (minValue).ToString();
                            else if (valueNum > maxValue)
                                validValue = (maxValue).ToString();
                        }
                        else {
                            float valueNum = Single.Parse(value, CultureInfo.InvariantCulture);

                            if (valueNum < (float)minValue)
                                validValue = (minValue).ToString();
                            else if (valueNum > (float)maxValue)
                                validValue = (maxValue).ToString();
                        }
                    } catch (Exception) {
                        validValue = (maxValue).ToString();
                    }
                }
            }
            return validValue;
        }

        /// <include file='doc\UnitControl.uex' path='docs/doc[@for="UnitControl.InitControl"]/*' />
        /// <devdoc>
        ///     Create the contained controls and initialize their settings
        /// </devdoc>
        private void InitControl() {
            int editWidth = this.Width - (COMBO_X_SIZE + SEPARATOR_X_SIZE);
            if (editWidth < 0)
                editWidth = 0;

            valueEdit = new NumberEdit();
            valueEdit.Location = new Point(0, 0);
            valueEdit.Size = new Size(editWidth, CTL_Y_SIZE);
            valueEdit.TabIndex = 0;
            valueEdit.MaxLength = 10;
            valueEdit.TextChanged += new EventHandler(this.OnValueTextChanged);
            valueEdit.LostFocus += new EventHandler(this.OnValueLostFocus);

            unitCombo = new ComboBox();
            unitCombo.DropDownStyle = ComboBoxStyle.DropDownList;
            unitCombo.Location = new Point(editWidth + SEPARATOR_X_SIZE, 0);
            unitCombo.Size = new Size(COMBO_X_SIZE, CTL_Y_SIZE);
            unitCombo.TabIndex = 1;
            unitCombo.MaxDropDownItems = 9;
            unitCombo.SelectedIndexChanged += new EventHandler(this.OnUnitSelectedIndexChanged);

            this.Controls.Clear();
            this.Controls.AddRange(new Control[] {
                                        unitCombo,
                                        valueEdit});

            for (int i = UNIT_PX; i <= UNIT_EX; i++)
                unitCombo.Items.Add(UNIT_VALUES[i]);
            if (allowPercent)
                unitCombo.Items.Add(UNIT_VALUES[UNIT_PERCENT]);
            if (allowNonUnit)
                unitCombo.Items.Add(UNIT_VALUES[UNIT_NONE]);
        }

        /// <include file='doc\UnitControl.uex' path='docs/doc[@for="UnitControl.InitUI"]/*' />
        /// <devdoc>
        ///     Initialize the controls to their default state
        /// </devdoc>
        private void InitUI() {
            valueEdit.Text = "";
            unitCombo.SelectedIndex = -1;
        }

        /// <include file='doc\UnitControl.uex' path='docs/doc[@for="UnitControl.OnChanged"]/*' />
        /// <devdoc>
        ///     Fires the "changed" event.
        /// </devdoc>
        private void OnChanged(EventArgs e) {
            if (onChangedHandler != null)
                onChangedHandler.Invoke(this, e);
        }


        ///////////////////////////////////////////////////////////////////////////
        // Event Handlers

        protected override void OnGotFocus(EventArgs e) {
            valueEdit.Focus();
        }

        /// <include file='doc\UnitControl.uex' path='docs/doc[@for="UnitControl.OnValueTextChanged"]/*' />
        /// <devdoc>
        ///     Handles changes in the value edit control.
        ///     If there is no unit selected, and a value is entered, the default unit is
        ///     selected.  If the value is cleared, the unit is also deselected.
        /// </devdoc>
        private void OnValueTextChanged(object source, EventArgs e) {
            if (initMode)
                return;

            string text = valueEdit.Text;
            if (text.Length == 0) {
                internalChange = true;
                unitCombo.SelectedIndex = -1;
                internalChange = false;
            }
            else {
                if (unitCombo.SelectedIndex == -1) {
                    internalChange = true;
                    unitCombo.SelectedIndex = defaultUnit;
                    internalChange = false;
                }
            }
            valueChanged = true;
            OnChanged(null);
        }

        private void OnValueLostFocus(object source, EventArgs e) {
            if (valueChanged) {
                string value = GetValidatedValue();
                if (value != null) {
                    valueEdit.Text = value;
                    OnValueTextChanged(valueEdit, EventArgs.Empty);
                }

                valueChanged = false;
                OnChanged(EventArgs.Empty);
            }
        }

        /// <include file='doc\UnitControl.uex' path='docs/doc[@for="UnitControl.OnUnitSelectedIndexChanged"]/*' />
        /// <devdoc>
        ///     Handles the event when the unit combobox selection changes.
        ///     Fires a changed event.
        /// </devdoc>
        private void OnUnitSelectedIndexChanged(object source, EventArgs e) {
            if (initMode || internalChange)
                return;

            OnChanged(EventArgs.Empty);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\webcontrols\basedatalistdesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="BaseDataListDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.WebControls {
    using System;
    using System.Design;
    using System.Collections;    
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Data;
    using System.Diagnostics;
    using System.Drawing;
    using System.IO;
    using System.Text;
    using System.Web.UI;
    using System.Web.UI.Design;
    using System.Web.UI.Design.WebControls.ListControls;
    using System.Web.UI.WebControls;
    using System.Windows.Forms;
    using System.Windows.Forms.Design;

    using AttributeCollection = System.ComponentModel.AttributeCollection;
    using DataBinding = System.Web.UI.DataBinding;
    using DataGrid = System.Web.UI.WebControls.DataGrid;
    using DataSourceConverter = System.Web.UI.Design.DataSourceConverter;

    /// <include file='doc\BaseDataListDesigner.uex' path='docs/doc[@for="BaseDataListDesigner"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides the base designer class for the DataList WebControl.
    ///    </para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public abstract class BaseDataListDesigner : TemplatedControlDesigner, IDataSourceProvider {

        private BaseDataList bdl;

        private DataTable dummyDataTable;
        private DataTable designTimeDataTable;

        private DesignerVerbCollection designerVerbs;

        /// <include file='doc\BaseDataListDesigner.uex' path='docs/doc[@for="BaseDataListDesigner.BaseDataListDesigner"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='BaseDataListDesigner'/> .
        ///    </para>
        /// </devdoc>
        public BaseDataListDesigner() {
        }

        /// <include file='doc\BaseDataListDesigner.uex' path='docs/doc[@for="BaseDataListDesigner.DesignTimeHtmlRequiresLoadComplete"]/*' />
        public override bool DesignTimeHtmlRequiresLoadComplete {
            get {
                // if we have a data source, we're going to look it up in the container
                // and require the document to be loaded completely
                return (DataSource.Length != 0);
            }
        }

        /// <include file='doc\BaseDataListDesigner.uex' path='docs/doc[@for="BaseDataListDesigner.DataKeyField"]/*' />
        /// <devdoc>
        /// </devdoc>
        public string DataKeyField {
            get {
                return bdl.DataKeyField;
            }
            set {
                bdl.DataKeyField = value;
            }
        }
        
        /// <include file='doc\BaseDataListDesigner.uex' path='docs/doc[@for="BaseDataListDesigner.DataMember"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string DataMember {
            get {
                return bdl.DataMember;
            }
            set {
                bdl.DataMember = value;
                OnDataSourceChanged();
            }
        }
        
        /// <include file='doc\BaseDataListDesigner.uex' path='docs/doc[@for="BaseDataListDesigner.DataSource"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the data source property.
        ///    </para>
        /// </devdoc>
        public string DataSource {
            get {
                DataBinding binding = DataBindings["DataSource"];

                if (binding != null) {
                    return binding.Expression;
                }
                return String.Empty;
            }
            set {
                if ((value == null) || (value.Length == 0)) {
                    DataBindings.Remove("DataSource");
                }
                else {
                    DataBinding binding = DataBindings["DataSource"];

                    if (binding == null) {
                        binding = new DataBinding("DataSource", typeof(IEnumerable), value);
                    }
                    else {
                        binding.Expression = value;
                    }
                    DataBindings.Add(binding);
                }

                OnDataSourceChanged();
                OnBindingsCollectionChanged("DataSource");
            }
        }

        /// <include file='doc\BaseDataListDesigner.uex' path='docs/doc[@for="BaseDataListDesigner.Verbs"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The designer's collection of verbs.
        ///    </para>
        /// </devdoc>
        public override DesignerVerbCollection Verbs {
            get {
                if (designerVerbs == null) {
                    designerVerbs = new DesignerVerbCollection();
                    designerVerbs.Add(new DesignerVerb(SR.GetString(SR.BDL_AutoFormatVerb),
                                                        new EventHandler(this.OnAutoFormat)));
                    designerVerbs.Add(new DesignerVerb(SR.GetString(SR.BDL_PropertyBuilderVerb),
                                                        new EventHandler(this.OnPropertyBuilder)));
                }

                designerVerbs[0].Enabled = !this.InTemplateMode;
                designerVerbs[1].Enabled = !this.InTemplateMode;

                return designerVerbs;
            }
        }

        /// <include file='doc\BaseDataListDesigner.uex' path='docs/doc[@for="BaseDataListDesigner.Dispose"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Disposes of the resources (other than memory) used by
        ///       the <see cref='System.Web.UI.Design.WebControls.BaseDataListDesigner'/>.
        ///    </para>
        /// </devdoc>
        protected override void Dispose(bool disposing) {
            if (disposing) {
                bdl = null;
            }

            base.Dispose(disposing);
        }

        /// <include file='doc\BaseDataListDesigner.uex' path='docs/doc[@for="BaseDataListDesigner.GetDesignTimeDataSource"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets sample data matching the schema of the selected data source.
        ///    </para>
        /// </devdoc>
        protected IEnumerable GetDesignTimeDataSource(int minimumRows, out bool dummyDataSource) {
            IEnumerable selectedDataSource = GetResolvedSelectedDataSource();
            return GetDesignTimeDataSource(selectedDataSource, minimumRows, out dummyDataSource);
        }

        /// <include file='doc\BaseDataListDesigner.uex' path='docs/doc[@for="BaseDataListDesigner.GetDesignTimeDataSource1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets sample data matching the schema of the selected data source.
        ///    </para>
        /// </devdoc>
        protected IEnumerable GetDesignTimeDataSource(IEnumerable selectedDataSource, int minimumRows, out bool dummyDataSource) {
            DataTable dataTable = designTimeDataTable;
            dummyDataSource = false;

            // use the datatable corresponding to the selected datasource if possible
            if (dataTable == null) {
                if (selectedDataSource != null) {
                    designTimeDataTable = DesignTimeData.CreateSampleDataTable(selectedDataSource);

                    dataTable = designTimeDataTable;
                }

                if (dataTable == null) {
                    // fallback on a dummy datasource if we can't create a sample datatable
                    if (dummyDataTable == null) {
                        dummyDataTable = DesignTimeData.CreateDummyDataTable();
                    }

                    dataTable = dummyDataTable;
                    dummyDataSource = true;
                }
            }

            IEnumerable liveDataSource = DesignTimeData.GetDesignTimeDataSource(dataTable, minimumRows);
            return liveDataSource;
        }

        /// <include file='doc\BaseDataListDesigner.uex' path='docs/doc[@for="BaseDataListDesigner.GetResolvedSelectedDataSource"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public IEnumerable GetResolvedSelectedDataSource() {
            IEnumerable selectedDataSource = null;

            DataBinding binding = DataBindings["DataSource"];

            if (binding != null) {
                selectedDataSource = DesignTimeData.GetSelectedDataSource(bdl, binding.Expression, DataMember);
            }

            return selectedDataSource;
        }

        /// <include file='doc\BaseDataListDesigner.uex' path='docs/doc[@for="BaseDataListDesigner.GetSelectedDataSource"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the selected data source component from the component's container.
        ///    </para>
        /// </devdoc>
        public object GetSelectedDataSource() {
            object selectedDataSource = null;

            DataBinding binding = DataBindings["DataSource"];

            if (binding != null) {
                selectedDataSource = DesignTimeData.GetSelectedDataSource(bdl, binding.Expression);
            }

            return selectedDataSource;
        }

        /// <include file='doc\BaseDataListDesigner.uex' path='docs/doc[@for="BaseDataListDesigner.GetTemplateContainerDataSource"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the template's container's data source.
        ///    </para>
        /// </devdoc>
        public override IEnumerable GetTemplateContainerDataSource(string templateName) {
            return GetResolvedSelectedDataSource();
        }

        /// <include file='doc\BaseDataListDesigner.uex' path='docs/doc[@for="BaseDataListDesigner.Initialize"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes the designer with the DataGrid control that this instance
        ///       of the designer is associated with.
        ///    </para>
        /// </devdoc>
        public override void Initialize(IComponent component) {
            Debug.Assert(component is BaseDataList,
                         "BaseDataListDesigner::Initialize - Invalid BaseDataList Control");

            bdl = (BaseDataList)component;
            base.Initialize(component);
        }

        /// <include file='doc\BaseDataListDesigner.uex' path='docs/doc[@for="BaseDataListDesigner.InvokePropertyBuilder"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Invokes the property builder beginning with the specified page.
        ///    </para>
        /// </devdoc>
        protected internal void InvokePropertyBuilder(int initialPage) {
            IServiceProvider site = bdl.Site;
            IComponentChangeService changeService = null;

            DesignerTransaction transaction = null;

            try {
                if (site != null) {
                    IDesignerHost designerHost = (IDesignerHost)site.GetService(typeof(IDesignerHost));
                    Debug.Assert(designerHost != null);
                    transaction = designerHost.CreateTransaction(SR.GetString(SR.BDL_PropertyBuilderVerb));

                    changeService = (IComponentChangeService)site.GetService(typeof(IComponentChangeService));
                    if (changeService != null) {
                        try {
                            changeService.OnComponentChanging(bdl, null);
                        }
                        catch (CheckoutException ex) {
                            if (ex == CheckoutException.Canceled)
                                return;
                            throw ex;
                        }
                    }
                }

                bool success = false;
                try {
                    ComponentEditor compEditor;
                    if (bdl is DataGrid) {
                        compEditor = new DataGridComponentEditor(initialPage);
                    }
                    else {
                        compEditor = new DataListComponentEditor(initialPage);
                    }

                    success = compEditor.EditComponent(bdl);
                }
                finally {
                    if (success && changeService != null) {
                        changeService.OnComponentChanged(bdl, null, null, null);
                    }
                }
            }
            finally {
                if (transaction != null) {
                    transaction.Commit();
                }
            }
        }

        /// <include file='doc\BaseDataListDesigner.uex' path='docs/doc[@for="BaseDataListDesigner.OnAutoFormat"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Represents the method that will handle the AutoFormat event.
        ///    </para>
        /// </devdoc>
        protected void OnAutoFormat(object sender, EventArgs e) {
            IServiceProvider site = bdl.Site;
            IComponentChangeService changeService = null;
            
            DesignerTransaction transaction = null;
            DialogResult result = DialogResult.Cancel;

            try {
                if (site != null) {
                    IDesignerHost designerHost = (IDesignerHost)site.GetService(typeof(IDesignerHost));
                    Debug.Assert(designerHost != null);

                    transaction = designerHost.CreateTransaction(SR.GetString(SR.BDL_AutoFormatVerb));
                    
                    changeService = (IComponentChangeService)site.GetService(typeof(IComponentChangeService));
                    if (changeService != null) {
                        try {
                            changeService.OnComponentChanging(bdl, null);
                        }
                        catch (CheckoutException ex) {
                            if (ex == CheckoutException.Canceled)
                                return;
                            throw ex;
                        }
                    }
                }

                try {
                    AutoFormatDialog dlg = new AutoFormatDialog();

                    dlg.SetComponent(bdl);
                    result = dlg.ShowDialog();
                }
                finally {
                    if ((result == DialogResult.OK) && (changeService != null)) {
                        changeService.OnComponentChanged(bdl, null, null, null);
                        OnStylesChanged();
                    }
                }
            }
            finally {
                if (result == DialogResult.OK) {
                    transaction.Commit();
                }
                else {
                    transaction.Cancel();
                }
            }
        }

        /// <include file='doc\BaseDataListDesigner.uex' path='docs/doc[@for="BaseDataListDesigner.OnComponentChanged"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Represents the method that will handle the component change event.
        ///    </para>
        /// </devdoc>
        public override void OnComponentChanged(object sender, ComponentChangedEventArgs e) {
            if (e.Member != null) {
                string memberName = e.Member.Name;
                if (memberName.Equals("DataSource") || memberName.Equals("DataMember")) {
                    OnDataSourceChanged();
                }
                else if (memberName.Equals("ItemStyle") ||
                         memberName.Equals("AlternatingItemStyle") ||
                         memberName.Equals("SelectedItemStyle") ||
                         memberName.Equals("EditItemStyle") ||
                         memberName.Equals("HeaderStyle") ||
                         memberName.Equals("FooterStyle") ||
                         memberName.Equals("SeparatorStyle") ||
                         memberName.Equals("Font") ||
                         memberName.Equals("ForeColor") ||
                         memberName.Equals("BackColor")) {
                    OnStylesChanged();
                }
            }

            base.OnComponentChanged(sender, e);
        }

        /// <include file='doc\BaseDataListDesigner.uex' path='docs/doc[@for="BaseDataListDesigner.OnDataSourceChanged"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Raises the DataSourceChanged event.
        ///    </para>
        /// </devdoc>
        protected internal virtual void OnDataSourceChanged() {
            designTimeDataTable = null;
        }

        /// <include file='doc\BaseDataListDesigner.uex' path='docs/doc[@for="BaseDataListDesigner.OnPropertyBuilder"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Represents the method that will handle the property builder event.
        ///    </para>
        /// </devdoc>
        protected void OnPropertyBuilder(object sender, EventArgs e) {
            InvokePropertyBuilder(0);
        }

        /// <include file='doc\BaseDataListDesigner.uex' path='docs/doc[@for="BaseDataListDesigner.OnStylesChanged"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Notification that is called when styles have been changed.
        ///    </para>
        /// </devdoc>
        protected internal void OnStylesChanged() {
            OnTemplateEditingVerbsChanged();
        }

        /// <include file='doc\BaseDataListDesigner.uex' path='docs/doc[@for="BaseDataListDesigner.OnTemplateEditingVerbsChanged"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Notification that is called when templates are changed.
        ///    </para>
        /// </devdoc>
        protected abstract void OnTemplateEditingVerbsChanged();

        /// <include file='doc\BaseDataListDesigner.uex' path='docs/doc[@for="BaseDataListDesigner.PreFilterProperties"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Filter the properties to replace the runtime DataSource property
        ///       descriptor with the designer's.
        ///    </para>
        /// </devdoc>
        protected override void PreFilterProperties(IDictionary properties) {
            base.PreFilterProperties(properties);

            PropertyDescriptor prop;

            prop = (PropertyDescriptor)properties["DataSource"];
            Debug.Assert(prop != null);

            // we can't create the designer DataSource property based on the runtime property since theie
            // types do not match. Therefore, we have to copy over all the attributes from the runtime
            // and use them that way.
            AttributeCollection runtimeAttributes = prop.Attributes;
            Attribute[] attrs = new Attribute[runtimeAttributes.Count + 1];

            runtimeAttributes.CopyTo(attrs, 0);
            attrs[runtimeAttributes.Count] = new TypeConverterAttribute(typeof(DataSourceConverter));
            prop = TypeDescriptor.CreateProperty(this.GetType(), "DataSource", typeof(string),
                                                 attrs);
            properties["DataSource"] = prop;
            
            prop = (PropertyDescriptor)properties["DataMember"];
            Debug.Assert(prop != null);
            prop = TypeDescriptor.CreateProperty(this.GetType(), prop,
                                                 new Attribute[] {
                                                     new TypeConverterAttribute(typeof(DataMemberConverter))
                                                 });
            properties["DataMember"] = prop;

            prop = (PropertyDescriptor)properties["DataKeyField"];
            Debug.Assert(prop != null);
            prop = TypeDescriptor.CreateProperty(this.GetType(), prop,
                                                 new Attribute[] {
                                                     new TypeConverterAttribute(typeof(DataFieldConverter))
                                                 });
            properties["DataKeyField"] = prop;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\webcontrols\checkboxdesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="CheckBoxDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.WebControls {
    using System.ComponentModel;

    using System.Diagnostics;

    using System;
    using System.Web.UI.WebControls;
    using Microsoft.Win32;

    /// <include file='doc\CheckBoxDesigner.uex' path='docs/doc[@for="CheckBoxDesigner"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides a designer for the <see cref='System.Web.UI.WebControls.CheckBox'/>
    ///       control.
    ///    </para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public class CheckBoxDesigner : ControlDesigner {

        /// <include file='doc\CheckBoxDesigner.uex' path='docs/doc[@for="CheckBoxDesigner.GetDesignTimeHtml"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the design time HTML of the <see cref='System.Web.UI.WebControls.CheckBox'/>
        ///       control.
        ///    </para>
        /// </devdoc>
        public override string GetDesignTimeHtml() {
            CheckBox c = (CheckBox)Component;
            string originalText  = c.Text;
            bool blank = (originalText == null) || (originalText.Length == 0);

            if (blank) {
                c.Text = "[" + c.ID + "]";
            }

            string html = base.GetDesignTimeHtml();

            if (blank) {
                c.Text = originalText;
            }

            return html;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\webcontrols\calendardatabindinghandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="CalendarDataBindingHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design {

    using System;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Reflection;
    using System.Web.UI;
    using System.Web.UI.WebControls;

    /// <include file='doc\CalendarDataBindingHandler.uex' path='docs/doc[@for="CalendarDataBindingHandler"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public class CalendarDataBindingHandler : DataBindingHandler {

        /// <include file='doc\CalendarDataBindingHandler.uex' path='docs/doc[@for="CalendarDataBindingHandler.DataBindControl"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void DataBindControl(IDesignerHost designerHost, Control control) {
            Debug.Assert(control is Calendar, "Expected a Calendar");
            Calendar calendar = (Calendar)control;

            DataBinding dateBinding = ((IDataBindingsAccessor)calendar).DataBindings["SelectedDate"];
            if (dateBinding != null) {
                calendar.SelectedDate = DateTime.Today;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\webcontrols\calendarautoformatdialog.cs ===
//------------------------------------------------------------------------------
// <copyright file="CalendarAutoFormatDialog.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.WebControls {

    using System.Design;
    using System.Runtime.InteropServices;    
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.Windows.Forms;    
    using System.Windows.Forms.Design;
    using System.ComponentModel.Design;
    using System.Drawing;
    using System.Web.UI.WebControls;
    using System.Web.UI.Design.Util;

    // To resolve ambiguities between Web Forms and system objects
    using Unit = System.Web.UI.WebControls.Unit;

    /// <include file='doc\CalendarAutoFormatDialog.uex' path='docs/doc[@for="CalendarAutoFormatDialog"]/*' />
    /// <devdoc>
    ///    <para>
    ///       The AutoFormat page for a <see cref='System.Web.UI.WebControls.Calendar'/>
    ///       control
    ///    </para>
    /// </devdoc>
    [
    System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode),
    ToolboxItem(false)
    ]
    public class CalendarAutoFormatDialog : Form {

        // Components added to the property page
        private Windows.Forms.Label schemeNameLabel;
        private Windows.Forms.ListBox schemeNameList;
        private Windows.Forms.Label schemePreviewLabel;
        private Windows.Forms.Button cancelButton;
        private Windows.Forms.Button okButton;
        private MSHTMLHost schemePreview;
        private Calendar calendar;

        // Flags corresponding to each component
        private bool schemeDirty;
        private bool firstActivate = true;

        /// <include file='doc\CalendarAutoFormatDialog.uex' path='docs/doc[@for="CalendarAutoFormatDialog.CalendarAutoFormatDialog"]/*' />
        /// <devdoc>
        ///    Create a new AutoFormatPage instance
        /// </devdoc>
        /// <internalonly/>
        public CalendarAutoFormatDialog(Calendar calendar) : base() {
            this.calendar = calendar;
            InitForm();

        }
        
        /// <include file='doc\CalendarAutoFormatDialog.uex' path='docs/doc[@for="CalendarAutoFormatDialog.DoDelayLoadActions"]/*' />
        /// <devdoc>
        ///    Executes any initialization that was delayed until the first idle time
        /// </devdoc>
        /// <internalonly/>
        protected void DoDelayLoadActions() {
            schemePreview.CreateTrident();
            schemePreview.ActivateTrident();
        }

        /// <include file='doc\CalendarAutoFormatDialog.uex' path='docs/doc[@for="CalendarAutoFormatDialog.GetPreviewCalendar"]/*' />
        /// <devdoc>
        ///    Create a new Calendar object for previewing
        /// </devdoc>
        /// <internalonly/>
        private Calendar GetPreviewCalendar() { 
        
            // create a new calendar to preview
            Calendar previewCal = new Calendar();

            // Modify its components based on the current calendar
            previewCal.ShowTitle = calendar.ShowTitle;
            previewCal.ShowNextPrevMonth = calendar.ShowNextPrevMonth;
            previewCal.ShowDayHeader = calendar.ShowDayHeader;
            previewCal.SelectionMode = calendar.SelectionMode;

            WCScheme selectedScheme = (WCScheme) schemeNameList.SelectedItem;
            selectedScheme.Apply(previewCal);

            return previewCal;
        }
        
        /// <include file='doc\CalendarAutoFormatDialog.uex' path='docs/doc[@for="CalendarAutoFormatDialog.InitForm"]/*' />
        /// <devdoc>
        ///    Initialize the UI of this page
        /// </devdoc>
        /// <internalonly/>
        private void InitForm() {

            this.schemeNameLabel = new Windows.Forms.Label();
            this.schemeNameList = new Windows.Forms.ListBox();
            this.schemePreviewLabel = new Windows.Forms.Label();
            this.schemePreview = new MSHTMLHost();
            this.cancelButton = new Windows.Forms.Button();
            this.okButton = new Windows.Forms.Button();
            Windows.Forms.Button helpButton = new Windows.Forms.Button();

            schemeNameLabel.SetBounds(8, 10, 154, 16);
            schemeNameLabel.Text = SR.GetString(SR.CalAFmt_SchemeName);
            schemeNameLabel.TabStop = false;
            schemeNameLabel.TabIndex = 1;

            schemeNameList.TabIndex = 2;
            schemeNameList.SetBounds(8, 26, 150, 100);
            schemeNameList.UseTabStops = true;
            schemeNameList.IntegralHeight = false;
            schemeNameList.Items.AddRange(new object [] { 
                                                     new WCSchemeNone(),
                                                     new WCSchemeStandard(), 
                                                     new WCSchemeProfessional1(),
                                                     new WCSchemeProfessional2(),
                                                     new WCSchemeClassic(),
                                                     new WCSchemeColorful1(),
                                                     new WCSchemeColorful2(),
                                                     });
            schemeNameList.SelectedIndexChanged += new EventHandler(this.OnSelChangedScheme);

            schemePreviewLabel.SetBounds(165, 10, 92, 16);
            schemePreviewLabel.Text = SR.GetString(SR.CalAFmt_Preview);
            schemePreviewLabel.TabStop = false;
            schemePreviewLabel.TabIndex = 3;

            schemePreview.SetBounds(165, 26, 270, 240);
            schemePreview.TabIndex = 4;
            schemePreview.TabStop = false;

            helpButton.Location = new Point(360, 276);
            helpButton.Size = new Size(75, 23);
            helpButton.TabIndex = 7;
            helpButton.Text = SR.GetString(SR.CalAFmt_Help);
            helpButton.FlatStyle = FlatStyle.System;
            helpButton.Click += new EventHandler(this.OnClickHelp);

            okButton.Location = new Point(198, 276);
            okButton.Size = new Size(75, 23);
            okButton.TabIndex = 5;
            okButton.Text = SR.GetString(SR.CalAFmt_OK);
            okButton.DialogResult = DialogResult.OK;
            okButton.FlatStyle = FlatStyle.System;
            okButton.Click += new EventHandler(this.OnOKClicked);

            cancelButton.Location = new Point(279, 276);
            cancelButton.Size = new Size(75, 23);
            cancelButton.TabIndex = 6;
            cancelButton.Text = SR.GetString(SR.CalAFmt_Cancel);
            cancelButton.FlatStyle = FlatStyle.System;
            cancelButton.DialogResult = DialogResult.Cancel;
       
            this.Text = SR.GetString(SR.CalAFmt_Title);
            this.Size = new Size(450, 336);
            this.AcceptButton = okButton;
            this.FormBorderStyle = FormBorderStyle.FixedDialog;
            this.CancelButton = cancelButton;
            this.Icon = null;
            this.MaximizeBox = false;
            this.MinimizeBox = false;
            this.ShowInTaskbar = false;
            this.StartPosition = FormStartPosition.CenterParent;
            this.Activated += new EventHandler(this.OnActivated);
            this.HelpRequested += new HelpEventHandler(this.OnHelpRequested);

            // Use the correct VS Font
            Font f = Control.DefaultFont;
            ISite site = calendar.Site;
            IUIService uiService = (IUIService)site.GetService(typeof(IUIService));
            if (uiService != null) {
                f = (Font)uiService.Styles["DialogFont"];
            }            
            this.Font = f;

            // Actually add all the controls into the page
            Controls.Clear();
            Controls.AddRange(new Control[] {
                                            schemePreview,
                                            schemePreviewLabel,
                                            schemeNameList,
                                            schemeNameLabel,
                                            okButton,
                                            cancelButton,
                                            helpButton
                        });
        }
        

        /// <include file='doc\CalendarAutoFormatDialog.uex' path='docs/doc[@for="CalendarAutoFormatDialog.OnActivated"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Handles the activate event of the <see cref='System.Web.UI.WebControls.Calendar'/>
        ///       AutoFormat dialog.
        ///    </para>
        /// </devdoc>
        protected void OnActivated(object source, EventArgs e) {
            if (!firstActivate) {
                return;
            }            

            schemeDirty = false;

            // kick off the timer to continued with delayed initialization if this
            // if the first activation of the page
            DoDelayLoadActions();

            // select the first scheme
            schemeNameList.SelectedIndex = 0;

            firstActivate = false;        
        }

        private void ShowHelp() {
            ISite componentSite = calendar.Site;
            Debug.Assert(componentSite != null, "Expected the component to be sited.");
 
            IHelpService helpService = (IHelpService)componentSite.GetService(typeof(IHelpService));
            if (helpService != null) {
                helpService.ShowHelpFromKeyword("net.Asp.Calendar.AutoFormat");
            }
        }

        private void OnClickHelp(object sender, EventArgs e) {
            ShowHelp();
        }

        private void OnHelpRequested(object sender, HelpEventArgs e) {
            ShowHelp();
        }


        /// <include file='doc\CalendarAutoFormatDialog.uex' path='docs/doc[@for="CalendarAutoFormatDialog.OnSelChangedScheme"]/*' />
        /// <devdoc>
        ///    Handle changes in the pre-defined schema choices
        /// </devdoc>
        /// <internalonly/>
        protected void OnSelChangedScheme(object source, EventArgs e) {
            schemeDirty = true;
            UpdateSchemePreview();
        }

        /// <include file='doc\CalendarAutoFormatDialog.uex' path='docs/doc[@for="CalendarAutoFormatDialog.OnOKClicked"]/*' />
        /// <devdoc>
        ///    Handle changes in the pre-defined schema choices
        /// </devdoc>
        /// <internalonly/>
        protected void OnOKClicked(object source, EventArgs e) {
            SaveComponent();
        }

        /// <include file='doc\CalendarAutoFormatDialog.uex' path='docs/doc[@for="CalendarAutoFormatDialog.SaveComponent"]/*' />
        /// <devdoc>
        ///    Save any changes into the component
        /// </devdoc>
        /// <internalonly/>
        protected void SaveComponent() {

            if (schemeDirty) {
                WCScheme selectedScheme = (WCScheme) schemeNameList.SelectedItem;
                Debug.Assert(selectedScheme != null, "We should have a scheme here");
                selectedScheme.Apply(calendar);
                schemeDirty = false;
            }
    
        }


        /// <include file='doc\CalendarAutoFormatDialog.uex' path='docs/doc[@for="CalendarAutoFormatDialog.UpdateSchemePreview"]/*' />
        /// <devdoc>
        ///    Update scheme preview
        /// </devdoc>
        /// <internalonly/>
        private void UpdateSchemePreview() {
            
            // create a new calendar and apply the scheme to it        
            Calendar wc = GetPreviewCalendar();

            // CONSIDER: Its not safe to create a designer and associate it to
            //   a control that is not site'd...
            //   This should use the runtime control directly and call RenderControl instead.

            // get the design time HTML
            IDesigner designer = TypeDescriptor.CreateDesigner(wc, typeof(IDesigner));
            designer.Initialize(wc);
            CalendarDesigner wcd = (CalendarDesigner) designer;    
            string designHTML = wcd.GetDesignTimeHtml();

            // and show it!
            NativeMethods.IHTMLDocument2 tridentDocument = schemePreview.GetDocument();
            NativeMethods.IHTMLElement documentElement = tridentDocument.GetBody();
            documentElement.SetInnerHTML(designHTML);
        }

        /// <include file='doc\CalendarAutoFormatDialog.uex' path='docs/doc[@for="CalendarAutoFormatDialog.WCScheme"]/*' />
        /// <devdoc>
        ///    WCScheme: abstract base class for scheme
        ///    Each scheme is a class instance. To create a new scheme, derive a class from
        ///    WCScheme and implement GetDescription and Apply, and add one to the list in 
        ///    InitForm. 
        /// </devdoc>
        /// <internalonly/>
        private abstract class WCScheme {
            
            /// <include file='doc\CalendarAutoFormatDialog.uex' path='docs/doc[@for="CalendarAutoFormatDialog.WCScheme.GetDescription"]/*' />
            /// <devdoc>
            ///   This is the string that will appear in the list box
            /// </devdoc>
            /// <internalonly/>
            public abstract string GetDescription(); 

            /// <include file='doc\CalendarAutoFormatDialog.uex' path='docs/doc[@for="CalendarAutoFormatDialog.WCScheme.Apply"]/*' />
            /// <devdoc>
            ///   This routine should apply whatever changes constitute the sheme to the given calendar
            ///   
            ///   Do not change the following properties: SelectionMode, 
            ///                                           ShowTitle, 
            ///                                           ShowDayHeader, 
            ///                                           ShowNextPrevMonth
            /// </devdoc>
            /// <internalonly/>
            public abstract void Apply(Calendar wc);

            /// <include file='doc\CalendarAutoFormatDialog.uex' path='docs/doc[@for="CalendarAutoFormatDialog.WCScheme.ToString"]/*' />
            /// <devdoc>
            ///   Override ToString to allow use in a ListBox
            /// </devdoc>
            /// <internalonly/>
            public override string ToString() {
                return GetDescription();
            }

            /// <include file='doc\CalendarAutoFormatDialog.uex' path='docs/doc[@for="CalendarAutoFormatDialog.WCScheme.ClearCalendar"]/*' />
            /// <devdoc>
            ///   Helper routine to get the calendar to a consistent state
            ///   Should change only appearance properties
            /// </devdoc>
            /// <internalonly/>
            public static void ClearCalendar(Calendar wc) {

                // Clear out any existing styles
                wc.TitleStyle.Reset();
                wc.NextPrevStyle.Reset();
                wc.DayHeaderStyle.Reset();
                wc.SelectorStyle.Reset();
                wc.DayStyle.Reset();
                wc.OtherMonthDayStyle.Reset();
                wc.WeekendDayStyle.Reset();
                wc.TodayDayStyle.Reset();
                wc.SelectedDayStyle.Reset();
                wc.ControlStyle.Reset();
            }
        }

        /// <include file='doc\CalendarAutoFormatDialog.uex' path='docs/doc[@for="CalendarAutoFormatDialog.WCSchemeNone"]/*' />
        /// <devdoc>
        ///   Returns calendar to the default look
        /// </devdoc>
        /// <internalonly/>
        private class WCSchemeNone : WCScheme {

            public override string GetDescription() {
                return SR.GetString(SR.CalAFmt_Scheme_Default);
            }

            public override void Apply(Calendar wc) {
                ClearCalendar(wc);

                wc.DayNameFormat = DayNameFormat.Short;
                wc.NextPrevFormat = NextPrevFormat.CustomText;
                wc.TitleFormat = TitleFormat.MonthYear;

                wc.CellPadding = 2;
                wc.CellSpacing = 0;
                wc.ShowGridLines = false;
            }
        }

        private class WCSchemeStandard : WCScheme {

            public override string GetDescription() {
                return SR.GetString(SR.CalAFmt_Scheme_Simple);
            }

            public override void Apply(Calendar wc) {
                
                ClearCalendar(wc);

                wc.DayNameFormat = DayNameFormat.FirstLetter;
                wc.NextPrevFormat = NextPrevFormat.CustomText;
                wc.TitleFormat = TitleFormat.MonthYear;

                wc.CellPadding = 4;
                wc.CellSpacing = 0;
                wc.ShowGridLines = false;

                wc.Height = Unit.Pixel(180);
                wc.Width = Unit.Pixel(200);
                wc.BorderColor = Color.FromArgb(0x99, 0x99, 0x99);
                wc.ForeColor = Color.Black;
                wc.BackColor = Color.White;
                wc.Font.Name = "Verdana";
                wc.Font.Size = FontUnit.Point(8);

                wc.TitleStyle.Font.Bold = true;
                wc.TitleStyle.BorderColor = Color.Black;
                wc.TitleStyle.BackColor = Color.FromArgb(0x99, 0x99, 0x99);
                wc.NextPrevStyle.VerticalAlign = VerticalAlign.Bottom;
                wc.DayHeaderStyle.Font.Bold = true;
                wc.DayHeaderStyle.Font.Size = FontUnit.Point(7);
                wc.DayHeaderStyle.BackColor = Color.FromArgb(0xCC, 0xCC, 0xCC);
                wc.SelectorStyle.BackColor = Color.FromArgb(0xCC, 0xCC, 0xCC);

                wc.TodayDayStyle.BackColor = Color.FromArgb(0xCC, 0xCC, 0xCC);
                wc.TodayDayStyle.ForeColor = Color.Black;
                wc.SelectedDayStyle.BackColor = Color.FromArgb(0x66, 0x66, 0x66);
                wc.SelectedDayStyle.ForeColor = Color.White;
                wc.SelectedDayStyle.Font.Bold = true;
                wc.OtherMonthDayStyle.ForeColor = Color.FromArgb(0x80, 0x80, 0x80);
                wc.WeekendDayStyle.BackColor = Color.FromArgb(0xFF, 0xFF, 0xCC);
            }
        }

        private class WCSchemeProfessional1 : WCScheme {

            public override string GetDescription() {
                return SR.GetString(SR.CalAFmt_Scheme_Professional1);
            }

            public override void Apply(Calendar wc) {
                
                ClearCalendar(wc);

                wc.DayNameFormat = DayNameFormat.Short;
                wc.NextPrevFormat = NextPrevFormat.FullMonth;
                wc.TitleFormat = TitleFormat.MonthYear;

                wc.CellPadding = 2;
                wc.CellSpacing = 0;
                wc.ShowGridLines = false;

                wc.Height = Unit.Pixel(190);
                wc.Width = Unit.Pixel(350);
                wc.BorderColor = Color.White;
                wc.BorderWidth = Unit.Pixel(1);
                wc.ForeColor = Color.Black;
                wc.BackColor = Color.White;
                wc.Font.Name = "Verdana";
                wc.Font.Size = FontUnit.Point(9);

                wc.TitleStyle.Font.Bold = true;
                wc.TitleStyle.BorderColor = Color.Black;
                wc.TitleStyle.BorderWidth = Unit.Pixel(4);
                wc.TitleStyle.ForeColor = Color.FromArgb(0x33, 0x33, 0x99);
                wc.TitleStyle.BackColor = Color.White;
                wc.TitleStyle.Font.Size = FontUnit.Point(12);                
                wc.NextPrevStyle.Font.Bold = true;
                wc.NextPrevStyle.Font.Size = FontUnit.Point(8);
                wc.NextPrevStyle.VerticalAlign = VerticalAlign.Bottom;
                wc.NextPrevStyle.ForeColor = Color.FromArgb(0x33, 0x33, 0x33);
                wc.DayHeaderStyle.Font.Bold = true;
                wc.DayHeaderStyle.Font.Size = FontUnit.Point(8);

                wc.TodayDayStyle.BackColor = Color.FromArgb(0xCC, 0xCC, 0xCC);
                wc.SelectedDayStyle.BackColor = Color.FromArgb(0x33, 0x33, 0x99);
                wc.SelectedDayStyle.ForeColor = Color.White;
                wc.OtherMonthDayStyle.ForeColor = Color.FromArgb(0x99, 0x99, 0x99);
            }
        }

        private class WCSchemeProfessional2 : WCScheme {

            public override string GetDescription() {
                return SR.GetString(SR.CalAFmt_Scheme_Professional2);
            }

            public override void Apply(Calendar wc) {
                
                ClearCalendar(wc);

                wc.DayNameFormat = DayNameFormat.Short;
                wc.NextPrevFormat = NextPrevFormat.ShortMonth;
                wc.TitleFormat = TitleFormat.MonthYear;

                wc.CellPadding = 2;
                wc.CellSpacing = 1;
                wc.ShowGridLines = false;

                wc.Height = Unit.Pixel(250);
                wc.Width = Unit.Pixel(330);
                wc.BackColor = Color.White;
                wc.BorderColor = Color.Black;
                wc.BorderStyle = UI.WebControls.BorderStyle.Solid;
                wc.ForeColor = Color.Black;
                wc.Font.Name = "Verdana";
                wc.Font.Size = FontUnit.Point(9);

                wc.TitleStyle.Font.Bold = true;
                wc.TitleStyle.ForeColor = Color.White;
                wc.TitleStyle.BackColor = Color.FromArgb(0x33, 0x33, 0x99);
                wc.TitleStyle.Font.Size = FontUnit.Point(12);                
                wc.TitleStyle.Height = Unit.Point(12);
                wc.NextPrevStyle.Font.Bold = true;
                wc.NextPrevStyle.Font.Size = FontUnit.Point(8);
                wc.NextPrevStyle.ForeColor = Color.White;
                wc.DayHeaderStyle.ForeColor = Color.FromArgb(0x33, 0x33, 0x33);
                wc.DayHeaderStyle.Font.Bold = true;
                wc.DayHeaderStyle.Font.Size = FontUnit.Point(8);
                wc.DayHeaderStyle.Height = Unit.Point(8);

                wc.DayStyle.BackColor = Color.FromArgb(0xCC, 0xCC, 0xCC);
                wc.TodayDayStyle.BackColor = Color.FromArgb(0x99, 0x99, 0x99);
                wc.TodayDayStyle.ForeColor = Color.White;
                wc.SelectedDayStyle.BackColor = Color.FromArgb(0x33, 0x33, 0x99);
                wc.SelectedDayStyle.ForeColor = Color.White;
                wc.OtherMonthDayStyle.ForeColor = Color.FromArgb(0x99, 0x99, 0x99);
            }
        }

        private class WCSchemeClassic : WCScheme {

            public override string GetDescription() {
                return SR.GetString(SR.CalAFmt_Scheme_Classic);
            }

            public override void Apply(Calendar wc) {
                
                ClearCalendar(wc);

                wc.DayNameFormat = DayNameFormat.FirstLetter;
                wc.NextPrevFormat = NextPrevFormat.FullMonth;
                wc.TitleFormat = TitleFormat.Month;

                wc.CellPadding = 2;
                wc.CellSpacing = 0;
                wc.ShowGridLines = false;

                wc.Height = Unit.Pixel(220);
                wc.Width = Unit.Pixel(400);
                wc.BackColor = Color.White;
                wc.BorderColor = Color.Black;
                wc.ForeColor = Color.Black;
                wc.Font.Name = "Times New Roman";
                wc.Font.Size = FontUnit.Point(10);

                wc.TitleStyle.Font.Bold = true;
                wc.TitleStyle.ForeColor = Color.White;
                wc.TitleStyle.BackColor = Color.Black;
                wc.TitleStyle.Font.Size = FontUnit.Point(13);                
                wc.TitleStyle.Height = Unit.Point(14);
                wc.NextPrevStyle.ForeColor = Color.White;
                wc.NextPrevStyle.Font.Size = FontUnit.Point(8);
                wc.DayHeaderStyle.Font.Bold = true;
                wc.DayHeaderStyle.Font.Size = FontUnit.Point(7);
                wc.DayHeaderStyle.Font.Name = "Verdana";
                wc.DayHeaderStyle.BackColor = Color.FromArgb(0xCC, 0xCC, 0xCC);
                wc.DayHeaderStyle.ForeColor = Color.FromArgb(0x33, 0x33, 0x33);
                wc.DayHeaderStyle.Height = Unit.Pixel(10);
                wc.SelectorStyle.BackColor = Color.FromArgb(0xCC, 0xCC, 0xCC);
                wc.SelectorStyle.ForeColor = Color.FromArgb(0x33, 0x33, 0x33);
                wc.SelectorStyle.Font.Bold = true;
                wc.SelectorStyle.Font.Size = FontUnit.Point(8);
                wc.SelectorStyle.Font.Name = "Verdana";
                wc.SelectorStyle.Width = Unit.Percentage(1);

                wc.DayStyle.Width = Unit.Percentage(14);
                wc.TodayDayStyle.BackColor = Color.FromArgb(0xCC, 0xCC, 0x99);
                wc.SelectedDayStyle.BackColor = Color.FromArgb(0xCC, 0x33, 0x33);
                wc.SelectedDayStyle.ForeColor = Color.White;
                wc.OtherMonthDayStyle.ForeColor = Color.FromArgb(0x99, 0x99, 0x99);
            }
        }

        private class WCSchemeColorful1 : WCScheme {

            public override string GetDescription() {
                return SR.GetString(SR.CalAFmt_Scheme_Colorful1);
            }

            public override void Apply(Calendar wc) {
                
                ClearCalendar(wc);

                wc.DayNameFormat = DayNameFormat.FirstLetter;
                wc.NextPrevFormat = NextPrevFormat.CustomText;
                wc.TitleFormat = TitleFormat.MonthYear;

                wc.CellPadding = 2;
                wc.CellSpacing = 0;
                wc.ShowGridLines = true;

                wc.Height = Unit.Pixel(200);
                wc.Width = Unit.Pixel(220);
                wc.BackColor = Color.FromArgb(0xFF, 0xFF, 0xCC);
                wc.BorderColor = Color.FromArgb(0xFF, 0xCC, 0x66);
                wc.BorderWidth = Unit.Pixel(1);
                wc.ForeColor = Color.FromArgb(0x66, 0x33, 0x99);
                wc.Font.Name = "Verdana";
                wc.Font.Size = FontUnit.Point(8);

                wc.TitleStyle.Font.Bold = true;
                wc.TitleStyle.Font.Size = FontUnit.Point(9);
                wc.TitleStyle.BackColor = Color.FromArgb(0x99, 0x00, 0x00);
                wc.TitleStyle.ForeColor = Color.FromArgb(0xFF, 0xFF, 0xCC);
                wc.NextPrevStyle.ForeColor = Color.FromArgb(0xFF, 0xFF, 0xCC);
                wc.NextPrevStyle.Font.Size = FontUnit.Point(9);
                wc.DayHeaderStyle.BackColor = Color.FromArgb(0xFF, 0xCC, 0x66);
                wc.DayHeaderStyle.Height = Unit.Pixel(1);
                wc.SelectorStyle.BackColor = Color.FromArgb(0xFF, 0xCC, 0x66);

                wc.SelectedDayStyle.BackColor = Color.FromArgb(0xCC, 0xCC, 0xFF);
                wc.SelectedDayStyle.Font.Bold = true;
                wc.OtherMonthDayStyle.ForeColor = Color.FromArgb(0xCC, 0x99, 0x66);
                wc.TodayDayStyle.ForeColor = Color.White;
                wc.TodayDayStyle.BackColor = Color.FromArgb(0xFF, 0xCC, 0x66);
            }
        }

        private class WCSchemeColorful2 : WCScheme {

            public override string GetDescription() {
                return SR.GetString(SR.CalAFmt_Scheme_Colorful2);
            }

            public override void Apply(Calendar wc) {
                
                ClearCalendar(wc);

                wc.DayNameFormat = DayNameFormat.FirstLetter;
                wc.NextPrevFormat = NextPrevFormat.CustomText;
                wc.TitleFormat = TitleFormat.MonthYear;

                wc.CellPadding = 1;
                wc.CellSpacing = 0;
                wc.ShowGridLines = false;

                wc.Height = Unit.Pixel(200);
                wc.Width = Unit.Pixel(220);
                wc.BackColor = Color.White;
                wc.BorderColor = Color.FromArgb(0x33, 0x66, 0xCC);
                wc.BorderWidth = Unit.Pixel(1);
                wc.ForeColor = Color.FromArgb(0x00, 0x33, 0x99);
                wc.Font.Name = "Verdana";
                wc.Font.Size = FontUnit.Point(8);
                
                wc.TitleStyle.Font.Bold = true;
                wc.TitleStyle.Font.Size = FontUnit.Point(10);
                wc.TitleStyle.BackColor = Color.FromArgb(0x00, 0x33, 0x99);
                wc.TitleStyle.ForeColor = Color.FromArgb(0xCC, 0xCC, 0xFF);
                wc.TitleStyle.BorderColor = Color.FromArgb(0x33, 0x66, 0xCC);
                wc.TitleStyle.BorderStyle = UI.WebControls.BorderStyle.Solid;
                wc.TitleStyle.BorderWidth = Unit.Pixel(1);
                wc.TitleStyle.Height = Unit.Pixel(25);
                wc.NextPrevStyle.ForeColor = Color.FromArgb(0xCC, 0xCC, 0xFF);
                wc.NextPrevStyle.Font.Size = FontUnit.Point(8);
                wc.DayHeaderStyle.BackColor = Color.FromArgb(0x99, 0xCC, 0xCC);
                wc.DayHeaderStyle.ForeColor = Color.FromArgb(0x33, 0x66, 0x66);
                wc.DayHeaderStyle.Height = Unit.Pixel(1);
                wc.SelectorStyle.BackColor = Color.FromArgb(0x99, 0xCC, 0xCC);
                wc.SelectorStyle.ForeColor = Color.FromArgb(0x33, 0x66, 0x66);

                wc.SelectedDayStyle.BackColor = Color.FromArgb(0x00, 0x99, 0x99);
                wc.SelectedDayStyle.ForeColor = Color.FromArgb(0xCC, 0xFF, 0x99);
                wc.SelectedDayStyle.Font.Bold = true;
                wc.OtherMonthDayStyle.ForeColor = Color.FromArgb(0x99, 0x99, 0x99);
                wc.TodayDayStyle.ForeColor = Color.White;
                wc.TodayDayStyle.BackColor = Color.FromArgb(0x99, 0xCC, 0xCC);
                wc.WeekendDayStyle.BackColor = Color.FromArgb(0xCC, 0xCC, 0xFF);
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\webcontrols\calendardesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="CalendarDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.WebControls {

    using System;
    using System.Design;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Runtime.InteropServices;
    using System.Text;
    using System.Web.UI.WebControls;
    using System.Windows.Forms;
    
    /// <include file='doc\CalendarDesigner.uex' path='docs/doc[@for="CalendarDesigner"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides a designer for the <see cref='System.Web.UI.WebControls.Calendar'/>
    ///       control.
    ///    </para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public class CalendarDesigner : ControlDesigner {

        private Calendar calendar;

        private DesignerVerbCollection designerVerbs;
       
        /// <include file='doc\CalendarDesigner.uex' path='docs/doc[@for="CalendarDesigner.Verbs"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the set of verbs this designer offers.
        ///    </para>
        /// </devdoc>
        public override DesignerVerbCollection Verbs {
            get {
                if (designerVerbs == null) {
                    designerVerbs = new DesignerVerbCollection();
                    designerVerbs.Add(new DesignerVerb(SR.GetString(SR.CalAFmt_Verb), new EventHandler(this.OnAutoFormat)));
                }
                return designerVerbs;
            }
        }
                    
        /// <include file='doc\CalendarDesigner.uex' path='docs/doc[@for="CalendarDesigner.Initialize"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes the designer with the component for design.
        ///    </para>
        /// </devdoc>
        public override void Initialize(IComponent component) {
            Debug.Assert(component is Calendar, "CalendarDesigner::Initialize - Invalid Calendar");
            base.Initialize(component);

            calendar = (Calendar)component;
        }

        /// <include file='doc\CalendarDesigner.uex' path='docs/doc[@for="CalendarDesigner.OnAutoFormat"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Delegate to handle the the AutoFormat verb by calling the AutoFormat dialog.
        ///    </para>
        /// </devdoc>
        protected void OnAutoFormat (Object sender, EventArgs e) {
            IServiceProvider site = calendar.Site;
            IComponentChangeService changeService = null;

            DesignerTransaction transaction = null;
            DialogResult result = DialogResult.Cancel;

            try {
                if (site != null) {
                    IDesignerHost designerHost = (IDesignerHost)site.GetService(typeof(IDesignerHost));
                    Debug.Assert(designerHost != null);

                    transaction = designerHost.CreateTransaction(SR.GetString(SR.CalAFmt_Verb));
                    
                    changeService = (IComponentChangeService)site.GetService(typeof(IComponentChangeService));
                    if (changeService != null) {
                        try {
                            changeService.OnComponentChanging(calendar, null);
                        }
                        catch (CheckoutException ex) {
                            if (ex == CheckoutException.Canceled)
                                return;
                            throw ex;
                        }
                    }
                }
            
                try {
                    CalendarAutoFormatDialog af = new CalendarAutoFormatDialog(calendar);
                    result = af.ShowDialog(null);
                }
                finally {
                    if (result == DialogResult.OK && changeService != null) {
                        changeService.OnComponentChanged(calendar, null, null, null);
                    }
                }
            }
            finally {
                if (transaction != null) {
                    if (result == DialogResult.OK) {
                        transaction.Commit();
                    }
                    else {
                        transaction.Cancel();
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\webcontrols\datagriddesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataGridDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.WebControls {
    
    using System;
    using System.Design;
    using System.Collections;    
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Data;
    using System.Diagnostics;
    using System.Web.UI.Design;
    using System.Web.UI.WebControls;

    /// <include file='doc\DataGridDesigner.uex' path='docs/doc[@for="DataGridDesigner"]/*' />
    /// <devdoc>
    ///    <para>
    ///       This is the designer class for the <see cref='System.Web.UI.WebControls.DataGrid'/>
    ///       control.
    ///    </para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public class DataGridDesigner : BaseDataListDesigner {

        internal static TraceSwitch DataGridDesignerSwitch =
            new TraceSwitch("DATAGRIDDESIGNER", "Enable DataGrid designer general purpose traces.");

        private static string[] ColumnTemplateNames = new string[] { "HeaderTemplate", "ItemTemplate", "EditItemTemplate", "FooterTemplate" };
        private const int IDX_HEADER_TEMPLATE = 0;
        private const int IDX_ITEM_TEMPLATE = 1;
        private const int IDX_EDITITEM_TEMPLATE = 2;
        private const int IDX_FOOTER_TEMPLATE = 3;

        private DataGrid dataGrid;
        private TemplateEditingVerb[] templateVerbs;
        private bool templateVerbsDirty;

        /// <include file='doc\DataGridDesigner.uex' path='docs/doc[@for="DataGridDesigner.DataGridDesigner"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.Web.UI.Design.WebControls.DataGridDesigner'/>.
        ///    </para>
        /// </devdoc>
        public DataGridDesigner() {
            templateVerbsDirty = true;
        }

        /// <include file='doc\DataGridDesigner.uex' path='docs/doc[@for="DataGridDesigner.CreateTemplateEditingFrame"]/*' />
        protected override ITemplateEditingFrame CreateTemplateEditingFrame(TemplateEditingVerb verb) {
            ITemplateEditingService teService = (ITemplateEditingService)GetService(typeof(ITemplateEditingService));
            Debug.Assert(teService != null, "How did we get this far without an ITemplateEditingService");

            Style[] templateStyles = new Style[] { dataGrid.HeaderStyle, dataGrid.ItemStyle, dataGrid.AlternatingItemStyle, dataGrid.FooterStyle };

            ITemplateEditingFrame editingFrame =
                teService.CreateFrame(this, verb.Text, ColumnTemplateNames, dataGrid.ControlStyle, templateStyles);
            return editingFrame;
        }

        /// <include file='doc\DataGridDesigner.uex' path='docs/doc[@for="DataGridDesigner.Dispose"]/*' />
        protected override void Dispose(bool disposing) {
            if (disposing) {
                DisposeTemplateVerbs();
                dataGrid = null;
            }

            base.Dispose(disposing);
        }

        private void DisposeTemplateVerbs() {
            if (templateVerbs != null) {
                for (int i = 0; i < templateVerbs.Length; i++) {
                    templateVerbs[i].Dispose();
                }

                templateVerbs = null;
                templateVerbsDirty = true;
            }
        }

        /// <include file='doc\DataGridDesigner.uex' path='docs/doc[@for="DataGridDesigner.GetCachedTemplateEditingVerbs"]/*' />
        protected override TemplateEditingVerb[] GetCachedTemplateEditingVerbs() {
            if (templateVerbsDirty == true) {
                DisposeTemplateVerbs();

                DataGridColumnCollection columns = dataGrid.Columns;
                int columnCount = columns.Count;

                if (columnCount > 0) {
                    int templateColumns  = 0;
                    int i, t;

                    for (i = 0; i < columnCount; i++) {
                        if (columns[i] is TemplateColumn) {
                            templateColumns++;
                        }
                    }

                    if (templateColumns > 0) {
                        templateVerbs = new TemplateEditingVerb[templateColumns];

                        for (i = 0, t = 0; i < columnCount; i++) {
                            if (columns[i] is TemplateColumn) {
                                string headerText = columns[i].HeaderText;
                                string caption = "Columns[" + (i).ToString() + "]";

                                if ((headerText != null) && (headerText.Length != 0)) {
                                    caption = caption + " - " + headerText;
                                }
                                templateVerbs[t] = new TemplateEditingVerb(caption, i, this);
                                t++;
                            }
                        }
                    }
                }

                templateVerbsDirty = false;
            }

            return templateVerbs;
        }

        /// <include file='doc\DataGridDesigner.uex' path='docs/doc[@for="DataGridDesigner.GetDesignTimeHtml"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the HTML to be used for the design time representation
        ///       of the control.
        ///    </para>
        /// </devdoc>
        public override string GetDesignTimeHtml() {
            int sampleRows = 5;

            // ensure there are enough sample rows to show an entire page, and still
            // have 1 more for a navigation button to be enabled
            // we also want to ensure we don't have something ridiculously large
            if (dataGrid.AllowPaging && dataGrid.PageSize != 0) {
                sampleRows = Math.Min(dataGrid.PageSize + 1, 101);
            }

            bool dummyDataSource = false;
            IEnumerable designTimeDataSource = GetDesignTimeDataSource(sampleRows, out dummyDataSource);
            bool autoGenColumnsChanged = false;
            bool dataKeyFieldChanged = false;

            bool oldAutoGenColumns = dataGrid.AutoGenerateColumns;
            string oldDataKeyField = null;

            string designTimeHTML = null;

            if ((oldAutoGenColumns == false) && (dataGrid.Columns.Count == 0)) {
                // ensure that AutoGenerateColumns is true when we don't have
                // a columns collection, so we see atleast something at
                // design time.
                autoGenColumnsChanged = true;
                dataGrid.AutoGenerateColumns = true;
            }
            
            if (dummyDataSource) {
                oldDataKeyField = dataGrid.DataKeyField;
                if (oldDataKeyField.Length != 0) {
                    dataKeyFieldChanged = true;
                    dataGrid.DataKeyField = String.Empty;
                }
            }
            
            try {
                dataGrid.DataSource = designTimeDataSource;
                dataGrid.DataBind();
                designTimeHTML = base.GetDesignTimeHtml();
            }
            catch (Exception e) {
                designTimeHTML = GetErrorDesignTimeHtml(e);
            }
            finally {
                // restore settings we changed for rendering purposes
                dataGrid.DataSource = null;
                if (autoGenColumnsChanged) {
                    dataGrid.AutoGenerateColumns = false;
                }
                if (dataKeyFieldChanged == true) {
                    dataGrid.DataKeyField = oldDataKeyField;
                }
            }
            return designTimeHTML;
        }

        /// <include file='doc\DataGridDesigner.uex' path='docs/doc[@for="DataGridDesigner.GetEmptyDesignTimeHtml"]/*' />
        /// <devdoc>
        /// </devdoc>
        protected override string GetEmptyDesignTimeHtml() {
            return CreatePlaceHolderDesignTimeHtml(null);
        }

        /// <include file='doc\DataGridDesigner.uex' path='docs/doc[@for="DataGridDesigner.GetErrorDesignTimeHtml"]/*' />
        /// <devdoc>
        /// </devdoc>
        protected override string GetErrorDesignTimeHtml(Exception e) {
            Debug.Fail(e.ToString());
            return CreatePlaceHolderDesignTimeHtml(SR.GetString(SR.DataGrid_ErrorRendering));
        }

        /// <include file='doc\DataGridDesigner.uex' path='docs/doc[@for="DataGridDesigner.GetTemplateContainerDataItemProperty"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the template's container's data item property.
        ///    </para>
        /// </devdoc>
        public override string GetTemplateContainerDataItemProperty(string templateName) {
            return "DataItem";
        }
        
        /// <include file='doc\DataGridDesigner.uex' path='docs/doc[@for="DataGridDesigner.GetTemplateContent"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the template's content.
        ///    </para>
        /// </devdoc>
        public override string GetTemplateContent(ITemplateEditingFrame editingFrame, string templateName, out bool allowEditing) {
            allowEditing = true;

            int columnIndex = editingFrame.Verb.Index;

            Debug.Assert((columnIndex >= 0) && (columnIndex < dataGrid.Columns.Count),
                         "Invalid column index in template editing frame.");
            Debug.Assert(dataGrid.Columns[columnIndex] is TemplateColumn,
                         "Template editing frame points to a non-TemplateColumn column.");
            
            TemplateColumn column = (TemplateColumn)dataGrid.Columns[columnIndex];
            ITemplate template = null;
            string templateContent = String.Empty;

            if (templateName.Equals(ColumnTemplateNames[IDX_HEADER_TEMPLATE])) {
                template = column.HeaderTemplate;
            }
            else if (templateName.Equals(ColumnTemplateNames[IDX_ITEM_TEMPLATE])) {
                template = column.ItemTemplate;
            }
            else if (templateName.Equals(ColumnTemplateNames[IDX_EDITITEM_TEMPLATE])) {
                template = column.EditItemTemplate;
            }
            else if (templateName.Equals(ColumnTemplateNames[IDX_FOOTER_TEMPLATE])) {
                template = column.FooterTemplate;
            }
            else {
                Debug.Fail("Unknown template name passed to GetTemplateContent");
            }

            if (template != null) {
                templateContent = GetTextFromTemplate(template);
            }

            return templateContent;
        }

        /// <include file='doc\DataGridDesigner.uex' path='docs/doc[@for="DataGridDesigner.GetTemplatePropertyParentType"]/*' />
        public override Type GetTemplatePropertyParentType(string templateName) {
            return typeof(TemplateColumn);
        }

        /// <include file='doc\DataGridDesigner.uex' path='docs/doc[@for="DataGridDesigner.OnColumnsChanged"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Notification that is called when the columns changed event occurs.
        ///    </para>
        /// </devdoc>
        public virtual void OnColumnsChanged() {
            OnTemplateEditingVerbsChanged();
        }

        /// <include file='doc\DataGridDesigner.uex' path='docs/doc[@for="DataGridDesigner.OnTemplateEditingVerbsChanged"]/*' />
        protected override void OnTemplateEditingVerbsChanged() {
            templateVerbsDirty = true;
        }

        /// <include file='doc\DataGridDesigner.uex' path='docs/doc[@for="DataGridDesigner.Initialize"]/*' />
        /// <devdoc>
        ///   Initializes the designer with the DataGrid control that this instance
        ///   of the designer is associated with.
        /// </devdoc>
        public override void Initialize(IComponent component) {
            Debug.Assert(component is DataGrid,
                         "DataGridDesigner::Initialize - Invalid DataGrid Control");

            dataGrid = (DataGrid)component;
            base.Initialize(component);
        }

        /// <include file='doc\DataGridDesigner.uex' path='docs/doc[@for="DataGridDesigner.SetTemplateContent"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Sets the content for the specified template and frame.
        ///    </para>
        /// </devdoc>
        public override void SetTemplateContent(ITemplateEditingFrame editingFrame, string templateName, string templateContent) {
            int columnIndex = editingFrame.Verb.Index;

            Debug.Assert((columnIndex >= 0) && (columnIndex < dataGrid.Columns.Count),
                         "Invalid column index in template editing frame.");
            Debug.Assert(dataGrid.Columns[columnIndex] is TemplateColumn,
                         "Template editing frame points to a non-TemplateColumn column.");
            
            TemplateColumn column = (TemplateColumn)dataGrid.Columns[columnIndex];
            ITemplate newTemplate = null;

            if ((templateContent != null) && (templateContent.Length != 0)) {
                ITemplate currentTemplate = null;

                // first get the current template so we can use it if we fail to parse the
                // new text into a template

                if (templateName.Equals(ColumnTemplateNames[IDX_HEADER_TEMPLATE])) {
                    currentTemplate = column.HeaderTemplate;
                }
                else if (templateName.Equals(ColumnTemplateNames[IDX_ITEM_TEMPLATE])) {
                    currentTemplate = column.ItemTemplate;
                }
                else if (templateName.Equals(ColumnTemplateNames[IDX_EDITITEM_TEMPLATE])) {
                    currentTemplate = column.EditItemTemplate;
                }
                else if (templateName.Equals(ColumnTemplateNames[IDX_FOOTER_TEMPLATE])) {
                    currentTemplate = column.FooterTemplate;
                }
                
                // this will parse out a new template, and if it fails, it will
                // return currentTemplate itself
                newTemplate = GetTemplateFromText(templateContent, currentTemplate);
            }

            // Set the new template into the control. Note this may be null, if the
            // template content was empty, i.e., the user cleared out everything in the UI.

            if (templateName.Equals(ColumnTemplateNames[IDX_HEADER_TEMPLATE])) {
                column.HeaderTemplate = newTemplate;
            }
            else if (templateName.Equals(ColumnTemplateNames[IDX_ITEM_TEMPLATE])) {
                column.ItemTemplate = newTemplate;
            }
            else if (templateName.Equals(ColumnTemplateNames[IDX_EDITITEM_TEMPLATE])) {
                column.EditItemTemplate = newTemplate;
            }
            else if (templateName.Equals(ColumnTemplateNames[IDX_FOOTER_TEMPLATE])) {
                column.FooterTemplate = newTemplate;
            }
            else {
                Debug.Fail("Unknown template name passed to SetTemplateContent");
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\webcontrols\datalistcomponenteditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataListComponentEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.WebControls {

    using System;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Web.UI.Design.WebControls.ListControls;
    using System.Windows.Forms.Design;

    /// <include file='doc\DataListComponentEditor.uex' path='docs/doc[@for="DataListComponentEditor"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides a component editor for a Web Forms <see cref='System.Web.UI.WebControls.DataList'/>
    ///       control.
    ///    </para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public class DataListComponentEditor : BaseDataListComponentEditor {

        // The set of pages used within the DataList ComponentEditor
        private static Type[] editorPages = new Type[] {
                                                typeof(DataListGeneralPage),
                                                typeof(FormatPage),
                                                typeof(BordersPage)
                                            };
        internal static int IDX_GENERAL = 0;
        internal static int IDX_FORMAT = 1;
        internal static int IDX_BORDERS = 2;
        
           
        /// <include file='doc\DataListComponentEditor.uex' path='docs/doc[@for="DataListComponentEditor.DataListComponentEditor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.Web.UI.Design.WebControls.DataListComponentEditor'/>.
        ///    </para>
        /// </devdoc>
        public DataListComponentEditor() : base(IDX_GENERAL) {
        }
        
        /// <include file='doc\DataListComponentEditor.uex' path='docs/doc[@for="DataListComponentEditor.DataListComponentEditor1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.Web.UI.Design.WebControls.DataListComponentEditor'/>.
        ///    </para>
        /// </devdoc>
        public DataListComponentEditor(int initialPage) : base(initialPage) {
        }

        /// <include file='doc\DataListComponentEditor.uex' path='docs/doc[@for="DataListComponentEditor.GetComponentEditorPages"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the set of component editor pages owned by the designer.
        ///    </para>
        /// </devdoc>
        protected override Type[] GetComponentEditorPages() {
            return editorPages;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\webcontrols\datagridcomponenteditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataGridComponentEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.WebControls {

    using System;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Web.UI.Design.WebControls.ListControls;
    using System.Windows.Forms.Design;

    /// <include file='doc\DataGridComponentEditor.uex' path='docs/doc[@for="DataGridComponentEditor"]/*' />
    /// <devdoc>
    ///    <para>
    ///       The component editor for a Web Forms <see cref='System.Web.UI.WebControls.DataGrid'/>
    ///       control.
    ///    </para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public class DataGridComponentEditor : BaseDataListComponentEditor {

        // The set of pages used within the DataGrid ComponentEditor
        private static Type[] editorPages = new Type[] {
                                                typeof(DataGridGeneralPage),
                                                typeof(DataGridColumnsPage),
                                                typeof(DataGridPagingPage),
                                                typeof(FormatPage),
                                                typeof(BordersPage)
                                            };
        internal static int IDX_GENERAL = 0;
        internal static int IDX_COLUMNS = 1;
        internal static int IDX_PAGING = 2;
        internal static int IDX_FORMAT = 3;
        internal static int IDX_BORDERS = 4;
        
        /// <include file='doc\DataGridComponentEditor.uex' path='docs/doc[@for="DataGridComponentEditor.DataGridComponentEditor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.Web.UI.Design.WebControls.DataGridComponentEditor'/>.
        ///    </para>
        /// </devdoc>
        public DataGridComponentEditor() : base(IDX_GENERAL) {
        }

        /// <include file='doc\DataGridComponentEditor.uex' path='docs/doc[@for="DataGridComponentEditor.DataGridComponentEditor1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.Web.UI.Design.WebControls.DataGridComponentEditor'/>.
        ///    </para>
        /// </devdoc>
        public DataGridComponentEditor(int initialPage) : base(initialPage) {
        }

        /// <include file='doc\DataGridComponentEditor.uex' path='docs/doc[@for="DataGridComponentEditor.GetComponentEditorPages"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the set of all pages in the <see cref='System.Web.UI.WebControls.DataGrid'/>
        ///       .
        ///    </para>
        /// </devdoc>
        protected override Type[] GetComponentEditorPages() {
            return editorPages;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\webcontrols\columncollectioneditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="ColumnCollectionEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.WebControls {
    using System.Runtime.Serialization.Formatters;

    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Drawing.Design;
    using System.Web.UI.WebControls;

    /// <include file='doc\ColumnCollectionEditor.uex' path='docs/doc[@for="DataGridColumnCollectionEditor"]/*' />
    /// <devdoc>
    ///    <para>
    ///       The editor for column collections.
    ///    </para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public class DataGridColumnCollectionEditor : UITypeEditor {

        /// <include file='doc\ColumnCollectionEditor.uex' path='docs/doc[@for="DataGridColumnCollectionEditor.EditValue"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Edits the value specified.
        ///    </para>
        /// </devdoc>
        public override object EditValue(ITypeDescriptorContext context,  IServiceProvider  provider, object value) {
            IDesignerHost designerHost = (IDesignerHost)context.GetService(typeof(IDesignerHost));
            Debug.Assert(designerHost != null, "Did not get DesignerHost service.");

            Debug.Assert(context.Instance is DataGrid, "Expected datagrid");
            DataGrid dataGrid = (DataGrid)context.Instance;

            BaseDataListDesigner designer = (BaseDataListDesigner)designerHost.GetDesigner(dataGrid);
            Debug.Assert(designer != null, "Did not get designer for component");

            designer.InvokePropertyBuilder(DataGridComponentEditor.IDX_COLUMNS);
            return value;
        }

        /// <include file='doc\ColumnCollectionEditor.uex' path='docs/doc[@for="DataGridColumnCollectionEditor.GetEditStyle"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the edit style.
        ///    </para>
        /// </devdoc>
        public override UITypeEditorEditStyle GetEditStyle(ITypeDescriptorContext context) {
            return UITypeEditorEditStyle.Modal;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\webcontrols\hyperlinkdatabindinghandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="HyperLinkDataBindingHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design {

    using System;
    using System.Design;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Web.UI;
    using System.Web.UI.WebControls;

    /// <include file='doc\HyperLinkDataBindingHandler.uex' path='docs/doc[@for="HyperLinkDataBindingHandler"]/*' />
    /// <devdoc>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public class HyperLinkDataBindingHandler : DataBindingHandler {

        /// <include file='doc\HyperLinkDataBindingHandler.uex' path='docs/doc[@for="HyperLinkDataBindingHandler.DataBindControl"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void DataBindControl(IDesignerHost designerHost, Control control) {
            DataBindingCollection bindings = ((IDataBindingsAccessor)control).DataBindings;
            DataBinding textBinding = bindings["Text"];
            DataBinding urlBinding = bindings["NavigateUrl"];

            if ((textBinding != null) || (urlBinding != null)) {
                HyperLink hyperLink = (HyperLink)control;

                if (textBinding != null) {
                    hyperLink.Text = SR.GetString(SR.Sample_Databound_Text);
                }
                if (urlBinding != null) {
                    // any value will do, we just need an href to be rendered
                    hyperLink.NavigateUrl = "url";
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\webcontrols\datalistdesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataListDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.WebControls {
    
    using System.Design;
    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Data;
    using System.Diagnostics;
    using System.Drawing;
    using System.IO;
    using System.Text;
    using System.Web.UI.Design;
    using System.Web.UI.WebControls;

    /// <include file='doc\DataListDesigner.uex' path='docs/doc[@for="DataListDesigner"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides a designer for the <see cref='System.Web.UI.WebControls.DataList'/>
    ///       control.
    ///    </para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public class DataListDesigner : BaseDataListDesigner {

        internal static TraceSwitch DataListDesignerSwitch =
            new TraceSwitch("DATALISTDESIGNER", "Enable DataList designer general purpose traces.");

        private const int HeaderFooterTemplates = 0;
        private const int ItemTemplates = 1;
        private const int SeparatorTemplate = 2;

        private static string[] HeaderFooterTemplateNames = new string[] { "HeaderTemplate", "FooterTemplate" };
        private const int IDX_HEADER_TEMPLATE = 0;
        private const int IDX_FOOTER_TEMPLATE = 1;

        private static string[] ItemTemplateNames = new String[] { "ItemTemplate", "AlternatingItemTemplate", "SelectedItemTemplate", "EditItemTemplate" };
        private const int IDX_ITEM_TEMPLATE = 0;
        private const int IDX_ALTITEM_TEMPLATE = 1;
        private const int IDX_SELITEM_TEMPLATE = 2;
        private const int IDX_EDITITEM_TEMPLATE = 3;

        private static string[] SeparatorTemplateNames = new String[] { "SeparatorTemplate" };
        private const int IDX_SEPARATOR_TEMPLATE = 0;

        private DataList dataList;
        private TemplateEditingVerb[] templateVerbs;
        private bool templateVerbsDirty;

        /// <include file='doc\DataListDesigner.uex' path='docs/doc[@for="DataListDesigner.DataListDesigner"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.Web.UI.Design.WebControls.DataListDesigner'/>.
        ///    </para>
        /// </devdoc>
        public DataListDesigner() {
            templateVerbsDirty = true;
        }

        /// <include file='doc\DataListDesigner.uex' path='docs/doc[@for="DataListDesigner.AllowResize"]/*' />
        public override bool AllowResize {
            get {
                // When templates are not defined, we render a read-only fixed
                // size block. Once templates are defined or are being edited the control should allow
                // resizing.
                return TemplatesExist || InTemplateMode;
            }
        }

        /// <include file='doc\DataListDesigner.uex' path='docs/doc[@for="DataListDesigner.TemplatesExist"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value
        ///       indicating whether templates associated to the designer currently exist.
        ///    </para>
        /// </devdoc>
        protected bool TemplatesExist {
            get {
                return (dataList.ItemTemplate != null);
            }
        }

        /// <include file='doc\DataListDesigner.uex' path='docs/doc[@for="DataListDesigner.CreateTemplateEditingFrame"]/*' />
        protected override ITemplateEditingFrame CreateTemplateEditingFrame(TemplateEditingVerb verb) {
            ITemplateEditingService teService = (ITemplateEditingService)GetService(typeof(ITemplateEditingService));
            Debug.Assert(teService != null, "How did we get this far without an ITemplateEditingService");

            string[] templateNames = null;
            Style[] templateStyles = null;

            switch (verb.Index) {
                case HeaderFooterTemplates:
                    templateNames = HeaderFooterTemplateNames;
                    templateStyles = new Style[] { dataList.HeaderStyle, dataList.FooterStyle };
                    break;
                case ItemTemplates:
                    templateNames = ItemTemplateNames;
                    templateStyles = new Style[] { dataList.ItemStyle, dataList.AlternatingItemStyle, dataList.SelectedItemStyle, dataList.EditItemStyle };
                    break;
                case SeparatorTemplate:
                    templateNames = SeparatorTemplateNames;
                    templateStyles = new Style[] { dataList.SeparatorStyle };
                    break;
                default:
                    Debug.Fail("Unknown Index value on TemplateEditingVerb");
                    break;
            }

            ITemplateEditingFrame editingFrame =
                teService.CreateFrame(this, verb.Text, templateNames, dataList.ControlStyle, templateStyles);
            return editingFrame;
        }

        /// <include file='doc\DataListDesigner.uex' path='docs/doc[@for="DataListDesigner.Dispose"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Disposes of the resources (other than memory) used by the
        ///    <see cref='System.Web.UI.Design.WebControls.DataListDesigner'/>.
        ///    </para>
        /// </devdoc>
        protected override void Dispose(bool disposing) {
            if (disposing) {
                DisposeTemplateVerbs();
                dataList = null;
            }

            base.Dispose(disposing);
        }

        private void DisposeTemplateVerbs() {
            if (templateVerbs != null) {
                for (int i = 0; i < templateVerbs.Length; i++) {
                    templateVerbs[i].Dispose();
                }

                templateVerbs = null;
                templateVerbsDirty = true;
            }
        }

        /// <include file='doc\DataListDesigner.uex' path='docs/doc[@for="DataListDesigner.GetCachedTemplateEditingVerbs"]/*' />
        protected override TemplateEditingVerb[] GetCachedTemplateEditingVerbs() {
            if (templateVerbsDirty == true) {
                DisposeTemplateVerbs();

                templateVerbs = new TemplateEditingVerb[3];
                templateVerbs[0] = new TemplateEditingVerb(SR.GetString(SR.DataList_HeaderFooterTemplates), HeaderFooterTemplates, this);
                templateVerbs[1] = new TemplateEditingVerb(SR.GetString(SR.DataList_ItemTemplates), ItemTemplates, this);
                templateVerbs[2] = new TemplateEditingVerb(SR.GetString(SR.DataList_SeparatorTemplate), SeparatorTemplate, this);

                templateVerbsDirty = false;
            }

            return templateVerbs;
        }

        /// <include file='doc\DataListDesigner.uex' path='docs/doc[@for="DataListDesigner.GetDesignTimeHtml"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the HTML to be used for the design-time representation
        ///       of the control.
        ///    </para>
        /// </devdoc>
        public override string GetDesignTimeHtml() {
            IEnumerable selectedDataSource = null;
            bool hasATemplate = this.TemplatesExist;
            string designTimeHTML = null;

            if (hasATemplate)
                selectedDataSource = GetResolvedSelectedDataSource();

            if (hasATemplate) {
                bool dummyDataSource;
                IEnumerable designTimeDataSource = GetDesignTimeDataSource(selectedDataSource, 5, out dummyDataSource);

                bool dataKeyFieldChanged = false;
                string oldDataKeyField = null;

                try {
                    dataList.DataSource = designTimeDataSource;
                    if (dummyDataSource) {
                        oldDataKeyField = dataList.DataKeyField;
                        if (oldDataKeyField.Length != 0) {
                            dataKeyFieldChanged = true;
                            dataList.DataKeyField = String.Empty;
                        }
                    }

                    dataList.DataBind();

                    designTimeHTML = base.GetDesignTimeHtml();
                }
                catch (Exception e) {
                    designTimeHTML = GetErrorDesignTimeHtml(e);
                }
                finally {
                    dataList.DataSource = null;
                    if (dataKeyFieldChanged) {
                        dataList.DataKeyField = oldDataKeyField;
                    }
                }
            }
            else {
                designTimeHTML = GetEmptyDesignTimeHtml();
            }

            return designTimeHTML;
        }

        /// <include file='doc\DataListDesigner.uex' path='docs/doc[@for="DataListDesigner.GetEmptyDesignTimeHtml"]/*' />
        /// <devdoc>
        /// </devdoc>
        protected override string GetEmptyDesignTimeHtml() {
            string text;

            if (CanEnterTemplateMode) {
                text = SR.GetString(SR.DataList_NoTemplatesInst);
            }
            else {
                text = SR.GetString(SR.DataList_NoTemplatesInst2);
            }
            return CreatePlaceHolderDesignTimeHtml(text);
        }

        /// <include file='doc\DataListDesigner.uex' path='docs/doc[@for="DataListDesigner.GetErrorDesignTimeHtml"]/*' />
        /// <devdoc>
        /// </devdoc>
        protected override string GetErrorDesignTimeHtml(Exception e) {
            Debug.Fail(e.ToString());
            return CreatePlaceHolderDesignTimeHtml(SR.GetString(SR.DataList_ErrorRendering));
        }

        /// <include file='doc\DataListDesigner.uex' path='docs/doc[@for="DataListDesigner.GetTemplateContainerDataItemProperty"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the template's container's data item property.
        ///    </para>
        /// </devdoc>
        public override string GetTemplateContainerDataItemProperty(string templateName) {
            return "DataItem";
        }
        
        /// <include file='doc\DataListDesigner.uex' path='docs/doc[@for="DataListDesigner.GetTemplateContent"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the template's content.
        ///    </para>
        /// </devdoc>
        public override string GetTemplateContent(ITemplateEditingFrame editingFrame, string templateName, out bool allowEditing) {
            allowEditing = true;

            ITemplate template = null;
            string templateContent = String.Empty;

            switch (editingFrame.Verb.Index) {
                case HeaderFooterTemplates:
                    if (templateName.Equals(HeaderFooterTemplateNames[IDX_HEADER_TEMPLATE])) {
                        template = dataList.HeaderTemplate;
                    }
                    else if (templateName.Equals(HeaderFooterTemplateNames[IDX_FOOTER_TEMPLATE])) {
                        template = dataList.FooterTemplate;
                    }
                    else {
                        Debug.Fail("Unknown template name passed to GetTemplateContent");
                    }
                    break;
                case ItemTemplates:
                    if (templateName.Equals(ItemTemplateNames[IDX_ITEM_TEMPLATE])) {
                        template = dataList.ItemTemplate;
                    }
                    else if (templateName.Equals(ItemTemplateNames[IDX_ALTITEM_TEMPLATE])) {
                        template = dataList.AlternatingItemTemplate;
                    }
                    else if (templateName.Equals(ItemTemplateNames[IDX_SELITEM_TEMPLATE])) {
                        template = dataList.SelectedItemTemplate;
                    }
                    else if (templateName.Equals(ItemTemplateNames[IDX_EDITITEM_TEMPLATE])) {
                        template = dataList.EditItemTemplate;
                    }
                    else {
                        Debug.Fail("Unknown template name passed to GetTemplateContent");
                    }
                    break;
                case SeparatorTemplate:
                    Debug.Assert(templateName.Equals(SeparatorTemplateNames[IDX_SEPARATOR_TEMPLATE]),
                                 "Unknown template name passed to GetTemplateContent");
                    template = dataList.SeparatorTemplate;
                    break;
                default:
                    Debug.Fail("Unknown Index value on ITemplateEditingFrame");
                    break;
            }

            if (template != null) {
                templateContent = GetTextFromTemplate(template);
            }

            return templateContent;
        }

        /// <include file='doc\DataListDesigner.uex' path='docs/doc[@for="DataListDesigner.Initialize"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes the designer with the <see cref='System.Web.UI.WebControls.DataList'/> control that this instance
        ///       of the designer is associated with.
        ///    </para>
        /// </devdoc>
        public override void Initialize(IComponent component) {
            Debug.Assert(component is DataList,
                         "DataListDesigner::Initialize - Invalid DataList Control");

            dataList = (DataList)component;
            base.Initialize(component);
        }

        /// <include file='doc\DataListDesigner.uex' path='docs/doc[@for="DataListDesigner.OnTemplateEditingVerbsChanged"]/*' />
        protected override void OnTemplateEditingVerbsChanged() {
            templateVerbsDirty = true;
        }

        /// <include file='doc\DataListDesigner.uex' path='docs/doc[@for="DataListDesigner.SetTemplateContent"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Sets the template's content.
        ///    </para>
        /// </devdoc>
        public override void SetTemplateContent(ITemplateEditingFrame editingFrame, string templateName, string templateContent) {
            ITemplate newTemplate = null;

            if ((templateContent != null) && (templateContent.Length != 0)) {
                ITemplate currentTemplate = null;

                // first get the current template so we can use it if we fail to parse the
                // new text into a template

                switch (editingFrame.Verb.Index) {
                    case HeaderFooterTemplates:
                        if (templateName.Equals(HeaderFooterTemplateNames[IDX_HEADER_TEMPLATE])) {
                            currentTemplate = dataList.HeaderTemplate;
                        }
                        else if (templateName.Equals(HeaderFooterTemplateNames[IDX_FOOTER_TEMPLATE])) {
                            currentTemplate = dataList.FooterTemplate;
                        }
                        break;
                    case ItemTemplates:
                        if (templateName.Equals(ItemTemplateNames[IDX_ITEM_TEMPLATE])) {
                            currentTemplate = dataList.ItemTemplate;
                        }
                        else if (templateName.Equals(ItemTemplateNames[IDX_ALTITEM_TEMPLATE])) {
                            currentTemplate = dataList.AlternatingItemTemplate;
                        }
                        else if (templateName.Equals(ItemTemplateNames[IDX_SELITEM_TEMPLATE])) {
                            currentTemplate = dataList.SelectedItemTemplate;
                        }
                        else if (templateName.Equals(ItemTemplateNames[IDX_EDITITEM_TEMPLATE])) {
                            currentTemplate = dataList.EditItemTemplate;
                        }
                        break;
                    case SeparatorTemplate:
                        currentTemplate = dataList.SeparatorTemplate;
                        break;
                }

                // this will parse out a new template, and if it fails, it will
                // return currentTemplate itself
                newTemplate = GetTemplateFromText(templateContent, currentTemplate);
            }

            // Set the new template into the control. Note this may be null, if the
            // template content was empty, i.e., the user cleared out everything in the UI.

            switch (editingFrame.Verb.Index) {
                case HeaderFooterTemplates:
                    if (templateName.Equals(HeaderFooterTemplateNames[IDX_HEADER_TEMPLATE])) {
                        dataList.HeaderTemplate = newTemplate;
                    }
                    else if (templateName.Equals(HeaderFooterTemplateNames[IDX_FOOTER_TEMPLATE])) {
                        dataList.FooterTemplate = newTemplate;
                    }
                    else {
                        Debug.Fail("Unknown template name passed to SetTemplateContent");
                    }
                    break;
                case ItemTemplates:
                    if (templateName.Equals(ItemTemplateNames[IDX_ITEM_TEMPLATE])) {
                        dataList.ItemTemplate = newTemplate;
                    }
                    else if (templateName.Equals(ItemTemplateNames[IDX_ALTITEM_TEMPLATE])) {
                        dataList.AlternatingItemTemplate = newTemplate;
                    }
                    else if (templateName.Equals(ItemTemplateNames[IDX_SELITEM_TEMPLATE])) {
                        dataList.SelectedItemTemplate = newTemplate;
                    }
                    else if (templateName.Equals(ItemTemplateNames[IDX_EDITITEM_TEMPLATE])) {
                        dataList.EditItemTemplate = newTemplate;
                    }
                    else {
                        Debug.Fail("Unknown template name passed to SetTemplateContent");
                    }
                    break;
                case SeparatorTemplate:
                    Debug.Assert(templateName.Equals(SeparatorTemplateNames[IDX_SEPARATOR_TEMPLATE]),
                                 "Unknown template name passed to SetTemplateContent");
                    dataList.SeparatorTemplate = newTemplate;
                    break;
                default:
                    Debug.Fail("Unknown Index value on ITemplateEditingFrame");
                    break;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\webcontrols\labeldesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="LabelDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.WebControls {

    using System;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.IO;
    using System.Text;
    using System.Web.UI.Design;
    using System.Web.UI.WebControls;

    /// <include file='doc\LabelDesigner.uex' path='docs/doc[@for="LabelDesigner"]/*' />
    /// <devdoc>
    ///    <para>
    ///       The designer for the <see cref='System.Web.UI.WebControls.Label'/>
    ///       web control.
    ///    </para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public class LabelDesigner : TextControlDesigner {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\webcontrols\listitemscollectioneditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="ListItemsCollectionEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.WebControls {

    using System;
    using System.ComponentModel;
    using System.ComponentModel.Design;

    /// <include file='doc\ListItemsCollectionEditor.uex' path='docs/doc[@for="ListItemsCollectionEditor"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public class ListItemsCollectionEditor : CollectionEditor {

        /// <include file='doc\ListItemsCollectionEditor.uex' path='docs/doc[@for="ListItemsCollectionEditor.ListItemsCollectionEditor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ListItemsCollectionEditor(Type type) : base(type) {
        }

        /// <include file='doc\ListItemsCollectionEditor.uex' path='docs/doc[@for="ListItemsCollectionEditor.CanSelectMultipleInstances"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override bool CanSelectMultipleInstances() {
            return false;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\webcontrols\hyperlinkdesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="HyperLinkDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.WebControls {
    using System.ComponentModel;

    using System.Diagnostics;

    using System;
    using System.Web.UI.WebControls;
    using Microsoft.Win32;

    /// <include file='doc\HyperLinkDesigner.uex' path='docs/doc[@for="HyperLinkDesigner"]/*' />
    /// <devdoc>
    ///    <para>
    ///       The designer for the <see cref='System.Web.UI.WebControls.HyperLink'/>
    ///       web control.
    ///    </para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public class HyperLinkDesigner : TextControlDesigner {

        /// <include file='doc\HyperLinkDesigner.uex' path='docs/doc[@for="HyperLinkDesigner.GetDesignTimeHtml"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the design time HTML of the <see cref='System.Web.UI.WebControls.HyperLink'/>
        ///       control.
        ///    </para>
        /// </devdoc>
        public override string GetDesignTimeHtml() {
            HyperLink h = (HyperLink)Component;
            string originalText  = h.Text;
            string imageUrl = h.ImageUrl;
            string originalUrl = h.NavigateUrl;

            Debug.Assert(originalText != null);
            Debug.Assert(imageUrl != null);
            Debug.Assert(originalUrl != null);

            bool blankText = (originalText.Trim().Length == 0) && (imageUrl.Trim().Length == 0);
            bool blankUrl = (originalUrl.Trim().Length == 0);

            bool hasControls = h.HasControls();
            Control[] children = null;

            if (blankText) {
                if (hasControls) {
                    children = new Control[h.Controls.Count];
                    h.Controls.CopyTo(children, 0);
                }
                h.Text = "[" + h.ID + "]";
            }
            if (blankUrl) {
                h.NavigateUrl = "url";
            }

            string html;
            
            try {
                html = base.GetDesignTimeHtml();
            }
            finally {
                if (blankText) {
                    h.Text = originalText;
                    if (hasControls) {
                        foreach (Control c in children) {
                            h.Controls.Add(c);
                        }
                    }
                }
                if (blankUrl) {
                    h.NavigateUrl = originalUrl;
                }
            }
            return html;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\webcontrols\linkbuttondesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="LinkButtonDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.WebControls {

    using System;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Web.UI.Design;
    using System.Web.UI.WebControls;

    /// <include file='doc\LinkButtonDesigner.uex' path='docs/doc[@for="LinkButtonDesigner"]/*' />
    /// <devdoc>
    ///    <para>
    ///       The designer for the <see cref='System.Web.UI.WebControls.LinkButton'/>
    ///       web control.
    ///    </para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public class LinkButtonDesigner : TextControlDesigner {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\webcontrols\listcontroldatabindinghandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="ListControlDataBindingHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.WebControls {

    using System.Design;
    using System;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Reflection;
    using System.Web.UI;
    using System.Web.UI.WebControls;

    /// <include file='doc\ListControlDataBindingHandler.uex' path='docs/doc[@for="ListControlDataBindingHandler"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public class ListControlDataBindingHandler : DataBindingHandler {

        /// <include file='doc\ListControlDataBindingHandler.uex' path='docs/doc[@for="ListControlDataBindingHandler.DataBindControl"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void DataBindControl(IDesignerHost designerHost, Control control) {
            Debug.Assert(control is ListControl, "Expected a ListControl");

            DataBinding dataSourceBinding = ((IDataBindingsAccessor)control).DataBindings["DataSource"];
            if (dataSourceBinding != null) {
                ListControl listControl = (ListControl)control;

                listControl.Items.Clear();
                listControl.Items.Add(SR.GetString(SR.Sample_Databound_Text));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\webcontrols\listcontroldesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="ListControlDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   ListControlDesigner.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
    using System.Design;
//------------------------------------------------------------------------------
// <copyright file="ListControlDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.WebControls {

    using System;
    using System.Design;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.IO;
    using System.Data;
    using System.Web.UI;
    using System.Web.UI.WebControls;
    using System.Web.UI.Design;

    using AttributeCollection = System.ComponentModel.AttributeCollection;
    using DataBinding = System.Web.UI.DataBinding;

    /// <include file='doc\ListControlDesigner.uex' path='docs/doc[@for="ListControlDesigner"]/*' />
    /// <devdoc>
    ///    <para>
    ///       This is the base class for all <see cref='System.Web.UI.WebControls.ListControl'/>
    ///       designers.
    ///    </para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public class ListControlDesigner : ControlDesigner, IDataSourceProvider {

        private ListControl listControl;

        /// <include file='doc\ListControlDesigner.uex' path='docs/doc[@for="ListControlDesigner.ListControlDesigner"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.Web.UI.Design.WebControls.ListControlDesigner'/>
        ///       .
        ///    </para>
        /// </devdoc>
        public ListControlDesigner() {
        }

        /// <include file='doc\ListControlDesigner.uex' path='docs/doc[@for="ListControlDesigner.DataMember"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string DataMember {
            get {
                return listControl.DataMember;
            }
            set {
                listControl.DataMember = value;
                OnDataSourceChanged();
            }
        }

        /// <include file='doc\ListControlDesigner.uex' path='docs/doc[@for="ListControlDesigner.DataSource"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Implements the designer's DataSource property that operates on
        ///       the DataSource property in the control's binding collection.
        ///    </para>
        /// </devdoc>
        public string DataSource {
            get {
                DataBinding binding = DataBindings["DataSource"];

                if (binding != null) {
                    return binding.Expression;
                }
                return String.Empty;
            }
            set {
                if ((value == null) || (value.Length == 0)) {
                    DataBindings.Remove("DataSource");
                }
                else {
                    DataBinding binding = DataBindings["DataSource"];

                    if (binding == null) {
                        binding = new DataBinding("DataSource", typeof(IEnumerable), value);
                    }
                    else {
                        binding.Expression = value;
                    }
                    DataBindings.Add(binding);
                }

                OnDataSourceChanged();
                OnBindingsCollectionChanged("DataSource");
            }
        }

        /// <include file='doc\ListControlDesigner.uex' path='docs/doc[@for="ListControlDesigner.DataValueField"]/*' />
        /// <devdoc>
        /// </devdoc>
        public string DataValueField {
            get {
                return listControl.DataValueField;
            }
            set {
                listControl.DataValueField = value;
            }
        }

        /// <include file='doc\ListControlDesigner.uex' path='docs/doc[@for="ListControlDesigner.DataTextField"]/*' />
        /// <devdoc>
        ///   Retrieves the HTML to be used for the design time representation of the control runtime.
        /// </devdoc>
        public string DataTextField {
            get {
                return listControl.DataTextField;
            }
            set {
                listControl.DataTextField = value;
            }
        }

        /// <include file='doc\ListControlDesigner.uex' path='docs/doc[@for="ListControlDesigner.GetDesignTimeHtml"]/*' />
        /// <devdoc>
        ///    <para>Gets the HTML to be used for the design time representation of the control runtime.</para>
        /// </devdoc>
        public override string GetDesignTimeHtml() {
            ListItemCollection items = listControl.Items;
            string designTimeHTML;

            Debug.Assert(items != null, "Items is null in ListItemControl");
            if (items.Count > 0) {
                designTimeHTML = base.GetDesignTimeHtml();
            }
            else {
                if (IsDataBound()) {
                    items.Add(SR.GetString(SR.Sample_Databound_Text));
                }
                else {
                    items.Add(SR.GetString(SR.Sample_Unbound_Text));
                }
                designTimeHTML = base.GetDesignTimeHtml();
                items.Clear();
            }
            return designTimeHTML;
        }

        /// <include file='doc\ListControlDesigner.uex' path='docs/doc[@for="ListControlDesigner.Initialize"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes the component for design.
        ///    </para>
        /// </devdoc>
        public override void Initialize(IComponent component) {
            Debug.Assert(component is ListControl, "ListControlDesigner::Initialize - Invalid ListControl");
            base.Initialize(component);

            listControl = (ListControl)component;
        }

        /// <include file='doc\ListControlDesigner.uex' path='docs/doc[@for="ListControlDesigner.IsDataBound"]/*' />
        /// <devdoc>
        ///   Return true if the control is databound.
        /// </devdoc>
        private bool IsDataBound() {
            DataBinding dataSourceBinding = DataBindings["DataSource"];

            return (dataSourceBinding != null);
        }

        /// <include file='doc\ListControlDesigner.uex' path='docs/doc[@for="ListControlDesigner.GetResolvedSelectedDataSource"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public IEnumerable GetResolvedSelectedDataSource() {
            IEnumerable selectedDataSource = null;

            DataBinding binding = DataBindings["DataSource"];

            if (binding != null) {
                selectedDataSource = DesignTimeData.GetSelectedDataSource(listControl, binding.Expression, DataMember);
            }

            return selectedDataSource;
        }

        /// <include file='doc\ListControlDesigner.uex' path='docs/doc[@for="ListControlDesigner.GetSelectedDataSource"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the selected data source component from the component's container.
        ///    </para>
        /// </devdoc>
        public object GetSelectedDataSource() {
            object selectedDataSource = null;

            DataBinding binding = DataBindings["DataSource"];

            if (binding != null) {
                selectedDataSource = DesignTimeData.GetSelectedDataSource(listControl, binding.Expression);
            }

            return selectedDataSource;
        }

        /// <include file='doc\ListControlDesigner.uex' path='docs/doc[@for="ListControlDesigner.OnComponentChanged"]/*' />
        /// <devdoc>
        ///   Handles changes made to the component. This includes changes made
        ///   in the properties window.
        /// </devdoc>
        public override void OnComponentChanged(object source, ComponentChangedEventArgs ce) {
            if ((ce.Member != null) &&
                ((ce.Member.Name.Equals("DataSource")) || (ce.Member.Name.Equals("DataMember")))) {
                OnDataSourceChanged();
            }
            base.OnComponentChanged(source, ce);
        }

        /// <include file='doc\ListControlDesigner.uex' path='docs/doc[@for="ListControlDesigner.OnDataSourceChanged"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Raises the DataSource event.
        ///    </para>
        /// </devdoc>
        public virtual void OnDataSourceChanged() {
        }

        /// <include file='doc\ListControlDesigner.uex' path='docs/doc[@for="ListControlDesigner.PreFilterProperties"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Filters the properties to replace the runtime DataSource property
        ///       descriptor with the designer's.
        ///    </para>
        /// </devdoc>
        protected override void PreFilterProperties(IDictionary properties) {
            base.PreFilterProperties(properties);

            PropertyDescriptor prop;

            prop = (PropertyDescriptor)properties["DataSource"];
            Debug.Assert(prop != null);

            // we can't create the designer DataSource property based on the runtime property since theie
            // types do not match. Therefore, we have to copy over all the attributes from the runtime
            // and use them that way.
            AttributeCollection runtimeAttributes = prop.Attributes;
            Attribute[] attrs = new Attribute[runtimeAttributes.Count + 1];

            runtimeAttributes.CopyTo(attrs, 0);
            attrs[runtimeAttributes.Count] = new TypeConverterAttribute(typeof(DataSourceConverter));
            prop = TypeDescriptor.CreateProperty(this.GetType(), "DataSource", typeof(string),
                                                 attrs);
            properties["DataSource"] = prop;
            
            prop = (PropertyDescriptor)properties["DataMember"];
            Debug.Assert(prop != null);
            prop = TypeDescriptor.CreateProperty(this.GetType(), prop,
                                                 new Attribute[] {
                                                     new TypeConverterAttribute(typeof(DataMemberConverter))
                                                 });
            properties["DataMember"] = prop;

            Attribute[] fieldPropAttrs = new Attribute[] {
                                             new TypeConverterAttribute(typeof(DataFieldConverter))
                                         };
            prop = (PropertyDescriptor)properties["DataTextField"];
            Debug.Assert(prop != null);
            prop = TypeDescriptor.CreateProperty(this.GetType(), prop, fieldPropAttrs);
            properties["DataTextField"] = prop;

            prop = (PropertyDescriptor)properties["DataValueField"];
            Debug.Assert(prop != null);
            prop = TypeDescriptor.CreateProperty(this.GetType(), prop, fieldPropAttrs);
            properties["DataValueField"] = prop;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\webcontrols\pageletdesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="PageletDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design {

    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Web.UI;

    /// <include file='doc\PageletDesigner.uex' path='docs/doc[@for="UserControlDesigner"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides design-time support for the usercontrols (controls declared in
    ///       .ascx files).
    ///    </para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public class UserControlDesigner : ControlDesigner {

        /// <include file='doc\PageletDesigner.uex' path='docs/doc[@for="UserControlDesigner.UserControlDesigner"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the UserControlDesigner class.
        ///    </para>
        /// </devdoc>
        public UserControlDesigner() {
        }
        
        /// <include file='doc\PageletDesigner.uex' path='docs/doc[@for="UserControlDesigner.AllowResize"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether all user controls are resizeable.
        ///    </para>
        /// </devdoc>
        public override bool AllowResize {
            get {
                return false;
            }
        }

        /// <include file='doc\PageletDesigner.uex' path='docs/doc[@for="UserControlDesigner.ShouldCodeSerialize"]/*' />
        public override bool ShouldCodeSerialize {
            get {
                // should always return false - we don't want to code spit out
                // a variable of type UserControl
                return false;
            }
            set {
            }
        }
        
        /// <include file='doc\PageletDesigner.uex' path='docs/doc[@for="UserControlDesigner.GetDesignTimeHtml"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the HTML to be used for the design time representation of the control runtime.
        ///    </para>
        /// </devdoc>
        public override string GetDesignTimeHtml() {
            return CreatePlaceHolderDesignTimeHtml();
        }

        /// <include file='doc\PageletDesigner.uex' path='docs/doc[@for="PageletDesigner.GetPersistInnerHtml"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the persistable inner HTML.
        ///    </para>
        /// </devdoc>
        public override string GetPersistInnerHtml() {
            // always return null, so that the contents of the user control get round-tripped
            // as is, since we're not in a position to do the actual persistence
            return null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\webcontrols\paneldesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="PanelDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.WebControls {

    using System.Diagnostics;

    using System;
    using System.ComponentModel;
    using Microsoft.Win32;
    using System.Web.UI.WebControls;

    /// <include file='doc\PanelDesigner.uex' path='docs/doc[@for="PanelDesigner"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides design-time support for the <see cref='System.Web.UI.WebControls.Panel'/>
    ///       web control.
    ///    </para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public class PanelDesigner : ReadWriteControlDesigner {

        /// <include file='doc\PanelDesigner.uex' path='docs/doc[@for="PanelDesigner.MapPropertyToStyle"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Maps a specified property and value to a specified HTML style.
        ///    </para>
        /// </devdoc>
        protected override void MapPropertyToStyle(string propName, Object varPropValue) {
            Debug.Assert(propName != null && propName.Length != 0, "Invalid property name passed in!");
            Debug.Assert(varPropValue != null, "Invalid property value passed in!");
            if (propName == null || varPropValue == null) {
                return;
            }
            
            if (varPropValue != null) {
                try {
                    // CONSIDER: Should we also handle mapping of the "NoWrap" property?
                    
                    if (propName.Equals("BackImageUrl")) {
                        string strPropValue = Convert.ToString(varPropValue);
                        if (strPropValue != null) {
                            if (strPropValue.Length != 0) {
                                strPropValue = "url(" + strPropValue + ")";
                            }
                            Behavior.SetStyleAttribute("backgroundImage", true, strPropValue, true);
                        }
                    }
                    else if (propName.Equals("HorizontalAlign")) {
                        string strHAlign = String.Empty;

                        if ((HorizontalAlign)varPropValue != HorizontalAlign.NotSet) {
                            strHAlign = Enum.Format(typeof(HorizontalAlign), varPropValue, "G");
                        }
                        Behavior.SetStyleAttribute("textAlign", true, strHAlign, true);
                    }
                    else {
                        base.MapPropertyToStyle(propName, varPropValue);
                    }
                }
                catch (Exception ex) {
                    Debug.Fail(ex.ToString());
                }
            }
        }
        
        /// <include file='doc\PanelDesigner.uex' path='docs/doc[@for="PanelDesigner.OnBehaviorAttached"]/*' />
        /// <devdoc>
        ///     Notification that is fired upon the designer being attached to the behavior.
        /// </devdoc>
        protected override void OnBehaviorAttached() {
            base.OnBehaviorAttached();
            
            Panel panel = (Panel)Component;
            string backImageUrl = panel.BackImageUrl;
            if (backImageUrl != null) {
                MapPropertyToStyle("BackImageUrl", backImageUrl);
            }
            
            HorizontalAlign hAlign = panel.HorizontalAlign;
            if (HorizontalAlign.NotSet != hAlign) {
                MapPropertyToStyle("HorizontalAlign", hAlign);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\webcontrols\regexeditordialog.cs ===
//------------------------------------------------------------------------------
// <copyright file="RegexEditorDialog.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   RegexEditorDialog.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Web.UI.Design.WebControls {
    using System;
    using System.Design;
    using System.Drawing;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Windows.Forms;
    using System.Diagnostics;
    using System.Text.RegularExpressions;
    using System.Windows.Forms.Design;
    
    /// <include file='doc\RegexEditorDialog.uex' path='docs/doc[@for="RegexEditorDialog"]/*' />
    /// <internalonly/>
    /// <devdoc>
    ///    Dialog for editting regular expressions used by the RegularExpressionValidator
    /// </devdoc>
    [
    System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode),
    ToolboxItem(false)
    ]
    public class RegexEditorDialog : System.Windows.Forms.Form {
        
        private System.ComponentModel.Container components;
        private System.Windows.Forms.TextBox txtExpression;
        private System.Windows.Forms.ListBox lstStandardExpressions;
        private System.Windows.Forms.Label lblStandardExpressions;
        private System.Windows.Forms.Label lblTestResult;
        private System.Windows.Forms.TextBox txtSampleInput;
        private System.Windows.Forms.Button cmdTestValidate;
        private System.Windows.Forms.Label lblInput;
        private System.Windows.Forms.Label lblExpression;
        private System.Windows.Forms.GroupBox grpExpression;        
        private System.Windows.Forms.Button cmdHelp;
        private System.Windows.Forms.Button cmdCancel;        
        private System.Windows.Forms.Button cmdOK;
        
        private string regularExpression;
        private bool settingValue;
        private bool firstActivate = true;
        private ISite site;
        static object [] cannedExpressions;
        
        
        /// <include file='doc\RegexEditorDialog.uex' path='docs/doc[@for="RegexEditorDialog.RegularExpression"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string RegularExpression {
            get {        
                return regularExpression;
            }
            set {
                regularExpression = value;
            }
        }
        
        /// <include file='doc\RegexEditorDialog.uex' path='docs/doc[@for="RegexEditorDialog.RegexEditorDialog"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public RegexEditorDialog(ISite site) {
            this.site = site;
            InitializeComponent();
            settingValue = false;
            regularExpression = string.Empty;
        }
        
        /// <include file='doc\RegexEditorDialog.uex' path='docs/doc[@for="RegexEditorDialog.Dispose"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void Dispose(bool disposing) {
            if (disposing) {
                components.Dispose();
            }
            base.Dispose(disposing);
        }
        
        private void InitializeComponent() {
            this.components = new System.ComponentModel.Container();
            this.lblTestResult = new System.Windows.Forms.Label();
            this.lstStandardExpressions = new System.Windows.Forms.ListBox();
            this.cmdHelp = new System.Windows.Forms.Button();
            this.lblStandardExpressions = new System.Windows.Forms.Label();
            this.cmdTestValidate = new System.Windows.Forms.Button();
            this.txtExpression = new System.Windows.Forms.TextBox();
            this.lblInput = new System.Windows.Forms.Label();
            this.grpExpression = new System.Windows.Forms.GroupBox();
            this.txtSampleInput = new System.Windows.Forms.TextBox();
            this.cmdCancel = new System.Windows.Forms.Button();
            this.lblExpression = new System.Windows.Forms.Label();
            this.cmdOK = new System.Windows.Forms.Button();
            
            // Use the correct VS Font
            Font f = Control.DefaultFont;
            IUIService uiService = (IUIService)site.GetService(typeof(IUIService));
            if (uiService != null) {
                f = (Font)uiService.Styles["DialogFont"];
            }            
            this.Font = f;
            
            this.Text = SR.GetString(SR.RegexEditor_Title);
            this.MaximizeBox = false;
            this.ImeMode = System.Windows.Forms.ImeMode.Disable;
            this.AcceptButton = cmdOK;
            this.CancelButton = cmdCancel;
            this.Icon = null;
            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
            this.MinimizeBox = false;
            this.ClientSize = new System.Drawing.Size(344, 193);
            this.Activated += new System.EventHandler(RegexTypeEditor_Activated);
            this.HelpRequested += new HelpEventHandler(Form_HelpRequested);
            this.StartPosition = FormStartPosition.CenterParent;
            
            lstStandardExpressions.Location = new System.Drawing.Point(8, 24);
            lstStandardExpressions.Size = new System.Drawing.Size(328, 84);
            lstStandardExpressions.TabIndex = 1;
            lstStandardExpressions.SelectedIndexChanged += new System.EventHandler(lstStandardExpressions_SelectedIndexChanged);
            lstStandardExpressions.Sorted = true;
            lstStandardExpressions.IntegralHeight = true;
            lstStandardExpressions.Items.AddRange(CannedExpressions);       
            
            lblStandardExpressions.Location = new System.Drawing.Point(8, 8);
            lblStandardExpressions.Text = SR.GetString(SR.RegexEditor_StdExp);
            lblStandardExpressions.Size = new System.Drawing.Size(328, 16);
            lblStandardExpressions.TabIndex = 0;
            
            txtExpression.Location = new System.Drawing.Point(8, 130);
            txtExpression.TabIndex = 3;
            txtExpression.Size = new System.Drawing.Size(328, 20);
            txtExpression.TextChanged += new System.EventHandler(txtExpression_TextChanged);            
            
            lblExpression.Location = new System.Drawing.Point(8, 114);
            lblExpression.Text = SR.GetString(SR.RegexEditor_ValidationExpression);
            lblExpression.Size = new System.Drawing.Size(328, 16);
            lblExpression.TabIndex = 2;
            
            cmdOK.Location = new System.Drawing.Point(99, 162);
            cmdOK.DialogResult = System.Windows.Forms.DialogResult.OK;
            cmdOK.Size = new System.Drawing.Size(75, 23);
            cmdOK.TabIndex = 9;
            cmdOK.Text = SR.GetString(SR.RegexEditor_OK);
            cmdOK.FlatStyle = FlatStyle.System;
            cmdOK.Click += new System.EventHandler(cmdOK_Click);
            
            cmdCancel.Location = new System.Drawing.Point(180, 162);
            cmdCancel.DialogResult = System.Windows.Forms.DialogResult.Cancel;
            cmdCancel.Size = new System.Drawing.Size(75, 23);
            cmdCancel.TabIndex = 10;
            cmdCancel.FlatStyle = FlatStyle.System;
            cmdCancel.Text = SR.GetString(SR.RegexEditor_Cancel);
            
            cmdHelp.Location = new System.Drawing.Point(261, 162);
            cmdHelp.Size = new System.Drawing.Size(75, 23);
            cmdHelp.TabIndex = 11;
            cmdHelp.Text = SR.GetString(SR.RegexEditor_Help);
            cmdHelp.FlatStyle = FlatStyle.System;
            cmdHelp.Click += new System.EventHandler(cmdHelp_Click);
            
            // This is hidden and out of the way for now.
            grpExpression.Location = new System.Drawing.Point(8, 280);
            grpExpression.ImeMode = System.Windows.Forms.ImeMode.Disable;
            grpExpression.TabIndex = 4;
            grpExpression.TabStop = false;
            grpExpression.Text = SR.GetString(SR.RegexEditor_TestExpression);
            grpExpression.Size = new System.Drawing.Size(328, 80);
            grpExpression.Visible = false;
            
            txtSampleInput.Location = new System.Drawing.Point(88, 24);
            txtSampleInput.TabIndex = 6;
            txtSampleInput.Size = new System.Drawing.Size(160, 20);
            
            grpExpression.Controls.Add(lblTestResult);
            grpExpression.Controls.Add(txtSampleInput);
            grpExpression.Controls.Add(cmdTestValidate);
            grpExpression.Controls.Add(lblInput);
            
            cmdTestValidate.Location = new System.Drawing.Point(256, 24);
            cmdTestValidate.Size = new System.Drawing.Size(56, 20);
            cmdTestValidate.TabIndex = 7;
            cmdTestValidate.Text = SR.GetString(SR.RegexEditor_Validate);
            cmdTestValidate.FlatStyle = FlatStyle.System;
            cmdTestValidate.Click += new System.EventHandler(cmdTestValidate_Click);
            
            lblInput.Location = new System.Drawing.Point(8, 28);
            lblInput.Text = SR.GetString(SR.RegexEditor_SampleInput);
            lblInput.Size = new System.Drawing.Size(80, 16);
            lblInput.TabIndex = 5;  
            
            lblTestResult.Location = new System.Drawing.Point(8, 56);
            lblTestResult.Size = new System.Drawing.Size(312, 16);
            lblTestResult.TabIndex = 8;
            
            this.Controls.Add(txtExpression);
            this.Controls.Add(lstStandardExpressions);
            this.Controls.Add(lblStandardExpressions);
            this.Controls.Add(lblExpression);
            this.Controls.Add(grpExpression);
            this.Controls.Add(cmdHelp);
            this.Controls.Add(cmdCancel);
            this.Controls.Add(cmdOK);
        }
    
        /// <include file='doc\RegexEditorDialog.uex' path='docs/doc[@for="RegexEditorDialog.txtExpression_TextChanged"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected void txtExpression_TextChanged(object sender, System.EventArgs e){
            if (settingValue || firstActivate) 
                return;
            lblTestResult.Text = string.Empty;
            UpdateExpressionList();
        }
        /// <include file='doc\RegexEditorDialog.uex' path='docs/doc[@for="RegexEditorDialog.lstStandardExpressions_SelectedIndexChanged"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected void lstStandardExpressions_SelectedIndexChanged(object sender, System.EventArgs e) {
            if (settingValue) 
                return;
            // first item should always be "(Custom)"
            if (lstStandardExpressions.SelectedIndex >= 1) {
                CannedExpression expression = (CannedExpression) lstStandardExpressions.SelectedItem;
                settingValue = true;
                txtExpression.Text = expression.Expression;
                settingValue = false;
            }                                
        }
    
        /// <include file='doc\RegexEditorDialog.uex' path='docs/doc[@for="RegexEditorDialog.RegexTypeEditor_Activated"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected void RegexTypeEditor_Activated(object sender, System.EventArgs e) {
            if (!firstActivate) {
                return;
            }            
            txtExpression.Text = RegularExpression;
            UpdateExpressionList();
            firstActivate = false;
        }
        
        private void UpdateExpressionList() {
            bool found = false;
            settingValue = true;
            string expression = txtExpression.Text;
            // first item is always be "(Custom)"
            for (int i = 1; i < lstStandardExpressions.Items.Count; i++) {
                if (expression == ((CannedExpression)lstStandardExpressions.Items[i]).Expression) {
                    lstStandardExpressions.SelectedIndex = i;
                    found = true;
                }
            }
            if (!found) {
                lstStandardExpressions.SelectedIndex = 0;
            }
            settingValue = false;
        }
    
        /// <include file='doc\RegexEditorDialog.uex' path='docs/doc[@for="RegexEditorDialog.cmdTestValidate_Click"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected void cmdTestValidate_Click(object sender, System.EventArgs args) {            
            // Note: keep this in sync with RegularExpressionValidator.EvaluateIsValid
            
            try {
                bool isValid;            
                // check the expression first so we find all bad expressions
                // we are looking for an exact match, not just a search hit
                Match m = Regex.Match(txtSampleInput.Text, txtExpression.Text);
                isValid = (m.Success 
                    && m.Index == 0 
                    && m.Length == txtSampleInput.Text.Length);
                
                // Blank input is always valid
                if (txtSampleInput.Text.Length == 0) {
                    isValid = true;   
                }
                else {
                }
                lblTestResult.Text = isValid
                    ? SR.GetString(SR.RegexEditor_InputValid)
                    : SR.GetString(SR.RegexEditor_InputInvalid);
                lblTestResult.ForeColor = isValid ? Color.Black : Color.Red;
            }
            catch {
                lblTestResult.Text = SR.GetString(SR.RegexEditor_BadExpression);
                lblTestResult.ForeColor = Color.Red;
            }                   
        }

        private void ShowHelp() {
            IHelpService helpService = (IHelpService)site.GetService(typeof(IHelpService));
            if (helpService != null) {
                helpService.ShowHelpFromKeyword("net.Asp.RegularExpressionEditor");
            }
        }
    
        /// <include file='doc\RegexEditorDialog.uex' path='docs/doc[@for="RegexEditorDialog.cmdHelp_Click"]/*' />
        protected void cmdHelp_Click(object sender, System.EventArgs e) {
            ShowHelp();
        }

        private void Form_HelpRequested(object sender, HelpEventArgs e) {
            ShowHelp();
        }

        
        /// <include file='doc\RegexEditorDialog.uex' path='docs/doc[@for="RegexEditorDialog.cmdOK_Click"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected void cmdOK_Click(object sender, System.EventArgs e) {
            this.RegularExpression = this.txtExpression.Text;
        }
        
        private object [] CannedExpressions {
            get {
                if (cannedExpressions == null) {
                    cannedExpressions = new object [] {
                        SR.GetString(SR.RegexCanned_Custom),
                            new CannedExpression(SR.GetString(SR.RegexCanned_SocialSecurity), @"\d{3}-\d{2}-\d{4}"),
                            new CannedExpression(SR.GetString(SR.RegexCanned_USPhone), @"((\(\d{3}\) ?)|(\d{3}-))?\d{3}-\d{4}"),
                            new CannedExpression(SR.GetString(SR.RegexCanned_Zip), @"\d{5}(-\d{4})?"),
                            new CannedExpression(SR.GetString(SR.RegexCanned_Email), @"\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*"),
                            new CannedExpression(SR.GetString(SR.RegexCanned_URL), @"http://([\w-]+\.)+[\w-]+(/[\w- ./?%&=]*)?"),

                            new CannedExpression(SR.GetString(SR.RegexCanned_FrZip), @"\d{5}"),
                            new CannedExpression(SR.GetString(SR.RegexCanned_FrPhone), @"(0( \d|\d ))?\d\d \d\d(\d \d| \d\d )\d\d"),

                            new CannedExpression(SR.GetString(SR.RegexCanned_DeZip), @"(D-)?\d{5}"),
                            new CannedExpression(SR.GetString(SR.RegexCanned_DePhone), @"((\(0\d\d\) |(\(0\d{3}\) )?\d )?\d\d \d\d \d\d|\(0\d{4}\) \d \d\d-\d\d?)"),
                            
                            new CannedExpression(SR.GetString(SR.RegexCanned_JpnZip), @"\d{3}(-(\d{4}|\d{2}))?"),
                            new CannedExpression(SR.GetString(SR.RegexCanned_JpnPhone), @"(0\d{1,4}-|\(0\d{1,4}\) ?)?\d{1,4}-\d{4}"),

                            new CannedExpression(SR.GetString(SR.RegexCanned_PrcZip), @"\d{6}"),
                            new CannedExpression(SR.GetString(SR.RegexCanned_PrcPhone), @"(\(\d{3}\)|\d{3}-)?\d{8}"),
                            new CannedExpression(SR.GetString(SR.RegexCanned_PrcSocialSecurity), @"\d{18}|\d{15}"),
                            
                    };
                }
                return cannedExpressions;
            }
        }
        
        private class CannedExpression {
            
            public string Description;
            public string Expression;
            
            public CannedExpression(string description, string expression) {
                Description = description;
                Expression = expression;
            }
            
            public override string ToString() {
                return Description;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\webcontrols\tablecellscollectioneditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="TableCellsCollectionEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.WebControls {

    using System;
    using System.ComponentModel;
    using System.Reflection;
    using System.ComponentModel.Design;

    /// <include file='doc\TableCellsCollectionEditor.uex' path='docs/doc[@for="TableCellsCollectionEditor"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public class TableCellsCollectionEditor : CollectionEditor {

        /// <include file='doc\TableCellsCollectionEditor.uex' path='docs/doc[@for="TableCellsCollectionEditor.TableCellsCollectionEditor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public TableCellsCollectionEditor(Type type) : base(type) {
        }

        /// <include file='doc\TableCellsCollectionEditor.uex' path='docs/doc[@for="TableCellsCollectionEditor.CanSelectMultipleInstances"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override bool CanSelectMultipleInstances() {
            return false;
        }

        /// <include file='doc\TableCellsCollectionEditor.uex' path='docs/doc[@for="TableCellsCollectionEditor.CreateInstance"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override object CreateInstance(Type itemType) {
            return Activator.CreateInstance(itemType, BindingFlags.Instance | BindingFlags.Public | BindingFlags.CreateInstance, null, null, null);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\webcontrols\regextypeeditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="RegexTypeEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.WebControls {
    
    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;
    using System.IO;
    using System.Collections;
    using System.ComponentModel;
    using System.Windows.Forms;
    using System.Drawing;
    using System.Drawing.Design;    
    using System.Windows.Forms.Design;
    using System.Windows.Forms.ComponentModel;
    using System.Web.UI.Design.Util;

    /// <include file='doc\RegexTypeEditor.uex' path='docs/doc[@for="RegexTypeEditor"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public class RegexTypeEditor : UITypeEditor {
        
        /// <include file='doc\RegexTypeEditor.uex' path='docs/doc[@for="RegexTypeEditor.EditValue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override object EditValue(ITypeDescriptorContext context,  IServiceProvider  provider, object value) {

            if (provider != null) {
                IWindowsFormsEditorService edSvc = (IWindowsFormsEditorService)provider.GetService(typeof(IWindowsFormsEditorService));

                if (edSvc != null) {

                    // Get the site
                    // REVIEW amoore: there must be a better way to do this.
                    ISite site = null;
                    if (context.Instance is IComponent) {
                        site = ((IComponent)context.Instance).Site;
                    }
                    else if (context.Instance is object[]) {
                        object [] components = (object []) context.Instance;
                        if (components[0] is IComponent) {
                            site = ((IComponent)components[0]).Site;
                        }
                    }

                    RegexEditorDialog editorDialog = new RegexEditorDialog(site);
                    editorDialog.RegularExpression = value.ToString();
                    if (editorDialog.ShowDialog() == DialogResult.OK) {
                        value = editorDialog.RegularExpression;
                    }
                }
            }
            return value;
        }

        /// <include file='doc\RegexTypeEditor.uex' path='docs/doc[@for="RegexTypeEditor.GetEditStyle"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override UITypeEditorEditStyle GetEditStyle(ITypeDescriptorContext context) {
            return UITypeEditorEditStyle.Modal;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\webcontrols\repeaterdesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="RepeaterDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.WebControls {
    
    using System;
    using System.Design;
    using System.Collections;    
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Data;
    using System.Diagnostics;
    using System.Web.UI.Design;
    using System.Web.UI.WebControls;

    using AttributeCollection = System.ComponentModel.AttributeCollection;
    using DataBinding = System.Web.UI.DataBinding;

    /// <include file='doc\RepeaterDesigner.uex' path='docs/doc[@for="RepeaterDesigner"]/*' />
    /// <internalonly/>
    /// <devdoc>
    ///    <para>
    ///       Provides a designer for the <see cref='System.Web.UI.WebControls.Repeater'/> control.
    ///    </para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public class RepeaterDesigner : ControlDesigner, IDataSourceProvider {

        internal static TraceSwitch RepeaterDesignerSwitch =
            new TraceSwitch("RepeaterDesigner", "Enable Repeater designer general purpose traces.");

        private Repeater repeater;
        private DataTable dummyDataTable;
        private DataTable designTimeDataTable;

        /// <include file='doc\RepeaterDesigner.uex' path='docs/doc[@for="RepeaterDesigner.RepeaterDesigner"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Web.UI.Design.WebControls.RepeaterDesigner'/> class.
        ///    </para>
        /// </devdoc>
        public RepeaterDesigner() {
        }

        /// <include file='doc\RepeaterDesigner.uex' path='docs/doc[@for="RepeaterDesigner.DataMember"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string DataMember {
            get {
                return repeater.DataMember;
            }
            set {
                repeater.DataMember = value;
                OnDataSourceChanged();
            }
        }
        
        /// <include file='doc\RepeaterDesigner.uex' path='docs/doc[@for="RepeaterDesigner.DataSource"]/*' />
        /// <devdoc>
        ///   Designer implementation of DataSource property that operates on
        ///   the DataSource property in the control's binding collection.
        /// </devdoc>
        public string DataSource {
            get {
                DataBinding binding = DataBindings["DataSource"];

                if (binding != null) {
                    return binding.Expression;
                }
                return String.Empty;
            }
            set {
                if ((value == null) || (value.Length == 0)) {
                    DataBindings.Remove("DataSource");
                }
                else {
                    DataBinding binding = DataBindings["DataSource"];

                    if (binding == null) {
                        binding = new DataBinding("DataSource", typeof(IEnumerable), value);
                    }
                    else {
                        binding.Expression = value;
                    }
                    DataBindings.Add(binding);
                }

                OnDataSourceChanged();
                OnBindingsCollectionChanged("DataSource");
            }
        }

        /// <include file='doc\RepeaterDesigner.uex' path='docs/doc[@for="RepeaterDesigner.TemplatesExist"]/*' />
        /// <devdoc>
        /// </devdoc>
        protected bool TemplatesExist {
            get {
                return (repeater.ItemTemplate != null) ||
                       (repeater.HeaderTemplate != null) ||
                       (repeater.FooterTemplate != null) ||
                       (repeater.AlternatingItemTemplate != null);
            }
        }


        /// <include file='doc\RepeaterDesigner.uex' path='docs/doc[@for="RepeaterDesigner.Dispose"]/*' />
        /// <devdoc>
        ///   Performs the cleanup of the designer class.
        /// </devdoc>
        protected override void Dispose(bool disposing) {
            if (disposing) {
                repeater = null;
            }

            base.Dispose(disposing);
        }

        /// <include file='doc\RepeaterDesigner.uex' path='docs/doc[@for="RepeaterDesigner.GetDesignTimeDataSource"]/*' />
        /// <devdoc>
        ///   Returns a sample data matching the schema of the selected datasource.
        /// </devdoc>
        protected IEnumerable GetDesignTimeDataSource(int minimumRows) {
            IEnumerable selectedDataSource = GetResolvedSelectedDataSource();
            return GetDesignTimeDataSource(selectedDataSource, minimumRows);
        }

        /// <include file='doc\RepeaterDesigner.uex' path='docs/doc[@for="RepeaterDesigner.GetDesignTimeDataSource1"]/*' />
        /// <devdoc>
        ///   Returns a sample data matching the schema of the selected datasource.
        /// </devdoc>
        protected IEnumerable GetDesignTimeDataSource(IEnumerable selectedDataSource, int minimumRows) {
            DataTable dataTable = designTimeDataTable;

            // use the datatable corresponding to the selected datasource if possible
            if (dataTable == null) {
                if (selectedDataSource != null) {
                    designTimeDataTable = DesignTimeData.CreateSampleDataTable(selectedDataSource);

                    dataTable = designTimeDataTable;
                }

                if (dataTable == null) {
                    // fallback on a dummy datasource if we can't create a sample datatable
                    if (dummyDataTable == null) {
                        dummyDataTable = DesignTimeData.CreateDummyDataTable();
                    }

                    dataTable = dummyDataTable;
                }
            }

            IEnumerable liveDataSource = DesignTimeData.GetDesignTimeDataSource(dataTable, minimumRows);
            return liveDataSource;
        }

        /// <include file='doc\RepeaterDesigner.uex' path='docs/doc[@for="RepeaterDesigner.GetDesignTimeHtml"]/*' />
        /// <devdoc>
        ///   Retrieves the HTML to be used for the design time representation
        ///   of the control.
        /// </devdoc>
        public override string GetDesignTimeHtml() {
            IEnumerable selectedDataSource = null;
            bool hasATemplate = this.TemplatesExist;
            string designTimeHTML;

            if (hasATemplate) {
                selectedDataSource = GetResolvedSelectedDataSource();
                IEnumerable designTimeDataSource = GetDesignTimeDataSource(selectedDataSource, 5);

                try {
                    repeater.DataSource = designTimeDataSource;
                    repeater.DataBind();
                    designTimeHTML = base.GetDesignTimeHtml();
                }
                catch (Exception e) {
                    designTimeHTML = GetErrorDesignTimeHtml(e);
                }
                finally {
                    repeater.DataSource = null;
                }
            }
            else {
                designTimeHTML = GetEmptyDesignTimeHtml();
            }

            return designTimeHTML;
        }

        /// <include file='doc\RepeaterDesigner.uex' path='docs/doc[@for="RepeaterDesigner.GetEmptyDesignTimeHtml"]/*' />
        /// <devdoc>
        /// </devdoc>
        protected override string GetEmptyDesignTimeHtml() {
            return CreatePlaceHolderDesignTimeHtml(SR.GetString(SR.Repeater_NoTemplatesInst));
        }

        /// <include file='doc\RepeaterDesigner.uex' path='docs/doc[@for="RepeaterDesigner.GetErrorDesignTimeHtml"]/*' />
        /// <devdoc>
        /// </devdoc>
        protected override string GetErrorDesignTimeHtml(Exception e) {
            return CreatePlaceHolderDesignTimeHtml(SR.GetString(SR.Repeater_ErrorRendering));
        }

        /// <include file='doc\RepeaterDesigner.uex' path='docs/doc[@for="RepeaterDesigner.GetResolvedSelectedDataSource"]/*' />
        /// <devdoc>
        /// </devdoc>
        public IEnumerable GetResolvedSelectedDataSource() {
            IEnumerable selectedDataSource = null;

            DataBinding binding = DataBindings["DataSource"];

            if (binding != null) {
                selectedDataSource = DesignTimeData.GetSelectedDataSource(repeater, binding.Expression, DataMember);
            }

            return selectedDataSource;
        }

        /// <include file='doc\RepeaterDesigner.uex' path='docs/doc[@for="RepeaterDesigner.GetSelectedDataSource"]/*' />
        /// <devdoc>
        ///   Retrieves the selected datasource component from the component's container.
        /// </devdoc>
        public object GetSelectedDataSource() {
            object selectedDataSource = null;

            DataBinding binding = DataBindings["DataSource"];

            if (binding != null) {
                selectedDataSource = DesignTimeData.GetSelectedDataSource(repeater, binding.Expression);
            }

            return selectedDataSource;
        }

        /// <include file='doc\RepeaterDesigner.uex' path='docs/doc[@for="RepeaterDesigner.Initialize"]/*' />
        /// <devdoc>
        ///   Initializes the designer with the Repeater control that this instance
        ///   of the designer is associated with.
        /// </devdoc>
        public override void Initialize(IComponent component) {
            Debug.Assert(component is Repeater,
                         "RepeaterDesigner::Initialize - Invalid Repeater Control");

            repeater = (Repeater)component;
            base.Initialize(component);
        }

        /// <include file='doc\RepeaterDesigner.uex' path='docs/doc[@for="RepeaterDesigner.OnComponentChanged"]/*' />
        /// <devdoc>
        ///   Handles changes made to the component. This includes changes made
        ///   in the properties window.
        /// </devdoc>
        public override void OnComponentChanged(object source, ComponentChangedEventArgs ce) {
            if ((ce.Member != null) &&
                ((ce.Member.Name.Equals("DataSource")) || (ce.Member.Name.Equals("DataMember")))) {
                OnDataSourceChanged();
            }
            base.OnComponentChanged(source, ce);
        }

        /// <include file='doc\RepeaterDesigner.uex' path='docs/doc[@for="RepeaterDesigner.OnDataSourceChanged"]/*' />
        /// <devdoc>
        ///   Handles changes made to the data source
        /// </devdoc>
        public virtual void OnDataSourceChanged() {
            designTimeDataTable = null;
        }

        /// <include file='doc\RepeaterDesigner.uex' path='docs/doc[@for="RepeaterDesigner.PreFilterProperties"]/*' />
        /// <devdoc>
        ///   Filter the properties to replace the runtime DataSource property
        ///   descriptor with the designer's.
        /// </devdoc>
        protected override void PreFilterProperties(IDictionary properties) {
            base.PreFilterProperties(properties);

            PropertyDescriptor prop;

            prop = (PropertyDescriptor)properties["DataSource"];
            Debug.Assert(prop != null);

            // we can't create the designer DataSource property based on the runtime property since theie
            // types do not match. Therefore, we have to copy over all the attributes from the runtime
            // and use them that way.
            AttributeCollection runtimeAttributes = prop.Attributes;
            Attribute[] attrs = new Attribute[runtimeAttributes.Count + 1];

            runtimeAttributes.CopyTo(attrs, 0);
            attrs[runtimeAttributes.Count] = new TypeConverterAttribute(typeof(DataSourceConverter));
            prop = TypeDescriptor.CreateProperty(this.GetType(), "DataSource", typeof(string),
                                                 attrs);
            properties["DataSource"] = prop;
            
            prop = (PropertyDescriptor)properties["DataMember"];
            Debug.Assert(prop != null);
            prop = TypeDescriptor.CreateProperty(this.GetType(), prop,
                                                 new Attribute[] {
                                                     new TypeConverterAttribute(typeof(DataMemberConverter))
                                                 });
            properties["DataMember"] = prop;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\webcontrols\tablerowscollectioneditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="TableRowsCollectionEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.WebControls {

    using System;
    using System.Reflection;
    using System.ComponentModel;
    using System.ComponentModel.Design;

    /// <include file='doc\TableRowsCollectionEditor.uex' path='docs/doc[@for="TableRowsCollectionEditor"]/*' />
    /// <devdoc>
    ///    <para>Provides an editor to edit rows in a table.</para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public class TableRowsCollectionEditor : CollectionEditor {

        /// <include file='doc\TableRowsCollectionEditor.uex' path='docs/doc[@for="TableRowsCollectionEditor.TableRowsCollectionEditor"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.UI.Design.WebControls.TableRowsCollectionEditor'/> class.</para>
        /// </devdoc>
        public TableRowsCollectionEditor(Type type) : base(type) {
        }

        /// <include file='doc\TableRowsCollectionEditor.uex' path='docs/doc[@for="TableRowsCollectionEditor.CanSelectMultipleInstances"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether multiple instances may be selected.</para>
        /// </devdoc>
        protected override bool CanSelectMultipleInstances() {
            return false;
        }

        /// <include file='doc\TableRowsCollectionEditor.uex' path='docs/doc[@for="TableRowsCollectionEditor.CreateInstance"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override object CreateInstance(Type itemType) {
            return Activator.CreateInstance(itemType, BindingFlags.Instance | BindingFlags.Public | BindingFlags.CreateInstance, null, null, null);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\webcontrols\xmldesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.WebControls {
    
    using System;
    using System.Design;
    using System.Collections;    
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Data;
    using System.Diagnostics;
    using System.Web.UI.Design;
    using System.Web.UI.WebControls;

    /// <include file='doc\XmlDesigner.uex' path='docs/doc[@for="XmlDesigner"]/*' />
    /// <internalonly/>
    /// <devdoc>
    ///    <para>
    ///       Provides a designer for the <see cref='System.Web.UI.WebControls.Xml'/> control.
    ///    </para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public class XmlDesigner : ControlDesigner {

        private Xml xml;

        /// <include file='doc\XmlDesigner.uex' path='docs/doc[@for="XmlDesigner.XmlDesigner"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Web.UI.Design.WebControls.RepeaterDesigner'/> class.
        ///    </para>
        /// </devdoc>
        public XmlDesigner() {
        }

        /// <include file='doc\XmlDesigner.uex' path='docs/doc[@for="XmlDesigner.Dispose"]/*' />
        /// <devdoc>
        ///   Performs the cleanup of the designer class.
        /// </devdoc>
        protected override void Dispose(bool disposing) {
            if (disposing) {
                xml = null;
            }

            base.Dispose(disposing);
        }

        /// <include file='doc\XmlDesigner.uex' path='docs/doc[@for="XmlDesigner.GetDesignTimeHtml"]/*' />
        /// <devdoc>
        ///   Retrieves the HTML to be used for the design time representation
        ///   of the control.
        /// </devdoc>
        public override string GetDesignTimeHtml() {
            return GetEmptyDesignTimeHtml();
        }

        /// <include file='doc\XmlDesigner.uex' path='docs/doc[@for="XmlDesigner.GetEmptyDesignTimeHtml"]/*' />
        /// <devdoc>
        /// </devdoc>
        protected override string GetEmptyDesignTimeHtml() {
            return CreatePlaceHolderDesignTimeHtml(SR.GetString(SR.Xml_Inst));
        }

        /// <include file='doc\XmlDesigner.uex' path='docs/doc[@for="XmlDesigner.Initialize"]/*' />
        /// <devdoc>
        ///   Initializes the designer with the Repeater control that this instance
        ///   of the designer is associated with.
        /// </devdoc>
        public override void Initialize(IComponent component) {
            Debug.Assert(component is Xml,
                         "RepeaterDesigner::Initialize - Invalid Repeater Control");

            xml = (Xml)component;
            base.Initialize(component);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\webcontrols\tabledesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="TableDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.WebControls {

    using System;
    using System.Collections;
    using System.ComponentModel;
    using Microsoft.Win32;
    using System.Diagnostics;
    using System.Web.UI.WebControls;

    /// <include file='doc\TableDesigner.uex' path='docs/doc[@for="TableDesigner"]/*' />
    /// <devdoc>
    ///    <para>
    ///       The designer for the <see cref='System.Web.UI.WebControls.Table'/>
    ///       web control.
    ///    </para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public class TableDesigner : ControlDesigner {

        /// <include file='doc\TableDesigner.uex' path='docs/doc[@for="TableDesigner.GetDesignTimeHtml"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the design time HTML of the <see cref='System.Web.UI.WebControls.Table'/>
        ///       control.
        ///    </para>
        /// </devdoc>
        public override string GetDesignTimeHtml() {
            Table table = (Table)Component;
            TableRowCollection rows = table.Rows;
            ArrayList cellsWithDummyContents = null;

            bool emptyTable = (rows.Count == 0);
            bool emptyRows = false;

            if (emptyTable) {
                TableRow row = new TableRow();
                rows.Add(row);

                TableCell cell = new TableCell();
                cell.Text = "###";
                rows[0].Cells.Add(cell);
            }
            else {
                emptyRows = true;
                for (int i = 0; i < rows.Count; i++) {
                    if (rows[i].Cells.Count != 0) {
                        emptyRows = false;
                        break;
                    }
                }
                if (emptyRows == true) {
                    TableCell cell = new TableCell();
                    cell.Text = "###";
                    rows[0].Cells.Add(cell);
                }
            }

            if (emptyTable == false) {
                // rows and cells were defined by the user, but if the cells are empty
                // then something needs to be done about that, so they are visible
                foreach (TableRow row in rows) {
                    foreach (TableCell cell in row.Cells) {
                        if ((cell.Text.Length == 0) && (cell.HasControls() == false)) {
                            if (cellsWithDummyContents == null) {
                                cellsWithDummyContents = new ArrayList();
                            }
                            cellsWithDummyContents.Add(cell);
                            cell.Text = "###";
                        }
                    }
                }
            }

            // now get the design-time HTML
            string designTimeHTML = base.GetDesignTimeHtml();

            // and restore the table back to the way it was
            if (emptyTable) {
                // restore the table back to its empty state
                rows.Clear();
            }
            else {
                // restore the cells that were empty
                if (cellsWithDummyContents != null) {
                    foreach (TableCell cell in cellsWithDummyContents) {
                        cell.Text = String.Empty;
                    }
                }
                if (emptyRows) {
                    // we added a cell into row 0, so remove it
                    rows[0].Cells.Clear();
                }
            }

            return designTimeHTML;
        }

        /// <internalonly/>
        public override string GetPersistInnerHtml() {
            if (!IsDirty) {
                return null;
            }

            Table table = (Table)Component;
            
            bool oldVisible = table.Visible;
            string html = String.Empty;
            try {
                table.Visible = true;
                html = base.GetPersistInnerHtml();
            }
            finally {
                table.Visible = oldVisible;
            }

            return html;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\webcontrols\listcontrols\basedatalistpage.cs ===
//------------------------------------------------------------------------------
// <copyright file="BaseDataListPage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.WebControls.ListControls {

    using System.Design;
    using System;
    using System.CodeDom;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Data;
    using System.Drawing;
    using System.Web.UI.WebControls;
    using System.Windows.Forms;
    using System.Windows.Forms.Design;

    /// <include file='doc\BaseDataListPage.uex' path='docs/doc[@for="BaseDataListPage"]/*' />
    /// <devdoc>
    ///   The base class for all DataGrid and DataList component editor pages.
    /// </devdoc>
    /// <internalonly/>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal abstract class BaseDataListPage : ComponentEditorPage {

        private bool dataGridMode;

        public BaseDataListPage() : base() {
        }

        protected abstract string HelpKeyword {
            get;
        }

        protected bool IsDataGridMode {
            get {
                return dataGridMode;
            }
        }

        protected BaseDataList GetBaseControl() {
            IComponent selectedComponent = GetSelectedComponent();

            Debug.Assert(selectedComponent is BaseDataList,
                         "Unexpected component type for BaseDataListPage: " + selectedComponent.GetType().FullName);
            return (BaseDataList)selectedComponent;
        }

        protected BaseDataListDesigner GetBaseDesigner() {
            BaseDataListDesigner controlDesigner = null;

            IComponent selectedComponent = GetSelectedComponent();

            ISite componentSite = selectedComponent.Site;
            Debug.Assert(componentSite != null, "Expected the component to be sited.");

            IDesignerHost designerHost = (IDesignerHost)componentSite.GetService(typeof(IDesignerHost));
            Debug.Assert(designerHost != null, "Expected a designer host.");

            if (designerHost != null) {
                object designer = designerHost.GetDesigner(selectedComponent);

                Debug.Assert(designer != null, "Expected a designer for the selected component");
                Debug.Assert(designer is BaseDataListDesigner, "Expected a designer that derives from BaseDataListDesigner");
                controlDesigner = (BaseDataListDesigner)designer;
            }

            return controlDesigner;
        }

        /// <include file='doc\BaseDataListPage.uex' path='docs/doc[@for="BaseDataListPage.SetComponent"]/*' />
        /// <devdoc>
        ///   Sets the component that is to be edited in the page.
        /// </devdoc>
        public override void SetComponent(IComponent component) {
            base.SetComponent(component);
            dataGridMode = (GetBaseControl() is System.Web.UI.WebControls.DataGrid);
        }

        /// <include file='doc\BaseDataListPage.uex' path='docs/doc[@for="BaseDataListPage.ShowHelp"]/*' />
        public override void ShowHelp() {
            IComponent selectedComponent = GetSelectedComponent();

            ISite componentSite = selectedComponent.Site;
            Debug.Assert(componentSite != null, "Expected the component to be sited.");
 
            IHelpService helpService = (IHelpService)componentSite.GetService(typeof(IHelpService));
            if (helpService != null) {
                helpService.ShowHelpFromKeyword(HelpKeyword);
            }
        }

        /// <include file='doc\BaseDataListPage.uex' path='docs/doc[@for="BaseDataListPage.SupportsHelp"]/*' />
        public override bool SupportsHelp() {
            return true;
        }


        /// <include file='doc\BaseDataListPage.uex' path='docs/doc[@for="BaseDataListPage.DataSourceItem"]/*' />
        /// <devdoc>
        ///   This contains information about a datasource and is used to populate
        ///   the datasource combo. This is used in the General page for a DataList
        ///   and the Data page for a DataGrid.
        /// </devdoc>
        protected class DataSourceItem {
            private IEnumerable runtimeDataSource;
            private string dataSourceName;
            private PropertyDescriptorCollection dataFields;

            public DataSourceItem(string dataSourceName, IEnumerable runtimeDataSource) {
                Debug.Assert(dataSourceName != null, "invalid name for datasource");

                this.runtimeDataSource = runtimeDataSource;
                this.dataSourceName = dataSourceName;
            }

            public PropertyDescriptorCollection Fields {
                get {
                    if (dataFields == null) {
                        IEnumerable ds = RuntimeDataSource;
                        if (ds != null) {
                            dataFields = DesignTimeData.GetDataFields(ds);
                        }
                    }
                    if (dataFields == null) {
                        dataFields = new PropertyDescriptorCollection(null);
                    }
                    return dataFields;
                }
            }

            public virtual bool HasDataMembers {
                get {
                    return false;
                }
            }

            public string Name {
                get {
                    return dataSourceName;
                }
            }

            protected virtual object RuntimeComponent {
                get {
                    return runtimeDataSource;
                }
            }
            
            protected virtual IEnumerable RuntimeDataSource {
                get {
                    return runtimeDataSource;
                }
            }

            protected void ClearFields() {
                dataFields = null;
            }
            
            public bool IsSelectable() {
                object runtimeComp = this.RuntimeComponent;
                Debug.Assert(runtimeComp != null);
                
                // the selected datasource must not be private
                MemberAttributes modifiers = 0;
                PropertyDescriptor modifiersProp = TypeDescriptor.GetProperties(runtimeComp)["Modifiers"];
                if (modifiersProp != null) {
                    modifiers = (MemberAttributes)modifiersProp.GetValue(runtimeComp);
                }

                if ((modifiers & MemberAttributes.AccessMask) == MemberAttributes.Private) {
                    string message = String.Format(SR.GetString(SR.BDL_PrivateDataSource), dataSourceName);
                    string caption = SR.GetString(SR.BDL_PrivateDataSourceT);

                    MessageBox.Show(message, caption, MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
                    return false;
                }

                // ok to select
                return true;
            }

            public override string ToString() {
                return this.Name;
            }
        }

        /// <include file='doc\BaseDataListPage.uex' path='docs/doc[@for="BaseDataListPage.ListSourceDataSourceItem"]/*' />
        /// <devdoc>
        /// </devdoc>
        protected class ListSourceDataSourceItem : DataSourceItem {

            private IListSource runtimeListSource;
            private string currentDataMember;
            private string[] dataMembers;

            public ListSourceDataSourceItem(string dataSourceName, IListSource runtimeListSource) :
                base(dataSourceName, null) {
                Debug.Assert(runtimeListSource != null);
                this.runtimeListSource = runtimeListSource;
            }

            public string CurrentDataMember {
                get {
                    return currentDataMember;
                }
                set {
                    currentDataMember = value;
                    ClearFields();
                }
            }

            public string[] DataMembers {
                get {
                    if (dataMembers == null) {
                        if (HasDataMembers) {
                            dataMembers = DesignTimeData.GetDataMembers(runtimeListSource);
                        }
                        else {
                            dataMembers = new string[0];
                        }
                    }
                    return dataMembers;
                }
            }

            public override bool HasDataMembers {
                get {
                    return runtimeListSource.ContainsListCollection;
                }
            }

            protected override object RuntimeComponent {
                get {
                    return runtimeListSource;
                }
            }

            protected override IEnumerable RuntimeDataSource {
                get {
                    if (HasDataMembers) {
                        return DesignTimeData.GetDataMember(runtimeListSource, currentDataMember);
                    }
                    else {
                        return (IEnumerable)runtimeListSource.GetList();
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\webcontrols\listcontrols\datagridpagingpage.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataGridPagingPage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.WebControls.ListControls {

    using System;
    using System.Design;
    using System.Collections;    
    using System.Globalization;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Drawing;
    using System.Web.UI.Design.Util;
    using System.Web.UI.WebControls;
    using System.Windows.Forms;

    using DataGrid = System.Web.UI.WebControls.DataGrid;

    using CheckBox = System.Windows.Forms.CheckBox;
    using Label = System.Windows.Forms.Label;
    using ListBox = System.Windows.Forms.ListBox;
    using TextBox = System.Windows.Forms.TextBox;

    /// <include file='doc\DataGridPagingPage.uex' path='docs/doc[@for="DataGridPagingPage"]/*' />
    /// <devdoc>
    ///   The Pagin page for the DataGrid control
    /// </devdoc>
    /// <internalonly/>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal sealed class DataGridPagingPage : BaseDataListPage {

        private const int IDX_POS_TOP = 0;
        private const int IDX_POS_BOTTOM = 1;
        private const int IDX_POS_TOPANDBOTTOM = 2;

        private const int IDX_MODE_PAGEBUTTONS = 0;
        private const int IDX_MODE_PAGENUMBERS = 1;

        private CheckBox allowPagingCheck;
        private NumberEdit pageSizeEdit;
        private CheckBox visibleCheck;
        private ComboBox posCombo;
        private ComboBox modeCombo;
        private TextBox nextPageTextEdit;
        private TextBox prevPageTextEdit;
        private NumberEdit pageButtonCountEdit;
        private CheckBox allowCustomPagingCheck;

        /// <include file='doc\DataGridPagingPage.uex' path='docs/doc[@for="DataGridPagingPage.DataGridPagingPage"]/*' />
        /// <devdoc>
        ///   Creates a new instance of DataGridPagingPage.
        /// </devdoc>
        public DataGridPagingPage() : base() {
        }

        /// <include file='doc\DataGridPagingPage.uex' path='docs/doc[@for="DataGridPagingPage.HelpKeyword"]/*' />
        protected override string HelpKeyword {
            get {
                return "net.Asp.DataGridProperties.Paging";
            }
        }

        /// <include file='doc\DataGridPagingPage.uex' path='docs/doc[@for="DataGridPagingPage.InitForm"]/*' />
        /// <devdoc>
        ///    Creates the UI of the page.
        /// </devdoc>
        private void InitForm() {
            GroupLabel pagingGroup = new GroupLabel();
            this.allowPagingCheck = new CheckBox();
            this.allowCustomPagingCheck = new CheckBox();
            Label pageSizeLabel = new Label();
            this.pageSizeEdit = new NumberEdit();
            Label miscLabel = new Label();
            GroupLabel navigationGroup = new GroupLabel();
            this.visibleCheck = new CheckBox();
            Label pagingPosLabel = new Label();
            this.posCombo = new ComboBox();
            Label pagingModeLabel = new Label();
            this.modeCombo = new ComboBox();
            Label nextPageLabel = new Label();
            this.nextPageTextEdit = new TextBox();
            Label prevPageLabel = new Label();
            this.prevPageTextEdit = new TextBox();
            Label pageButtonCountLabel = new Label();
            this.pageButtonCountEdit = new NumberEdit();

            pagingGroup.SetBounds(4, 4, 431, 16);
            pagingGroup.Text = SR.GetString(SR.DGPg_PagingGroup);
            pagingGroup.TabStop = false;
            pagingGroup.TabIndex = 0;

            allowPagingCheck.SetBounds(12, 24, 180, 16);
            allowPagingCheck.Text = SR.GetString(SR.DGPg_AllowPaging);
            allowPagingCheck.TextAlign = ContentAlignment.MiddleLeft;
            allowPagingCheck.TabIndex = 1;
            allowPagingCheck.FlatStyle = FlatStyle.System;
            allowPagingCheck.CheckedChanged += new EventHandler(this.OnCheckChangedAllowPaging);

            allowCustomPagingCheck.SetBounds(220, 24, 180, 16);
            allowCustomPagingCheck.Text = SR.GetString(SR.DGPg_AllowCustomPaging);
            allowCustomPagingCheck.TextAlign = ContentAlignment.MiddleLeft;
            allowCustomPagingCheck.TabIndex = 2;
            allowCustomPagingCheck.FlatStyle = FlatStyle.System;
            allowCustomPagingCheck.CheckedChanged += new EventHandler(this.OnCheckChangedAllowCustomPaging);

            pageSizeLabel.SetBounds(12, 50, 100, 14);
            pageSizeLabel.Text = SR.GetString(SR.DGPg_PageSize);
            pageSizeLabel.TabStop = false;
            pageSizeLabel.TabIndex = 3;

            pageSizeEdit.SetBounds(112, 46, 40, 24);
            pageSizeEdit.TabIndex = 4;
            pageSizeEdit.AllowDecimal = false;
            pageSizeEdit.AllowNegative = false;
            pageSizeEdit.TextChanged += new EventHandler(this.OnTextChangedPageSize);

            miscLabel.SetBounds(158, 50, 80, 14);
            miscLabel.Text = SR.GetString(SR.DGPg_Rows);
            miscLabel.TabStop = false;
            miscLabel.TabIndex = 5;

            navigationGroup.SetBounds(4, 78, 431, 14);
            navigationGroup.Text = SR.GetString(SR.DGPg_NavigationGroup);
            navigationGroup.TabStop = false;
            navigationGroup.TabIndex = 6;

            visibleCheck.SetBounds(12, 100, 260, 16);
            visibleCheck.Text = SR.GetString(SR.DGPg_Visible);
            visibleCheck.TextAlign = ContentAlignment.MiddleLeft;
            visibleCheck.TabIndex = 7;
            visibleCheck.FlatStyle = FlatStyle.System;
            visibleCheck.CheckedChanged += new EventHandler(this.OnCheckChangedVisible);

            pagingPosLabel.SetBounds(12, 122, 150, 14);
            pagingPosLabel.Text = SR.GetString(SR.DGPg_Position);
            pagingPosLabel.TabStop = false;
            pagingPosLabel.TabIndex = 8;

            posCombo.SetBounds(12, 138, 144, 21);
            posCombo.TabIndex = 9;
            posCombo.DropDownStyle = ComboBoxStyle.DropDownList;
            posCombo.Items.AddRange(new object[] {
                                     SR.GetString(SR.DGPg_Pos_Top),
                                     SR.GetString(SR.DGPg_Pos_Bottom),
                                     SR.GetString(SR.DGPg_Pos_TopBottom)
                                 });
            posCombo.SelectedIndexChanged += new EventHandler(this.OnPagerChanged);

            pagingModeLabel.SetBounds(12, 166, 150, 14);
            pagingModeLabel.Text = SR.GetString(SR.DGPg_Mode);
            pagingModeLabel.TabStop = false;
            pagingModeLabel.TabIndex = 10;

            modeCombo.SetBounds(12, 182, 144, 64);
            modeCombo.TabIndex = 11;
            modeCombo.DropDownStyle = ComboBoxStyle.DropDownList;
            modeCombo.Items.AddRange(new object[] {
                                      SR.GetString(SR.DGPg_Mode_Buttons),
                                      SR.GetString(SR.DGPg_Mode_Numbers)
                                  });
            modeCombo.SelectedIndexChanged += new EventHandler(this.OnPagerChanged);

            nextPageLabel.SetBounds(12, 210, 200, 14);
            nextPageLabel.Text = SR.GetString(SR.DGPg_NextPage);
            nextPageLabel.TabStop = false;
            nextPageLabel.TabIndex = 12;

            nextPageTextEdit.SetBounds(12, 226, 144, 24);
            nextPageTextEdit.TabIndex = 13;
            nextPageTextEdit.TextChanged += new EventHandler(this.OnPagerChanged);

            prevPageLabel.SetBounds(220, 210, 200, 14);
            prevPageLabel.Text = SR.GetString(SR.DGPg_PrevPage);
            prevPageLabel.TabStop = false;
            prevPageLabel.TabIndex = 14;

            prevPageTextEdit.SetBounds(220, 226, 140, 24);
            prevPageTextEdit.TabIndex = 15;
            prevPageTextEdit.TextChanged += new EventHandler(this.OnPagerChanged);

            pageButtonCountLabel.SetBounds(12, 254, 200, 14);
            pageButtonCountLabel.Text = SR.GetString(SR.DGPg_ButtonCount);
            pageButtonCountLabel.TabStop = false;
            pageButtonCountLabel.TabIndex = 16;

            pageButtonCountEdit.SetBounds(12, 270, 40, 24);
            pageButtonCountEdit.TabIndex = 17;
            pageButtonCountEdit.AllowDecimal = false;
            pageButtonCountEdit.AllowNegative = false;
            pageButtonCountEdit.TextChanged += new EventHandler(this.OnPagerChanged);

            this.Text = SR.GetString(SR.DGPg_Text);
            this.Size = new Size(464, 300);
            this.CommitOnDeactivate = true;
            this.Icon = new Icon(this.GetType(), "DataGridPagingPage.ico");

            this.Controls.Clear();
            this.Controls.AddRange(new Control[] {
                                    pageButtonCountEdit,
                                    pageButtonCountLabel,
                                    prevPageTextEdit,
                                    prevPageLabel,
                                    nextPageTextEdit,
                                    nextPageLabel,
                                    modeCombo,
                                    pagingModeLabel,
                                    posCombo,
                                    pagingPosLabel,
                                    visibleCheck,
                                    navigationGroup,
                                    miscLabel,
                                    pageSizeEdit,
                                    pageSizeLabel,
                                    allowCustomPagingCheck,
                                    allowPagingCheck,
                                    pagingGroup
                                });
        }

        /// <include file='doc\DataGridPagingPage.uex' path='docs/doc[@for="DataGridPagingPage.InitPage"]/*' />
        /// <devdoc>
        ///   Initializes the page before it can be loaded with the component.
        /// </devdoc>
        private void InitPage() {
            pageSizeEdit.Clear();
            visibleCheck.Checked = false;
            posCombo.SelectedIndex = -1;
            modeCombo.SelectedIndex = -1;
            nextPageTextEdit.Clear();
            prevPageTextEdit.Clear();
        }

        /// <include file='doc\DataGridPagingPage.uex' path='docs/doc[@for="DataGridPagingPage.LoadComponent"]/*' />
        /// <devdoc>
        ///   Loads the component into the page.
        /// </devdoc>
        protected override void LoadComponent() {
            InitPage();

            DataGrid dataGrid = (DataGrid)GetBaseControl();
            DataGridPagerStyle pagerStyle = dataGrid.PagerStyle;

            allowPagingCheck.Checked = dataGrid.AllowPaging;
            allowCustomPagingCheck.Checked = dataGrid.AllowCustomPaging;

            pageSizeEdit.Text = (dataGrid.PageSize).ToString();
            visibleCheck.Checked = pagerStyle.Visible;

            switch (pagerStyle.Mode) {
                case PagerMode.NextPrev:
                    modeCombo.SelectedIndex = IDX_MODE_PAGEBUTTONS;
                    break;
                case PagerMode.NumericPages:
                    modeCombo.SelectedIndex = IDX_MODE_PAGENUMBERS;
                    break;
            }

            switch (pagerStyle.Position) {
                case PagerPosition.Bottom:
                    posCombo.SelectedIndex = IDX_POS_BOTTOM;
                    break;
                case PagerPosition.Top:
                    posCombo.SelectedIndex = IDX_POS_TOP;
                    break;
                case PagerPosition.TopAndBottom:
                    posCombo.SelectedIndex = IDX_POS_TOPANDBOTTOM;
                    break;
            }

            nextPageTextEdit.Text = pagerStyle.NextPageText;
            prevPageTextEdit.Text = pagerStyle.PrevPageText;
            pageButtonCountEdit.Text = (pagerStyle.PageButtonCount).ToString();

            UpdateEnabledVisibleState();
        }

        /// <include file='doc\DataGridPagingPage.uex' path='docs/doc[@for="DataGridPagingPage.OnCheckChangedAllowCustomPaging"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void OnCheckChangedAllowCustomPaging(object source, EventArgs e) {
            if (IsLoading())
                return;
            SetDirty();
        }
        
        /// <include file='doc\DataGridPagingPage.uex' path='docs/doc[@for="DataGridPagingPage.OnCheckChangedAllowPaging"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void OnCheckChangedAllowPaging(object source, EventArgs e) {
            if (IsLoading())
                return;
            SetDirty();
            UpdateEnabledVisibleState();
        }
        
        /// <include file='doc\DataGridPagingPage.uex' path='docs/doc[@for="DataGridPagingPage.OnCheckChangedVisible"]/*' />
        /// <devdoc>
        ///   Handles changes made to the pager visibility.
        /// </devdoc>
        private void OnCheckChangedVisible(object source, EventArgs e) {
            if (IsLoading())
                return;

            SetDirty();
            UpdateEnabledVisibleState();
        }

        /// <include file='doc\DataGridPagingPage.uex' path='docs/doc[@for="DataGridPagingPage.OnPagerChanged"]/*' />
        /// <devdoc>
        ///   Handles changes made to the pager.
        /// </devdoc>
        private void OnPagerChanged(object source, EventArgs e) {
            if (IsLoading())
                return;

            SetDirty();
            if (source == modeCombo)
                UpdateEnabledVisibleState();
        }

        /// <include file='doc\DataGridPagingPage.uex' path='docs/doc[@for="DataGridPagingPage.OnTextChangedPageSize"]/*' />
        /// <devdoc>
        ///   Handles changes made to the page size.
        /// </devdoc>
        private void OnTextChangedPageSize(object source, EventArgs e) {
            if (IsLoading())
                return;

            SetDirty();
            UpdateEnabledVisibleState();
        }

        /// <include file='doc\DataGridPagingPage.uex' path='docs/doc[@for="DataGridPagingPage.SaveComponent"]/*' />
        /// <devdoc>
        ///   Saves the component loaded into the page.
        /// </devdoc>
        protected override void SaveComponent() {
            DataGrid dataGrid = (DataGrid)GetBaseControl();
            DataGridPagerStyle pagerStyle = dataGrid.PagerStyle;

            dataGrid.AllowPaging = allowPagingCheck.Checked;
            dataGrid.AllowCustomPaging = allowCustomPagingCheck.Checked;

            try {
                int pageSize = 10;
                string pageSizeText = pageSizeEdit.Text.Trim();

                if (pageSizeText.Length != 0)
                    pageSize = Int32.Parse(pageSizeText, CultureInfo.InvariantCulture);
                dataGrid.PageSize = pageSize;
            } catch (Exception) {
                pageSizeEdit.Text = (dataGrid.PageSize).ToString();
            }

            pagerStyle.Visible = visibleCheck.Checked;

            switch (modeCombo.SelectedIndex) {
                case IDX_MODE_PAGEBUTTONS:
                    pagerStyle.Mode = PagerMode.NextPrev;
                    break;
                case IDX_MODE_PAGENUMBERS:
                    pagerStyle.Mode = PagerMode.NumericPages;
                    break;
            }

            switch (posCombo.SelectedIndex) {
                case IDX_POS_BOTTOM:
                    pagerStyle.Position = PagerPosition.Bottom;
                    break;
                case IDX_POS_TOP:
                    pagerStyle.Position = PagerPosition.Top;
                    break;
                case IDX_POS_TOPANDBOTTOM:
                    pagerStyle.Position = PagerPosition.TopAndBottom;
                    break;
            }

            pagerStyle.NextPageText = nextPageTextEdit.Text;
            pagerStyle.PrevPageText = prevPageTextEdit.Text;

            try {
                int pageButtonCount = 10;
                string pageButtonCountText = pageButtonCountEdit.Text.Trim();

                if (pageButtonCountText.Length != 0)
                    pageButtonCount = Int32.Parse(pageButtonCountText, CultureInfo.InvariantCulture);
                pagerStyle.PageButtonCount = pageButtonCount;
            } catch(Exception) {
                pageButtonCountEdit.Text = (pagerStyle.PageButtonCount).ToString();
            }
        }

        /// <include file='doc\DataGridPagingPage.uex' path='docs/doc[@for="DataGridPagingPage.SetComponent"]/*' />
        /// <devdoc>
        ///   Sets the component that is to be edited in the page.
        /// </devdoc>
        public override void SetComponent(IComponent component) {
            base.SetComponent(component);
            InitForm();
        }

        /// <include file='doc\DataGridPagingPage.uex' path='docs/doc[@for="DataGridPagingPage.UpdateEnabledVisibleState"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void UpdateEnabledVisibleState() {
            int pageSizeValue = 0;

            string pageSize = pageSizeEdit.Text.Trim();
            if (pageSize.Length != 0) {
                try {
                    pageSizeValue = Int32.Parse(pageSize, CultureInfo.InvariantCulture);
                } catch (Exception) {
                }

                Debug.Assert(pageSizeValue >= 0,
                             "Page size should have been restricted to a number greater than 0.");
            }

            bool pagingAllowed = allowPagingCheck.Checked;
            bool pagingEnabled = pagingAllowed && (pageSizeValue != 0);
            bool pagerVisible = visibleCheck.Checked;
            bool nextPrevButtonMode = modeCombo.SelectedIndex == IDX_MODE_PAGEBUTTONS;

            allowCustomPagingCheck.Enabled = pagingAllowed;
            pageSizeEdit.Enabled = pagingAllowed;

            visibleCheck.Enabled = pagingEnabled;
            posCombo.Enabled = pagingEnabled && pagerVisible;
            modeCombo.Enabled = pagingEnabled && pagerVisible;
            nextPageTextEdit.Enabled = pagingEnabled && pagerVisible && nextPrevButtonMode;
            prevPageTextEdit.Enabled = pagingEnabled && pagerVisible && nextPrevButtonMode;
            pageButtonCountEdit.Enabled = pagingEnabled && pagerVisible && !nextPrevButtonMode;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\webcontrols\listcontrols\datalistgeneralpage.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataListGeneralPage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.WebControls.ListControls {

    using System;
    using System.Design;
    using System.Collections;
    using System.Globalization;
    using System.ComponentModel;
    using System.Data;
    using System.Diagnostics;
    using System.Drawing;
    using System.Web.UI;
    using System.Web.UI.Design.Util;
    using System.Web.UI.WebControls;
    using System.Windows.Forms;

    using DataBinding = System.Web.UI.DataBinding;    
    using DataList = System.Web.UI.WebControls.DataList;

    using CheckBox = System.Windows.Forms.CheckBox;
    using Control = System.Windows.Forms.Control;
    using Label = System.Windows.Forms.Label;
    using PropertyDescriptor = System.ComponentModel.PropertyDescriptor;

    /// <include file='doc\DataListGeneralPage.uex' path='docs/doc[@for="DataListGeneralPage"]/*' />
    /// <devdoc>
    ///   The General page for the DataList control.
    /// </devdoc>
    /// <internalonly/>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal sealed class DataListGeneralPage : BaseDataListPage {

        private const int IDX_DIR_HORIZONTAL = 0;
        private const int IDX_DIR_VERTICAL = 1;

        private const int IDX_MODE_TABLE = 0;
        private const int IDX_MODE_FLOW = 1;

        private UnsettableComboBox dataSourceCombo;
        private UnsettableComboBox dataMemberCombo;
        private UnsettableComboBox dataKeyFieldCombo;
        private CheckBox showHeaderCheck;
        private CheckBox showFooterCheck;
        private NumberEdit repeatColumnsEdit;
        private ComboBox repeatDirectionCombo;
        private ComboBox repeatLayoutCombo;
        private CheckBox extractRowsCheck;

        private DataSourceItem currentDataSource;
        private bool dataSourceDirty;

        /// <include file='doc\DataListGeneralPage.uex' path='docs/doc[@for="DataListGeneralPage.DataListGeneralPage"]/*' />
        /// <devdoc>
        ///   Creates a new instance of DataListGeneralPage.
        /// </devdoc>
        public DataListGeneralPage() : base() {
        }

        /// <include file='doc\DataListGeneralPage.uex' path='docs/doc[@for="DataListGeneralPage.HelpKeyword"]/*' />
        protected override string HelpKeyword {
            get {
                return "net.Asp.DataListProperties.General";
            }
        }

        /// <include file='doc\DataListGeneralPage.uex' path='docs/doc[@for="DataListGeneralPage.InitForm"]/*' />
        /// <devdoc>
        ///   Initializes the UI of the form.
        /// </devdoc>
        private void InitForm() {
            GroupLabel dataGroup = new GroupLabel();
            Label dataSourceLabel = new Label();
            this.dataSourceCombo = new UnsettableComboBox();
            Label dataMemberLabel = new Label();
            this.dataMemberCombo = new UnsettableComboBox();
            Label dataKeyFieldLabel = new Label();
            this.dataKeyFieldCombo = new UnsettableComboBox();
            GroupLabel headerFooterGroup = new GroupLabel();
            this.showHeaderCheck = new CheckBox();
            this.showFooterCheck = new CheckBox();
            GroupLabel repeatGroup = new GroupLabel();
            Label repeatColumnsLabel = new Label();
            this.repeatColumnsEdit = new NumberEdit();
            Label repeatDirectionLabel = new Label();
            this.repeatDirectionCombo = new ComboBox();
            Label repeatLayoutLabel = new Label();
            this.repeatLayoutCombo = new ComboBox();
            GroupLabel templatesGroup = new GroupLabel();
            this.extractRowsCheck = new CheckBox();

            dataGroup.SetBounds(4, 4, 360, 16);
            dataGroup.Text = SR.GetString(SR.DLGen_DataGroup);
            dataGroup.TabIndex = 0;
            dataGroup.TabStop = false;

            dataSourceLabel.SetBounds(8, 24, 170, 16);
            dataSourceLabel.Text = SR.GetString(SR.DLGen_DataSource);
            dataSourceLabel.TabStop = false;
            dataSourceLabel.TabIndex = 1;

            dataSourceCombo.SetBounds(8, 40, 140, 21);
            dataSourceCombo.DropDownStyle = ComboBoxStyle.DropDownList;
            dataSourceCombo.Sorted = true;
            dataSourceCombo.TabIndex = 2;
            dataSourceCombo.NotSetText = SR.GetString(SR.DLGen_DSUnbound);
            dataSourceCombo.SelectedIndexChanged += new EventHandler(this.OnSelChangedDataSource);

            dataMemberLabel.SetBounds(184, 24, 170, 16);
            dataMemberLabel.Text = SR.GetString(SR.DLGen_DataMember);
            dataMemberLabel.TabStop = false;
            dataMemberLabel.TabIndex = 3;

            dataMemberCombo.SetBounds(184, 40, 140, 21);
            dataMemberCombo.DropDownStyle = ComboBoxStyle.DropDownList;
            dataMemberCombo.Sorted = true;
            dataMemberCombo.TabIndex = 4;
            dataMemberCombo.NotSetText = SR.GetString(SR.DLGen_DMNone);
            dataMemberCombo.SelectedIndexChanged += new EventHandler(this.OnSelChangedDataMember);
            
            dataKeyFieldLabel.SetBounds(8, 66, 170, 16);
            dataKeyFieldLabel.Text = SR.GetString(SR.DLGen_DataKey);
            dataKeyFieldLabel.TabStop = false;
            dataKeyFieldLabel.TabIndex = 4;

            dataKeyFieldCombo.SetBounds(8, 82, 140, 21);
            dataKeyFieldCombo.DropDownStyle = ComboBoxStyle.DropDownList;
            dataKeyFieldCombo.Sorted = true;
            dataKeyFieldCombo.TabIndex = 5;
            dataKeyFieldCombo.NotSetText = SR.GetString(SR.DLGen_DKNone);
            dataKeyFieldCombo.SelectedIndexChanged += new EventHandler(this.OnSelChangedDataKeyField);

            headerFooterGroup.SetBounds(4, 108, 360, 16);
            headerFooterGroup.Text = SR.GetString(SR.DLGen_HeaderFooterGroup);
            headerFooterGroup.TabIndex = 6;
            headerFooterGroup.TabStop = false;

            showHeaderCheck.SetBounds(8, 128, 170, 16);
            showHeaderCheck.TabIndex = 7;
            showHeaderCheck.Text = SR.GetString(SR.DLGen_ShowHeader);
            showHeaderCheck.TextAlign = ContentAlignment.MiddleLeft;
            showHeaderCheck.FlatStyle = FlatStyle.System;
            showHeaderCheck.CheckedChanged += new EventHandler(this.OnCheckChangedShowHeader);

            showFooterCheck.SetBounds(8, 146, 170, 16);
            showFooterCheck.TabIndex = 8;
            showFooterCheck.Text = SR.GetString(SR.DLGen_ShowFooter);
            showFooterCheck.TextAlign = ContentAlignment.MiddleLeft;
            showFooterCheck.FlatStyle = FlatStyle.System;
            showFooterCheck.CheckedChanged += new EventHandler(this.OnCheckChangedShowFooter);

            repeatGroup.SetBounds(4, 172, 360, 16);
            repeatGroup.Text = SR.GetString(SR.DLGen_RepeatLayoutGroup);
            repeatGroup.TabIndex = 9;
            repeatGroup.TabStop = false;

            repeatColumnsLabel.SetBounds(8, 192, 106, 16);
            repeatColumnsLabel.Text = SR.GetString(SR.DLGen_RepeatColumns);
            repeatColumnsLabel.TabStop = false;
            repeatColumnsLabel.TabIndex = 10;

            repeatColumnsEdit.SetBounds(112, 188, 40, 21);
            repeatColumnsEdit.AllowDecimal = false;
            repeatColumnsEdit.AllowNegative = false;
            repeatColumnsEdit.TabIndex = 11;
            repeatColumnsEdit.TextChanged += new EventHandler(this.OnChangedRepeatProps);

            repeatDirectionLabel.SetBounds(8, 217, 106, 16);
            repeatDirectionLabel.Text = SR.GetString(SR.DLGen_RepeatDirection);
            repeatDirectionLabel.TabStop = false;
            repeatDirectionLabel.TabIndex = 12;

            repeatDirectionCombo.SetBounds(112, 213, 140, 56);
            repeatDirectionCombo.DropDownStyle = ComboBoxStyle.DropDownList;
            repeatDirectionCombo.Items.AddRange(new object[] {
                                                 SR.GetString(SR.DLGen_RD_Horz),
                                                 SR.GetString(SR.DLGen_RD_Vert)
                                             });
            repeatDirectionCombo.TabIndex = 13;
            repeatDirectionCombo.SelectedIndexChanged += new EventHandler(this.OnChangedRepeatProps);

            repeatLayoutLabel.SetBounds(8, 242, 106, 16);
            repeatLayoutLabel.Text = SR.GetString(SR.DLGen_RepeatLayout);
            repeatLayoutLabel.TabStop = false;
            repeatLayoutLabel.TabIndex = 14;

            repeatLayoutCombo.SetBounds(112, 238, 140, 21);
            repeatLayoutCombo.DropDownStyle = ComboBoxStyle.DropDownList;
            repeatLayoutCombo.Items.AddRange(new object[] {
                                              SR.GetString(SR.DLGen_RL_Table),
                                              SR.GetString(SR.DLGen_RL_Flow)
                                          });
            repeatLayoutCombo.TabIndex = 15;
            repeatLayoutCombo.SelectedIndexChanged += new EventHandler(this.OnChangedRepeatProps);

            templatesGroup.SetBounds(4, 266, 360, 16);
            templatesGroup.Text = "Templates";
            templatesGroup.TabIndex = 16;
            templatesGroup.TabStop = false;
            templatesGroup.Visible = false;

            extractRowsCheck.SetBounds(8, 286, 260, 16);
            extractRowsCheck.Text = "Extract rows from Tables in template content";
            extractRowsCheck.TabIndex = 17;
            extractRowsCheck.Visible = false;
            extractRowsCheck.FlatStyle = FlatStyle.System;
            extractRowsCheck.CheckedChanged += new EventHandler(this.OnCheckChangedExtractRows);

            this.Text = SR.GetString(SR.DLGen_Text);
            this.Size = new Size(368, 280);
            this.CommitOnDeactivate = true;
            this.Icon = new Icon(this.GetType(), "DataListGeneralPage.ico");

            Controls.Clear();
            Controls.AddRange(new Control[] {
                               extractRowsCheck,
                               templatesGroup,
                               repeatLayoutCombo,
                               repeatLayoutLabel,
                               repeatDirectionCombo,
                               repeatDirectionLabel,
                               repeatColumnsEdit,
                               repeatColumnsLabel,
                               repeatGroup,
                               showFooterCheck,
                               showHeaderCheck,
                               headerFooterGroup,
                               dataKeyFieldCombo,
                               dataKeyFieldLabel,
                               dataMemberCombo,
                               dataMemberLabel,
                               dataSourceCombo,
                               dataSourceLabel,
                               dataGroup
                           });
        }

        /// <include file='doc\DataListGeneralPage.uex' path='docs/doc[@for="DataListGeneralPage.InitPage"]/*' />
        /// <devdoc>
        ///   Initializes the page before it can be loaded with the component.
        /// </devdoc>
        private void InitPage() {
            dataSourceCombo.SelectedIndex = -1;
            dataSourceCombo.Items.Clear();
            currentDataSource = null;
            dataMemberCombo.SelectedIndex = -1;
            dataMemberCombo.Items.Clear();
            dataKeyFieldCombo.SelectedIndex = -1;
            dataKeyFieldCombo.Items.Clear();
            dataSourceDirty = false;

            showHeaderCheck.Checked = false;
            showFooterCheck.Checked = false;

            repeatColumnsEdit.Clear();
            repeatDirectionCombo.SelectedIndex = -1;
            repeatLayoutCombo.SelectedIndex = -1;

            extractRowsCheck.Checked = false;
        }

        /// <include file='doc\DataListGeneralPage.uex' path='docs/doc[@for="DataListGeneralPage.LoadComponent"]/*' />
        /// <devdoc>
        ///   Loads the component into the page.
        /// </devdoc>
        protected override void LoadComponent() {
            InitPage();

            DataList dataList = (DataList)GetBaseControl();

            LoadDataSourceItems();

            showHeaderCheck.Checked = dataList.ShowHeader;
            showFooterCheck.Checked = dataList.ShowFooter;

            repeatColumnsEdit.Text = (dataList.RepeatColumns).ToString();

            switch (dataList.RepeatDirection) {
                case RepeatDirection.Horizontal:
                    repeatDirectionCombo.SelectedIndex = IDX_DIR_HORIZONTAL;
                    break;
                case RepeatDirection.Vertical:
                    repeatDirectionCombo.SelectedIndex = IDX_DIR_VERTICAL;
                    break;
            }

            switch (dataList.RepeatLayout) {
                case RepeatLayout.Table:
                    repeatLayoutCombo.SelectedIndex = IDX_MODE_TABLE;
                    break;
                case RepeatLayout.Flow:
                    repeatLayoutCombo.SelectedIndex = IDX_MODE_FLOW;
                    break;
            }

            extractRowsCheck.Checked = dataList.ExtractTemplateRows;

            if (dataSourceCombo.Items.Count > 0) {
                DataListDesigner dataListDesigner = (DataListDesigner)GetBaseDesigner();
                string dataSourceValue = dataListDesigner.DataSource;

                if (dataSourceValue != null) {
                    int dataSourcesAvailable = dataSourceCombo.Items.Count;
                    for (int j = 1; j < dataSourcesAvailable; j++) {
                        DataSourceItem dataSourceItem =
                            (DataSourceItem)dataSourceCombo.Items[j];

                        if (String.Compare(dataSourceItem.Name, dataSourceValue, true, CultureInfo.InvariantCulture) == 0) {
                            dataSourceCombo.SelectedIndex = j;
                            currentDataSource = dataSourceItem;
                            LoadDataMembers();

                            if (currentDataSource is ListSourceDataSourceItem) {
                                string dataMember = dataListDesigner.DataMember;
                                dataMemberCombo.SelectedIndex = dataMemberCombo.FindStringExact(dataMember);

                                if (dataMemberCombo.IsSet()) {
                                    ((ListSourceDataSourceItem)currentDataSource).CurrentDataMember = dataMember;
                                }
                            }

                            LoadDataSourceFields();

                            break;
                        }
                    }
                }
            }

            string dataKeyField = dataList.DataKeyField;
            if (dataKeyField.Length != 0) {
                int fieldIndex = dataKeyFieldCombo.FindStringExact(dataKeyField);
                dataKeyFieldCombo.SelectedIndex = fieldIndex;
            }

            UpdateEnabledVisibleState();
        }

        /// <include file='doc\DataListGeneralPage.uex' path='docs/doc[@for="DataListGeneralPage.LoadDataMembers"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void LoadDataMembers() {
            EnterLoadingMode();

            dataMemberCombo.SelectedIndex = -1;
            dataMemberCombo.Items.Clear();
            dataMemberCombo.EnsureNotSetItem();

            if ((currentDataSource != null) && (currentDataSource is ListSourceDataSourceItem)) {
                string[] dataMembers = ((ListSourceDataSourceItem)currentDataSource).DataMembers;

                for (int i = 0; i < dataMembers.Length; i++) {
                    dataMemberCombo.AddItem(dataMembers[i]);
                }
            }

            ExitLoadingMode();
        }

        /// <include file='doc\DataListGeneralPage.uex' path='docs/doc[@for="DataListGeneralPage.LoadDataSourceFields"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void LoadDataSourceFields() {
            EnterLoadingMode();

            dataKeyFieldCombo.SelectedIndex = -1;
            dataKeyFieldCombo.Items.Clear();
            dataKeyFieldCombo.EnsureNotSetItem();

            if (currentDataSource != null) {
                PropertyDescriptorCollection fields = currentDataSource.Fields;

                if (fields != null) {
                    IEnumerator fieldEnum = fields.GetEnumerator();
                    while (fieldEnum.MoveNext()) {
                        PropertyDescriptor fieldDesc = (PropertyDescriptor)fieldEnum.Current;

                        if (BaseDataList.IsBindableType(fieldDesc.PropertyType)) {
                            dataKeyFieldCombo.AddItem(fieldDesc.Name);
                        }
                    }
                }
            }

            ExitLoadingMode();
        }

        /// <include file='doc\DataListGeneralPage.uex' path='docs/doc[@for="DataListGeneralPage.LoadDataSourceItems"]/*' />
        /// <devdoc>
        ///   Loads the list of available IEnumerable components
        /// </devdoc>
        private void LoadDataSourceItems() {
            dataSourceCombo.EnsureNotSetItem();

            ISite thisSite = GetSelectedComponent().Site;

            if (thisSite != null) {
                IContainer container = (IContainer)thisSite.GetService(typeof(IContainer));

                if (container != null) {
                    ComponentCollection allComponents = container.Components;
                    if (allComponents != null) {
                        foreach (IComponent comp in (IEnumerable)allComponents) {
                            if ((comp is IEnumerable) || (comp is IListSource)) {
                                // must have a valid site and a name
                                ISite componentSite = comp.Site;
                                if ((componentSite == null) || (componentSite.Name == null) ||
                                    (componentSite.Name.Length == 0))
                                    continue;

                                DataSourceItem dsItem;
                                if (comp is IListSource) {
                                    // an IListSource
                                    IListSource listSource = (IListSource)comp;
                                    dsItem = new ListSourceDataSourceItem(componentSite.Name, listSource);
                                }
                                else {
                                    // found a IEnumerable
                                    IEnumerable dataSource = (IEnumerable)comp;
                                    dsItem = new DataSourceItem(componentSite.Name, dataSource);
                                }
                                dataSourceCombo.AddItem(dsItem);
                            }
                        }
                    }
                }
            }
        }

        /// <include file='doc\DataListGeneralPage.uex' path='docs/doc[@for="DataListGeneralPage.OnCheckChangedExtractRows"]/*' />
        /// <devdoc>
        ///   Handles changes to the extract rows checkbox
        /// </devdoc>
        private void OnCheckChangedExtractRows(object source, EventArgs e) {
            if (IsLoading())
                return;
            SetDirty();
        }
        
        /// <include file='doc\DataListGeneralPage.uex' path='docs/doc[@for="DataListGeneralPage.OnChangedRepeatProps"]/*' />
        /// <devdoc>
        ///   Handles changes to the different repeater properties
        /// </devdoc>
        private void OnChangedRepeatProps(object source, EventArgs e) {
            if (IsLoading())
                return;
            SetDirty();
        }

        /// <include file='doc\DataListGeneralPage.uex' path='docs/doc[@for="DataListGeneralPage.OnCheckChangedShowHeader"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void OnCheckChangedShowHeader(object source, EventArgs e) {
            if (IsLoading())
                return;
            SetDirty();
        }

        /// <include file='doc\DataListGeneralPage.uex' path='docs/doc[@for="DataListGeneralPage.OnCheckChangedShowFooter"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void OnCheckChangedShowFooter(object source, EventArgs e) {
            if (IsLoading())
                return;
            SetDirty();
        }

        /// <include file='doc\DataListGeneralPage.uex' path='docs/doc[@for="DataListGeneralPage.OnSelChangedDataKeyField"]/*' />
        /// <devdoc>
        ///   Handles changes in the datasource selection.
        /// </devdoc>
        private void OnSelChangedDataKeyField(object source, EventArgs e) {
            if (IsLoading())
                return;
            SetDirty();
        }

        /// <include file='doc\DataListGeneralPage.uex' path='docs/doc[@for="DataListGeneralPage.OnSelChangedDataMember"]/*' />
        /// <devdoc>
        ///   Handles changes in the datamember selection
        /// </devdoc>
        private void OnSelChangedDataMember(object source, EventArgs e) {
            if (IsLoading())
                return;

            string newDataMember = null;
            if (dataMemberCombo.IsSet())
                newDataMember = (string)dataMemberCombo.SelectedItem;

            Debug.Assert((currentDataSource != null) && (currentDataSource is ListSourceDataSourceItem));
            ((ListSourceDataSourceItem)currentDataSource).CurrentDataMember = newDataMember;

            LoadDataSourceFields();
            dataSourceDirty = true;

            SetDirty();
            UpdateEnabledVisibleState();
        }

        /// <include file='doc\DataListGeneralPage.uex' path='docs/doc[@for="DataListGeneralPage.OnSelChangedDataSource"]/*' />
        /// <devdoc>
        ///   Handles changes in the datasource selection.
        /// </devdoc>
        private void OnSelChangedDataSource(object source, EventArgs e) {
            if (IsLoading())
                return;

            DataSourceItem newDataSource = null;

            if (dataSourceCombo.IsSet())
                newDataSource = (DataSourceItem)dataSourceCombo.SelectedItem;

            if (newDataSource != null) {
                if (newDataSource.IsSelectable() == false) {
                    EnterLoadingMode();
                    if (currentDataSource == null) {
                        dataSourceCombo.SelectedIndex = -1;
                    }
                    else {
                        dataSourceCombo.SelectedItem = currentDataSource;
                    }
                    ExitLoadingMode();
                    return;
                }
            }

            currentDataSource = newDataSource;
            if (currentDataSource is ListSourceDataSourceItem) {
                ((ListSourceDataSourceItem)currentDataSource).CurrentDataMember = null;
            }
            
            LoadDataMembers();
            LoadDataSourceFields();
            dataSourceDirty = true;

            SetDirty();
            UpdateEnabledVisibleState();
        }

        /// <include file='doc\DataListGeneralPage.uex' path='docs/doc[@for="DataListGeneralPage.SaveComponent"]/*' />
        /// <devdoc>
        ///   Saves the component loaded into the page.
        /// </devdoc>
        protected override void SaveComponent() {
            DataList dataList = (DataList)GetBaseControl();

            dataList.ShowHeader = showHeaderCheck.Checked;
            dataList.ShowFooter = showFooterCheck.Checked;

            try {
                int repeatColumns = 1;
                string repeatColumnsValue = repeatColumnsEdit.Text.Trim();
                if (repeatColumnsValue.Length != 0)
                    repeatColumns = Int32.Parse(repeatColumnsValue, CultureInfo.InvariantCulture);
                dataList.RepeatColumns = repeatColumns;
            } catch (Exception) {
                repeatColumnsEdit.Text = (dataList.RepeatColumns).ToString();
            }

            switch (repeatDirectionCombo.SelectedIndex) {
                case IDX_DIR_HORIZONTAL:
                    dataList.RepeatDirection = RepeatDirection.Horizontal;
                    break;
                case IDX_DIR_VERTICAL:
                    dataList.RepeatDirection = RepeatDirection.Vertical;
                    break;
            }

            switch (repeatLayoutCombo.SelectedIndex) {
                case IDX_MODE_TABLE:
                    dataList.RepeatLayout = RepeatLayout.Table;
                    break;
                case IDX_MODE_FLOW:
                    dataList.RepeatLayout = RepeatLayout.Flow;
                    break;
            }

            dataList.ExtractTemplateRows = extractRowsCheck.Checked;

            string dataKeyField = String.Empty;
            if (dataKeyFieldCombo.IsSet())
                dataKeyField = (string)dataKeyFieldCombo.SelectedItem;
            dataList.DataKeyField = dataKeyField;

            if (dataSourceDirty) {
                DataListDesigner dataListDesigner = (DataListDesigner)GetBaseDesigner();

                // save the datasource as a binding on the control
                DataBindingCollection dataBindings = dataListDesigner.DataBindings;

                if (currentDataSource == null) {
                    dataListDesigner.DataSource = String.Empty;
                    dataListDesigner.DataMember = String.Empty;
                }
                else {
                    dataListDesigner.DataSource = currentDataSource.ToString();
                    if (dataMemberCombo.IsSet()) {
                        dataListDesigner.DataMember = (string)dataMemberCombo.SelectedItem;
                    }
                    else {
                        dataListDesigner.DataMember = String.Empty;
                    }
                }

                dataListDesigner.OnDataSourceChanged();
            }
        }

        /// <include file='doc\DataListGeneralPage.uex' path='docs/doc[@for="DataListGeneralPage.SetComponent"]/*' />
        /// <devdoc>
        ///   Sets the component that is to be edited in the page.
        /// </devdoc>
        public override void SetComponent(IComponent component) {
            base.SetComponent(component);
            InitForm();
        }

        /// <include file='doc\DataListGeneralPage.uex' path='docs/doc[@for="DataListGeneralPage.UpdateEnabledVisibleState"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void UpdateEnabledVisibleState() {
            bool dataSourceSelected = (currentDataSource != null);

            dataMemberCombo.Enabled = (dataSourceSelected && currentDataSource.HasDataMembers);
            dataKeyFieldCombo.Enabled = dataSourceSelected;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\webcontrols\listcontrols\datagridgeneralpage.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataGridGeneralPage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.WebControls.ListControls {

    using System;
    using System.Design;
    using System.Collections;
    using System.ComponentModel;
    using System.Data;
    using System.Diagnostics;
    using System.Drawing;
    using System.Web.UI;
    using System.Web.UI.Design.Util;
    using System.Web.UI.WebControls;
    using System.Windows.Forms;

    using WebControls = System.Web.UI.WebControls;
    using DataBinding = System.Web.UI.DataBinding;    
    using DataGrid = System.Web.UI.WebControls.DataGrid;

    using CheckBox = System.Windows.Forms.CheckBox;
    using Control = System.Windows.Forms.Control;
    using Label = System.Windows.Forms.Label;
    using PropertyDescriptor = System.ComponentModel.PropertyDescriptor;
    using System.Globalization;
    
    /// <include file='doc\DataGridGeneralPage.uex' path='docs/doc[@for="DataGridGeneralPage"]/*' />
    /// <devdoc>
    ///   The General page for the DataGrid control.
    /// </devdoc>
    /// <internalonly/>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal sealed class DataGridGeneralPage : BaseDataListPage {

        private CheckBox showHeaderCheck;
        private CheckBox showFooterCheck;
        private CheckBox allowSortingCheck;
        private UnsettableComboBox dataSourceCombo;
        private UnsettableComboBox dataMemberCombo;
        private UnsettableComboBox dataKeyFieldCombo;
        private Label columnInfoLabel;

        private DataSourceItem currentDataSource;
        private bool dataSourceDirty;

        /// <include file='doc\DataGridGeneralPage.uex' path='docs/doc[@for="DataGridGeneralPage.DataGridGeneralPage"]/*' />
        /// <devdoc>
        ///   Creates a new instance of DataGridGeneralPage.
        /// </devdoc>
        public DataGridGeneralPage() : base() {
        }

        /// <include file='doc\DataGridGeneralPage.uex' path='docs/doc[@for="DataGridGeneralPage.HelpKeyword"]/*' />
        protected override string HelpKeyword {
            get {
                return "net.Asp.DataGridProperties.General";
            }
        }

        /// <include file='doc\DataGridGeneralPage.uex' path='docs/doc[@for="DataGridGeneralPage.InitForm"]/*' />
        /// <devdoc>
        ///   Initializes the UI of the form.
        /// </devdoc>
        private void InitForm() {
            GroupLabel dataGroup = new GroupLabel();
            Label dataSourceLabel = new Label();
            this.dataSourceCombo = new UnsettableComboBox();
            Label dataMemberLabel = new Label();
            this.dataMemberCombo = new UnsettableComboBox();
            Label dataKeyFieldLabel = new Label();
            this.dataKeyFieldCombo = new UnsettableComboBox();
            this.columnInfoLabel = new Label();
            GroupLabel headerFooterGroup = new GroupLabel();
            this.showHeaderCheck = new CheckBox();
            this.showFooterCheck = new CheckBox();
            GroupLabel behaviorGroup = new GroupLabel();
            this.allowSortingCheck = new CheckBox();

            dataGroup.SetBounds(4, 4, 431, 16);
            dataGroup.Text = SR.GetString(SR.DGGen_DataGroup);
            dataGroup.TabIndex = 0;
            dataGroup.TabStop = false;

            dataSourceLabel.SetBounds(12, 24, 170, 16);
            dataSourceLabel.Text = SR.GetString(SR.DGGen_DataSource);
            dataSourceLabel.TabStop = false;
            dataSourceLabel.TabIndex = 1;

            dataSourceCombo.SetBounds(12, 40, 140, 64);
            dataSourceCombo.DropDownStyle = ComboBoxStyle.DropDownList;
            dataSourceCombo.Sorted = true;
            dataSourceCombo.TabIndex = 2;
            dataSourceCombo.NotSetText = SR.GetString(SR.DGGen_DSUnbound);
            dataSourceCombo.SelectedIndexChanged += new EventHandler(this.OnSelChangedDataSource);

            dataMemberLabel.SetBounds(184, 24, 170, 16);
            dataMemberLabel.Text = SR.GetString(SR.DGGen_DataMember);
            dataMemberLabel.TabStop = false;
            dataMemberLabel.TabIndex = 3;

            dataMemberCombo.SetBounds(184, 40, 140, 21);
            dataMemberCombo.DropDownStyle = ComboBoxStyle.DropDownList;
            dataMemberCombo.Sorted = true;
            dataMemberCombo.TabIndex = 4;
            dataMemberCombo.NotSetText = SR.GetString(SR.DGGen_DMNone);
            dataMemberCombo.SelectedIndexChanged += new EventHandler(this.OnSelChangedDataMember);

            dataKeyFieldLabel.SetBounds(12, 66, 170, 16);
            dataKeyFieldLabel.Text = SR.GetString(SR.DGGen_DataKey);
            dataKeyFieldLabel.TabStop = false;
            dataKeyFieldLabel.TabIndex = 5;

            dataKeyFieldCombo.SetBounds(12, 82, 140, 64);
            dataKeyFieldCombo.DropDownStyle = ComboBoxStyle.DropDownList;
            dataKeyFieldCombo.Sorted = true;
            dataKeyFieldCombo.TabIndex = 6;
            dataKeyFieldCombo.NotSetText = SR.GetString(SR.DGGen_DKNone);
            dataKeyFieldCombo.SelectedIndexChanged += new EventHandler(this.OnSelChangedDataKeyField);

            columnInfoLabel.SetBounds(8, 112, 420, 48);
            columnInfoLabel.TabStop = false;
            columnInfoLabel.TabIndex = 7;

            headerFooterGroup.SetBounds(4, 162, 431, 16);
            headerFooterGroup.Text = SR.GetString(SR.DGGen_HeaderFooterGroup);
            headerFooterGroup.TabIndex = 8;
            headerFooterGroup.TabStop = false;

            showHeaderCheck.SetBounds(12, 182, 160, 16);
            showHeaderCheck.TabIndex = 9;
            showHeaderCheck.Text = SR.GetString(SR.DGGen_ShowHeader);
            showHeaderCheck.TextAlign = ContentAlignment.MiddleLeft;
            showHeaderCheck.FlatStyle = FlatStyle.System;
            showHeaderCheck.CheckedChanged += new EventHandler(this.OnCheckChangedShowHeader);

            showFooterCheck.SetBounds(12, 202, 160, 16);
            showFooterCheck.TabIndex = 10;
            showFooterCheck.Text = SR.GetString(SR.DGGen_ShowFooter);
            showFooterCheck.TextAlign = ContentAlignment.MiddleLeft;
            showFooterCheck.FlatStyle = FlatStyle.System;
            showFooterCheck.CheckedChanged += new EventHandler(this.OnCheckChangedShowFooter);

            behaviorGroup.SetBounds(4, 228, 431, 16);
            behaviorGroup.Text = SR.GetString(SR.DGGen_BehaviorGroup);
            behaviorGroup.TabIndex = 11;
            behaviorGroup.TabStop = false;

            allowSortingCheck.SetBounds(12, 246, 160, 16);
            allowSortingCheck.Text = SR.GetString(SR.DGGen_AllowSorting);
            allowSortingCheck.TabIndex = 12;
            allowSortingCheck.TextAlign = ContentAlignment.MiddleLeft;
            allowSortingCheck.FlatStyle = FlatStyle.System;
            allowSortingCheck.CheckedChanged += new EventHandler(this.OnCheckChangedAllowSorting);

            this.Text = SR.GetString(SR.DGGen_Text);
            this.Size = new Size(464, 272);
            this.CommitOnDeactivate = true;
            this.Icon = new Icon(this.GetType(), "DataGridGeneralPage.ico");

            Controls.Clear();
            Controls.AddRange(new Control[] {
                               allowSortingCheck,
                               behaviorGroup,
                               showFooterCheck,
                               showHeaderCheck,
                               headerFooterGroup,
                               columnInfoLabel,
                               dataKeyFieldCombo,
                               dataKeyFieldLabel,
                               dataMemberCombo,
                               dataMemberLabel,
                               dataSourceCombo,
                               dataSourceLabel,
                               dataGroup
                           });
        }

        /// <include file='doc\DataGridGeneralPage.uex' path='docs/doc[@for="DataGridGeneralPage.InitPage"]/*' />
        /// <devdoc>
        ///   Initializes the page before it can be loaded with the component.
        /// </devdoc>
        private void InitPage() {
            dataSourceCombo.SelectedIndex = -1;
            dataSourceCombo.Items.Clear();
            currentDataSource = null;
            dataMemberCombo.SelectedIndex = -1;
            dataMemberCombo.Items.Clear();
            dataKeyFieldCombo.SelectedIndex = -1;
            dataKeyFieldCombo.Items.Clear();
            dataSourceDirty = false;

            showHeaderCheck.Checked = false;
            showFooterCheck.Checked = false;
            allowSortingCheck.Checked = false;
        }

        /// <include file='doc\DataGridGeneralPage.uex' path='docs/doc[@for="DataGridGeneralPage.LoadComponent"]/*' />
        /// <devdoc>
        ///   Loads the component into the page.
        /// </devdoc>
        protected override void LoadComponent() {
            InitPage();

            DataGrid dataGrid = (DataGrid)GetBaseControl();

            LoadDataSourceItems();

            showHeaderCheck.Checked = dataGrid.ShowHeader;
            showFooterCheck.Checked = dataGrid.ShowFooter;
            allowSortingCheck.Checked = dataGrid.AllowSorting;

            if (dataSourceCombo.Items.Count > 0) {
                DataGridDesigner dataGridDesigner = (DataGridDesigner)GetBaseDesigner();
                string dataSourceValue = dataGridDesigner.DataSource;

                if (dataSourceValue != null) {
                    int dataSourcesAvailable = dataSourceCombo.Items.Count;
                    for (int j = 1; j < dataSourcesAvailable; j++) {
                        DataSourceItem dataSourceItem =
                            (DataSourceItem)dataSourceCombo.Items[j];

                        if (String.Compare(dataSourceItem.Name, dataSourceValue, true, CultureInfo.InvariantCulture) == 0) {
                            dataSourceCombo.SelectedIndex = j;
                            currentDataSource = dataSourceItem;
                            LoadDataMembers();

                            if (currentDataSource is ListSourceDataSourceItem) {
                                string dataMember = dataGridDesigner.DataMember;
                                dataMemberCombo.SelectedIndex = dataMemberCombo.FindStringExact(dataMember);

                                if (dataMemberCombo.IsSet()) {
                                    ((ListSourceDataSourceItem)currentDataSource).CurrentDataMember = dataMember;
                                }
                            }

                            LoadDataSourceFields();

                            break;
                        }
                    }
                }
            }

            string dataKeyField = dataGrid.DataKeyField;
            if (dataKeyField.Length != 0) {
                int fieldIndex = dataKeyFieldCombo.FindStringExact(dataKeyField);
                dataKeyFieldCombo.SelectedIndex = fieldIndex;
            }

            if (dataGrid.AutoGenerateColumns) {
                columnInfoLabel.Text = SR.GetString(SR.DGGen_AutoColumnInfo);
            }
            else {
                columnInfoLabel.Text = SR.GetString(SR.DGGen_CustomColumnInfo);
            }

            UpdateEnabledVisibleState();
        }

        /// <include file='doc\DataGridGeneralPage.uex' path='docs/doc[@for="DataGridGeneralPage.LoadDataMembers"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void LoadDataMembers() {
            EnterLoadingMode();

            dataMemberCombo.SelectedIndex = -1;
            dataMemberCombo.Items.Clear();
            dataMemberCombo.EnsureNotSetItem();

            if ((currentDataSource != null) && (currentDataSource is ListSourceDataSourceItem)) {
                string[] dataMembers = ((ListSourceDataSourceItem)currentDataSource).DataMembers;

                for (int i = 0; i < dataMembers.Length; i++) {
                    dataMemberCombo.AddItem(dataMembers[i]);
                }
            }

            ExitLoadingMode();
        }

        /// <include file='doc\DataGridGeneralPage.uex' path='docs/doc[@for="DataGridGeneralPage.LoadDataSourceFields"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void LoadDataSourceFields() {
            EnterLoadingMode();

            dataKeyFieldCombo.SelectedIndex = -1;
            dataKeyFieldCombo.Items.Clear();
            dataKeyFieldCombo.EnsureNotSetItem();

            if (currentDataSource != null) {
                PropertyDescriptorCollection fields = currentDataSource.Fields;

                if (fields != null) {
                    IEnumerator fieldEnum = fields.GetEnumerator();
                    while (fieldEnum.MoveNext()) {
                        PropertyDescriptor fieldDesc = (PropertyDescriptor)fieldEnum.Current;

                        if (BaseDataList.IsBindableType(fieldDesc.PropertyType)) {
                            dataKeyFieldCombo.AddItem(fieldDesc.Name);
                        }
                    }
                }
            }

            ExitLoadingMode();
        }

        /// <include file='doc\DataGridGeneralPage.uex' path='docs/doc[@for="DataGridGeneralPage.LoadDataSourceItems"]/*' />
        /// <devdoc>
        ///   Loads the list of available IEnumerable components
        /// </devdoc>
        private void LoadDataSourceItems() {
            dataSourceCombo.EnsureNotSetItem();

            ISite thisSite = GetSelectedComponent().Site;

            if (thisSite != null) {
                IContainer container = (IContainer)thisSite.GetService(typeof(IContainer));

                if (container != null) {
                    ComponentCollection allComponents = container.Components;
                    if (allComponents != null) {
                        foreach (IComponent comp in (IEnumerable)allComponents) {
                            if ((comp is IEnumerable) || (comp is IListSource)) {
                                // must have a valid site and a name
                                ISite componentSite = comp.Site;
                                if ((componentSite == null) || (componentSite.Name == null) ||
                                    (componentSite.Name.Length == 0))
                                    continue;

                                DataSourceItem dsItem;
                                if (comp is IListSource) {
                                    // an IListSource
                                    IListSource listSource = (IListSource)comp;
                                    dsItem = new ListSourceDataSourceItem(componentSite.Name, listSource);
                                }
                                else {
                                    // found an IEnumerable
                                    IEnumerable dataSource = (IEnumerable)comp;
                                    dsItem = new DataSourceItem(componentSite.Name, dataSource);
                                }
                                dataSourceCombo.AddItem(dsItem);
                            }
                        }
                    }
                }
            }
        }

        /// <include file='doc\DataGridGeneralPage.uex' path='docs/doc[@for="DataGridGeneralPage.OnCheckChangedShowHeader"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void OnCheckChangedShowHeader(object source, EventArgs e) {
            if (IsLoading())
                return;
            SetDirty();
        }

        /// <include file='doc\DataGridGeneralPage.uex' path='docs/doc[@for="DataGridGeneralPage.OnCheckChangedShowFooter"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void OnCheckChangedShowFooter(object source, EventArgs e) {
            if (IsLoading())
                return;
            SetDirty();
        }

        /// <include file='doc\DataGridGeneralPage.uex' path='docs/doc[@for="DataGridGeneralPage.OnCheckChangedAllowSorting"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void OnCheckChangedAllowSorting(object source, EventArgs e) {
            if (IsLoading())
                return;
            SetDirty();
        }

        /// <include file='doc\DataGridGeneralPage.uex' path='docs/doc[@for="DataGridGeneralPage.OnSelChangedDataKeyField"]/*' />
        /// <devdoc>
        ///   Handles changes in the datasource selection.
        /// </devdoc>
        private void OnSelChangedDataKeyField(object source, EventArgs e) {
            if (IsLoading())
                return;
            SetDirty();
        }

        /// <include file='doc\DataGridGeneralPage.uex' path='docs/doc[@for="DataGridGeneralPage.OnSelChangedDataMember"]/*' />
        /// <devdoc>
        ///   Handles changes in the datamember selection
        /// </devdoc>
        private void OnSelChangedDataMember(object source, EventArgs e) {
            if (IsLoading())
                return;

            string newDataMember = null;
            if (dataMemberCombo.IsSet())
                newDataMember = (string)dataMemberCombo.SelectedItem;

            Debug.Assert((currentDataSource != null) && (currentDataSource is ListSourceDataSourceItem));
            ListSourceDataSourceItem dsItem = (ListSourceDataSourceItem)currentDataSource;

            dsItem.CurrentDataMember = newDataMember;

            LoadDataSourceFields();
            dataSourceDirty = true;

            SetDirty();
            UpdateEnabledVisibleState();
        }

        /// <include file='doc\DataGridGeneralPage.uex' path='docs/doc[@for="DataGridGeneralPage.OnSelChangedDataSource"]/*' />
        /// <devdoc>
        ///   Handles changes in the datasource selection.
        /// </devdoc>
        private void OnSelChangedDataSource(object source, EventArgs e) {
            if (IsLoading())
                return;

            DataSourceItem newDataSource = null;

            if (dataSourceCombo.IsSet())
                newDataSource = (DataSourceItem)dataSourceCombo.SelectedItem;

            if (newDataSource != null) {
                if (newDataSource.IsSelectable() == false) {
                    EnterLoadingMode();
                    if (currentDataSource == null) {
                        dataSourceCombo.SelectedIndex = -1;
                    }
                    else {
                        dataSourceCombo.SelectedItem = currentDataSource;
                    }
                    ExitLoadingMode();
                    return;
                }
            }

            currentDataSource = newDataSource;
            if (currentDataSource is ListSourceDataSourceItem) {
                ((ListSourceDataSourceItem)currentDataSource).CurrentDataMember = null;
            }

            LoadDataMembers();
            LoadDataSourceFields();
            dataSourceDirty = true;

            SetDirty();
            UpdateEnabledVisibleState();
        }

        /// <include file='doc\DataGridGeneralPage.uex' path='docs/doc[@for="DataGridGeneralPage.SaveComponent"]/*' />
        /// <devdoc>
        ///   Saves the component loaded into the page.
        /// </devdoc>
        protected override void SaveComponent() {
            DataGrid dataGrid = (DataGrid)GetBaseControl();

            dataGrid.ShowHeader = showHeaderCheck.Checked;
            dataGrid.ShowFooter = showFooterCheck.Checked;
            dataGrid.AllowSorting = allowSortingCheck.Checked;

            string dataKeyField = String.Empty;
            if (dataKeyFieldCombo.IsSet())
                dataKeyField = (string)dataKeyFieldCombo.SelectedItem;
            dataGrid.DataKeyField = dataKeyField;

            if (dataSourceDirty) {
                // save the datasource as a binding on the control

                DataGridDesigner dataGridDesigner = (DataGridDesigner)GetBaseDesigner();
                DataBindingCollection dataBindings = dataGridDesigner.DataBindings;

                if (currentDataSource == null) {
                    dataGridDesigner.DataSource = String.Empty;
                    dataGridDesigner.DataMember = String.Empty;
                }
                else {
                    dataGridDesigner.DataSource = currentDataSource.ToString();

                    if (dataMemberCombo.IsSet()) {
                        dataGridDesigner.DataMember = (string)dataMemberCombo.SelectedItem;
                    }
                    else {
                        dataGridDesigner.DataMember = String.Empty;
                    }
                }

                dataGridDesigner.OnDataSourceChanged();
            }
        }

        /// <include file='doc\DataGridGeneralPage.uex' path='docs/doc[@for="DataGridGeneralPage.SetComponent"]/*' />
        /// <devdoc>
        ///   Sets the component that is to be edited in the page.
        /// </devdoc>
        public override void SetComponent(IComponent component) {
            base.SetComponent(component);
            InitForm();
        }

        /// <include file='doc\DataGridGeneralPage.uex' path='docs/doc[@for="DataGridGeneralPage.UpdateEnabledVisibleState"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void UpdateEnabledVisibleState() {
            bool dataSourceSelected = (currentDataSource != null);

            dataMemberCombo.Enabled = (dataSourceSelected && currentDataSource.HasDataMembers);
            dataKeyFieldCombo.Enabled = dataSourceSelected;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\webcontrols\listcontrols\autoformatdialog.cs ===
//------------------------------------------------------------------------------
// <copyright file="AutoFormatDialog.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.WebControls.ListControls {

    using System;
    using System.Design;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Xml;
    using System.Data;
    using System.Diagnostics;
    using System.Drawing;
    
    using System.IO;
    using System.Reflection;
    using System.Text;
    using System.Globalization;
    using System.Web.UI.Design.Util;
    using System.Web.UI.WebControls;
    using System.Windows.Forms;
    using System.Windows.Forms.Design;

    using WebControls = System.Web.UI.WebControls;
    using DataList = System.Web.UI.WebControls.DataList;
    using DataGrid = System.Web.UI.WebControls.DataGrid;
    using ListSelectionMode = System.Web.UI.WebControls.ListSelectionMode;
    using Unit = System.Web.UI.WebControls.Unit;
    using BorderStyle = System.Web.UI.WebControls.BorderStyle;

    using Timer = System.Windows.Forms.Timer;
    using Button = System.Windows.Forms.Button;
    using Label = System.Windows.Forms.Label;
    using ListBox = System.Windows.Forms.ListBox;


    /// <include file='doc\AutoFormatDialog.uex' path='docs/doc[@for="AutoFormatDialog"]/*' />
    /// <devdoc>
    ///   The AutoFormat dialog for the DataGrid and DataList controls.
    /// </devdoc>
    /// <internalonly/>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal sealed class AutoFormatDialog : Form {
    
        private ListBox schemeNameList;
        private MSHTMLHost schemePreviewMSHTML;
        private Button okButton;
        private Button cancelButton;
        private Button helpButton;

        private BaseDataList bdl;

        private bool firstActivate;
        private SchemePreview schemePreview;

        /// <include file='doc\AutoFormatDialog.uex' path='docs/doc[@for="AutoFormatDialog.AutoFormatDialog"]/*' />
        /// <devdoc>
        /// </devdoc>
        public AutoFormatDialog() {
            firstActivate = true;
        }

        /// <include file='doc\AutoFormatDialog.uex' path='docs/doc[@for="AutoFormatDialog.ApplySelectedScheme"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void ApplySelectedScheme() {
            BaseDataListScheme selectedScheme = (BaseDataListScheme)schemeNameList.SelectedItem;
            selectedScheme.ApplyScheme(bdl);
        }

        /// <include file='doc\AutoFormatDialog.uex' path='docs/doc[@for="AutoFormatDialog.InitForm"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void InitForm() {
            Label schemeNameLabel = new Label();
            this.schemeNameList = new ListBox();
            Label schemePreviewLabel = new Label();
            this.schemePreviewMSHTML = new MSHTMLHost();
            this.okButton = new Button();
            this.cancelButton = new Button();
            this.helpButton = new Button();
            
            schemeNameLabel.SetBounds(8, 8, 176, 16);
            schemeNameLabel.Text = SR.GetString(SR.BDLAF_SchemeName);
            schemeNameLabel.TabStop = false;
            schemeNameLabel.TabIndex = 0;

            schemeNameList.SetBounds(8, 24, 176, 150);
            schemeNameList.TabIndex = 1;
            schemeNameList.UseTabStops = true;
            schemeNameList.IntegralHeight = false;
            if (bdl is DataGrid) {
                object[] schemes = DataGridScheme.LoadSchemes();
                foreach(object scheme in schemes) {
                    schemeNameList.Items.Add(scheme);
                }
            }
            else {
                Debug.Assert(bdl is DataList, "AutoFormatDialog only supports DataGrid and DataList.");
                object[] schemes = DataListScheme.LoadSchemes();
                foreach(object scheme in schemes) {
                    schemeNameList.Items.Add(scheme);
                }
            }
            schemeNameList.SelectedIndex = 0;            
            schemeNameList.SelectedIndexChanged += new EventHandler(this.OnSelChangedSchemeName);

            schemePreviewLabel.SetBounds(192, 8, 92, 16);
            schemePreviewLabel.Text = SR.GetString(SR.BDLAF_Preview);
            schemePreviewLabel.TabStop = false;
            schemePreviewLabel.TabIndex = 2;

            schemePreviewMSHTML.SetBounds(192, 24, 200, 190);
            schemePreviewMSHTML.TabIndex = 3;
            schemePreviewMSHTML.TabStop = false;

            okButton.SetBounds(159, 228, 75, 23);
            okButton.Text = SR.GetString(SR.BDLAF_OK);
            okButton.TabIndex = 4;
            okButton.FlatStyle = FlatStyle.System;
            okButton.Click += new EventHandler(this.OnClickOKButton);

            cancelButton.SetBounds(238, 228, 75, 23);
            cancelButton.DialogResult = DialogResult.Cancel;
            cancelButton.Text = SR.GetString(SR.BDLAF_Cancel);
            cancelButton.FlatStyle = FlatStyle.System;
            cancelButton.TabIndex = 4;

            helpButton.SetBounds(317, 228, 75, 23);
            helpButton.Text = SR.GetString(SR.BDLAF_Help);
            helpButton.TabIndex = 5;
            helpButton.FlatStyle = FlatStyle.System;
            helpButton.Click += new EventHandler(this.OnClickHelpButton);

            Font f = Control.DefaultFont;
            ISite site = bdl.Site;
            IUIService uiService = (IUIService)site.GetService(typeof(IUIService));
            if (uiService != null) {
                f = (Font)uiService.Styles["DialogFont"];
            }
            
            this.Text = SR.GetString(SR.BDLAF_Title);
            this.AutoScaleBaseSize = new Size(5, 13);
            this.Font = f;
            this.FormBorderStyle = FormBorderStyle.FixedDialog;
            this.ClientSize = new Size(400, 259);
            this.AcceptButton = okButton;
            this.CancelButton = cancelButton;
            this.MaximizeBox = false;
            this.MinimizeBox = false;
            this.ShowInTaskbar = false;
            this.Icon = null;
            this.StartPosition = FormStartPosition.CenterParent;
            this.HelpRequested += new HelpEventHandler(this.OnHelpRequested);
            
            this.Controls.Clear();
            this.Controls.AddRange(new Control[] {
                                    helpButton,
                                    cancelButton,
                                    okButton,
                                    schemePreviewMSHTML,
                                    schemePreviewLabel,
                                    schemeNameList,
                                    schemeNameLabel
                                });
        }

        /// <include file='doc\AutoFormatDialog.uex' path='docs/doc[@for="AutoFormatDialog.SetComponent"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void SetComponent(BaseDataList bdl) {
            this.bdl = bdl;
            InitForm();
        }

        /// <include file='doc\AutoFormatDialog.uex' path='docs/doc[@for="AutoFormatDialog.OnActivated"]/*' />
        /// <devdoc>
        /// </devdoc>
        protected override void OnActivated(EventArgs e) {
            base.OnActivated(e);

            if (firstActivate) {
                firstActivate = false;

                Timer t = new Timer();

                t.Interval = 500;
                t.Tick += new EventHandler(this.OnDelayLoadTimer);
                t.Start();
            }
        }

        private void ShowHelp() {
            ISite componentSite = bdl.Site;
            Debug.Assert(componentSite != null, "Expected the component to be sited.");
 
            IHelpService helpService = (IHelpService)componentSite.GetService(typeof(IHelpService));
            if (helpService != null) {
                helpService.ShowHelpFromKeyword("net.Asp.DataGridDataList.AutoFormat");
            }
        }

        /// <include file='doc\AutoFormatDialog.uex' path='docs/doc[@for="AutoFormatDialog.OnClickHelpButton"]/*' />
        private void OnClickHelpButton(object sender, EventArgs e) {
            ShowHelp();
        }

        private void OnHelpRequested(object sender, HelpEventArgs e) {
            ShowHelp();
        }

        /// <include file='doc\AutoFormatDialog.uex' path='docs/doc[@for="AutoFormatDialog.OnClickOKButton"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void OnClickOKButton(object sender, EventArgs e) {
            ApplySelectedScheme();
            Close();
            DialogResult = DialogResult.OK;
        }

        /// <include file='doc\AutoFormatDialog.uex' path='docs/doc[@for="AutoFormatDialog.OnDelayLoadTimer"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void OnDelayLoadTimer(object source, EventArgs e) {
            Timer t = (Timer)source;

            t.Stop();

            NativeMethods.MSG msg = new NativeMethods.MSG();
            if (NativeMethods.PeekMessage(ref msg, Handle, 0, 0, NativeMethods.PM_NOREMOVE) == false) {
                t.Dispose();
                schemePreviewMSHTML.CreateTrident();

                NativeMethods.IHTMLDocument2 document = schemePreviewMSHTML.GetDocument();
                if (document != null) {
                    schemePreview = new SchemePreview(document);
                    if (schemePreview.InitPreview() == false) {
                        schemePreview.ClosePreview();
                        schemePreview = null;
                    }
                    else {
                        schemePreviewMSHTML.ActivateTrident();
                        PreviewSelectedScheme();
                    }
                }
            }
            else {
                t.Start();
            }
        }

        /// <include file='doc\AutoFormatDialog.uex' path='docs/doc[@for="AutoFormatDialog.OnHandleDestroyed"]/*' />
        /// <devdoc>
        /// </devdoc>
        protected override void OnHandleDestroyed(EventArgs e) {
            if (schemePreview != null) {
                schemePreview.ClosePreview();
                schemePreview = null;
            }
            schemePreviewMSHTML.CloseTrident();

            base.OnHandleDestroyed(e);
        }

        /// <include file='doc\AutoFormatDialog.uex' path='docs/doc[@for="AutoFormatDialog.OnSelChangedSchemeName"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void OnSelChangedSchemeName(object sender, EventArgs e) {
            PreviewSelectedScheme();
        }

        /// <include file='doc\AutoFormatDialog.uex' path='docs/doc[@for="AutoFormatDialog.PreviewSelectedScheme"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void PreviewSelectedScheme() {
                        BaseDataListScheme selectedScheme = (BaseDataListScheme)schemeNameList.SelectedItem;
                        schemePreview.PreviewScheme(selectedScheme);
        }



        /// <include file='doc\AutoFormatDialog.uex' path='docs/doc[@for="AutoFormatDialog.SchemePreview"]/*' />
        /// <devdoc>
        ///   Implements the preview used to preview a scheme
        /// </devdoc>
        /// <internalonly/>
        private class SchemePreview {

            private const string PREVIEW_CSS =
                @"
                 body { border: none; margin: 0; padding: 0; overflow: hidden }
                 #divPreview { height: 100%; width: 100%; overflow: hidden; padding: 4px }
                 table { width: 100%; table-layout: fixed; font-family: Tahoma !important; font-size: 8pt !important }
                 previewElem tr { height: 12pt }
                 ";

            private const string PREVIEW_HTML =
                @"
                 <div id=""divPreview"">
                   <table border=0 cellspacing=0 cellpadding=0 style=""width: 100%; height: 100%"">
                     <tr>
                       <td id=""previewElem"" align=center valign=middle style=""width: 100%; height: 100%""></td>
                     </tr>
                   </table>
                 </div>
                 ";

            private const string PREVIEW_ID = "previewElem";

            protected NativeMethods.IHTMLDocument2 previewDocument;
            protected NativeMethods.IHTMLElement previewElement;
            protected NativeMethods.IHTMLStyleSheet previewStyleSheet;

            /// <include file='doc\AutoFormatDialog.uex' path='docs/doc[@for="AutoFormatDialog.SchemePreview.SchemePreview"]/*' />
            /// <devdoc>
            /// </devdoc>
            public SchemePreview(NativeMethods.IHTMLDocument2 document) {
                Debug.Assert(document != null, "null document passed in as preview");
                previewDocument = document;
            }

            /// <include file='doc\AutoFormatDialog.uex' path='docs/doc[@for="AutoFormatDialog.SchemePreview.InitPreview"]/*' />
            /// <devdoc>
            /// </devdoc>
            public bool InitPreview() {
                bool result = false;
                NativeMethods.IHTMLElement documentElem;
                NativeMethods.IHTMLBodyElement bodyElem;

                try {
                    previewStyleSheet = previewDocument.CreateStyleSheet("", 0);
                    if (previewStyleSheet == null) {
                        Debug.Fail("Failed to create preview style sheet");
                        throw new Exception();
                    }

                    previewStyleSheet.SetCssText(PREVIEW_CSS);

                    documentElem = previewDocument.GetBody();
                    if (documentElem == null) {
                        Debug.Fail("Failed to get body element from preview");
                        throw new Exception();
                    }

                    documentElem.SetInnerHTML(PREVIEW_HTML);

                    bodyElem = (NativeMethods.IHTMLBodyElement)documentElem;
                    bodyElem.SetScroll("no");

                    previewElement = GetElement(PREVIEW_ID);
                    if (previewElement == null) {
                        Debug.Fail("Failed to get preview element");
                        throw new Exception();
                    }

                    ClearPreviewDocument(false);

                    result = true;
                } catch (Exception e) {
                    Debug.Fail(e.ToString());
                    previewDocument = null;
                }

                return result;
            }

            /// <include file='doc\AutoFormatDialog.uex' path='docs/doc[@for="AutoFormatDialog.SchemePreview.ClearPreviewDocument"]/*' />
            /// <devdoc>
            /// </devdoc>
            public void ClearPreviewDocument(bool fEnabled) {
                Object backColor = fEnabled ? String.Empty : "buttonface";

                previewElement.SetInnerHTML(String.Empty);
                previewDocument.SetBgColor(backColor);
            }

            /// <include file='doc\AutoFormatDialog.uex' path='docs/doc[@for="AutoFormatDialog.SchemePreview.ClosePreview"]/*' />
            /// <devdoc>
            /// </devdoc>
            public void ClosePreview() {
                previewElement = null;
                previewDocument = null;
            }

            /// <include file='doc\AutoFormatDialog.uex' path='docs/doc[@for="AutoFormatDialog.SchemePreview.GetElement"]/*' />
            /// <devdoc>
            /// </devdoc>
            private NativeMethods.IHTMLElement GetElement(string strID) {
                try {
                    NativeMethods.IHTMLElementCollection allCollection;

                    allCollection = previewDocument.GetAll();
                    if (allCollection == null)
                        throw new Exception();

                    Object elemID = strID;
                    Object elemIndex = (int)0;

                    return(NativeMethods.IHTMLElement)allCollection.Item(elemID, elemIndex);
                } catch (Exception e) {
                    Debug.WriteLine("Exception caught while retrieving element from preview:\n\t" + e.ToString());
                    return null;
                }
            }

            /// <include file='doc\AutoFormatDialog.uex' path='docs/doc[@for="AutoFormatDialog.SchemePreview.PreviewScheme"]/*' />
            /// <devdoc>
            /// </devdoc>
            public void PreviewScheme(BaseDataListScheme scheme) {
                if (scheme == null) {
                    ClearPreviewDocument(false);
                }
                else {
                    ClearPreviewDocument(true);
                    previewElement.SetInnerHTML(scheme.PreviewHTML);
                }
            }
        }



        /// <include file='doc\AutoFormatDialog.uex' path='docs/doc[@for="AutoFormatDialog.BaseDataListScheme"]/*' />
        /// <devdoc>
        ///   The base class for autoformat schemes that apply to
        ///   BaseDataList controls.
        /// </devdoc>
        /// <internalonly/>
        private abstract class BaseDataListScheme {

            protected string previewHTML;

            protected string name;
            protected string headerForeColor;
            protected string headerBackColor;
            protected int headerFont;
            protected string footerForeColor;
            protected string footerBackColor;
            protected int footerFont;
            protected string borderColor;
            protected string borderWidth;
            protected int borderStyle;
            protected int gridLines;
            protected int cellSpacing;
            protected int cellPadding;
            protected string foreColor;
            protected string backColor;
            protected string itemForeColor;
            protected string itemBackColor;
            protected int itemFont;
            protected string alternatingItemForeColor;
            protected string alternatingItemBackColor;
            protected int alternatingItemFont;
            protected string selectedItemForeColor;
            protected string selectedItemBackColor;
            protected int selectedItemFont;
            protected string pagerForeColor;
            protected string pagerBackColor;
            protected int pagerFont;
            protected int pagerAlign;
            protected int pagerMode;

            protected const int FONT_BOLD = 1;
            protected const int FONT_ITALIC = 2;


            protected BaseDataListScheme(DataRow schemeData) {
                this.name = SR.GetString(schemeData["SchemeName"].ToString());
                Debug.Assert(name != null, "Did not find name for scheme with name '" + schemeData["SchemeName"]);

                this.cellSpacing = 0;
                this.cellPadding = -1;
                this.borderStyle = -1;
                this.gridLines = -1;
                this.headerFont = 0;
                this.footerFont = 0;
                this.itemFont = 0;
                this.alternatingItemFont = 0;
                this.selectedItemFont = 0;
                this.pagerFont = 0;
                this.pagerAlign = 0;
                this.pagerMode = 0;

                object data;

                data = schemeData["ForeColor"];
                if ((data != null) && !data.Equals(DBNull.Value))
                    this.foreColor = data.ToString();

                data = schemeData["BackColor"];
                if ((data != null) && !data.Equals(DBNull.Value))
                    this.backColor = data.ToString();

                data = schemeData["BorderColor"];
                if ((data != null) && !data.Equals(DBNull.Value))
                    this.borderColor = data.ToString();

                data = schemeData["BorderWidth"];
                if ((data != null) && !data.Equals(DBNull.Value))
                    this.borderWidth = data.ToString();

                data = schemeData["BorderStyle"];
                if ((data != null) && !data.Equals(DBNull.Value))
                    this.borderStyle = Int32.Parse(data.ToString(), CultureInfo.InvariantCulture);

                data = schemeData["CellSpacing"];
                if ((data != null) && !data.Equals(DBNull.Value))
                    this.cellSpacing = Int32.Parse(data.ToString(), CultureInfo.InvariantCulture);

                data = schemeData["CellPadding"];
                if ((data != null) && !data.Equals(DBNull.Value))
                    this.cellPadding = Int32.Parse(data.ToString(), CultureInfo.InvariantCulture);

                data = schemeData["GridLines"];
                if ((data != null) && !data.Equals(DBNull.Value))
                    this.gridLines = Int32.Parse(data.ToString(), CultureInfo.InvariantCulture);

                data = schemeData["ItemForeColor"];
                if ((data != null) && !data.Equals(DBNull.Value))
                    this.itemForeColor = data.ToString();

                data = schemeData["ItemBackColor"];
                if ((data != null) && !data.Equals(DBNull.Value))
                    this.itemBackColor = data.ToString();

                data = schemeData["ItemFont"];
                if ((data != null) && !data.Equals(DBNull.Value))
                    this.itemFont = Int32.Parse(data.ToString(), CultureInfo.InvariantCulture);

                data = schemeData["AltItemForeColor"];
                if ((data != null) && !data.Equals(DBNull.Value))
                    this.alternatingItemForeColor = data.ToString();

                data = schemeData["AltItemBackColor"];
                if ((data != null) && !data.Equals(DBNull.Value))
                    this.alternatingItemBackColor = data.ToString();

                data = schemeData["AltItemFont"];
                if ((data != null) && !data.Equals(DBNull.Value))
                    this.alternatingItemFont = Int32.Parse(data.ToString(), CultureInfo.InvariantCulture);

                data = schemeData["SelItemForeColor"];
                if ((data != null) && !data.Equals(DBNull.Value))
                    this.selectedItemForeColor = data.ToString();

                data = schemeData["SelItemBackColor"];
                if ((data != null) && !data.Equals(DBNull.Value))
                    this.selectedItemBackColor = data.ToString();

                data = schemeData["SelItemFont"];
                if ((data != null) && !data.Equals(DBNull.Value))
                    this.selectedItemFont = Int32.Parse(data.ToString(), CultureInfo.InvariantCulture);

                data = schemeData["HeaderForeColor"];
                if ((data != null) && !data.Equals(DBNull.Value))
                    this.headerForeColor = data.ToString();

                data = schemeData["HeaderBackColor"];
                if ((data != null) && !data.Equals(DBNull.Value))
                    this.headerBackColor = data.ToString();

                data = schemeData["HeaderFont"];
                if ((data != null) && !data.Equals(DBNull.Value))
                    this.headerFont = Int32.Parse(data.ToString(), CultureInfo.InvariantCulture);

                data = schemeData["FooterForeColor"];
                if ((data != null) && !data.Equals(DBNull.Value))
                    this.footerForeColor = data.ToString();

                data = schemeData["FooterBackColor"];
                if ((data != null) && !data.Equals(DBNull.Value))
                    this.footerBackColor = data.ToString();

                data = schemeData["FooterFont"];
                if ((data != null) && !data.Equals(DBNull.Value))
                    this.footerFont = Int32.Parse(data.ToString(), CultureInfo.InvariantCulture);

                data = schemeData["PagerForeColor"];
                if ((data != null) && !data.Equals(DBNull.Value))
                    this.pagerForeColor = data.ToString();

                data = schemeData["PagerBackColor"];
                if ((data != null) && !data.Equals(DBNull.Value))
                    this.pagerBackColor = data.ToString();

                data = schemeData["PagerFont"];
                if ((data != null) && !data.Equals(DBNull.Value))
                    this.pagerFont = Int32.Parse(data.ToString(), CultureInfo.InvariantCulture);

                data = schemeData["PagerAlign"];
                if ((data != null) && !data.Equals(DBNull.Value))
                    this.pagerAlign = Int32.Parse(data.ToString(), CultureInfo.InvariantCulture);

                data = schemeData["PagerMode"];
                if ((data != null) && !data.Equals(DBNull.Value))
                    this.pagerMode = Int32.Parse(data.ToString(), CultureInfo.InvariantCulture);
            }

            public string Name {
                get {
                    return name;
                }
            }

            public string PreviewHTML {
                get {
                    if (previewHTML == null)
                        previewHTML = CreatePreviewHTML();
                    return previewHTML;
                }
            }

            public abstract void ApplyScheme(BaseDataList bdl);

            protected abstract string CreatePreviewHTML();

            public override bool Equals(object o) {
                if (o is BaseDataListScheme) {
                    return Name.Equals(((BaseDataListScheme)o).Name);
                }
                return false;
            }
            
            public override int GetHashCode() {
                return base.GetHashCode();
            }

            public override string ToString() {
                return Name;
            }
        }

        /// <include file='doc\AutoFormatDialog.uex' path='docs/doc[@for="AutoFormatDialog.DataGridScheme"]/*' />
        /// <devdoc>
        ///   The autoformat scheme for a DataGrid control.
        /// </devdoc>
        /// <internalonly/>
        private sealed class DataGridScheme : BaseDataListScheme {

            private static DataGridScheme[] schemes;

            private DataGridScheme(DataRow schemeData) : base(schemeData) {
            }

            public override void ApplyScheme(BaseDataList bdl) {
                Debug.Assert(bdl is DataGrid,
                             "DataGridScheme::ApplyScheme can be applied to a DataGrid control only.");
                DataGrid d = (DataGrid)bdl;

                d.HeaderStyle.ForeColor = ColorTranslator.FromHtml(headerForeColor);
                d.HeaderStyle.BackColor = ColorTranslator.FromHtml(headerBackColor);
                d.HeaderStyle.Font.Bold = ((headerFont & FONT_BOLD) != 0);
                d.HeaderStyle.Font.Italic = ((headerFont & FONT_ITALIC) != 0);
                d.FooterStyle.ForeColor = ColorTranslator.FromHtml(footerForeColor);
                d.FooterStyle.BackColor = ColorTranslator.FromHtml(footerBackColor);
                d.FooterStyle.Font.Bold = ((footerFont & FONT_BOLD) != 0);
                d.FooterStyle.Font.Italic = ((footerFont & FONT_ITALIC) != 0);
                d.BorderWidth = new Unit(borderWidth);
                switch (gridLines) {
                    case 0: d.GridLines = GridLines.None; break;
                    case 1: d.GridLines = GridLines.Horizontal; break;
                    case 2: d.GridLines = GridLines.Vertical; break;
                    case 3:
                    default:
                        d.GridLines = GridLines.Both; break;
                }
                if ((borderStyle >= 0) && (borderStyle <= 9)) {
                    d.BorderStyle = (System.Web.UI.WebControls.BorderStyle)borderStyle;
                }
                else {
                    d.BorderStyle = System.Web.UI.WebControls.BorderStyle.NotSet;
                }
                d.BorderColor = ColorTranslator.FromHtml(borderColor);
                d.CellPadding = cellPadding;
                d.CellSpacing = cellSpacing;
                d.ForeColor = ColorTranslator.FromHtml(foreColor);
                d.BackColor = ColorTranslator.FromHtml(backColor);
                d.ItemStyle.ForeColor = ColorTranslator.FromHtml(itemForeColor);
                d.ItemStyle.BackColor = ColorTranslator.FromHtml(itemBackColor);
                d.ItemStyle.Font.Bold = ((itemFont & FONT_BOLD) != 0);
                d.ItemStyle.Font.Italic = ((itemFont & FONT_ITALIC) != 0);
                d.AlternatingItemStyle.ForeColor = ColorTranslator.FromHtml(alternatingItemForeColor);
                d.AlternatingItemStyle.BackColor = ColorTranslator.FromHtml(alternatingItemBackColor);
                d.AlternatingItemStyle.Font.Bold = ((alternatingItemFont & FONT_BOLD) != 0);
                d.AlternatingItemStyle.Font.Italic = ((alternatingItemFont & FONT_ITALIC) != 0);
                d.SelectedItemStyle.ForeColor = ColorTranslator.FromHtml(selectedItemForeColor);
                d.SelectedItemStyle.BackColor = ColorTranslator.FromHtml(selectedItemBackColor);
                d.SelectedItemStyle.Font.Bold = ((selectedItemFont & FONT_BOLD) != 0);
                d.SelectedItemStyle.Font.Italic = ((selectedItemFont & FONT_ITALIC) != 0);
                d.PagerStyle.ForeColor = ColorTranslator.FromHtml(pagerForeColor);
                d.PagerStyle.BackColor = ColorTranslator.FromHtml(pagerBackColor);
                d.PagerStyle.Font.Bold = ((pagerFont & FONT_BOLD) != 0);
                d.PagerStyle.Font.Italic = ((pagerFont & FONT_ITALIC) != 0);
                d.PagerStyle.HorizontalAlign = (HorizontalAlign)pagerAlign;
                d.PagerStyle.Mode = (PagerMode)pagerMode;
            }

            protected override string CreatePreviewHTML() {
                StringBuilder sb = new StringBuilder(512);

                sb.Append("<table style=\"");
                if (foreColor != null)
                    sb.Append("color:" + foreColor + ";");
                if (backColor != null)
                    sb.Append("background-color:" + backColor + ";");
                if (cellSpacing == 0)
                    sb.Append("border-collapse:collapse;");
                if ((borderStyle > 0) && (borderStyle <= 9)) {
                    sb.Append("border-style:");
                    sb.Append(Enum.Format(typeof(BorderStyle), (BorderStyle)borderStyle, "G"));
                }
                sb.Append('"');
                if (cellSpacing != -1)
                    sb.Append(" cellspacing=" + (cellSpacing).ToString());
                if (cellPadding != -1)
                    sb.Append(" cellpadding=" + (cellPadding).ToString());
                if (borderWidth != null)
                    sb.Append(" border=" + borderWidth);
                else
                    sb.Append(" border=1");
                if (borderColor != null)
                    sb.Append(" bordercolor=" + borderColor);
                sb.Append(" rules=");
                switch (gridLines) {
                    case 0: sb.Append("none"); break;
                    case 1: sb.Append("rows"); break;
                    case 2: sb.Append("cols"); break;
                    case 3:
                    default:sb.Append("all"); break;
                }

                sb.Append('>');
                
                // header
                sb.Append("<tr style=\"");
                if ((headerFont & FONT_BOLD) != 0)
                    sb.Append("font-weight:bold;");
                if ((headerFont & FONT_ITALIC) != 0)
                    sb.Append("font-style:italic;");
                if (headerForeColor != null)
                    sb.Append("color:" + headerForeColor + ";");
                if (headerBackColor != null)
                    sb.Append("background-color:" + headerBackColor);
                sb.Append("\"><td align=center>");
                sb.Append(SR.GetString(SR.BDLAF_Column1));
                sb.Append("</td><td align=center>");
                sb.Append(SR.GetString(SR.BDLAF_Column2));
                sb.Append("</td></tr>");

                for (int i = 0; i < 3; i++) {
                    if (i != 1) {
                        // item
                        sb.Append("<tr style=\"");
                        if ((itemFont & FONT_BOLD) != 0)
                            sb.Append("font-weight:bold;");
                        if ((itemFont & FONT_ITALIC) != 0)
                            sb.Append("font-style:italic;");
                        if (itemForeColor != null)
                            sb.Append("color:" + itemForeColor + ";");
                        if (itemBackColor != null)
                            sb.Append("background-color:" + itemBackColor);
                        sb.Append("\">");
                        sb.Append("<td align=center>####</td><td align=center>####</td>");
                        sb.Append("</tr>");
                    }
                    else {
                        // selected item
                        sb.Append("<tr style=\"");
                        if (((selectedItemFont & FONT_BOLD) != 0) || ((itemFont & FONT_BOLD) != 0))
                            sb.Append("font-weight:bold;");
                        if (((selectedItemFont & FONT_ITALIC) != 0) || ((itemFont & FONT_ITALIC) != 0))
                            sb.Append("font-style:italic;");
                        if (selectedItemForeColor != null) {
                            sb.Append("color:" + selectedItemForeColor + ";");
                        }
                        else if (itemForeColor != null) {
                            sb.Append("color:" + itemForeColor + ";");
                        }
                        if (selectedItemBackColor != null) {
                            sb.Append("background-color:" + selectedItemBackColor);
                        }
                        else if (itemBackColor != null) {
                            sb.Append("background-color:" + itemBackColor);
                        }
                        sb.Append("\">");
                        sb.Append("<td align=center>####</td><td align=center>####</td>");
                        sb.Append("</tr>");
                    }

                    if (i != 2) {
                        // alternating item
                        sb.Append("<tr style=\"");
                        if (((alternatingItemFont & FONT_BOLD) != 0) || ((itemFont & FONT_BOLD) != 0))
                            sb.Append("font-weight:bold;");
                        if (((alternatingItemFont & FONT_ITALIC) != 0) || ((itemFont & FONT_ITALIC) != 0))
                            sb.Append("font-style:italic;");
                        if (alternatingItemForeColor != null) {
                            sb.Append("color:" + alternatingItemForeColor + ";");
                        }
                        else if (itemForeColor != null) {
                            sb.Append("color:" + itemForeColor + ";");
                        }
                        if (alternatingItemBackColor != null) {
                            sb.Append("background-color:" + alternatingItemBackColor);
                        }
                        else if (itemBackColor != null) {
                            sb.Append("background-color:" + itemBackColor);
                        }
                        sb.Append("\">");
                        sb.Append("<td align=center>####</td><td align=center>####</td>");
                        sb.Append("</tr>");
                    }
                }

                // footer
                sb.Append("<tr style=\"");
                if ((footerFont & FONT_BOLD) != 0)
                    sb.Append("font-weight:bold;");
                if ((footerFont & FONT_ITALIC) != 0)
                    sb.Append("font-style:italic;");
                if (footerForeColor != null)
                    sb.Append("color:" + footerForeColor + ";");
                if (footerBackColor != null)
                    sb.Append("background-color:" + footerBackColor);
                sb.Append("\">");
                sb.Append("<td>&nbsp;</td><td>&nbsp;</td>");
                sb.Append("</tr>");
                
                sb.Append("</table>");

                return sb.ToString();
            }

            public static DataGridScheme[] LoadSchemes() {
                if (DataGridScheme.schemes == null) {
                    try {
                        DataSet ds = new DataSet();
                        ds.Locale = CultureInfo.InvariantCulture;
                        ds.ReadXml(new XmlTextReader(new StringReader(SCHEMES)));

                        Debug.Assert((ds.Tables.Count == 1) && (ds.Tables[0].TableName.Equals("Scheme")),
                                    "Unexpected tables in schemes dataset");

                        DataTable schemeTable = ds.Tables[0];
                        DataRowCollection schemeRows = schemeTable.Rows;

                        Debug.Assert((schemeRows != null) && (schemeRows.Count != 0),
                                    "Expected schemes in scheme table");

                        int schemeCount = schemeRows.Count;
                        DataGridScheme.schemes = new DataGridScheme[schemeCount];

                        for (int i = 0; i < schemeCount; i++) {
                            schemes[i] = new DataGridScheme(schemeRows[i]);
                        }
                    }
                    catch (Exception e) {
                        Debug.Fail(e.ToString());
                    }
                }
                return DataGridScheme.schemes;
            }
        }

        /// <include file='doc\AutoFormatDialog.uex' path='docs/doc[@for="AutoFormatDialog.DataListScheme"]/*' />
        /// <devdoc>
        ///   The autoformat scheme for a DataList control.
        /// </devdoc>
        /// <internalonly/>
        private sealed class DataListScheme : BaseDataListScheme {

            private static DataListScheme[] schemes;

            private DataListScheme(DataRow schemeData) : base(schemeData) {
            }

            public override void ApplyScheme(BaseDataList bdl) {
                Debug.Assert(bdl is DataList,
                             "DataListScheme::ApplyScheme can be applied to a DataList control only.");
                DataList d = (DataList)bdl;

                d.HeaderStyle.ForeColor = ColorTranslator.FromHtml(headerForeColor);
                d.HeaderStyle.BackColor = ColorTranslator.FromHtml(headerBackColor);
                d.HeaderStyle.Font.Bold = ((headerFont & FONT_BOLD) != 0);
                d.HeaderStyle.Font.Italic = ((headerFont & FONT_ITALIC) != 0);
                d.FooterStyle.ForeColor = ColorTranslator.FromHtml(footerForeColor);
                d.FooterStyle.BackColor = ColorTranslator.FromHtml(footerBackColor);
                d.FooterStyle.Font.Bold = ((footerFont & FONT_BOLD) != 0);
                d.FooterStyle.Font.Italic = ((footerFont & FONT_ITALIC) != 0);
                d.BorderWidth = new Unit(borderWidth);
                switch (gridLines) {
                    case 1: d.GridLines = GridLines.Horizontal; break;
                    case 2: d.GridLines = GridLines.Vertical; break;
                    case 3: d.GridLines = GridLines.Both; break;
                    case 0:
                    default:
                        d.GridLines = GridLines.None; break;
                }
                if ((borderStyle >= 0) && (borderStyle <= 9)) {
                    d.BorderStyle = (System.Web.UI.WebControls.BorderStyle)borderStyle;
                }
                else {
                    d.BorderStyle = System.Web.UI.WebControls.BorderStyle.NotSet;
                }
                d.BorderColor = ColorTranslator.FromHtml(borderColor);
                d.CellPadding = cellPadding;
                d.CellSpacing = cellSpacing;
                d.ForeColor = ColorTranslator.FromHtml(foreColor);
                d.BackColor = ColorTranslator.FromHtml(backColor);
                d.ItemStyle.ForeColor = ColorTranslator.FromHtml(itemForeColor);
                d.ItemStyle.BackColor = ColorTranslator.FromHtml(itemBackColor);
                d.ItemStyle.Font.Bold = ((itemFont & FONT_BOLD) != 0);
                d.ItemStyle.Font.Italic = ((itemFont & FONT_ITALIC) != 0);
                d.AlternatingItemStyle.ForeColor = ColorTranslator.FromHtml(alternatingItemForeColor);
                d.AlternatingItemStyle.BackColor = ColorTranslator.FromHtml(alternatingItemBackColor);
                d.AlternatingItemStyle.Font.Bold = ((alternatingItemFont & FONT_BOLD) != 0);
                d.AlternatingItemStyle.Font.Italic = ((alternatingItemFont & FONT_ITALIC) != 0);
                d.SelectedItemStyle.ForeColor = ColorTranslator.FromHtml(selectedItemForeColor);
                d.SelectedItemStyle.BackColor = ColorTranslator.FromHtml(selectedItemBackColor);
                d.SelectedItemStyle.Font.Bold = ((selectedItemFont & FONT_BOLD) != 0);
                d.SelectedItemStyle.Font.Italic = ((selectedItemFont & FONT_ITALIC) != 0);
            }

            protected override string CreatePreviewHTML() {
                StringBuilder sb = new StringBuilder(512);

                sb.Append("<table style=\"");
                if (foreColor != null)
                    sb.Append("color:" + foreColor + ";");
                if (backColor != null)
                    sb.Append("background-color:" + backColor + ";");
                if (cellSpacing == 0)
                    sb.Append("border-collapse:collapse;");
                if ((borderStyle > 0) && (borderStyle <= 9)) {
                    sb.Append("border-style:");
                    sb.Append(Enum.Format(typeof(BorderStyle), (BorderStyle)borderStyle, "G"));
                }
                sb.Append('"');
                if (cellSpacing != -1)
                    sb.Append(" cellspacing=" + (cellSpacing).ToString());
                if (cellPadding != -1)
                    sb.Append(" cellpadding=" + (cellPadding).ToString());
                if (borderWidth != null)
                    sb.Append(" border=" + borderWidth);
                if (borderColor != null)
                    sb.Append(" bordercolor=" + borderColor);
                sb.Append(" rules=");
                switch (gridLines) {
                    case 1: sb.Append("rows"); break;
                    case 2: sb.Append("cols"); break;
                    case 3: sb.Append("all"); break;
                    case 0:
                    default:sb.Append("none"); break;
                }

                sb.Append('>');
                
                // header
                sb.Append("<tr style=\"");
                if ((headerFont & FONT_BOLD) != 0)
                    sb.Append("font-weight:bold;");
                if ((headerFont & FONT_ITALIC) != 0)
                    sb.Append("font-style:italic;");
                if (headerForeColor != null)
                    sb.Append("color:" + headerForeColor + ";");
                if (headerBackColor != null)
                    sb.Append("background-color:" + headerBackColor);
                sb.Append("\"><td align=center>");
                sb.Append(SR.GetString(SR.BDLAF_Header));
                sb.Append("</td></tr>");

                for (int i = 0; i < 3; i++) {
                    if (i != 1) {
                        // item
                        sb.Append("<tr style=\"");
                        if ((itemFont & FONT_BOLD) != 0)
                            sb.Append("font-weight:bold;");
                        if ((itemFont & FONT_ITALIC) != 0)
                            sb.Append("font-style:italic;");
                        if (itemForeColor != null)
                            sb.Append("color:" + itemForeColor + ";");
                        if (itemBackColor != null)
                            sb.Append("background-color:" + itemBackColor);
                        sb.Append("\">");
                        sb.Append("<td align=center>####</td>");
                        sb.Append("</tr>");
                    }
                    else {
                        // selected item
                        sb.Append("<tr style=\"");
                        if (((selectedItemFont & FONT_BOLD) != 0) || ((itemFont & FONT_BOLD) != 0))
                            sb.Append("font-weight:bold;");
                        if (((selectedItemFont & FONT_ITALIC) != 0) || ((itemFont & FONT_ITALIC) != 0))
                            sb.Append("font-style:italic;");
                        if (selectedItemForeColor != null) {
                            sb.Append("color:" + selectedItemForeColor + ";");
                        }
                        else if (itemForeColor != null) {
                            sb.Append("color:" + itemForeColor + ";");
                        }
                        if (selectedItemBackColor != null) {
                            sb.Append("background-color:" + selectedItemBackColor);
                        }
                        else if (itemBackColor != null) {
                            sb.Append("background-color:" + itemBackColor);
                        }
                        sb.Append("\">");
                        sb.Append("<td align=center>####</td>");
                        sb.Append("</tr>");
                    }

                    if (i != 2) {
                        // alternating item
                        sb.Append("<tr style=\"");
                        if (((alternatingItemFont & FONT_BOLD) != 0) || ((itemFont & FONT_BOLD) != 0))
                            sb.Append("font-weight:bold;");
                        if (((alternatingItemFont & FONT_ITALIC) != 0) || ((itemFont & FONT_ITALIC) != 0))
                            sb.Append("font-style:italic;");
                        if (alternatingItemForeColor != null) {
                            sb.Append("color:" + alternatingItemForeColor + ";");
                        }
                        else if (itemForeColor != null) {
                            sb.Append("color:" + itemForeColor + ";");
                        }
                        if (alternatingItemBackColor != null) {
                            sb.Append("background-color:" + alternatingItemBackColor);
                        }
                        else if (itemBackColor != null) {
                            sb.Append("background-color:" + itemBackColor);
                        }
                        sb.Append("\">");
                        sb.Append("<td align=center>####</td>");
                        sb.Append("</tr>");
                    }
                }

                // footer
                sb.Append("<tr style=\"");
                if ((footerFont & FONT_BOLD) != 0)
                    sb.Append("font-weight:bold;");
                if ((footerFont & FONT_ITALIC) != 0)
                    sb.Append("font-style:italic;");
                if (footerForeColor != null)
                    sb.Append("color:" + footerForeColor + ";");
                if (footerBackColor != null)
                    sb.Append("background-color:" + footerBackColor);
                sb.Append("\"><td align=center>");
                sb.Append(SR.GetString(SR.BDLAF_Footer));
                sb.Append("</td></tr>");
                
                sb.Append("</table>");

                return sb.ToString();
            }

            public static DataListScheme[] LoadSchemes() {
                if (DataListScheme.schemes == null) {
                    try {
                        DataSet ds = new DataSet();
                        ds.Locale = CultureInfo.InvariantCulture;
                        ds.ReadXml(new XmlTextReader(new StringReader(SCHEMES)));

                        Debug.Assert((ds.Tables.Count == 1) && (ds.Tables[0].TableName.Equals("Scheme")),
                                    "Unexpected tables in schemes dataset");

                        DataTable schemeTable = ds.Tables[0];
                        DataRowCollection schemeRows = schemeTable.Rows;

                        Debug.Assert((schemeRows != null) && (schemeRows.Count != 0),
                                    "Expected schemes in scheme table");

                        int schemeCount = schemeRows.Count;
                        DataListScheme.schemes = new DataListScheme[schemeCount];

                        for (int i = 0; i < schemeCount; i++) {
                            schemes[i] = new DataListScheme(schemeRows[i]);
                        }
                    } catch(Exception e) {
                        Debug.Fail(e.ToString());
                    }
                }
                return DataListScheme.schemes;
            }
        }


        internal const string SCHEMES =
        @"<Schemes>
            <xsd:schema id=""Schemes"" xmlns="""" xmlns:xsd=""http://www.w3.org/2001/XMLSchema"" xmlns:msdata=""urn:schemas-microsoft-com:xml-msdata"">
              <xsd:element name=""Scheme"">
                <xsd:complexType>
                  <xsd:all>
                    <xsd:element name=""SchemeName"" type=""xsd:string""/>
                    <xsd:element name=""ForeColor"" minOccurs=""0"" type=""xsd:string""/>
                    <xsd:element name=""BackColor"" minOccurs=""0"" type=""xsd:string""/>
                    <xsd:element name=""BorderColor"" minOccurs=""0"" type=""xsd:string""/>
                    <xsd:element name=""BorderWidth"" minOccurs=""0"" type=""xsd:string""/>
                    <xsd:element name=""BorderStyle"" minOccurs=""0"" type=""xsd:string""/>
                    <xsd:element name=""GridLines"" minOccurs=""0"" type=""xsd:string""/>
                    <xsd:element name=""CellPadding"" minOccurs=""0"" type=""xsd:string""/>
                    <xsd:element name=""CellSpacing"" minOccurs=""0"" type=""xsd:string""/>
                    <xsd:element name=""ItemForeColor"" minOccurs=""0"" type=""xsd:string""/>
                    <xsd:element name=""ItemBackColor"" minOccurs=""0"" type=""xsd:string""/>
                    <xsd:element name=""ItemFont"" minOccurs=""0"" type=""xsd:string""/>
                    <xsd:element name=""AltItemForeColor"" minOccurs=""0"" type=""xsd:string""/>
                    <xsd:element name=""AltItemBackColor"" minOccurs=""0"" type=""xsd:string""/>
                    <xsd:element name=""AltItemFont"" minOccurs=""0"" type=""xsd:string""/>
                    <xsd:element name=""SelItemForeColor"" minOccurs=""0"" type=""xsd:string""/>
                    <xsd:element name=""SelItemBackColor"" minOccurs=""0"" type=""xsd:string""/>
                    <xsd:element name=""SelItemFont"" minOccurs=""0"" type=""xsd:string""/>
                    <xsd:element name=""HeaderForeColor"" minOccurs=""0"" type=""xsd:string""/>
                    <xsd:element name=""HeaderBackColor"" minOccurs=""0"" type=""xsd:string""/>
                    <xsd:element name=""HeaderFont"" minOccurs=""0"" type=""xsd:string""/>
                    <xsd:element name=""FooterForeColor"" minOccurs=""0"" type=""xsd:string""/>
                    <xsd:element name=""FooterBackColor"" minOccurs=""0"" type=""xsd:string""/>
                    <xsd:element name=""FooterFont"" minOccurs=""0"" type=""xsd:string""/>
                    <xsd:element name=""PagerForeColor"" minOccurs=""0"" type=""xsd:string""/>
                    <xsd:element name=""PagerBackColor"" minOccurs=""0"" type=""xsd:string""/>
                    <xsd:element name=""PagerFont"" minOccurs=""0"" type=""xsd:string""/>
                    <xsd:element name=""PagerAlign"" minOccurs=""0"" type=""xsd:string""/>
                    <xsd:element name=""PagerMode"" minOccurs=""0"" type=""xsd:string""/>
                  </xsd:all>
                </xsd:complexType>
              </xsd:element>
              <xsd:element name=""Schemes"" msdata:IsDataSet=""true"">
                <xsd:complexType>
                  <xsd:choice maxOccurs=""unbounded"">
                    <xsd:element ref=""Scheme""/>
                  </xsd:choice>
                </xsd:complexType>
              </xsd:element>
            </xsd:schema>
            <Scheme>
              <SchemeName>BDLScheme_Empty</SchemeName>
            </Scheme>
            <Scheme>
              <SchemeName>BDLScheme_Colorful1</SchemeName>
              <BackColor>White</BackColor>
              <BorderColor>#CC9966</BorderColor>
              <BorderWidth>1px</BorderWidth>
              <BorderStyle>1</BorderStyle>
              <GridLines>3</GridLines>
              <CellPadding>4</CellPadding>
              <CellSpacing>0</CellSpacing>
              <ItemForeColor>#330099</ItemForeColor>
              <ItemBackColor>White</ItemBackColor>
              <SelItemForeColor>#663399</SelItemForeColor>
              <SelItemBackColor>#FFCC66</SelItemBackColor>
              <SelItemFont>1</SelItemFont>
              <HeaderForeColor>#FFFFCC</HeaderForeColor>
              <HeaderBackColor>#990000</HeaderBackColor>
              <HeaderFont>1</HeaderFont>
              <FooterForeColor>#330099</FooterForeColor>
              <FooterBackColor>#FFFFCC</FooterBackColor>
              <PagerForeColor>#330099</PagerForeColor>
              <PagerBackColor>#FFFFCC</PagerBackColor>
              <PagerAlign>2</PagerAlign>
            </Scheme>
            <Scheme>
              <SchemeName>BDLScheme_Colorful2</SchemeName>
              <BackColor>White</BackColor>
              <BorderColor>#3366CC</BorderColor>
              <BorderWidth>1px</BorderWidth>
              <BorderStyle>1</BorderStyle>
              <GridLines>3</GridLines>
              <CellPadding>4</CellPadding>
              <CellSpacing>0</CellSpacing>
              <ItemForeColor>#003399</ItemForeColor>
              <ItemBackColor>White</ItemBackColor>
              <SelItemForeColor>#CCFF99</SelItemForeColor>
              <SelItemBackColor>#009999</SelItemBackColor>
              <SelItemFont>1</SelItemFont>
              <HeaderForeColor>#CCCCFF</HeaderForeColor>
              <HeaderBackColor>#003399</HeaderBackColor>
              <HeaderFont>1</HeaderFont>
              <FooterForeColor>#003399</FooterForeColor>
              <FooterBackColor>#99CCCC</FooterBackColor>
              <PagerForeColor>#003399</PagerForeColor>
              <PagerBackColor>#99CCCC</PagerBackColor>
              <PagerAlign>1</PagerAlign>
              <PagerMode>1</PagerMode>
            </Scheme>
            <Scheme>
              <SchemeName>BDLScheme_Colorful3</SchemeName>
              <BackColor>#DEBA84</BackColor>
              <BorderColor>#DEBA84</BorderColor>
              <BorderWidth>1px</BorderWidth>
              <BorderStyle>1</BorderStyle>
              <GridLines>3</GridLines>
              <CellPadding>3</CellPadding>
              <CellSpacing>2</CellSpacing>
              <ItemForeColor>#8C4510</ItemForeColor>
              <ItemBackColor>#FFF7E7</ItemBackColor>
              <SelItemForeColor>White</SelItemForeColor>
              <SelItemBackColor>#738A9C</SelItemBackColor>
              <SelItemFont>1</SelItemFont>
              <HeaderForeColor>White</HeaderForeColor>
              <HeaderBackColor>#A55129</HeaderBackColor>
              <HeaderFont>1</HeaderFont>
              <FooterForeColor>#8C4510</FooterForeColor>
              <FooterBackColor>#F7DFB5</FooterBackColor>
              <PagerForeColor>#8C4510</PagerForeColor>
              <PagerAlign>2</PagerAlign>
              <PagerMode>1</PagerMode>
            </Scheme>
            <Scheme>
              <SchemeName>BDLScheme_Colorful4</SchemeName>
              <BackColor>White</BackColor>
              <BorderColor>#E7E7FF</BorderColor>
              <BorderWidth>1px</BorderWidth>
              <BorderStyle>1</BorderStyle>
              <GridLines>1</GridLines>
              <CellPadding>3</CellPadding>
              <CellSpacing>0</CellSpacing>
              <ItemForeColor>#4A3C8C</ItemForeColor>
              <ItemBackColor>#E7E7FF</ItemBackColor>
              <AltItemBackColor>#F7F7F7</AltItemBackColor>
              <SelItemForeColor>#F7F7F7</SelItemForeColor>
              <SelItemBackColor>#738A9C</SelItemBackColor>
              <SelItemFont>1</SelItemFont>
              <HeaderForeColor>#F7F7F7</HeaderForeColor>
              <HeaderBackColor>#4A3C8C</HeaderBackColor>
              <HeaderFont>1</HeaderFont>
              <FooterForeColor>#4A3C8C</FooterForeColor>
              <FooterBackColor>#B5C7DE</FooterBackColor>
              <PagerForeColor>#4A3C8C</PagerForeColor>
              <PagerBackColor>#E7E7FF</PagerBackColor>
              <PagerAlign>3</PagerAlign>
              <PagerMode>1</PagerMode>
            </Scheme>
            <Scheme>
              <SchemeName>BDLScheme_Colorful5</SchemeName>
              <ForeColor>Black</ForeColor>
              <BackColor>LightGoldenRodYellow</BackColor>
              <BorderColor>Tan</BorderColor>
              <BorderWidth>1px</BorderWidth>
              <GridLines>0</GridLines>
              <CellPadding>2</CellPadding>
              <AltItemBackColor>PaleGoldenRod</AltItemBackColor>
              <HeaderBackColor>Tan</HeaderBackColor>
              <HeaderFont>1</HeaderFont>
              <FooterBackColor>Tan</FooterBackColor>
              <SelItemBackColor>DarkSlateBlue</SelItemBackColor>
              <SelItemForeColor>GhostWhite</SelItemForeColor>
              <PagerBackColor>PaleGoldenrod</PagerBackColor>
              <PagerForeColor>DarkSlateBlue</PagerForeColor>
              <PagerAlign>2</PagerAlign>
            </Scheme>
            <Scheme>
              <SchemeName>BDLScheme_Professional1</SchemeName>
              <BackColor>White</BackColor>
              <BorderColor>#999999</BorderColor>
              <BorderWidth>1px</BorderWidth>
              <BorderStyle>1</BorderStyle>
              <GridLines>2</GridLines>
              <CellPadding>3</CellPadding>
              <CellSpacing>0</CellSpacing>
              <ItemForeColor>Black</ItemForeColor>
              <ItemBackColor>#EEEEEE</ItemBackColor>
              <AltItemBackColor>#DCDCDC</AltItemBackColor>
              <SelItemForeColor>White</SelItemForeColor>
              <SelItemBackColor>#008A8C</SelItemBackColor>
              <SelItemFont>1</SelItemFont>
              <HeaderForeColor>White</HeaderForeColor>
              <HeaderBackColor>#000084</HeaderBackColor>
              <HeaderFont>1</HeaderFont>
              <FooterForeColor>Black</FooterForeColor>
              <FooterBackColor>#CCCCCC</FooterBackColor>
              <PagerForeColor>Black</PagerForeColor>
              <PagerBackColor>#999999</PagerBackColor>
              <PagerAlign>2</PagerAlign>
              <PagerMode>1</PagerMode>
            </Scheme>
            <Scheme>
              <SchemeName>BDLScheme_Professional2</SchemeName>
              <BackColor>White</BackColor>
              <BorderColor>#CCCCCC</BorderColor>
              <BorderWidth>1px</BorderWidth>
              <BorderStyle>1</BorderStyle>
              <GridLines>3</GridLines>
              <CellPadding>3</CellPadding>
              <CellSpacing>0</CellSpacing>
              <ItemForeColor>#000066</ItemForeColor>
              <SelItemForeColor>White</SelItemForeColor>
              <SelItemBackColor>#669999</SelItemBackColor>
              <SelItemFont>1</SelItemFont>
              <HeaderForeColor>White</HeaderForeColor>
              <HeaderBackColor>#006699</HeaderBackColor>
              <HeaderFont>1</HeaderFont>
              <FooterForeColor>#000066</FooterForeColor>
              <FooterBackColor>White</FooterBackColor>
              <PagerForeColor>#000066</PagerForeColor>
              <PagerBackColor>White</PagerBackColor>
              <PagerAlign>1</PagerAlign>
              <PagerMode>1</PagerMode>
            </Scheme>
            <Scheme>
              <SchemeName>BDLScheme_Professional3</SchemeName>
              <BackColor>White</BackColor>
              <BorderColor>White</BorderColor>
              <BorderWidth>2px</BorderWidth>
              <BorderStyle>7</BorderStyle>
              <GridLines>0</GridLines>
              <CellPadding>3</CellPadding>
              <CellSpacing>1</CellSpacing>
              <ItemForeColor>Black</ItemForeColor>
              <ItemBackColor>#DEDFDE</ItemBackColor>
              <SelItemForeColor>White</SelItemForeColor>
              <SelItemBackColor>#9471DE</SelItemBackColor>
              <SelItemFont>1</SelItemFont>
              <HeaderForeColor>#E7E7FF</HeaderForeColor>
              <HeaderBackColor>#4A3C8C</HeaderBackColor>
              <HeaderFont>1</HeaderFont>
              <FooterForeColor>Black</FooterForeColor>
              <FooterBackColor>#C6C3C6</FooterBackColor>
              <PagerForeColor>Black</PagerForeColor>
              <PagerBackColor>#C6C3C6</PagerBackColor>
              <PagerAlign>3</PagerAlign>
            </Scheme>
            <Scheme>
              <SchemeName>BDLScheme_Simple1</SchemeName>
              <ForeColor>Black</ForeColor>
              <BackColor>White</BackColor>
              <BorderColor>#999999</BorderColor>
              <BorderWidth>1px</BorderWidth>
              <BorderStyle>4</BorderStyle>
              <GridLines>2</GridLines>
              <CellPadding>3</CellPadding>
              <CellSpacing>0</CellSpacing>
              <AltItemBackColor>#CCCCCC</AltItemBackColor>
              <SelItemForeColor>White</SelItemForeColor>
              <SelItemBackColor>#000099</SelItemBackColor>
              <SelItemFont>1</SelItemFont>
              <HeaderForeColor>White</HeaderForeColor>
              <HeaderBackColor>Black</HeaderBackColor>
              <HeaderFont>1</HeaderFont>
              <FooterBackColor>#CCCCCC</FooterBackColor>
              <PagerForeColor>Black</PagerForeColor>
              <PagerBackColor>#999999</PagerBackColor>
              <PagerAlign>2</PagerAlign>
            </Scheme>
            <Scheme>
              <SchemeName>BDLScheme_Simple2</SchemeName>
              <ForeColor>Black</ForeColor>
              <BackColor>#CCCCCC</BackColor>
              <BorderColor>#999999</BorderColor>
              <BorderWidth>3px</BorderWidth>
              <BorderStyle>4</BorderStyle>
              <GridLines>3</GridLines>
              <CellPadding>4</CellPadding>
              <CellSpacing>2</CellSpacing>
              <ItemBackColor>White</ItemBackColor>
              <SelItemForeColor>White</SelItemForeColor>
              <SelItemBackColor>#000099</SelItemBackColor>
              <SelItemFont>1</SelItemFont>
              <HeaderForeColor>White</HeaderForeColor>
              <HeaderBackColor>Black</HeaderBackColor>
              <HeaderFont>1</HeaderFont>
              <FooterBackColor>#CCCCCC</FooterBackColor>
              <PagerForeColor>Black</PagerForeColor>
              <PagerBackColor>#CCCCCC</PagerBackColor>
              <PagerAlign>1</PagerAlign>
              <PagerMode>1</PagerMode>
            </Scheme>
            <Scheme>
              <SchemeName>BDLScheme_Simple3</SchemeName>
              <BackColor>White</BackColor>
              <BorderColor>#336666</BorderColor>
              <BorderWidth>3px</BorderWidth>
              <BorderStyle>5</BorderStyle>
              <GridLines>1</GridLines>
              <CellPadding>4</CellPadding>
              <CellSpacing>0</CellSpacing>
              <ItemForeColor>#333333</ItemForeColor>
              <ItemBackColor>White</ItemBackColor>
              <SelItemForeColor>White</SelItemForeColor>
              <SelItemBackColor>#339966</SelItemBackColor>
              <SelItemFont>1</SelItemFont>
              <HeaderForeColor>White</HeaderForeColor>
              <HeaderBackColor>#336666</HeaderBackColor>
              <HeaderFont>1</HeaderFont>
              <FooterForeColor>#333333</FooterForeColor>
              <FooterBackColor>White</FooterBackColor>
              <PagerForeColor>White</PagerForeColor>
              <PagerBackColor>#336666</PagerBackColor>
              <PagerAlign>2</PagerAlign>
              <PagerMode>1</PagerMode>
            </Scheme>
            <Scheme>
              <SchemeName>BDLScheme_Classic1</SchemeName>
              <ForeColor>Black</ForeColor>
              <BackColor>White</BackColor>
              <BorderColor>#CCCCCC</BorderColor>
              <BorderWidth>1px</BorderWidth>
              <BorderStyle>1</BorderStyle>
              <GridLines>1</GridLines>
              <CellPadding>4</CellPadding>
              <CellSpacing>0</CellSpacing>
              <SelItemForeColor>White</SelItemForeColor>
              <SelItemBackColor>#CC3333</SelItemBackColor>
              <SelItemFont>1</SelItemFont>
              <HeaderForeColor>White</HeaderForeColor>
              <HeaderBackColor>#333333</HeaderBackColor>
              <HeaderFont>1</HeaderFont>
              <FooterForeColor>Black</FooterForeColor>
              <FooterBackColor>#CCCC99</FooterBackColor>
              <PagerForeColor>Black</PagerForeColor>
              <PagerBackColor>White</PagerBackColor>
              <PagerAlign>3</PagerAlign>
            </Scheme>
            <Scheme>
              <SchemeName>BDLScheme_Classic2</SchemeName>
              <ForeColor>Black</ForeColor>
              <BackColor>White</BackColor>
              <BorderColor>#DEDFDE</BorderColor>
              <BorderWidth>1px</BorderWidth>
              <BorderStyle>1</BorderStyle>
              <GridLines>2</GridLines>
              <CellPadding>4</CellPadding>
              <CellSpacing>0</CellSpacing>
              <ItemBackColor>#F7F7DE</ItemBackColor>
              <AltItemBackColor>White</AltItemBackColor>
              <SelItemForeColor>White</SelItemForeColor>
              <SelItemBackColor>#CE5D5A</SelItemBackColor>
              <SelItemFont>1</SelItemFont>
              <HeaderForeColor>White</HeaderForeColor>
              <HeaderBackColor>#6B696B</HeaderBackColor>
              <HeaderFont>1</HeaderFont>
              <FooterBackColor>#CCCC99</FooterBackColor>
              <PagerForeColor>Black</PagerForeColor>
              <PagerBackColor>#F7F7DE</PagerBackColor>
              <PagerAlign>3</PagerAlign>
              <PagerMode>1</PagerMode>
            </Scheme>
          </Schemes>";

/*
            <Scheme>
              <SchemeName>BDLScheme_Default</SchemeName>
              <ForeColor>Black</ForeColor>
              <BackColor>Silver</BackColor>
              <BorderWidth>1px</BorderWidth>
              <CellPadding>2</CellPadding>
              <ItemBackColor>White</ItemBackColor>
              <AltItemBackColor>Gainsboro</AltItemBackColor>
              <FooterForeColor>White</FooterForeColor>
              <FooterBackColor>Silver</FooterBackColor>
              <HeaderBackColor>Navy</HeaderBackColor>
              <HeaderForeColor>White</HeaderForeColor>
              <HeaderFont>1</HeaderFont>
            </Scheme>
            <Scheme>
              <SchemeName>Colorful 1</SchemeName>
              <ForeColor>DarkSlateBlue</ForeColor>
              <BackColor>White</BackColor>
              <BorderColor>Tan</BorderColor>
              <BorderWidth>1px</BorderWidth>
              <BorderStyle>4</BorderStyle>
              <GridLines>3</GridLines>
              <CellPadding>2</CellPadding>
              <CellSpacing>0</CellSpacing>
              <AltItemBackColor>Beige</AltItemBackColor>
              <SelItemBackColor>PaleGoldenRod</SelItemBackColor>
              <SelItemFont>2</SelItemFont>
              <HeaderForeColor>White</HeaderForeColor>
              <HeaderBackColor>DarkRed</HeaderBackColor>
              <HeaderFont>1</HeaderFont>
              <FooterBackColor>Tan</FooterBackColor>
            </Scheme>
*/    
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\webcontrols\listcontrols\borderspage.cs ===
//------------------------------------------------------------------------------
// <copyright file="BordersPage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   BordersPage.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
    using System.Design;
//------------------------------------------------------------------------------
// <copyright file="BordersPage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.WebControls.ListControls {

    using System;
    using System.Design;
    using System.Collections;
    using System.Globalization;
    using System.ComponentModel;
    using System.Drawing;
    
    using System.Diagnostics;
    using System.Web.UI.Design.Util;
    using System.Web.UI.WebControls;
    using System.Windows.Forms;

    using WebControls = System.Web.UI.WebControls;
    using DataGrid = System.Web.UI.WebControls.DataGrid;

    using Button = System.Windows.Forms.Button;
    using CheckBox = System.Windows.Forms.CheckBox;
    using Label = System.Windows.Forms.Label;

    /// <include file='doc\BordersPage.uex' path='docs/doc[@for="BordersPage"]/*' />
    /// <devdoc>
    ///   The Borders page for the DataGrid and DataList controls
    /// </devdoc>
    /// <internalonly/>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal sealed class BordersPage : BaseDataListPage {

        private const int IDX_GRID_HORIZONTAL = 0;
        private const int IDX_GRID_VERTICAL = 1;
        private const int IDX_GRID_BOTH = 2;
        private const int IDX_GRID_NEITHER = 3;

        private NumberEdit cellPaddingEdit;
        private NumberEdit cellSpacingEdit;
        private ComboBox gridLinesCombo;
        private ColorComboBox borderColorCombo;
        private Button borderColorPickerButton;
        private UnitControl borderWidthUnit;

        /// <include file='doc\BordersPage.uex' path='docs/doc[@for="BordersPage.BordersPage"]/*' />
        /// <devdoc>
        ///   Creates a new instance of BordersPage.
        /// </devdoc>
        public BordersPage() : base() {
        }

        /// <include file='doc\BordersPage.uex' path='docs/doc[@for="BordersPage.HelpKeyword"]/*' />
        protected override string HelpKeyword {
            get {
                if (IsDataGridMode) {
                    return "net.Asp.DataGridProperties.Borders";
                }
                else {
                    return "net.Asp.DataListProperties.Borders";
                }
            }
        }

        /// <include file='doc\BordersPage.uex' path='docs/doc[@for="BordersPage.InitForm"]/*' />
        /// <devdoc>
        ///    Creates the UI of the page.
        /// </devdoc>
        private void InitForm() {
            GroupLabel cellMarginGroup = new GroupLabel();
            Label cellPaddingLabel = new Label();
            this.cellPaddingEdit = new NumberEdit();
            Label cellSpacingLabel = new Label();
            this.cellSpacingEdit = new NumberEdit();
            GroupLabel borderLinesGroup = new GroupLabel();
            Label gridLinesLabel = new Label();
            this.gridLinesCombo = new ComboBox();
            Label colorLabel = new Label();
            this.borderColorCombo = new ColorComboBox();
            this.borderColorPickerButton = new Button();
            Label borderWidthLabel = new Label();
            this.borderWidthUnit = new UnitControl();

            cellMarginGroup.SetBounds(4, 4, 300, 16);
            cellMarginGroup.Text = SR.GetString(SR.BDLBor_CellMarginsGroup);
            cellMarginGroup.TabStop = false;
            cellMarginGroup.TabIndex = 0;

            cellPaddingLabel.Text = SR.GetString(SR.BDLBor_CellPadding);
            cellPaddingLabel.SetBounds(12, 24, 120, 14);
            cellPaddingLabel.TabStop = false;
            cellPaddingLabel.TabIndex = 1;

            cellPaddingEdit.SetBounds(12, 40, 70, 20);
            cellPaddingEdit.AllowDecimal = false;
            cellPaddingEdit.AllowNegative = false;
            cellPaddingEdit.TabIndex = 2;
            cellPaddingEdit.TextChanged += new EventHandler(this.OnBordersChanged);

            cellSpacingLabel.Text = SR.GetString(SR.BDLBor_CellSpacing);
            cellSpacingLabel.SetBounds(160, 24, 120, 14);
            cellSpacingLabel.TabStop = false;
            cellSpacingLabel.TabIndex = 3;

            cellSpacingEdit.SetBounds(160, 40, 70, 20);
            cellSpacingEdit.AllowDecimal = false;
            cellSpacingEdit.AllowNegative = false;
            cellSpacingEdit.TabIndex = 4;
            cellSpacingEdit.TextChanged += new EventHandler(this.OnBordersChanged);

            borderLinesGroup.SetBounds(4, 70, 300, 16);
            borderLinesGroup.Text = SR.GetString(SR.BDLBor_BorderLinesGroup);
            borderLinesGroup.TabStop = false;
            borderLinesGroup.TabIndex = 5;

            gridLinesLabel.Text = SR.GetString(SR.BDLBor_GridLines);
            gridLinesLabel.SetBounds(12, 90, 150, 14);
            gridLinesLabel.TabStop = false;
            gridLinesLabel.TabIndex = 6;

            gridLinesCombo.SetBounds(12, 106, 140, 21);
            gridLinesCombo.DropDownStyle = ComboBoxStyle.DropDownList;
            gridLinesCombo.Items.Clear();
            gridLinesCombo.Items.AddRange(new object[] {
                                           SR.GetString(SR.BDLBor_GL_Horz),
                                           SR.GetString(SR.BDLBor_GL_Vert),
                                           SR.GetString(SR.BDLBor_GL_Both),
                                           SR.GetString(SR.BDLBor_GL_None)
                                       });
            gridLinesCombo.TabIndex = 7;
            gridLinesCombo.SelectedIndexChanged += new EventHandler(this.OnBordersChanged);

            colorLabel.Text = SR.GetString(SR.BDLBor_BorderColor);
            colorLabel.SetBounds(12, 134, 150, 14);
            colorLabel.TabStop = false;
            colorLabel.TabIndex = 8;

            borderColorCombo.SetBounds(12, 150, 140, 21);
            borderColorCombo.TabIndex = 9;
            borderColorCombo.TextChanged += new EventHandler(this.OnBordersChanged);
            borderColorCombo.SelectedIndexChanged += new EventHandler(this.OnBordersChanged);

            borderColorPickerButton.SetBounds(156, 149, 24, 22);
            borderColorPickerButton.Text = "...";
            borderColorPickerButton.TabIndex = 10;
            borderColorPickerButton.FlatStyle = FlatStyle.System;
            borderColorPickerButton.Click += new EventHandler(this.OnClickColorPicker);

            borderWidthLabel.Text = SR.GetString(SR.BDLBor_BorderWidth);
            borderWidthLabel.SetBounds(12, 178, 150, 14);
            borderWidthLabel.TabStop = false;
            borderWidthLabel.TabIndex = 11;

            borderWidthUnit.SetBounds(12, 194, 102, 22);
            borderWidthUnit.AllowNegativeValues = false;
            borderWidthUnit.AllowPercentValues = false;
            borderWidthUnit.DefaultUnit = UnitControl.UNIT_PX;
            borderWidthUnit.TabIndex = 12;
            borderWidthUnit.Changed += new EventHandler(OnBordersChanged);

            this.Text = SR.GetString(SR.BDLBor_Text);
            this.Size = new Size(308, 156);
            this.CommitOnDeactivate = true;
            this.Icon = new Icon(this.GetType(), "BordersPage.ico");

            this.Controls.Clear();
            this.Controls.AddRange(new Control[] {
                                    borderWidthUnit,
                                    borderWidthLabel,
                                    borderColorPickerButton,
                                    borderColorCombo,
                                    colorLabel,
                                    gridLinesCombo,
                                    gridLinesLabel,
                                    borderLinesGroup,
                                    cellSpacingEdit,
                                    cellSpacingLabel,
                                    cellPaddingEdit,
                                    cellPaddingLabel,
                                    cellMarginGroup
                                });
        }

        /// <include file='doc\BordersPage.uex' path='docs/doc[@for="BordersPage.InitPage"]/*' />
        /// <devdoc>
        ///   Initializes the page before it can be loaded with the component.
        /// </devdoc>
        private void InitPage() {
            cellPaddingEdit.Clear();
            cellSpacingEdit.Clear();
            gridLinesCombo.SelectedIndex = -1;
            borderColorCombo.Color = null;
            borderWidthUnit.Value = null;
        }

        /// <include file='doc\BordersPage.uex' path='docs/doc[@for="BordersPage.LoadComponent"]/*' />
        /// <devdoc>
        ///   Loads the component into the page.
        /// </devdoc>
        protected override void LoadComponent() {
            InitPage();

            BaseDataList bdl = (BaseDataList)GetBaseControl();

            int cellPadding = bdl.CellPadding;
            if (cellPadding != -1)
                cellPaddingEdit.Text = (cellPadding).ToString();
            int cellSpacing = bdl.CellSpacing;
            if (cellSpacing != -1)
                cellSpacingEdit.Text = (cellSpacing).ToString();

            switch (bdl.GridLines) {
                case GridLines.None:
                    gridLinesCombo.SelectedIndex = IDX_GRID_NEITHER;
                    break;
                case GridLines.Horizontal:
                    gridLinesCombo.SelectedIndex = IDX_GRID_HORIZONTAL;
                    break;
                case GridLines.Vertical:
                    gridLinesCombo.SelectedIndex = IDX_GRID_VERTICAL;
                    break;
                case GridLines.Both:
                    gridLinesCombo.SelectedIndex = IDX_GRID_BOTH;
                    break;
            }

            borderColorCombo.Color = ColorTranslator.ToHtml(bdl.BorderColor);
            borderWidthUnit.Value = bdl.BorderWidth.ToString();
        }

        /// <include file='doc\BordersPage.uex' path='docs/doc[@for="BordersPage.OnBordersChanged"]/*' />
        /// <devdoc>
        ///   Handles changes in the border settings.
        /// </devdoc>
        private void OnBordersChanged(object source, EventArgs e) {
            if (IsLoading())
                return;

            SetDirty();
        }

        /// <include file='doc\BordersPage.uex' path='docs/doc[@for="BordersPage.OnClickColorPicker"]/*' />
        /// <devdoc>
        ///   Invokes the color picker to pick the grid color.
        /// </devdoc>
        private void OnClickColorPicker(object source, EventArgs e) {
            string color = borderColorCombo.Color;

            color = ColorBuilder.BuildColor(GetBaseControl(), this, color);
            if (color != null) {
                borderColorCombo.Color = color;
                OnBordersChanged(borderColorCombo, EventArgs.Empty);
            }
        }

        /// <include file='doc\BordersPage.uex' path='docs/doc[@for="BordersPage.SaveComponent"]/*' />
        /// <devdoc>
        ///   Saves the component loaded into the page.
        /// </devdoc>
        protected override void SaveComponent() {
            BaseDataList bdl = (BaseDataList)GetBaseControl();

            try {
                string cellPadding = cellPaddingEdit.Text.Trim();
                if (cellPadding.Length != 0)
                    bdl.CellPadding = Int32.Parse(cellPadding, CultureInfo.InvariantCulture);
                else
                    bdl.CellPadding = -1;
            } catch (Exception) {
                if (bdl.CellPadding != -1) {
                    cellPaddingEdit.Text = (bdl.CellPadding).ToString();
                }
                else {
                    cellPaddingEdit.Clear();
                }
            }

            try {
                string cellSpacing = cellSpacingEdit.Text.Trim();
                if (cellSpacing.Length != 0)
                    bdl.CellSpacing = Int32.Parse(cellSpacing, CultureInfo.InvariantCulture);
                else
                    bdl.CellSpacing = -1;
            } catch (Exception) {
                if (bdl.CellSpacing != -1) {
                    cellSpacingEdit.Text = (bdl.CellSpacing).ToString();
                }
                else {
                    cellSpacingEdit.Clear();
                }
            }

            switch (gridLinesCombo.SelectedIndex) {
                case IDX_GRID_HORIZONTAL:
                    bdl.GridLines = GridLines.Horizontal;
                    break;
                case IDX_GRID_VERTICAL:
                    bdl.GridLines = GridLines.Vertical;
                    break;
                case IDX_GRID_BOTH:
                    bdl.GridLines = GridLines.Both;
                    break;
                case IDX_GRID_NEITHER:
                    bdl.GridLines = GridLines.None;
                    break;
            }

            try {
                string colorValue = borderColorCombo.Color;
                bdl.BorderColor = ColorTranslator.FromHtml(colorValue);
            } catch (Exception) {
                borderColorCombo.Color = ColorTranslator.ToHtml(bdl.BorderColor);
            }

            try {
                string borderWidth = borderWidthUnit.Value;
                Unit unitValue = Unit.Empty;
                if (borderWidth != null)
                    unitValue = Unit.Parse(borderWidth);
                bdl.BorderWidth = unitValue;
            } catch (Exception) {
                borderWidthUnit.Value = bdl.BorderWidth.ToString();
            }
        }

        /// <include file='doc\BordersPage.uex' path='docs/doc[@for="BordersPage.SetComponent"]/*' />
        /// <devdoc>
        ///   Sets the component that is to be edited in the page.
        /// </devdoc>
        public override void SetComponent(IComponent component) {
            base.SetComponent(component);
            InitForm();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\adornmenttype.cs ===
//------------------------------------------------------------------------------
// <copyright file="AdornmentType.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms.Design {
    using System.Diagnostics;
    using System;
    using System.ComponentModel;
    using Microsoft.Win32;

    /// <include file='doc\AdornmentType.uex' path='docs/doc[@for="AdornmentType"]/*' />
    /// <internalonly/>
    /// <devdoc>
    ///    <para>
    ///       Specifies
    ///       numeric IDs for different types of adornments on a component.
    ///    </para>
    /// </devdoc>
    internal enum AdornmentType {

        /// <include file='doc\AdornmentType.uex' path='docs/doc[@for="AdornmentType.GrabHandle"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies
        ///       the type as
        ///       grab handle adornments.
        ///    </para>
        /// </devdoc>
        GrabHandle  = 1,

        /// <include file='doc\AdornmentType.uex' path='docs/doc[@for="AdornmentType.ContainerSelector"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies
        ///       the type as
        ///       container selector adornments.
        ///    </para>
        /// </devdoc>
        ContainerSelector = 2,

        /// <include file='doc\AdornmentType.uex' path='docs/doc[@for="AdornmentType.Maximum"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies the
        ///       type as the
        ///       maximum size of any adornment.
        ///    </para>
        /// </devdoc>
        Maximum = 3,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\webcontrols\listcontrols\formatpage.cs ===
//------------------------------------------------------------------------------
// <copyright file="FormatPage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.WebControls.ListControls {

    using System;
    using System.Design;
    using System.Collections;
    using System.ComponentModel;
    using System.Drawing;
    
    using System.Diagnostics;
    using System.Web.UI.Design.Util;
    using System.Web.UI.WebControls;
    using System.Windows.Forms;

    using WebControls = System.Web.UI.WebControls;
    using DataList = System.Web.UI.WebControls.DataList;
    using DataGrid = System.Web.UI.WebControls.DataGrid;
    using DataGridColumn = System.Web.UI.WebControls.DataGridColumn;
    using DataGridColumnCollection = System.Web.UI.WebControls.DataGridColumnCollection;
    using HorizontalAlign = System.Web.UI.WebControls.HorizontalAlign;
    using VerticalAlign = System.Web.UI.WebControls.VerticalAlign;

    using Button = System.Windows.Forms.Button;
    using CheckBox = System.Windows.Forms.CheckBox;
    using Label = System.Windows.Forms.Label;
    using ListBox = System.Windows.Forms.ListBox;
    using Panel = System.Windows.Forms.Panel;

    /// <include file='doc\FormatPage.uex' path='docs/doc[@for="FormatPage"]/*' />
    /// <devdoc>
    ///   The Format page for the DataGrid and DataList controls
    /// </devdoc>
    /// <internalonly/>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal sealed class FormatPage : BaseDataListPage {

        private const int IDX_ENTIRE = 0;
        private const int IDX_PAGER = 1;

        private const int IDX_HEADER = 0;
        private const int IDX_FOOTER = 1;

        private const int IDX_ROW_NORMAL = 2;
        private const int IDX_ROW_ALT = 3;
        private const int IDX_ROW_SELECTED = 4;
        private const int IDX_ROW_EDIT = 5;
        private const int ROW_TYPE_COUNT = 6;

        private const int COL_ROW_TYPE_COUNT = 3;

        private const int IDX_ITEM_NORMAL = 2;
        private const int IDX_ITEM_ALT = 3;
        private const int IDX_ITEM_SELECTED = 4;
        private const int IDX_ITEM_EDIT = 5;
        private const int IDX_ITEM_SEPARATOR = 6;
        private const int ITEM_TYPE_COUNT = 7;

        private const int IDX_FSIZE_SMALLER = 1;
        private const int IDX_FSIZE_LARGER = 2;
        private const int IDX_FSIZE_XXSMALL = 3;
        private const int IDX_FSIZE_XSMALL = 4;
        private const int IDX_FSIZE_SMALL = 5;
        private const int IDX_FSIZE_MEDIUM = 6;
        private const int IDX_FSIZE_LARGE = 7;
        private const int IDX_FSIZE_XLARGE = 8;
        private const int IDX_FSIZE_XXLARGE = 9;
        private const int IDX_FSIZE_CUSTOM = 10;

        private const int IDX_HALIGN_NOTSET = 0;
        private const int IDX_HALIGN_LEFT = 1;
        private const int IDX_HALIGN_CENTER = 2;
        private const int IDX_HALIGN_RIGHT = 3;
        private const int IDX_HALIGN_JUSTIFY = 4;

        private const int IDX_VALIGN_NOTSET = 0;
        private const int IDX_VALIGN_TOP = 1;
        private const int IDX_VALIGN_MIDDLE = 2;
        private const int IDX_VALIGN_BOTTOM = 3;

        private TreeView formatTree;
        private Panel stylePanel;
        private ColorComboBox foreColorCombo;
        private Button foreColorPickerButton;
        private ColorComboBox backColorCombo;
        private Button backColorPickerButton;
        private ComboBox fontNameCombo;
        private UnsettableComboBox fontSizeCombo;
        private UnitControl fontSizeUnit;
        private CheckBox boldCheck;
        private CheckBox italicCheck;
        private CheckBox underlineCheck;
        private CheckBox strikeOutCheck;
        private CheckBox overlineCheck;
        private Panel columnPanel;
        private UnitControl widthUnit;
        private CheckBox allowWrappingCheck;
        private UnsettableComboBox horzAlignCombo;
        private Label vertAlignLabel;
        private UnsettableComboBox vertAlignCombo;

        private FormatObject currentFormatObject;
        private FormatTreeNode currentFormatNode;
        private bool propChangesPending;
        private bool fontNameChanged;

        private ArrayList formatNodes;

        /// <include file='doc\FormatPage.uex' path='docs/doc[@for="FormatPage.FormatPage"]/*' />
        /// <devdoc>
        ///   Creates a new instance of FormatPage.
        /// </devdoc>
        public FormatPage() : base() {
        }

        /// <include file='doc\FormatPage.uex' path='docs/doc[@for="FormatPage.HelpKeyword"]/*' />
        protected override string HelpKeyword {
            get {
                if (IsDataGridMode) {
                    return "net.Asp.DataGridProperties.Format";
                }
                else {
                    return "net.Asp.DataListProperties.Format";
                }
            }
        }

        /// <include file='doc\FormatPage.uex' path='docs/doc[@for="FormatPage.InitFontList"]/*' />
        /// <devdoc>
        ///    Loads the list of fonts into the font dropdown
        /// </devdoc>
        private void InitFontList() {
            try {
                FontFamily[] families = FontFamily.Families;

                for (int i = 0; i < families.Length; i++) {
                    if ((fontNameCombo.Items.Count == 0) ||
                        (fontNameCombo.FindStringExact(families[i].Name) == ListBox.NoMatches))
                        fontNameCombo.Items.Add(families[i].Name);
                }
            }
            catch (Exception e) {
                Debug.Fail(e.ToString());
            }
        }

        /// <include file='doc\FormatPage.uex' path='docs/doc[@for="FormatPage.InitForm"]/*' />
        /// <devdoc>
        ///   Initializes the UI of the form.
        /// </devdoc>
        private void InitForm() {
            Label formatObjLabel = new Label();
            this.formatTree = new TreeView();
            this.stylePanel = new Panel();
            GroupLabel appearanceGroup = new GroupLabel();
            Label foreColorLabel = new Label();
            this.foreColorCombo = new ColorComboBox();
            this.foreColorPickerButton = new Button();
            Label backColorLabel = new Label();
            this.backColorCombo = new ColorComboBox();
            this.backColorPickerButton = new Button();
            Label fontNameLabel = new Label();
            this.fontNameCombo = new ComboBox();
            Label fontSizeLabel = new Label();
            this.fontSizeCombo = new UnsettableComboBox();
            this.fontSizeUnit = new UnitControl();
            this.boldCheck = new CheckBox();
            this.italicCheck = new CheckBox();
            this.underlineCheck = new CheckBox();
            this.strikeOutCheck = new CheckBox();
            this.overlineCheck = new CheckBox();
            GroupLabel alignmentGroup = new GroupLabel();
            Label horzAlignLabel = new Label();
            this.horzAlignCombo = new UnsettableComboBox();
            this. vertAlignLabel = new Label();
            this.vertAlignCombo = new UnsettableComboBox();
            this.allowWrappingCheck = new CheckBox();
            GroupLabel layoutGroup = null;
            Label widthLabel = null;
            if (IsDataGridMode) {
                this.columnPanel = new Panel();
                layoutGroup = new GroupLabel();
                widthLabel = new Label();
                this.widthUnit = new UnitControl();
            }

            formatObjLabel.SetBounds(4, 4, 111, 14);
            formatObjLabel.Text = SR.GetString(SR.BDLFmt_Objects);
            formatObjLabel.TabStop = false;
            formatObjLabel.TabIndex = 2;

            formatTree.SetBounds(4, 20, 162, 350);
            formatTree.HideSelection = false;
            formatTree.TabIndex = 3;
            formatTree.AfterSelect += new TreeViewEventHandler(this.OnSelChangedFormatObject);

            stylePanel.SetBounds(177, 4, 230, 370);
            stylePanel.TabIndex = 6;
            stylePanel.Visible = false;

            appearanceGroup.SetBounds(0, 2, 224, 14);
            appearanceGroup.Text = SR.GetString(SR.BDLFmt_AppearanceGroup);
            appearanceGroup.TabStop = false;
            appearanceGroup.TabIndex = 1;

            foreColorLabel.SetBounds(8, 19, 160, 14);
            foreColorLabel.Text = SR.GetString(SR.BDLFmt_ForeColor);
            foreColorLabel.TabStop = false;
            foreColorLabel.TabIndex = 2;

            foreColorCombo.SetBounds(8, 37, 102, 22);
            foreColorCombo.TabIndex = 3;
            foreColorCombo.TextChanged += new EventHandler(this.OnFormatChanged);
            foreColorCombo.SelectedIndexChanged += new EventHandler(this.OnFormatChanged);

            foreColorPickerButton.SetBounds(114, 36, 24, 22);
            foreColorPickerButton.TabIndex = 4;
            foreColorPickerButton.Text = "...";
            foreColorPickerButton.FlatStyle = FlatStyle.System;
            foreColorPickerButton.Click += new EventHandler(this.OnClickForeColorPicker);

            backColorLabel.SetBounds(8, 62, 160, 14);
            backColorLabel.Text = SR.GetString(SR.BDLFmt_BackColor);
            backColorLabel.TabStop = false;
            backColorLabel.TabIndex = 5;

            backColorCombo.SetBounds(8, 78, 102, 22);
            backColorCombo.TabIndex = 6;
            backColorCombo.TextChanged += new EventHandler(this.OnFormatChanged);
            backColorCombo.SelectedIndexChanged += new EventHandler(this.OnFormatChanged);

            backColorPickerButton.SetBounds(114, 77, 24, 22);
            backColorPickerButton.TabIndex = 7;
            backColorPickerButton.Text = "...";
            backColorPickerButton.FlatStyle = FlatStyle.System;
            backColorPickerButton.Click += new EventHandler(this.OnClickBackColorPicker);

            fontNameLabel.SetBounds(8, 104, 160, 14);
            fontNameLabel.Text = SR.GetString(SR.BDLFmt_FontName);
            fontNameLabel.TabStop = false;
            fontNameLabel.TabIndex = 8;

            fontNameCombo.SetBounds(8, 120, 200, 22);
            fontNameCombo.Sorted = true;
            fontNameCombo.TabIndex = 9;
            fontNameCombo.SelectedIndexChanged += new EventHandler(this.OnFontNameChanged);
            fontNameCombo.TextChanged += new EventHandler(this.OnFontNameChanged);

            fontSizeLabel.SetBounds(8, 146, 160, 14);
            fontSizeLabel.Text = SR.GetString(SR.BDLFmt_FontSize);
            fontSizeLabel.TabStop = false;
            fontSizeLabel.TabIndex = 10;

            fontSizeCombo.SetBounds(8, 162, 100, 22);
            fontSizeCombo.TabIndex = 11;
            fontSizeCombo.MaxDropDownItems = 11;
            fontSizeCombo.DropDownStyle = ComboBoxStyle.DropDownList;
            fontSizeCombo.Items.AddRange(new object[] {
                                             SR.GetString(SR.BDLFmt_FS_Smaller),
                                             SR.GetString(SR.BDLFmt_FS_Larger),
                                             SR.GetString(SR.BDLFmt_FS_XXSmall),
                                             SR.GetString(SR.BDLFmt_FS_XSmall),
                                             SR.GetString(SR.BDLFmt_FS_Small),
                                             SR.GetString(SR.BDLFmt_FS_Medium),
                                             SR.GetString(SR.BDLFmt_FS_Large),
                                             SR.GetString(SR.BDLFmt_FS_XLarge),
                                             SR.GetString(SR.BDLFmt_FS_XXLarge),
                                             SR.GetString(SR.BDLFmt_FS_Custom)
                                         });
            fontSizeCombo.SelectedIndexChanged += new EventHandler(this.OnFontSizeChanged);
            
            fontSizeUnit.SetBounds(112, 162, 96, 22);
            fontSizeUnit.AllowNegativeValues = false;
            fontSizeUnit.TabIndex = 12;
            fontSizeUnit.Changed += new EventHandler(this.OnFormatChanged);

            boldCheck.SetBounds(8, 186, 106, 20);
            boldCheck.Text = SR.GetString(SR.BDLFmt_FontBold);
            boldCheck.TabIndex = 13;
            boldCheck.TextAlign = ContentAlignment.MiddleLeft;
            boldCheck.FlatStyle = FlatStyle.System;
            boldCheck.CheckedChanged += new EventHandler(this.OnFormatChanged);

            italicCheck.SetBounds(8, 204, 106, 20);
            italicCheck.Text = SR.GetString(SR.BDLFmt_FontItalic);
            italicCheck.TabIndex = 14;
            italicCheck.TextAlign = ContentAlignment.MiddleLeft;
            italicCheck.FlatStyle = FlatStyle.System;
            italicCheck.CheckedChanged += new EventHandler(this.OnFormatChanged);

            underlineCheck.SetBounds(8, 222, 106, 20);
            underlineCheck.Text = SR.GetString(SR.BDLFmt_FontUnderline);
            underlineCheck.TabIndex = 15;
            underlineCheck.TextAlign = ContentAlignment.MiddleLeft;
            underlineCheck.FlatStyle = FlatStyle.System;
            underlineCheck.CheckedChanged += new  EventHandler(this.OnFormatChanged);

            strikeOutCheck.SetBounds(120, 186, 106, 20);
            strikeOutCheck.Text = SR.GetString(SR.BDLFmt_FontStrikeout);
            strikeOutCheck.TabIndex = 16;
            strikeOutCheck.TextAlign = ContentAlignment.MiddleLeft;
            strikeOutCheck.FlatStyle = FlatStyle.System;
            strikeOutCheck.CheckedChanged += new EventHandler(this.OnFormatChanged);

            overlineCheck.SetBounds(120, 204, 106, 20);
            overlineCheck.Text = SR.GetString(SR.BDLFmt_FontOverline);
            overlineCheck.TabIndex = 17;
            overlineCheck.TextAlign = ContentAlignment.MiddleLeft;
            overlineCheck.FlatStyle = FlatStyle.System;
            overlineCheck.CheckedChanged += new EventHandler(this.OnFormatChanged);

            alignmentGroup.SetBounds(0, 248, 224, 14);
            alignmentGroup.Text = SR.GetString(SR.BDLFmt_AlignmentGroup);
            alignmentGroup.TabStop = false;
            alignmentGroup.TabIndex = 18;

            horzAlignLabel.SetBounds(8, 266, 160, 14);
            horzAlignLabel.Text = SR.GetString(SR.BDLFmt_HorzAlign);
            horzAlignLabel.TabStop = false;
            horzAlignLabel.TabIndex = 19;

            horzAlignCombo.SetBounds(8, 282, 190, 22);
            horzAlignCombo.DropDownStyle = ComboBoxStyle.DropDownList;
            horzAlignCombo.Items.AddRange(new object[] {
                                           SR.GetString(SR.BDLFmt_HA_Left),
                                           SR.GetString(SR.BDLFmt_HA_Center),
                                           SR.GetString(SR.BDLFmt_HA_Right),
                                           SR.GetString(SR.BDLFmt_HA_Justify)
                                       });
            horzAlignCombo.TabIndex = 20;
            horzAlignCombo.SelectedIndexChanged += new EventHandler(this.OnFormatChanged);

            vertAlignLabel.SetBounds(8, 308, 160, 14);
            vertAlignLabel.Text = SR.GetString(SR.BDLFmt_VertAlign);
            vertAlignLabel.TabStop = false;
            vertAlignLabel.TabIndex = 21;

            vertAlignCombo.SetBounds(8, 324, 190, 22);
            vertAlignCombo.DropDownStyle = ComboBoxStyle.DropDownList;
            vertAlignCombo.Items.AddRange(new object[] {
                                           SR.GetString(SR.BDLFmt_VA_Top),
                                           SR.GetString(SR.BDLFmt_VA_Middle),
                                           SR.GetString(SR.BDLFmt_VA_Bottom)
                                       });
            vertAlignCombo.TabIndex = 22;
            vertAlignCombo.SelectedIndexChanged += new EventHandler(this.OnFormatChanged);

            allowWrappingCheck.SetBounds(8, 350, 200, 17);
            allowWrappingCheck.Text = SR.GetString(SR.BDLFmt_AllowWrapping);
            allowWrappingCheck.TabIndex = 24;
            allowWrappingCheck.FlatStyle = FlatStyle.System;
            allowWrappingCheck.CheckedChanged += new EventHandler(this.OnFormatChanged);

            if (IsDataGridMode) {
                columnPanel.SetBounds(177, 4, 279, 350);
                columnPanel.TabIndex = 7;
                columnPanel.Visible = false;

                layoutGroup.SetBounds(0, 0, 279, 14);
                layoutGroup.Text = SR.GetString(SR.BDLFmt_LayoutGroup);
                layoutGroup.TabStop = false;
                layoutGroup.TabIndex = 0;

                widthLabel.SetBounds(8, 20, 64, 14);
                widthLabel.Text = SR.GetString(SR.BDLFmt_Width);
                widthLabel.TabStop = false;
                widthLabel.TabIndex = 1;

                widthUnit.SetBounds(80, 17, 102, 22);
                widthUnit.AllowNegativeValues = false;
                widthUnit.DefaultUnit = UnitControl.UNIT_PX;
                widthUnit.TabIndex = 2;
                widthUnit.Changed += new EventHandler(this.OnFormatChanged);
            }

            this.Text = SR.GetString(SR.BDLFmt_Text);
            this.Size = new Size(408, 370);
            this.CommitOnDeactivate = true;
            this.Icon = new Icon(this.GetType(), "FormatPage.ico");

            stylePanel.Controls.Clear();                  
            stylePanel.Controls.AddRange(new Control[] {
                                          allowWrappingCheck,
                                          vertAlignCombo,
                                          vertAlignLabel,
                                          horzAlignCombo,
                                          horzAlignLabel,
                                          alignmentGroup,
                                          overlineCheck,
                                          strikeOutCheck,
                                          underlineCheck,
                                          italicCheck,
                                          boldCheck,
                                          fontSizeUnit,
                                          fontSizeCombo,
                                          fontSizeLabel,
                                          fontNameCombo,
                                          fontNameLabel,
                                          backColorPickerButton,
                                          backColorCombo,
                                          backColorLabel,
                                          foreColorPickerButton,
                                          foreColorCombo,
                                          foreColorLabel,
                                          appearanceGroup
                                      });
            if (IsDataGridMode) {
                columnPanel.Controls.Clear();
                columnPanel.Controls.AddRange(new Control[] {
                                               widthUnit,
                                               widthLabel,
                                               layoutGroup
                                           });
                Controls.Clear();
                Controls.AddRange(new Control[] {
                                   columnPanel,
                                   stylePanel,
                                   formatTree,
                                   formatObjLabel
                               });
            }
            else {
                Controls.Clear();
                Controls.AddRange(new Control[] {
                                   stylePanel,
                                   formatTree,
                                   formatObjLabel
                               });
            }
        }

        /// <include file='doc\FormatPage.uex' path='docs/doc[@for="FormatPage.InitFormatTree"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void InitFormatTree() {
            FormatTreeNode newNode;
            FormatObject formatObject;

            if (IsDataGridMode) {
                DataGrid dataGrid = (DataGrid)GetBaseControl();

                formatObject = new FormatStyle(dataGrid.ControlStyle);
                formatObject.LoadFormatInfo();
                newNode = new FormatTreeNode(SR.GetString(SR.BDLFmt_Node_EntireDG), formatObject);
                formatTree.Nodes.Add(newNode);
                formatNodes.Add(newNode);

                formatObject = new FormatStyle(dataGrid.HeaderStyle);
                formatObject.LoadFormatInfo();
                newNode = new FormatTreeNode(SR.GetString(SR.BDLFmt_Node_Header), formatObject);
                formatTree.Nodes.Add(newNode);
                formatNodes.Add(newNode);

                formatObject = new FormatStyle(dataGrid.FooterStyle);
                formatObject.LoadFormatInfo();
                newNode = new FormatTreeNode(SR.GetString(SR.BDLFmt_Node_Footer), formatObject);
                formatTree.Nodes.Add(newNode);
                formatNodes.Add(newNode);

                formatObject = new FormatStyle(dataGrid.PagerStyle);
                formatObject.LoadFormatInfo();
                newNode = new FormatTreeNode(SR.GetString(SR.BDLFmt_Node_Pager), formatObject);
                formatTree.Nodes.Add(newNode);
                formatNodes.Add(newNode);

                FormatTreeNode itemsNode = new FormatTreeNode(SR.GetString(SR.BDLFmt_Node_Items), null);
                formatTree.Nodes.Add(itemsNode);

                formatObject = new FormatStyle(dataGrid.ItemStyle);
                formatObject.LoadFormatInfo();
                newNode = new FormatTreeNode(SR.GetString(SR.BDLFmt_Node_NormalItems), formatObject);
                itemsNode.Nodes.Add(newNode);
                formatNodes.Add(newNode);

                formatObject = new FormatStyle(dataGrid.AlternatingItemStyle);
                formatObject.LoadFormatInfo();
                newNode = new FormatTreeNode(SR.GetString(SR.BDLFmt_Node_AltItems), formatObject);
                itemsNode.Nodes.Add(newNode);
                formatNodes.Add(newNode);

                formatObject = new FormatStyle(dataGrid.SelectedItemStyle);
                formatObject.LoadFormatInfo();
                newNode = new FormatTreeNode(SR.GetString(SR.BDLFmt_Node_SelItems), formatObject);
                itemsNode.Nodes.Add(newNode);
                formatNodes.Add(newNode);

                formatObject = new FormatStyle(dataGrid.EditItemStyle);
                formatObject.LoadFormatInfo();
                newNode = new FormatTreeNode(SR.GetString(SR.BDLFmt_Node_EditItems), formatObject);
                itemsNode.Nodes.Add(newNode);
                formatNodes.Add(newNode);

                DataGridColumnCollection columns = dataGrid.Columns;
                int columnCount = columns.Count;
                if (columnCount != 0) {
                    FormatTreeNode columnsNode = new FormatTreeNode(SR.GetString(SR.BDLFmt_Node_Columns), null);
                    formatTree.Nodes.Add(columnsNode);

                    for (int i = 0; i < columnCount; i++) {
                        DataGridColumn c = columns[i];

                        string caption = "Columns[" + (i).ToString() + "]";
                        string headerText = c.HeaderText;
                        if (headerText.Length != 0)
                            caption = caption + " - " + headerText;

                        formatObject = new FormatColumn(c);
                        formatObject.LoadFormatInfo();
                        FormatTreeNode thisColumnNode = new FormatTreeNode(caption, formatObject);
                        columnsNode.Nodes.Add(thisColumnNode);
                        formatNodes.Add(thisColumnNode);

                        formatObject = new FormatStyle(c.HeaderStyle);
                        formatObject.LoadFormatInfo();
                        newNode = new FormatTreeNode(SR.GetString(SR.BDLFmt_Node_Header), formatObject);
                        thisColumnNode.Nodes.Add(newNode);
                        formatNodes.Add(newNode);

                        formatObject = new FormatStyle(c.FooterStyle);
                        formatObject.LoadFormatInfo();
                        newNode = new FormatTreeNode(SR.GetString(SR.BDLFmt_Node_Footer), formatObject);
                        thisColumnNode.Nodes.Add(newNode);
                        formatNodes.Add(newNode);

                        formatObject = new FormatStyle(c.ItemStyle);
                        formatObject.LoadFormatInfo();
                        newNode = new FormatTreeNode(SR.GetString(SR.BDLFmt_Node_Items), formatObject);
                        thisColumnNode.Nodes.Add(newNode);
                        formatNodes.Add(newNode);
                    }
                }
            }
            else {
                DataList dataList = (DataList)GetBaseControl();

                formatObject = new FormatStyle(dataList.ControlStyle);
                formatObject.LoadFormatInfo();
                newNode = new FormatTreeNode(SR.GetString(SR.BDLFmt_Node_EntireDL), formatObject);
                formatTree.Nodes.Add(newNode);
                formatNodes.Add(newNode);

                formatObject = new FormatStyle(dataList.HeaderStyle);
                formatObject.LoadFormatInfo();
                newNode = new FormatTreeNode(SR.GetString(SR.BDLFmt_Node_Header), formatObject);
                formatTree.Nodes.Add(newNode);
                formatNodes.Add(newNode);

                formatObject = new FormatStyle(dataList.FooterStyle);
                formatObject.LoadFormatInfo();
                newNode = new FormatTreeNode(SR.GetString(SR.BDLFmt_Node_Footer), formatObject);
                formatTree.Nodes.Add(newNode);
                formatNodes.Add(newNode);

                FormatTreeNode itemsNode = new FormatTreeNode(SR.GetString(SR.BDLFmt_Node_Items), null);
                formatTree.Nodes.Add(itemsNode);

                formatObject = new FormatStyle(dataList.ItemStyle);
                formatObject.LoadFormatInfo();
                newNode = new FormatTreeNode(SR.GetString(SR.BDLFmt_Node_NormalItems), formatObject);
                itemsNode.Nodes.Add(newNode);
                formatNodes.Add(newNode);

                formatObject = new FormatStyle(dataList.AlternatingItemStyle);
                formatObject.LoadFormatInfo();
                newNode = new FormatTreeNode(SR.GetString(SR.BDLFmt_Node_AltItems), formatObject);
                itemsNode.Nodes.Add(newNode);
                formatNodes.Add(newNode);

                formatObject = new FormatStyle(dataList.SelectedItemStyle);
                formatObject.LoadFormatInfo();
                newNode = new FormatTreeNode(SR.GetString(SR.BDLFmt_Node_SelItems), formatObject);
                itemsNode.Nodes.Add(newNode);
                formatNodes.Add(newNode);

                formatObject = new FormatStyle(dataList.EditItemStyle);
                formatObject.LoadFormatInfo();
                newNode = new FormatTreeNode(SR.GetString(SR.BDLFmt_Node_EditItems), formatObject);
                itemsNode.Nodes.Add(newNode);
                formatNodes.Add(newNode);

                formatObject = new FormatStyle(dataList.SeparatorStyle);
                formatObject.LoadFormatInfo();
                newNode = new FormatTreeNode(SR.GetString(SR.BDLFmt_Node_Separators), formatObject);
                formatTree.Nodes.Add(newNode);
                formatNodes.Add(newNode);
            }
        }

        /// <include file='doc\FormatPage.uex' path='docs/doc[@for="FormatPage.InitFormatUI"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void InitFormatUI() {
            foreColorCombo.Color = null;
            backColorCombo.Color = null;
            fontNameCombo.Text = String.Empty;
            fontNameCombo.SelectedIndex = -1;
            fontSizeCombo.SelectedIndex = -1;
            fontSizeUnit.Value = null;
            italicCheck.Checked = false;
            underlineCheck.Checked = false;
            strikeOutCheck.Checked = false;
            overlineCheck.Checked = false;
            horzAlignCombo.SelectedIndex = -1;
            vertAlignCombo.SelectedIndex = -1;
            allowWrappingCheck.Checked = false;
            if (IsDataGridMode) {
                widthUnit.Value = null;
                columnPanel.Visible = false;
            }
            stylePanel.Visible = false;
        }

        /// <include file='doc\FormatPage.uex' path='docs/doc[@for="FormatPage.InitPage"]/*' />
        /// <devdoc>
        ///   Initializes the page before it can be loaded with the component.
        /// </devdoc>
        private void InitPage() {
            formatNodes = new ArrayList();

            propChangesPending = false;
            fontNameChanged = false;

            currentFormatNode = null;
            currentFormatObject = null;
            formatTree.Nodes.Clear();

            InitFormatUI();
        }

        /// <include file='doc\FormatPage.uex' path='docs/doc[@for="FormatPage.LoadComponent"]/*' />
        /// <devdoc>
        ///   Loads the component into the page.
        /// </devdoc>
        protected override void LoadComponent() {
            // Load the list of fonts available the first time around
            if (IsFirstActivate()) {
                InitFontList();
            }

            InitPage();
            InitFormatTree();
        }

        /// <include file='doc\FormatPage.uex' path='docs/doc[@for="FormatPage.LoadFormatProperties"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void LoadFormatProperties() {
            if (currentFormatObject != null) {
                EnterLoadingMode();

                InitFormatUI();
                if (currentFormatObject is FormatStyle) {
                    FormatStyle formatStyle = (FormatStyle)currentFormatObject;

                    foreColorCombo.Color = formatStyle.foreColor;
                    backColorCombo.Color = formatStyle.backColor;

                    int fontIndex = -1;
                    if (formatStyle.fontName.Length != 0)
                        fontIndex = fontNameCombo.FindStringExact(formatStyle.fontName);
                    if (fontIndex != -1) {
                        fontNameCombo.SelectedIndex = fontIndex;
                    }
                    else {
                        fontNameCombo.Text = formatStyle.fontName;
                    }

                    boldCheck.Checked = formatStyle.bold;
                    italicCheck.Checked = formatStyle.italic;
                    underlineCheck.Checked = formatStyle.underline;
                    strikeOutCheck.Checked = formatStyle.strikeOut;
                    overlineCheck.Checked = formatStyle.overline;

                    if (formatStyle.fontType != -1) {
                        fontSizeCombo.SelectedIndex = formatStyle.fontType;
                        if (formatStyle.fontType == IDX_FSIZE_CUSTOM) {
                            fontSizeUnit.Value = formatStyle.fontSize;
                        }
                    }

                    if (formatStyle.horzAlignment == IDX_HALIGN_NOTSET)
                        horzAlignCombo.SelectedIndex = -1;
                    else
                        horzAlignCombo.SelectedIndex = formatStyle.horzAlignment;

                    if (formatStyle.vertAlignment == IDX_VALIGN_NOTSET)
                        vertAlignCombo.SelectedIndex = -1;
                    else
                        vertAlignCombo.SelectedIndex = formatStyle.vertAlignment;

                    allowWrappingCheck.Checked = formatStyle.allowWrapping;
                }
                else {
                    FormatColumn formatColumn = (FormatColumn)currentFormatObject;

                    widthUnit.Value = formatColumn.width;
                }
                ExitLoadingMode();
            }

            UpdateEnabledVisibleState();
        }

        /// <include file='doc\FormatPage.uex' path='docs/doc[@for="FormatPage.OnClickBackColorPicker"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void OnClickBackColorPicker(object source, EventArgs e) {
            string color = backColorCombo.Color;

            color = ColorBuilder.BuildColor(GetBaseControl(), this, color);
            if (color != null) {
                backColorCombo.Color = color;
                OnFormatChanged(backColorCombo, EventArgs.Empty);
            }
        }

        /// <include file='doc\FormatPage.uex' path='docs/doc[@for="FormatPage.OnClickForeColorPicker"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void OnClickForeColorPicker(object source, EventArgs e) {
            string color = foreColorCombo.Color;

            color = ColorBuilder.BuildColor(GetBaseControl(), this, color);
            if (color != null) {
                foreColorCombo.Color = color;
                OnFormatChanged(foreColorCombo, EventArgs.Empty);
            }
        }

        /// <include file='doc\FormatPage.uex' path='docs/doc[@for="FormatPage.OnFontNameChanged"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void OnFontNameChanged(object source, EventArgs e) {
            if (IsLoading())
                return;
            fontNameChanged = true;
            OnFormatChanged(fontNameCombo, EventArgs.Empty);
        }

        /// <include file='doc\FormatPage.uex' path='docs/doc[@for="FormatPage.OnFontSizeChanged"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void OnFontSizeChanged(object source, EventArgs e) {
            if (IsLoading())
                return;
            UpdateEnabledVisibleState();
            OnFormatChanged(fontSizeCombo, EventArgs.Empty);
        }

        /// <include file='doc\FormatPage.uex' path='docs/doc[@for="FormatPage.OnHandleCreated"]/*' />
        /// <devdoc>
        /// </devdoc>
        protected override void OnHandleCreated(EventArgs e) {
            base.OnHandleCreated(e);

            if (formatTree.Nodes.Count != 0) {
                // Force create the handle, since the tree does not keep track of
                // selected node if its handle has not been created already
                //
                IntPtr treeHandle = formatTree.Handle;

                formatTree.SelectedNode = formatTree.Nodes[0];
            }
        }

        /// <include file='doc\FormatPage.uex' path='docs/doc[@for="FormatPage.OnFormatChanged"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void OnFormatChanged(object source, EventArgs e) {
            if (IsLoading())
                return;
            if (currentFormatNode != null) {
                SetDirty();
                propChangesPending = true;
                currentFormatNode.Dirty = true;
            }
        }

        /// <include file='doc\FormatPage.uex' path='docs/doc[@for="FormatPage.OnSelChangedFormatObject"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void OnSelChangedFormatObject(object source, TreeViewEventArgs e) {
            if (propChangesPending) {
                SaveFormatProperties();
            }

            currentFormatNode = (FormatTreeNode)formatTree.SelectedNode;
            if (currentFormatNode != null) {
                currentFormatObject = currentFormatNode.FormatObject;
            }
            else {
                currentFormatObject = null;
            }
            LoadFormatProperties();
        }

        /// <include file='doc\FormatPage.uex' path='docs/doc[@for="FormatPage.SaveComponent"]/*' />
        /// <devdoc>
        ///   Saves the component loaded into the page.
        /// </devdoc>
        protected override void SaveComponent() {
            if (propChangesPending) {
                SaveFormatProperties();
            }

            FormatTreeNode formatNode;
            FormatObject formatObject;

            IEnumerator formatNodeEnum = formatNodes.GetEnumerator();
            while (formatNodeEnum.MoveNext()) {
                formatNode = (FormatTreeNode)formatNodeEnum.Current;
                if (formatNode.Dirty) {
                    formatObject = formatNode.FormatObject;
                    formatObject.SaveFormatInfo();
                    formatNode.Dirty = false;
                }
            }

            BaseDataListDesigner designer = GetBaseDesigner();
            designer.OnStylesChanged();
        }

        /// <include file='doc\FormatPage.uex' path='docs/doc[@for="FormatPage.SaveFormatProperties"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void SaveFormatProperties() {
            Debug.Assert(propChangesPending == true,
                         "SaveFormatProperties called without pending changes.");

            if (currentFormatObject != null) {
                int index;
                if (currentFormatObject is FormatStyle) {
                    FormatStyle formatStyle = (FormatStyle)currentFormatObject;

                    formatStyle.foreColor = foreColorCombo.Color;
                    formatStyle.backColor = backColorCombo.Color;
                    if (fontNameChanged) {
                        formatStyle.fontName = fontNameCombo.Text.Trim();
                        formatStyle.fontNameChanged = true;
                        fontNameChanged = false;
                    }

                    formatStyle.bold = boldCheck.Checked;
                    formatStyle.italic = italicCheck.Checked;
                    formatStyle.underline = underlineCheck.Checked;
                    formatStyle.strikeOut = strikeOutCheck.Checked;
                    formatStyle.overline = overlineCheck.Checked;

                    if (fontSizeCombo.IsSet()) {
                        formatStyle.fontType = fontSizeCombo.SelectedIndex;
                        if (formatStyle.fontType == IDX_FSIZE_CUSTOM) {
                            formatStyle.fontSize = fontSizeUnit.Value;
                        }
                    }
                    else {
                        formatStyle.fontType = -1;
                    }

                    index = horzAlignCombo.SelectedIndex;
                    if (index == -1)
                        index = IDX_HALIGN_NOTSET;
                    formatStyle.horzAlignment = index;

                    index = vertAlignCombo.SelectedIndex;
                    if (index == -1)
                        index = IDX_VALIGN_NOTSET;
                    formatStyle.vertAlignment = index;

                    formatStyle.allowWrapping = allowWrappingCheck.Checked;
                }
                else {
                    FormatColumn formatColumn = (FormatColumn)currentFormatObject;

                    formatColumn.width = widthUnit.Value;
                }
                currentFormatNode.Dirty = true;
            }
            propChangesPending = false;
        }

        /// <include file='doc\FormatPage.uex' path='docs/doc[@for="FormatPage.SetComponent"]/*' />
        /// <devdoc>
        ///   Sets the component that is to be edited in the page.
        /// </devdoc>
        public override void SetComponent(IComponent component) {
            base.SetComponent(component);
            InitForm();
        }

        /// <include file='doc\FormatPage.uex' path='docs/doc[@for="FormatPage.UpdateEnabledVisibleState"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void UpdateEnabledVisibleState() {
            if (currentFormatObject == null) {
                stylePanel.Visible = false;
                if (IsDataGridMode)
                    columnPanel.Visible = false;
            }
            else {
                if (currentFormatObject is FormatStyle) {
                    stylePanel.Visible = true;
                    if (IsDataGridMode)
                        columnPanel.Visible = false;

                    fontSizeUnit.Enabled = (fontSizeCombo.SelectedIndex == IDX_FSIZE_CUSTOM);

                    if (((FormatStyle)currentFormatObject).IsTableItemStyle) {
                        vertAlignLabel.Visible = true;
                        vertAlignCombo.Visible = true;

                        allowWrappingCheck.Visible = true;
                    }
                    else {
                        vertAlignLabel.Visible = false;
                        vertAlignCombo.Visible = false;

                        allowWrappingCheck.Visible = false;
                    }
                }
                else {
                    stylePanel.Visible = false;
                    columnPanel.Visible = true;
                }
            }
        }



        /// <include file='doc\FormatPage.uex' path='docs/doc[@for="FormatPage.FormatTreeNode"]/*' />
        /// <devdoc>
        /// </devdoc>
        private class FormatTreeNode : TreeNode {
            protected FormatObject formatObject;
            protected bool dirty;

            /// <include file='doc\FormatPage.uex' path='docs/doc[@for="FormatPage.FormatTreeNode.FormatTreeNode"]/*' />
            /// <devdoc>
            /// </devdoc>
            public FormatTreeNode(string text, FormatObject formatObject) : base(text) {
                this.formatObject = formatObject;
            }

            /// <include file='doc\FormatPage.uex' path='docs/doc[@for="FormatPage.FormatTreeNode.Dirty"]/*' />
            /// <devdoc>
            /// </devdoc>
            public bool Dirty {
                get {
                    return dirty;
                }
                set {
                    dirty = value;
                }
            }

            /// <include file='doc\FormatPage.uex' path='docs/doc[@for="FormatPage.FormatTreeNode.FormatObject"]/*' />
            /// <devdoc>
            /// </devdoc>
            public FormatObject FormatObject {
                get {
                    return formatObject;
                }
            }
        }

        /// <include file='doc\FormatPage.uex' path='docs/doc[@for="FormatPage.FormatObject"]/*' />
        /// <devdoc>
        /// </devdoc>
        private abstract class FormatObject {

            public abstract void LoadFormatInfo();
            public abstract void SaveFormatInfo();
        }

        /// <include file='doc\FormatPage.uex' path='docs/doc[@for="FormatPage.FormatStyle"]/*' />
        /// <devdoc>
        ///   This class contains formatting settings common to all objects.
        /// </devdoc>
        private class FormatStyle : FormatObject {
            public string foreColor;
            public string backColor;
            public string fontName;
            public bool fontNameChanged;
            public int fontType;
            public string fontSize;
            public bool bold;
            public bool italic;
            public bool underline;
            public bool strikeOut;
            public bool overline;
            public int horzAlignment;
            public int vertAlignment;
            public bool allowWrapping;

            protected WebControls.Style runtimeStyle;

            /// <include file='doc\FormatPage.uex' path='docs/doc[@for="FormatPage.FormatStyle.FormatStyle"]/*' />
            /// <devdoc>
            /// </devdoc>
            public FormatStyle(WebControls.Style runtimeStyle) {
                this.runtimeStyle = runtimeStyle;
            }

            /// <include file='doc\FormatPage.uex' path='docs/doc[@for="FormatPage.FormatStyle.IsTableItemStyle"]/*' />
            /// <devdoc>
            /// </devdoc>
            public bool IsTableItemStyle {
                get {
                    return runtimeStyle is TableItemStyle;
                }
            }

            /// <include file='doc\FormatPage.uex' path='docs/doc[@for="FormatPage.FormatStyle.LoadFormatInfo"]/*' />
            /// <devdoc>
            /// </devdoc>
            public override void LoadFormatInfo() {
                Color c;
                WebControls.FontInfo fi;

                c = runtimeStyle.BackColor;
                backColor = ColorTranslator.ToHtml(c);

                c = runtimeStyle.ForeColor;
                foreColor = ColorTranslator.ToHtml(c);

                fi = runtimeStyle.Font;
                fontName = fi.Name;
                fontNameChanged = false;
                bold = fi.Bold;
                italic = fi.Italic;
                underline = fi.Underline;
                strikeOut = fi.Strikeout;
                overline = fi.Overline;

                fontType = -1;
                WebControls.FontUnit size = fi.Size;
                if (size.IsEmpty == false) {
                    fontSize = null;
                    switch (size.Type) {
                        case FontSize.AsUnit:
                            fontType = IDX_FSIZE_CUSTOM;
                            fontSize = size.ToString();
                            break;
                        case FontSize.Smaller:
                            fontType = IDX_FSIZE_SMALLER;
                            break;
                        case FontSize.Larger:
                            fontType = IDX_FSIZE_LARGER;
                            break;
                        case FontSize.XXSmall:
                            fontType = IDX_FSIZE_XXSMALL;
                            break;
                        case FontSize.XSmall:
                            fontType = IDX_FSIZE_XSMALL;
                            break;
                        case FontSize.Small:
                            fontType = IDX_FSIZE_SMALL;
                            break;
                        case FontSize.Medium:
                            fontType = IDX_FSIZE_MEDIUM;
                            break;
                        case FontSize.Large:
                            fontType = IDX_FSIZE_LARGE;
                            break;
                        case FontSize.XLarge:
                            fontType = IDX_FSIZE_XLARGE;
                            break;
                        case FontSize.XXLarge:
                            fontType = IDX_FSIZE_XXLARGE;
                            break;
                    }
                }
                
                TableItemStyle ts = null;
                HorizontalAlign ha;

                if (runtimeStyle is TableItemStyle) {
                    ts = (TableItemStyle)runtimeStyle;
                    ha = ts.HorizontalAlign;

                    allowWrapping = ts.Wrap;
                }
                else {
                    Debug.Assert(runtimeStyle is TableStyle, "Expected a TableStyle");
                    ha = ((TableStyle)runtimeStyle).HorizontalAlign;
                }

                horzAlignment = FormatPage.IDX_HALIGN_NOTSET;
                switch (ha) {
                    case HorizontalAlign.Left:
                        horzAlignment = FormatPage.IDX_HALIGN_LEFT;
                        break;
                    case HorizontalAlign.Center:
                        horzAlignment = FormatPage.IDX_HALIGN_CENTER;
                        break;
                    case HorizontalAlign.Right:
                        horzAlignment = FormatPage.IDX_HALIGN_RIGHT;
                        break;
                    case HorizontalAlign.Justify:
                        horzAlignment = FormatPage.IDX_HALIGN_JUSTIFY;
                        break;
                }

                if (ts != null) {
                    VerticalAlign va = ts.VerticalAlign;
                    vertAlignment = FormatPage.IDX_VALIGN_NOTSET;
                    switch (va) {
                        case VerticalAlign.Top:
                            vertAlignment = FormatPage.IDX_VALIGN_TOP;
                            break;
                        case VerticalAlign.Middle:
                            vertAlignment = FormatPage.IDX_VALIGN_MIDDLE;
                            break;
                        case VerticalAlign.Bottom:
                            vertAlignment = FormatPage.IDX_VALIGN_BOTTOM;
                            break;
                    }
                }
            }

            /// <include file='doc\FormatPage.uex' path='docs/doc[@for="FormatPage.FormatStyle.SaveFormatInfo"]/*' />
            /// <devdoc>
            /// </devdoc>
            public override void SaveFormatInfo() {
                WebControls.FontInfo fi;

                try {
                    runtimeStyle.BackColor = ColorTranslator.FromHtml(backColor);
                }
                catch (Exception) {
                }
                try {
                    runtimeStyle.ForeColor = ColorTranslator.FromHtml(foreColor);
                }
                catch (Exception) {
                }

                fi = runtimeStyle.Font;
                if (fontNameChanged) {
                    fi.Name = fontName;
                    fontNameChanged = false;
                }
                fi.Bold = bold;
                fi.Italic = italic;
                fi.Underline = underline;
                fi.Strikeout = strikeOut;
                fi.Overline = overline;

                if (fontType != -1) {
                    switch (fontType) {
                        case IDX_FSIZE_CUSTOM:
                            fi.Size = new FontUnit(fontSize);
                            break;
                        case IDX_FSIZE_SMALLER:
                            fi.Size = FontUnit.Smaller;
                            break;
                        case IDX_FSIZE_LARGER:
                            fi.Size = FontUnit.Larger;
                            break;
                        case IDX_FSIZE_XXSMALL:
                            fi.Size = FontUnit.XXSmall;
                            break;
                        case IDX_FSIZE_XSMALL:
                            fi.Size = FontUnit.XSmall;
                            break;
                        case IDX_FSIZE_SMALL:
                            fi.Size = FontUnit.Small;
                            break;
                        case IDX_FSIZE_MEDIUM:
                            fi.Size = FontUnit.Medium;
                            break;
                        case IDX_FSIZE_XXLARGE:
                            fi.Size = FontUnit.XXLarge;
                            break;
                        case IDX_FSIZE_XLARGE:
                            fi.Size = FontUnit.XLarge;
                            break;
                        case IDX_FSIZE_LARGE:
                            fi.Size = FontUnit.Large;
                            break;
                    }
                }
                else {
                    fi.Size = FontUnit.Empty;
                }

                TableItemStyle ts = null;
                HorizontalAlign ha = HorizontalAlign.NotSet;

                switch (horzAlignment) {
                    case FormatPage.IDX_HALIGN_NOTSET:
                        ha = HorizontalAlign.NotSet;
                        break;
                    case FormatPage.IDX_HALIGN_LEFT:
                        ha = HorizontalAlign.Left;
                        break;
                    case FormatPage.IDX_HALIGN_CENTER:
                        ha = HorizontalAlign.Center;
                        break;
                    case FormatPage.IDX_HALIGN_RIGHT:
                        ha = HorizontalAlign.Right;
                        break;
                    case FormatPage.IDX_HALIGN_JUSTIFY:
                        ha = HorizontalAlign.Justify;
                        break;
                }

                if (runtimeStyle is TableItemStyle) {
                    ts = (TableItemStyle)runtimeStyle;
                    ts.HorizontalAlign = ha;

                    ts.Wrap = allowWrapping;
                }
                else {
                    Debug.Assert(runtimeStyle is TableStyle, "Expected a TableStyle");
                    ((TableStyle)runtimeStyle).HorizontalAlign = ha;
                }

                if (ts != null) {
                    switch (vertAlignment) {
                        case FormatPage.IDX_VALIGN_NOTSET:
                            ts.VerticalAlign = VerticalAlign.NotSet;
                            break;
                        case FormatPage.IDX_VALIGN_TOP:
                            ts.VerticalAlign = VerticalAlign.Top;
                            break;
                        case FormatPage.IDX_VALIGN_MIDDLE:
                            ts.VerticalAlign = VerticalAlign.Middle;
                            break;
                        case FormatPage.IDX_VALIGN_BOTTOM:
                            ts.VerticalAlign = VerticalAlign.Bottom;
                            break;
                    }
                }
            }
        }

        /// <include file='doc\FormatPage.uex' path='docs/doc[@for="FormatPage.FormatColumn"]/*' />
        /// <devdoc>
        ///   This class contains formatting settings that apply only
        ///   to columns.
        /// </devdoc>
        private class FormatColumn : FormatObject {
            public string width;

            protected DataGridColumn runtimeColumn;

            /// <include file='doc\FormatPage.uex' path='docs/doc[@for="FormatPage.FormatColumn.FormatColumn"]/*' />
            /// <devdoc>
            /// </devdoc>
            public FormatColumn(DataGridColumn runtimeColumn) {
                this.runtimeColumn = runtimeColumn;
            }

            /// <include file='doc\FormatPage.uex' path='docs/doc[@for="FormatPage.FormatColumn.LoadFormatInfo"]/*' />
            /// <devdoc>
            /// </devdoc>
            public override void LoadFormatInfo() {
                TableItemStyle headerStyle = runtimeColumn.HeaderStyle;

                if (headerStyle.Width.IsEmpty == false)
                    width = headerStyle.Width.ToString();
                else
                    width = null;
            }

            /// <include file='doc\FormatPage.uex' path='docs/doc[@for="FormatPage.FormatColumn.SaveFormatInfo"]/*' />
            /// <devdoc>
            /// </devdoc>
            public override void SaveFormatInfo() {
                TableItemStyle headerStyle = runtimeColumn.HeaderStyle;

                if (width == null)
                    headerStyle.Width = WebControls.Unit.Empty;
                else
                    headerStyle.Width = new WebControls.Unit(width);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\advancedbindingeditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="AdvancedBindingEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms.Design {

    using System;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Drawing;
    using System.Drawing.Design;
    using System.Windows.Forms;
    
    /// <include file='doc\AdvancedBindingEditor.uex' path='docs/doc[@for="AdvancedBindingEditor"]/*' />
    /// <devdoc>
    ///    <para>Provides an editor to edit advanced binding objects.</para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class AdvancedBindingEditor : UITypeEditor {

        private AdvancedBindingPicker advancedBindingPicker;
        
        /// <include file='doc\AdvancedBindingEditor.uex' path='docs/doc[@for="AdvancedBindingEditor.EditValue"]/*' />
        /// <devdoc>
        ///    <para>Edits the specified value using the specified provider 
        ///       within the specified context.</para>
        /// </devdoc>
        public override object EditValue(ITypeDescriptorContext context,  IServiceProvider  provider, object value) {
            if (provider != null) {
                IWindowsFormsEditorService edSvc = (IWindowsFormsEditorService)provider.GetService(typeof(IWindowsFormsEditorService));

                if (edSvc != null) {
                    if (advancedBindingPicker == null) {
                        advancedBindingPicker = new AdvancedBindingPicker(context);
                    }

                    IComponentChangeService changeSvc = (IComponentChangeService)provider.GetService(typeof(IComponentChangeService));
                    Control c = ((ControlBindingsCollection)context.Instance).Control;
                    if (changeSvc != null) {
                        changeSvc.OnComponentChanging(c, TypeDescriptor.GetProperties(c)["DataBindings"]);
                    }

                    AdvancedBindingObject abo = (AdvancedBindingObject) value;
                    abo.Changed = false;
                    advancedBindingPicker.Value = abo;
                    edSvc.ShowDialog(advancedBindingPicker);
                    advancedBindingPicker.End();

                    if (abo.Changed) {
                        // since the bindings may have changed, the properties listed in the properties window
                        // need to be refreshed
                        Debug.Assert(context.Instance is ControlBindingsCollection);
                        TypeDescriptor.Refresh(((ControlBindingsCollection)context.Instance).Control);
                        if (changeSvc != null) {
                            changeSvc.OnComponentChanged(c, TypeDescriptor.GetProperties(c)["DataBindings"], null, null);
                        }
                    }
                }
            }

            return value;
        }

        /// <include file='doc\AdvancedBindingEditor.uex' path='docs/doc[@for="AdvancedBindingEditor.GetEditStyle"]/*' />
        /// <devdoc>
        ///    <para>Gets the edit style from the current context.</para>
        /// </devdoc>
        public override UITypeEditorEditStyle GetEditStyle(ITypeDescriptorContext context) {
            return UITypeEditorEditStyle.Modal;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\advancedbindingobject.cs ===
//------------------------------------------------------------------------------
// <copyright file="AdvancedBindingObject.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms.Design {

    using System;
    using System.ComponentModel;
    using System.Collections;

    [
    System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode),
    ToolboxItem(false),
    DesignTimeVisible(false),
    TypeConverterAttribute(typeof(AdvancedBindingConverter))
    ]    
    internal class AdvancedBindingObject : ICustomTypeDescriptor, IComponent, ISite {
        private ControlBindingsCollection bindings;
        private PropertyDescriptorCollection propsCollection;
        private PropertyDescriptor defaultProp = null;
        private bool showAll;
        private bool changed = false;
        
        /// <include file='doc\AdvancedBindingObject.uex' path='docs/doc[@for="AdvancedBindingObject.AdvancedBindingObject"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Windows.Forms.Design.AdvancedBindingObject'/> class.</para>
        /// </devdoc>
        public AdvancedBindingObject(ControlBindingsCollection bindings) {
            this.bindings = bindings;
        }
        
        /// <include file='doc\AdvancedBindingObject.uex' path='docs/doc[@for="AdvancedBindingObject.Bindings"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the collection of bindings.</para>
        /// </devdoc>
        public ControlBindingsCollection Bindings {
            get {
                return bindings;
            }
        }

        internal bool Changed {
            get{
                return changed;
            }
            set {
                changed = value;
            }
        }

        /// <include file='doc\AdvancedBindingObject.uex' path='docs/doc[@for="AdvancedBindingObject.Disposed"]/*' />
        /// <devdoc>
        ///    <para>Adds a event handler to listen to the Disposed event on the component.</para>
        /// </devdoc>
        public event EventHandler Disposed;
        
        /// <include file='doc\AdvancedBindingObject.uex' path='docs/doc[@for="AdvancedBindingObject.ShowAll"]/*' />
        /// <devdoc>
        ///    <para>Indicates whether to show all bindings.</para>
        /// </devdoc>
        public bool ShowAll {
            get {
                return showAll;
            }
            set {
                this.showAll = value;
                propsCollection = null;
                defaultProp = null;
            }
        }
        
        /// <include file='doc\AdvancedBindingObject.uex' path='docs/doc[@for="AdvancedBindingObject.ICustomTypeDescriptor.GetAttributes"]/*' />
        /// <devdoc>
        ///     Retrieves an array of member attributes for the given object.
        /// </devdoc>
        AttributeCollection ICustomTypeDescriptor.GetAttributes() {
            return new AttributeCollection(null);
        }

        /// <include file='doc\AdvancedBindingObject.uex' path='docs/doc[@for="AdvancedBindingObject.ICustomTypeDescriptor.GetClassName"]/*' />
        /// <devdoc>
        ///     Retrieves the class name for this object.  If null is returned,
        ///     the type name is used.
        /// </devdoc>
        string ICustomTypeDescriptor.GetClassName() {
            return null;
        }

        /// <include file='doc\AdvancedBindingObject.uex' path='docs/doc[@for="AdvancedBindingObject.ICustomTypeDescriptor.GetComponentName"]/*' />
        /// <devdoc>
        ///     Retrieves the name for this object.  If null is returned,
        ///     the default is used.
        /// </devdoc>
        string ICustomTypeDescriptor.GetComponentName() {
            return null;
        }

        /// <include file='doc\AdvancedBindingObject.uex' path='docs/doc[@for="AdvancedBindingObject.ICustomTypeDescriptor.GetConverter"]/*' />
        /// <devdoc>
        ///      Retrieves the type converter for this object.
        /// </devdoc>
        TypeConverter ICustomTypeDescriptor.GetConverter() {
            return null;
        }

        /// <include file='doc\AdvancedBindingObject.uex' path='docs/doc[@for="AdvancedBindingObject.ICustomTypeDescriptor.GetDefaultEvent"]/*' />
        /// <devdoc>
        ///     Retrieves the default event.
        /// </devdoc>
        EventDescriptor ICustomTypeDescriptor.GetDefaultEvent() {
            return null;
        } 


        /// <include file='doc\AdvancedBindingObject.uex' path='docs/doc[@for="AdvancedBindingObject.ICustomTypeDescriptor.GetDefaultProperty"]/*' />
        /// <devdoc>
        ///     Retrieves the default property.
        /// </devdoc>
        PropertyDescriptor ICustomTypeDescriptor.GetDefaultProperty() {
            // ASURT 45429: set focus on the defaultProperty from 
            // the list of properties, if there is not a default property, 
            // then set focus on the first property
            //
            if (defaultProp != null) {
                System.Diagnostics.Debug.Assert(propsCollection != null, "how can we have a property and not have a list of properties?");
                return defaultProp;
            } else if (propsCollection != null && propsCollection.Count > 0)
                return propsCollection[0];
            else
                return null;
        }

        /// <include file='doc\AdvancedBindingObject.uex' path='docs/doc[@for="AdvancedBindingObject.ICustomTypeDescriptor.GetEditor"]/*' />
        /// <devdoc>
        ///      Retrieves the an editor for this object.
        /// </devdoc>
        object ICustomTypeDescriptor.GetEditor(Type editorBaseType) {
            return null;
        }

        /// <include file='doc\AdvancedBindingObject.uex' path='docs/doc[@for="AdvancedBindingObject.ICustomTypeDescriptor.GetEvents"]/*' />
        /// <devdoc>
        ///     Retrieves an array of events that the given component instance
        ///     provides.  This may differ from the set of events the class
        ///     provides.  If the component is sited, the site may add or remove
        ///     additional events.
        /// </devdoc>
        EventDescriptorCollection ICustomTypeDescriptor.GetEvents() {
            return null;
        }

        /// <include file='doc\AdvancedBindingObject.uex' path='docs/doc[@for="AdvancedBindingObject.ICustomTypeDescriptor.GetEvents1"]/*' />
        /// <devdoc>
        ///     Retrieves an array of events that the given component instance
        ///     provides.  This may differ from the set of events the class
        ///     provides.  If the component is sited, the site may add or remove
        ///     additional events.  The returned array of events will be
        ///     filtered by the given set of attributes.
        /// </devdoc>
        EventDescriptorCollection ICustomTypeDescriptor.GetEvents(Attribute[] attributes) {
            return null;
         }

        /// <include file='doc\AdvancedBindingObject.uex' path='docs/doc[@for="AdvancedBindingObject.ICustomTypeDescriptor.GetProperties"]/*' />
        /// <devdoc>
        ///     Retrieves an array of properties that the given component instance
        ///     provides.  This may differ from the set of properties the class
        ///     provides.  If the component is sited, the site may add or remove
        ///     additional properties.
        /// </devdoc>
        PropertyDescriptorCollection ICustomTypeDescriptor.GetProperties() {
            return ((ICustomTypeDescriptor)this).GetProperties(null);
        }

        /// <include file='doc\AdvancedBindingObject.uex' path='docs/doc[@for="AdvancedBindingObject.ICustomTypeDescriptor.GetProperties1"]/*' />
        /// <devdoc>
        ///     Retrieves an array of properties that the given component instance
        ///     provides.  This may differ from the set of properties the class
        ///     provides.  If the component is sited, the site may add or remove
        ///     additional properties.  The returned array of properties will be
        ///     filtered by the given set of attributes.
        /// </devdoc>
        PropertyDescriptorCollection ICustomTypeDescriptor.GetProperties(Attribute[] attributes) {
            if (propsCollection == null) {
                Control control = bindings.Control;
                Type type = control.GetType();

                PropertyDescriptorCollection bindableProperties = TypeDescriptor.GetProperties(control, attributes);

                AttributeCollection controlAttributes = TypeDescriptor.GetAttributes(type);
                DefaultPropertyAttribute defPropAttr = ((DefaultPropertyAttribute)controlAttributes[typeof(DefaultPropertyAttribute)]);

                ArrayList props = new ArrayList();
                for (int i = 0; i < bindableProperties.Count; i++) {
                    if (bindableProperties[i].IsReadOnly)
                        continue;
                    bool bindable = ((BindableAttribute)bindableProperties[i].Attributes[typeof(BindableAttribute)]).Bindable;
                    DesignOnlyAttribute designAttr = ((DesignOnlyAttribute)bindableProperties[i].Attributes[typeof(DesignOnlyAttribute)]);
                    DesignBindingPropertyDescriptor property = new DesignBindingPropertyDescriptor(bindableProperties[i], null);
                    property.AddValueChanged(bindings, new EventHandler(OnBindingChanged));
                    // ASURT 45429: skip the Design time properties
                    //
                    if (!bindable && !showAll || designAttr.IsDesignOnly) {
                        if (((DesignBinding)property.GetValue(this)).IsNull) {
                             continue;
                        }
                    }
                    props.Add(property);

                    // ASURT 45429: make the default property have focus in the properties window
                    //
                    if (defPropAttr != null && property.Name.Equals(defPropAttr.Name)) {
                        System.Diagnostics.Debug.Assert(this.defaultProp == null, "a control cannot have two default properties");
                        this.defaultProp = property;
                    }
                }
                PropertyDescriptor[] propArray = new PropertyDescriptor[props.Count];
                props.CopyTo(propArray,0);
                this.propsCollection = new PropertyDescriptorCollection(propArray);
            }                              
            return propsCollection;
        }

        /// <include file='doc\AdvancedBindingObject.uex' path='docs/doc[@for="AdvancedBindingObject.ICustomTypeDescriptor.GetPropertyOwner"]/*' />
        /// <devdoc>
        ///    <para>Gets the object that directly depends on the value being edited.</para>
        /// </devdoc>
        object ICustomTypeDescriptor.GetPropertyOwner(PropertyDescriptor pd) {
            return this;
        }
        
        public ISite Site {
            get {
                return this;
            }
            set {
            }
        }
        
        void IDisposable.Dispose() {
            if (Disposed != null) {
                Disposed(this, EventArgs.Empty);
            }
        }

        IComponent ISite.Component {
            get {
                return this;
            }
        }
                
        IContainer ISite.Container {
            get {
                return bindings.Control.Site != null ? bindings.Control.Site.Container : null;
            }
        }
        
        bool ISite.DesignMode {
            get {
                return bindings.Control.Site != null ? bindings.Control.Site.DesignMode : false; // why false? why not?
            }
        }
        
        object  IServiceProvider.GetService(Type service) {
            if (bindings.Control.Site != null)
                return bindings.Control.Site.GetService(service);
            else
                return null;
        }
        
        /// <include file='doc\AdvancedBindingObject.uex' path='docs/doc[@for="AdvancedBindingObject.Name"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the name for this object.</para>
        /// </devdoc>
        public string Name {
            get {
                return bindings.Control.Site != null ? bindings.Control.Site.Name : "";
            }
            set {
            }
        }

        private void OnBindingChanged(object sender, EventArgs e) {
            this.changed = true;
        }

        public override string ToString() {
            return "";
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\advancedbindingconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="AdvancedBindingConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms.Design {

    using System;
    using Microsoft.Win32;
    using System.Collections;
    using System.ComponentModel;
    using System.Globalization;

    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class AdvancedBindingConverter : TypeConverter {

        /// <include file='doc\AdvancedBindingConverter.uex' path='docs/doc[@for="AdvancedBindingConverter.ConvertTo"]/*' />
        /// <devdoc>
        ///    <para>Converts the object to the specified destination type, if possible.</para>
        /// </devdoc>
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
            if (destinationType == typeof(string)) {
                return "";
            }
            return base.ConvertTo(context, culture, value, destinationType);
        }

        public override bool GetPropertiesSupported(ITypeDescriptorContext context) {
            return true;
        }

        public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value,
                                                                   Attribute[] attributes) {
            if (value is AdvancedBindingObject)
                return ((ICustomTypeDescriptor) value).GetProperties(attributes);
            else
                return null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\advancedbindingpicker.cs ===
//------------------------------------------------------------------------------
// <copyright file="AdvancedBindingPicker.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms.Design {

    using System;
    using System.Design;
    using System.Windows.Forms;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Collections;
    using System.Drawing;
    using System.Drawing.Design;
    
    /// <include file='doc\AdvancedBindingPicker.uex' path='docs/doc[@for="AdvancedBindingPicker"]/*' />
    /// <devdoc>
    ///    <para>Provides a picker to select advanced bindings. </para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class AdvancedBindingPicker : Form {
        static readonly string HELP_KEYWORD = "VS.PropertyBrowser.DataBindings.Advanced";

        ITypeDescriptorContext context;
        AdvancedBindingObject value;

        Container components;
        Label label1;
        PropertyGrid propertyGrid1;
        CheckBox checkBox1;
        Button button1;
        
        
        /// <include file='doc\AdvancedBindingPicker.uex' path='docs/doc[@for="AdvancedBindingPicker.AdvancedBindingPicker"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Windows.Forms.Design.AdvancedBindingPicker'/> class.</para>
        /// </devdoc>
        public AdvancedBindingPicker(ITypeDescriptorContext context) {
            this.context = context;
            this.ShowInTaskbar = false;
            InitializeComponent();
        }

        public void End() {
            this.propertyGrid1.SelectedObjects = null;
        }
        
        public AdvancedBindingObject Value {
            get {
                return value;
            }
            set {
                this.value = value;
                this.Text = SR.GetString(SR.DataGridAdvancedBindingString,
                value.Bindings.Control.Site != null ? value.Bindings.Control.Site.Name : ""); // ASURT 79138: look there for a description
                                                                                              // of when the control may not be sited
                value.ShowAll = checkBox1.CheckState == CheckState.Checked;
                propertyGrid1.SelectedObject = value;
            }
        }
        
        private void CheckBox1_CheckedChanged(object sender, EventArgs e) {
            // CONSIDER: make this nicer... this will reset the browsable attribute.
            Value = value;
        }
        
        void OnHelpRequested(object sender, HelpEventArgs e) {
            IServiceProvider sp = context;

            if (sp != null) {
                IHelpService helpService = (IHelpService)sp.GetService(typeof(IHelpService));
                if (helpService != null) {
                    helpService.ShowHelpFromKeyword(HELP_KEYWORD);
                }
            }
        }

        private void InitializeComponent() {
            System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(AdvancedBindingPicker));
            this.components = new System.ComponentModel.Container();
            this.checkBox1 = new System.Windows.Forms.CheckBox();
            this.label1 = new System.Windows.Forms.Label();
            this.button1 = new System.Windows.Forms.Button();
            this.propertyGrid1 = new System.Windows.Forms.PropertyGrid();
                        
            checkBox1.CheckState = CheckState.Checked;
            checkBox1.CheckedChanged += new EventHandler(this.CheckBox1_CheckedChanged);
            checkBox1.AccessibleDescription = ((string)(resources.GetObject("checkBox1.AccessibleDescription")));
            checkBox1.AccessibleName = ((string)(resources.GetObject("checkBox1.AccessibleName")));
            checkBox1.Anchor = ((System.Windows.Forms.AnchorStyles)(resources.GetObject("checkBox1.Anchor")));
            checkBox1.CheckAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("checkBox1.CheckAlign")));
            checkBox1.Cursor = ((System.Windows.Forms.Cursor)(resources.GetObject("checkBox1.Cursor")));
            checkBox1.FlatStyle = ((System.Windows.Forms.FlatStyle)(resources.GetObject("checkBox1.FlatStyle")));
            checkBox1.ImeMode = ((System.Windows.Forms.ImeMode)(resources.GetObject("checkBox1.ImeMode")));
            checkBox1.Location = ((System.Drawing.Point)(resources.GetObject("checkBox1.Location")));
            checkBox1.Size = ((System.Drawing.Size)(resources.GetObject("checkBox1.Size")));
            checkBox1.TabIndex = ((int)(resources.GetObject("checkBox1.TabIndex")));
            checkBox1.Text = SR.GetString(SR.DataGridShowAllString);
            checkBox1.TextAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("checkBox1.TextAlign")));

            label1.AccessibleDescription = ((string)(resources.GetObject("label1.AccessibleDescription")));
            label1.AccessibleName = ((string)(resources.GetObject("label1.AccessibleName")));
            label1.Anchor = ((System.Windows.Forms.AnchorStyles)(resources.GetObject("label1.Anchor")));
            label1.Cursor = ((System.Windows.Forms.Cursor)(resources.GetObject("label1.Cursor")));
            label1.ImeMode = ((System.Windows.Forms.ImeMode)(resources.GetObject("label1.ImeMode")));
            label1.Location = ((System.Drawing.Point)(resources.GetObject("label1.Location")));
            label1.Size = ((System.Drawing.Size)(resources.GetObject("label1.Size")));
            label1.Text = resources.GetString("label1.Text");
            label1.TextAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("label1.TextAlign")));

            button1.DialogResult = System.Windows.Forms.DialogResult.OK;
            button1.AccessibleDescription = ((string)(resources.GetObject("button1.AccessibleDescription")));
            button1.AccessibleName = ((string)(resources.GetObject("button1.AccessibleName")));
            button1.Anchor = ((System.Windows.Forms.AnchorStyles)(resources.GetObject("button1.Anchor")));
            button1.Cursor = ((System.Windows.Forms.Cursor)(resources.GetObject("button1.Cursor")));
            button1.FlatStyle = ((System.Windows.Forms.FlatStyle)(resources.GetObject("button1.FlatStyle")));
            button1.ImeMode = ((System.Windows.Forms.ImeMode)(resources.GetObject("button1.ImeMode")));
            button1.Location = ((System.Drawing.Point)(resources.GetObject("button1.Location")));
            button1.Size = ((System.Drawing.Size)(resources.GetObject("button1.Size")));
            button1.TabIndex = ((int)(resources.GetObject("button1.TabIndex")));
            button1.Text = resources.GetString("button1.Text");
            button1.TextAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("button1.TextAlign")));

            propertyGrid1.PropertySort = PropertySort.Alphabetical;
            propertyGrid1.CommandsVisibleIfAvailable = false;
            propertyGrid1.HelpVisible = false;
            propertyGrid1.ToolbarVisible = false;
            propertyGrid1.AccessibleDescription = ((string)(resources.GetObject("propertyGrid1.AccessibleDescription")));
            propertyGrid1.AccessibleName = ((string)(resources.GetObject("propertyGrid1.AccessibleName")));
            propertyGrid1.Anchor = ((System.Windows.Forms.AnchorStyles)(resources.GetObject("propertyGrid1.Anchor")));
            propertyGrid1.Cursor = ((System.Windows.Forms.Cursor)(resources.GetObject("propertyGrid1.Cursor")));
            propertyGrid1.ImeMode = ((System.Windows.Forms.ImeMode)(resources.GetObject("propertyGrid1.ImeMode")));
            propertyGrid1.Location = ((System.Drawing.Point)(resources.GetObject("propertyGrid1.Location")));
            propertyGrid1.Size = ((System.Drawing.Size)(resources.GetObject("propertyGrid1.Size")));
            propertyGrid1.TabIndex = ((int)(resources.GetObject("propertyGrid1.TabIndex")));

            this.MaximizeBox = false;
            this.MinimizeBox = false;
            this.AcceptButton = button1;
            this.CancelButton = button1;
            this.HelpRequested += new HelpEventHandler(this.OnHelpRequested);
            this.AccessibleDescription = ((string)(resources.GetObject("$this.AccessibleDescription")));
            this.AccessibleName = ((string)(resources.GetObject("$this.AccessibleName")));
            this.AutoScaleBaseSize = ((System.Drawing.Size)(resources.GetObject("$this.AutoScaleBaseSize")));
            this.ClientSize = ((System.Drawing.Size)(resources.GetObject("$this.ClientSize")));
            this.ControlBox = false;
            this.Cursor = ((System.Windows.Forms.Cursor)(resources.GetObject("$this.Cursor")));
            this.Icon = ((System.Drawing.Icon)(resources.GetObject("$this.Icon")));
            this.ImeMode = ((System.Windows.Forms.ImeMode)(resources.GetObject("$this.ImeMode")));
            this.MinimumSize = ((System.Drawing.Size)(resources.GetObject("$this.MinimumSize")));
            this.StartPosition = ((System.Windows.Forms.FormStartPosition)(resources.GetObject("$this.StartPosition")));
            this.Text = resources.GetString("$this.Text");

            this.Controls.AddRange(new System.Windows.Forms.Control[] {
                this.label1,
                this.propertyGrid1,
                this.checkBox1,
                this.button1});
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\webcontrols\listcontrols\datagridcolumnspage.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataGridColumnsPage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.WebControls.ListControls {

    using System;
    using System.Design;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Data;
    using System.Diagnostics;
    using System.Drawing;
    using System.IO;
    using System.Text;
    using System.Web.UI.Design;
    using System.Web.UI.Design.Util;
    using System.Web.UI.WebControls;
    using System.Windows.Forms;

    using ControlCollection = System.Web.UI.ControlCollection;
    using DataGrid = System.Web.UI.WebControls.DataGrid;
    using DataGridColumn = System.Web.UI.WebControls.DataGridColumn;
    using DataGridColumnCollection = System.Web.UI.WebControls.DataGridColumnCollection;
    using DataBinding = System.Web.UI.DataBinding;

    using Button = System.Windows.Forms.Button;
    using CheckBox = System.Windows.Forms.CheckBox;
    using Color = System.Drawing.Color;
    using Image = System.Drawing.Image;
    using Label = System.Windows.Forms.Label;
    using ListViewItem = System.Windows.Forms.ListViewItem;
    using Panel = System.Windows.Forms.Panel;
    using TextBox = System.Windows.Forms.TextBox;

    /// <include file='doc\DataGridColumnsPage.uex' path='docs/doc[@for="DataGridColumnsPage"]/*' />
    /// <devdoc>
    ///   The Data page for the DataGrid control
    /// </devdoc>
    /// <internalonly/>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal sealed class DataGridColumnsPage : BaseDataListPage {

        private const int ILI_DATASOURCE = 0;
        private const int ILI_BOUND = 1;
        private const int ILI_ALL = 2;
        private const int ILI_CUSTOM = 3;
        private const int ILI_BUTTON = 4;
        private const int ILI_SELECTBUTTON = 5;
        private const int ILI_EDITBUTTON = 6;
        private const int ILI_DELETEBUTTON = 7;
        private const int ILI_HYPERLINK = 8;
        private const int ILI_TEMPLATE = 9;

        private CheckBox autoColumnCheck;
        private TreeView availableColumnsTree;
        private Button addColumnButton;
        private ListView selColumnsList;
        private IconButton moveColumnUpButton;
        private IconButton moveColumnDownButton;
        private IconButton deleteColumnButton;
        private GroupLabel columnPropsGroup;
        private TextBox columnHeaderTextEdit;
        private TextBox columnHeaderImageEdit;
        private TextBox columnFooterTextEdit;
        private ComboBox columnSortExprCombo;
        private CheckBox columnVisibleCheck;
        private Button columnHeaderImagePickerButton;
        private LinkLabel templatizeLink;
        private BoundColumnEditor boundColumnEditor;
        private ButtonColumnEditor buttonColumnEditor;
        private HyperLinkColumnEditor hyperLinkColumnEditor;
        private EditCommandColumnEditor editCommandColumnEditor;

        private DataSourceItem currentDataSource;

        private DataSourceNode selectedDataSourceNode;
        private ColumnItem currentColumnItem;
        private ColumnItemEditor currentColumnEditor;
        private bool propChangesPending;
        private bool headerTextChanged;

        /// <include file='doc\DataGridColumnsPage.uex' path='docs/doc[@for="DataGridColumnsPage.DataGridColumnsPage"]/*' />
        /// <devdoc>
        ///   Creates a new instance of DataGridColumnsPage.
        /// </devdoc>
        public DataGridColumnsPage() : base() {
        }

        /// <include file='doc\DataGridColumnsPage.uex' path='docs/doc[@for="DataGridColumnsPage.HelpKeyword"]/*' />
        protected override string HelpKeyword {
            get {
                return "net.Asp.DataGridProperties.Columns";
            }
        }

        /// <include file='doc\DataGridColumnsPage.uex' path='docs/doc[@for="DataGridColumnsPage.InitForm"]/*' />
        /// <devdoc>
        ///    Creates the UI of the page.
        /// </devdoc>
        private void InitForm() {
            this.autoColumnCheck = new CheckBox();
            GroupLabel columnListGroup = new GroupLabel();
            Label availableColumnsLabel = new Label();
            this.availableColumnsTree = new TreeView();
            this.addColumnButton = new Button();
            Label selColumnsLabel = new Label();
            this.selColumnsList = new ListView();
            this.moveColumnUpButton = new IconButton();
            this.moveColumnDownButton = new IconButton();
            this.deleteColumnButton = new IconButton();
            this.columnPropsGroup = new GroupLabel();
            Label columnHeaderTextLabel = new Label();
            this.columnHeaderTextEdit = new TextBox();
            Label columnHeaderImageLabel = new Label();
            this.columnHeaderImageEdit = new TextBox();
            this.columnHeaderImagePickerButton = new Button();
            Label columnFooterTextLabel = new Label();
            this.columnFooterTextEdit = new TextBox();
            Label columnSortExprLabel = new Label();
            this.columnSortExprCombo = new ComboBox();
            this.columnVisibleCheck = new CheckBox();
            this.boundColumnEditor = new BoundColumnEditor();
            this.buttonColumnEditor = new ButtonColumnEditor();
            this.hyperLinkColumnEditor = new HyperLinkColumnEditor();
            this.editCommandColumnEditor = new EditCommandColumnEditor();
            this.templatizeLink = new LinkLabel();

            Image columnNodesBitmap = new Bitmap(this.GetType(), "ColumnNodes.bmp");
            ImageList columnImages = new ImageList();
            columnImages.TransparentColor = Color.Teal;
            columnImages.Images.AddStrip(columnNodesBitmap);

            autoColumnCheck.SetBounds(4, 4, 400, 16);
            autoColumnCheck.Text = SR.GetString(SR.DGCol_AutoGen);
            autoColumnCheck.TabIndex = 0;
            autoColumnCheck.TextAlign = ContentAlignment.MiddleLeft;
            autoColumnCheck.FlatStyle = FlatStyle.System;
            autoColumnCheck.CheckedChanged += new EventHandler(this.OnCheckChangedAutoColumn);

            columnListGroup.SetBounds(4, 24, 431, 14);
            columnListGroup.Text = SR.GetString(SR.DGCol_ColListGroup);
            columnListGroup.TabStop = false;
            columnListGroup.TabIndex = 1;

            availableColumnsLabel.SetBounds(12, 40, 184, 16);
            availableColumnsLabel.Text = SR.GetString(SR.DGCol_AvailableCols);
            availableColumnsLabel.TabStop = false;
            availableColumnsLabel.TabIndex = 2;

            availableColumnsTree.SetBounds(12, 58, 170, 88);
            availableColumnsTree.ImageList = columnImages;
            availableColumnsTree.Indent = 5;
            availableColumnsTree.HideSelection = false;
            availableColumnsTree.TabIndex = 3;
            availableColumnsTree.AfterSelect += new TreeViewEventHandler(this.OnSelChangedAvailableColumns);

            addColumnButton.SetBounds(187, 82, 31, 24);
            addColumnButton.Text = ">";
            addColumnButton.TabIndex = 4;
            addColumnButton.FlatStyle = FlatStyle.System;
            addColumnButton.Click += new EventHandler(this.OnClickAddColumn);

            selColumnsLabel.SetBounds(226, 40, 200, 14);
            selColumnsLabel.Text = SR.GetString(SR.DGCol_SelectedCols);
            selColumnsLabel.TabStop = false;
            selColumnsLabel.TabIndex = 5;

            ColumnHeader columnHeader = new ColumnHeader();
            columnHeader.Width = 176;

            selColumnsList.SetBounds(222, 58, 180, 88);
            selColumnsList.Columns.Add(columnHeader);
            selColumnsList.SmallImageList = columnImages;
            selColumnsList.View = View.Details;
            selColumnsList.HeaderStyle = ColumnHeaderStyle.None;
            selColumnsList.LabelWrap = false;
            selColumnsList.HideSelection = false;
            selColumnsList.MultiSelect = false;
            selColumnsList.TabIndex = 6;
            selColumnsList.SelectedIndexChanged += new EventHandler(this.OnSelIndexChangedSelColumnsList);

            moveColumnUpButton.SetBounds(406, 58, 28, 27);
            moveColumnUpButton.TabIndex = 7;
            moveColumnUpButton.Icon = new Icon(this.GetType(), "SortUp.ico");
            moveColumnUpButton.Click += new EventHandler(this.OnClickMoveColumnUp);

            moveColumnDownButton.SetBounds(406, 88, 28, 27);
            moveColumnDownButton.TabIndex = 8;
            moveColumnDownButton.Icon = new Icon(this.GetType(), "SortDown.ico");
            moveColumnDownButton.Click += new EventHandler(this.OnClickMoveColumnDown);

            deleteColumnButton.SetBounds(406, 118, 28, 27);
            deleteColumnButton.TabIndex = 9;
            deleteColumnButton.Icon = new Icon(this.GetType(), "Delete.ico");
            deleteColumnButton.Click += new EventHandler(this.OnClickDeleteColumn);

            columnPropsGroup.SetBounds(8, 150, 431, 14);
            columnPropsGroup.Text = SR.GetString(SR.DGCol_ColumnPropsGroup1);
            columnPropsGroup.TabStop = false;
            columnPropsGroup.TabIndex = 10;

            columnHeaderTextLabel.SetBounds(20, 166, 180, 14);
            columnHeaderTextLabel.Text = SR.GetString(SR.DGCol_HeaderText);
            columnHeaderTextLabel.TabStop = false;
            columnHeaderTextLabel.TabIndex = 11;

            columnHeaderTextEdit.SetBounds(20, 182, 182, 24);
            columnHeaderTextEdit.TabIndex = 12;
            columnHeaderTextEdit.TextChanged += new EventHandler(this.OnTextChangedColHeaderText);
            columnHeaderTextEdit.LostFocus += new EventHandler(this.OnLostFocusColHeaderText);

            columnHeaderImageLabel.SetBounds(20, 208, 180, 14);
            columnHeaderImageLabel.Text = SR.GetString(SR.DGCol_HeaderImage);
            columnHeaderImageLabel.TabStop = false;
            columnHeaderImageLabel.TabIndex = 13;

            columnHeaderImageEdit.SetBounds(20, 224, 156, 24);
            columnHeaderImageEdit.TabIndex = 14;
            columnHeaderImageEdit.TextChanged += new EventHandler(this.OnChangedColumnProperties);

            columnHeaderImagePickerButton.SetBounds(180, 223, 24, 23);
            columnHeaderImagePickerButton.Text = "...";
            columnHeaderImagePickerButton.TabIndex = 15;
            columnHeaderImagePickerButton.FlatStyle = FlatStyle.System;
            columnHeaderImagePickerButton.Click += new EventHandler(this.OnClickColHeaderImagePicker);

            columnFooterTextLabel.SetBounds(220, 166, 180, 14);
            columnFooterTextLabel.Text = SR.GetString(SR.DGCol_FooterText);
            columnFooterTextLabel.TabStop = false;
            columnFooterTextLabel.TabIndex = 16;

            columnFooterTextEdit.SetBounds(220, 182, 182, 24);
            columnFooterTextEdit.TabIndex = 17;
            columnFooterTextEdit.TextChanged += new EventHandler(this.OnChangedColumnProperties);

            columnSortExprLabel.SetBounds(220, 208, 144, 16);
            columnSortExprLabel.Text = SR.GetString(SR.DGCol_SortExpr);
            columnSortExprLabel.TabStop = false;
            columnSortExprLabel.TabIndex = 18;

            columnSortExprCombo.SetBounds(220, 224, 140, 21);
            columnSortExprCombo.TabIndex = 19;
            columnSortExprCombo.TextChanged += new EventHandler(this.OnChangedColumnProperties);
            columnSortExprCombo.SelectedIndexChanged += new EventHandler(this.OnChangedColumnProperties);

            columnVisibleCheck.SetBounds(368, 222, 100, 16);
            columnVisibleCheck.Text = SR.GetString(SR.DGCol_Visible);
            columnVisibleCheck.TabIndex = 20;
            columnVisibleCheck.FlatStyle = FlatStyle.System;
            columnVisibleCheck.CheckedChanged += new EventHandler(this.OnChangedColumnProperties);

            boundColumnEditor.SetBounds(20, 250, 416, 164);
            boundColumnEditor.TabIndex = 21;
            boundColumnEditor.Visible = false;
            boundColumnEditor.Changed += new EventHandler(this.OnChangedColumnProperties);

            buttonColumnEditor.SetBounds(20, 250, 416, 164);
            buttonColumnEditor.TabIndex = 22;
            buttonColumnEditor.Visible = false;
            buttonColumnEditor.Changed += new EventHandler(this.OnChangedColumnProperties);

            hyperLinkColumnEditor.SetBounds(20, 250, 416, 164);
            hyperLinkColumnEditor.TabIndex = 23;
            hyperLinkColumnEditor.Visible = false;
            hyperLinkColumnEditor.Changed += new EventHandler(this.OnChangedColumnProperties);

            editCommandColumnEditor.SetBounds(20, 250, 416, 164);
            editCommandColumnEditor.TabIndex = 24;
            editCommandColumnEditor.Visible = false;
            editCommandColumnEditor.Changed += new EventHandler(this.OnChangedColumnProperties);

            templatizeLink.SetBounds(18, 414, 400, 16);
            templatizeLink.TabIndex = 25;
            templatizeLink.Text = SR.GetString(SR.DGCol_Templatize);
            templatizeLink.Visible = false;
            templatizeLink.LinkClicked += new LinkLabelLinkClickedEventHandler(this.OnClickTemplatize);

            this.Text = SR.GetString(SR.DGCol_Text);
            this.Size = new Size(464, 432);
            this.CommitOnDeactivate = true;
            this.Icon = new Icon(this.GetType(), "DataGridColumnsPage.ico");

            this.Controls.Clear();
            this.Controls.AddRange(new Control[] {
                                    templatizeLink,
                                    editCommandColumnEditor,
                                    hyperLinkColumnEditor,
                                    buttonColumnEditor,
                                    boundColumnEditor,
                                    columnVisibleCheck,
                                    columnSortExprCombo,
                                    columnSortExprLabel,
                                    columnFooterTextEdit,
                                    columnFooterTextLabel,
                                    columnHeaderImagePickerButton,
                                    columnHeaderImageEdit,
                                    columnHeaderImageLabel,
                                    columnHeaderTextEdit,
                                    columnHeaderTextLabel,
                                    columnPropsGroup,
                                    deleteColumnButton,
                                    moveColumnDownButton,
                                    moveColumnUpButton,
                                    selColumnsList,
                                    selColumnsLabel,
                                    addColumnButton,
                                    availableColumnsTree,
                                    availableColumnsLabel,
                                    columnListGroup,
                                    autoColumnCheck
                                });
        }

        /// <include file='doc\DataGridColumnsPage.uex' path='docs/doc[@for="DataGridColumnsPage.InitPage"]/*' />
        /// <devdoc>
        ///   Initializes the page before it can be loaded with the component.
        /// </devdoc>
        private void InitPage() {
            currentDataSource = null;

            autoColumnCheck.Checked = false;

            selectedDataSourceNode = null;
            availableColumnsTree.Nodes.Clear();
            selColumnsList.Items.Clear();
            currentColumnItem = null;
            
            columnSortExprCombo.Items.Clear();

            currentColumnEditor = null;
            boundColumnEditor.ClearDataFields();
            buttonColumnEditor.ClearDataFields();
            hyperLinkColumnEditor.ClearDataFields();
            editCommandColumnEditor.ClearDataFields();

            propChangesPending = false;
            headerTextChanged = false;
        }

        /// <include file='doc\DataGridColumnsPage.uex' path='docs/doc[@for="DataGridColumnsPage.LoadColumnProperties"]/*' />
        /// <devdoc>
        ///   Loads the properties of a column into the ui
        /// </devdoc>
        private void LoadColumnProperties() {
            string propGroupText = SR.GetString(SR.DGCol_ColumnPropsGroup1);

            if (currentColumnItem != null) {
                EnterLoadingMode();

                columnHeaderTextEdit.Text = currentColumnItem.HeaderText;
                columnHeaderImageEdit.Text = currentColumnItem.HeaderImageUrl;
                columnFooterTextEdit.Text = currentColumnItem.FooterText;
                columnSortExprCombo.Text = currentColumnItem.SortExpression;
                columnVisibleCheck.Checked = currentColumnItem.Visible;

                currentColumnEditor = null;
                if (currentColumnItem is BoundColumnItem) {
                    currentColumnEditor = boundColumnEditor;
                    propGroupText = String.Format(SR.GetString(SR.DGCol_ColumnPropsGroup2), "BoundColumn");
                }
                else if (currentColumnItem is ButtonColumnItem) {
                    currentColumnEditor = buttonColumnEditor;
                    propGroupText = String.Format(SR.GetString(SR.DGCol_ColumnPropsGroup2), "ButtonColumn");
                }
                else if (currentColumnItem is HyperLinkColumnItem) {
                    currentColumnEditor = hyperLinkColumnEditor;
                    propGroupText = String.Format(SR.GetString(SR.DGCol_ColumnPropsGroup2), "HyperLinkColumn");
                }
                else if (currentColumnItem is EditCommandColumnItem) {
                    currentColumnEditor = editCommandColumnEditor;
                    propGroupText = String.Format(SR.GetString(SR.DGCol_ColumnPropsGroup2), "EditCommandColumn");
                }
                else if (currentColumnItem is TemplateColumnItem) {
                    propGroupText = String.Format(SR.GetString(SR.DGCol_ColumnPropsGroup2), "TemplateColumn");
                }

                if (currentColumnEditor != null) {
                    currentColumnEditor.LoadColumn(currentColumnItem);
                }

                ExitLoadingMode();
            }
            columnPropsGroup.Text = propGroupText;
        }

        /// <include file='doc\DataGridColumnsPage.uex' path='docs/doc[@for="DataGridColumnsPage.LoadColumns"]/*' />
        /// <devdoc>
        ///   Loads the columns collection
        /// </devdoc>
        private void LoadColumns() {
            DataGrid dataGrid = (DataGrid)GetBaseControl();
            DataGridColumnCollection columns = dataGrid.Columns;

            if (columns != null) {
                int columnCount = columns.Count;

                for (int i = 0; i < columnCount; i++) {
                    DataGridColumn column = columns[i];
                    ColumnItem newItem = null;

                    // create the associated design time column
                    if (column is BoundColumn) {
                        newItem = new BoundColumnItem((BoundColumn)column);
                    }
                    else if (column is ButtonColumn) {
                        newItem = new ButtonColumnItem((ButtonColumn)column);
                    }
                    else if (column is HyperLinkColumn) {
                        newItem = new HyperLinkColumnItem((HyperLinkColumn)column);
                    }
                    else if (column is TemplateColumn) {
                        newItem = new TemplateColumnItem((TemplateColumn)column);
                    }
                    else if (column is EditCommandColumn) {
                        newItem = new EditCommandColumnItem((EditCommandColumn)column);
                    }
                    else {
                        newItem = new CustomColumnItem(column);
                    }

                    newItem.LoadColumnInfo();
                    selColumnsList.Items.Add(newItem);
                }

                if (selColumnsList.Items.Count != 0) {
                    currentColumnItem = (ColumnItem)selColumnsList.Items[0];
                    currentColumnItem.Selected = true;
                }
            }
        }

        /// <include file='doc\DataGridColumnsPage.uex' path='docs/doc[@for="DataGridColumnsPage.LoadComponent"]/*' />
        /// <devdoc>
        ///   Loads the component into the page.
        /// </devdoc>
        protected override void LoadComponent() {
            InitPage();

            DataGrid dataGrid = (DataGrid)GetBaseControl();

            LoadDataSourceItem();
            LoadAvailableColumnsTree();
            LoadDataSourceFields();

            autoColumnCheck.Checked = dataGrid.AutoGenerateColumns;
            LoadColumns();

            UpdateEnabledVisibleState();
        }

        /// <include file='doc\DataGridColumnsPage.uex' path='docs/doc[@for="DataGridColumnsPage.LoadDataSourceItem"]/*' />
        /// <devdoc>
        ///   Loads the selected datasource
        /// </devdoc>
        private void LoadDataSourceItem() {
            DataGrid dataGrid = (DataGrid)GetBaseControl();
            DataGridDesigner dataGridDesigner = (DataGridDesigner)GetBaseDesigner();

            string dataSourceValue = dataGridDesigner.DataSource;

            if (dataSourceValue != null) {
                ISite thisSite = dataGrid.Site;
                Debug.Assert(thisSite != null, "Expected site on the selected component");

                IContainer container = (IContainer)thisSite.GetService(typeof(IContainer));
                if (container != null) {
                    IComponent component = container.Components[dataSourceValue];
                    if (component != null) {
                        if (component is IListSource) {
                            ListSourceDataSourceItem dsItem = new ListSourceDataSourceItem(dataSourceValue, (IListSource)component);
                            dsItem.CurrentDataMember = dataGridDesigner.DataMember;
                            currentDataSource = dsItem;
                        }
                        else if (component is IEnumerable) {
                            currentDataSource = new DataSourceItem(dataSourceValue, (IEnumerable)component);
                        }
                    }
                }
            }
        }

        /// <include file='doc\DataGridColumnsPage.uex' path='docs/doc[@for="DataGridColumnsPage.LoadDataSourceFields"]/*' />
        /// <devdoc>
        ///   Loads the fields present in the selected datasource
        /// </devdoc>
        private void LoadDataSourceFields() {
            EnterLoadingMode();

            if (currentDataSource != null) {
                PropertyDescriptorCollection dataSourceFields = currentDataSource.Fields;

                if (dataSourceFields != null) {
                    int fieldCount = dataSourceFields.Count;

                    if (fieldCount > 0) {
                        DataFieldNode allFieldsNode = new DataFieldNode();
                        selectedDataSourceNode.Nodes.Add(allFieldsNode);

                        IEnumerator fieldEnum = dataSourceFields.GetEnumerator();
                        while (fieldEnum.MoveNext()) {
                            PropertyDescriptor fieldDesc = (PropertyDescriptor)fieldEnum.Current;

                            if (DataGrid.IsBindableType(fieldDesc.PropertyType)) {
                                string fieldName = fieldDesc.Name;
                                
                                DataFieldNode fieldNode = new DataFieldNode(fieldName);
                                selectedDataSourceNode.Nodes.Add(fieldNode);

                                boundColumnEditor.AddDataField(fieldName);
                                buttonColumnEditor.AddDataField(fieldName);
                                hyperLinkColumnEditor.AddDataField(fieldName);
                                editCommandColumnEditor.AddDataField(fieldName);

                                columnSortExprCombo.Items.Add(fieldName);
                            }
                        }

                        availableColumnsTree.SelectedNode = allFieldsNode;
                        allFieldsNode.EnsureVisible();
                    }
                }
            }
            else {
                DataFieldNode genericBoundColumn = new DataFieldNode(null);
                availableColumnsTree.Nodes.Insert(0, genericBoundColumn);
                availableColumnsTree.SelectedNode = genericBoundColumn;
                genericBoundColumn.EnsureVisible();
            }

            ExitLoadingMode();
        }

        /// <include file='doc\DataGridColumnsPage.uex' path='docs/doc[@for="DataGridColumnsPage.LoadAvailableColumnsTree"]/*' />
        /// <devdoc>
        ///    Loads the fixed nodes in the available columns tree, i.e., the
        ///    DataSource, Button and HyperLink nodes
        /// </devdoc>
        private void LoadAvailableColumnsTree() {
            if (currentDataSource != null) {
                selectedDataSourceNode = new DataSourceNode();
                availableColumnsTree.Nodes.Add(selectedDataSourceNode);
            }

            ButtonNode buttonNode = new ButtonNode();
            availableColumnsTree.Nodes.Add(buttonNode);

            ButtonNode selectButtonNode = new ButtonNode(DataGrid.SelectCommandName, SR.GetString(SR.DGCol_SelectButton), SR.GetString(SR.DGCol_Node_Select));
            buttonNode.Nodes.Add(selectButtonNode);

            EditCommandNode editButtonNode = new EditCommandNode();
            buttonNode.Nodes.Add(editButtonNode);

            ButtonNode deleteButtonNode = new ButtonNode(DataGrid.DeleteCommandName, SR.GetString(SR.DGCol_DeleteButton), SR.GetString(SR.DGCol_Node_Delete));
            buttonNode.Nodes.Add(deleteButtonNode);

            HyperLinkNode hyperLinkNode = new HyperLinkNode();
            availableColumnsTree.Nodes.Add(hyperLinkNode);

            TemplateNode templateNode = new TemplateNode();
            availableColumnsTree.Nodes.Add(templateNode);
        }

        /// <include file='doc\DataGridColumnsPage.uex' path='docs/doc[@for="DataGridColumnsPage.OnChangedColumnProperties"]/*' />
        /// <devdoc>
        ///    Handles changes to the column properties made in the column node editor.
        ///    Sets a flag to indicate there are pending changes.
        /// </devdoc>
        private void OnChangedColumnProperties(object source, EventArgs e) {
            if (IsLoading())
                return;

            propChangesPending = true;
            SetDirty();
        }

        /// <include file='doc\DataGridColumnsPage.uex' path='docs/doc[@for="DataGridColumnsPage.OnCheckChangedAutoColumn"]/*' />
        /// <devdoc>
        ///    Handles changes to the auto column generation choice.
        ///    When this functionality is turned on, the columns collection is
        ///    cleared, and auto generated columns are shown. When it is turned
        ///    off, nothing is done, which effectively makes the auto generated
        ///    columns part of the column collection.
        /// </devdoc>
        private void OnCheckChangedAutoColumn(object source, EventArgs e) {
            if (IsLoading())
                return;

            SetDirty();
            UpdateEnabledVisibleState();
        }

        /// <include file='doc\DataGridColumnsPage.uex' path='docs/doc[@for="DataGridColumnsPage.OnClickAddColumn"]/*' />
        /// <devdoc>
        ///    Adds a column to the column collection
        /// </devdoc>
        private void OnClickAddColumn(object source, EventArgs e) {
            AvailableColumnNode selectedNode = (AvailableColumnNode)availableColumnsTree.SelectedNode;

            Debug.Assert((selectedNode != null) &&
                         selectedNode.IsColumnCreator,
                         "Add button should not have been enabled");

            // first save off any pending changes
            if (propChangesPending) {
                SaveColumnProperties();
            }

            if (selectedNode.CreatesMultipleColumns == false) {
                ColumnItem column = selectedNode.CreateColumn();

                selColumnsList.Items.Add(column);
                currentColumnItem = column;
                currentColumnItem.Selected = true;
                currentColumnItem.EnsureVisible();
            }
            else {
                ColumnItem[] columns = selectedNode.CreateColumns(currentDataSource.Fields);
                int columnCount = columns.Length;

                for (int i = 0; i < columnCount; i++) {
                    selColumnsList.Items.Add(columns[i]);
                }
                currentColumnItem = columns[columnCount - 1];
                currentColumnItem.Selected = true;
                currentColumnItem.EnsureVisible();
            }

            selColumnsList.Focus();

            SetDirty();
            UpdateEnabledVisibleState();
        }

        /// <include file='doc\DataGridColumnsPage.uex' path='docs/doc[@for="DataGridColumnsPage.OnClickColHeaderImagePicker"]/*' />
        /// <devdoc>
        ///   Handles clicks on the column image picker button.
        /// </devdoc>
        private void OnClickColHeaderImagePicker(object source, EventArgs e) {
            string url = columnHeaderImageEdit.Text.Trim();
            string caption = SR.GetString(SR.DGCol_URLPCaption);
            string filter = SR.GetString(SR.DGCol_URLPFilter);

            url = System.Web.UI.Design.UrlBuilder.BuildUrl(GetBaseControl(), this, url, caption, filter);
            if (url != null) {
                columnHeaderImageEdit.Text = url;
                OnChangedColumnProperties(columnHeaderImageEdit, EventArgs.Empty);
            }
        }

        /// <include file='doc\DataGridColumnsPage.uex' path='docs/doc[@for="DataGridColumnsPage.OnClickDeleteColumn"]/*' />
        /// <devdoc>
        ///   Deletes a column from the column collection.
        /// </devdoc>
        private void OnClickDeleteColumn(object source, EventArgs e) {
            Debug.Assert(currentColumnItem != null, "Must have a column item to delete");

            int currentIndex = currentColumnItem.Index;
            int nextIndex = -1;
            int itemCount = selColumnsList.Items.Count;

            if (itemCount > 1) {
                if (currentIndex == (itemCount - 1))
                    nextIndex = currentIndex - 1;
                else
                    nextIndex = currentIndex;
            }

            // discard changes that might have existed for the column
            propChangesPending = false;
            currentColumnItem.Remove();
            currentColumnItem = null;

            if (nextIndex != -1) {
                currentColumnItem = (ColumnItem)selColumnsList.Items[nextIndex];
                currentColumnItem.Selected = true;
                currentColumnItem.EnsureVisible();
            }

            SetDirty();
            UpdateEnabledVisibleState();
        }

        /// <include file='doc\DataGridColumnsPage.uex' path='docs/doc[@for="DataGridColumnsPage.OnClickMoveColumnDown"]/*' />
        /// <devdoc>
        ///   Move a column down within the column collection
        /// </devdoc>
        private void OnClickMoveColumnDown(object source, EventArgs e) {
            Debug.Assert(currentColumnItem != null, "Must have a column item to move");

            if (propChangesPending) {
                SaveColumnProperties();
            }

            int indexCurrent = currentColumnItem.Index;
            Debug.Assert(indexCurrent < selColumnsList.Items.Count - 1,
                         "Move down not allowed");

            ListViewItem temp = selColumnsList.Items[indexCurrent];
            selColumnsList.Items.RemoveAt(indexCurrent);
            selColumnsList.Items.Insert(indexCurrent + 1, temp);
            
            currentColumnItem = (ColumnItem)selColumnsList.Items[indexCurrent + 1];
            currentColumnItem.Selected = true;
            currentColumnItem.EnsureVisible();

            SetDirty();
            UpdateEnabledVisibleState();
        }

        /// <include file='doc\DataGridColumnsPage.uex' path='docs/doc[@for="DataGridColumnsPage.OnClickMoveColumnUp"]/*' />
        /// <devdoc>
        ///   Move a column up within the column collection
        /// </devdoc>
        private void OnClickMoveColumnUp(object source, EventArgs e) {
            Debug.Assert(currentColumnItem != null, "Must have a column item to move");

            if (propChangesPending) {
                SaveColumnProperties();
            }

            int indexCurrent = currentColumnItem.Index;
            Debug.Assert(indexCurrent > 0, "Move up not allowed");

            ListViewItem temp = selColumnsList.Items[indexCurrent];
            selColumnsList.Items.RemoveAt(indexCurrent);
            selColumnsList.Items.Insert(indexCurrent - 1, temp);

            currentColumnItem = (ColumnItem)selColumnsList.Items[indexCurrent - 1];
            currentColumnItem.Selected = true;
            currentColumnItem.EnsureVisible();

            SetDirty();
            UpdateEnabledVisibleState();
        }

        /// <include file='doc\DataGridColumnsPage.uex' path='docs/doc[@for="DataGridColumnsPage.OnClickTemplatize"]/*' />
        /// <devdoc>
        ///   Converts a column into an equivalent template column.
        /// </devdoc>
        private void OnClickTemplatize(object source, LinkLabelLinkClickedEventArgs e) {
            Debug.Assert(currentColumnItem != null, "Must have a column item to templatize");
            Debug.Assert((currentColumnItem is BoundColumnItem) ||
                         (currentColumnItem is ButtonColumnItem) ||
                         (currentColumnItem is HyperLinkColumnItem) ||
                         (currentColumnItem is EditCommandColumnItem),
                         "Unexpected type of column being templatized");

            if (propChangesPending) {
                SaveColumnProperties();
            }

            currentColumnItem.SaveColumnInfo();

            TemplateColumn newColumn;
            TemplateColumnItem newColumnItem;

            newColumn = currentColumnItem.GetTemplateColumn((DataGrid)GetBaseControl());
            newColumnItem = new TemplateColumnItem(newColumn);
            newColumnItem.LoadColumnInfo();

            selColumnsList.Items[currentColumnItem.Index] = newColumnItem;
            
            currentColumnItem = newColumnItem;
            currentColumnItem.Selected = true;

            SetDirty();
            UpdateEnabledVisibleState();
        }

        /// <include file='doc\DataGridColumnsPage.uex' path='docs/doc[@for="DataGridColumnsPage.OnLostFocusColHeaderText"]/*' />
        /// <devdoc>
        ///    Handles focus lost on the column header text edit box, so the
        ///    column name can be changed in the selected columns tree.
        /// </devdoc>
        private void OnLostFocusColHeaderText(object source, EventArgs e) {
            if (headerTextChanged) {
                headerTextChanged = false;

                if (currentColumnItem != null) {
                    // LostFocus event might come in after the ListView's selectionchange,
                    // in which case the HeaderText has been taken care off.
                    currentColumnItem.HeaderText = columnHeaderTextEdit.Text;
                }
            }
        }

        /// <include file='doc\DataGridColumnsPage.uex' path='docs/doc[@for="DataGridColumnsPage.OnSelChangedAvailableColumns"]/*' />
        /// <devdoc>
        ///    Handles selection change in the available columns tree.
        /// </devdoc>
        private void OnSelChangedAvailableColumns(object source, TreeViewEventArgs e) {
            UpdateEnabledVisibleState();
        }

        /// <include file='doc\DataGridColumnsPage.uex' path='docs/doc[@for="DataGridColumnsPage.OnSelIndexChangedSelColumnsList"]/*' />
        /// <devdoc>
        ///    Handles selection change within the selected columns list.
        /// </devdoc>
        private void OnSelIndexChangedSelColumnsList(object source, EventArgs e) {
            if (propChangesPending) {
                SaveColumnProperties();
            }

            if (selColumnsList.SelectedItems.Count == 0)
                currentColumnItem = null;
            else
                currentColumnItem = (ColumnItem)selColumnsList.SelectedItems[0];
            LoadColumnProperties();
            UpdateEnabledVisibleState();
        }

        /// <include file='doc\DataGridColumnsPage.uex' path='docs/doc[@for="DataGridColumnsPage.OnTextChangedColHeaderText"]/*' />
        /// <devdoc>
        ///    Handles changes made to the column header text.
        /// </devdoc>
        private void OnTextChangedColHeaderText(object source, EventArgs e) {
            if (IsLoading())
                return;

            headerTextChanged = true;
            propChangesPending = true;
            SetDirty();
        }

        /// <include file='doc\DataGridColumnsPage.uex' path='docs/doc[@for="DataGridColumnsPage.SaveColumnProperties"]/*' />
        /// <devdoc>
        ///   Saves the properties of a column from the ui
        /// </devdoc>
        private void SaveColumnProperties() {
            Debug.Assert(propChangesPending == true, "Unneccessary call to SaveColumnProperties.");

            if (currentColumnItem != null) {
                currentColumnItem.HeaderText = columnHeaderTextEdit.Text;
                currentColumnItem.HeaderImageUrl = columnHeaderImageEdit.Text.Trim();
                currentColumnItem.FooterText = columnFooterTextEdit.Text;
                currentColumnItem.SortExpression = columnSortExprCombo.Text.Trim();
                currentColumnItem.Visible = columnVisibleCheck.Checked;

                if (currentColumnEditor != null)
                    currentColumnEditor.SaveColumn();
            }

            propChangesPending = false;
        }

        /// <include file='doc\DataGridColumnsPage.uex' path='docs/doc[@for="DataGridColumnsPage.SaveComponent"]/*' />
        /// <devdoc>
        ///   Saves the component loaded into the page.
        /// </devdoc>
        protected override void SaveComponent() {
            if (propChangesPending) {
                SaveColumnProperties();
            }

            DataGrid dataGrid = (DataGrid)GetBaseControl();
            DataGridDesigner dataGridDesigner = (DataGridDesigner)GetBaseDesigner();

            dataGrid.AutoGenerateColumns = autoColumnCheck.Checked;

            // save the columns collection
            DataGridColumnCollection columns = dataGrid.Columns;

            columns.Clear();
            int columnCount = selColumnsList.Items.Count;

            for (int i = 0; i < columnCount; i++) {
                ColumnItem columnItem = (ColumnItem)selColumnsList.Items[i];

                columnItem.SaveColumnInfo();
                columns.Add(columnItem.RuntimeColumn);
            }

            dataGridDesigner.OnColumnsChanged();
        }

        /// <include file='doc\DataGridColumnsPage.uex' path='docs/doc[@for="DataGridColumnsPage.SetComponent"]/*' />
        /// <devdoc>
        ///   Sets the component that is to be edited in the page.
        /// </devdoc>
        public override void SetComponent(IComponent component) {
            base.SetComponent(component);
            InitForm();
        }

        /// <include file='doc\DataGridColumnsPage.uex' path='docs/doc[@for="DataGridColumnsPage.UpdateEnabledVisibleState"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void UpdateEnabledVisibleState() {
            AvailableColumnNode selColumnNode = (AvailableColumnNode)availableColumnsTree.SelectedNode;

            int columnCount = selColumnsList.Items.Count;
            int selColumnCount = selColumnsList.SelectedItems.Count;
            ColumnItem selColumn = null;
            int selColumnIndex = -1;

            if (selColumnCount != 0)
                selColumn = (ColumnItem)selColumnsList.SelectedItems[0];
            if (selColumn != null)
                selColumnIndex = selColumn.Index;

            bool columnSelected = (selColumnIndex != -1);

            addColumnButton.Enabled = (selColumnNode != null) && selColumnNode.IsColumnCreator;
            moveColumnUpButton.Enabled = (selColumnIndex > 0);
            moveColumnDownButton.Enabled = (selColumnIndex >= 0) && (selColumnIndex < (columnCount - 1));
            deleteColumnButton.Enabled = columnSelected;

            columnHeaderTextEdit.Enabled = columnSelected;
            columnHeaderImageEdit.Enabled = columnSelected;
            columnHeaderImagePickerButton.Enabled = columnSelected;
            columnFooterTextEdit.Enabled = columnSelected;
            columnSortExprCombo.Enabled = columnSelected;
            columnVisibleCheck.Enabled = columnSelected;

            boundColumnEditor.Visible = (currentColumnEditor == boundColumnEditor);
            buttonColumnEditor.Visible = (currentColumnEditor == buttonColumnEditor);
            hyperLinkColumnEditor.Visible = (currentColumnEditor == hyperLinkColumnEditor);
            editCommandColumnEditor.Visible = (currentColumnEditor == editCommandColumnEditor);

            templatizeLink.Visible = (columnCount != 0) &&
                                     (boundColumnEditor.Visible ||
                                      buttonColumnEditor.Visible ||
                                      hyperLinkColumnEditor.Visible ||
                                      editCommandColumnEditor.Visible);
        }



        /// <include file='doc\DataGridColumnsPage.uex' path='docs/doc[@for="DataGridColumnsPage.AvailableColumnNode"]/*' />
        /// <devdoc>
        /// </devdoc>
        private abstract class AvailableColumnNode : TreeNode {

            public AvailableColumnNode(string text, int icon) : base(text, icon, icon) {
            }

            public virtual bool CreatesMultipleColumns {
                get {
                    return false;
                }
            }

            public virtual bool IsColumnCreator {
                get {
                    return true;
                }
            }

            public virtual ColumnItem CreateColumn() {
                return null;
            }

            public virtual ColumnItem[] CreateColumns(PropertyDescriptorCollection fields) {
                return null;
            }
        }

        /// <include file='doc\DataGridColumnsPage.uex' path='docs/doc[@for="DataGridColumnsPage.DataSourceNode"]/*' />
        /// <devdoc>
        ///   This represents the datasource in the available columns tree.
        /// </devdoc>
        private class DataSourceNode : AvailableColumnNode {
            public DataSourceNode() : base(SR.GetString(SR.DGCol_Node_DataFields), DataGridColumnsPage.ILI_DATASOURCE) {
            }

            public override bool IsColumnCreator {
                get {
                    return false;
                }
            }
        }

        /// <include file='doc\DataGridColumnsPage.uex' path='docs/doc[@for="DataGridColumnsPage.DataFieldNode"]/*' />
        /// <devdoc>
        ///   This represents a datafield available in the selected datasource within
        ///   in the available columns tree.
        ///   It could also represent the pseudo column implying all datafields.
        /// </devdoc>
        private class DataFieldNode : AvailableColumnNode {
            protected string fieldName;

            private bool genericBoundColumn;
            private bool allFields;

            public DataFieldNode() : base(SR.GetString(SR.DGCol_Node_AllFields), DataGridColumnsPage.ILI_ALL) {
                this.fieldName = null;
                this.allFields = true;
            }

            public DataFieldNode(string fieldName) : base(fieldName, DataGridColumnsPage.ILI_BOUND) {
                this.fieldName = fieldName;
                if (fieldName == null) {
                    genericBoundColumn = true;
                    Text = SR.GetString(SR.DGCol_Node_Bound);
                }
            }

            public override bool CreatesMultipleColumns {
                get {
                    return allFields;
                }
            }

            public override ColumnItem CreateColumn() {
                BoundColumn runtimeColumn = new BoundColumn();

                if (genericBoundColumn == false) {
                    runtimeColumn.HeaderText = fieldName;
                    runtimeColumn.DataField = fieldName;
                    runtimeColumn.SortExpression = fieldName;
                }

                ColumnItem column = new BoundColumnItem(runtimeColumn);
                column.LoadColumnInfo();

                return column;
            }

            public override ColumnItem[] CreateColumns(PropertyDescriptorCollection fields) {
                ArrayList createdColumns = new ArrayList();

                IEnumerator fieldEnum = fields.GetEnumerator();
                while (fieldEnum.MoveNext()) {
                    PropertyDescriptor fieldDesc = (PropertyDescriptor)fieldEnum.Current;

                    if (DataGrid.IsBindableType(fieldDesc.PropertyType)) {
                        BoundColumn runtimeColumn = new BoundColumn();

                        runtimeColumn.HeaderText = fieldDesc.Name;
                        runtimeColumn.DataField = fieldDesc.Name;

                        ColumnItem column = new BoundColumnItem(runtimeColumn);
                        column.LoadColumnInfo();
                        createdColumns.Add(column);
                    }
                }

                return (ColumnItem[])createdColumns.ToArray(typeof(ColumnItem));
            }
        }

        /// <include file='doc\DataGridColumnsPage.uex' path='docs/doc[@for="DataGridColumnsPage.ButtonNode"]/*' />
        /// <devdoc>
        ///   This represents a button column in the available columns tree.
        /// </devdoc>
        private class ButtonNode : AvailableColumnNode {

            private string command;
            private string buttonText;

            public ButtonNode() : this(String.Empty, SR.GetString(SR.DGCol_Button), SR.GetString(SR.DGCol_Node_Button)) {
            }

            public ButtonNode(string command, string buttonText, string text) : base(text, DataGridColumnsPage.ILI_BUTTON) {
                this.command = command;
                this.buttonText = buttonText;
            }

            public override ColumnItem CreateColumn() {
                ButtonColumn runtimeColumn = new ButtonColumn();
                runtimeColumn.Text = buttonText;
                runtimeColumn.CommandName = command;

                ColumnItem column = new ButtonColumnItem(runtimeColumn);
                column.LoadColumnInfo();

                return column;
            }
        }

        /// <include file='doc\DataGridColumnsPage.uex' path='docs/doc[@for="DataGridColumnsPage.EditCommandNode"]/*' />
        /// <devdoc>
        /// </devdoc>
        private class EditCommandNode : AvailableColumnNode {
            
            public EditCommandNode() : base(SR.GetString(SR.DGCol_Node_Edit), DataGridColumnsPage.ILI_BUTTON) {
            }

            public override ColumnItem CreateColumn() {
                EditCommandColumn runtimeColumn = new EditCommandColumn();
                runtimeColumn.EditText = SR.GetString(SR.DGCol_EditButton);
                runtimeColumn.UpdateText = SR.GetString(SR.DGCol_UpdateButton);
                runtimeColumn.CancelText = SR.GetString(SR.DGCol_CancelButton);

                ColumnItem column = new EditCommandColumnItem(runtimeColumn);
                column.LoadColumnInfo();
                
                return column;
            }
        }

        /// <include file='doc\DataGridColumnsPage.uex' path='docs/doc[@for="DataGridColumnsPage.HyperLinkNode"]/*' />
        /// <devdoc>
        ///   This represents a HyperLink column in the available columns tree.
        /// </devdoc>
        private class HyperLinkNode : AvailableColumnNode {
            private string hyperLinkText;

            public HyperLinkNode() : this(SR.GetString(SR.DGCol_HyperLink)) {
            }

            public HyperLinkNode(string hyperLinkText) : base(SR.GetString(SR.DGCol_Node_HyperLink), DataGridColumnsPage.ILI_HYPERLINK) {
                this.hyperLinkText = hyperLinkText;
            }

            public override ColumnItem CreateColumn() {
                HyperLinkColumn runtimeColumn = new HyperLinkColumn();

                ColumnItem column = new HyperLinkColumnItem(runtimeColumn);
                column.Text = hyperLinkText;
                column.LoadColumnInfo();

                return column;
            }
        }

        /// <include file='doc\DataGridColumnsPage.uex' path='docs/doc[@for="DataGridColumnsPage.TemplateNode"]/*' />
        /// <devdoc>
        ///   This represents a template column in the available columns tree.
        /// </devdoc>
        private class TemplateNode : AvailableColumnNode {
            public TemplateNode() : base(SR.GetString(SR.DGCol_Node_Template), DataGridColumnsPage.ILI_TEMPLATE) {
            }

            public override ColumnItem CreateColumn() {
                TemplateColumn runtimeColumn = new TemplateColumn();

                ColumnItem column = new TemplateColumnItem(runtimeColumn);
                // TODO: Possibly set up default templates
                column.LoadColumnInfo();

                return column;
            }
        }



        /// <include file='doc\DataGridColumnsPage.uex' path='docs/doc[@for="DataGridColumnsPage.ColumnItem"]/*' />
        /// <devdoc>
        ///   Represents a column in the columns collection of the DataGrid.
        /// </devdoc>
        private abstract class ColumnItem : ListViewItem {
            protected DataGridColumn runtimeColumn;
            protected string headerText;
            protected string headerImageUrl;
            protected string footerText;
            protected bool visible;
            protected string sortExpression;

            public ColumnItem(DataGridColumn runtimeColumn, int image) : base(String.Empty, image) {
                this.runtimeColumn = runtimeColumn;
                this.headerText = GetDefaultHeaderText();
                this.Text = GetNodeText(null);
            }

            public virtual ColumnItemEditor ColumnEditor {
                get {
                    return null;
                }
            }

            public string HeaderText {
                get {
                    return headerText;
                }
                set {
                    headerText = value;
                    UpdateDisplayText();
                }
            }

            public string HeaderImageUrl {
                get {
                    return headerImageUrl;
                }
                set {
                    headerImageUrl = value;
                }
            }

            public string FooterText {
                get {
                    return footerText;
                }
                set {
                    footerText = value;
                }
            }

            public DataGridColumn RuntimeColumn {
                get {
                    return runtimeColumn;
                }
            }

            public string SortExpression {
                get {
                    return sortExpression;
                }
                set {
                    sortExpression = value;
                }
            }

            public bool Visible {
                get {
                    return visible;
                }
                set {
                    visible = value;
                }
            }

            protected virtual string GetDefaultHeaderText() {
                return SR.GetString(SR.DGCol_Node);
            }

            public virtual string GetNodeText(string headerText) {
                if ((headerText == null) || (headerText.Length == 0)) {
                    return GetDefaultHeaderText();
                }
                else {
                    return headerText;
                }
            }

            protected ITemplate GetTemplate(DataGrid dataGrid, string templateContent) {
                try {
                    ISite site = dataGrid.Site;
                    Debug.Assert(site != null);

                    IDesignerHost designerHost = (IDesignerHost)site.GetService(typeof(IDesignerHost));
                    
                    return ControlParser.ParseTemplate(designerHost, templateContent, null);
                } catch (Exception e) {
                    Debug.Fail(e.ToString());
                    return null;
                }
            }

            public virtual TemplateColumn GetTemplateColumn(DataGrid dataGrid) {
                TemplateColumn column = new TemplateColumn();

                column.HeaderText = headerText;
                column.HeaderImageUrl = headerImageUrl;

                return column;
            }

            public virtual void LoadColumnInfo() {
                headerText = runtimeColumn.HeaderText;
                headerImageUrl = runtimeColumn.HeaderImageUrl;
                footerText = runtimeColumn.FooterText;
                visible = runtimeColumn.Visible;
                sortExpression = runtimeColumn.SortExpression;

                UpdateDisplayText();
            }

            public virtual void SaveColumnInfo() {
                runtimeColumn.HeaderText = headerText;
                runtimeColumn.HeaderImageUrl = headerImageUrl;
                runtimeColumn.FooterText = footerText;
                runtimeColumn.Visible = visible;
                runtimeColumn.SortExpression = sortExpression;
            }

            protected void UpdateDisplayText() {
                this.Text = GetNodeText(headerText);
            }
        }

        /// <include file='doc\DataGridColumnsPage.uex' path='docs/doc[@for="DataGridColumnsPage.BoundColumnItem"]/*' />
        /// <devdoc>
        ///    Represents a column bound to a datafield.
        /// </devdoc>
        private class BoundColumnItem : ColumnItem {
            protected string dataField;
            protected string dataFormatString;
            protected bool readOnly;

            public BoundColumnItem(BoundColumn runtimeColumn) : base(runtimeColumn, DataGridColumnsPage.ILI_BOUND) {
            }

            public string DataField {
                get {
                    return dataField;
                }
                set {
                    dataField = value;
                    UpdateDisplayText();
                }
            }

            public string DataFormatString {
                get {
                    return dataFormatString;
                }
                set {
                    dataFormatString = value;
                }
            }

            public bool ReadOnly {
                get {
                    return readOnly;
                }
                set {
                    readOnly = value;
                }
            }

            protected override string GetDefaultHeaderText() {
                if ((dataField != null) && (dataField.Length != 0)) {
                    return dataField;
                }
                return SR.GetString(SR.DGCol_Node_Bound);
            }

            public override TemplateColumn GetTemplateColumn(DataGrid dataGrid) {
                TemplateColumn column = base.GetTemplateColumn(dataGrid);

                column.ItemTemplate = GetTemplate(dataGrid, GetTemplateContent(false));
                if (readOnly == false) {
                    column.EditItemTemplate = GetTemplate(dataGrid, GetTemplateContent(true));
                }

                return column;
            }

            private string GetTemplateContent(bool editMode) {
                StringBuilder sb = new StringBuilder();
                string tag = (editMode ? "TextBox" : "Label");

                sb.Append("<asp:");
                sb.Append(tag);
                sb.Append(" runat=\"server\"");

                string dataField = ((BoundColumn)this.RuntimeColumn).DataField;
                if (dataField.Length != 0) {
                    sb.Append(" Text='<%# DataBinder.Eval(Container, \"DataItem.");
                    sb.Append(dataField);
                    sb.Append("\"");

                    if (dataFormatString.Length != 0) {
                        sb.Append(", \"");
                        sb.Append(dataFormatString);
                        sb.Append("\"");
                    }
                    sb.Append(") %>'");
                }

                sb.Append("></asp:");
                sb.Append(tag);
                sb.Append(">");

                return sb.ToString();
            }

            public override void LoadColumnInfo() {
                base.LoadColumnInfo();

                BoundColumn column = (BoundColumn)this.RuntimeColumn;

                dataField = column.DataField;
                dataFormatString = column.DataFormatString;
                readOnly = column.ReadOnly;

                UpdateDisplayText();
            }

            public override void SaveColumnInfo() {
                base.SaveColumnInfo();

                BoundColumn column = (BoundColumn)this.RuntimeColumn;

                column.DataField = dataField;
                column.DataFormatString = dataFormatString;
                column.ReadOnly = readOnly;
            }
        }

        /// <include file='doc\DataGridColumnsPage.uex' path='docs/doc[@for="DataGridColumnsPage.ButtonColumnItem"]/*' />
        /// <devdoc>
        ///   Represents a column containing a button.
        /// </devdoc>
        private class ButtonColumnItem : ColumnItem {
            protected string command;
            protected string buttonText;
            protected string buttonDataTextField;
            protected string buttonDataTextFormatString;
            protected ButtonColumnType buttonType;

            public ButtonColumnItem(ButtonColumn runtimeColumn) : base(runtimeColumn, DataGridColumnsPage.ILI_BUTTON) {
            }

            public string Command {
                get {
                    return command;
                }
                set {
                    command = value;
                }
            }

            public string ButtonText {
                get {
                    return buttonText;
                }
                set {
                    buttonText = value;
                    UpdateDisplayText();
                }
            }

            public ButtonColumnType ButtonType {
                get {
                    return buttonType;
                }
                set {
                    buttonType = value;
                }
            }

            public string ButtonDataTextField {
                get {
                    return buttonDataTextField;
                }
                set {
                    buttonDataTextField = value;
                }
            }

            public string ButtonDataTextFormatString {
                get {
                    return buttonDataTextFormatString;
                }
                set {
                    buttonDataTextFormatString = value;
                }
            }

            protected override string GetDefaultHeaderText() {
                if ((buttonText != null) && (buttonText.Length != 0)) {
                    return buttonText;
                }
                return SR.GetString(SR.DGCol_Node_Button);
            }

            public override TemplateColumn GetTemplateColumn(DataGrid dataGrid) {
                TemplateColumn column = base.GetTemplateColumn(dataGrid);

                StringBuilder sb = new StringBuilder();
                string tag = ((buttonType == ButtonColumnType.LinkButton) ? "LinkButton" : "Button");

                sb.Append("<asp:");
                sb.Append(tag);
                sb.Append(" runat=\"server\"");

                if (buttonDataTextField.Length != 0) {
                    sb.Append(" Text='<%# DataBinder.Eval(Container, \"DataItem.");
                    sb.Append(buttonDataTextField);
                    sb.Append("\"");

                    if (buttonDataTextFormatString.Length != 0) {
                        sb.Append(", \"");
                        sb.Append(buttonDataTextFormatString);
                        sb.Append("\"");
                    }
                    sb.Append(") %>'");
                }
                else {
                    sb.Append(" Text=\"");
                    sb.Append(buttonText);
                    sb.Append("\"");
                }
                sb.Append(" CommandName=\"");
                sb.Append(command);
                sb.Append("\"");

                sb.Append(" CausesValidation=\"false\"></asp:");
                sb.Append(tag);
                sb.Append(">");
                
                column.ItemTemplate = GetTemplate(dataGrid, sb.ToString());

                return column;
            }

            public override void LoadColumnInfo() {
                base.LoadColumnInfo();

                ButtonColumn column = (ButtonColumn)this.RuntimeColumn;

                command = column.CommandName;
                buttonText = column.Text;
                buttonDataTextField = column.DataTextField;
                buttonDataTextFormatString = column.DataTextFormatString;
                buttonType = column.ButtonType;

                UpdateDisplayText();
            }

            public override void SaveColumnInfo() {
                base.SaveColumnInfo();

                ButtonColumn column = (ButtonColumn)this.RuntimeColumn;

                column.CommandName = command;
                column.Text = buttonText;
                column.DataTextField = buttonDataTextField;
                column.DataTextFormatString = buttonDataTextFormatString;
                column.ButtonType = buttonType;
            }
        }

        /// <include file='doc\DataGridColumnsPage.uex' path='docs/doc[@for="DataGridColumnsPage.HyperLinkColumnItem"]/*' />
        /// <devdoc>
        ///   Represents a column containing a hyperlink.
        /// </devdoc>
        private class HyperLinkColumnItem : ColumnItem {
            protected string anchorText;
            protected string anchorDataTextField;
            protected string anchorDataTextFormatString;
            protected string url;
            protected string dataUrlField;
            protected string dataUrlFormatString;
            protected string target;

            public HyperLinkColumnItem(HyperLinkColumn runtimeColumn) : base(runtimeColumn, DataGridColumnsPage.ILI_HYPERLINK) {
            }

            public string AnchorText {
                get {
                    return anchorText;
                }
                set {
                    anchorText = value;
                    UpdateDisplayText();
                }
            }

            public string AnchorDataTextField {
                get {
                    return anchorDataTextField;
                }
                set {
                    anchorDataTextField = value;
                }
            }

            public string AnchorDataTextFormatString {
                get {
                    return anchorDataTextFormatString;
                }
                set {
                    anchorDataTextFormatString = value;
                }
            }

            public string Url {
                get {
                    return url;
                }
                set {
                    url = value;
                }
            }

            public string DataUrlField {
                get {
                    return dataUrlField;
                }
                set {
                    dataUrlField = value;
                }
            }

            public string DataUrlFormatString {
                get {
                    return dataUrlFormatString;
                }
                set {
                    dataUrlFormatString = value;
                }
            }

            public string Target {
                get {
                    return target;
                }
                set {
                    target = value;
                }
            }

            protected override string GetDefaultHeaderText() {
                if ((anchorText != null) && (anchorText.Length != 0)) {
                    return anchorText;
                }
                return SR.GetString(SR.DGCol_Node_HyperLink);
            }

            public override TemplateColumn GetTemplateColumn(DataGrid dataGrid) {
                TemplateColumn column = base.GetTemplateColumn(dataGrid);

                StringBuilder sb = new StringBuilder();

                sb.Append("<asp:HyperLink");
                sb.Append(" runat=\"server\"");

                if (anchorDataTextField.Length != 0) {
                    sb.Append(" Text='<%# DataBinder.Eval(Container, \"DataItem.");
                    sb.Append(anchorDataTextField);
                    sb.Append("\"");

                    if (anchorDataTextFormatString.Length != 0) {
                        sb.Append(", \"");
                        sb.Append(anchorDataTextFormatString);
                        sb.Append("\"");
                    }
                    sb.Append(") %>'");
                }
                else {
                    sb.Append(" Text=\"");
                    sb.Append(anchorText);
                    sb.Append("\"");
                }
                if (dataUrlField.Length != 0) {
                    sb.Append(" NavigateUrl='<%# DataBinder.Eval(Container, \"DataItem.");
                    sb.Append(dataUrlField);
                    sb.Append("\"");

                    if (dataUrlFormatString.Length != 0) {
                        sb.Append(", \"");
                        sb.Append(dataUrlFormatString);
                        sb.Append("\"");
                    }
                    sb.Append(") %>'");
                }
                else {
                    sb.Append(" NavigateUrl=\"");
                    sb.Append(url);
                    sb.Append("\"");
                }
                if (target.Length != 0) {
                    sb.Append(" Target=\"");
                    sb.Append(target);
                    sb.Append("\"");
                }

                sb.Append("></asp:HyperLink>");
                
                column.ItemTemplate = GetTemplate(dataGrid, sb.ToString());

                return column;
            }

            public override void LoadColumnInfo() {
                base.LoadColumnInfo();

                HyperLinkColumn column = (HyperLinkColumn)this.RuntimeColumn;

                anchorText = column.Text;
                anchorDataTextField = column.DataTextField;
                anchorDataTextFormatString = column.DataTextFormatString;
                url = column.NavigateUrl;
                dataUrlField = column.DataNavigateUrlField;
                dataUrlFormatString = column.DataNavigateUrlFormatString;
                target = column.Target;

                UpdateDisplayText();
            }

            public override void SaveColumnInfo() {
                base.SaveColumnInfo();

                HyperLinkColumn column = (HyperLinkColumn)this.RuntimeColumn;

                column.Text = anchorText;
                column.DataTextField = anchorDataTextField;
                column.DataTextFormatString = anchorDataTextFormatString;
                column.NavigateUrl = url;
                column.DataNavigateUrlField = dataUrlField;
                column.DataNavigateUrlFormatString = dataUrlFormatString;
                column.Target = target;
            }
        }

        /// <include file='doc\DataGridColumnsPage.uex' path='docs/doc[@for="DataGridColumnsPage.TemplateColumnItem"]/*' />
        /// <devdoc>
        ///   Represents a column containing a template.
        /// </devdoc>
        private class TemplateColumnItem : ColumnItem {

            public TemplateColumnItem(TemplateColumn runtimeColumn) : base(runtimeColumn, DataGridColumnsPage.ILI_TEMPLATE) {
            }

            protected override string GetDefaultHeaderText() {
                return SR.GetString(SR.DGCol_Node_Template);
            }
        }

        /// <include file='doc\DataGridColumnsPage.uex' path='docs/doc[@for="DataGridColumnsPage.EditCommandColumnItem"]/*' />
        /// <devdoc>
        ///   Represents a EditCommandColumn
        /// </devdoc>
        private class EditCommandColumnItem : ColumnItem {

            private string editText;
            private string updateText;
            private string cancelText;
            private ButtonColumnType buttonType;

            public EditCommandColumnItem(EditCommandColumn runtimeColumn) : base(runtimeColumn, DataGridColumnsPage.ILI_BUTTON) {
            }

            public ButtonColumnType ButtonType {
                get {
                    return buttonType;
                }
                set {
                    buttonType = value;
                }
            }

            public string CancelText {
                get {
                    return cancelText;
                }
                set {
                    cancelText = value;
                }
            }

            public string EditText {
                get {
                    return editText;
                }
                set {
                    editText = value;
                }
            }

            public string UpdateText {
                get {
                    return updateText;
                }
                set {
                    updateText = value;
                }
            }

            protected override string GetDefaultHeaderText() {
                return SR.GetString(SR.DGCol_Node_Edit);
            }

            public override TemplateColumn GetTemplateColumn(DataGrid dataGrid) {
                TemplateColumn column = base.GetTemplateColumn(dataGrid);

                column.ItemTemplate = GetTemplate(dataGrid, GetTemplateContent(false));
                column.EditItemTemplate = GetTemplate(dataGrid, GetTemplateContent(true));

                return column;
            }

            private string GetTemplateContent(bool editMode) {
                StringBuilder sb = new StringBuilder();
                string tag = ((buttonType == ButtonColumnType.LinkButton) ? "LinkButton" : "Button");

                sb.Append("<asp:");
                sb.Append(tag);
                sb.Append(" runat=\"server\"");

                sb.Append(" Text=\"");
                if (editMode == false) {
                    sb.Append(editText);
                }
                else {
                    sb.Append(updateText);
                }
                sb.Append("\"");

                sb.Append(" CommandName=\"");
                if (editMode == false) {
                    sb.Append("Edit\"");
                    sb.Append(" CausesValidation=\"false\"");
                }
                else {
                    sb.Append("Update\"");
                }

                sb.Append("></asp:");
                sb.Append(tag);
                sb.Append(">");
                
                if (editMode) {
                    sb.Append("&nbsp;");

                    sb.Append("<asp:");
                    sb.Append(tag);
                    sb.Append(" runat=\"server\"");

                    sb.Append(" Text=\"");
                    sb.Append(cancelText);
                    sb.Append("\"");

                    sb.Append(" CommandName=\"");
                    sb.Append("Cancel\"");

                    sb.Append(" CausesValidation=\"false\"></asp:");
                    sb.Append(tag);
                    sb.Append(">");
                }

                return sb.ToString();
            }

            public override void LoadColumnInfo() {
                base.LoadColumnInfo();

                EditCommandColumn column = (EditCommandColumn)this.RuntimeColumn;

                editText = column.EditText;
                updateText = column.UpdateText;
                cancelText = column.CancelText;
                buttonType = column.ButtonType;
            }

            public override void SaveColumnInfo() {
                base.SaveColumnInfo();

                EditCommandColumn column = (EditCommandColumn)this.RuntimeColumn;

                column.EditText = editText;
                column.UpdateText = updateText;
                column.CancelText = cancelText;
                column.ButtonType = buttonType;
            }
        }

        /// <include file='doc\DataGridColumnsPage.uex' path='docs/doc[@for="DataGridColumnsPage.CustomColumnItem"]/*' />
        /// <devdoc>
        ///   Represents a column of an unknown/custom type.
        /// </devdoc>
        private class CustomColumnItem : ColumnItem {

            public CustomColumnItem(DataGridColumn runtimeColumn) : base(runtimeColumn, DataGridColumnsPage.ILI_CUSTOM) {
            }
        }


        /// <include file='doc\DataGridColumnsPage.uex' path='docs/doc[@for="DataGridColumnsPage.ColumnItemEditor"]/*' />
        /// <devdoc>
        ///   Panel that provides UI to edit a column's properties
        /// </devdoc>
        private abstract class ColumnItemEditor : Panel {
            protected ColumnItem columnItem;
            protected EventHandler onChangedHandler = null;
            protected bool dataFieldsAvailable;

            public ColumnItemEditor() : base() {
                InitPanel();
            }

            public virtual void AddDataField(string fieldName) {
                dataFieldsAvailable = true;
            }

            public event EventHandler Changed {
                add {
                    onChangedHandler += value;
                }
                remove {
                    onChangedHandler -= value;
                }
            }

            public virtual void ClearDataFields() {
                dataFieldsAvailable = false;
            }

            protected virtual void InitPanel() {
            }

            public virtual void LoadColumn(ColumnItem columnItem) {
                this.columnItem = columnItem;
            }

            protected virtual void OnChanged(EventArgs e) {
                if (onChangedHandler != null)
                    onChangedHandler.Invoke(this, e);
            }

            public virtual void SaveColumn() {
            }
        }

        /// <include file='doc\DataGridColumnsPage.uex' path='docs/doc[@for="DataGridColumnsPage.BoundColumnEditor"]/*' />
        /// <devdoc>
        ///   Panel that provides UI to edit a bound column's properties
        /// </devdoc>
        private class BoundColumnEditor : ColumnItemEditor {
            private TextBox dataFieldEdit;
            private TextBox dataFormatStringEdit;
            private CheckBox readOnlyCheck;

            public BoundColumnEditor() : base() {
            }

            protected override void InitPanel() {
                Label dataFieldLabel = new Label();
                this.dataFieldEdit = new TextBox();
                Label dataFormatStringLabel = new Label();
                this.dataFormatStringEdit = new TextBox();
                this.readOnlyCheck = new CheckBox();

                dataFieldLabel.SetBounds(0, 0, 160, 14);
                dataFieldLabel.Text = SR.GetString(SR.DGCol_DFC_DataField);
                dataFieldLabel.TabStop = false;
                dataFieldLabel.TabIndex = 1;

                dataFieldEdit.SetBounds(0, 16, 182, 20);
                dataFieldEdit.TabIndex = 2;
                dataFieldEdit.ReadOnly = true;
                dataFieldEdit.TextChanged += new EventHandler(this.OnColumnChanged);

                dataFormatStringLabel.SetBounds(0, 40, 182, 14);
                dataFormatStringLabel.Text = SR.GetString(SR.DGCol_DFC_DataFormat);
                dataFormatStringLabel.TabStop = false;
                dataFormatStringLabel.TabIndex = 3;

                dataFormatStringEdit.SetBounds(0, 56, 182, 20);
                dataFormatStringEdit.TabIndex = 4;
                dataFormatStringEdit.TextChanged += new EventHandler(this.OnColumnChanged);

                readOnlyCheck.SetBounds(0, 80, 160, 16);
                readOnlyCheck.Text = SR.GetString(SR.DGCol_DFC_ReadOnly);
                readOnlyCheck.TabIndex = 5;
                readOnlyCheck.TextAlign = ContentAlignment.MiddleLeft;
                readOnlyCheck.FlatStyle = FlatStyle.System;
                readOnlyCheck.CheckedChanged += new EventHandler(this.OnColumnChanged);

                this.Controls.Clear();
                this.Controls.AddRange(new Control[] {
                                        readOnlyCheck,
                                        dataFormatStringEdit,
                                        dataFormatStringLabel,
                                        dataFieldEdit,
                                        dataFieldLabel
                                    });
            }

            public override void LoadColumn(ColumnItem columnItem) {
                Debug.Assert(columnItem is BoundColumnItem, "Expected a BoundColumnItem");

                base.LoadColumn(columnItem);

                BoundColumnItem boundColumn = (BoundColumnItem)columnItem;

                dataFieldEdit.Text = boundColumn.DataField;
                dataFormatStringEdit.Text = boundColumn.DataFormatString;
                readOnlyCheck.Checked = boundColumn.ReadOnly;

                dataFieldEdit.ReadOnly = dataFieldsAvailable;
            }

            private void OnColumnChanged(object source, EventArgs e) {
                OnChanged(EventArgs.Empty);
            }

            public override void SaveColumn() {
                Debug.Assert(columnItem != null, "Null column in SaveColumn");

                base.SaveColumn();

                BoundColumnItem boundColumn = (BoundColumnItem)this.columnItem;

                boundColumn.DataFormatString = dataFormatStringEdit.Text;
                boundColumn.ReadOnly = readOnlyCheck.Checked;

                if (dataFieldsAvailable == false) {
                    boundColumn.DataField = dataFieldEdit.Text.Trim();
                }
            }
        }


        /// <include file='doc\DataGridColumnsPage.uex' path='docs/doc[@for="DataGridColumnsPage.ButtonColumnEditor"]/*' />
        /// <devdoc>
        ///   Panel that provides UI to edit a button column's properties
        /// </devdoc>
        private class ButtonColumnEditor : ColumnItemEditor {

            private const int IDX_TYPE_LINKBUTTON = 0;
            private const int IDX_TYPE_PUSHBUTTON = 1;

            private TextBox commandEdit;
            private TextBox textEdit;
            private UnsettableComboBox dataTextFieldCombo;
            private TextBox dataTextFieldEdit;
            private TextBox dataTextFormatStringEdit;
            private ComboBox buttonTypeCombo;

            public ButtonColumnEditor() : base() {
            }

            public override void AddDataField(string fieldName) {
                dataTextFieldCombo.AddItem(fieldName);
                base.AddDataField(fieldName);
            }

            public override void ClearDataFields() {
                dataTextFieldCombo.Items.Clear();
                dataTextFieldCombo.EnsureNotSetItem();
                base.ClearDataFields();
            }

            protected override void InitPanel() {
                Label textLabel = new Label();
                this.textEdit = new TextBox();
                Label dataTextFieldLabel = new Label();
                this.dataTextFieldCombo = new UnsettableComboBox();
                this.dataTextFieldEdit = new TextBox();
                Label dataTextFormatStringLabel = new Label();
                this.dataTextFormatStringEdit = new TextBox();
                Label commandLabel = new Label();
                this.commandEdit = new TextBox();
                Label buttonTypeLabel = new Label();
                this.buttonTypeCombo = new ComboBox();

                textLabel.SetBounds(0, 0, 160, 14);
                textLabel.Text = SR.GetString(SR.DGCol_BC_Text);
                textLabel.TabStop = false;
                textLabel.TabIndex = 1;

                textEdit.SetBounds(0, 16, 182, 24);
                textEdit.TabIndex = 2;
                textEdit.TextChanged += new EventHandler(this.OnColumnChanged);

                dataTextFieldLabel.SetBounds(0, 40, 160, 14);
                dataTextFieldLabel.Text = SR.GetString(SR.DGCol_BC_DataTextField);
                dataTextFieldLabel.TabStop = false;
                dataTextFieldLabel.TabIndex = 3;

                dataTextFieldCombo.SetBounds(0, 56, 182, 21);
                dataTextFieldCombo.TabIndex = 4;
                dataTextFieldCombo.DropDownStyle = ComboBoxStyle.DropDownList;
                dataTextFieldCombo.SelectedIndexChanged += new EventHandler(this.OnColumnChanged);

                dataTextFieldEdit.SetBounds(0, 56, 182, 14);
                dataTextFieldEdit.TabIndex = 4;
                dataTextFieldEdit.TextChanged += new EventHandler(this.OnColumnChanged);

                dataTextFormatStringLabel.SetBounds(0, 82, 182, 14);
                dataTextFormatStringLabel.Text = SR.GetString(SR.DGCol_BC_DataTextFormat);
                dataTextFormatStringLabel.TabIndex = 5;
                dataTextFormatStringLabel.TabStop = false;

                dataTextFormatStringEdit.SetBounds(0, 98, 182, 14);
                dataTextFormatStringEdit.TabIndex = 6;
                dataTextFormatStringEdit.TextChanged += new EventHandler(this.OnColumnChanged);

                commandLabel.SetBounds(200, 0, 160, 14);
                commandLabel.Text = SR.GetString(SR.DGCol_BC_Command);
                commandLabel.TabStop = false;
                commandLabel.TabIndex = 8;

                commandEdit.SetBounds(200, 16, 182, 24);
                commandEdit.TabIndex = 9;
                commandEdit.TextChanged += new EventHandler(this.OnColumnChanged);

                buttonTypeLabel.SetBounds(200, 40, 160, 14);
                buttonTypeLabel.Text = SR.GetString(SR.DGCol_BC_ButtonType);
                buttonTypeLabel.TabStop = false;
                buttonTypeLabel.TabIndex = 10;

                buttonTypeCombo.SetBounds(200, 56, 182, 21);
                buttonTypeCombo.DropDownStyle = ComboBoxStyle.DropDownList;
                buttonTypeCombo.Items.AddRange(new object[] {
                                                SR.GetString(SR.DGCol_BC_BT_Link),
                                                SR.GetString(SR.DGCol_BC_BT_Push)
                                            });
                buttonTypeCombo.TabIndex = 11;
                buttonTypeCombo.SelectedIndexChanged += new EventHandler(this.OnColumnChanged);

                this.Controls.Clear();
                this.Controls.AddRange(new Control[] {
                                        buttonTypeCombo,
                                        buttonTypeLabel,
                                        commandEdit,
                                        commandLabel,
                                        dataTextFormatStringEdit,
                                        dataTextFormatStringLabel,
                                        dataTextFieldEdit,
                                        dataTextFieldCombo,
                                        dataTextFieldLabel,
                                        textEdit,
                                        textLabel
                                    });
            }

            public override void LoadColumn(ColumnItem columnItem) {
                Debug.Assert(columnItem is ButtonColumnItem, "Expected a ButtonColumnItem");

                base.LoadColumn(columnItem);

                ButtonColumnItem buttonColumn = (ButtonColumnItem)this.columnItem;

                commandEdit.Text = buttonColumn.Command;
                textEdit.Text = buttonColumn.ButtonText;
                if (dataFieldsAvailable) {
                    if (buttonColumn.ButtonDataTextField != null) {
                        int fieldIndex = dataTextFieldCombo.FindStringExact(buttonColumn.ButtonDataTextField);
                        dataTextFieldCombo.SelectedIndex = fieldIndex;
                    }
                    dataTextFieldCombo.Visible = true;
                    dataTextFieldEdit.Visible = false;
                }
                else {
                    dataTextFieldEdit.Text = buttonColumn.ButtonDataTextField;
                    dataTextFieldEdit.Visible = true;
                    dataTextFieldCombo.Visible = false;
                }
                dataTextFormatStringEdit.Text = buttonColumn.ButtonDataTextFormatString;

                switch (buttonColumn.ButtonType) {
                    case ButtonColumnType.LinkButton:
                        buttonTypeCombo.SelectedIndex = IDX_TYPE_LINKBUTTON;
                        break;
                    case ButtonColumnType.PushButton:
                        buttonTypeCombo.SelectedIndex = IDX_TYPE_PUSHBUTTON;
                        break;
                }

                UpdateEnabledState();
            }

            private void OnColumnChanged(object source, EventArgs e) {
                OnChanged(EventArgs.Empty);

                if (source == dataTextFieldCombo) {
                    UpdateEnabledState();
                }
            }

            public override void SaveColumn() {
                Debug.Assert(columnItem != null, "Null column in SaveColumn");

                base.SaveColumn();

                ButtonColumnItem buttonColumn = (ButtonColumnItem)this.columnItem;

                buttonColumn.Command = commandEdit.Text.Trim();
                buttonColumn.ButtonText = textEdit.Text;
                if (dataFieldsAvailable) {
                    if (dataTextFieldCombo.IsSet())
                        buttonColumn.ButtonDataTextField = dataTextFieldCombo.Text;
                    else
                        buttonColumn.ButtonDataTextField = String.Empty;
                }
                else {
                    buttonColumn.ButtonDataTextField = dataTextFieldEdit.Text.Trim();
                }
                buttonColumn.ButtonDataTextFormatString = dataTextFormatStringEdit.Text;

                switch (buttonTypeCombo.SelectedIndex) {
                    case IDX_TYPE_LINKBUTTON:
                        buttonColumn.ButtonType = ButtonColumnType.LinkButton;
                        break;
                    case IDX_TYPE_PUSHBUTTON:
                        buttonColumn.ButtonType = ButtonColumnType.PushButton;
                        break;
                }
            }

            private void UpdateEnabledState() {
                if (dataFieldsAvailable) {
                    dataTextFormatStringEdit.Enabled = dataTextFieldCombo.IsSet();
                }
                else {
                    dataTextFormatStringEdit.Enabled = dataTextFieldEdit.Text.Trim().Length != 0;
                }
            }
        }

        /// <include file='doc\DataGridColumnsPage.uex' path='docs/doc[@for="DataGridColumnsPage.HyperLinkColumnEditor"]/*' />
        /// <devdoc>
        ///   Panel that provides UI to edit a hyperlink column's properties
        /// </devdoc>
        private class HyperLinkColumnEditor : ColumnItemEditor {

            private TextBox textEdit;
            private UnsettableComboBox dataTextFieldCombo;
            private TextBox dataTextFieldEdit;
            private TextBox dataTextFormatStringEdit;
            private TextBox urlEdit;
            private UnsettableComboBox dataUrlFieldCombo;
            private TextBox dataUrlFieldEdit;
            private TextBox dataUrlFormatStringEdit;
            private ComboBox targetCombo;

            public HyperLinkColumnEditor() : base() {
            }

            public override void AddDataField(string fieldName) {
                dataTextFieldCombo.AddItem(fieldName);
                dataUrlFieldCombo.AddItem(fieldName);

                base.AddDataField(fieldName);
            }

            public override void ClearDataFields() {
                dataTextFieldCombo.Items.Clear();
                dataUrlFieldCombo.Items.Clear();
                dataTextFieldCombo.EnsureNotSetItem();
                dataUrlFieldCombo.EnsureNotSetItem();

                base.ClearDataFields();
            }

            protected override void InitPanel() {
                Label textLabel = new Label();
                this.textEdit = new TextBox();
                Label dataTextFieldLabel = new Label();
                this.dataTextFieldCombo = new UnsettableComboBox();
                this.dataTextFieldEdit = new TextBox();
                Label dataTextFormatStringLabel = new Label();
                this.dataTextFormatStringEdit = new TextBox();
                Label targetLabel = new Label();
                this.targetCombo = new ComboBox();
                Label urlLabel = new Label();
                this.urlEdit = new TextBox();
                Label dataUrlFieldLabel = new Label();
                this.dataUrlFieldCombo = new UnsettableComboBox();
                this.dataUrlFieldEdit = new TextBox();
                Label dataUrlFormatStringLabel = new Label();
                this.dataUrlFormatStringEdit = new TextBox();

                textLabel.SetBounds(0, 0, 160, 14);
                textLabel.Text = SR.GetString(SR.DGCol_HC_Text);
                textLabel.TabStop = false;
                textLabel.TabIndex = 1;

                textEdit.SetBounds(0, 16, 182, 24);
                textEdit.TabIndex = 2;
                textEdit.TextChanged += new EventHandler(this.OnColumnChanged);

                dataTextFieldLabel.SetBounds(0, 40, 160, 14);
                dataTextFieldLabel.Text = SR.GetString(SR.DGCol_HC_DataTextField);
                dataTextFieldLabel.TabStop = false;
                dataTextFieldLabel.TabIndex = 3;

                dataTextFieldCombo.SetBounds(0, 56, 182, 21);
                dataTextFieldCombo.DropDownStyle = ComboBoxStyle.DropDownList;
                dataTextFieldCombo.TabIndex = 4;
                dataTextFieldCombo.SelectedIndexChanged += new EventHandler(this.OnColumnChanged);

                dataTextFieldEdit.SetBounds(0, 56, 182, 14);
                dataTextFieldEdit.TabIndex = 4;
                dataTextFieldEdit.TextChanged += new EventHandler(this.OnColumnChanged);

                dataTextFormatStringLabel.SetBounds(0, 82, 160, 14);
                dataTextFormatStringLabel.Text = SR.GetString(SR.DGCol_HC_DataTextFormat);
                dataTextFormatStringLabel.TabStop = false;
                dataTextFormatStringLabel.TabIndex = 5;

                dataTextFormatStringEdit.SetBounds(0, 98, 182, 21);
                dataTextFormatStringEdit.TabIndex = 6;
                dataTextFormatStringEdit.TextChanged += new EventHandler(this.OnColumnChanged);

                targetLabel.SetBounds(0, 123, 160, 14);
                targetLabel.Text = SR.GetString(SR.DGCol_HC_Target);
                targetLabel.TabStop = false;
                targetLabel.TabIndex = 7;

                targetCombo.SetBounds(0, 139, 182, 21);
                targetCombo.TabIndex = 8;
                targetCombo.Items.AddRange(new object[] {
                                            "_blank",
                                            "_parent",
                                            "_search",
                                            "_self",
                                            "_top"
                                        });
                targetCombo.SelectedIndexChanged += new EventHandler(this.OnColumnChanged);
                targetCombo.TextChanged += new EventHandler(this.OnColumnChanged);

                urlLabel.SetBounds(200, 0, 160, 14);
                urlLabel.Text = SR.GetString(SR.DGCol_HC_URL);
                urlLabel.TabStop = false;
                urlLabel.TabIndex = 10;

                urlEdit.SetBounds(200, 16, 182, 24);
                urlEdit.TabIndex = 11;
                urlEdit.TextChanged += new EventHandler(this.OnColumnChanged);

                dataUrlFieldLabel.SetBounds(200, 40, 160, 14);
                dataUrlFieldLabel.Text = SR.GetString(SR.DGCol_HC_DataURLField);
                dataUrlFieldLabel.TabStop = false;
                dataUrlFieldLabel.TabIndex = 12;

                dataUrlFieldCombo.SetBounds(200, 56, 182, 21);
                dataUrlFieldCombo.DropDownStyle = ComboBoxStyle.DropDownList;
                dataUrlFieldCombo.TabIndex = 13;
                dataUrlFieldCombo.SelectedIndexChanged += new EventHandler(this.OnColumnChanged);

                dataUrlFieldEdit.SetBounds(200, 56, 182, 14);
                dataUrlFieldEdit.TabIndex = 13;
                dataUrlFieldEdit.TextChanged += new EventHandler(this.OnColumnChanged);

                dataUrlFormatStringLabel.SetBounds(200, 82, 160, 14);
                dataUrlFormatStringLabel.Text = SR.GetString(SR.DGCol_HC_DataURLFormat);
                dataUrlFormatStringLabel.TabStop = false;
                dataUrlFormatStringLabel.TabIndex = 14;

                dataUrlFormatStringEdit.SetBounds(200, 98, 182, 21);
                dataUrlFormatStringEdit.TabIndex = 15;
                dataUrlFormatStringEdit.TextChanged += new EventHandler(this.OnColumnChanged);

                this.Controls.Clear();
                this.Controls.AddRange(new Control[] {
                                        dataUrlFormatStringEdit,
                                        dataUrlFormatStringLabel,
                                        dataUrlFieldEdit,
                                        dataUrlFieldCombo,
                                        dataUrlFieldLabel,
                                        urlEdit,
                                        urlLabel,
                                        targetCombo,
                                        targetLabel,
                                        dataTextFormatStringEdit,
                                        dataTextFormatStringLabel,
                                        dataTextFieldEdit,
                                        dataTextFieldCombo,
                                        dataTextFieldLabel,
                                        textEdit,
                                        textLabel
                                    });
            }

            public override void LoadColumn(ColumnItem columnItem) {
                Debug.Assert(columnItem is HyperLinkColumnItem, "Expected a HyperLinkColumnItem");

                base.LoadColumn(columnItem);

                HyperLinkColumnItem hyperLinkColumn = (HyperLinkColumnItem)this.columnItem;

                textEdit.Text = hyperLinkColumn.AnchorText;
                if (dataFieldsAvailable) {
                    if (hyperLinkColumn.AnchorDataTextField != null) {
                        int fieldIndex = dataTextFieldCombo.FindStringExact(hyperLinkColumn.AnchorDataTextField);
                        dataTextFieldCombo.SelectedIndex = fieldIndex;
                    }
                    dataTextFieldCombo.Visible = true;
                    dataTextFieldEdit.Visible = false;
                }
                else {
                    dataTextFieldEdit.Text = hyperLinkColumn.AnchorDataTextField;
                    dataTextFieldEdit.Visible = true;
                    dataTextFieldCombo.Visible = false;
                }
                dataTextFormatStringEdit.Text = hyperLinkColumn.AnchorDataTextFormatString;

                urlEdit.Text = hyperLinkColumn.Url;
                if (dataFieldsAvailable) {
                    if (hyperLinkColumn.DataUrlField != null) {
                        int fieldIndex = dataTextFieldCombo.FindStringExact(hyperLinkColumn.DataUrlField);
                        dataUrlFieldCombo.SelectedIndex = fieldIndex;
                    }
                    dataUrlFieldCombo.Visible = true;
                    dataUrlFieldEdit.Visible = false;
                }
                else {
                    dataUrlFieldEdit.Text = hyperLinkColumn.DataUrlField;
                    dataUrlFieldEdit.Visible = true;
                    dataUrlFieldCombo.Visible = false;
                }
                dataUrlFormatStringEdit.Text = hyperLinkColumn.DataUrlFormatString;

                targetCombo.Text = hyperLinkColumn.Target;

                UpdateEnabledState();
            }

            protected void OnColumnChanged(object source, EventArgs e) {
                OnChanged(EventArgs.Empty);

                if ((source == dataTextFieldCombo) ||
                    (source == dataUrlFieldCombo) ||
                    (source == dataTextFieldEdit) ||
                    (source == dataUrlFieldEdit)) {
                    UpdateEnabledState();
                }
            }

            public override void SaveColumn() {
                Debug.Assert(columnItem != null, "Null column in SaveColumn");

                base.SaveColumn();

                HyperLinkColumnItem hyperLinkColumn = (HyperLinkColumnItem)this.columnItem;

                hyperLinkColumn.AnchorText = textEdit.Text;
                if (dataFieldsAvailable) {
                    if (dataTextFieldCombo.IsSet())
                        hyperLinkColumn.AnchorDataTextField = dataTextFieldCombo.Text;
                    else
                        hyperLinkColumn.AnchorDataTextField = String.Empty;
                }
                else {
                    hyperLinkColumn.AnchorDataTextField = dataTextFieldEdit.Text.Trim();
                }
                hyperLinkColumn.AnchorDataTextFormatString = dataTextFormatStringEdit.Text;

                hyperLinkColumn.Url = urlEdit.Text.Trim();
                if (dataFieldsAvailable) {
                    if (dataUrlFieldCombo.IsSet())
                        hyperLinkColumn.DataUrlField = dataUrlFieldCombo.Text;
                    else
                        hyperLinkColumn.DataUrlField = String.Empty;
                }
                else {
                    hyperLinkColumn.DataUrlField = dataUrlFieldEdit.Text.Trim();
                }
                hyperLinkColumn.DataUrlFormatString = dataUrlFormatStringEdit.Text;

                hyperLinkColumn.Target = targetCombo.Text.Trim();
            }

            private void UpdateEnabledState() {
                if (dataFieldsAvailable) {
                    dataTextFormatStringEdit.Enabled = dataTextFieldCombo.IsSet();
                    dataUrlFormatStringEdit.Enabled = dataUrlFieldCombo.IsSet();
                }
                else {
                    dataTextFormatStringEdit.Enabled = dataTextFieldEdit.Text.Trim().Length != 0;
                    dataUrlFormatStringEdit.Enabled = dataUrlFieldEdit.Text.Trim().Length != 0;
                }
            }
        }


        /// <include file='doc\DataGridColumnsPage.uex' path='docs/doc[@for="DataGridColumnsPage.EditCommandColumnEditor"]/*' />
        /// <devdoc>
        ///   Panel that provides UI to edit a EditCommandColumn column's properties
        /// </devdoc>
        private class EditCommandColumnEditor : ColumnItemEditor {

            private const int IDX_TYPE_LINKBUTTON = 0;
            private const int IDX_TYPE_PUSHBUTTON = 1;

            private TextBox editTextEdit;
            private TextBox updateTextEdit;
            private TextBox cancelTextEdit;
            private ComboBox buttonTypeCombo;

            public EditCommandColumnEditor() : base() {
            }

            protected override void InitPanel() {
                Label editTextLabel = new Label();
                this.editTextEdit = new TextBox();
                Label updateTextLabel = new Label();
                this.updateTextEdit = new TextBox();
                Label cancelTextLabel = new Label();
                this.cancelTextEdit = new TextBox();
                Label buttonTypeLabel = new Label();
                this.buttonTypeCombo = new ComboBox();

                editTextLabel.SetBounds(0, 0, 160, 14);
                editTextLabel.Text = SR.GetString(SR.DGCol_EC_Edit);
                editTextLabel.TabStop = false;
                editTextLabel.TabIndex = 1;

                editTextEdit.SetBounds(0, 16, 182, 24);
                editTextEdit.TabIndex = 2;
                editTextEdit.TextChanged += new EventHandler(this.OnColumnChanged);

                updateTextLabel.SetBounds(0, 40, 160, 14);
                updateTextLabel.Text = SR.GetString(SR.DGCol_EC_Update);
                updateTextLabel.TabStop = false;
                updateTextLabel.TabIndex = 3;

                updateTextEdit.SetBounds(0, 56, 182, 24);
                updateTextEdit.TabIndex = 4;
                updateTextEdit.TextChanged += new EventHandler(this.OnColumnChanged);

                cancelTextLabel.SetBounds(200, 0, 160, 14);
                cancelTextLabel.Text = SR.GetString(SR.DGCol_EC_Cancel);
                cancelTextLabel.TabStop = false;
                cancelTextLabel.TabIndex = 5;

                cancelTextEdit.SetBounds(200, 16, 182, 24);
                cancelTextEdit.TabIndex = 6;
                cancelTextEdit.TextChanged += new EventHandler(this.OnColumnChanged);

                buttonTypeLabel.SetBounds(200, 40, 160, 14);
                buttonTypeLabel.Text = SR.GetString(SR.DGCol_EC_ButtonType);
                buttonTypeLabel.TabStop = false;
                buttonTypeLabel.TabIndex = 7;

                buttonTypeCombo.SetBounds(200, 56, 182, 21);
                buttonTypeCombo.DropDownStyle = ComboBoxStyle.DropDownList;
                buttonTypeCombo.Items.AddRange(new object[] {
                                                SR.GetString(SR.DGCol_EC_BT_Link),
                                                SR.GetString(SR.DGCol_EC_BT_Push)
                                            });
                buttonTypeCombo.TabIndex = 8;
                buttonTypeCombo.SelectedIndexChanged += new EventHandler(this.OnColumnChanged);

                this.Controls.Clear();
                this.Controls.AddRange(new Control[] {
                                        buttonTypeCombo,
                                        buttonTypeLabel,
                                        cancelTextEdit,
                                        cancelTextLabel,
                                        updateTextEdit,
                                        updateTextLabel,
                                        editTextEdit,
                                        editTextLabel
                                    });
            }

            public override void LoadColumn(ColumnItem columnItem) {
                Debug.Assert(columnItem is EditCommandColumnItem, "Expected an EditCommandColumnItem");

                base.LoadColumn(columnItem);

                EditCommandColumnItem editColumn = (EditCommandColumnItem)this.columnItem;

                editTextEdit.Text = editColumn.EditText;
                updateTextEdit.Text = editColumn.UpdateText;
                cancelTextEdit.Text = editColumn.CancelText;

                switch (editColumn.ButtonType) {
                    case ButtonColumnType.LinkButton:
                        buttonTypeCombo.SelectedIndex = IDX_TYPE_LINKBUTTON;
                        break;
                    case ButtonColumnType.PushButton:
                        buttonTypeCombo.SelectedIndex = IDX_TYPE_PUSHBUTTON;
                        break;
                }
            }

            private void OnColumnChanged(object source, EventArgs e) {
                OnChanged(EventArgs.Empty);
            }

            public override void SaveColumn() {
                Debug.Assert(columnItem != null, "Null column in SaveColumn");

                base.SaveColumn();

                EditCommandColumnItem editColumn = (EditCommandColumnItem)this.columnItem;

                editColumn.EditText = editTextEdit.Text;
                editColumn.UpdateText = updateTextEdit.Text;
                editColumn.CancelText = cancelTextEdit.Text;

                switch (buttonTypeCombo.SelectedIndex) {
                    case IDX_TYPE_LINKBUTTON:
                        editColumn.ButtonType = ButtonColumnType.LinkButton;
                        break;
                    case IDX_TYPE_PUSHBUTTON:
                        editColumn.ButtonType = ButtonColumnType.PushButton;
                        break;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\advancedbindingpropertydescriptor.cs ===
//------------------------------------------------------------------------------
// <copyright file="AdvancedBindingPropertyDescriptor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms.Design {

    using System.Design;
    using System;
    using System.ComponentModel;
    
    /// <include file='doc\AdvancedBindingPropertyDescriptor.uex' path='docs/doc[@for="AdvancedBindingPropertyDescriptor"]/*' />
    /// <devdoc>
    ///    <para>Provides a property description of an advanced binding object.</para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class AdvancedBindingPropertyDescriptor : PropertyDescriptor {

        internal static AdvancedBindingEditor advancedBindingEditor = new AdvancedBindingEditor();
        internal AdvancedBindingPropertyDescriptor() : base(SR.GetString(SR.AdvancedBindingPropertyDescName), null) {
        }
            
        /// <include file='doc\AdvancedBindingPropertyDescriptor.uex' path='docs/doc[@for="AdvancedBindingPropertyDescriptor.ComponentType"]/*' />
        /// <devdoc>
        ///    <para>Gets the type of component this property is bound to.</para>
        /// </devdoc>
        public override Type ComponentType {
            get {
                return typeof(ControlBindingsCollection);
            }
        }

        public override AttributeCollection Attributes {
            get {
                return new AttributeCollection(new Attribute[]{new SRDescriptionAttribute(SR.AdvancedBindingPropertyDescriptorDesc)});
            }
        }

        /// <include file='doc\AdvancedBindingPropertyDescriptor.uex' path='docs/doc[@for="AdvancedBindingPropertyDescriptor.IsReadOnly"]/*' />
        /// <devdoc>
        ///    <para>Indicates whether this property is read-only.</para>
        /// </devdoc>
        public override bool IsReadOnly {
            get {
                return false;
            }
        }

        /// <include file='doc\AdvancedBindingPropertyDescriptor.uex' path='docs/doc[@for="AdvancedBindingPropertyDescriptor.PropertyType"]/*' />
        /// <devdoc>
        ///    <para>Gets the type of the property.</para>
        /// </devdoc>
        public override Type PropertyType {
            get {
                return typeof(object);
            }
        }

        /// <include file='doc\AdvancedBindingPropertyDescriptor.uex' path='docs/doc[@for="AdvancedBindingPropertyDescriptor.GetEditor"]/*' />
        /// <devdoc>
        ///    <para>Gets an editor of the specified type.</para>
        /// </devdoc>
        public override object GetEditor(Type type) {
            if (type == typeof(System.Drawing.Design.UITypeEditor)) {
                return advancedBindingEditor;
            }
            return base.GetEditor(type);
        }
                    
        /// <include file='doc\AdvancedBindingPropertyDescriptor.uex' path='docs/doc[@for="AdvancedBindingPropertyDescriptor.CanResetValue"]/*' />
        /// <devdoc>
        ///    <para>Indicates whether resetting the component will change the value of the 
        ///       component.</para>
        /// </devdoc>
        public override bool CanResetValue(object component) {
            return false;
        }
       
        /// <include file='doc\AdvancedBindingPropertyDescriptor.uex' path='docs/doc[@for="AdvancedBindingPropertyDescriptor.FillAttributes"]/*' />
        /// <devdoc>
        ///    <para>In an derived class, adds the attributes of the inherited class to the
        ///       specified list of attributes in the parent class.</para>
        /// </devdoc>
        protected override void FillAttributes(System.Collections.IList attributeList) {
            attributeList.Add(RefreshPropertiesAttribute.All);
            base.FillAttributes(attributeList);
        }

            
        /// <include file='doc\AdvancedBindingPropertyDescriptor.uex' path='docs/doc[@for="AdvancedBindingPropertyDescriptor.GetValue"]/*' />
        /// <devdoc>
        ///    <para>Gets the current value of the property on the specified 
        ///       component.</para>
        /// </devdoc>
        public override object GetValue(object component) {
            return new AdvancedBindingObject((ControlBindingsCollection)component);
        }
            
        /// <include file='doc\AdvancedBindingPropertyDescriptor.uex' path='docs/doc[@for="AdvancedBindingPropertyDescriptor.ResetValue"]/*' />
        /// <devdoc>
        ///    <para>Resets the value of the property on the specified component.</para>
        /// </devdoc>
        public override void ResetValue(object component) {
        }
            
        /// <include file='doc\AdvancedBindingPropertyDescriptor.uex' path='docs/doc[@for="AdvancedBindingPropertyDescriptor.SetValue"]/*' />
        /// <devdoc>
        ///    <para>Sets the value of the property on the specified component to the specified 
        ///       value.</para>
        /// </devdoc>
        public override void SetValue(object component, object value) {
        }
            
        /// <include file='doc\AdvancedBindingPropertyDescriptor.uex' path='docs/doc[@for="AdvancedBindingPropertyDescriptor.ShouldSerializeValue"]/*' />
        /// <devdoc>
        ///    <para>Indicates whether the value of this property should be persisted.</para>
        /// </devdoc>
        public override bool ShouldSerializeValue(object component) {
            return false;
        }            
    }        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\anchoreditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="AnchorEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms.Design {
    
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System;    
    using System.ComponentModel.Design;
    using Microsoft.Win32;
    using System.Diagnostics;
    using System.Drawing;
    using System.Design;
    
    using System.Drawing.Design;
    using System.Windows.Forms;
    using System.Windows.Forms.ComponentModel;
    using System.Windows.Forms.Design;

    /// <include file='doc\AnchorEditor.uex' path='docs/doc[@for="AnchorEditor"]/*' />
    /// <devdoc>
    ///    <para>Provides a design-time editor for specifying the
    ///    <see cref='System.Windows.Forms.Control.Anchor'/>
    ///    property.</para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public sealed class AnchorEditor : UITypeEditor {
        private AnchorUI anchorUI;

        /// <include file='doc\AnchorEditor.uex' path='docs/doc[@for="AnchorEditor.EditValue"]/*' />
        /// <devdoc>
        ///    <para>Edits the given object value using the editor style provided by 
        ///       GetEditorStyle.</para>
        /// </devdoc>
        public override object EditValue(ITypeDescriptorContext context,  IServiceProvider  provider, object value) {

            object returnValue = value;

            if (provider != null) {
                IWindowsFormsEditorService edSvc = (IWindowsFormsEditorService)provider.GetService(typeof(IWindowsFormsEditorService));

                if (edSvc != null) {
                    if (anchorUI == null) {
                        anchorUI = new AnchorUI(this);
                    }
                    anchorUI.Start(edSvc, value);
                    edSvc.DropDownControl(anchorUI);
                    value = anchorUI.Value;
                    anchorUI.End();
                }
            }

            return value;
        }

        /// <include file='doc\AnchorEditor.uex' path='docs/doc[@for="AnchorEditor.GetEditStyle"]/*' />
        /// <devdoc>
        ///    <para>Gets the editing style of the Edit method.</para>
        /// </devdoc>
        public override UITypeEditorEditStyle GetEditStyle(ITypeDescriptorContext context) {
            return UITypeEditorEditStyle.DropDown;
        }

        /// <include file='doc\AnchorEditor.uex' path='docs/doc[@for="AnchorEditor.AnchorUI"]/*' />
        /// <devdoc>
        ///     User Interface for the AnchorEditor.
        /// </devdoc>
        /// <internalonly/>
        private class AnchorUI : Control {
            private ContainerPlaceholder container = new ContainerPlaceholder();
            private ControlPlaceholder control = new ControlPlaceholder();
            private IWindowsFormsEditorService edSvc;
            private SpringControl left;
            private SpringControl right;
            private SpringControl top;
            private SpringControl bottom;
            private SpringControl[] tabOrder;
            private AnchorEditor editor = null;
            private AnchorStyles oldAnchor;
            private object value;

            public AnchorUI(AnchorEditor editor) {
                this.editor = editor;
                this.left = new SpringControl( this );
                this.right = new SpringControl( this );
                this.top = new SpringControl( this );
                this.bottom = new SpringControl( this );
                tabOrder = new SpringControl[] { left, top, right, bottom};

                InitializeComponent();
            }
            
            public object Value { 
                get {
                    return value;
                }
            }
            
            public void End() {
                edSvc = null;
                value = null;
            }

            public virtual AnchorStyles GetSelectedAnchor() {
                AnchorStyles baseVar = (AnchorStyles)0;
                if (left.GetSolid()) {
                    baseVar |= AnchorStyles.Left;
                }
                if (top.GetSolid()) {
                    baseVar |= AnchorStyles.Top;
                }
                if (bottom.GetSolid()) {
                    baseVar |= AnchorStyles.Bottom;
                }
                if (right.GetSolid()) {
                    baseVar |= AnchorStyles.Right;
                }
                return baseVar;
            }

            internal virtual void InitializeComponent() {
                int XBORDER = SystemInformation.Border3DSize.Width;
                int YBORDER = SystemInformation.Border3DSize.Height;
                SetBounds(0, 0, 90, 90);

                container.Location = new Point(0, 0);
                container.Size = new Size(90, 90);
                container.Anchor = AnchorStyles.Top | AnchorStyles.Left | AnchorStyles.Bottom | AnchorStyles.Right;
                
                control.Location = new Point(30, 30);
                control.Size = new Size(30, 30);
                control.Anchor = AnchorStyles.Top | AnchorStyles.Left | AnchorStyles.Bottom | AnchorStyles.Right;

                right.Location = new Point(60, 40);
                right.Size = new Size(30 - XBORDER, 10);
                right.TabIndex = 2;
                right.TabStop = true;
                right.Anchor = AnchorStyles.Right;
                right.AccessibleName = SR.GetString(SR.AnchorEditorRightAccName);

                left.Location = new Point(XBORDER, 40);
                left.Size = new Size(30 - XBORDER, 10);
                left.TabIndex = 0;
                left.TabStop = true;
                left.Anchor = AnchorStyles.Left;
                left.AccessibleName = SR.GetString(SR.AnchorEditorLeftAccName);

                top.Location = new Point(40, YBORDER);
                top.Size = new Size(10, 30 - YBORDER);
                top.TabIndex = 1;
                top.TabStop = true;
                top.Anchor = AnchorStyles.Top;
                top.AccessibleName = SR.GetString(SR.AnchorEditorTopAccName);

                bottom.Location = new Point(40, 60);
                bottom.Size = new Size(10, 30 - YBORDER);
                bottom.TabIndex = 3;
                bottom.TabStop = true;
                bottom.Anchor = AnchorStyles.Bottom;
                bottom.AccessibleName = SR.GetString(SR.AnchorEditorBottomAccName);

                Controls.Clear();
                Controls.AddRange(new Control[]{
                                   container});
                                   
                container.Controls.Clear();                                   
                container.Controls.AddRange(new Control[]{
                                                control,
                                                top,
                                                left,
                                                bottom,
                                                right});
            }
            
            protected override void OnGotFocus(EventArgs e) {
                base.OnGotFocus(e);
                top.Focus();
            }

            private void SetValue() {
                value = GetSelectedAnchor();
            }

            public void Start(IWindowsFormsEditorService edSvc, object value) {
                this.edSvc = edSvc;
                this.value = value;
                
                if (value is AnchorStyles) {
                    left.SetSolid((((AnchorStyles)value) & AnchorStyles.Left) == AnchorStyles.Left);
                    top.SetSolid((((AnchorStyles)value) & AnchorStyles.Top) == AnchorStyles.Top);
                    bottom.SetSolid((((AnchorStyles)value) & AnchorStyles.Bottom) == AnchorStyles.Bottom);
                    right.SetSolid((((AnchorStyles)value) & AnchorStyles.Right) == AnchorStyles.Right);
                    oldAnchor = (AnchorStyles) value;
                }
                else {
                    oldAnchor = AnchorStyles.Top | AnchorStyles.Left;
                }
            }

            private void Teardown( bool saveAnchor ) {
                if (!saveAnchor) {
                    // restore the old settings if user pressed ESC
                    value = oldAnchor;
                }
                edSvc.CloseDropDown();
            }

            /// <include file='doc\AnchorEditor.uex' path='docs/doc[@for="AnchorEditor.AnchorUI.ContainerPlaceholder"]/*' />
            /// <devdoc>
            /// </devdoc>
            private class ContainerPlaceholder : Control {
                public ContainerPlaceholder() {
                    this.BackColor = SystemColors.Window;
                    this.ForeColor = SystemColors.WindowText;
                    this.TabStop = false;
                }

                protected override void OnPaint(PaintEventArgs e) {
                    Rectangle rc = this.ClientRectangle;
                    ControlPaint.DrawBorder3D(e.Graphics, rc, Border3DStyle.Sunken);
                }
            }


            /// <include file='doc\AnchorEditor.uex' path='docs/doc[@for="AnchorEditor.AnchorUI.ControlPlaceholder"]/*' />
            /// <devdoc>
            /// </devdoc>
            private class ControlPlaceholder : Control {
                public ControlPlaceholder() {
                    this.BackColor = SystemColors.Control;
                    this.TabStop = false;
                    this.SetStyle( ControlStyles.Selectable, false );
                }

                protected override void OnPaint(PaintEventArgs e) {
                    Rectangle rc = this.ClientRectangle;
                    ControlPaint.DrawButton(e.Graphics, rc, ButtonState.Normal);
                }
            }


            /// <include file='doc\AnchorEditor.uex' path='docs/doc[@for="AnchorEditor.AnchorUI.SpringControl"]/*' />
            /// <devdoc>
            /// </devdoc>
            private class SpringControl : Control {
                internal bool solid;
                internal bool focused;
                private AnchorUI picker;

                public SpringControl( AnchorUI picker ) {
                    if (picker == null)
                        throw new ArgumentException();
                    this.picker = picker;
                    this.TabStop = true;
                }
                
                protected override AccessibleObject CreateAccessibilityInstance() {
                    return new SpringControlAccessibleObject(this);
                }

                public virtual bool GetSolid() {
                    return solid;
                }

                protected override void OnGotFocus(EventArgs e) {
                    if (!focused) {
                        focused = true;
                        this.Invalidate();
                    }

                    base.OnGotFocus(e);
                }

                protected override void OnLostFocus(EventArgs e) {
                    if (focused) {
                        focused = false;
                        this.Invalidate();
                    }
                    base.OnLostFocus(e);
                }

                protected override void OnMouseDown(MouseEventArgs e) {
                    SetSolid(!solid);
                    Focus();
                }

                protected override void OnPaint(PaintEventArgs e) {
                    Rectangle rc = this.ClientRectangle;

                    if (solid) {
                        e.Graphics.FillRectangle(SystemBrushes.ControlDark, rc);
                        e.Graphics.DrawRectangle(SystemPens.WindowFrame, rc.X, rc.Y, rc.Width - 1, rc.Height - 1);
                    }
                    else {
                        ControlPaint.DrawFocusRectangle(e.Graphics, rc);
                    }

                    if (focused) {
                        rc.Inflate(-2, -2);
                        ControlPaint.DrawFocusRectangle(e.Graphics, rc);
                    }
                }

                protected override bool ProcessDialogChar(char charCode) {
                    if (charCode == ' ') {
                        SetSolid(!solid);
                        return true;
                    }
                    return base.ProcessDialogChar(charCode);
                }

                protected override bool ProcessDialogKey(Keys keyData) {
                    if ((keyData & Keys.KeyCode) == Keys.Return && (keyData & (Keys.Alt | Keys.Control)) == 0) {
                        picker.Teardown(true);
                        return true;
                    }
                    else if ((keyData & Keys.KeyCode) == Keys.Escape && (keyData & (Keys.Alt | Keys.Control)) == 0) {
                        picker.Teardown(false);
                        return true;
                    }
                    else if ((keyData & Keys.KeyCode) == Keys.Tab && (keyData & (Keys.Alt | Keys.Control)) == 0) {
                        for (int i = 0; i < picker.tabOrder.Length; i++) {
                            if (picker.tabOrder[i] == this) {
                                i += ((keyData & Keys.Shift) == 0 ? 1 : -1);
                                i = (i < 0 ? i + picker.tabOrder.Length : i % picker.tabOrder.Length);
                                picker.tabOrder[i].Focus();
                                break;
                            }
                        }
                        return true;
                    }
                    
                    return base.ProcessDialogKey(keyData);
                }

                public virtual void SetSolid(bool value) {
                    if (solid != value) {
                        solid = value;
                        picker.SetValue();
                        this.Invalidate();
                    }
                }
                
                private class SpringControlAccessibleObject : ControlAccessibleObject {
                    
                    public SpringControlAccessibleObject(SpringControl owner) : base(owner) {
                    }
                    
                    public override AccessibleStates State {
                        get {
                            AccessibleStates state = base.State;
                            
                            if (((SpringControl)Owner).GetSolid()) {
                                state |= AccessibleStates.Selected;
                            }
                            
                            return state;
                        }
                    } 
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\axparameterdata.cs ===
//------------------------------------------------------------------------------
// <copyright file="AxParameterData.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   AxParameterData.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Windows.Forms.Design {
    using System.Diagnostics;
    using System;
    using System.Reflection;
    using Microsoft.Win32;
    using System.CodeDom;
    using System.Globalization;

    /// <include file='doc\AxParameterData.uex' path='docs/doc[@for="AxParameterData"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    /// <internalonly/>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public class AxParameterData {
        private string name;
        private string typeName;
        private Type   type;
        private bool   isByRef = false;
        private bool   isOut   = false;
        private bool   isIn    = false;
        private bool   isOptional = false;
    
        /// <include file='doc\AxParameterData.uex' path='docs/doc[@for="AxParameterData.AxParameterData"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public AxParameterData(string inname, string typeName) {
            Name = inname;
            this.typeName = typeName;
        }
    
        /// <include file='doc\AxParameterData.uex' path='docs/doc[@for="AxParameterData.AxParameterData1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public AxParameterData(string inname, Type type) {
            Name = inname;
            this.type = type;
            this.typeName = AxWrapperGen.MapTypeName(type);
        }
    
        /// <include file='doc\AxParameterData.uex' path='docs/doc[@for="AxParameterData.AxParameterData2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public AxParameterData(ParameterInfo info) : this(info, false) {
        }
    
        /// <include file='doc\AxParameterData.uex' path='docs/doc[@for="AxParameterData.AxParameterData3"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public AxParameterData(ParameterInfo info, bool ignoreByRefs) {
            Name = info.Name;
            this.type = info.ParameterType;
            this.typeName = AxWrapperGen.MapTypeName(info.ParameterType);
            this.isByRef = info.ParameterType.IsByRef && !ignoreByRefs;
            this.isIn    = info.IsIn && !ignoreByRefs;
            this.isOut   = info.IsOut && !this.isIn && !ignoreByRefs;
            this.isOptional = info.IsOptional;
        }
    
        /// <include file='doc\AxParameterData.uex' path='docs/doc[@for="AxParameterData.Direction"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public FieldDirection Direction {
            get {
                if (IsOut)
                    return FieldDirection.Out;
                else if (IsByRef)
                    return FieldDirection.Ref;
                else
                    return FieldDirection.In;
            }
        }
        
        /// <include file='doc\AxParameterData.uex' path='docs/doc[@for="AxParameterData.IsByRef"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool IsByRef {
            get {
                return isByRef;
            }
        }
    
        /// <include file='doc\AxParameterData.uex' path='docs/doc[@for="AxParameterData.IsIn"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool IsIn {
            get {
                return isIn;
            }
        }
    
        /// <include file='doc\AxParameterData.uex' path='docs/doc[@for="AxParameterData.IsOut"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool IsOut {
            get {
                return isOut;
            }
        }
    
        /// <include file='doc\AxParameterData.uex' path='docs/doc[@for="AxParameterData.IsOptional"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool IsOptional {
            get {
                return isOptional;
            }
        }
    
        /// <include file='doc\AxParameterData.uex' path='docs/doc[@for="AxParameterData.Name"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string Name {
            get {
                return name;
            }
    
            set {
                if (value == null) {
                    name = null;
                }
                else {
                    if (value != null && value.Length > 0 && Char.IsUpper(value[0])) {
                        char[] chars = value.ToCharArray();
                        if (chars.Length > 0)
                            chars[0] = Char.ToLower(chars[0], CultureInfo.InvariantCulture);
                        name = new String(chars);
                    }
                    else {
                        name = value;
                    }
                }
            }
        }
    
        /// <include file='doc\AxParameterData.uex' path='docs/doc[@for="AxParameterData.ParameterType"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Type ParameterType {
            get {
                return type;
            }
        }
    
        /// <include file='doc\AxParameterData.uex' path='docs/doc[@for="AxParameterData.TypeName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string TypeName {
            get {
                Debug.Assert(typeName != null, "Type name is null");
                if(typeName.EndsWith("&")) {
                    typeName = typeName.TrimEnd(new char[] {'&'});
                }
                return typeName;
            }
        }
    
        /// <include file='doc\AxParameterData.uex' path='docs/doc[@for="AxParameterData.Convert"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static AxParameterData[] Convert(ParameterInfo[] infos) {
            return AxParameterData.Convert(infos, false);
        }
    
        /// <include file='doc\AxParameterData.uex' path='docs/doc[@for="AxParameterData.Convert1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static AxParameterData[] Convert(ParameterInfo[] infos, bool ignoreByRefs) {
            if (infos == null) return new AxParameterData[0];
    
            int noname = 0;
            AxParameterData[] parameters = new AxParameterData[infos.Length];
            for (int i = 0; i < infos.Length; ++i) {
                parameters[i] = new AxParameterData(infos[i], ignoreByRefs);
                if (parameters[i].Name == null || parameters[i].Name == "") {
                    parameters[i].Name = "param" + (noname++);
                }
            }
    
            return parameters;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\comboboxdesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="ComboBoxDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms.Design {
    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;

    /// <include file='doc\ComboBoxDesigner.uex' path='docs/doc[@for="ComboBoxDesigner"]/*' />
    /// <devdoc>
    ///    <para> 
    ///       Provides a designer that can design components
    ///       that extend ComboBox.</para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class ComboBoxDesigner : ControlDesigner {

        private EventHandler propChanged = null; // Delegate used to dirty the selectionUIItem when needed.
        
        /// <include file='doc\ComboBoxDesigner.uex' path='docs/doc[@for="ComboBoxDesigner.Dispose"]/*' />
        /// <devdoc>
        ///      Disposes of this object.
        /// </devdoc>
        protected override void Dispose(bool disposing) {
            if (disposing) {
                // Hook up the property change notification so that we can dirty the SelectionUIItem when needed.
                if (propChanged != null) {
                    ((ComboBox)Control).StyleChanged -= propChanged;
                }
            }
    
            base.Dispose(disposing);
        }

        /// <include file='doc\ComboBoxDesigner.uex' path='docs/doc[@for="ComboBoxDesigner.Initialize"]/*' />
        /// <devdoc>
        ///     Called by the host when we're first initialized.
        /// </devdoc>
        public override void Initialize(IComponent component) {
            base.Initialize(component);

            // Hook up the property change notification so that we can dirty the SelectionUIItem when needed.
            propChanged = new EventHandler(this.OnControlPropertyChanged);
            ((ComboBox)Control).StyleChanged += propChanged;
        }

        /// <include file='doc\ComboBoxDesigner.uex' path='docs/doc[@for="ComboBoxDesigner.OnControlPropertyChanged"]/*' />
        /// <devdoc>
        ///      For controls, we sync their property changed event so our component can track their location.
        /// </devdoc>
        private void OnControlPropertyChanged(object sender, EventArgs e) {
            ISelectionUIService selectionUISvc = (ISelectionUIService)GetService(typeof(ISelectionUIService));
            if (selectionUISvc != null) {
                selectionUISvc.SyncComponent((IComponent)sender);
            }
        }

        /// <include file='doc\ComboBoxDesigner.uex' path='docs/doc[@for="ComboBoxDesigner.SelectionRules"]/*' />
        /// <devdoc>
        ///     Retrieves a set of rules concerning the movement capabilities of a component.
        ///     This should be one or more flags from the SelectionRules class.  If no designer
        ///     provides rules for a component, the component will not get any UI services.
        /// </devdoc>
        public override SelectionRules SelectionRules {
            get {
                SelectionRules rules = base.SelectionRules;
                object component = Component;

                PropertyDescriptor propStyle = TypeDescriptor.GetProperties(component)["Style"];
                if (propStyle != null) {
                    ComboBoxStyle style = (ComboBoxStyle)propStyle.GetValue(component);

                    // Height is not user-changable for these styles
                    if (style == ComboBoxStyle.DropDown || style == ComboBoxStyle.DropDownList)
                        rules &= ~(SelectionRules.TopSizeable | SelectionRules.BottomSizeable);
                }

                return rules;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\compositioncommandset.cs ===
//------------------------------------------------------------------------------
// <copyright file="CompositionCommandSet.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms.Design {
    using System.ComponentModel;
    using System.Diagnostics;
    using System;    
    using System.ComponentModel.Design;
    using System.Windows.Forms;
    using System.Drawing;
    using System.Collections;
    using Microsoft.Win32;

    /// <include file='doc\CompositionCommandSet.uex' path='docs/doc[@for="CompositionCommandSet"]/*' />
    /// <devdoc>
    ///      This class implements commands that are specific to the
    ///      composition designer.
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class CompositionCommandSet : CommandSet {

        private Control             compositionUI;
        private CommandSetItem[]    commandSet;
        
        /// <include file='doc\CompositionCommandSet.uex' path='docs/doc[@for="CompositionCommandSet.CompositionCommandSet"]/*' />
        /// <devdoc>
        ///      Constructs a new composition command set object.
        /// </devdoc>
        public CompositionCommandSet(Control compositionUI, ISite site) : base(site) {
            Debug.Assert(compositionUI != null, "Null compositionUI passed into CompositionCommandSet");
            this.compositionUI = compositionUI;

            // Establish our set of commands
            //
            commandSet = new CommandSetItem[] {
                // Keyboard commands
                new CommandSetItem(
                                  this,
                                  new EventHandler(OnStatusAlways),
                                  new EventHandler(OnKeySelect),
                                  MenuCommands.KeySelectNext),
                                  
                new CommandSetItem(
                                  this,
                                  new EventHandler(OnStatusAlways),
                                  new EventHandler(OnKeySelect),
                                  MenuCommands.KeySelectPrevious),
            };
            
            if (MenuService != null) {
                for (int i = 0; i < commandSet.Length; i++) {
                    MenuService.AddCommand(commandSet[i]);
                }
            }
        }
        
        /// <include file='doc\CompositionCommandSet.uex' path='docs/doc[@for="CompositionCommandSet.Dispose"]/*' />
        /// <devdoc>
        ///     Disposes of this object, removing all commands from the menu service.
        /// </devdoc>
        public override void Dispose() {
            if (MenuService != null) {
                for (int i = 0; i < commandSet.Length; i++) {
                    MenuService.RemoveCommand(commandSet[i]);
                }
            }
            base.Dispose();
        }

        /// <include file='doc\CompositionCommandSet.uex' path='docs/doc[@for="CompositionCommandSet.OnKeyCancel"]/*' />
        /// <devdoc>
        ///     Called for the two cancel commands we support.
        /// </devdoc>
        protected override bool OnKeyCancel(object sender) {

            // The base implementation here just checks to see if we are dragging.
            // If we are, then we abort the drag.
            //
            if (!base.OnKeyCancel(sender)) {
                ISelectionService selSvc = SelectionService;
                IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));

                if (selSvc == null || host == null) {
                    return true;
                }

                IComponent comp = host.RootComponent;
                selSvc.SetSelectedComponents(new object[] {comp}, SelectionTypes.Replace);

                return true;
            }
            
            return false;
        }

        /// <include file='doc\CompositionCommandSet.uex' path='docs/doc[@for="CompositionCommandSet.OnKeySelect"]/*' />
        /// <devdoc>
        ///     Called for selection via the tab key.
        /// </devdoc>
        protected void OnKeySelect(object sender, EventArgs e) {
            MenuCommand cmd = (MenuCommand)sender;
            bool reverse = (cmd.CommandID.Equals(MenuCommands.KeySelectPrevious));
            RotateTabSelection(reverse);
        }
        
        /// <include file='doc\CompositionCommandSet.uex' path='docs/doc[@for="CompositionCommandSet.OnUpdateCommandStatus"]/*' />
        /// <devdoc>
        ///      This is called when the selection has changed.  Anyone using CommandSetItems
        ///      that need to update their status based on selection changes should override
        ///      this and update their own commands at this time.  The base implementaion
        ///      runs through all base commands and calls UpdateStatus on them.
        /// </devdoc>
        protected override void OnUpdateCommandStatus() {
            // Now whip through all of the commands and ask them to update.
            //
            for (int i = 0; i < commandSet.Length; i++) {
                commandSet[i].UpdateStatus();
            }
            base.OnUpdateCommandStatus();
        }

        /// <include file='doc\CompositionCommandSet.uex' path='docs/doc[@for="CompositionCommandSet.RotateTabSelection"]/*' />
        /// <devdoc>
        ///     Rotates the selection to the element next in the tab index.  If backwards
        ///     is set, this will rotate to the previous tab index.
        /// </devdoc>
        private void RotateTabSelection(bool backwards) {
            ISelectionService           selSvc;
            IComponent                  currentComponent;
            Control                     currentControl;
            ComponentTray.TrayControl   nextControl = null;

            // First, get the currently selected component
            //
            selSvc = SelectionService;
            if (selSvc == null) {
                return;
            }

            object primarySelection = selSvc.PrimarySelection;

            if (primarySelection is IComponent) {
                currentComponent = (IComponent)primarySelection;
            }
            else {
                currentComponent = null;
                ICollection selection = selSvc.GetSelectedComponents();
                foreach(object obj in selection) {
                    if (obj is IComponent) {
                        currentComponent = (IComponent)obj;
                        break;
                    }
                }
            }

            // Now, if we have a selected component, get the composition UI for it and
            // find the next control on the UI.  Otherwise, we just select the first
            // control on the UI.
            //
            if (currentComponent != null) {
                currentControl = ComponentTray.TrayControl.FromComponent(currentComponent);
            }
            else {
                currentControl = null;
            }

            if (currentControl != null) {
                Debug.Assert(compositionUI.Controls[0] is LinkLabel, "First item in the Composition designer is not a linklabel");
                for (int i = 1; i < compositionUI.Controls.Count; i++) {
                    if (compositionUI.Controls[i] == currentControl) {
                        int next = i + 1;

                        if (next >= compositionUI.Controls.Count) {
                            next = 1;
                        }

                        if (compositionUI.Controls[next] is ComponentTray.TrayControl) {
                            nextControl = (ComponentTray.TrayControl)compositionUI.Controls[next];
                        }
                        else {
                            continue;
                        }
                        break;
                    }
                }
            }
            else {
                if (compositionUI.Controls.Count > 1) {
                    Debug.Assert(compositionUI.Controls[0] is LinkLabel, "First item in the Composition designer is not a linklabel");
                    if (compositionUI.Controls[1] is ComponentTray.TrayControl) {
                        nextControl = (ComponentTray.TrayControl)compositionUI.Controls[1];
                    }
                }
            }

            // If we got a "nextControl", then select the component inside of it.
            //
            if (nextControl != null) {
                selSvc.SetSelectedComponents(new object[] {nextControl.Component}, SelectionTypes.Replace);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\axhostdesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="AxHostDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms.Design {
    using System.Collections;
    using System.Design;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using Hashtable = System.Collections.Hashtable;
    using IDictionaryEnumerator = System.Collections.IDictionaryEnumerator;
    using System.IO;
    using System.Runtime.InteropServices;
    using System.Windows.Forms;
    using System.Drawing;    
    using System.ComponentModel.Design;
    using Microsoft.Win32;

    /// <include file='doc\AxHostDesigner.uex' path='docs/doc[@for="AxHostDesigner"]/*' />
    /// <devdoc>
    ///    <para> Provides design time behavior for the AxHost class. AxHost
    ///       is used to host ActiveX controls.</para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class AxHostDesigner : ControlDesigner {
        private AxHost axHost;
        private EventHandler handler;
        private bool foundEdit = false;
        private bool foundAbout = false;
        private bool foundProperties = false;
        private bool dragdropRevoked = false;

        private const int OLEIVERB_UIACTIVATE = -4;
        private const int HOSTVERB_ABOUT = 2;
        private const int HOSTVERB_PROPERTIES = 1;
        private const int HOSTVERB_EDIT = 3;

        private static readonly HostVerbData EditVerbData = new HostVerbData(SR.GetString(SR.AXEdit), HOSTVERB_EDIT);
        private static readonly HostVerbData PropertiesVerbData = new HostVerbData(SR.GetString(SR.AXProperties), HOSTVERB_PROPERTIES);
        private static readonly HostVerbData AboutVerbData = new HostVerbData(SR.GetString(SR.AXAbout), HOSTVERB_ABOUT);

        private static TraceSwitch AxHostDesignerSwitch     = new TraceSwitch("AxHostDesigner", "ActiveX Designer Trace");

        /// <include file='doc\AxHostDesigner.uex' path='docs/doc[@for="AxHostDesigner.AxHostDesigner"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Windows.Forms.Design.AxHostDesigner'/> class.
        ///    </para>
        /// </devdoc>
        public AxHostDesigner() {
            handler = new EventHandler(this.OnVerb);
        }
        
        /// <include file='doc\AxHostDesigner.uex' path='docs/doc[@for="AxHostDesigner.SelectionStyle"]/*' />
        /// <devdoc>
        ///     This property allows the AxHost class to modify our selection style.  It provides three levels
        ///     of selection:  0 (not selected), 1 (selected) and 2 (selected UI active).
        /// </devdoc>
        private int SelectionStyle {
            get {
                // we don't implement GET
                return 0;
            }
            set {
                ISelectionUIService uis = (ISelectionUIService)GetService(typeof(ISelectionUIService));
                if (uis != null) {
                    SelectionStyles style = SelectionStyles.None;
                    if (value == 1) style = SelectionStyles.Selected;
                    else if (value == 2) style = SelectionStyles.Active;
                    
                    uis.SetSelectionStyle(Component, style);
                }
            }
        }

        /// <include file='doc\AxHostDesigner.uex' path='docs/doc[@for="AxHostDesigner.GetOleVerbs"]/*' />
        public override DesignerVerbCollection Verbs { 
            get {
                DesignerVerbCollection l = new DesignerVerbCollection();
                GetOleVerbs(l);
                /*
                if (!foundEdit && (((AxHost)axHost).OCXFlags & AxHost.AxFlags.PREVENT_EDIT_MODE) == 0) {
                    l.Add(new HostVerb(EditVerbData, handler));
                }
                if ((((AxHost)axHost).OCXFlags & AxHost.AxFlags.INCLUDE_PROPERTIES_VERB) != 0 && ((AxHost)axHost).HasPropertyPages()) {
                    l.Add(new HostVerb(PropertiesVerbData, handler));
                }
                */
                if (!foundAbout && ((AxHost)axHost).HasAboutBox) {
                    l.Add(new HostVerb(AboutVerbData, handler));
                }
                return l;
            }
        }

        public virtual void GetOleVerbs(DesignerVerbCollection rval) {
            NativeMethods.IEnumOLEVERB verbEnum = null;
            NativeMethods.IOleObject obj = axHost.GetOcx() as NativeMethods.IOleObject;
            if (obj == null || NativeMethods.Failed(obj.EnumVerbs(out verbEnum))) {
                return;
            }

            Debug.Assert(verbEnum != null, "must have return value");
            if (verbEnum == null) return;
            int[] fetched = new int[1];
            NativeMethods.tagOLEVERB oleVerb = new NativeMethods.tagOLEVERB();

            foundEdit = false;
            foundAbout = false;
            foundProperties = false;

            while (true) {
                fetched[0] = 0;
                oleVerb.lpszVerbName = null;
                int hr = verbEnum.Next(1, oleVerb, fetched);
                if (hr == NativeMethods.S_FALSE) {
                    break;
                }
                else if (NativeMethods.Failed(hr)) {
                    Debug.Fail("Failed to enumerate through enums: " + hr.ToString());
                    break;
                }

                // Believe it or not, some controls, notably the shdocview control, dont' return
                // S_FALSE and neither do they set fetched to 1.  So, we need to comment out what's
                // below to maintain compatibility with Visual Basic.
                //                 if (fetched[0] != 1) {
                //                     Debug.fail("gotta have our 1 verb...");
                //                     break;
                //                 }
                if ((oleVerb.grfAttribs & NativeMethods.ActiveX.OLEVERBATTRIB_ONCONTAINERMENU) != 0) {
                    foundEdit = foundEdit || oleVerb.lVerb == OLEIVERB_UIACTIVATE;
                    foundAbout = foundAbout || oleVerb.lVerb == HOSTVERB_ABOUT;
                    foundProperties = foundProperties || oleVerb.lVerb == HOSTVERB_PROPERTIES;

                    rval.Add(new HostVerb(new OleVerbData(oleVerb), handler));
                }
            }
        }

        protected override bool GetHitTest(Point p) {
            return axHost.EditMode;
        }

        public override void Initialize(IComponent component) {
            base.Initialize(component);
            axHost = (AxHost)component;
        }

        /// <include file='doc\AxHostDesigner.uex' path='docs/doc[@for="AxHostDesigner.OnCreateHandle"]/*' />
        /// <devdoc>
        ///      This is called immediately after the control handle has been created.
        /// </devdoc>
        protected override void OnCreateHandle() {
            base.OnCreateHandle();

            //Application.OLERequired();
            //int n = NativeMethods.RevokeDragDrop(Control.Handle);
        }

        /// <include file='doc\AxHostDesigner.uex' path='docs/doc[@for="AxHostDesigner.OnSetComponentDefaults"]/*' />
        /// <devdoc>
        ///     Called when the designer is intialized.  This allows the designer to provide some
        ///     meaningful default values in the component.  The default implementation of this
        ///     sets the components's default property to it's name, if that property is a string.
        /// </devdoc>
        public override void OnSetComponentDefaults() {
            try {
                base.OnSetComponentDefaults();
            }
            catch (Exception) {
                // The ControlDesigner tries to set the Text property of the control when 
                // it creates the site. ActiveX controls generally don't like that, causing an
                // exception to be thrown. We now catch these exceptions in the AxHostDesigner
                // and continue on.
            }
        }

        public virtual void OnVerb(object sender, EventArgs evevent) {
            if (sender != null && sender is HostVerb) {
                HostVerb vd = (HostVerb)sender;
                vd.Invoke((AxHost)axHost);
            }
            else {
                Debug.Fail("Bad verb invocation.");
            }
        }

        /// <include file='doc\AxHostDesigner.uex' path='docs/doc[@for="AxHostDesigner.PreFilterProperties"]/*' />
        /// <devdoc>
        ///      Allows a designer to filter the set of properties
        ///      the component it is designing will expose through the
        ///      TypeDescriptor object.  This method is called
        ///      immediately before its corresponding "Post" method.
        ///      If you are overriding this method you should call
        ///      the base implementation before you perform your own
        ///      filtering.
        /// </devdoc>
        protected override void PreFilterProperties(IDictionary properties) {
            object enabledProp = properties["Enabled"];

            base.PreFilterProperties(properties);

            properties["Enabled"] = enabledProp;

            // Add a property to handle selection from ActiveX
            //
            properties["SelectionStyle"] = TypeDescriptor.CreateProperty(typeof(AxHostDesigner), "SelectionStyle",
                typeof(int),
                BrowsableAttribute.No,
                DesignerSerializationVisibilityAttribute.Hidden,
                DesignOnlyAttribute.Yes);
        }
        
        /// <include file='doc\AxHostDesigner.uex' path='docs/doc[@for="AxHostDesigner.WndProc"]/*' />
        /// <devdoc>
        ///     This method should be called by the extending designer for each message
        ///     the control would normally receive.  This allows the designer to pre-process
        ///     messages before allowing them to be routed to the control.
        /// </devdoc>
        protected override void WndProc(ref Message m) {
            switch (m.Msg) {
                case NativeMethods.WM_PARENTNOTIFY:
                    if ((int)m.WParam == NativeMethods.WM_CREATE) {
                        HookChildHandles(m.LParam);
                    }

                    base.WndProc(ref m);
                    break;
                
                case NativeMethods.WM_NCHITTEST:
                    // ASURT 66102 The ShDocVw control registers itself as a drop-target even in design mode.
                    // We take the first chance to unregister that, so we can perform our design-time behavior
                    // irrespective of what the control wants to do.
                    //
                    if (!dragdropRevoked) {
                        int n = NativeMethods.RevokeDragDrop(Control.Handle);
                        dragdropRevoked = (n == NativeMethods.S_OK);
                    }
                    
                    // Some ActiveX controls return non-HTCLIENT return values for NC_HITTEST, which
                    // causes the message to go to our parent.  We want the control's designer to get
                    // these messages so we change the result to HTCLIENT.
                    //
                    base.WndProc(ref m);
                    if (((int)m.Result == NativeMethods.HTTRANSPARENT) || ((int)m.Result > NativeMethods.HTCLIENT)) {
                        Debug.WriteLineIf(AxHostDesignerSwitch.TraceVerbose, "Converting NCHITTEST result from : " + (int)m.Result + " to HTCLIENT");
                        m.Result = (IntPtr)NativeMethods.HTCLIENT;
                    }
                    break;

                default:
                    base.WndProc(ref m);
                    break;
            }
        }

        /**
          * @security(checkClassLinking=on)
          */
        private class HostVerb : DesignerVerb {
            private HostVerbData data;

            public HostVerb(HostVerbData data, EventHandler handler) : base(data.ToString(), handler) {
                this.data = data;
            }

            public void Invoke(AxHost host) {
                data.Execute(host);
            }
        }

        /**
         * @security(checkClassLinking=on)
         */
        private class HostVerbData {
            internal readonly string name;
            internal readonly int id;

            internal HostVerbData(string name, int id) {
                this.name = name;
                this.id = id;
            }

            public override string ToString() {
                return name;
            }

            internal virtual void Execute(AxHost ctl) {
                switch (id) {
                    case HOSTVERB_PROPERTIES:
                        ctl.ShowPropertyPages();
                        break;
                    case HOSTVERB_EDIT:
                        ctl.InvokeEditMode();
                        break;
                    case HOSTVERB_ABOUT:
                        ctl.ShowAboutBox();
                        break;
                    default:
                        Debug.Fail("bad verb id in HostVerb");
                        break;
                }
            }
        }

        /**
         * @security(checkClassLinking=on)
         */
        private class OleVerbData : HostVerbData {
            private readonly bool dirties;

            internal OleVerbData(NativeMethods.tagOLEVERB oleVerb)
            : base(SR.GetString(SR.AXVerbPrefix) + oleVerb.lpszVerbName, oleVerb.lVerb) {
                this.dirties = (oleVerb.grfAttribs & NativeMethods.ActiveX.OLEVERBATTRIB_NEVERDIRTIES) == 0;
            }

            internal override void Execute(AxHost ctl) {
                if (dirties) ctl.MakeDirty();
                ctl.DoVerb(id);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\aximporter.cs ===
//------------------------------------------------------------------------------
// <copyright file="AxImporter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   AxImporter.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Windows.Forms.Design {
    using System.Design;        
    using System;
    using Microsoft.Win32;
    using System.ComponentModel;
    using System.IO;
    using System.ComponentModel.Design;
    using System.Reflection;
    using System.Reflection.Emit;
    using System.Diagnostics;
    using System.Windows.Forms;
    using System.Runtime.InteropServices;
    using System.Collections;
    using System.Globalization;
    
    /// <include file='doc\AxImporter.uex' path='docs/doc[@for="AxImporter"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Imports ActiveX controls and generates a wrapper that can be accessed by a
    ///       designer.
    ///    </para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public class AxImporter {

        // Private instance data.
        //
        internal Options options;
        internal string typeLibName;
        private ArrayList refAssems;
        private ArrayList genAssems;
        private ArrayList tlbAttrs;
        private ArrayList generatedSources;
        private Hashtable copiedAssems;
        private Hashtable rcwCache;

        /// <include file='doc\AxImporter.uex' path='docs/doc[@for="AxImporter.AxImporter"]/*' />
        public AxImporter(Options options) {
            this.options = options;
        }

        /// <include file='doc\AxImporter.uex' path='docs/doc[@for="AxImporter.GeneratedAssemblies"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string[] GeneratedAssemblies {
            get {
                if (genAssems == null || genAssems.Count <= 0) {
                    return new string[0];
                }
                Debug.Assert(tlbAttrs.Count == genAssems.Count, "Number of typelibs not equal to number of generated assemblies");

                string[] gen = new string[genAssems.Count];

                // Return references to all the generated assemblies.
                //
                for (int i = 0; i < genAssems.Count; ++i) {
                    gen[i] = (string)genAssems[i];
                }

                return gen;
            }
        }

        /// <include file='doc\AxImporter.uex' path='docs/doc[@for="AxImporter.GeneratedTypeLibAttributes"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public TYPELIBATTR[] GeneratedTypeLibAttributes {
            get {
                if (tlbAttrs == null) {
                    return new TYPELIBATTR[0];
                }

                TYPELIBATTR[] gen = new TYPELIBATTR[tlbAttrs.Count];

                // Return references to all the generated assemblies.
                //
                for (int i = 0; i < tlbAttrs.Count; ++i) {
                    gen[i] = (TYPELIBATTR)tlbAttrs[i];
                }

                return gen;
            }
        }

        /// <include file='doc\AxImporter.uex' path='docs/doc[@for="AxImporter.GeneratedSources"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string[] GeneratedSources {
            get {
                if (options.genSources) {
                    string[] srcs = new string[ generatedSources.Count ];
                    for (int i = 0; i < generatedSources.Count; i++) {
                        srcs[ i ] = (string) generatedSources[ i ];
                    }
                    
                    return srcs;
                }
                else
                    return null;
            }
        }
        
        private void AddDependentAssemblies(Assembly assem) {
            AssemblyName[] refAssems = assem.GetReferencedAssemblies();
            foreach(AssemblyName an in refAssems) {
                if (String.Compare(an.Name, "mscorlib", true, CultureInfo.InvariantCulture) == 0)
                    continue;
                
                string codebase = GetComReference(an);
                
                // If we can't get a valid codebase, see if we can load this
                // assembly from the AssemblyName (should succeed if this is
                // in the GAC or some path where Fusion can find this) and then
                // get the codebase from there.
                //
                if (codebase == null) {
                    Assembly dependAssem = Assembly.Load(an);
                    codebase = dependAssem.EscapedCodeBase;
                    if (codebase != null) {
                        codebase = GetLocalPath(codebase);
                    }
                }

                Debug.Assert(codebase != null, "No reference found for assembly: " + an.Name);
                AddReferencedAssembly(codebase);
            }
        }

        private void AddReferencedAssembly(string assem) {
            if (refAssems == null) {
                refAssems = new ArrayList();
            }

            refAssems.Add(assem);
        }

        private void AddGeneratedAssembly(string assem) {
            if (genAssems == null) {
                genAssems = new ArrayList();
            }

            genAssems.Add(assem);
        }

        internal void AddRCW(UCOMITypeLib typeLib, Assembly assem) {
            if (rcwCache == null) {
                rcwCache = new Hashtable();
            }

            IntPtr typeLibAttr = NativeMethods.InvalidIntPtr;
            typeLib.GetLibAttr(out typeLibAttr);

            try {
                if (typeLibAttr != NativeMethods.InvalidIntPtr) {
                    // Marshal the returned int as a TLibAttr structure
                    //
                    TYPELIBATTR tlbAttr = (TYPELIBATTR) Marshal.PtrToStructure(typeLibAttr, typeof(TYPELIBATTR)); 
                    rcwCache.Add(tlbAttr.guid, assem);
                }
            }
            finally {
                typeLib.ReleaseTLibAttr(typeLibAttr);
            }
        }

        internal Assembly FindRCW(UCOMITypeLib typeLib) {
            if (rcwCache == null) {
                return null;
            }

            IntPtr typeLibAttr = NativeMethods.InvalidIntPtr;
            typeLib.GetLibAttr(out typeLibAttr);

            try {
                if (typeLibAttr != NativeMethods.InvalidIntPtr) {
                    // Marshal the returned int as a TLibAttr structure
                    //
                    TYPELIBATTR tlbAttr = (TYPELIBATTR) Marshal.PtrToStructure(typeLibAttr, typeof(TYPELIBATTR)); 
                    return (Assembly)rcwCache[tlbAttr.guid];
                }
            }
            finally {
                typeLib.ReleaseTLibAttr(typeLibAttr);
            }

            return null;
        }

        private void AddTypeLibAttr(UCOMITypeLib typeLib) {
            // Add the TYPELIBATTR of the TypeLib to our list.
            //
            if (tlbAttrs == null) {
                tlbAttrs = new ArrayList();
            }
            
            IntPtr typeLibAttr = NativeMethods.InvalidIntPtr;
            typeLib.GetLibAttr(out typeLibAttr);
            if (typeLibAttr != NativeMethods.InvalidIntPtr) {
                // Marshal the returned int as a TLibAttr structure
                //
                TYPELIBATTR typeLibraryAttributes = (TYPELIBATTR) Marshal.PtrToStructure(typeLibAttr, typeof(TYPELIBATTR)); 
                tlbAttrs.Add(typeLibraryAttributes);

                typeLib.ReleaseTLibAttr(typeLibAttr);
            }
        }

        private string GetAxReference(UCOMITypeLib typeLib) {
            if (options.references == null)
                return null;

            return options.references.ResolveActiveXReference(typeLib);
        }

        private string GetReferencedAssembly(string assemName) {
            if (refAssems == null || refAssems.Count <= 0)
                return null;

            foreach(string assemRef in refAssems) {
                if (String.Compare(assemRef, assemName, true, CultureInfo.InvariantCulture) == 0) {
                    return assemRef;
                }
            }

            return null;
        }

        private string GetComReference(UCOMITypeLib typeLib) {
            if (options.references == null)
                return null;

            return options.references.ResolveComReference(typeLib);
        }

        private string GetComReference(AssemblyName name) {
            if (options.references == null)
                return name.EscapedCodeBase;

            return options.references.ResolveComReference(name);
        }

        private string GetManagedReference(string assemName) {
            if (options.references == null)
                return assemName + ".dll";

            return options.references.ResolveManagedReference(assemName);
        }

        /// <devdoc>
        /// <para>Walks through all AxHost derived classes in the given assembly, 
        /// and returns the type that matches our control's CLSID.</para>
        /// </devdoc>
        private string GetAxTypeFromAssembly(string fileName, Guid clsid) {
            Assembly a = GetCopiedAssembly(fileName, true, false);

            Type[] types = a.GetTypes();
            foreach(Type t in types) {
                if (!(typeof(AxHost).IsAssignableFrom(t))) {
                    continue;
                }

                object[] attrs = t.GetCustomAttributes(typeof(AxHost.ClsidAttribute), false);
                Debug.Assert(attrs != null && attrs.Length == 1, "Invalid number of GuidAttributes found on: " + t.FullName);

                AxHost.ClsidAttribute clsidAttr = (AxHost.ClsidAttribute)attrs[0];
                if (clsidAttr.Value == "{" + clsid.ToString() + "}")
                    return t.FullName;
            }

            return null;
        }

        private Assembly GetCopiedAssembly(string fileName, bool loadPdb, bool isPIA) {
            if (!File.Exists(fileName)) {
                return null;
            }

            Assembly assembly = null;
            string upperFileName = fileName.ToUpper(CultureInfo.InvariantCulture);
            if (copiedAssems == null) {
                copiedAssems = new Hashtable();
            }
            else {
                if (copiedAssems.Contains(upperFileName))
                    return (Assembly)copiedAssems[upperFileName];
            }

            Debug.WriteLineIf(AxWrapperGen.AxWrapper.Enabled, "Loading assembly " + fileName + ((!isPIA) ? " from bytes" : " from file"));

            if (!isPIA) {
                // Shadow copy the assembly first...
                //
                Stream stream = new FileStream(fileName, FileMode.Open, FileAccess.Read, FileShare.Read);
                int streamLen = (int)stream.Length;

                byte[] assemblyBytes = new byte[streamLen];
                stream.Read(assemblyBytes, 0, streamLen);
                stream.Close();

                byte[] pdbBytes = null;
                if (loadPdb) {
                    // See if we can discover a PDB at the same time.
                    //
                    string pdbName = Path.ChangeExtension(fileName, "pdb");
                    if (File.Exists(pdbName)) {
                        stream = new FileStream(pdbName, FileMode.Open, FileAccess.Read, FileShare.Read);
                        streamLen = (int)stream.Length;
                        pdbBytes = new byte[streamLen];
                        stream.Read(pdbBytes, 0, streamLen);
                        stream.Close();
                        Debug.WriteLineIf(AxWrapperGen.AxWrapper.Enabled, "Located assembly PDB " + pdbName + " containing " + streamLen + " bytes.");
                    }
                }

                if (pdbBytes == null) {
                    assembly = Assembly.Load(assemblyBytes);
                }
                else {
                    assembly = Assembly.Load(assemblyBytes, pdbBytes);
                }
            }
            else {
                assembly = Assembly.LoadFrom(fileName);
            }
            
            copiedAssems.Add(upperFileName, assembly);
            return assembly;
        }

        /// <devdoc>
        /// <para>Gets the file name corresponding to the given TypelibAttribute. </para>
        /// </devdoc>
        private static string GetFileOfTypeLib(UCOMITypeLib typeLib) {
            IntPtr typeLibAttr = NativeMethods.InvalidIntPtr;
            typeLib.GetLibAttr(out typeLibAttr);
            if (typeLibAttr != NativeMethods.InvalidIntPtr) {
                // Marshal the returned int as a TLibAttr structure
                //
                TYPELIBATTR typeLibraryAttributes = (TYPELIBATTR) Marshal.PtrToStructure(typeLibAttr, typeof(TYPELIBATTR)); 

                try {
                    return GetFileOfTypeLib(ref typeLibraryAttributes);
                }
                finally {
                    typeLib.ReleaseTLibAttr(typeLibAttr);
                }
            }

            return null;
        }

        /// <include file='doc\AxImporter.uex' path='docs/doc[@for="AxImporter.GetFileOfTypeLib"]/*' />
        /// <devdoc>
        /// <para>Gets the file name corresponding to the given TypelibAttribute. </para>
        /// </devdoc>
        public static string GetFileOfTypeLib(ref TYPELIBATTR tlibattr) { 
            // Get which file the type library resides in.  If the appropriate
            // file cannot be found then a blank string is returned.  

            string returnedPath = null;
            
            // Get the path from the registry
            returnedPath = NativeMethods.QueryPathOfRegTypeLib(ref tlibattr.guid, tlibattr.wMajorVerNum, tlibattr.wMinorVerNum, tlibattr.lcid);
            
            if (returnedPath.Length > 0) {
                // Remove the '\0' characters at the end of the string, so File.Exists()
                // does not get confused.
                int nullTerminate = returnedPath.IndexOf('\0');
                if (nullTerminate > -1) {
                    returnedPath = returnedPath.Substring(0, nullTerminate);
                }

                // If we got a path then it might have a type library number appended to 
                // it.  If so, then we need to strip it.  
                if (!File.Exists(returnedPath)) {
                    // Strip the type library number
                    //
                    int lastSlash = returnedPath.LastIndexOf(Path.DirectorySeparatorChar);
                    if (lastSlash != -1) {
                        bool allNumbers = true;
                        for (int i = lastSlash + 1; i < returnedPath.Length; i++) {

                            // We have to check for NULL here because QueryPathOfRegTypeLib() returns
                            // a BSTR with a NULL character appended to it.
                            if (returnedPath[i] != '\0' && !Char.IsDigit(returnedPath[i])) {
                                allNumbers = false;
                                break;
                            }
                        }

                        // If we had all numbers past the last slash then we're OK to strip
                        // the type library number
                        if (allNumbers) {
                            returnedPath = returnedPath.Substring(0, lastSlash); 
                            if (!File.Exists(returnedPath)) {
                                returnedPath = null;
                            }
                        }  
                        else {
                            returnedPath = null;
                        }
                    }
                    else {
                        returnedPath = null;
                    }
                }
            }

            return returnedPath;
        }

        /// <devdoc>
        ///     This method takes a file URL and converts it to a local path.  The trick here is that
        ///     if there is a '#' in the path, everything after this is treated as a fragment.  So
        ///     we need to append the fragment to the end of the path.
        /// </devdoc>
        private string GetLocalPath(string fileName) {
            System.Diagnostics.Debug.Assert(fileName != null && fileName.Length > 0, "Cannot get local path, fileName is not valid");

            Uri uri = new Uri(fileName, true);
            return uri.LocalPath + uri.Fragment;
        }

        /// <devdoc>
        ///    <para>
        ///       Generates a wrapper for an ActiveX control for use in the design-time
        ///       environment.
        ///    </para>
        /// </devdoc>
        internal string GenerateFromActiveXClsid(Guid clsid) {
            string controlKey = "CLSID\\{" + clsid.ToString() + "}";
            RegistryKey key = Registry.ClassesRoot.OpenSubKey(controlKey);
            if (key == null) {
                Debug.WriteLineIf(AxWrapperGen.AxWrapper.Enabled, "No registry key found for: " + controlKey);
                throw new ArgumentException(SR.GetString(SR.AXNotRegistered, controlKey.ToString()));
            }

            // Load the typelib into memory.
            //
            UCOMITypeLib typeLib = null;

            // Try to get the TypeLib's Guid.
            //
            Guid tlbGuid = Guid.Empty;

            // Open the key for the TypeLib
            //
            RegistryKey tlbKey = key.OpenSubKey("TypeLib");

            if (tlbKey != null) {
                // Get the major and minor version numbers.
                //
                RegistryKey verKey = key.OpenSubKey("Version");
                Debug.Assert(verKey != null, "No version registry key found for: " + controlKey);

                short majorVer = -1;
                short minorVer = -1;
                string ver = (string)verKey.GetValue("");
                int dot = ver.IndexOf('.');
                if (dot == -1) {
                    majorVer = Int16.Parse(ver);
                    minorVer = 0;
                }
                else {
                    majorVer = Int16.Parse(ver.Substring(0, dot));
                    minorVer = Int16.Parse(ver.Substring(dot + 1, ver.Length - dot - 1));
                }
                Debug.Assert(majorVer > 0 && minorVer >= 0, "No Major version number found for: " + controlKey);
                verKey.Close();

                object o = tlbKey.GetValue("");
                tlbGuid = new Guid((string)o);
                Debug.Assert(!tlbGuid.Equals(Guid.Empty), "No valid Guid found for: " + controlKey);
                tlbKey.Close();

                try {
                    typeLib = NativeMethods.LoadRegTypeLib(ref tlbGuid, majorVer, minorVer, Application.CurrentCulture.LCID);
                }
                catch (Exception e) {
                    Debug.WriteLineIf(AxWrapperGen.AxWrapper.Enabled, "Failed to LoadRegTypeLib: " + e.ToString());
                }
            }

            // Try to load the TLB directly from the InprocServer32.
            //
            // If that fails, try to load the TLB based on the TypeLib guid key.
            //
            if (typeLib == null) {
                RegistryKey inprocServerKey = key.OpenSubKey("InprocServer32");
                if (inprocServerKey != null) {
                    string inprocServer = (string)inprocServerKey.GetValue("");
                    Debug.Assert(inprocServer != null, "No valid InprocServer32 found for: " + controlKey);               
                    inprocServerKey.Close();

                    typeLib = NativeMethods.LoadTypeLib(inprocServer);
                }
            }

            key.Close();

            if (typeLib != null) {
                try {
                    return GenerateFromTypeLibrary(typeLib, clsid);
                }
                finally {
                    Marshal.ReleaseComObject(typeLib);
                }
            }
            else {
                throw new ArgumentException(SR.GetString(SR.AXNotRegistered, controlKey.ToString()));
            }
        }

        /// <include file='doc\AxImporter.uex' path='docs/doc[@for="AxImporter.GenerateFromFile"]/*' />
        /// <devdoc>
        ///    <para>Generates a wrapper for an ActiveX control for use in the design-time
        ///       environment.</para>
        /// </devdoc>
        public string GenerateFromFile(FileInfo file) {
            typeLibName = file.FullName;

            UCOMITypeLib typeLib = null;
            Debug.WriteLineIf(AxWrapperGen.AxWrapper.Enabled, "Loading Typelib from " + typeLibName);
            typeLib = (UCOMITypeLib)NativeMethods.LoadTypeLib(typeLibName);
            if (typeLib == null) {
                throw new Exception(SR.GetString(SR.AXCannotLoadTypeLib, typeLibName));
            }

            try {
                return GenerateFromTypeLibrary(typeLib);
            }
            finally {
                if (typeLib != null) {
                    Marshal.ReleaseComObject(typeLib);
                }
            }
        }

        /// <include file='doc\AxImporter.uex' path='docs/doc[@for="AxImporter.GenerateFromTypeLibrary"]/*' />
        /// <devdoc>
        ///    <para>Generates a wrapper for an ActiveX control for use in the design-time
        ///       environment.</para>
        /// </devdoc>
        public string GenerateFromTypeLibrary(UCOMITypeLib typeLib) {
            bool foundAxCtl = false;
            
            int ctypes = typeLib.GetTypeInfoCount();
            Debug.WriteLineIf(AxWrapperGen.AxWrapper.Enabled, "Number of TypeInfos found in typelib: " + ctypes);

            for (int i = 0; i < ctypes; ++i) {
                IntPtr pAttr;
                TYPEATTR typeAttr;
                UCOMITypeInfo pTI;

                typeLib.GetTypeInfo(i, out pTI);
                pTI.GetTypeAttr(out pAttr);
                typeAttr = (TYPEATTR)Marshal.PtrToStructure(pAttr, typeof(TYPEATTR));

                if ((int)typeAttr.typekind == (int)TYPEKIND.TKIND_COCLASS) {
                    Guid g = typeAttr.guid;
                    string controlKey = "CLSID\\{" + g.ToString() + "}\\Control";
                    RegistryKey key = Registry.ClassesRoot.OpenSubKey(controlKey);
                    if (key != null) {
                        Debug.WriteLineIf(AxWrapperGen.AxWrapper.Enabled, "Found ActiveX control with the following GUID: " + g.ToString());
                        foundAxCtl = true;
                    }
                }

                pTI.ReleaseTypeAttr(pAttr);
                pAttr = IntPtr.Zero;
                Marshal.ReleaseComObject(pTI);
                pTI = null;
            }

            if (foundAxCtl) {
                Debug.WriteLineIf(AxWrapperGen.AxWrapper.Enabled, "Generating Windows Forms wrappers for: " + typeLibName);
                return GenerateFromTypeLibrary(typeLib, Guid.Empty);
            }
            else {
                throw new Exception(SR.GetString(SR.AXNoActiveXControls, (typeLibName != null) ? typeLibName : Marshal.GetTypeLibName(typeLib)));
            }
        }

        /// <include file='doc\AxImporter.uex' path='docs/doc[@for="AxImporter.GenerateFromTypeLibrary1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates a wrapper for an ActiveX control for use in the design-time
        ///       environment.
        ///    </para>
        /// </devdoc>
        public string GenerateFromTypeLibrary(UCOMITypeLib typeLib, Guid clsid) {
            string axWFW = null;
            string axctlType = null;
            Assembly rcw = null;

            // Look to see if we can find the AxWrapper also for this typeLib.
            //
            axWFW = GetAxReference(typeLib);

            if (axWFW != null && clsid != Guid.Empty) {
                axctlType = GetAxTypeFromAssembly(axWFW, clsid);
            }

            if (axWFW == null) {
                string tlbName = Marshal.GetTypeLibName(typeLib);
                string rcwName = Path.Combine(options.outputDirectory, tlbName + ".dll");
                Debug.WriteLineIf(AxWrapperGen.AxWrapper.Enabled, "Converting TypeLib Name: " + tlbName + " in " + rcwName);

                AddReferencedAssembly(GetManagedReference("System.Windows.Forms"));
                AddReferencedAssembly(GetManagedReference("System.Drawing"));
                AddReferencedAssembly(GetManagedReference("System"));

                string rcwAssem = GetComReference(typeLib);
                if (rcwAssem != null) {
                    AddReferencedAssembly(rcwAssem);
                    rcw = GetCopiedAssembly(rcwAssem, false, false);
                    AddDependentAssemblies(rcw);
                }
                else {
                    TypeLibConverter tlbConverter = new TypeLibConverter();
                    
                    // Try to locate the primary interop assembly first.
                    //
                    rcw = GetPrimaryInteropAssembly(typeLib, tlbConverter);
                    
                    if (rcw != null) {
                        rcwAssem = GetLocalPath(rcw.EscapedCodeBase);
                        AddDependentAssemblies(rcw);
                    }
                    else {
                        AssemblyBuilder asmBldr = tlbConverter.ConvertTypeLibToAssembly(typeLib,
                                                                                        rcwName,
                                                                                        (TypeLibImporterFlags)0,
                                                                                        new ImporterCallback(this),
                                                                                        options.publicKey,
                                                                                        options.keyPair,
                                                                                        null,
                                                                                        null);

                        if (rcwAssem == null) {
                            // Save the assembly to the disk only if we did not find it already on the reference list.
                            //
                            rcwAssem = SaveAssemblyBuilder(typeLib, asmBldr, rcwName);
                            rcw = GetCopiedAssembly(rcwAssem, false, false);
                        }
                    }
                }
                Debug.Assert(rcw != null, "No assembly obtained from: " + rcwAssem);

                // Create a list of the referenced assemblies and create the WFW Wrapper for the AxControl.
                //
                int i = 0;
                string[] refAssems = new string[this.refAssems.Count];
                foreach(string assem in this.refAssems) {
                    string name = assem;

                    name = name.Replace("%20", " ");
                    Debug.WriteLineIf(AxWrapperGen.AxWrapper.Enabled, "Adding " + name + " to the wrapper reference list...");
                    refAssems[i++] = name;
                }

                if (axctlType == null) {
                    string file = GetFileOfTypeLib(typeLib);
                    DateTime tlbTimeStamp = (file == null) ? DateTime.Now : File.GetLastWriteTime(file);
                    
                    // Hook up the type resolution events for the appdomain so we can delay load
                    // any assemblies/types users gave us in the /i option.
                    //
                    ResolveEventHandler assemblyResolveEventHandler = new ResolveEventHandler(OnAssemblyResolve);
                    AppDomain.CurrentDomain.AssemblyResolve += assemblyResolveEventHandler;

                    try {
                        if (options.genSources)
                            AxWrapperGen.GeneratedSources = new ArrayList();
                        
                        if (options.outputName == null)
                            options.outputName = "Ax" + tlbName + ".dll";

                        axctlType = AxWrapperGen.GenerateWrappers(this, clsid, rcw, refAssems, tlbTimeStamp, out axWFW);

                        if (options.genSources)
                            generatedSources = AxWrapperGen.GeneratedSources;
                    }
                    finally {
                        AppDomain.CurrentDomain.AssemblyResolve -= assemblyResolveEventHandler;
                    }

                    if (axctlType == null) {
                        throw new Exception(SR.GetString(SR.AXNoActiveXControls, ((typeLibName != null) ? typeLibName : tlbName)));
                    }
                }

                if (axctlType != null) {
                    // Add the WFW assembly to the references list.
                    //
                    Debug.Assert(axWFW != null && axWFW.Length > 0, "Invalid output assembly name");
                    AddReferencedAssembly(axWFW);
                    AddTypeLibAttr(typeLib);
                    AddGeneratedAssembly(axWFW);
                }
            }
        
            return axctlType;
        }

        internal Assembly GetPrimaryInteropAssembly(UCOMITypeLib typeLib, TypeLibConverter tlbConverter) {
            Assembly pia = FindRCW(typeLib);
            if (pia != null)
                return pia;
            
            IntPtr typeLibAttr = NativeMethods.InvalidIntPtr;
            typeLib.GetLibAttr(out typeLibAttr);

            if (typeLibAttr != NativeMethods.InvalidIntPtr) {
                // Marshal the returned int as a TLibAttr structure
                //
                TYPELIBATTR tlbAttr = (TYPELIBATTR) Marshal.PtrToStructure(typeLibAttr, typeof(TYPELIBATTR)); 
                string asmName = null;
                string asmCodeBase = null;

                try {
                    tlbConverter.GetPrimaryInteropAssembly(tlbAttr.guid, tlbAttr.wMajorVerNum, tlbAttr.wMinorVerNum, tlbAttr.lcid,
                                                           out asmName, out asmCodeBase);

                    if (asmName != null && asmCodeBase == null) {
                        // We found the PIA in the GAC... we need a codebase for this
                        // so we can pass this to the compiler.
                        //
                        try {
                            pia = Assembly.Load(asmName);
                            asmCodeBase = GetLocalPath(pia.EscapedCodeBase);
                        }
                        catch (Exception e) {
                            Debug.WriteLineIf(AxWrapperGen.AxWrapper.Enabled, "Could load assembly from GAC " + asmName + " Exception " + e.Message);
                        }
                    }
                    else if (asmCodeBase != null) {
                        asmCodeBase = GetLocalPath(asmCodeBase);
                        pia = Assembly.LoadFrom(asmCodeBase);
                    }

                    if (pia != null) {
                        AddRCW(typeLib, pia);
                        AddReferencedAssembly(asmCodeBase);
                    }
                }
                finally {
                    typeLib.ReleaseTLibAttr(typeLibAttr);
                }
            }
        
            return pia;
        }

        private Assembly OnAssemblyResolve(object sender, ResolveEventArgs e) {
            string assemblyName = e.Name;

            Debug.WriteLineIf(AxWrapperGen.AxWrapper.Enabled, "In OnAssemblyResolve: " + assemblyName);
            
            // Look for the assembly in the RCW cache.
            //
            if (rcwCache != null) {
                foreach (Assembly a in rcwCache.Values) {
                    if (a.FullName == assemblyName) {
                        Debug.WriteLineIf(AxWrapperGen.AxWrapper.Enabled, "\t Found " + a.GetName().Name);
                        return a;
                    }
                }
            }

            Assembly assembly = null;

            if (copiedAssems == null) {
                copiedAssems = new Hashtable();
            }
            else {
                assembly = (Assembly)copiedAssems[assemblyName];
                if (assembly != null) {
                    return assembly;
                }
            }

            // Now, look for it among the copied assemblies.
            //
            if (refAssems == null || refAssems.Count == 0)
                return null;
            
            foreach (string assemName in refAssems) {
                Assembly assem = GetCopiedAssembly(assemName, false, false);
                if (assem == null)
                    continue;

                string s = assem.GetName().FullName;
                if (s == assemblyName) {
                    Debug.WriteLineIf(AxWrapperGen.AxWrapper.Enabled, "\t Found " + s);
                    return assem;
                }
            }

            Debug.WriteLineIf(AxWrapperGen.AxWrapper.Enabled, "\t Did not find " + assemblyName);
            return null;
        }
            
        private string SaveAssemblyBuilder(UCOMITypeLib typeLib, AssemblyBuilder asmBldr, string rcwName) {
            string assembly = null;
            FileInfo rcwFile = new FileInfo(rcwName);
            string fullPath = rcwFile.FullName;
            string assemName = rcwFile.Name;

            // Check to see if the assembly is already in the referenced set of assemblies.
            // If so, just use the referenced assembly instead of creating a new one on disk.
            //

            // Otherwise, create our assembly by saving to disk.
            //
            if (rcwFile.Exists) {
                if (options.overwriteRCW) {
                    if (typeLibName != null && String.Compare(typeLibName, rcwFile.FullName, true, CultureInfo.InvariantCulture) == 0) {
                        throw new Exception(SR.GetString(SR.AXCannotOverwriteFile, rcwFile.FullName));
                    }

                    if (((int)rcwFile.Attributes & (int)FileAttributes.ReadOnly) == (int)FileAttributes.ReadOnly) {
                        throw new Exception(SR.GetString(SR.AXReadOnlyFile, rcwFile.FullName));
                    }

                    try {
                        rcwFile.Delete();
                        asmBldr.Save(assemName);
                    }
                    catch(Exception e) {
                        Debug.WriteLineIf(AxWrapperGen.AxWrapper.Enabled, "Exception deleting file " + rcwFile.FullName + " Exception: " + e.ToString());
                        throw new Exception(SR.GetString(SR.AXCannotOverwriteFile, rcwFile.FullName));
                    }
                }
            }
            else {
                asmBldr.Save(assemName);
            }

            assembly = rcwFile.FullName;

            // Add the generated assembly to our list.
            //
            AddReferencedAssembly(assembly);
            AddTypeLibAttr(typeLib);
            AddGeneratedAssembly(assembly);

            return assembly;
        }

        private class ImporterCallback : ITypeLibImporterNotifySink {
            AxImporter importer;
            Options options;

            public ImporterCallback(AxImporter importer) {
                this.importer = importer;
                this.options = importer.options;
            }

            void ITypeLibImporterNotifySink.ReportEvent(ImporterEventKind EventKind, int EventCode, String EventMsg) {
            }

            Assembly ITypeLibImporterNotifySink.ResolveRef(Object typeLib) {
                try {
                    string assem = importer.GetComReference((UCOMITypeLib)typeLib);
                    if (assem != null) {
                        importer.AddReferencedAssembly(assem);
                    }

                    Assembly a = importer.FindRCW((UCOMITypeLib)typeLib);
                    if (a != null) {
                        return a;
                    }

                    // Generate the RCW for the typelib. We have to go through the motions of this anyway,
                    // because there is no easy way to find the dependent references for this typelib.
                    //
                    try {
                        string tlbName = Marshal.GetTypeLibName((UCOMITypeLib)typeLib);
                        string rcwName = Path.Combine(options.outputDirectory, tlbName + ".dll");

                        Debug.WriteLineIf(AxWrapperGen.AxWrapper.Enabled, "\tConverting recursive TypeLib Name: " + tlbName + " in " + rcwName);
                        
                        if (importer.GetReferencedAssembly(rcwName) != null) {
                            Debug.WriteLineIf(AxWrapperGen.AxWrapper.Enabled, "\t\tFound RCW in referenced assembly list at " + rcwName);
                            return importer.GetCopiedAssembly(rcwName, false, false);
                        }

                        // Create the TypeLibConverter.
                        TypeLibConverter tlbConv = new TypeLibConverter();

                        // Try to locate the primary interop assembly first.
                        //
                        a = importer.GetPrimaryInteropAssembly((UCOMITypeLib)typeLib, tlbConv);
                        if (a != null) {
                            return a;
                        }
                        else {
                            // Convert the typelib.
                            AssemblyBuilder asmBldr = tlbConv.ConvertTypeLibToAssembly(typeLib,
                                                                                       rcwName,
                                                                                       (TypeLibImporterFlags)0,
                                                                                       new ImporterCallback(importer),
                                                                                       options.publicKey,
                                                                                       options.keyPair,
                                                                                       null,
                                                                                       null);
    
                            if (assem == null) {
                                // Save the assembly to the disk only if we did not find it already on the reference list.
                                //
                                Debug.WriteLineIf(AxWrapperGen.AxWrapper.Enabled, "\t\tGenerated RCW at " + rcwName);
                                string rcwAssem = importer.SaveAssemblyBuilder((UCOMITypeLib)typeLib, asmBldr, rcwName);
                                importer.AddRCW((UCOMITypeLib)typeLib, asmBldr);
                                return asmBldr;
                            }
                            else {
                                Debug.WriteLineIf(AxWrapperGen.AxWrapper.Enabled, "\t\tFound COM Reference at " + assem);
                                return importer.GetCopiedAssembly(assem, false, false);
                            }
                        }
                    }
                    catch (Exception) {
                        return null;
                    }
                }
                finally {
                    Marshal.ReleaseComObject(typeLib);
                }
            }
        }
        
        /// <include file='doc\AxImporter.uex' path='docs/doc[@for="AxImporter.Options"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Various options to be set before calling AxImporter to generate wrappers
        ///       for an ActiveX control.
        ///    </para>
        /// </devdoc>
        public sealed class Options {
            /// The path-included filename of type library containing the definition of the ActiveX control.
            ///
            /// <include file='doc\AxImporter.uex' path='docs/doc[@for="Options.outputName"]/*' />
            public string               outputName = null;
            
            /// The output directory for all the generated assemblies.
            ///
            /// <include file='doc\AxImporter.uex' path='docs/doc[@for="Options.outputDirectory"]/*' />
            public string               outputDirectory = null;

            /// The public key used to sign the generated assemblies.
            ///
            /// <include file='doc\AxImporter.uex' path='docs/doc[@for="Options.publicKey"]/*' />
            public byte[]               publicKey = null;
            
            /// The strong name used for the generated assemblies.
            ///
            /// <include file='doc\AxImporter.uex' path='docs/doc[@for="Options.keyPair"]/*' />
            public StrongNameKeyPair    keyPair = null;
            
            /// The file containing the strong name key for the generated assemblies.
            ///
            /// <include file='doc\AxImporter.uex' path='docs/doc[@for="Options.keyFile"]/*' />
            public string               keyFile = null;
            
            /// The file containing the strong name key container for the generated assemblies.
            ///
            /// <include file='doc\AxImporter.uex' path='docs/doc[@for="Options.keyContainer"]/*' />
            public string               keyContainer = null;
            
            /// Flag that controls whether we are to generate sources for the ActiveX control wrapper.
            ///
            /// <include file='doc\AxImporter.uex' path='docs/doc[@for="Options.genSources"]/*' />
            public bool                 genSources = false;
            
            /// Flag that controls whether we should show the logo.
            ///
            /// <include file='doc\AxImporter.uex' path='docs/doc[@for="Options.noLogo"]/*' />
            public bool                 noLogo = false;
            
            /// Flag that controls the output generated.
            ///
            /// <include file='doc\AxImporter.uex' path='docs/doc[@for="Options.silentMode"]/*' />
            public bool                 silentMode = false;
            
            /// Flag that controls the output generated. 
            ///
            /// <include file='doc\AxImporter.uex' path='docs/doc[@for="Options.verboseMode"]/*' />
            public bool                 verboseMode = false;
            
            /// The flag that controls when we sign the generated assemblies.
            ///
            /// <include file='doc\AxImporter.uex' path='docs/doc[@for="Options.delaySign"]/*' />
            public bool                 delaySign = false;
            
            /// The flag that controls whether we try to overwrite existing generated assemblies.
            ///
            /// <include file='doc\AxImporter.uex' path='docs/doc[@for="Options.overwriteRCW"]/*' />
            public bool                 overwriteRCW = false;
            
            /// The object that allows us to resolve types and references needed to generate assemblies.
            ///
            /// <include file='doc\AxImporter.uex' path='docs/doc[@for="Options.references"]/*' />
            public IReferenceResolver   references = null;
        }

        /// <include file='doc\AxImporter.uex' path='docs/doc[@for="AxImporter.IReferenceResolver"]/*' />
        /// <devdoc>
        ///     The Reference Resolver service will try to look through the references it can obtain,
        ///     for a reference that matches the given criterion. For now, the only kind of references
        ///     it can look for are COM (RCW) references and ActiveX wrapper references.
        /// </devdoc>
        public interface IReferenceResolver {
            /// <include file='doc\AxImporter.uex' path='docs/doc[@for="IReferenceResolver.ResolveManagedReference"]/*' />
            string ResolveManagedReference(string assemName);
            
            /// <include file='doc\AxImporter.uex' path='docs/doc[@for="IReferenceResolver.ResolveComReference"]/*' />
            string ResolveComReference(UCOMITypeLib typeLib);
            
            /// <include file='doc\AxImporter.uex' path='docs/doc[@for="IReferenceResolver.ResolveComReference1"]/*' />
            string ResolveComReference(AssemblyName name);
            
            /// <include file='doc\AxImporter.uex' path='docs/doc[@for="IReferenceResolver.ResolveActiveXReference"]/*' />
            string ResolveActiveXReference(UCOMITypeLib typeLib);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\componenttray.cs ===
//------------------------------------------------------------------------------
// <copyright file="ComponentTray.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms.Design {
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.Collections;    
    using System.ComponentModel.Design;
    using System.ComponentModel.Design.Serialization;
    using Microsoft.Win32;
    using System.Drawing;
    using System.Design;
    using System.Drawing.Design;
    using System.Windows.Forms;
    using System.Windows.Forms.ComponentModel;

    /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray"]/*' />
    /// <devdoc>
    ///    <para> 
    ///       Provides the component tray UI for the form designer.</para>
    /// </devdoc>
    [
    System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode),
    ToolboxItem(false),
    DesignTimeVisible(false),
    ProvideProperty("Location", typeof(IComponent)),
    ]
    public class ComponentTray : ScrollableControl, IExtenderProvider, ISelectionUIHandler, IOleDragClient {

        /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.InvalidPoint"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        private static readonly Point InvalidPoint = new Point(int.MinValue, int.MinValue);

        private  IServiceProvider   serviceProvider;    // Where services come from.

        private Point                   whiteSpace = Point.Empty;         // space to leave between components.
        private Size                    grabHandle = Size.Empty; // Size of the grab handles.

        private ArrayList               controls;           // List of items in the tray in the order of their layout.

        private SelectionUIHandler      dragHandler;        // the thing responsible for handling mouse drags
        private ISelectionUIService     selectionUISvc;     // selectiuon UI; we use this a lot
        private IToolboxService         toolboxService;     // cached for drag/drop
        
        /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.oleDragDropHandler"]/*' />
        /// <devdoc>
        ///    <para>Provides drag and drop functionality through OLE.</para>
        /// </devdoc>
        internal OleDragDropHandler     oleDragDropHandler; // handler class for ole drag drop operations.
        private  bool                   addingDraggedComponent = false;
        private  Point                  droppedLocation = InvalidPoint;
    
        private IDesigner               mainDesigner;       // the designer that is associated with this tray
        private IEventHandlerService    eventHandlerService = null; // Event Handler service to handle keyboard and focus.
        private bool                    queriedTabOrder;
        private MenuCommand             tabOrderCommand;
        private ICollection             selectedObjects;

        // Services that we use on a high enough frequency to merit caching.
        //
        private IMenuCommandService     menuCommandService;
        private CommandSet              privateCommandSet;
        private InheritanceUI           inheritanceUI;

        private Point       mouseDragStart = InvalidPoint;       // the starting location of a drag
        private Point       mouseDragEnd = InvalidPoint;         // the ending location of a drag
        private Rectangle   mouseDragWorkspace = Rectangle.Empty;   // a temp work rectangle we cache for perf
        private ToolboxItem mouseDragTool;        // the tool that's being dragged; only for drag/drop
        private Point       mouseDropLocation = InvalidPoint;    // where the tool was dropped
        private bool        showLargeIcons = false;// Show Large icons or not.
        private bool        autoArrange = false;   // allows for auto arranging icons.
        private Point       autoScrollPosBeforeDragging = Point.Empty;//Used to return the correct scroll pos. after a drag

        // Component Tray Context menu items...
        /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.menucmdArrangeIcons"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        private MenuCommand menucmdArrangeIcons = null;
        /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.menucmdLineupIcons"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        private MenuCommand menucmdLineupIcons = null;
        /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.menucmdLargeIcons"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        private MenuCommand menucmdLargeIcons = null;

        private bool fResetAmbient = false;

        /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.ComponentTray"]/*' />
        /// <devdoc>
        ///      Creates a new component tray.  The component tray
        ///      will monitor component additions and removals and create
        ///      appropriate UI objects in its space.
        /// </devdoc>
        public ComponentTray(IDesigner mainDesigner, IServiceProvider serviceProvider) {
            this.AutoScroll = true;
            this.mainDesigner = mainDesigner;
            this.serviceProvider = serviceProvider;
            this.AllowDrop = true;
            Text = "ComponentTray"; // makes debugging easier
            SetStyle(ControlStyles.ResizeRedraw | ControlStyles.DoubleBuffer, true);

            controls = new ArrayList();
        
            IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
            IExtenderProviderService es = (IExtenderProviderService)GetService(typeof(IExtenderProviderService));
            Debug.Assert(es != null, "Component tray wants an extender provider service, but there isn't one.");
            if (es != null) {
                es.AddExtenderProvider(this);
            }
            
            if (GetService(typeof(IEventHandlerService)) == null) {
                if (host != null) {
                    eventHandlerService = new EventHandlerService(this);
                    host.AddService(typeof(IEventHandlerService), eventHandlerService);
                }
            }

            IMenuCommandService mcs = MenuService;
            if (mcs != null) {
                Debug.Assert(menucmdArrangeIcons == null, "Non-Null Menu Command for ArrangeIcons");
                Debug.Assert(menucmdLineupIcons  == null, "Non-Null Menu Command for LineupIcons");
                Debug.Assert(menucmdLargeIcons   == null, "Non-Null Menu Command for LargeIcons");

                menucmdArrangeIcons = new MenuCommand(new EventHandler(OnMenuArrangeIcons), StandardCommands.ArrangeIcons);
                menucmdLineupIcons = new MenuCommand(new EventHandler(OnMenuLineupIcons), StandardCommands.LineupIcons);
                menucmdLargeIcons = new MenuCommand(new EventHandler(OnMenuShowLargeIcons), StandardCommands.ShowLargeIcons);

                menucmdArrangeIcons.Checked = AutoArrange;
                menucmdLargeIcons.Checked   = ShowLargeIcons;
                mcs.AddCommand(menucmdArrangeIcons);
                mcs.AddCommand(menucmdLineupIcons);
                mcs.AddCommand(menucmdLargeIcons);
            }

            IComponentChangeService componentChangeService = (IComponentChangeService)GetService(typeof(IComponentChangeService));

            if (componentChangeService != null) {
                componentChangeService.ComponentRemoved += new ComponentEventHandler(this.OnComponentRemoved);
            }

            IUIService uiService = (IUIService)GetService(typeof(IUIService));
            if (uiService != null) {
                BackColor = (Color)uiService.Styles["HighlightColor"];
                Font = (Font)uiService.Styles["DialogFont"];
            }
            
            ISelectionService selSvc = (ISelectionService)GetService(typeof(ISelectionService));
            if (selSvc != null) {
                selSvc.SelectionChanged += new EventHandler(OnSelectionChanged);
            }

            // Listen to the SystemEvents so that we can resync selection based on display settings etc.
            SystemEvents.DisplaySettingsChanged += new EventHandler(this.OnSystemSettingChanged);
            SystemEvents.InstalledFontsChanged += new EventHandler(this.OnSystemSettingChanged);
            SystemEvents.UserPreferenceChanged += new UserPreferenceChangedEventHandler(this.OnUserPreferenceChanged);
        
            // Listen to refresh events from TypeDescriptor.  If a component gets refreshed, we re-query
            // and will hide/show the view based on the DesignerView attribute.
            //
            TypeDescriptor.Refreshed += new RefreshEventHandler(OnComponentRefresh);
        }

        /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.AutoArrange"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool AutoArrange {
            get {
                return autoArrange;
            }

            set {
                if (autoArrange != value) {
                    autoArrange = value;
                    menucmdArrangeIcons.Checked = value;

                    if (autoArrange) {
                        DoAutoArrange(true);
                    }
                }
            }
        }

        /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.ComponentCount"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the number of compnents contained within this tray.
        ///    </para>
        /// </devdoc>
        public int ComponentCount {
            get {
                return Controls.Count;
            }
        }

        internal virtual SelectionUIHandler DragHandler {
            get {
                if (dragHandler == null) {
                    dragHandler = new TraySelectionUIHandler(this);
                }
                return dragHandler;
            }
        }
        
        private InheritanceUI InheritanceUI {
            get {
                if (inheritanceUI == null) {
                    inheritanceUI = new InheritanceUI();
                }
                return inheritanceUI;
            }
        }
        
        /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.MenuService"]/*' />
        /// <devdoc>
        ///     Retrieves the menu editor service, which we cache for speed.
        /// </devdoc>
        private IMenuCommandService MenuService {
            get {
                if (menuCommandService == null) {
                    menuCommandService = (IMenuCommandService)GetService(typeof(IMenuCommandService));
                }
                return menuCommandService;
            }
        }

        /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.ShowLargeIcons"]/*' />
        /// <devdoc>
        ///     Determines whether the tray will show large icon view or not.
        /// </devdoc>
        public bool ShowLargeIcons {
            get {
                return showLargeIcons;
            }

            set {
                if (showLargeIcons != value) {
                    showLargeIcons = value;
                    menucmdLargeIcons.Checked = ShowLargeIcons;

                    ResetTrayControls();
                    Invalidate(true);
                }
            }
        }

        /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.TabOrderActive"]/*' />
        /// <devdoc>
        ///      Determines if the tab order UI is active.  When tab order is active, the tray is locked in
        ///      a "read only" mode.
        /// </devdoc>
        private bool TabOrderActive {
            get {
                if (!queriedTabOrder) {
                    queriedTabOrder = true;
                    IMenuCommandService mcs = MenuService;
                    tabOrderCommand = mcs.FindCommand(MenuCommands.TabOrder);
                }

                if (tabOrderCommand != null) {
                    return tabOrderCommand.Checked;
                }

                return false;
            }
        }

        /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.IsWindowVisible"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Indicates whether the window is visible.</para>
        /// </devdoc>
        internal bool IsWindowVisible {
            get {
                if (this.IsHandleCreated) {
                    return NativeMethods.IsWindowVisible(this.Handle);
                }
                return false;
            }
        }
        
        internal Size ParentGridSize {
            get {
                ParentControlDesigner designer = mainDesigner as ParentControlDesigner;
                if (designer != null) {
                    return designer.ParentGridSize;
                }

                return new Size(8, 8);
            }
        }
        /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.AddComponent"]/*' />
        /// <devdoc>
        ///    <para>Adds a component to the tray.</para>
        /// </devdoc>
        public virtual void AddComponent(IComponent component) {
            IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
        
            // Ignore components that cannot be added to the tray
            if (!CanDisplayComponent(component)) {
                return;
            }
        
            // And designate us as the selection UI handler for the
            // control.
            //
            if (selectionUISvc == null) {
                selectionUISvc = (ISelectionUIService)GetService(typeof(ISelectionUIService));
            
                // If there is no selection service, then we will provide our own.
                //
                if (selectionUISvc == null) {
                    selectionUISvc = new SelectionUIService(host);
                    host.AddService(typeof(ISelectionUIService), selectionUISvc);
                    privateCommandSet = new CommandSet(mainDesigner.Component.Site);
                }
                
                grabHandle = selectionUISvc.GetAdornmentDimensions(AdornmentType.GrabHandle);
            }

            // Create a new instance of a tray control.
            //
            TrayControl trayctl = new TrayControl(this, component);

            SuspendLayout();
            try {
                // Add it to us.
                //
                Controls.Add(trayctl);
                controls.Add(trayctl);

                if (host != null && !host.Loading) {
                    PositionControl(trayctl);

                    if (addingDraggedComponent) {
                        droppedLocation = trayctl.Location;
                    }
                }

                if (selectionUISvc != null) {
                    selectionUISvc.AssignSelectionUIHandler(component, this);
                }
                
                InheritanceAttribute attr = trayctl.InheritanceAttribute;
                if (attr.InheritanceLevel != InheritanceLevel.NotInherited) {
                    InheritanceUI iui = InheritanceUI;
                    if (iui != null) {
                        iui.AddInheritedControl(trayctl, attr.InheritanceLevel);
                    }
                }
            }
            finally {
                ResumeLayout();
            }

            if (host != null && !host.Loading) {
                ScrollControlIntoView(trayctl);
            }
        }

        /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.IExtenderProvider.CanExtend"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>
        /// Gets whether or not this extender provider can extend the given
        /// component. We only extend components that have been added
        /// to our UI.
        /// </para>
        /// </devdoc>
        bool IExtenderProvider.CanExtend(object component) {
            return (component is IComponent) && (TrayControl.FromComponent((IComponent)component) != null);
        }

        /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="CanCreateComponentFromTool"]/*' />
        protected virtual bool CanCreateComponentFromTool(ToolboxItem tool) {
            IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
            Debug.Assert(host != null, "Service object could not provide us with a designer host.");

            // Disallow controls to be added to the component tray.
            Type compType = host.GetType(tool.TypeName);

            if (compType == null)
                return true;

            if (compType.IsSubclassOf(typeof(Control)))
                return false;

            return true;
        }
        
        /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.CanDisplayComponent"]/*' />
        /// <devdoc>
        ///     This method determines if a UI representation for the given component should be provided.
        ///     If it returns true, then the component will get a glyph in the tray area.  If it returns
        ///     false, then the component will not actually be added to the tray.  The default 
        ///     implementation looks for DesignTimeVisibleAttribute.Yes on the component's class.
        /// </devdoc>
        protected virtual bool CanDisplayComponent(IComponent component) {
            return TypeDescriptor.GetAttributes(component).Contains(DesignTimeVisibleAttribute.Yes);
        }

        /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.CreateComponentFromTool"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void CreateComponentFromTool(ToolboxItem tool) {
            if (!CanCreateComponentFromTool(tool)) {
                return;
            }

            // We invoke the drag drop handler for this.  This implementation is shared between all designers that
            // create components.
            //
            GetOleDragHandler().CreateTool(tool, 0, 0, 0, 0, false, false);
        }

        /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.DisplayError"]/*' />
        /// <devdoc>
        ///      Displays the given exception to the user.
        /// </devdoc>
        protected void DisplayError(Exception e) {
            IUIService uis = (IUIService)GetService(typeof(IUIService));
            if (uis != null) {
                uis.ShowError(e);
            }
            else {
                string message = e.Message;
                if (message == null || message.Length == 0) {
                    message = e.ToString();
                }
                MessageBox.Show(message, null, MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
            }
        }
        
        //
        /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.Dispose"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Disposes of the resources (other than memory) used by the component tray object.
        ///    </para>
        /// </devdoc>
        protected override void Dispose(bool disposing) {
            if (disposing) {
                IExtenderProviderService es = (IExtenderProviderService)GetService(typeof(IExtenderProviderService));
                if (CompModSwitches.CommonDesignerServices.Enabled) Debug.Assert(es != null, "IExtenderProviderService not found");
                if (es != null) {
                    es.RemoveExtenderProvider(this);
                }

                IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
                if (eventHandlerService != null) {
                    if (host != null) {
                        host.RemoveService(typeof(IEventHandlerService));
                        eventHandlerService = null;
                    }
                }

                TypeDescriptor.Refreshed -= new RefreshEventHandler(OnComponentRefresh);
                SystemEvents.DisplaySettingsChanged -= new EventHandler(this.OnSystemSettingChanged);
                SystemEvents.InstalledFontsChanged -= new EventHandler(this.OnSystemSettingChanged);
                SystemEvents.UserPreferenceChanged -= new UserPreferenceChangedEventHandler(this.OnUserPreferenceChanged);

                IMenuCommandService mcs = MenuService;
                if (mcs != null) {
                    Debug.Assert(menucmdArrangeIcons != null, "Null Menu Command for ArrangeIcons");
                    Debug.Assert(menucmdLineupIcons  != null, "Null Menu Command for LineupIcons");
                    Debug.Assert(menucmdLargeIcons   != null, "Null Menu Command for LargeIcons");
                    mcs.RemoveCommand(menucmdArrangeIcons);
                    mcs.RemoveCommand(menucmdLineupIcons);
                    mcs.RemoveCommand(menucmdLargeIcons);
                }

                if (privateCommandSet != null) {
                    privateCommandSet.Dispose();

                    // If we created a private command set, we also added a selection ui service to the host
                    if (host != null) {
                        host.RemoveService(typeof(ISelectionUIService));
                    }

                }            
                selectionUISvc = null;

                if (inheritanceUI != null) {
                    inheritanceUI.Dispose();
                    inheritanceUI = null;
                }

                serviceProvider = null;
                controls.Clear();
                controls = null;
            }
            base.Dispose(disposing);
        }

        private void DoAutoArrange(bool dirtyDesigner) {
            if (controls == null || controls.Count <= 0) {
                return;
            }

            controls.Sort(new AutoArrangeComparer());

            SuspendLayout();

            //Reset the autoscroll position before auto arranging.
            //This way, when OnLayout gets fired after this, we won't
            //have to move every component again.  Note that sync'ing
            //the selection will automatically select & scroll into view
            //the right components
            this.AutoScrollPosition = new Point(0,0);

            try {
                Control prevCtl = null;
                foreach(Control ctl in controls) {
                    if (!ctl.Visible)
                        continue;

                    // If we're auto arranging, always move the control.  If not,
                    // move the control only if it was never given a position.  This
                    // auto arranges it until the user messes with it, or until its
                    // position is saved into the resx.
                    //
                    if (autoArrange) {
                        PositionInNextAutoSlot(ctl as TrayControl, prevCtl, dirtyDesigner);
                    }
                    else if (!((TrayControl)ctl).Positioned) {
                        PositionInNextAutoSlot(ctl as TrayControl, prevCtl, false);
                    }
                    prevCtl = ctl;
                }

                if (selectionUISvc != null) {
                    selectionUISvc.SyncSelection();
                }
            }
            finally {
                ResumeLayout();
            }
        }

        private void DoLineupIcons() {
            if (autoArrange)
                return;

            bool oldValue = autoArrange;
            autoArrange = true;
            
            try {
                DoAutoArrange(true);
            }
            finally {
                autoArrange = oldValue;
            }
        }

        /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.DrawRubber"]/*' />
        /// <devdoc>
        ///      Draws a rubber band at the given coordinates.  The coordinates
        ///      can be transposed.
        /// </devdoc>
        private void DrawRubber(Point start, Point end) {
            mouseDragWorkspace.X = Math.Min(start.X, end.X);
            mouseDragWorkspace.Y = Math.Min(start.Y, end.Y);
            mouseDragWorkspace.Width = Math.Abs(end.X - start.X);
            mouseDragWorkspace.Height = Math.Abs(end.Y - start.Y);

            mouseDragWorkspace = RectangleToScreen(mouseDragWorkspace);

            ControlPaint.DrawReversibleFrame(mouseDragWorkspace, BackColor, FrameStyle.Dashed);
        }

        internal void FocusDesigner() {
            IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
            if (host != null) {
                IDesigner d = host.GetDesigner(host.RootComponent);
                if (d is IRootDesigner) {
                    IRootDesigner rd = (IRootDesigner)d;
                    ViewTechnology[] techs = rd.SupportedTechnologies;
                    foreach(ViewTechnology t in techs) {
                        if (t == ViewTechnology.WindowsForms) {
                            ((Control)rd.GetView(t)).Focus();
                            break;
                        }
                    }
                }
            }    
        }

        /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.GetComponentsInRect"]/*' />
        /// <devdoc>
        ///     Finds the array of components within the given rectangle.  This uses the rectangle to
        ///     find controls within our frame, and then uses those controls to find the actual
        ///     components.  It returns an object array so the output can be directly fed into
        ///     the selection service.
        /// </devdoc>
        private object[] GetComponentsInRect(Rectangle rect) {
            ArrayList list = new ArrayList();

            int controlCount = Controls.Count;

            for (int i = 0; i < controlCount; i++) {
                Control child = Controls[i];
                Rectangle bounds = child.Bounds;

                if (child is TrayControl && bounds.IntersectsWith(rect)) {
                    list.Add(((TrayControl)child).Component);
                }
            }

            return list.ToArray();
        }

        /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.GetDragDimensions"]/*' />
        /// <devdoc>
        ///     Returns the drag dimensions needed to move the currently selected
        ///     component one way or the other.
        /// </devdoc>
        internal Size GetDragDimensions() {

            // This is a really gross approximation of the correct diemensions.
            //
            if (AutoArrange) {
                ISelectionService ss = (ISelectionService)GetService(typeof(ISelectionService));
                IComponent comp = null;

                if (ss != null) {
                    comp = (IComponent)ss.PrimarySelection;
                }

                Control control = null;

                if (comp != null) {
                    control = ((IOleDragClient)this).GetControlForComponent(comp);
                }

                if (control == null && controls.Count > 0) {
                    control = (Control)controls[0];
                }

                if (control != null) {
                    Size s = control.Size;
                    s.Width += 2 * whiteSpace.X;
                    s.Height += 2 * whiteSpace.Y;
                    return s;
                }
            }

            return new Size(10, 10);
        }

        /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.GetNextComponent"]/*' />
        /// <devdoc>
        ///     Similar to GetNextControl on Control, this method returns the next
        ///     component in the tray, given a starting component.  It will return
        ///     null if the end (or beginning, if forward is false) of the list
        ///     is encountered.
        /// </devdoc>
        internal IComponent GetNextComponent(IComponent component, bool forward) {

            for (int i = 0; i < controls.Count; i++) {
                TrayControl control = (TrayControl)controls[i];
                if (control.Component == component) {

                    int targetIndex = (forward ? i + 1 : i - 1);

                    if (targetIndex >= 0 && targetIndex < controls.Count) {
                        return((TrayControl)controls[targetIndex]).Component;
                    }

                    // Reached the end of the road.
                    return null;
                }
            }

            // If we got here then the component isn't in our list.  Prime the
            // caller with either the first or the last.

            if (controls.Count > 0) {
                int targetIndex = (forward ? 0 : controls.Count -1);
                return((TrayControl)controls[targetIndex]).Component;
            }

            return null;
        }

        internal virtual OleDragDropHandler GetOleDragHandler() {
            if (oleDragDropHandler == null) {
                oleDragDropHandler = new TrayOleDragDropHandler(this.DragHandler, this.serviceProvider, this);
            }
            return oleDragDropHandler;
        }

        /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.GetLocation"]/*' />
        /// <devdoc>
        ///     Accessor method for the location extender property.  We offer this extender
        ///     to all non-visual components.
        /// </devdoc>
        [
            Category("Layout"),
            Localizable(false),
            Browsable(false),
            SRDescription("ControlLocationDescr"),
            DesignOnly(true),
        ]
        public Point GetLocation(IComponent receiver) {
            Control c = TrayControl.FromComponent(receiver);

            if (c == null) {
                Debug.Fail("Anything we're extending should have a component view.");
                return new Point();
            }

            Point loc = c.Location;
            Point autoScrollLoc = this.AutoScrollPosition;

            return new Point(loc.X - autoScrollLoc.X, loc.Y - autoScrollLoc.Y);
        }

        /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.GetService"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the requsted service type.
        ///    </para>
        /// </devdoc>
        protected override object GetService(Type serviceType) {
            object service = null;

            Debug.Assert(serviceProvider != null, "Trying to access services too late or too early.");
            if (serviceProvider != null) {
                service = serviceProvider.GetService(serviceType);
            }

            return service;
        }

        internal bool IsTrayComponent(IComponent comp) {

            if (TrayControl.FromComponent(comp) == null) {
                return false;
            }

            foreach (TrayControl tc in this.Controls) {
                if (tc.Component == comp) {
                    return true;
                }
            }

            return false;
        }

        /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.OnComponentRefresh"]/*' />
        /// <devdoc>
        ///     Called when a component's metadata is invalidated.  We re-query here and will show/hide
        ///     the control's tray control based on the new metadata.
        /// </devdoc>
        private void OnComponentRefresh(RefreshEventArgs e) {
            IComponent component = e.ComponentChanged as IComponent;
            
            if (component != null) {
                TrayControl control = TrayControl.FromComponent(component);
                
                if (control != null) {
                    bool shouldDisplay = CanDisplayComponent(component);
                    if (shouldDisplay != control.Visible || !shouldDisplay) {
                        control.Visible = shouldDisplay;
                        Rectangle bounds = control.Bounds;
                        bounds.Inflate(grabHandle);
                        bounds.Inflate(grabHandle);
                        Invalidate(bounds);
                        PerformLayout();
                    }
                }
            }
        }

        /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.OnComponentRemoved"]/*' />
        /// <devdoc>
        ///      Called when a component is removed from the container.
        /// </devdoc>
        private void OnComponentRemoved(object sender, ComponentEventArgs cevent) {
            RemoveComponent(cevent.Component);
        }

        /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.OnComponentTrayPaste"]/*' />
        /// <devdoc>
        ///      Called from CommandSet's OnMenuPaste method.  This will allow us to properly adjust the location
        ///      of the components in the tray after we've incorreclty set them by deserializing the design time
        ///      properties (and hence called SetValue(c, myBadLocation) on the location property).
        /// </devdoc>
        internal void UpdatePastePositions(ArrayList components) {
            foreach (TrayControl c in components) {
                if (!CanDisplayComponent(c.Component)) {
                    return;
                }

                Control prevCtl = null;
                if (controls.Count > 1) {
                    prevCtl = (Control)controls[controls.Count-1];
                }
                PositionInNextAutoSlot(c, prevCtl, true);
                c.BringToFront();
            }
        }

        /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.OnContextMenu"]/*' />
        /// <devdoc>
        ///     Called when we are to display our context menu for this component.
        /// </devdoc>
        private void OnContextMenu(int x, int y, bool useSelection) {

            if (!TabOrderActive) {
                Capture = false;

                IMenuCommandService mcs = MenuService;
                if (mcs != null) {
                    Capture = false;
                    Cursor.Clip = Rectangle.Empty;

                    ISelectionService s = (ISelectionService)GetService(typeof(ISelectionService));



                    if (useSelection && s != null && !(1 == s.SelectionCount && s.PrimarySelection == mainDesigner.Component)) {
                        mcs.ShowContextMenu(MenuCommands.TraySelectionMenu, x, y);
                    }
                    else {
                        mcs.ShowContextMenu(MenuCommands.ComponentTrayMenu, x, y);
                    }
                }
            }
        }

        /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.OnDoubleClick"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnDoubleClick(EventArgs e) {
            base.OnDoubleClick(e);

            if (!TabOrderActive) {
                OnLostCapture();
                IEventBindingService eps = (IEventBindingService)GetService(typeof(IEventBindingService));
                if (CompModSwitches.CommonDesignerServices.Enabled) Debug.Assert(eps != null, "IEventBindingService not found");
                if (eps != null) {
                    eps.ShowCode();
                }
            }
        }
        
        /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.OnGiveFeedback"]/*' />
        /// <devdoc>
        ///     Inheriting classes should override this method to handle this event.
        ///     Call base.onGiveFeedback to send this event to any registered event listeners.
        /// </devdoc>
        protected override void OnGiveFeedback(GiveFeedbackEventArgs gfevent) {
            base.OnGiveFeedback(gfevent);
            GetOleDragHandler().DoOleGiveFeedback(gfevent);
        }

        /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.OnDragDrop"]/*' />
        /// <devdoc>
        ///      Called in response to a drag drop for OLE drag and drop.  Here we
        ///      drop a toolbox component on our parent control.
        /// </devdoc>
        protected override void OnDragDrop(DragEventArgs de) {
            // This will be used once during PositionComponent to place the component
            // at the drop point.  It is automatically set to null afterwards, so further
            // components appear after the first one dropped.
            //
            mouseDropLocation = PointToClient(new Point(de.X, de.Y));
            autoScrollPosBeforeDragging = this.AutoScrollPosition;//save the scroll position
            
            if (mouseDragTool != null) {
                ToolboxItem tool = mouseDragTool;
                mouseDragTool = null;

                if (CompModSwitches.CommonDesignerServices.Enabled) Debug.Assert(GetService(typeof(IDesignerHost)) != null, "IDesignerHost not found");

                try {
                    IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
                    IDesigner designer = host.GetDesigner(host.RootComponent);

                    if (designer is IToolboxUser) {
                        ((IToolboxUser) designer).ToolPicked(tool);
                    }
                    else {
                        CreateComponentFromTool(tool);
                    }
                }
                catch (Exception e) {
                    DisplayError(e);
                }
                de.Effect = DragDropEffects.Copy;

            }
            else {
                GetOleDragHandler().DoOleDragDrop(de);
            }

            mouseDropLocation = InvalidPoint;
        }

        /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.OnDragEnter"]/*' />
        /// <devdoc>
        ///      Called in response to a drag enter for OLE drag and drop.
        /// </devdoc>
        protected override void OnDragEnter(DragEventArgs de) {
            if (!TabOrderActive) {
                if (toolboxService == null) {
                    toolboxService = (IToolboxService)GetService(typeof(IToolboxService));
                }

                if (toolboxService != null) {
                    mouseDragTool = toolboxService.DeserializeToolboxItem(de.Data, (IDesignerHost)GetService(typeof(IDesignerHost)));
                }

                if (mouseDragTool != null) {
                    Debug.Assert(0 != (int)(de.AllowedEffect & (DragDropEffects.Move | DragDropEffects.Copy)), "DragDropEffect.Move | .Copy isn't allowed?");
                    if ((int)(de.AllowedEffect & DragDropEffects.Move) != 0) {
                        de.Effect = DragDropEffects.Move;
                    }
                    else {
                        de.Effect = DragDropEffects.Copy;
                    }
                }
                else {
                    GetOleDragHandler().DoOleDragEnter(de);
                }
            }
        }

        /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.OnDragLeave"]/*' />
        /// <devdoc>
        ///     Called when a drag-drop operation leaves the control designer view
        ///
        /// </devdoc>
        protected override void OnDragLeave(EventArgs e) {
            mouseDragTool = null;
            GetOleDragHandler().DoOleDragLeave();
        }

        /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.OnDragOver"]/*' />
        /// <devdoc>
        ///     Called when a drag drop object is dragged over the control designer view
        /// </devdoc>
        protected override void OnDragOver(DragEventArgs de) {
            if (mouseDragTool != null) {
                Debug.Assert(0!=(int)(de.AllowedEffect & DragDropEffects.Copy), "DragDropEffect.Move isn't allowed?");
                de.Effect = DragDropEffects.Copy;
            }
            else {
                GetOleDragHandler().DoOleDragOver(de);
            }
        }

        /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.OnLayout"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    Forces the layout of any docked or anchored child controls.
        /// </devdoc>
        protected override void OnLayout(LayoutEventArgs levent) {
            DoAutoArrange(false);
            // make sure selection service redraws
            Invalidate(true);
            base.OnLayout(levent);
        }
        
        /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.OnLostCapture"]/*' />
        /// <devdoc>
        ///      This is called when we lose capture.  Here we get rid of any
        ///      rubber band we were drawing.  You should put any cleanup
        ///      code in here.
        /// </devdoc>
        protected virtual void OnLostCapture() {
            if (mouseDragStart != InvalidPoint) {
                Cursor.Clip = Rectangle.Empty;
                if (mouseDragEnd != InvalidPoint) {
                    DrawRubber(mouseDragStart, mouseDragEnd);
                    mouseDragEnd = InvalidPoint;
                }
                mouseDragStart = InvalidPoint;
            }
        }

        private void OnMenuArrangeIcons(object sender, EventArgs e) {
            IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
            DesignerTransaction t = null;
            
            try {
                t = host.CreateTransaction(SR.GetString(SR.TrayAutoArrange));
                
                PropertyDescriptor trayAAProp = TypeDescriptor.GetProperties(mainDesigner.Component)["TrayAutoArrange"];
                if (trayAAProp != null) {
                    trayAAProp.SetValue(mainDesigner.Component, !AutoArrange);
                }
            }
            finally {
                if (t != null)
                    t.Commit();
            }
        }

        private void OnMenuShowLargeIcons(object sender, EventArgs e) {
            IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
            DesignerTransaction t = null;
            
            try {
                t = host.CreateTransaction(SR.GetString(SR.TrayShowLargeIcons));
                PropertyDescriptor trayIconProp = TypeDescriptor.GetProperties(mainDesigner.Component)["TrayLargeIcon"];
                if (trayIconProp != null) {
                    trayIconProp.SetValue(mainDesigner.Component, !ShowLargeIcons);
                }
            }
            finally {
                if (t != null)
                    t.Commit();
            }
        }

        private void OnMenuLineupIcons(object sender, EventArgs e) {
            IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
            DesignerTransaction t = null;
            try {
                t = host.CreateTransaction(SR.GetString(SR.TrayLineUpIcons));
                DoLineupIcons();
            }
            finally {
                if (t != null)
                    t.Commit();
            }
        }

        /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.OnMouseDown"]/*' />
        /// <devdoc>
        ///     Inheriting classes should override this method to handle this event.
        ///     Call base.onMouseDown to send this event to any registered event listeners.
        /// </devdoc>
        protected override void OnMouseDown(MouseEventArgs e) {
            
            base.OnMouseDown(e);

            if (!TabOrderActive) {
                if (toolboxService == null) {
                    toolboxService = (IToolboxService)GetService(typeof(IToolboxService));
                }


                FocusDesigner();

                if (e.Button == MouseButtons.Left && toolboxService != null) {
                    ToolboxItem tool = toolboxService.GetSelectedToolboxItem((IDesignerHost)GetService(typeof(IDesignerHost)));
                    if (tool != null) {
                        // mouseDropLocation is checked in PositionControl, which should get called as a result of adding a new
                        // component.  This allows us to set the position without flickering, while still providing support for auto
                        // layout if the control was double clicked or added through extensibility.
                        //
                        mouseDropLocation = new Point(e.X, e.Y);
                        try {
                            CreateComponentFromTool(tool);
                            toolboxService.SelectedToolboxItemUsed();
                        }
                        catch (Exception ex) {
                            DisplayError(ex);
                        }
                        mouseDropLocation = InvalidPoint;
                        return;
                    }
                }

                // If it is the left button, start a rubber band drag to laso
                // controls.
                //
                if (e.Button == MouseButtons.Left) {
                    mouseDragStart = new Point(e.X, e.Y);
                    Capture = true;
                    Cursor.Clip = RectangleToScreen(ClientRectangle);
                    
                }
                else {
                    try {
                        ISelectionService ss = (ISelectionService)GetService(typeof(ISelectionService));
                        if (CompModSwitches.CommonDesignerServices.Enabled) Debug.Assert(ss != null, "ISelectionService not found");
                        if (ss != null) {
                            ss.SetSelectedComponents(new object[] {mainDesigner.Component});
                        }
                    }
                    catch (Exception) {
                        // nothing we can really do here; just eat it.
                    }
                }
            }
        }

        /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.OnMouseMove"]/*' />
        /// <devdoc>
        ///     Inheriting classes should override this method to handle this event.
        ///     Call base.onMouseMove to send this event to any registered event listeners.
        /// </devdoc>
        protected override void OnMouseMove(MouseEventArgs e) {
            base.OnMouseMove(e);

            // If we are dragging, then draw our little rubber band.
            //
            if (mouseDragStart != InvalidPoint) {
                if (mouseDragEnd != InvalidPoint) {
                    DrawRubber(mouseDragStart, mouseDragEnd);
                }
                else {
                    mouseDragEnd = new Point(0, 0);
                }

                mouseDragEnd.X = e.X;
                mouseDragEnd.Y = e.Y;

                DrawRubber(mouseDragStart, mouseDragEnd);
            }
        }

        /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.OnMouseUp"]/*' />
        /// <devdoc>
        ///     Inheriting classes should override this method to handle this event.
        ///     Call base.onMouseUp to send this event to any registered event listeners.
        /// </devdoc>
        protected override void OnMouseUp(MouseEventArgs e) {
            
            if (mouseDragStart != InvalidPoint && e.Button == MouseButtons.Left) {
                object[] comps = null;

                Capture = false;
                Cursor.Clip = Rectangle.Empty;
                
                if (mouseDragEnd != InvalidPoint) {
                    DrawRubber(mouseDragStart, mouseDragEnd);

                    Rectangle rect = new Rectangle();
                    rect.X = Math.Min(mouseDragStart.X, e.X);
                    rect.Y = Math.Min(mouseDragStart.Y, e.Y);
                    rect.Width = Math.Abs(e.X - mouseDragStart.X);
                    rect.Height = Math.Abs(e.Y - mouseDragStart.Y);
                    comps = GetComponentsInRect(rect);
                    mouseDragEnd = InvalidPoint;
                }
                else {
                    comps = new object[0];
                }

                if (comps.Length == 0) {
                    comps = new object[] {mainDesigner.Component};
                }

                try {
                    ISelectionService ss = (ISelectionService)GetService(typeof(ISelectionService));
                    if (CompModSwitches.CommonDesignerServices.Enabled) Debug.Assert(ss != null, "ISelectionService not found");
                    if (ss != null) {
                        ss.SetSelectedComponents(comps);
                    }
                }
                catch (Exception) {
                    // nothing we can really do here; just eat it.
                }

                mouseDragStart = InvalidPoint;
            }


            base.OnMouseUp(e);
        }

        /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.OnPaint"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnPaint(PaintEventArgs pe) {
            if (fResetAmbient) {
                fResetAmbient = false;

                IUIService uiService = (IUIService)GetService(typeof(IUIService));
                if (uiService != null) {
                    BackColor = (Color)uiService.Styles["HighlightColor"];
                    Font = (Font)uiService.Styles["DialogFont"];
                }
            }

            base.OnPaint(pe);

            Graphics gr = pe.Graphics;
            
            // Now, if we have a selection, paint it
            //
            if (selectedObjects != null) {
                foreach(object o in selectedObjects) {
                    Control c = ((IOleDragClient)this).GetControlForComponent(o);
                    if (c != null && c.Visible) {
                        Rectangle innerRect = c.Bounds;
                        Rectangle outerRect = new Rectangle(
                                                            innerRect.X - grabHandle.Width,
                                                            innerRect.Y - grabHandle.Height,
                                                            innerRect.Width + 2 * grabHandle.Width,
                                                            innerRect.Height + 2 * grabHandle.Height);


                        Region oldClip = gr.Clip;
                        Brush brush = new SolidBrush(BackColor);
                        gr.ExcludeClip(innerRect);
                        gr.FillRectangle(brush, outerRect);
                        gr.Clip = oldClip;

                        ControlPaint.DrawSelectionFrame(gr, false, outerRect, innerRect, BackColor);
                    }
                }
            }
        }

        private void OnSelectionChanged(object sender, EventArgs e) {
            selectedObjects = ((ISelectionService)sender).GetSelectedComponents();
            Invalidate();

            // Accessibility information
            //
            foreach(object selObj in selectedObjects) {
                IComponent component = selObj as IComponent;
                if (component != null) {
                    Control c = TrayControl.FromComponent(component);
                    if (c != null) {
                        Debug.WriteLineIf(CompModSwitches.MSAA.TraceInfo, "MSAA: SelectionAdd, traycontrol = " + c.ToString());
                        UnsafeNativeMethods.NotifyWinEvent((int)AccessibleEvents.SelectionAdd, c.Handle, NativeMethods.OBJID_CLIENT, 0);
                    }
                }
            }

            object primary = ((ISelectionService)sender).PrimarySelection;
            if (primary != null && primary is IComponent) {
                Control c = TrayControl.FromComponent((IComponent)primary);
                if (c != null && IsHandleCreated) {
                    this.ScrollControlIntoView(c);
                    UnsafeNativeMethods.NotifyWinEvent((int)AccessibleEvents.Focus, c.Handle, NativeMethods.OBJID_CLIENT, 0);
                }
            }
        }

        /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.OnSetCursor"]/*' />
        /// <devdoc>
        ///      Sets the cursor.  You may override this to set your own
        ///      cursor.
        /// </devdoc>
        protected virtual void OnSetCursor() {
            if (toolboxService == null) {
                toolboxService = (IToolboxService)GetService(typeof(IToolboxService));
            }

            if (toolboxService == null || !toolboxService.SetCursor()) {
                Cursor.Current = Cursors.Default;
            }
        }

        private delegate void AsyncInvokeHandler(bool children);

        private void OnSystemSettingChanged(object sender, EventArgs e) {
            fResetAmbient = true;
            ResetTrayControls();
            BeginInvoke(new AsyncInvokeHandler(Invalidate), new object[] {true});
        }

        private void OnUserPreferenceChanged(object sender, UserPreferenceChangedEventArgs e) {
            fResetAmbient = true;
            ResetTrayControls();
            BeginInvoke(new AsyncInvokeHandler(Invalidate), new object[] {true});
        }

        /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.PositionControl"]/*' />
        /// <devdoc>
        ///      Sets the given control to the correct position on our
        ///      surface.  You may override this to perform your own
        ///      positioning.
        /// </devdoc>
        private void PositionControl(TrayControl c) {
            Debug.Assert(c.Visible, "TrayControl for " + c.Component + " should not be positioned");

            if (!autoArrange) {
                if (mouseDropLocation != InvalidPoint) {
                    if (!c.Location.Equals(mouseDropLocation))
                        c.Location = mouseDropLocation;
                    mouseDropLocation = InvalidPoint;
                }
                else {
                    Control prevCtl = null;
                    if (controls.Count > 1)
                        prevCtl = (Control)controls[controls.Count-2];
                    PositionInNextAutoSlot(c, prevCtl, true);
                }
            }
            else {
                if (mouseDropLocation != InvalidPoint) {
                    RearrangeInAutoSlots(c, mouseDropLocation);
                    mouseDropLocation = InvalidPoint;
                }
                else {
                    Control prevCtl = null;
                    if (controls.Count > 1)
                        prevCtl = (Control)controls[controls.Count-2];
                    PositionInNextAutoSlot(c, prevCtl, true);
                }
            }

            Debug.Assert(mouseDropLocation == InvalidPoint, "Did not reset points after positioning...");
        }

        private bool PositionInNextAutoSlot(TrayControl c, Control prevCtl, bool dirtyDesigner) {
            Debug.Assert(c.Visible, "TrayControl for " + c.Component + " should not be positioned");
            
            if (whiteSpace.IsEmpty) {
                Debug.Assert(selectionUISvc != null, "No SelectionUIService available for tray.");
                whiteSpace = new Point(selectionUISvc.GetAdornmentDimensions(AdornmentType.GrabHandle));
                whiteSpace.X = whiteSpace.X * 2 + 3;
                whiteSpace.Y = whiteSpace.Y * 2 + 3;
            }

            if (prevCtl == null) {
                Rectangle display = DisplayRectangle;
                Point newLoc = new Point(display.X + whiteSpace.X, display.Y + whiteSpace.Y);
                if (!c.Location.Equals(newLoc)) {
                    if (dirtyDesigner) {
                        IComponent comp = c.Component;
                        Debug.Assert(comp != null, "Component for the TrayControl is null");

                        PropertyDescriptor ctlLocation = TypeDescriptor.GetProperties(comp)["Location"];
                        if (ctlLocation != null) {
                            Point autoScrollLoc = this.AutoScrollPosition;
                            newLoc = new Point(newLoc.X - autoScrollLoc.X, newLoc.Y - autoScrollLoc.Y);
                            ctlLocation.SetValue(comp, newLoc);
                        }
                    }
                    else {
                        c.Location = newLoc;
                    }
                    return true;
                }
            }
            else {
                // Calcuate the next location for this control.
                //
                Rectangle bounds = prevCtl.Bounds;
                Point newLoc = new Point(bounds.X + bounds.Width + whiteSpace.X, bounds.Y);

                // Check to see if it goes over the edge of our window.  If it does,
                // then wrap it.
                //
                if (newLoc.X + c.Size.Width > Size.Width) {
                    newLoc.X = whiteSpace.X;
                    newLoc.Y += bounds.Height + whiteSpace.Y;
                }

                if (!c.Location.Equals(newLoc)) {
                    if (dirtyDesigner) {
                        IComponent comp = c.Component;
                        Debug.Assert(comp != null, "Component for the TrayControl is null");

                        PropertyDescriptor ctlLocation = TypeDescriptor.GetProperties(comp)["Location"];
                        if (ctlLocation != null) {
                            Point autoScrollLoc = this.AutoScrollPosition;
                            newLoc = new Point(newLoc.X - autoScrollLoc.X, newLoc.Y - autoScrollLoc.Y);
                            ctlLocation.SetValue(comp, newLoc);
                        }
                    }
                    else {
                        c.Location = newLoc;
                    }
                    return true;
                }
            }

            return false;
        }

        /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.RemoveComponent"]/*' />
        /// <devdoc>
        ///      Removes a component from the tray.
        /// </devdoc>
        public virtual void RemoveComponent(IComponent component) {
            TrayControl c = TrayControl.FromComponent(component);
            if (c != null) {
                InheritanceAttribute attr = c.InheritanceAttribute;
                if (attr.InheritanceLevel != InheritanceLevel.NotInherited && inheritanceUI != null) {
                    inheritanceUI.RemoveInheritedControl(c);
                }
            
                if (controls != null) {
                    int index = controls.IndexOf(c);
                    if (index != -1)
                        controls.RemoveAt(index);
                }
                c.Dispose();
            }
        }
                                                               
        private void ResetTrayControls() {
            ControlCollection children = (ControlCollection)this.Controls;
            if (children == null)
                return;

            for (int i = 0; i < children.Count; ++i) {
                if (children[i] is TrayControl)
                    ((TrayControl)children[i]).fRecompute = true;
            }
        }

        /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.SetLocation"]/*' />
        /// <devdoc>
        ///     Accessor method for the location extender property.  We offer this extender
        ///     to all non-visual components.
        /// </devdoc>
        public void SetLocation(IComponent receiver, Point location) {
            TrayControl c = TrayControl.FromComponent(receiver);

            if (c == null) {
                Debug.Fail("Anything we're extending should have a component view.");
                return;
            }

            if (c.Parent == this) {
                Point autoScrollLoc = this.AutoScrollPosition;
                location = new Point(location.X + autoScrollLoc.X, location.Y + autoScrollLoc.Y);

                if (c.Visible) {
                    RearrangeInAutoSlots(c, location);
                }
            }
            else if (!c.Location.Equals(location)) {
                c.Location = location;
                c.Positioned = true;
            }
        }
        
        /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.WndProc"]/*' />
        /// <devdoc>
        ///     We override our base class's WndProc to monitor certain messages.
        /// </devdoc>
        protected override void WndProc(ref Message m) {
            switch (m.Msg) {
                case NativeMethods.WM_CANCELMODE:

                    // When we get cancelmode (i.e. you tabbed away to another window)
                    // then we want to cancel any pending drag operation!
                    //
                    OnLostCapture();
                    break;

                case NativeMethods.WM_SETCURSOR:
                    OnSetCursor();
                    return;

                case NativeMethods.WM_HSCROLL:
                case NativeMethods.WM_VSCROLL:

                    // When we scroll, we reposition a control without causing a
                    // property change event.  Therefore, we must tell the
                    // selection UI service to sync itself.
                    //
                    base.WndProc(ref m);
                    if (selectionUISvc != null) {
                        selectionUISvc.SyncSelection();
                    }
                    return;

                case NativeMethods.WM_STYLECHANGED:

                    // When the scroll bars first appear, we need to
                    // invalidate so we properly paint our grid.
                    //
                    Invalidate();
                    break;

                case NativeMethods.WM_CONTEXTMENU:

                    // Pop a context menu for the composition designer.
                    //
                    int x = NativeMethods.Util.SignedLOWORD((int)m.LParam);
                    int y = NativeMethods.Util.SignedHIWORD((int)m.LParam);
                    if (x == -1 && y == -1) {
                        // for shift-F10
                        Point mouse = Control.MousePosition;
                        x = mouse.X;
                        y = mouse.Y;
                    }
                    OnContextMenu(x, y, true);
                    break;

                default:
                    base.WndProc(ref m);
                    break;
            }
        }

        /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.IOleDragClient.CanModifyComponents"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Checks if the client is read only.  That is, if components can
        /// be added or removed from the designer.
        /// </devdoc>
        bool IOleDragClient.CanModifyComponents {
            get {
                return true;
            }
        }

        /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.IOleDragClient.Component"]/*' />
        /// <internalonly/>
        IComponent IOleDragClient.Component {
            get{
                return mainDesigner.Component;
            }
        }

        /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.IOleDragClient.AddComponent"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Adds a component to the tray.
        /// </devdoc>
        bool IOleDragClient.AddComponent(IComponent component, string name, bool firstAdd) {

            // the designer for controls decides what to do here
            if (mainDesigner is IOleDragClient) {
                Debug.Assert(mouseDropLocation != InvalidPoint, "No MouseDrop Location was set... are we not in drag-drop?");

                droppedLocation = InvalidPoint;
                addingDraggedComponent = true;
                try {
                    ((IOleDragClient)mainDesigner).AddComponent(component, name, firstAdd);

                    // We store the adjusted drop location during the drag-drop, so that
                    // we can ignore the serialized location of the component, and use the
                    // new dropped location.
                    //
                    if (droppedLocation != InvalidPoint) {
                        SetLocation(component, droppedLocation);
                    }
                    return true;
                }
                finally {
                    addingDraggedComponent = false;
                    droppedLocation = InvalidPoint;
                }
            }
            else {
                // for webforms (98109) just add the component directly to the host
                //
                IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));

                try {
                    if (host != null && host.Container != null) {
                        if (host.Container.Components[name] != null) {
                            name = null;
                        }
                        host.Container.Add(component, name);
                        return true;
                    }
                }
                catch {
                }
            
            }
            Debug.Fail("Don't know how to add component!");
            return false;
        }

        /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.IOleDragClient.GetControlForComponent"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>
        /// Gets the control view instance for the given component.
        /// For Win32 designer, this will often be the component itself.
        /// </para>
        /// </devdoc>
        Control IOleDragClient.GetControlForComponent(object component) {
            if (component is IComponent) {
                return TrayControl.FromComponent((IComponent)component);
            }
            Debug.Fail("component is not IComponent");
            return null;
        }

        /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.IOleDragClient.GetDesignerControl"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>
        /// Gets the control view instance for the designer that
        /// is hosting the drag.
        /// </para>
        /// </devdoc>
        Control IOleDragClient.GetDesignerControl() {
            return this;
        }

        /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.IOleDragClient.IsDropOk"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Checks if it is valid to drop this type of a component on this client.
        /// </devdoc>
        bool IOleDragClient.IsDropOk(IComponent component) {
            return true;
        }

        /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.ISelectionUIHandler.BeginDrag"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Begins a drag operation.  A designer should examine the list of components
        /// to see if it wants to support the drag.  If it does, it should return
        /// true.  If it returns true, the designer should provide
        /// UI feedback about the drag at this time.  Typically, this feedback consists
        /// of an inverted rectangle for each component, or a caret if the component
        /// is text.
        /// </devdoc>
        bool ISelectionUIHandler.BeginDrag(object[] components, SelectionRules rules, int initialX, int initialY) {
            if (TabOrderActive) {
                return false;
            }

            bool result = DragHandler.BeginDrag(components, rules, initialX, initialY);
            if (result) {
                if (!GetOleDragHandler().DoBeginDrag(components, rules, initialX, initialY)) {
                    return false;
                }
            }
            return result;
        }

        /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.ISelectionUIHandler.DragMoved"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Called when the user has moved the mouse.  This will only be called on
        /// the designer that returned true from beginDrag.  The designer
        /// should update its UI feedback here.
        /// </devdoc>
        void ISelectionUIHandler.DragMoved(object[] components, Rectangle offset) {
            DragHandler.DragMoved(components, offset);
        }

        /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.ISelectionUIHandler.EndDrag"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Called when the user has completed the drag.  The designer should
        /// remove any UI feedback it may be providing.
        /// </devdoc>
        void ISelectionUIHandler.EndDrag(object[] components, bool cancel) {
            DragHandler.EndDrag(components, cancel);

            GetOleDragHandler().DoEndDrag(components, cancel);

            //Here, after the drag is finished and after we have resumed layout,
            //adjust the location of the components we dragged by the scroll offset
            //
            if (!this.autoScrollPosBeforeDragging.IsEmpty) {
                foreach (IComponent comp in components) {
                    TrayControl tc = TrayControl.FromComponent(comp);
                    if (tc != null) {
                        this.SetLocation(comp, new Point(tc.Location.X - this.autoScrollPosBeforeDragging.X, tc.Location.Y - this.autoScrollPosBeforeDragging.Y));
                    }
                }
                this.AutoScrollPosition = new Point(-this.autoScrollPosBeforeDragging.X, -this.autoScrollPosBeforeDragging.Y);
            }
        }

        /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.ISelectionUIHandler.GetComponentBounds"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>
        /// Gets the shape of the component. The component's shape should be in
        /// absolute coordinates and in pixels, where 0,0 is the upper left corner of
        /// the screen.
        /// </para>
        /// </devdoc>
        Rectangle ISelectionUIHandler.GetComponentBounds(object component) {
            // We render the selection UI glyph ourselves.
            return Rectangle.Empty;
        }

        /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.ISelectionUIHandler.GetComponentRules"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>
        /// Gets a set of rules concerning the movement capabilities of a component.
        /// This should be one or more flags from the SelectionRules class. If no designer
        /// provides rules for a component, the component will not get any UI services.
        /// </para>
        /// </devdoc>
        SelectionRules ISelectionUIHandler.GetComponentRules(object component) {
            return SelectionRules.Visible | SelectionRules.Moveable;
        }

        /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.ISelectionUIHandler.GetSelectionClipRect"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>
        /// Gets the rectangle that any selection adornments should be clipped
        /// to. This is normally the client area (in screen coordinates) of the
        /// container.
        /// </para>
        /// </devdoc>
        Rectangle ISelectionUIHandler.GetSelectionClipRect(object component) {
            if (IsHandleCreated) {
                return RectangleToScreen(ClientRectangle);
            }
            return Rectangle.Empty;
        }

        /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.ISelectionUIHandler.OleDragEnter"]/*' />
        /// <internalonly/>
        void ISelectionUIHandler.OleDragEnter(DragEventArgs de) {
            GetOleDragHandler().DoOleDragEnter(de);
        }

        /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.ISelectionUIHandler.OleDragDrop"]/*' />
        /// <internalonly/>
        void ISelectionUIHandler.OleDragDrop(DragEventArgs de) {
            GetOleDragHandler().DoOleDragDrop(de);
        }

        /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.ISelectionUIHandler.OleDragOver"]/*' />
        /// <internalonly/>
        void ISelectionUIHandler.OleDragOver(DragEventArgs de) {
            GetOleDragHandler().DoOleDragOver(de);
        }

        /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.ISelectionUIHandler.OleDragLeave"]/*' />
        /// <internalonly/>
        void ISelectionUIHandler.OleDragLeave() {
            GetOleDragHandler().DoOleDragLeave();
        }

        /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.ISelectionUIHandler.OnSelectionDoubleClick"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Handle a double-click on the selection rectangle
        /// of the given component.
        /// </devdoc>
        void ISelectionUIHandler.OnSelectionDoubleClick(IComponent component) {
            if (!TabOrderActive) {
                Control tc = ((IOleDragClient)this).GetControlForComponent(component);
                if (tc != null && tc is TrayControl) {
                    ((TrayControl)tc).ViewDefaultEvent(component);
                }
            }
        }

        /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.ISelectionUIHandler.QueryBeginDrag"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Queries to see if a drag operation
        /// is valid on this handler for the given set of components.
        /// If it returns true, BeginDrag will be called immediately after.
        /// </devdoc>
        bool ISelectionUIHandler.QueryBeginDrag(object[] components, SelectionRules rules, int initialX, int initialY) {
            return DragHandler.QueryBeginDrag(components, rules, initialX, initialY);
        }

        internal void RearrangeInAutoSlots(Control c, Point pos) {
#if DEBUG
            int index = controls.IndexOf(c);
            Debug.Assert(index != -1, "Add control to the list of controls before autoarranging.!!!");
            Debug.Assert(this.Visible == c.Visible, "TrayControl for " + ((TrayControl)c).Component + " should not be positioned");
#endif // DEBUG

            TrayControl tc = (TrayControl)c;
            tc.Positioned = true;
            tc.Location = pos;
        }

        /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.ISelectionUIHandler.ShowContextMenu"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Shows the context menu for the given component.
        /// </devdoc>
        void ISelectionUIHandler.ShowContextMenu(IComponent component) {
            Point cur = Control.MousePosition;
            OnContextMenu(cur.X, cur.Y, true);
        }

        /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.TrayOleDragDropHandler"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    TrayOleDragDropHandler provides the Ole Drag-drop handler for the
        ///    component tray.
        /// </devdoc>
        private class TrayOleDragDropHandler : OleDragDropHandler {

            public TrayOleDragDropHandler(SelectionUIHandler selectionHandler,  IServiceProvider  serviceProvider, IOleDragClient client) : 
            base(selectionHandler, serviceProvider, client) {
            }

            protected override bool CanDropDataObject(IDataObject dataObj) {
                ICollection comps = null;
                if (dataObj != null) {
                    if (dataObj is ComponentDataObjectWrapper) {
                        IDataObject dataObjReal = ((ComponentDataObjectWrapper)dataObj).InnerData;
                        ComponentDataObject cdo = (ComponentDataObject)dataObjReal;
                        comps = cdo.Components;
                    }
                    else {
                        try {
                            object serializationData = dataObj.GetData(OleDragDropHandler.DataFormat, true);

                            if (serializationData == null) {
                                return false;
                            }

                            IDesignerSerializationService ds = (IDesignerSerializationService)GetService(typeof(IDesignerSerializationService));
                            if (ds == null) {
                                return false;
                            }
                            comps = ds.Deserialize(serializationData);
                        }
                        catch (Exception) {
                            // we return false on any exception
                        }
                    }
                }
                
                if (comps != null && comps.Count > 0) {
                    foreach(object comp in comps) {
                        if (comp is Point) {
                            continue;
                        }
                        if (comp is Control || !(comp is IComponent)) {
                            return false;
                        }
                    }
                    return true;
                }

                return false;
            }
        }

        internal class AutoArrangeComparer : IComparer {
            int IComparer.Compare(object o1, object o2) {
                Debug.Assert(o1 != null && o2 != null, "Null objects sent for comparison!!!");

                Point tcLoc1 = ((Control)o1).Location;
                Point tcLoc2 = ((Control)o2).Location;
                int width = ((Control)o1).Width / 2;
                int height = ((Control)o1).Height / 2;

                // If they are at the same location, they are equal.
                if (tcLoc1.X == tcLoc2.X && tcLoc1.Y == tcLoc2.Y) {
                    return 0;
                }

                // Is the first control lower than the 2nd...
                if (tcLoc1.Y + height <= tcLoc2.Y)
                    return -1;

                // Is the 2nd control lower than the first...
                if (tcLoc2.Y + height <= tcLoc1.Y)
                    return 1;

                // Which control is left of the other...
                return((tcLoc1.X <= tcLoc2.X) ? -1 : 1);
            }
        }
        /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.TrayControl"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    The tray control is the UI we show for each component in the tray.
        /// </devdoc>
        internal class TrayControl : Control {

            // Values that define this tray control
            //
            private IComponent  component;       // the component this control is representing
            private Image       toolboxBitmap;   // the bitmap used to represent the component
            private int         cxIcon;          // the dimensions of the bitmap
            private int         cyIcon;          // the dimensions of the bitmap

            private InheritanceAttribute inheritanceAttribute;

            // Services that we use often enough to cache.
            //
            private ComponentTray        tray;

            // transient values that are used during mouse drags
            //
            private Point mouseDragLast = InvalidPoint;  // the last position of the mouse during a drag.
            private bool  mouseDragMoved;       // has the mouse been moved during this drag?
            private bool  ctrlSelect = false;   // was the ctrl key down on the mouse down?
            private bool  positioned = false;   // Have we given this control an explicit location yet?
            
            private const int whiteSpace  = 5;
            private int borderWidth;

            internal bool fRecompute = false; // This flag tells the TrayControl that it needs to retrieve
                                              // the font and the background color before painting.

            /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.TrayControl.TrayControl"]/*' />
            /// <devdoc>
            ///      Creates a new TrayControl based on the component.
            /// </devdoc>
            public TrayControl(ComponentTray tray, IComponent component) {
                this.tray = tray;
                this.component = component;

                SetStyle(ControlStyles.DoubleBuffer, true);
                SetStyle(ControlStyles.Selectable, false);
                borderWidth = SystemInformation.BorderSize.Width;
                
                UpdateIconInfo();

                IComponentChangeService cs = (IComponentChangeService)tray.GetService(typeof(IComponentChangeService));
                if (CompModSwitches.CommonDesignerServices.Enabled) Debug.Assert(cs != null, "IComponentChangeService not found");
                if (cs != null) {
                    cs.ComponentRename += new ComponentRenameEventHandler(this.OnComponentRename);
                }

                ISite site = component.Site;
                string name = null;

                if (site != null) {
                    name = site.Name;

                    IDictionaryService ds = (IDictionaryService)site.GetService(typeof(IDictionaryService));
                    Debug.Assert(ds != null, "ComponentTray relies on IDictionaryService, which is not available.");
                    if (ds != null) {
                        ds.SetValue(GetType(), this);
                    }
                }

                if (name == null) {
                    // We always want name to have something in it, so we default to
                    // the class name.  This way the design instance contains something
                    // semi-intuitive if we don't have a site.
                    //
                    name = component.GetType().Name;
                }

                Text = name;
                inheritanceAttribute = (InheritanceAttribute)TypeDescriptor.GetAttributes(component)[typeof(InheritanceAttribute)];
                TabStop = false;

                // Listen to the location changes of underlying components, if they have their own
                // location property.
                //
                Control c = component as Control;
                if (c != null) {
                    c.LocationChanged += new EventHandler(this.OnControlLocationChanged);

                    if (this.Location != c.Location) {
                        this.Location = c.Location;
                        positioned = true;
                    }
                }
            }

            /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.TrayControl.Component"]/*' />
            /// <devdoc>
            ///      Retrieves the compnent this control is representing.
            /// </devdoc>
            public IComponent Component {
                get {
                    return component;
                }
            }

            public override Font Font {
                get {
                    /*
                    IDesignerHost host = (IDesignerHost)tray.GetService(typeof(IDesignerHost));
                    if (host != null && host.GetRootComponent() is Control) {
                        Control c = (Control)host.GetRootComponent();
                        return c.Font;
                    }
                    */
                    return tray.Font;
                }
            }
            
            public InheritanceAttribute InheritanceAttribute {
                get {
                    return inheritanceAttribute;
                }
            }

            public bool Positioned {
                get {
                    return positioned;
                }
                set {
                    positioned = value;
                }
            }

            /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.TrayControl.AdjustSize"]/*' />
            /// <devdoc>
            ///     Adjusts the size of the control based on the contents.
            /// </devdoc>
            // CONSIDER: this method gets called three or four times per component,
            // and is even reentrant (CreateGraphics can force handle creation, and OnCreateHandle
            // calls this method).  There's probably a better way to do this, but since
            // this doesn't seem to be on the critical path, I'm not going to lose sleep over it.
            private void AdjustSize(bool autoArrange) {
                // CONSIDER: this forces handle creation.  Can we delay this calculation?
                Graphics gr = CreateGraphics();

                Size sz = Size.Ceiling(gr.MeasureString(Text, Font));
                gr.Dispose();

                Rectangle rc = Bounds;

                if (tray.ShowLargeIcons) {
                    rc.Width = Math.Max(cxIcon, sz.Width) + 4 * borderWidth + 2 * whiteSpace;
                    rc.Height = cyIcon + 2 * whiteSpace + sz.Height + 4 * borderWidth;
                }
                else {
                    rc.Width = cxIcon + sz.Width + 4 * borderWidth + 2 * whiteSpace;
                    rc.Height = Math.Max(cyIcon, sz.Height) + 4 * borderWidth;
                }

                Bounds = rc;
                Invalidate();
            }

            protected override AccessibleObject CreateAccessibilityInstance() {
                return new TrayControlAccessibleObject(this, tray);
            }

            /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.TrayControl.Dispose"]/*' />
            /// <devdoc>
            ///     Destroys this control.  Views automatically destroy themselves when they
            ///     are removed from the design container.
            /// </devdoc>
            protected override void Dispose(bool disposing) {
                if (disposing) {
                    ISite site = component.Site;
                    if (site != null) {
                        IComponentChangeService cs = (IComponentChangeService)site.GetService(typeof(IComponentChangeService));
                        if (CompModSwitches.CommonDesignerServices.Enabled) Debug.Assert(cs != null, "IComponentChangeService not found");
                        if (cs != null) {
                            cs.ComponentRename -= new ComponentRenameEventHandler(this.OnComponentRename);
                        }

                        IDictionaryService ds = (IDictionaryService)site.GetService(typeof(IDictionaryService));
                        if (CompModSwitches.CommonDesignerServices.Enabled) Debug.Assert(ds != null, "IDictionaryService not found");
                        if (ds != null) {
                            ds.SetValue(typeof(TrayControl), null);
                        }
                    }
                }

                base.Dispose(disposing);
            }

            /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.TrayControl.FromComponent"]/*' />
            /// <devdoc>
            ///      Retrieves the tray control object for the given component.
            /// </devdoc>
            public static TrayControl FromComponent(IComponent component) {
                TrayControl c = null;

                if (component == null) {
                    return null;
                }

                ISite site = component.Site;
                if (site != null) {
                    IDictionaryService ds = (IDictionaryService)site.GetService(typeof(IDictionaryService));
                    if (CompModSwitches.CommonDesignerServices.Enabled) Debug.Assert(ds != null, "IDictionaryService not found");
                    if (ds != null) {
                        c = (TrayControl)ds.GetValue(typeof(TrayControl));
                    }
                }

                return c;
            }

            /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.TrayControl.OnComponentRename"]/*' />
            /// <devdoc>
            ///     Delegate that is called in response to a name change.  Here we update our own
            ///     stashed version of the name, recalcuate our size and repaint.
            /// </devdoc>
            private void OnComponentRename(object sender, ComponentRenameEventArgs e) {
                if (e.Component == this.component) {
                    Text = e.NewName;
                    AdjustSize(true);
                }
            }

            /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.TrayControl.OnHandleCreated"]/*' />
            /// <devdoc>
            ///     Overrides handle creation notification for a control.  Here we just ensure
            ///     that we're the proper size.
            /// </devdoc>
            protected override void OnHandleCreated(EventArgs e) {
                base.OnHandleCreated(e);
                AdjustSize(false);
            }

            /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.TrayControl.OnDoubleClick"]/*' />
            /// <devdoc>
            ///     Called in response to a double-click of the left mouse button.  The
            ///     default behavior here calls onDoubleClick on IMouseHandler
            /// </devdoc>
            protected override void OnDoubleClick(EventArgs e) {
                base.OnDoubleClick(e);

                if (!tray.TabOrderActive) {
                    IDesignerHost host = (IDesignerHost)tray.GetService(typeof(IDesignerHost));
                    Debug.Assert(host != null, "Component tray does not have access to designer host.");
                    if (host != null) {
                        mouseDragLast = InvalidPoint;

                        Capture = false;

                        // We try to get a designer for the component and let it view the
                        // event.  If this fails, then we'll try to do it ourselves.
                        //
                        IDesigner designer = host.GetDesigner(component);

                        if (designer == null) {
                            ViewDefaultEvent(component);
                        }
                        else {
                            designer.DoDefaultAction();
                        }
                    }
                }
            }

            private void OnControlLocationChanged(object sender, EventArgs e) {
                Debug.Assert(sender == component, "Called on some one else's component!!!");

                Point controlLoc = ((Control)sender).Location;
                if (!this.Location.Equals(controlLoc)) {
                    this.Location = controlLoc;
                    positioned = true;
                }
            }

            /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.TrayControl.OnMouseDown"]/*' />
            /// <devdoc>
            ///     Called when the mouse button is pressed down.  Here, we provide drag
            ///     support for the component.
            /// </devdoc>
            protected override void OnMouseDown(MouseEventArgs me) {
                base.OnMouseDown(me);

                if (!tray.TabOrderActive) {
                    
                    tray.FocusDesigner();
                                        
                    // If this is the left mouse button, then begin a drag.
                    //
                    if (me.Button == MouseButtons.Left) {
                        Capture = true;
                        mouseDragLast = PointToScreen(new Point(me.X, me.Y));

                        // If the CTRL key isn't down, select this component,
                        // otherwise, we wait until the mouse up
                        //
                        // Make sure the component is selected
                        //

                        ctrlSelect = NativeMethods.GetKeyState((int)Keys.ControlKey) != 0;

                        if (!ctrlSelect) {
                            ISelectionService sel = (ISelectionService)tray.GetService(typeof(ISelectionService));

                            // Make sure the component is selected
                            //
                            if (CompModSwitches.CommonDesignerServices.Enabled) Debug.Assert(sel != null, "ISelectionService not found");

                            if (sel != null) {
                                SelectionTypes type = SelectionTypes.Click;
                                if (!sel.GetComponentSelected(this.Component)) {
                                    type |= SelectionTypes.MouseDown;
                                }

                                sel.SetSelectedComponents(new object[] {this.Component}, type);
                            }
                        }
                    }
                }
            }

            /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.TrayControl.OnMouseMove"]/*' />
            /// <devdoc>
            ///     Called when the mouse is moved over the component.  We update our drag
            ///     information here if we're dragging the component around.
            /// </devdoc>
            protected override void OnMouseMove(MouseEventArgs me) {
                base.OnMouseMove(me);

                if (mouseDragLast == InvalidPoint) {
                    return;
                }

                if (!mouseDragMoved) {

                    Size minDrag = SystemInformation.DragSize;
                    Size minDblClick = SystemInformation.DoubleClickSize;

                    minDrag.Width = Math.Max(minDrag.Width, minDblClick.Width);
                    minDrag.Height = Math.Max(minDrag.Height, minDblClick.Height);

                    // we have to make sure the mouse moved farther than
                    // the minimum drag distance before we actually start
                    // the drag
                    //
                    Point newPt = PointToScreen(new Point(me.X, me.Y));
                    if (mouseDragLast == InvalidPoint ||
                        (Math.Abs(mouseDragLast.X - newPt.X) < minDrag.Width &&
                         Math.Abs(mouseDragLast.Y - newPt.Y) < minDrag.Height)) {
                        return;
                    }
                    else {
                        mouseDragMoved = true;

                        // we're on the move, so we're not in a ctrlSelect
                        //
                        ctrlSelect = false;
                    }
                }

                try {
                    // Make sure the component is selected
                    //
                    ISelectionService sel = (ISelectionService)tray.GetService(typeof(ISelectionService));
                    if (sel != null) {
                        SelectionTypes type = SelectionTypes.Click;
                        if (!sel.GetComponentSelected(this.Component)) {
                            type |= SelectionTypes.MouseDown;
                            sel.SetSelectedComponents(new object[] {this.Component}, type);
                        }
                    }

                    // Notify the selection service that all the components are in the "mouse down" mode.
                    //
                    if (tray.selectionUISvc != null && tray.selectionUISvc.BeginDrag(SelectionRules.Visible | SelectionRules.Moveable, mouseDragLast.X, mouseDragLast.Y)) {
                        OnSetCursor();
                    }
                }
                finally {
                    mouseDragMoved = false;
                    mouseDragLast = InvalidPoint;
                }
            }

            /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.TrayControl.OnMouseUp"]/*' />
            /// <devdoc>
            ///     Called when the mouse button is released.  Here, we finish our drag
            ///     if one was started.
            /// </devdoc>
            protected override void OnMouseUp(MouseEventArgs me) {
                base.OnMouseUp(me);

                mouseDragLast = InvalidPoint;

                if (!mouseDragMoved) {
                    if (ctrlSelect) {
                        ISelectionService sel = (ISelectionService)tray.GetService(typeof(ISelectionService));
                        if (sel != null) {
                            SelectionTypes type = SelectionTypes.Click;
                            if (!sel.GetComponentSelected(this.Component)) {
                                type |= SelectionTypes.MouseDown;
                            }
                            sel.SetSelectedComponents(new object[] {this.Component}, type);
                        }
                        ctrlSelect = false;
                    }
                    return;
                }
                mouseDragMoved = false;
                ctrlSelect = false;

                Capture = false;
                OnSetCursor();

                // And now finish the drag.
                //
                Debug.Assert(tray.selectionUISvc != null, "We shouldn't be able to begin a drag without this");
                if (tray.selectionUISvc != null && tray.selectionUISvc.Dragging) {
                    tray.selectionUISvc.EndDrag(false);
                }
            }

            /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.TrayControl.OnContextMenu"]/*' />
            /// <devdoc>
            ///     Called when we are to display our context menu for this component.
            /// </devdoc>
            private void OnContextMenu(int x, int y) {

                if (!tray.TabOrderActive) {
                    Capture = false;

                    // Ensure that this component is selected.
                    //
                    ISelectionService s = (ISelectionService)tray.GetService(typeof(ISelectionService));
                    if (s != null && !s.GetComponentSelected(component)) {
                        s.SetSelectedComponents(new object[] {component}, SelectionTypes.Replace);
                    }

                    IMenuCommandService mcs = tray.MenuService;
                    if (mcs != null) {
                        Capture = false;
                        Cursor.Clip = Rectangle.Empty;
                        mcs.ShowContextMenu(MenuCommands.TraySelectionMenu, x, y);
                    }
                }
            }

            /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.TrayControl.OnPaint"]/*' />
            /// <devdoc>
            ///     Painting for our control.
            /// </devdoc>
            protected override void OnPaint(PaintEventArgs e) {
                if (fRecompute) {
                    fRecompute = false;
                    UpdateIconInfo();
                }

                base.OnPaint(e);
                Rectangle rc = ClientRectangle;

                rc.X += whiteSpace + borderWidth;
                rc.Y += borderWidth;
                rc.Width -= (2 * borderWidth + whiteSpace);
                rc.Height -= 2 * borderWidth;

                StringFormat format = new StringFormat();
                format.Alignment = StringAlignment.Center;
                
                Brush foreBrush = new SolidBrush(ForeColor);
                
                if (tray.ShowLargeIcons) {
                    if (null != toolboxBitmap) {
                        int x = rc.X + (rc.Width - cxIcon)/2;
                        int y = rc.Y + whiteSpace;
                        e.Graphics.DrawImage(toolboxBitmap, new Rectangle(x, y, cxIcon, cyIcon));
                    }

                    rc.Y += (cyIcon + whiteSpace);
                    rc.Height -= cyIcon;
                    e.Graphics.DrawString(Text, Font, foreBrush, rc, format);
                }
                else {
                    if (null != toolboxBitmap) {
                        int y = rc.Y + (rc.Height - cyIcon)/2;
                        e.Graphics.DrawImage(toolboxBitmap, new Rectangle(rc.X, y, cxIcon, cyIcon));
                    }

                    rc.X += (cxIcon + borderWidth);
                    rc.Width -= cxIcon;
                    rc.Y += 3;
                    e.Graphics.DrawString(Text, Font, foreBrush, rc);
                }
                    
                format.Dispose();
                foreBrush.Dispose();

                // If this component is being inherited, paint it as such
                //
                if (!InheritanceAttribute.NotInherited.Equals(inheritanceAttribute)) {
                    InheritanceUI iui = tray.InheritanceUI;
                    if (iui != null) {
                        e.Graphics.DrawImage(iui.InheritanceGlyph, 0, 0);
                    }
                }
            }

            /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.TrayControl.OnFontChanged"]/*' />
            /// <devdoc>
            ///     Overrides control's FontChanged.  Here we re-adjust our size if the font changes.
            /// </devdoc>
            protected override void OnFontChanged(EventArgs e) {
                AdjustSize(true);
                base.OnFontChanged(e);
            }

            /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.TrayControl.OnTextChanged"]/*' />
            /// <devdoc>
            ///     Overrides control's TextChanged.  Here we re-adjust our size if the font changes.
            /// </devdoc>
            protected override void OnTextChanged(EventArgs e) {
                AdjustSize(true);
                base.OnTextChanged(e);
            }

            /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.TrayControl.OnSetCursor"]/*' />
            /// <devdoc>
            ///     Called each time the cursor needs to be set.  The ControlDesigner behavior here
            ///     will set the cursor to one of three things:
            ///     1.  If the selection UI service shows a locked selection, or if there is no location
            ///     property on the control, then the default arrow will be set.
            ///     2.  Otherwise, the four headed arrow will be set to indicate that the component can
            ///     be clicked and moved.
            ///     3.  If the user is currently dragging a component, the crosshair cursor will be used
            ///     instead of the four headed arrow.
            /// </devdoc>
            private void OnSetCursor() {

                // Check that the component is not locked.
                //
                PropertyDescriptor prop = TypeDescriptor.GetProperties(component)["Locked"];
                if (prop != null  && ((bool)prop.GetValue(component)) == true) {
                    Cursor.Current = Cursors.Default;
                    return;
                }

                // Ask the tray to see if the tab order UI is not running.
                //
                if (tray.TabOrderActive) {
                    Cursor.Current = Cursors.Default;
                    return;
                }

                if (mouseDragMoved) {
                    Cursor.Current = Cursors.Default;
                }
                else if (mouseDragLast != InvalidPoint) {
                    Cursor.Current = Cursors.Cross;
                }
                else {
                    Cursor.Current = Cursors.SizeAll;
                }
            }

            protected override void SetBoundsCore(int x, int y, int width, int height, BoundsSpecified specified) {
                if (!tray.AutoArrange ||
                    (specified & BoundsSpecified.Width) == BoundsSpecified.Width ||
                    (specified & BoundsSpecified.Height) == BoundsSpecified.Height) {
                    
                    base.SetBoundsCore(x, y, width, height, specified);
                }

                Rectangle bounds = Bounds;
                Size parentGridSize = tray.ParentGridSize;
                if (Math.Abs(bounds.X - x) > parentGridSize.Width || Math.Abs(bounds.Y - y) > parentGridSize.Height) {
                    base.SetBoundsCore(x, y, width, height, specified);
                }

                // If the component is a control, then sync its location with
                // the tray component.  The tray component monitors control events
                // since after this, all changes go through properties.
                //
                if (component is Control) {
                    ((Control)component).Location = this.Location;
                }
            }

            /// <include file='doc\Control.uex' path='docs/doc[@for="Control.SetVisibleCore"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            protected override void SetVisibleCore(bool value) {
                if (value && !tray.CanDisplayComponent(this.component))
                    return;

                base.SetVisibleCore(value);
            }

            public override string ToString() {
                return "ComponentTray: " + component.ToString();
            }

            internal void UpdateIconInfo() {
                ToolboxBitmapAttribute attr = (ToolboxBitmapAttribute)TypeDescriptor.GetAttributes(component)[typeof(ToolboxBitmapAttribute)];
                if (attr != null) {
                    toolboxBitmap = attr.GetImage(component, tray.ShowLargeIcons);
                }

                // Get the size of the bitmap so we can size our
                // component correctly.
                //
                if (null == toolboxBitmap) {
                    cxIcon = 0;
                    cyIcon = SystemInformation.IconSize.Height;
                }
                else {
                    Size sz = toolboxBitmap.Size;
                    cxIcon = sz.Width;
                    cyIcon = sz.Height;
                }

                AdjustSize(true);
            }

            /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.TrayControl.ViewDefaultEvent"]/*' />
            /// <devdoc>
            ///      This creates a method signature in the source code file for the
            ///      default event on the component and navigates the user's cursor
            ///      to that location.
            /// </devdoc>
            public virtual void ViewDefaultEvent(IComponent component) {
                EventDescriptor defaultEvent = TypeDescriptor.GetDefaultEvent(component);
                PropertyDescriptor defaultPropEvent = null;
                string handler = null;
                bool eventChanged = false;

                IEventBindingService eps = (IEventBindingService)GetService(typeof(IEventBindingService));
                if (CompModSwitches.CommonDesignerServices.Enabled) Debug.Assert(eps != null, "IEventBindingService not found");
                if (eps != null) {
                    defaultPropEvent = eps.GetEventProperty(defaultEvent);
                }

                // If we couldn't find a property for this event, or of the property is read only, then
                // abort and just show the code.
                //
                if (defaultPropEvent == null || defaultPropEvent.IsReadOnly) {
                    eps.ShowCode();
                    return;
                }

                handler = (string)defaultPropEvent.GetValue(component);
                
                // If there is no handler set, set one now.
                //
                if (handler == null) {
                    eventChanged = true;
                    handler = eps.CreateUniqueMethodName(component, defaultEvent);
                }
                
                IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
                DesignerTransaction trans = null;
                
                try {
                    if (host != null) {
                        trans = host.CreateTransaction(SR.GetString(SR.WindowsFormsAddEvent, defaultEvent.Name));
                    }

                    // Save the new value... BEFORE navigating to it!
                    //
                    if (eventChanged && defaultPropEvent != null) {

                        defaultPropEvent.SetValue(component, handler);

                        // make sure set succeded (may fail if under SCC)
                        // if (defaultPropEvent.GetValue(component) != handler) {
                        //     return;
                        // }
                    }

                    eps.ShowCode(component, defaultEvent);
                }
                finally {
                    if (trans != null) {
                        trans.Commit();
                    }
                }
            }

            /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.TrayControl.WndProc"]/*' />
            /// <devdoc>
            ///     This method should be called by the extending designer for each message
            ///     the control would normally receive.  This allows the designer to pre-process
            ///     messages before allowing them to be routed to the control.
            /// </devdoc>
            protected override void WndProc(ref Message m) {
                switch (m.Msg) {
                    case NativeMethods.WM_SETCURSOR:
                        // We always handle setting the cursor ourselves.
                        //
                        OnSetCursor();
                        break;

                    case NativeMethods.WM_CONTEXTMENU:
                        // We must handle this ourselves.  Control only allows
                        // regular Windows Forms context menus, which doesn't do us much
                        // good.  Also, control's button up processing calls DefwndProc
                        // first, which causes a right mouse up to be routed as a
                        // WM_CONTEXTMENU.  If we don't respond to it here, this
                        // message will be bubbled up to our parent, which would
                        // pop up a container context menu instead of our own.
                        //
                        int x = NativeMethods.Util.SignedLOWORD((int)m.LParam);
                        int y = NativeMethods.Util.SignedHIWORD((int)m.LParam);
                        if (x == -1 && y == -1) {
                            // for shift-F10
                            Point mouse = Control.MousePosition;
                            x = mouse.X;
                            y = mouse.Y;
                        }
                        OnContextMenu(x, y);
                        break;
                    default:
                        base.WndProc(ref m);
                        break;
                }
            }

            private class TrayControlAccessibleObject : ControlAccessibleObject
            {
                ComponentTray tray;

                public TrayControlAccessibleObject(TrayControl owner, ComponentTray tray) : base(owner) {
                    this.tray = tray;
                }

                private IComponent Component {
                    get
                    {
                        return ((TrayControl)Owner).Component;
                    }
                }

                public override AccessibleStates State {
                    get
                    {
                        AccessibleStates state = base.State;

                        ISelectionService s = (ISelectionService)tray.GetService(typeof(ISelectionService));
                        if (s != null) {
                            if (s.GetComponentSelected(Component)) {
                                state |= AccessibleStates.Selected;
                            }
                            if (s.PrimarySelection == Component) {
                                state |= AccessibleStates.Focused;
                            }
                        }

                        return state;
                    }
                }
            }
        }

        /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.TraySelectionUIHandler"]/*' />
        /// <devdoc>
        ///      This class inherits from the abstract SelectionUIHandler
        ///      class to provide a selection UI implementation for the
        ///      component tray.
        /// </devdoc>
        private class TraySelectionUIHandler : SelectionUIHandler {

            private ComponentTray tray;
            private Size snapSize = Size.Empty;

            /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.TraySelectionUIHandler.TraySelectionUIHandler"]/*' />
            /// <devdoc>
            ///      Creates a new selection UI handler for the given
            ///      component tray.
            /// </devdoc>
            public TraySelectionUIHandler(ComponentTray tray) {
                this.tray = tray;
                snapSize = new Size();
            }

            /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.TraySelectionUIHandler.BeginDrag"]/*' />
            /// <devdoc>
            ///     Called when the user has started the drag.
            /// </devdoc>
            public override bool BeginDrag(object[] components, SelectionRules rules, int initialX, int initialY) {
                bool value = base.BeginDrag(components, rules, initialX, initialY);
                tray.SuspendLayout();
                return value;
            }

            /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.TraySelectionUIHandler.EndDrag"]/*' />
            /// <devdoc>
            ///     Called when the user has completed the drag.  The designer should
            ///     remove any UI feedback it may be providing.
            /// </devdoc>
            public override void EndDrag(object[] components, bool cancel) {
                base.EndDrag(components, cancel);
                tray.ResumeLayout();
            }

            /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.TraySelectionUIHandler.GetComponent"]/*' />
            /// <devdoc>
            ///      Retrieves the base component for the selection handler.
            /// </devdoc>
            protected override IComponent GetComponent() {
                return tray;
            }

            /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.TraySelectionUIHandler.GetControl"]/*' />
            /// <devdoc>
            ///      Retrieves the base component's UI control for the selection handler.
            /// </devdoc>
            protected override Control GetControl() {
                return tray;
            }

            /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.TraySelectionUIHandler.GetControl1"]/*' />
            /// <devdoc>
            ///      Retrieves the UI control for the given component.
            /// </devdoc>
            protected override Control GetControl(IComponent component) {
                return TrayControl.FromComponent(component);
            }

            /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.TraySelectionUIHandler.GetCurrentSnapSize"]/*' />
            /// <devdoc>
            ///      Retrieves the current grid snap size we should snap objects
            ///      to.
            /// </devdoc>
            protected override Size GetCurrentSnapSize() {
                return snapSize;
            }

            /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.TraySelectionUIHandler.GetService"]/*' />
            /// <devdoc>
            ///      We use this to request often-used services.
            /// </devdoc>
            protected override object GetService(Type serviceType) {
                return tray.GetService(serviceType);
            }

            /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.TraySelectionUIHandler.GetShouldSnapToGrid"]/*' />
            /// <devdoc>
            ///      Determines if the selection UI handler should attempt to snap
            ///      objects to a grid.
            /// </devdoc>
            protected override bool GetShouldSnapToGrid() {
                return false;
            }

            /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.TraySelectionUIHandler.GetUpdatedRect"]/*' />
            /// <devdoc>
            ///      Given a rectangle, this updates the dimensions of it
            ///      with any grid snaps and returns a new rectangle.  If
            ///      no changes to the rectangle's size were needed, this
            ///      may return the same rectangle.
            /// </devdoc>
            public override Rectangle GetUpdatedRect(Rectangle originalRect, Rectangle dragRect, bool updateSize) {
                return dragRect;
            }

            /// <include file='doc\ComponentTray.uex' path='docs/doc[@for="ComponentTray.TraySelectionUIHandler.SetCursor"]/*' />
            /// <devdoc>
            ///     Asks the handler to set the appropriate cursor
            /// </devdoc>
            public override void SetCursor() {
                tray.OnSetCursor();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\containerselectoractiveevent.cs ===
//------------------------------------------------------------------------------
// <copyright file="ContainerSelectorActiveEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms.Design {
    using System.Diagnostics;
    using System;
    using System.ComponentModel;
    using Microsoft.Win32;

    /// <include file='doc\ContainerSelectorActiveEvent.uex' path='docs/doc[@for="ContainerSelectorActiveEventArgs"]/*' />
    /// <internalonly/>
    /// <devdoc>
    /// <para>Provides data for the <see cref='System.Windows.Forms.Design.ISelectionUIService.ContainerSelectorActive'/>
    /// event.</para>
    /// </devdoc>
    internal class ContainerSelectorActiveEventArgs : EventArgs {
        
        private readonly object component;
        private readonly ContainerSelectorActiveEventArgsType eventType;

        /// <include file='doc\ContainerSelectorActiveEvent.uex' path='docs/doc[@for="ContainerSelectorActiveEventArgs.ContainerSelectorActiveEventArgs"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the 'ContainerSelectorActiveEventArgs'
        ///       class.
        ///    </para>
        /// </devdoc>
        public ContainerSelectorActiveEventArgs(object component) : this(component, ContainerSelectorActiveEventArgsType.Mouse) {
        }

        /// <include file='doc\ContainerSelectorActiveEvent.uex' path='docs/doc[@for="ContainerSelectorActiveEventArgs.ContainerSelectorActiveEventArgs1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the 'ContainerSelectorActiveEventArgs'
        ///       class.
        ///    </para>
        /// </devdoc>
        public ContainerSelectorActiveEventArgs(object component, ContainerSelectorActiveEventArgsType eventType) {
            this.component = component;
            this.eventType = eventType;
        }
        
        /// <include file='doc\ContainerSelectorActiveEvent.uex' path='docs/doc[@for="ContainerSelectorActiveEventArgs.Component"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the
        ///       component related to the event.
        ///    </para>
        /// </devdoc>
        public object Component {
            get {
                return component;
            }
        }

        /// <include file='doc\ContainerSelectorActiveEvent.uex' path='docs/doc[@for="ContainerSelectorActiveEventArgs.EventType"]/*' />
        /// <devdoc>
        /// </devdoc>
        public ContainerSelectorActiveEventArgsType EventType {
            get {
                return eventType;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\containerselectoractiveeventtype.cs ===
//------------------------------------------------------------------------------
// <copyright file="ContainerSelectorActiveEventType.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms.Design {
    using System.Runtime.Remoting;
    using System.Diagnostics;
    using System;
    using System.ComponentModel;
    using Microsoft.Win32;

    /// <include file='doc\ContainerSelectorActiveEventType.uex' path='docs/doc[@for="ContainerSelectorActiveEventArgsType"]/*' />
    /// <internalonly/>
    /// <devdoc>
    ///    <para>
    ///       Specifies IDs for containers of certain event types.
    ///    </para>
    /// </devdoc>
    internal enum ContainerSelectorActiveEventArgsType {
        /// <include file='doc\ContainerSelectorActiveEventType.uex' path='docs/doc[@for="ContainerSelectorActiveEventArgsType.Contextmenu"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates
        ///       the container of the active event was the contextmenu.
        ///    </para>
        /// </devdoc>
        Contextmenu = 1,
        /// <include file='doc\ContainerSelectorActiveEventType.uex' path='docs/doc[@for="ContainerSelectorActiveEventArgsType.Mouse"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates
        ///       the container of the active event was the mouse.
        ///    </para>
        /// </devdoc>
        Mouse       = 2,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\containerselectoractiveeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="ContainerSelectorActiveEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms.Design {
    using System.ComponentModel;

    using System.Diagnostics;

    using System;

    /// <include file='doc\ContainerSelectorActiveEventHandler.uex' path='docs/doc[@for="ContainerSelectorActiveEventHandler"]/*' />
    /// <internalonly/>
    /// <devdoc>
    /// <para>Represents the method that will handle a ContainerSelectorActive event.</para>
    /// </devdoc>
    internal delegate void ContainerSelectorActiveEventHandler(object sender, ContainerSelectorActiveEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\controlbindingsconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="ControlBindingsConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms.Design {

    using System;
    using Microsoft.Win32;
    using System.Collections;
    using System.ComponentModel;
    using System.Globalization;

    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class ControlBindingsConverter : TypeConverter {

        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
            if (destinationType == typeof(string)) {
                // return "(Bindings)";
                // return an empty string, since we don't want a meaningless
                // string displayed as the value for the expandable Bindings property
                return "";
            }
            return base.ConvertTo(context, culture, value, destinationType);
        }

        public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes) {
            if (value is ControlBindingsCollection) {
                ControlBindingsCollection collection = (ControlBindingsCollection)value;
                Control control = collection.Control;
                Type type = control.GetType();

                PropertyDescriptorCollection bindableProperties = TypeDescriptor.GetProperties(control, null);
                ArrayList props = new ArrayList();
                for (int i = 0; i < bindableProperties.Count; i++) {
                    DesignBindingPropertyDescriptor property = new DesignBindingPropertyDescriptor(bindableProperties[i], null);
                    bool bindable = ((BindableAttribute)bindableProperties[i].Attributes[typeof(BindableAttribute)]).Bindable;
                    if (bindable || !((DesignBinding)property.GetValue(collection)).IsNull) {                       
                        props.Add(property);
                    }                   
                } 

                props.Add(new AdvancedBindingPropertyDescriptor());
                PropertyDescriptor[] propArray = new PropertyDescriptor[props.Count];
                props.CopyTo(propArray,0);
                return new PropertyDescriptorCollection(propArray);
            }                  
            return new PropertyDescriptorCollection(new PropertyDescriptor[0]);
        }
        
        public override bool GetPropertiesSupported(ITypeDescriptorContext context) {
            return true;
        } 
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\axwrappergen.cs ===
//------------------------------------------------------------------------------
// <copyright file="AxWrapperGen.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   AxWrapperGen.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Windows.Forms.Design {
    using System.Design;
    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;
    using System.IO;
    using Microsoft.Win32;
    using System.CodeDom;
    using System.CodeDom.Compiler;
    using System.Collections;
    using System.Reflection;
    using System.ComponentModel;
    using System.Windows.Forms;
    using System.Globalization;
    
    /// <include file='doc\AxWrapperGen.uex' path='docs/doc[@for="AxWrapperGen"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Generates a wrapper for ActiveX controls for use in the design-time
    ///       environment.
    ///    </para>
    /// </devdoc>
    /// <internalonly/>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public class AxWrapperGen {
        private String axctlIface;
        private Type   axctlType;
        private Guid   clsidAx;
    
        private String axctlEvents;
        private Type   axctlEventsType;
    
        private String axctl;
        private static String axctlNS;
    
        private string memIface = null;
        private string multicaster = null;
        private string cookie = null;
    
        private bool dispInterface = false;
        private bool enumerableInterface = false;

        private string defMember = null; // Default Member (used for DefaultProperty attribute)
        
        private string aboutBoxMethod = null; // Method name that handles the AboutBox().

        private CodeFieldReferenceExpression memIfaceRef = null;
        private CodeFieldReferenceExpression multicasterRef = null;
        private CodeFieldReferenceExpression cookieRef = null;
    
        private ArrayList events = null;
        /// <include file='doc\AxWrapperGen.uex' path='docs/doc[@for="AxWrapperGen.GeneratedSources"]/*' />
        public static ArrayList GeneratedSources = new ArrayList();
    
        private static Guid Guid_DataSource = new Guid("{7C0FFAB3-CD84-11D0-949A-00A0C91110ED}");

        internal static BooleanSwitch AxWrapper = new BooleanSwitch("AxWrapper", "ActiveX WFW wrapper generation.");
        internal static BooleanSwitch AxCodeGen = new BooleanSwitch("AxCodeGen", "ActiveX WFW property generation.");
    
        // Attributes to add the NoBrowse/NoPersis attributes to selected properties.
        private static CodeAttributeDeclaration nobrowse    = null;
        private static CodeAttributeDeclaration browse      = null;
        private static CodeAttributeDeclaration nopersist   = null;
        private static CodeAttributeDeclaration bindable    = null;
        private static CodeAttributeDeclaration defaultBind = null;

        // Optimization caches.
        //
        private Hashtable axctlTypeMembers;
        private Hashtable axHostMembers;
        private Hashtable conflictableThings;
        private static Hashtable classesInNamespace;
        private static Hashtable axHostPropDescs;

        private ArrayList dataSourceProps = new ArrayList();

        /// <include file='doc\AxWrapperGen.uex' path='docs/doc[@for="AxWrapperGen.AxWrapperGen"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public AxWrapperGen(Type axType) {
            axctl = axType.Name;
            axctl = axctl.TrimStart(new char[]{'_', '1'});
            axctl = "Ax" + axctl;
            clsidAx = axType.GUID;

            Debug.WriteLineIf(AxWrapper.Enabled, "Found " + axctl + " as the ActiveX control. Guid: " + clsidAx.ToString() + " on : " + axType.FullName);

            object[] custom = axType.GetCustomAttributes(typeof(ComSourceInterfacesAttribute), false);
            
            // If we didn't find the attribute on the class itself, let's see if we can find it on
            // the base type, if the base type happens to be an internal tlbimp helper class.
            //
            if (custom.Length == 0 && axType.BaseType.GUID.Equals(axType.GUID)) {
                custom = axType.BaseType.GetCustomAttributes(typeof(ComSourceInterfacesAttribute), false);
                Debug.WriteLineIf(custom.Length > 0 && AxWrapper.Enabled, "Found ComSourceInterfacesAttribute in baseType: " + axType.BaseType);
            }

            if (custom.Length > 0) {
                ComSourceInterfacesAttribute coms = (ComSourceInterfacesAttribute)custom[0];

                // The string is a \0 delimited string containing all interfaces implemented on this
                // COM object. The first one is the default events interface.
                int indexIntf = coms.Value.IndexOfAny(new char[]{(char)0});
                Debug.Assert(indexIntf != -1, "Did not find delimiter in events name string: " + coms.Value);

                string eventName = coms.Value.Substring(0, indexIntf);
                axctlEventsType = axType.Module.Assembly.GetType(eventName);
                axctlEvents = axctlEventsType.FullName;

                Debug.Assert(axctlEventsType != null, "Could not get event interface: " + coms.Value);
                Debug.WriteLineIf(AxWrapper.Enabled, "Assigned: " + axctlEvents + " as events interface");
            }
            else
                Debug.WriteLineIf(AxWrapper.Enabled, "No Events Interface defined for: " + axType.Name);

            Type[] interfaces = axType.GetInterfaces();
            axctlType = interfaces[0];
            
            // Look to see if this interface has a CoClassAttribute. If it does this
            // means that this is a helper interface that in turn derives from the
            // default OCX interface.
            //
            foreach(Type iface in interfaces) {
                custom = iface.GetCustomAttributes(typeof(CoClassAttribute), false);
                if (custom.Length > 0) {
                    Type[] ifaces = iface.GetInterfaces();
                    Debug.Assert(ifaces != null && ifaces.Length > 0, "No interfaces implemented on the CoClass");

                    if (ifaces != null && ifaces.Length > 0) {
                        axctl = "Ax" + iface.Name;
                        axctlType = ifaces[0];
                        break;
                    }
                }
            }
            
            axctlIface = axctlType.Name;
            Debug.WriteLineIf(AxWrapper.Enabled, "Assigned: " + axctlIface + " as default interface");

            // Check to see if we want to implement IEnumerable on the ActiveX wrapper.
            //
            foreach(Type t in interfaces) {
                if (t == typeof(System.Collections.IEnumerable)) {
                    Debug.WriteLineIf(AxWrapper.Enabled, "ActiveX control " + axctlType.FullName + " implements IEnumerable");
                    enumerableInterface = true;
                    break;
                }
            }

            try {
                // Check to see if the default interface is disp-only.
                custom = axctlType.GetCustomAttributes(typeof(InterfaceTypeAttribute), false);
                if (custom.Length > 0) {
                    InterfaceTypeAttribute intfType = (InterfaceTypeAttribute)custom[0];
                    dispInterface = (intfType.Value == ComInterfaceType.InterfaceIsIDispatch);
                }
            }
            catch(MissingMethodException) {
                Debug.WriteLineIf(AxWrapper.Enabled, "The EE is not able to find the right ctor for InterfaceTypeAttribute");
            }
        }
        
        private Hashtable AxHostMembers {
            get {
                if (axHostMembers == null)
                    FillAxHostMembers();
                return axHostMembers;
            }
        }

        private Hashtable ConflictableThings {
            get {
                if (conflictableThings == null)
                    FillConflicatableThings();
                return conflictableThings;
            }
        }

        private void AddClassToNamespace(CodeNamespace ns, CodeTypeDeclaration cls) {
            if (classesInNamespace == null) {
                classesInNamespace = new Hashtable();
            }

            try {
                ns.Types.Add(cls);
                classesInNamespace.Add(cls.Name, cls);
            }
            catch(Exception e) {
                Debug.Fail("Failed to add " + cls.Name + " to types in Namespace. " + e);
            }
        }

        private EventEntry AddEvent(string name, string eventCls, string eventHandlerCls, Type retType, AxParameterData[] parameters) {
            if (events == null)
                events = new ArrayList();
            
            if (axctlTypeMembers == null) {
                axctlTypeMembers = new Hashtable();
                
                Type t = axctlType;

                MemberInfo[] members = t.GetMembers();
                foreach(MemberInfo member in members) {
                    string memberName = member.Name;
                    if (!axctlTypeMembers.Contains(memberName)) {
                        axctlTypeMembers.Add(memberName, member);
                    }
                }
            }

            bool contain = axctlTypeMembers.Contains(name) || AxHostMembers.Contains(name) || ConflictableThings.Contains(name);
            EventEntry entry = new EventEntry(name, eventCls, eventHandlerCls, retType, parameters, contain);
            events.Add(entry);
            return entry;
        }
    
        private bool ClassAlreadyExistsInNamespace(CodeNamespace ns, string clsName) {
            return classesInNamespace.Contains(clsName);
        }

        private static string Compile(AxImporter importer, CodeNamespace ns, string[] refAssemblies, DateTime tlbTimeStamp, Version version) {
            CodeDomProvider codeProvider = new Microsoft.CSharp.CSharpCodeProvider();
            ICodeGenerator codegen = codeProvider.CreateGenerator();

            // Build up the name of the output dll and the command line for the compiler.
            //
            string outputFileName = importer.options.outputName;
            Debug.Assert(outputFileName != null, "No output filename!!!");

            string outputName = Path.Combine(importer.options.outputDirectory, outputFileName);
            string fileName = Path.ChangeExtension(outputName, ".cs");
            
            CompilerParameters cparams = new CompilerParameters(refAssemblies, outputName);
            cparams.IncludeDebugInformation = importer.options.genSources;
            CodeCompileUnit cu = new CodeCompileUnit();
            cu.Namespaces.Add(ns);

            CodeAttributeDeclarationCollection assemblyAttributes = cu.AssemblyCustomAttributes;
            assemblyAttributes.Add(new CodeAttributeDeclaration("System.Reflection.AssemblyVersion", new CodeAttributeArgument(new CodePrimitiveExpression(version.ToString()))));
            assemblyAttributes.Add(new CodeAttributeDeclaration("System.Windows.Forms.AxHost.TypeLibraryTimeStamp", new CodeAttributeArgument(new CodePrimitiveExpression(tlbTimeStamp.ToString()))));
            if (importer.options.delaySign) {                    
                assemblyAttributes.Add(new CodeAttributeDeclaration("System.Reflection.AssemblyDelaySign", new CodeAttributeArgument(new CodePrimitiveExpression(true))));
            }
            if (importer.options.keyFile != null && importer.options.keyFile.Length > 0) {
                assemblyAttributes.Add(new CodeAttributeDeclaration("System.Reflection.AssemblyKeyFile", new CodeAttributeArgument(new CodePrimitiveExpression(importer.options.keyFile))));    
            }
            if (importer.options.keyContainer != null && importer.options.keyContainer.Length > 0) {
                assemblyAttributes.Add(new CodeAttributeDeclaration("System.Reflection.AssemblyKeyName", new CodeAttributeArgument(new CodePrimitiveExpression(importer.options.keyContainer))));    
            }

            // Compile the file into a DLL.
            //
            CompilerResults results;
            
            if (importer.options.genSources) {
                Debug.WriteLineIf(AxWrapperGen.AxWrapper.Enabled, "Compiling " + ns.Name + ".cs" + " to " + outputName);
                SaveCompileUnit(codegen, cu, fileName);
                results = ((ICodeCompiler)codegen).CompileAssemblyFromFile(cparams, fileName);
            }
            else {
                results = ((ICodeCompiler)codegen).CompileAssemblyFromDom(cparams, cu);
            }
            
            // Walk through any errors and warnings and build up the correct exception string if needed.
            //
            if (results.Errors != null && results.Errors.Count > 0) {
                string errorText = null;
                CompilerErrorCollection errors = results.Errors;
                
                Debug.WriteLineIf(AxWrapperGen.AxWrapper.Enabled, "Errors#: " + errors.Count);
                foreach(CompilerError err in errors) {
                    Debug.WriteLineIf(AxWrapperGen.AxWrapper.Enabled, err.ToString());

                    // Skip warnings...
                    //
                    if (!err.IsWarning)
                        errorText = errorText + err.ToString() + "\r\n";
                }
            
                if (errorText != null) {
                    SaveCompileUnit(codegen, cu, fileName);
                    errorText = SR.GetString(SR.AXCompilerError, ns.Name, fileName) + "\r\n" + errorText;
                    throw new Exception(errorText);
                }
            }
            
            return outputName;
        }
    
        private string CreateDataSourceFieldName(string propName) {
            return "ax" + propName;
        }

        private CodeParameterDeclarationExpression CreateParamDecl(string type, string name, bool isOptional) {
            CodeParameterDeclarationExpression paramDecl = new CodeParameterDeclarationExpression(type, name);
            
            if (!isOptional)
                return paramDecl;

            CodeAttributeDeclarationCollection paramAttrs = new CodeAttributeDeclarationCollection();
            paramAttrs.Add(new CodeAttributeDeclaration("System.Runtime.InteropServices.Optional", new CodeAttributeArgument[0]));
            paramDecl.CustomAttributes = paramAttrs;
            return paramDecl;
        }

        private CodeConditionStatement CreateValidStateCheck() {
            CodeConditionStatement ifstat = new CodeConditionStatement();
            CodeBinaryOperatorExpression cond1;
            CodeBinaryOperatorExpression cond2;
            CodeBinaryOperatorExpression condAnd;

            cond1 = new CodeBinaryOperatorExpression(memIfaceRef, CodeBinaryOperatorType.IdentityInequality, new CodePrimitiveExpression(null));
            cond2 = new CodeBinaryOperatorExpression(new CodeMethodInvokeExpression(new CodeThisReferenceExpression(), "PropsValid"),
                                                     CodeBinaryOperatorType.IdentityEquality,
                                                     new CodePrimitiveExpression(true));
            condAnd = new CodeBinaryOperatorExpression(cond1, CodeBinaryOperatorType.BooleanAnd, cond2);

            ifstat = new CodeConditionStatement();
            ifstat.Condition = condAnd;
            return ifstat;
        }

        private CodeStatement CreateInvalidStateException(string name, string kind) {
            CodeBinaryOperatorExpression cond = new CodeBinaryOperatorExpression(memIfaceRef,
                                                                                 CodeBinaryOperatorType.IdentityEquality,
                                                                                 new CodePrimitiveExpression(null));
            CodeConditionStatement ifstat = new CodeConditionStatement();
            ifstat.Condition = cond;

            CodeExpression[] createParams = new CodeExpression[] {
                new CodePrimitiveExpression(name),
                new CodeFieldReferenceExpression(new CodeFieldReferenceExpression(null, typeof(AxHost).FullName + ".ActiveXInvokeKind"), kind)
            };

            CodeObjectCreateExpression invalidState = new CodeObjectCreateExpression(typeof(AxHost.InvalidActiveXStateException).FullName, createParams);
            
            ifstat.TrueStatements.Add(new CodeThrowExceptionStatement(invalidState));
            return ifstat;
        }

        private void FillAxHostMembers() {
            if (axHostMembers == null) {
                axHostMembers = new Hashtable(CaseInsensitiveHashCodeProvider.Default, CaseInsensitiveComparer.Default);

                Type t = typeof(AxHost);

                MemberInfo[] members = t.GetMembers();
                foreach(MemberInfo member in members) {
                    string memberName = member.Name;
                    
                    if (!axHostMembers.Contains(memberName)) {
                        // Check to see if this is a field
                        //
                        FieldInfo fi = member as FieldInfo;
                        if (fi != null && !fi.IsPrivate) {
                            axHostMembers.Add(memberName, member);
                            continue;
                        }

                        // Check to see if this is a property
                        //
                        PropertyInfo pi = member as PropertyInfo;
                        if (pi != null) {
                            axHostMembers.Add(memberName, member);
                            continue;
                        }

                        // Check to see if this is a ctor or method.
                        //
                        MethodBase mb = member as MethodBase;
                        if (mb != null && !mb.IsPrivate) {
                            axHostMembers.Add(memberName, member);
                            continue;
                        }

                        // Check to see if this is a ctor or method.
                        //
                        EventInfo ei = member as EventInfo;
                        if (ei != null) {
                            axHostMembers.Add(memberName, member);
                            continue;
                        }
                    
                        // Check to see if this is a ctor or method.
                        //
                        Type type = member as Type;
                        if (type != null && (type.IsPublic || type.IsNestedPublic)) {
                            axHostMembers.Add(memberName, member);
                            continue;
                        }

                        Debug.Fail("Failed to process AxHost member " + member.ToString() + " " + member.GetType().FullName);
                        axHostMembers.Add(memberName, member);
                    }
                }
            }
        }

        private void FillConflicatableThings() {
            if (conflictableThings == null) {
                conflictableThings = new Hashtable();
                conflictableThings.Add("System", "System");
            }
        }

        private static void SaveCompileUnit(ICodeGenerator codegen, CodeCompileUnit cu, string fileName) {
            // Persist to file.
            Debug.WriteLineIf(AxWrapperGen.AxWrapper.Enabled, "Generating source file: " + fileName);
            try {
                try {
                    if (File.Exists(fileName))
                        File.Delete(fileName);
                }
                catch {
                    Debug.WriteLineIf(AxWrapperGen.AxWrapper.Enabled, "Could not delete: " + fileName);
                }

                FileStream file = new FileStream(fileName, FileMode.OpenOrCreate, FileAccess.ReadWrite);
                StreamWriter stream = new StreamWriter(file, new System.Text.UTF8Encoding(false));
                codegen.GenerateCodeFromCompileUnit(cu, stream, null);
                stream.Flush();
                stream.Close();
                file.Close();
                GeneratedSources.Add( fileName );
                Debug.WriteLineIf(AxWrapperGen.AxWrapper.Enabled, "Generated source file: " + fileName);
            }
            catch (Exception e) {
                Debug.WriteLineIf(AxWrapperGen.AxWrapper.Enabled, "Exception generating source file: " + e.ToString());
            }
        }
        
        internal static string MapTypeName(Type type) {
            bool isArray = type.IsArray;

            Type baseType = type.GetElementType();
            if (baseType != null)
                type = baseType;
            
            string typeName = type.FullName;
            return (isArray) ? (typeName + "[]") : typeName;
        }
        
        private static bool IsTypeActiveXControl(Type type) {
            if (type.IsClass && type.IsCOMObject && type.IsPublic && !type.GUID.Equals(Guid.Empty)) {

                // Check to see if the type is ComVisible. Otherwise, this is a internal helper type from tlbimp.
                //
                try {
                    object[] attrs = type.GetCustomAttributes(typeof(ComVisibleAttribute), false);
                    if (attrs.Length != 0 && ((ComVisibleAttribute)attrs[0]).Value == false) {
                        return false;
                    }
                }
                catch {
                    return false;
                }
                
                // Look for the Control key under the Classes_Root\CLSID to see if this is the ActiveX control.
                //
                Guid clsid = type.GUID;
                string controlKey = "CLSID\\{" + clsid.ToString() + "}\\Control";
                RegistryKey k = Registry.ClassesRoot.OpenSubKey(controlKey);
                if (k == null)
                    return false;
                
                k.Close();
                Debug.WriteLineIf(AxWrapper.Enabled, "Found key: " + controlKey);

                // Make sure this type implements atleast the default interface.
                //
                Type[] ifaces = type.GetInterfaces();
                Debug.WriteLineIf(ifaces.Length < 1 && AxWrapper.Enabled, "Not even one interface implemented on: " + type.FullName);

                if (ifaces != null && ifaces.Length >= 1)
                    return true;
            }

            return false;
        }

        /// <include file='doc\AxWrapperGen.uex' path='docs/doc[@for="AxWrapperGen.GenerateWrappers"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        internal static string GenerateWrappers(AxImporter importer, Guid axClsid, Assembly rcwAssem, string[] refAssemblies, DateTime tlbTimeStamp, out string assem) {
            assem = null;

            bool fFoundClass = false;
            CodeNamespace ns = null;
            string retAxCtlName = null;

            string axctlDll = rcwAssem.GetName().Name;
            if (axctlDll.EndsWith(".dll") || axctlDll.EndsWith(".mcl"))
                axctlDll = axctlDll.Substring(0, axctlDll.Length - 4);
            
            try {
                Type[] types = rcwAssem.GetTypes();
                for (int i = 0; i < types.Length; ++i) {
                    if (IsTypeActiveXControl(types[i])) {
                        fFoundClass = true;

                        // Create a namespace for the AxWrappers.
                        //
                        if (ns == null) {
                            // Determine the namespace for the ActiveX control wrappers.
                            //
                            axctlNS = "Ax" + types[i].Namespace;
                            ns = new CodeNamespace(axctlNS);
                        }

                        // Generate code for the ActiveX control wrapper.
                        //
                        AxWrapperGen axwrapper = new AxWrapperGen(types[i]);
                        axwrapper.GenerateAxHost(ns, refAssemblies);

                        // If we are given a specific GUID, then we should return the type for that control,
                        // otherwise, we will return the type of the first ActiveX control that we generate
                        // wrapper for.
                        //
                        if (!axClsid.Equals(Guid.Empty) && axClsid.Equals(types[i].GUID)) {
                            Debug.Assert(retAxCtlName == null, "Two controls match the same GUID... " + retAxCtlName + " and " + types[i].FullName);
                            retAxCtlName = axwrapper.axctl;
                        }
                        else if (axClsid.Equals(Guid.Empty) && retAxCtlName == null) {
                            retAxCtlName = axwrapper.axctl;
                        }
                    }
                }
            }
            finally {
                if (classesInNamespace != null) {
                    classesInNamespace.Clear();
                    classesInNamespace = null;
                }
            }
    
            if (fFoundClass) {
                // Now that we found atleast one ActiveX control, we should compile the namespace into
                // an assembly.
                //
                Debug.Assert(ns != null, "ActiveX control found but no code generated!!!!");
                
                Version version = rcwAssem.GetName().Version;
                assem = Compile(importer, ns, refAssemblies, tlbTimeStamp, version);
                
                // Return the type of the ActiveX control.
                //
                if (assem != null) {
                    if (retAxCtlName == null)
                        throw new Exception(SR.GetString(SR.AXNotValidControl, "{" + axClsid + "}"));

                    return axctlNS + "." + retAxCtlName + "," + axctlNS;
                }
            }
#if DEBUG
            else {
                Debug.WriteLineIf(AxWrapper.Enabled, "Did not find any ActiveX control in: " + axctlDll);
            }
#endif // DEBUG
            
            return null;
        }
    
        private void GenerateAxHost(CodeNamespace ns, string[] refAssemblies) {
            CodeTypeDeclaration cls = new CodeTypeDeclaration();
            cls.Name = axctl;
            cls.BaseTypes.Add(typeof(AxHost).FullName);

            if (enumerableInterface) {
                cls.BaseTypes.Add(typeof(System.Collections.IEnumerable));
            }

            CodeAttributeDeclarationCollection clsAttrs = new CodeAttributeDeclarationCollection();
            
            CodeAttributeDeclaration guidAttr = new CodeAttributeDeclaration(typeof(System.Windows.Forms.AxHost.ClsidAttribute).FullName,
                                                         new CodeAttributeArgument[] {new CodeAttributeArgument(new CodeSnippetExpression("\"{" + clsidAx.ToString() + "}\""))});
            
            clsAttrs.Add(guidAttr);

            // Generate the DesignTimeVisible attribute so that the control shows up in the toolbox.
            //

            CodeAttributeDeclaration designAttr = new CodeAttributeDeclaration(typeof(System.ComponentModel.DesignTimeVisibleAttribute).FullName,
                                                         new CodeAttributeArgument[] {new CodeAttributeArgument(new CodePrimitiveExpression(true))});

            clsAttrs.Add(designAttr);
            
            cls.CustomAttributes = clsAttrs;

            // See if there is a DefaultAttribute on the interface. If so, convert it to a DefaultPropertyAttribute.
            object[] attr = axctlType.GetCustomAttributes(typeof(System.Reflection.DefaultMemberAttribute), true);
            if (attr != null && attr.Length > 0) {
                defMember = ((DefaultMemberAttribute)attr[0]).MemberName;
            }

            AddClassToNamespace(ns, cls);
    
            WriteMembersDecl(cls);
    
            if (axctlEventsType != null) {
                WriteEventMembersDecl(ns, cls);
            }
    
            CodeConstructor ctor = WriteConstructor(cls);
    
            WriteProperties(cls);
            WriteMethods(cls);
    
            WriteHookupMethods(cls);
    
            // Hookup the AboutBox delegate if one exists for this control.
            //
            if (aboutBoxMethod != null) {
                CodeObjectCreateExpression aboutDelegate = new CodeObjectCreateExpression("AboutBoxDelegate");
                aboutDelegate.Parameters.Add(new CodeFieldReferenceExpression(null, aboutBoxMethod));

                CodeMethodInvokeExpression aboutAdd = new CodeMethodInvokeExpression(new CodeThisReferenceExpression(), "SetAboutBoxDelegate");
                aboutAdd.Parameters.Add(aboutDelegate);

                ctor.Statements.Add(new CodeExpressionStatement(aboutAdd));
            }

            if (axctlEventsType != null)
                WriteEvents(ns, cls);

            // If there is a need to generate a override for OnInPlaceActive()
            // do it now.
            //
            if (dataSourceProps.Count > 0) {
                WriteOnInPlaceActive(cls);
            }
        }
    
        private CodeExpression GetInitializer(Type type) {
            if (type == null)
                return new CodePrimitiveExpression(null);
            else if (type == typeof(Int32) || type == typeof(short) || type == typeof(Int64) || type == typeof(Single) || type == typeof(Double))
                return new CodePrimitiveExpression(0);
            else if (type == typeof(char))
                return new CodeCastExpression("System.Character", new CodePrimitiveExpression(0));
            else if (type == typeof(bool))
                return new CodePrimitiveExpression(false);
            else
                return new CodePrimitiveExpression(null);
        }
    
        private bool IsDispidKnown(int dp, string propName) {
            return dp == NativeMethods.ActiveX.DISPID_FORECOLOR ||
                   dp == NativeMethods.ActiveX.DISPID_BACKCOLOR ||
                   dp == NativeMethods.ActiveX.DISPID_FONT ||
                   dp == NativeMethods.ActiveX.DISPID_ENABLED ||
                   dp == NativeMethods.ActiveX.DISPID_TABSTOP ||
                   dp == NativeMethods.ActiveX.DISPID_RIGHTTOLEFT ||
                   dp == NativeMethods.ActiveX.DISPID_TEXT ||
                   dp == NativeMethods.ActiveX.DISPID_HWND ||
                   (dp == NativeMethods.ActiveX.DISPID_VALUE && propName.Equals(defMember));
        }

        private bool IsEventPresent(MethodInfo mievent) {
            //return TypeDescriptor.GetEvent(typeof(AxHost), eventsRef[i].Name) != null;

            return false;

            /*
            Type axHostType = typeof(AxHost);
            ParameterInfo[] parameters = mievent.GetParameters();
    
            Type[] paramList = new Type[parameters.Length];
            for (int i = 0; i < parameters.Length; ++i)
                paramList[i] = parameters[i].ParameterType;
    
            try {
                MethodInfo mi = axHostType.GetMethod("RaiseOn" + mievent.Name, paramList);
                bool f = (mi != null) && (mi.ReturnType == mievent.ReturnType);
                return f;
            }
            catch (AmbiguousMatchException) {
                return true;
            }
            */
        }
    
        private bool IsPropertyBindable(PropertyInfo pinfo, out bool isDefaultBind) {
            isDefaultBind = false;

            MethodInfo getter = pinfo.GetGetMethod();
            if (getter == null)
                return false;
            
            object[] attr = getter.GetCustomAttributes(typeof(TypeLibFuncAttribute), false);
            if (attr != null && attr.Length > 0) {
                TypeLibFuncFlags flags = ((TypeLibFuncAttribute)attr[0]).Value;
                
                isDefaultBind = ((int)flags & (int)TypeLibFuncFlags.FDefaultBind) != 0;
                
                if (isDefaultBind || ((int)flags & (int)TypeLibFuncFlags.FBindable) != 0) {
                    return true;
                }
            }

            return false;
        }

        private bool IsPropertyBrowsable(PropertyInfo pinfo, ComAliasEnum alias) {
            MethodInfo getter = pinfo.GetGetMethod();
            if (getter == null)
                return false;
            
            object[] attr = getter.GetCustomAttributes(typeof(TypeLibFuncAttribute), false);
            if (attr != null && attr.Length > 0) {
                TypeLibFuncFlags flags = ((TypeLibFuncAttribute)attr[0]).Value;
                if (((int)flags & (int)TypeLibFuncFlags.FNonBrowsable) != 0 || ((int)flags & (int)TypeLibFuncFlags.FHidden) != 0) {
                    return false;
                }
            }

            // Hide all properties that have COM objects that are not of the DataSource type
            // and do not have their type converted to a Windows Forms type.
            //
            Type t = pinfo.PropertyType;
            if (alias == ComAliasEnum.None && t.IsInterface && !t.GUID.Equals(Guid_DataSource)) {
                return false;
            }

            return true;
        }
    
        private bool IsPropertySignature(PropertyInfo pinfo, out bool useLet) {
            int nParams = 0;
            bool isProperty = true;

            useLet = false;

            // Handle Indexed properties.
            string defProp = ((defMember == null) ? "Item" : defMember);
            if (pinfo.Name.Equals(defProp))
                nParams = pinfo.GetIndexParameters().Length;
    
            if (pinfo.GetGetMethod() != null)
                isProperty = IsPropertySignature(pinfo.GetGetMethod(), pinfo.PropertyType, true, nParams);
            if (pinfo.GetSetMethod() != null) {
                isProperty = isProperty && IsPropertySignature(pinfo.GetSetMethod(), pinfo.PropertyType, false, nParams + 1);

                if (!isProperty) {
                    MethodInfo letMethod = pinfo.DeclaringType.GetMethod("let_" + pinfo.Name, BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly);
                    if (letMethod != null) {
                        isProperty = IsPropertySignature(letMethod, pinfo.PropertyType, false, nParams + 1);
                        useLet = true;
                    }
                }
            }
    
            return isProperty;
        }

        private bool IsPropertySignature(MethodInfo method, out bool hasPropInfo, out bool useLet) {
            useLet = false;
            hasPropInfo = false;

            bool getter = method.Name.StartsWith("get_");
            if (!getter && !method.Name.StartsWith("set_") && !method.Name.StartsWith("let_"))
                return false;
            
            string propName = method.Name.Substring(4, method.Name.Length - 4);
            PropertyInfo pinfo = axctlType.GetProperty(propName, BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly);
            
            Debug.Assert(pinfo != null, "No property found for:" + propName);
            if (pinfo == null)
                return false;
            
            return IsPropertySignature(pinfo, out useLet);
        }
    
        private bool IsPropertySignature(MethodInfo method, Type returnType, bool getter, int nParams) {
            if (method.IsConstructor) return false;
    
            // If there is a property of the same name, we handle it differently.
            if (getter) {
                Debug.Assert(method.Name.StartsWith("get_"), "Property get: " + method.Name + " does not start with get_!!!");
                String name = method.Name.Substring(4);
                if (axctlType.GetProperty(name) != null && method.GetParameters().Length == nParams)
                    return method.ReturnType == returnType;
            }
            else {
                Debug.Assert(method.Name.StartsWith("set_") || method.Name.StartsWith("let_"), "Property set: " + method.Name + " does not start with set_ or a let_!!!");
                String name = method.Name.Substring(4);
                ParameterInfo[] parameters = method.GetParameters();
                if (axctlType.GetProperty(name) != null && parameters.Length == nParams) {
                    if (parameters.Length > 0)
                        return parameters[parameters.Length-1].ParameterType == returnType ||
                            (method.Name.StartsWith("let_") && parameters[parameters.Length-1].ParameterType == typeof(object));
                    return true;
                }
            }
    
            return false;
        }
    
        private string ResolveConflict(string name, Type returnType, out bool fOverride, out bool fUseNew) {
            fOverride = false;
            fUseNew = false;

            string prefix = "";
            try {
                if (axHostPropDescs == null) {
                    axHostPropDescs = new Hashtable();
                    
                    PropertyInfo[] props = typeof(AxHost).GetProperties();
                    foreach(PropertyInfo prop in props) {
                        axHostPropDescs.Add(prop.Name + prop.PropertyType.GetHashCode(), prop);
                    }
                }

                PropertyInfo pinfo = (PropertyInfo)axHostPropDescs[name + returnType.GetHashCode()];
                if (pinfo != null) {
                    if (returnType.Equals(pinfo.PropertyType)) {
                        bool isVirtual = false;
                        isVirtual = (pinfo.CanRead) ? pinfo.GetGetMethod().IsVirtual : false;

                        if (isVirtual)
                            fOverride = true;
                        else
                            fUseNew = true;
                    }
                    else {
                        prefix = "Ctl";
                    }
                }
                else {
                    if (AxHostMembers.Contains(name) || ConflictableThings.Contains(name)) {
                        prefix = "Ctl";
                    }
                    else {
                        if (name.StartsWith("get_") || name.StartsWith("set_")) {
                            if (TypeDescriptor.GetProperties(typeof(AxHost))[name.Substring(4)] != null)
                               prefix = "Ctl";
                        }
                    }
                }
            }
            catch (AmbiguousMatchException) {
                prefix = "Ctl";
            }
    
    #if DEBUG
            if (fOverride)
                Debug.Assert(prefix.Length == 0, "Have override and Ctl prefix for: " + name);
            if (fUseNew)
                Debug.Assert(prefix.Length == 0, "Have new and Ctl prefix for: " + name);
            if (AxCodeGen.Enabled && prefix.Length != 0) Debug.WriteLine("Resolved conflict for: " + name);
            if (AxCodeGen.Enabled && fOverride) Debug.WriteLine("Resolved conflict for: " + name + " through override");
            if (AxCodeGen.Enabled && fUseNew) Debug.WriteLine("Resolved conflict for: " + name + " through new");
    #endif
            return prefix;
        }
    
        private CodeConstructor WriteConstructor(CodeTypeDeclaration cls) {
            CodeConstructor ctor = new CodeConstructor();
            ctor.Attributes = MemberAttributes.Public;
            
            ctor.BaseConstructorArgs.Add(new CodeSnippetExpression("\"" + clsidAx.ToString() + "\""));
            cls.Members.Add(ctor);
            return ctor;
        }
    
        private void WriteOnInPlaceActive(CodeTypeDeclaration cls) {
            CodeMemberMethod oipMeth = new CodeMemberMethod();
            oipMeth.Name = "OnInPlaceActive";
            oipMeth.Attributes = MemberAttributes.Family | MemberAttributes.Override;

            CodeMethodInvokeExpression baseOip = new CodeMethodInvokeExpression(new CodeBaseReferenceExpression(), "OnInPlaceActive");
            oipMeth.Statements.Add(new CodeExpressionStatement(baseOip));

            foreach(PropertyInfo pinfo in dataSourceProps) {
                string fieldName = CreateDataSourceFieldName(pinfo.Name);

                CodeBinaryOperatorExpression cond = new CodeBinaryOperatorExpression(new CodeFieldReferenceExpression(new CodeThisReferenceExpression(), fieldName),
                                                                                     CodeBinaryOperatorType.IdentityInequality,
                                                                                     new CodePrimitiveExpression(null));
                CodeConditionStatement ifstat = new CodeConditionStatement();
                ifstat.Condition = cond;

                CodeExpression left  = new CodeFieldReferenceExpression(memIfaceRef, pinfo.Name);
                CodeExpression right = new CodeFieldReferenceExpression(new CodeThisReferenceExpression(), fieldName);
                ifstat.TrueStatements.Add(new CodeAssignStatement(left, right));
            
                oipMeth.Statements.Add(ifstat);
            }

            cls.Members.Add(oipMeth);
        }

        private String WriteEventClass(CodeNamespace ns, MethodInfo mi, ParameterInfo[] pinfos) {
            String evntCls = axctlEventsType.Name + "_" + mi.Name + "Event";
            if (ClassAlreadyExistsInNamespace(ns, evntCls)) {
                return evntCls;
            }

            CodeTypeDeclaration cls = new CodeTypeDeclaration();
            cls.Name = evntCls;
    
            AxParameterData[] parameters = AxParameterData.Convert(pinfos);
            for (int i = 0; i < parameters.Length; ++i) {
                CodeMemberField field = new CodeMemberField(parameters[i].TypeName, parameters[i].Name);
                field.Attributes = MemberAttributes.Public | MemberAttributes.Final;
                cls.Members.Add(field);
            }
    
            CodeConstructor ctor = new CodeConstructor();
            ctor.Attributes = MemberAttributes.Public;
            
            for (int i = 0; i < parameters.Length; ++i) {
                if (parameters[i].Direction != FieldDirection.Out) {
                    ctor.Parameters.Add(CreateParamDecl(parameters[i].TypeName, parameters[i].Name, parameters[i].IsOptional));

                    CodeFieldReferenceExpression left = new CodeFieldReferenceExpression(new CodeThisReferenceExpression(), parameters[i].Name);
                    CodeFieldReferenceExpression right = new CodeFieldReferenceExpression(null, parameters[i].Name);
                    CodeAssignStatement assign = new CodeAssignStatement(left, right);
                    ctor.Statements.Add(assign);
                }
            }
            cls.Members.Add(ctor);
            AddClassToNamespace(ns, cls);
            return evntCls;
        }
    
        private String WriteEventHandlerClass(CodeNamespace ns, MethodInfo mi) {
            String evntCls = axctlEventsType.Name + "_" + mi.Name + "EventHandler";
            if (ClassAlreadyExistsInNamespace(ns, evntCls)) {
                return evntCls;
            }

            CodeTypeDelegate cls = new CodeTypeDelegate();
            cls.Name = evntCls;
            cls.Parameters.Add(CreateParamDecl(typeof(object).FullName, "sender", false));
            cls.Parameters.Add(CreateParamDecl(axctlEventsType.Name + "_" + mi.Name + "Event", "e", false));
            cls.ReturnType = new CodeTypeReference(mi.ReturnType);
    
            AddClassToNamespace(ns, cls);
            return evntCls;
        }
    
        private void WriteEventMembersDecl(CodeNamespace ns, CodeTypeDeclaration cls) {
            bool eventAttr = false;
            
            MethodInfo[] events = axctlEventsType.GetMethods(BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly);

            for (int i = 0; i < events.Length; ++i) {
                EventEntry entry = null;

                if (!IsEventPresent(events[i])) {
                    ParameterInfo[] parameters = events[i].GetParameters();

                    if (parameters.Length > 0 || events[i].ReturnType != typeof(void)) {
                        String eventHCls = WriteEventHandlerClass(ns, events[i]);
                        String eventCls = WriteEventClass(ns, events[i], parameters);
                        entry = AddEvent(events[i].Name, eventCls, eventHCls, events[i].ReturnType, AxParameterData.Convert(parameters));
                    }
                    else {
                        entry = AddEvent(events[i].Name, "System.EventArgs", "System.EventHandler", typeof(void), new AxParameterData[0]);
                    }
                }

                if (!eventAttr) {
                    object[] attrs = events[i].GetCustomAttributes(typeof(DispIdAttribute), false);
                    if (attrs == null || attrs.Length == 0) {
                        continue;
                    }
                    
                    DispIdAttribute dispid = (DispIdAttribute)attrs[0];
                    if (dispid.Value == 1) {
                        string eventName = (entry != null) ? entry.resovledEventName : events[i].Name;

                        CodeAttributeDeclaration defEventAttr = new CodeAttributeDeclaration("System.ComponentModel.DefaultEvent",
                                                                     new CodeAttributeArgument[] {new CodeAttributeArgument(new CodePrimitiveExpression(eventName))});
                        cls.CustomAttributes.Add(defEventAttr);
                        eventAttr = true;
                    }
                }
            }

            Debug.WriteLineIf(AxCodeGen.Enabled && !eventAttr, "No default event found for: " + axctlEventsType.FullName);
        }
    
        private string WriteEventMulticaster(CodeNamespace ns) {
            String evntCls = axctl + "EventMulticaster";
            if (ClassAlreadyExistsInNamespace(ns, evntCls)) {
                return evntCls;
            }

            CodeTypeDeclaration cls = new CodeTypeDeclaration();
            cls.Name = evntCls;
            cls.BaseTypes.Add(axctlEvents);
    
            CodeMemberField field = new CodeMemberField(axctl, "parent");
            field.Attributes = MemberAttributes.Private | MemberAttributes.Final;
            cls.Members.Add(field);
    
            CodeConstructor ctor = new CodeConstructor();
            ctor.Attributes = MemberAttributes.Public;
            ctor.Parameters.Add(CreateParamDecl(axctl, "parent", false));
    
            CodeFieldReferenceExpression right = new CodeFieldReferenceExpression(new CodeThisReferenceExpression(), "parent");
            CodeFieldReferenceExpression left  = new CodeFieldReferenceExpression(null, "parent");
            ctor.Statements.Add(new CodeAssignStatement(right, left));
            cls.Members.Add(ctor);
    
            MethodInfo[] eventsRef = axctlEventsType.GetMethods(BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly);
            int iEvent = 0;
            for (int i = 0; i < eventsRef.Length; ++i) {
                AxParameterData[] parameters = AxParameterData.Convert(eventsRef[i].GetParameters());
    
                CodeMemberMethod method = new CodeMemberMethod();
                method.Name = eventsRef[i].Name;
                method.Attributes = MemberAttributes.Public;
                method.ReturnType = new CodeTypeReference(MapTypeName(eventsRef[i].ReturnType));
    
                for (int iparam = 0; iparam < parameters.Length; ++iparam) {
                    CodeParameterDeclarationExpression param = CreateParamDecl(MapTypeName(parameters[iparam].ParameterType), parameters[iparam].Name, parameters[iparam].IsOptional);
                    param.Direction = parameters[iparam].Direction;
                    method.Parameters.Add(param);
                }
    
                CodeFieldReferenceExpression parent = new CodeFieldReferenceExpression(new CodeThisReferenceExpression(), "parent");
                if (!IsEventPresent(eventsRef[i])) {
                    EventEntry ee = (EventEntry)events[iEvent++];

                    Debug.Assert(eventsRef[i].Name.Equals(ee.eventName), "Not hadling the right event!!!");
    
                    CodeExpressionCollection paramstr = new CodeExpressionCollection();
                    paramstr.Add(parent);
                    if (ee.eventCls.Equals("EventArgs")) {
                        paramstr.Add(new CodeFieldReferenceExpression(new CodeFieldReferenceExpression(null, "EventArgs"), "Empty"));
                        
                        CodeExpression[] temp = new CodeExpression[paramstr.Count];
                        ((IList)paramstr).CopyTo(temp, 0);
                        CodeMethodInvokeExpression methodInvoke = new CodeMethodInvokeExpression(parent, ee.invokeMethodName, temp);
                        if (eventsRef[i].ReturnType == typeof(void)) {
                            method.Statements.Add(new CodeExpressionStatement(methodInvoke));
                        }
                        else {
                            method.Statements.Add(new CodeMethodReturnStatement(methodInvoke));
                        }
                    }
                    else {
                        CodeObjectCreateExpression create = new CodeObjectCreateExpression(ee.eventCls);
                        for (int iparam = 0; iparam < ee.parameters.Length; ++iparam) {
                            if (!ee.parameters[iparam].IsOut)
                                create.Parameters.Add(new CodeFieldReferenceExpression(null, ee.parameters[iparam].Name));
                        }
                        
                        CodeVariableDeclarationStatement evtfield = new CodeVariableDeclarationStatement(ee.eventCls, ee.eventParam);
                        evtfield.InitExpression = create;
                        method.Statements.Add(evtfield);
    
                        paramstr.Add(new CodeFieldReferenceExpression(null, ee.eventParam));
    
                        CodeExpression[] temp = new CodeExpression[paramstr.Count];
                        ((IList)paramstr).CopyTo(temp, 0);
                        CodeMethodInvokeExpression methodInvoke = new CodeMethodInvokeExpression(parent, ee.invokeMethodName, temp);
                        
                        if (eventsRef[i].ReturnType == typeof(void)) {
                            method.Statements.Add(new CodeExpressionStatement(methodInvoke));
                        }
                        else {
                            CodeVariableDeclarationStatement tempVar = new CodeVariableDeclarationStatement(ee.retType, ee.invokeMethodName);
                            method.Statements.Add(tempVar);
                            method.Statements.Add(new CodeAssignStatement(new CodeFieldReferenceExpression(null, tempVar.Name), methodInvoke));
                        }
    
                        for (int j = 0; j < parameters.Length; ++j) {
                            if (parameters[j].IsByRef) {
                                method.Statements.Add(new CodeAssignStatement(new CodeFieldReferenceExpression(null, parameters[j].Name),
                                                                                  new CodeFieldReferenceExpression(
                                                                                    new CodeFieldReferenceExpression(null, evtfield.Name),
                                                                                    parameters[j].Name))); 
                            }
                        }

                        if (eventsRef[i].ReturnType != typeof(void)) {
                            method.Statements.Add(new CodeMethodReturnStatement(new CodeFieldReferenceExpression(null, ee.invokeMethodName)));
                        }
                    }
                }
                else {
                    CodeExpressionCollection paramstr = new CodeExpressionCollection();
                    for (int iparam = 0; iparam < parameters.Length; ++iparam)
                        paramstr.Add(new CodeFieldReferenceExpression(null, parameters[iparam].Name));
                    
                    CodeExpression[] temp = new CodeExpression[paramstr.Count];
                    ((IList)paramstr).CopyTo(temp, 0);
                    CodeMethodInvokeExpression methodInvoke = new CodeMethodInvokeExpression(parent, "RaiseOn" + eventsRef[i].Name, temp);
                    
                    if (eventsRef[i].ReturnType == typeof(void)) {
                        method.Statements.Add(new CodeExpressionStatement(methodInvoke));
                    }
                    else {
                        method.Statements.Add(new CodeMethodReturnStatement(methodInvoke));
                    }
                }
                
                cls.Members.Add(method);
            }
            
            AddClassToNamespace(ns, cls);
            return evntCls;
        }
    
        private void WriteEvents(CodeNamespace ns, CodeTypeDeclaration cls) {
            for (int i = 0; events != null && i < events.Count; ++i) {
                EventEntry evententry = (EventEntry)events[i];
                
                Debug.WriteLineIf(AxCodeGen.Enabled, "Processing event: " + evententry.eventName);
                
                CodeMemberEvent e = new CodeMemberEvent();
                e.Name = evententry.resovledEventName;
                e.Attributes = evententry.eventFlags;

                e.Type = new CodeTypeReference(evententry.eventHandlerCls);
                cls.Members.Add(e);

                //Generate the "RaiseXXX" method.
                CodeMemberMethod cmm = new CodeMemberMethod();
                cmm.Name = evententry.invokeMethodName;
                cmm.ReturnType = new CodeTypeReference(evententry.retType);
                cmm.Attributes = MemberAttributes.Assembly | MemberAttributes.Final;
                cmm.Parameters.Add(CreateParamDecl(MapTypeName(typeof(object)), "sender", false));
                cmm.Parameters.Add(CreateParamDecl(evententry.eventCls, "e", false));
    
                CodeFieldReferenceExpression eventExpr = new CodeFieldReferenceExpression(new CodeThisReferenceExpression(), evententry.resovledEventName);
                CodeBinaryOperatorExpression cond = new CodeBinaryOperatorExpression(eventExpr,
                                                                                     CodeBinaryOperatorType.IdentityInequality,
                                                                                     new CodePrimitiveExpression(null));
                CodeConditionStatement ifstat = new CodeConditionStatement();
                ifstat.Condition = cond;

                CodeExpressionCollection paramstr = new CodeExpressionCollection();
                paramstr.Add(new CodeFieldReferenceExpression(null, "sender"));
                paramstr.Add(new CodeFieldReferenceExpression(null, "e"));
                
                CodeExpression[] temp = new CodeExpression[paramstr.Count];
                ((IList)paramstr).CopyTo(temp, 0);
                
                CodeMethodInvokeExpression methodInvoke = new CodeMethodInvokeExpression(new CodeThisReferenceExpression(), evententry.resovledEventName, temp);
                
                if (evententry.retType == typeof(void)) {
                    ifstat.TrueStatements.Add(new CodeExpressionStatement(methodInvoke));
                }
                else {
                    ifstat.TrueStatements.Add(new CodeMethodReturnStatement(methodInvoke));
                    ifstat.FalseStatements.Add(new CodeMethodReturnStatement(GetInitializer(evententry.retType)));
                }

                cmm.Statements.Add(ifstat);

                cls.Members.Add(cmm);
            }
    
            WriteEventMulticaster(ns);
        }
    
        private void WriteHookupMethods(CodeTypeDeclaration cls) {
            if (axctlEventsType != null) {
                // Generate the CreateSink() override.
                //
                CodeMemberMethod sinkMeth = new CodeMemberMethod();
                sinkMeth.Name = "CreateSink";
                sinkMeth.Attributes = MemberAttributes.Family | MemberAttributes.Override;
    
                CodeObjectCreateExpression newMultiCaster = new CodeObjectCreateExpression(axctl + "EventMulticaster");
                newMultiCaster.Parameters.Add(new CodeThisReferenceExpression());
                
                CodeAssignStatement assignMultiCaster = new CodeAssignStatement(multicasterRef, newMultiCaster);

                CodeObjectCreateExpression coce = new CodeObjectCreateExpression(typeof(AxHost.ConnectionPointCookie).FullName);
                coce.Parameters.Add(memIfaceRef);
                coce.Parameters.Add(multicasterRef);
                coce.Parameters.Add(new CodeTypeOfExpression(axctlEvents));
    
                CodeAssignStatement cas = new CodeAssignStatement(cookieRef, coce);
    
                CodeTryCatchFinallyStatement ctcf = new CodeTryCatchFinallyStatement();
                ctcf.TryStatements.Add(assignMultiCaster);
                ctcf.TryStatements.Add(cas);
                ctcf.CatchClauses.Add(new CodeCatchClause("", new CodeTypeReference(typeof(Exception))));
    
                // Add the CreateSink() method to the class.
                //
                sinkMeth.Statements.Add(ctcf);
                cls.Members.Add(sinkMeth);

                // Generate the DetachSink() override.
                //
                CodeMemberMethod detachMeth = new CodeMemberMethod();
                detachMeth.Name = "DetachSink";
                detachMeth.Attributes = MemberAttributes.Family | MemberAttributes.Override;
    
                CodeFieldReferenceExpression invokee = new CodeFieldReferenceExpression(new CodeThisReferenceExpression(), cookie);
                CodeMethodInvokeExpression cmis = new CodeMethodInvokeExpression(invokee, "Disconnect");
    
                ctcf = new CodeTryCatchFinallyStatement();
                ctcf.TryStatements.Add(cmis);
                ctcf.CatchClauses.Add(new CodeCatchClause("", new CodeTypeReference(typeof(Exception))));
                detachMeth.Statements.Add(ctcf);
                cls.Members.Add(detachMeth);
            }
    
            // Generate the AttachInterfaces() override.
            CodeMemberMethod attachMeth = new CodeMemberMethod();
            attachMeth.Name = "AttachInterfaces";
            attachMeth.Attributes = MemberAttributes.Family | MemberAttributes.Override;
    
            CodeCastExpression cce = new CodeCastExpression(axctlType.FullName, new CodeMethodInvokeExpression(new CodeThisReferenceExpression(), "GetOcx"));
            CodeAssignStatement assign = new CodeAssignStatement(memIfaceRef, cce);
    
            CodeTryCatchFinallyStatement trycatch = new CodeTryCatchFinallyStatement();
            trycatch.TryStatements.Add(assign);
            trycatch.CatchClauses.Add(new CodeCatchClause("", new CodeTypeReference(typeof(Exception))));
    
            attachMeth.Statements.Add(trycatch);
            cls.Members.Add(attachMeth);
        }
    
        private void WriteMembersDecl(CodeTypeDeclaration cls) {
            memIface = "ocx";
            memIfaceRef = new CodeFieldReferenceExpression(new CodeThisReferenceExpression(), memIface);
    
            cls.Members.Add(new CodeMemberField(MapTypeName(axctlType), memIface));
    
            if (axctlEventsType != null) {
                multicaster = "eventMulticaster";
                multicasterRef = new CodeFieldReferenceExpression(new CodeThisReferenceExpression(), multicaster);
                cls.Members.Add(new CodeMemberField(axctl + "EventMulticaster", multicaster));
                
                cookie = "cookie";
                cookieRef = new CodeFieldReferenceExpression(new CodeThisReferenceExpression(), cookie);
                cls.Members.Add(new CodeMemberField(typeof(AxHost.ConnectionPointCookie).FullName, cookie));
            }
        }
        
        private void WriteMethod(CodeTypeDeclaration cls, MethodInfo method, bool hasPropInfo) {
            Debug.WriteLineIf(AxCodeGen.Enabled, "Processing method: " + method.Name);

            bool fOverride = false;
            bool fUseNew = false;

            string methodPrefix = ResolveConflict(method.Name, method.ReturnType, out fOverride, out fUseNew);  
            if (fOverride)
                methodPrefix = "Ctl";
            
            CodeMemberMethod cmm = new CodeMemberMethod();

            String methodName = method.Name;
            cmm.Name = methodPrefix + methodName;
            cmm.Attributes = MemberAttributes.Public;

            cmm.ReturnType = new CodeTypeReference(MapTypeName(method.ReturnType));
            
            // Add the check for null this.ocx.
            //

            cmm.Statements.Add(CreateInvalidStateException(cmm.Name, "MethodInvoke"));

            // Add code for the actual method invoke.
            AxParameterData[] parameters = AxParameterData.Convert(method.GetParameters());
            if (parameters != null && parameters.Length > 0) {
                for (int iparam = 0; iparam < parameters.Length; ++iparam) {
                    CodeParameterDeclarationExpression param = CreateParamDecl(parameters[iparam].TypeName, parameters[iparam].Name, parameters[iparam].IsOptional);
                    param.Direction = parameters[iparam].Direction;
                    cmm.Parameters.Add(param);
                }
            }
            
            CodeMethodInvokeExpression mie = new CodeMethodInvokeExpression(memIfaceRef, method.Name);
            if (parameters != null && parameters.Length > 0) {
                for (int iparam = 0; iparam < parameters.Length; ++iparam) {
                    CodeDirectionExpression param = new CodeDirectionExpression(
                        parameters[iparam].Direction,
                        new CodeVariableReferenceExpression(parameters[iparam].Name));
                    mie.Parameters.Add(param);
                }
            }
    
            CodeStatement cs;
            if (method.ReturnType == typeof(void)) {
                cs = new CodeExpressionStatement(mie);
            }
            else {
                ComAliasEnum alias = ComAliasConverter.GetComAliasEnum(method, method.ReturnType, method.ReturnTypeCustomAttributes);
                if (alias != ComAliasEnum.None) {
                    CodeMethodInvokeExpression oldmie = mie;
                    string converter = ComAliasConverter.GetComToManagedConverter(alias);
                    
                    mie = new CodeMethodInvokeExpression(null, converter);
                    mie.Parameters.Add(oldmie);

                    cmm.ReturnType = new CodeTypeReference(ComAliasConverter.GetWFTypeFromComType(method.ReturnType, alias));
                }

                cs = new CodeMethodReturnStatement(mie);
            }
    
            cmm.Statements.Add(cs);
            cls.Members.Add(cmm);

            // Get the DISPID Attribute of the method to see if it handles the About Box.
            // If it does, we will have to add a delegate to this in the WriteHookupMethods() code.
            //
            object[] attrs = method.GetCustomAttributes(typeof(DispIdAttribute), false);
            if (attrs != null && attrs.Length > 0) {
                DispIdAttribute dispid = (DispIdAttribute)attrs[0];
                if (dispid.Value == NativeMethods.ActiveX.DISPID_ABOUTBOX && method.GetParameters().Length == 0) {
                    aboutBoxMethod = cmm.Name;
                }
            }
        }
    
        private void WriteMethods(CodeTypeDeclaration cls) {
            MethodInfo[] methods = axctlType.GetMethods(BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly);
            for (int imeth = 0; imeth < methods.Length; ++imeth) {
                bool hasPropInfo;
                bool useLet;
                bool f = IsPropertySignature(methods[imeth], out hasPropInfo, out useLet);
                Debug.WriteLineIf(AxCodeGen.Enabled, "Processing method: " + methods[imeth].Name + " IsProperty: " + f);

                if (!f) {
                    WriteMethod(cls, methods[imeth], hasPropInfo);
                }
            }
        }
    
        private void WriteProperty(CodeTypeDeclaration cls, PropertyInfo pinfo, bool useLet) {
            CodeAttributeDeclarationCollection customAttrs;
            CodeAttributeDeclaration dispidAttr = null;
            DispIdAttribute dispid = null;

            Debug.WriteLineIf(AxCodeGen.Enabled, "Processing property " + pinfo.Name);
            
            if (nopersist == null) {
                nopersist = new CodeAttributeDeclaration("System.ComponentModel.DesignerSerializationVisibility", new CodeAttributeArgument[] {
                                                                            new CodeAttributeArgument(new CodeFieldReferenceExpression(
                                                                            new CodeFieldReferenceExpression(null, "System.ComponentModel.DesignerSerializationVisibility"), "Hidden"))
                                                                            });
                nobrowse = new CodeAttributeDeclaration("System.ComponentModel.Browsable", new CodeAttributeArgument[] {new CodeAttributeArgument(new CodePrimitiveExpression(false))});
                browse   = new CodeAttributeDeclaration("System.ComponentModel.Browsable", new CodeAttributeArgument[] {new CodeAttributeArgument(new CodePrimitiveExpression(true))});
                bindable = new CodeAttributeDeclaration("System.ComponentModel.Bindable", new CodeAttributeArgument[] {
                                                                            new CodeAttributeArgument(new CodeFieldReferenceExpression(
                                                                                new CodeFieldReferenceExpression(null, "System.ComponentModel.BindableSupport"), "Yes"))
                                                                            });
                defaultBind = new CodeAttributeDeclaration("System.ComponentModel.Bindable", new CodeAttributeArgument[] {
                                                                            new CodeAttributeArgument(new CodeFieldReferenceExpression(
                                                                                new CodeFieldReferenceExpression(null, "System.ComponentModel.BindableSupport"), "Default"))
                                                                            });
            }
            
            object[] comaliasAttrs = pinfo.GetCustomAttributes(typeof(ComAliasNameAttribute), false);
            ComAliasEnum alias = ComAliasConverter.GetComAliasEnum(pinfo, pinfo.PropertyType, pinfo);
            
            Type propType = pinfo.PropertyType;
            if (alias != ComAliasEnum.None) {
                propType = ComAliasConverter.GetWFTypeFromComType(propType, alias);
            }
            
            // Is this a DataSource property? If so, add a member variable to 
            // cache the value of the property.
            //
            bool dataSourceProp = (propType.GUID.Equals(Guid_DataSource));
            if (dataSourceProp) {
                CodeMemberField field = new CodeMemberField(propType.FullName, CreateDataSourceFieldName(pinfo.Name));
                field.Attributes = MemberAttributes.Private | MemberAttributes.Final;
                cls.Members.Add(field);
                dataSourceProps.Add(pinfo);
            }

            // Get the DISPID Attribute of the property and store it in the newly generated wrapper property.
            // We use this later to determine the property category to be used in the properties window.
            //
            object[] attrs = pinfo.GetCustomAttributes(typeof(DispIdAttribute), false);
            if (attrs != null && attrs.Length > 0) {
                dispid = (DispIdAttribute)attrs[0];
                dispidAttr = new CodeAttributeDeclaration(typeof(DispIdAttribute).FullName, new CodeAttributeArgument[] {new CodeAttributeArgument(new CodePrimitiveExpression(dispid.Value))});
            }
#if DEBUG
            else {
                Debug.Fail("Property: " + pinfo.Name + " does not have any DISPID attribute, or has multiple DISPID attributes!!!" + ((attrs != null) ? attrs.Length : -1));
            }
#endif // DEBUG

            bool fOverride = false;
            bool fUseNew = false;

            string propPrefix = ResolveConflict(pinfo.Name, propType, out fOverride, out fUseNew);
            
            if (fOverride || fUseNew) {
                if (dispid == null)
                    return;
                else {
                    if (!IsDispidKnown(dispid.Value, pinfo.Name)) {
                        propPrefix = "Ctl";
                        fOverride = false;
                        fUseNew = false;
                    }
                }
            }
            
            CodeMemberProperty prop = new CodeMemberProperty();

            prop.Type = new CodeTypeReference(MapTypeName(propType));
            prop.Name = propPrefix + pinfo.Name;           
            prop.Attributes = MemberAttributes.Public;
    
            if (fOverride) {
                prop.Attributes |= MemberAttributes.Override;
            }
            else if (fUseNew) {
                prop.Attributes |= MemberAttributes.New;
            }

            bool isDefaultBind = false;
            bool browsable = IsPropertyBrowsable(pinfo, alias);
            bool isbind    = IsPropertyBindable(pinfo, out isDefaultBind);

            // Generate custom attributes for these properties.
            // 
            if (!browsable || alias == ComAliasEnum.Handle) {
                // These properties are NonBrowsable, NonPersistable ones.
                //
                customAttrs = new CodeAttributeDeclarationCollection(new CodeAttributeDeclaration[] {nobrowse, nopersist, dispidAttr});
            }
            else if (dataSourceProp) {
                // DataSource properties are persitable in code
                //
                customAttrs = new CodeAttributeDeclarationCollection(new CodeAttributeDeclaration[] {dispidAttr});
            }
            else {
                // The rest of the properties are to be Persistable.None, as they get persisted to the ActiveX control's persist stream.
                //
                if (fOverride || fUseNew) {
                    customAttrs = new CodeAttributeDeclarationCollection(new CodeAttributeDeclaration[] {browse, nopersist, dispidAttr});
                }
                else {
                    customAttrs = new CodeAttributeDeclarationCollection(new CodeAttributeDeclaration[] {nopersist, dispidAttr});
                }
            }

            if (alias != ComAliasEnum.None) {
                CodeAttributeDeclaration attr = new CodeAttributeDeclaration(typeof(ComAliasNameAttribute).FullName, new CodeAttributeArgument[] {
                                                                                new CodeAttributeArgument(new CodePrimitiveExpression(pinfo.PropertyType.FullName))});
                customAttrs.Add(attr);
            }

            if (isDefaultBind)
                customAttrs.Add(defaultBind);
            else if (isbind)
                customAttrs.Add(bindable);
            
            prop.CustomAttributes = customAttrs;
            
            // Handle Indexed properties...
            AxParameterData[] parameters = AxParameterData.Convert(pinfo.GetIndexParameters());
            if (parameters != null && parameters.Length > 0) {
                for (int iparam = 0; iparam < parameters.Length; ++iparam) {
                    CodeParameterDeclarationExpression param = CreateParamDecl(parameters[iparam].TypeName, parameters[iparam].Name, parameters[iparam].IsOptional);
                    param.Direction = parameters[iparam].Direction;
                    prop.Parameters.Add(param);
                }
            }
            
            // Visual Basic generates properties where the setter takes a BYREF parameter for the set_XXX().
            // This causes the C# code gen to not work correctly, since the compiler cannot convert
            // the parameter fro, type 'Foo' to type 'ref Foo'. The workaround is to recognize these
            // properties and generate the property invokes on the OCX to be of the get_XXX() and 
            // set_XXX(ref value) instead of the regular property invoke syntax.
            //
            bool fConvertPropCallsToMethodInvokes = useLet;
            if (pinfo.CanWrite) {
                MethodInfo setter;
                if (useLet)
                    setter = pinfo.DeclaringType.GetMethod("let_" + pinfo.Name, BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly);
                else
                    setter = pinfo.GetSetMethod();

                Debug.Assert(setter != null, "No set/let method found for : " + pinfo.Name);

                Type paramType = setter.GetParameters()[0].ParameterType;
                Type baseType = paramType.GetElementType();
                if (baseType != null && paramType != baseType) {
                    Debug.WriteLineIf(AxCodeGen.Enabled, "Writing property in method invoke syntax " + pinfo.Name);
                    fConvertPropCallsToMethodInvokes = true;
                }
            }
            
            if (pinfo.CanRead)
                WritePropertyGetter(prop, pinfo, alias, parameters, fConvertPropCallsToMethodInvokes, fOverride, dataSourceProp);
            if (pinfo.CanWrite)
                WritePropertySetter(prop, pinfo, alias, parameters, fConvertPropCallsToMethodInvokes, fOverride, useLet, dataSourceProp);
            
            // If the default property happens to be different from "Item", we have to
            // generate the name("foo") attribute on the default property so we can 
            // rename it.
            //
            if (parameters.Length > 0 && prop.Name != "Item") {
                CodeAttributeDeclaration nameAttr = new CodeAttributeDeclaration("System.Runtime.CompilerServices.IndexerName",
                                                             new CodeAttributeArgument[] {new CodeAttributeArgument(new CodePrimitiveExpression(prop.Name))});

                // Calling a property "Item" tells the codedom that this is the default indexed property.
                //
                prop.Name = "Item";
                prop.CustomAttributes.Add(nameAttr);
            }
        
            // Add DefaultProperty attribute for the class if needed...
            if (defMember != null && defMember.Equals(pinfo.Name)) {
                CodeAttributeDeclaration defMemberAttr = new CodeAttributeDeclaration("System.ComponentModel.DefaultProperty",
                                                             new CodeAttributeArgument[] {new CodeAttributeArgument(new CodePrimitiveExpression(prop.Name))});
                cls.CustomAttributes.Add(defMemberAttr);
            }

            cls.Members.Add(prop);
        }
    
        private void WritePropertyGetter(CodeMemberProperty prop, PropertyInfo pinfo, ComAliasEnum alias, AxParameterData[] parameters, bool fMethodSyntax, bool fOverride, bool dataSourceProp) {
            if (dataSourceProp) {
                Debug.Assert(!fOverride, "Cannot have a overridden DataSource property.");
                Debug.Assert(parameters.Length <= 0, "Cannot have a parameterized DataSource property.");
                
                string dataSourceName = CreateDataSourceFieldName(pinfo.Name);
                CodeMethodReturnStatement ret = new CodeMethodReturnStatement(new CodeFieldReferenceExpression(new CodeThisReferenceExpression(), dataSourceName));
                prop.GetStatements.Add(ret);
            }
            else if (fOverride) {
                CodeConditionStatement ifstat = CreateValidStateCheck();
                ifstat.TrueStatements.Add(GetPropertyGetRValue(pinfo, memIfaceRef, alias, parameters, fMethodSyntax));
                
                ifstat.FalseStatements.Add(GetPropertyGetRValue(pinfo, new CodeBaseReferenceExpression(), ComAliasEnum.None, parameters, false));

                prop.GetStatements.Add(ifstat);
            }
            else {
                prop.GetStatements.Add(CreateInvalidStateException(prop.Name, "PropertyGet"));
                prop.GetStatements.Add(GetPropertyGetRValue(pinfo, memIfaceRef, alias, parameters, fMethodSyntax));
            }
        }
    
        private void WritePropertySetter(CodeMemberProperty prop, PropertyInfo pinfo, ComAliasEnum alias, AxParameterData[] parameters, bool fMethodSyntax, bool fOverride, bool useLet, bool dataSourceProp) {
            if (!fOverride && !dataSourceProp) {
                prop.SetStatements.Add(CreateInvalidStateException(prop.Name, "PropertySet"));
            }

            if (dataSourceProp) {
                Debug.Assert(!fOverride, "Cannot have a overridden DataSource property.");
                Debug.Assert(parameters.Length <= 0, "Cannot have a parameterized DataSource property.");

                string dataSourceName = CreateDataSourceFieldName(pinfo.Name);
                WriteDataSourcePropertySetter(prop, pinfo, dataSourceName);
            }
            else if (!fMethodSyntax) {
                WritePropertySetterProp(prop, pinfo, alias, parameters, fOverride, useLet);
            }
            else {
                WritePropertySetterMethod(prop, pinfo, alias, parameters, fOverride, useLet);
            }
        }

        private void WriteDataSourcePropertySetter(CodeMemberProperty prop, PropertyInfo pinfo, string dataSourceName) {
            CodeExpression left = new CodeFieldReferenceExpression(new CodeThisReferenceExpression(), dataSourceName);
            CodeExpression right = new CodeFieldReferenceExpression(null, "value");
            CodeAssignStatement assign = new CodeAssignStatement(left, right);

            prop.SetStatements.Add(assign);

            CodeConditionStatement ifstat = CreateValidStateCheck();
            left = new CodeFieldReferenceExpression(memIfaceRef, pinfo.Name);
            ifstat.TrueStatements.Add(new CodeAssignStatement(left, right));

            prop.SetStatements.Add(ifstat);
        }

        private void WritePropertySetterMethod(CodeMemberProperty prop, PropertyInfo pinfo, ComAliasEnum alias, AxParameterData[] parameters, bool fOverride, bool useLet) {
            CodeExpression baseCall = null;
            CodeBinaryOperatorExpression cond = null;
            CodeConditionStatement ifstat = null;

            if (fOverride) {
                if (parameters.Length > 0) {
                    baseCall = new CodeIndexerExpression(memIfaceRef);
                }
                else {
                    baseCall = new CodePropertyReferenceExpression(new CodeBaseReferenceExpression(), pinfo.Name);
                }
                cond = new CodeBinaryOperatorExpression(memIfaceRef, CodeBinaryOperatorType.IdentityInequality, new CodePrimitiveExpression(null));
                ifstat = new CodeConditionStatement();
                ifstat.Condition = cond;
            }
            
            CodeFieldReferenceExpression propCallParam;
            string setterName = (useLet) ? "let_" + pinfo.Name : pinfo.GetSetMethod().Name;
            CodeMethodInvokeExpression propCall = new CodeMethodInvokeExpression(memIfaceRef, setterName);
            
            for (int iparam = 0; iparam < parameters.Length; ++iparam) {
                if (fOverride) {
                    ((CodeIndexerExpression)baseCall).Indices.Add(new CodeFieldReferenceExpression(null, parameters[iparam].Name));
                }
                propCall.Parameters.Add(new CodeFieldReferenceExpression(null, parameters[iparam].Name));
            }
            
            CodeFieldReferenceExpression valueExpr = new CodeFieldReferenceExpression(null, "value");
            CodeExpression rval = GetPropertySetRValue(alias, pinfo.PropertyType);

            if (alias != ComAliasEnum.None) {
                string paramConverter = ComAliasConverter.GetWFToComParamConverter(alias, pinfo.PropertyType);
                
                CodeParameterDeclarationExpression propCallParamDecl;
                if (paramConverter.Length == 0) {
                    propCallParamDecl = CreateParamDecl(MapTypeName(pinfo.PropertyType), "paramTemp", false);
                }
                else {
                    propCallParamDecl = CreateParamDecl(paramConverter, "paramTemp", false);
                }
                prop.SetStatements.Add(new CodeAssignStatement(propCallParamDecl, rval));

                propCallParam = new CodeFieldReferenceExpression(null, "paramTemp");
            }
            else {
                propCallParam = valueExpr;
            }
        
            propCall.Parameters.Add(new CodeDirectionExpression((useLet) ? FieldDirection.In : FieldDirection.Ref, propCallParam));

            if (fOverride) {
                prop.SetStatements.Add(new CodeAssignStatement(baseCall, valueExpr));
                ifstat.TrueStatements.Add(new CodeExpressionStatement(propCall));
                prop.SetStatements.Add(ifstat);
            }
            else {
                prop.SetStatements.Add(new CodeExpressionStatement(propCall));
            }
        }
    
        private void WritePropertySetterProp(CodeMemberProperty prop, PropertyInfo pinfo, ComAliasEnum alias, AxParameterData[] parameters, bool fOverride, bool useLet) {
            CodeExpression baseCall = null;
            CodeBinaryOperatorExpression cond = null;
            CodeConditionStatement ifstat = null;

            if (fOverride) {
                if (parameters.Length > 0) {
                    baseCall = new CodeIndexerExpression(memIfaceRef);
                }
                else {
                    baseCall = new CodePropertyReferenceExpression(new CodeBaseReferenceExpression(), pinfo.Name);
                }

                cond = new CodeBinaryOperatorExpression(memIfaceRef, CodeBinaryOperatorType.IdentityInequality, new CodePrimitiveExpression(null));
                ifstat = new CodeConditionStatement();
                ifstat.Condition = cond;
            }
            
            CodeExpression propCall;

            if (parameters.Length > 0) {
                propCall = new CodeIndexerExpression(memIfaceRef);
            }
            else {
                propCall = new CodePropertyReferenceExpression(memIfaceRef, pinfo.Name);
            }
            
            for (int iparam = 0; iparam < parameters.Length; ++iparam) {
                if (fOverride) {
                    ((CodeIndexerExpression)baseCall).Indices.Add(new CodeFieldReferenceExpression(null, parameters[iparam].Name));
                }
                ((CodeIndexerExpression)propCall).Indices.Add(new CodeFieldReferenceExpression(null, parameters[iparam].Name));
            }
            
            CodeFieldReferenceExpression valueExpr = new CodeFieldReferenceExpression(null, "value");
            CodeExpression rval = GetPropertySetRValue(alias, pinfo.PropertyType);

            if (fOverride) {
                prop.SetStatements.Add(new CodeAssignStatement(baseCall, valueExpr));
                ifstat.TrueStatements.Add(new CodeAssignStatement(propCall, rval));
                prop.SetStatements.Add(ifstat);
            }
            else {
                prop.SetStatements.Add(new CodeAssignStatement(propCall, rval));
            }
        }
    
        private CodeMethodReturnStatement GetPropertyGetRValue(PropertyInfo pinfo, CodeExpression reference, ComAliasEnum alias, AxParameterData[] parameters, bool fMethodSyntax) {
            CodeExpression propCall = null;

            if (fMethodSyntax) {
                propCall = new CodeMethodInvokeExpression(reference, pinfo.GetGetMethod().Name);
                for (int iparam = 0; iparam < parameters.Length; ++iparam)
                    ((CodeMethodInvokeExpression)propCall).Parameters.Add(new CodeFieldReferenceExpression(null, parameters[iparam].Name));
            }
            else {
                if (parameters.Length > 0) {
                    propCall = new CodeIndexerExpression(reference);
                    
                    for (int iparam = 0; iparam < parameters.Length; ++iparam)
                        ((CodeIndexerExpression)propCall).Indices.Add(new CodeFieldReferenceExpression(null, parameters[iparam].Name));
                }
                else {
                    propCall = new CodePropertyReferenceExpression(reference, ((parameters.Length == 0) ? pinfo.Name : ""));
                }
            }
            
            if (alias != ComAliasEnum.None) {
                string converter = ComAliasConverter.GetComToManagedConverter(alias);
                string paramConverter = ComAliasConverter.GetComToWFParamConverter(alias);

                CodeExpression[] expr = null;
                if (paramConverter.Length == 0) {
                    expr = new CodeExpression[] {propCall};
                }
                else {
                    CodeCastExpression paramCast = new CodeCastExpression(paramConverter, propCall);
                    expr = new CodeExpression[] {paramCast};
                }
                CodeMethodInvokeExpression methodInvoke = new CodeMethodInvokeExpression(null, converter, expr);
                return new CodeMethodReturnStatement(methodInvoke);
            }
            else {
                return new CodeMethodReturnStatement(propCall);
            }
        }

        private CodeExpression GetPropertySetRValue(ComAliasEnum alias, Type propertyType) {
            CodeExpression valueExpr = new CodePropertySetValueReferenceExpression();

            if (alias != ComAliasEnum.None) {
                string converter = ComAliasConverter.GetWFToComConverter(alias);
                string paramConverter = ComAliasConverter.GetWFToComParamConverter(alias, propertyType);
                
                CodeExpression[] expr = new CodeExpression[] {valueExpr};
                CodeMethodInvokeExpression methodInvoke = new CodeMethodInvokeExpression(null, converter, expr);
                
                if (paramConverter.Length == 0) {
                    return methodInvoke;
                }
                else {
                    return new CodeCastExpression(paramConverter, methodInvoke);
                }
            }
            else {
                return valueExpr;
            }
        }

        private void WriteProperties(CodeTypeDeclaration cls) {
            bool useLet;
            
            PropertyInfo[] props = axctlType.GetProperties(BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly);
            
            for (int iprop = 0; iprop < props.Length; ++iprop) {
                if (IsPropertySignature(props[iprop], out useLet)) {
                    WriteProperty(cls, props[iprop], useLet);
                }
            }
        }

        private enum ComAliasEnum {
            None,
            Color,
            Font,
            FontDisp,
            Handle,
            Picture,
            PictureDisp
        }

        private class ComAliasConverter {
            private static Guid Guid_IPicture     = new Guid("{7BF80980-BF32-101A-8BBB-00AA00300CAB}");
            private static Guid Guid_IPictureDisp = new Guid("{7BF80981-BF32-101A-8BBB-00AA00300CAB}");
            private static Guid Guid_IFont        = new Guid("{BEF6E002-A874-101A-8BBA-00AA00300CAB}");
            private static Guid Guid_IFontDisp    = new Guid("{BEF6E003-A874-101A-8BBA-00AA00300CAB}");

            // Optimization caches.
            //
            private static Hashtable typeGuids;

            public static string GetComToManagedConverter(ComAliasEnum alias) {
                Debug.Assert(alias != ComAliasEnum.None, "Cannot find converter for ComAliasEnum.None");
                if (alias == ComAliasEnum.Color)
                    return "GetColorFromOleColor";
                
                if (IsFont(alias))
                    return "GetFontFromIFont";
                
                if (IsPicture(alias))
                    return "GetPictureFromIPicture";
                
                return "";                    
            }

            public static string GetComToWFParamConverter(ComAliasEnum alias) {
                Debug.Assert(alias != ComAliasEnum.None, "Cannot find converter for ComAliasEnum.None");
                if (alias == ComAliasEnum.Color)
                    return typeof(uint).FullName;
                
                return "";                    
            }
            
            private static Guid GetGuid(Type t) {
                Guid g = Guid.Empty;

                if (typeGuids == null) {
                    typeGuids = new Hashtable();
                }
                else if (typeGuids.Contains(t)) {
                    g = (Guid)typeGuids[t];
                    return g;
                }
                
                g = t.GUID;
                typeGuids.Add(t, g);
                return g;
            }
            public static Type GetWFTypeFromComType(Type t, ComAliasEnum alias) {
                Debug.Assert(alias != ComAliasEnum.None, "Cannot find converter for ComAliasEnum.None");

                if (!IsValidType(alias, t))
                    return t;

                if (alias == ComAliasEnum.Color)
                    return typeof(System.Drawing.Color);
                
                if (IsFont(alias))
                    return typeof(System.Drawing.Font);
                
                if (IsPicture(alias))
                    return typeof(System.Drawing.Image);
                
                return t;                    
            }
            
            public static string GetWFToComConverter(ComAliasEnum alias) {
                Debug.Assert(alias != ComAliasEnum.None, "Cannot find converter for ComAliasEnum.None");
                if (alias == ComAliasEnum.Color)
                    return "GetOleColorFromColor";
                
                if (IsFont(alias))
                    return "GetIFontFromFont";
                
                if (IsPicture(alias))
                    return "GetIPictureFromPicture";
                
                return "";                    
            }

            public static string GetWFToComParamConverter(ComAliasEnum alias, Type t) {
                Debug.Assert(alias != ComAliasEnum.None, "Cannot find converter for ComAliasEnum.None");
                return t.FullName;
            }
            
            public static ComAliasEnum GetComAliasEnum(MemberInfo memberInfo, Type type, ICustomAttributeProvider attrProvider) {
                string aliasName = null;
                int dispid = -1;

                Debug.Assert(type != null, "No type for ComAliasEnum!!!");

                object[] attrs = attrProvider.GetCustomAttributes(typeof(ComAliasNameAttribute), false);
                if (attrs != null && attrs.Length > 0) {
                    Debug.Assert(attrs.Length == 1, "Multiple ComAliasNameAttributes found o: " + memberInfo.Name);
                    ComAliasNameAttribute alias = (ComAliasNameAttribute)attrs[0];
                    aliasName = alias.Value;
                }
                    
                if (aliasName != null && aliasName.Length != 0) {
                    if (aliasName.EndsWith(".OLE_COLOR") && IsValidType(ComAliasEnum.Color, type))
                        return ComAliasEnum.Color;

                    if (aliasName.EndsWith(".OLE_HANDLE") && IsValidType(ComAliasEnum.Handle, type))
                        return ComAliasEnum.Handle;
                    
#if DEBUG
                    //if (!aliasName.Equals("stdole.OLE_HANDLE"))
                    //    Debug.Fail("Did not handle ComAliasNameAttribute of: " + aliasName + " on property: " + memberInfo.Name);
#endif //DEBUG
                }

                if (memberInfo is PropertyInfo && String.Compare(memberInfo.Name, "hWnd", true, CultureInfo.InvariantCulture) == 0 && IsValidType(ComAliasEnum.Handle, type)) {
                    Debug.WriteLineIf(AxCodeGen.Enabled && (aliasName == null || aliasName.EndsWith(".OLE_HANDLE")), "hWnd property is not marked as OLE_HANDLE");
                    return ComAliasEnum.Handle;
                }

                // Get the dispid so we can use standard dispid values to compare.
                //
                attrs = attrProvider.GetCustomAttributes(typeof(DispIdAttribute), false);
                if (attrs != null && attrs.Length > 0) {
                    Debug.Assert(attrs.Length == 1, "Multiple ComAliasNameAttributes found o: " + memberInfo.Name);
                    DispIdAttribute alias = (DispIdAttribute)attrs[0];
                    dispid = alias.Value;
                }
                    
                if ((dispid == NativeMethods.ActiveX.DISPID_BACKCOLOR || dispid == NativeMethods.ActiveX.DISPID_FORECOLOR ||
                    dispid == NativeMethods.ActiveX.DISPID_FILLCOLOR ||  dispid == NativeMethods.ActiveX.DISPID_BORDERCOLOR) &&
                    IsValidType(ComAliasEnum.Color, type)) {
                        return ComAliasEnum.Color;
                }

                if (dispid == NativeMethods.ActiveX.DISPID_FONT && IsValidType(ComAliasEnum.Font, type)) {
                        return ComAliasEnum.Font;
                }

                if (dispid == NativeMethods.ActiveX.DISPID_PICTURE && IsValidType(ComAliasEnum.Picture, type)) {
                        return ComAliasEnum.Picture;
                }

                if (dispid == NativeMethods.ActiveX.DISPID_HWND && IsValidType(ComAliasEnum.Handle, type)) {
                        return ComAliasEnum.Handle;
                }

                if (IsValidType(ComAliasEnum.Font, type))
                    return ComAliasEnum.Font;

                if (IsValidType(ComAliasEnum.FontDisp, type))
                    return ComAliasEnum.FontDisp;

                if (IsValidType(ComAliasEnum.Picture, type))
                    return ComAliasEnum.Picture;

                if (IsValidType(ComAliasEnum.PictureDisp, type))
                    return ComAliasEnum.PictureDisp;

                return ComAliasEnum.None;
            }

            public static bool IsFont(ComAliasEnum e) {
                return e == ComAliasEnum.Font || e == ComAliasEnum.FontDisp;
            }
        
            public static bool IsPicture(ComAliasEnum e) {
                return e == ComAliasEnum.Picture || e == ComAliasEnum.PictureDisp;
            }

            private static bool IsValidType(ComAliasEnum e, Type t) {
                switch (e) {
                    case ComAliasEnum.Color:
                        return t == typeof(UInt16) || t == typeof(uint) || t == typeof(int) || t == typeof(short);
    
                    case ComAliasEnum.Handle:
                        return t == typeof(uint) || t == typeof(int) || t == typeof(IntPtr) || t == typeof(UIntPtr);
    
                    case ComAliasEnum.Font:
                        return GetGuid(t).Equals(Guid_IFont);
    
                    case ComAliasEnum.FontDisp:
                        return GetGuid(t).Equals(Guid_IFontDisp);
    
                    case ComAliasEnum.Picture:
                        return GetGuid(t).Equals(Guid_IPicture);
    
                    case ComAliasEnum.PictureDisp:
                        return GetGuid(t).Equals(Guid_IPictureDisp);
    
                    default:
                        Debug.Fail("Invalid verify call for " + e.ToString());
                        return false;
                }
            }
        }
        
        private class EventEntry {
            public string eventName;
            public string resovledEventName;
            public string eventCls;
            public string eventHandlerCls;
            public Type   retType;
            public AxParameterData[] parameters;
            public string eventParam;
            public string invokeMethodName;
            public MemberAttributes eventFlags;
    
            public EventEntry(string eventName, string eventCls, string eventHandlerCls, Type retType, AxParameterData[] parameters, bool conflict) {
                this.eventName = eventName;
                this.eventCls = eventCls;
                this.eventHandlerCls = eventHandlerCls;
                this.retType = retType;
                this.parameters = parameters;
                this.eventParam = eventName.ToLower(CultureInfo.InvariantCulture) + "Event";
                this.resovledEventName = (conflict) ? eventName + "Event" : eventName;
                this.invokeMethodName = "RaiseOn" + resovledEventName;
                this.eventFlags = MemberAttributes.Public | MemberAttributes.Final;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\compositiondesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="CompositionDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
* Copyright (c) 1999, Microsoft Corporation. All Rights Reserved.
* Information Contained Herein is Proprietary and Confidential.
*/
namespace System.Windows.Forms.Design {

    using System.Design;
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;    
    using System.ComponentModel.Design;
    using Microsoft.Win32;
    using System.Drawing;
    using System.Drawing.Design;
    using System.Collections;    
    using System.Windows.Forms;

    /// <include file='doc\CompositionDesigner.uex' path='docs/doc[@for="ComponentDocumentDesigner"]/*' />
    /// <devdoc>
    ///    <para> Provides a root designer implementation for designing components.</para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public class ComponentDocumentDesigner : ComponentDesigner, IRootDesigner, IToolboxUser, IOleDragClient, ITypeDescriptorFilterService {

        private CompositionUI           compositionUI;        // The UI for our designer
        private CompositionCommandSet   commandSet;           // Our set of menu commands
        private IEventHandlerService    eventHandlerService;  // The service that handles key and menu events
        private InheritanceService      inheritanceService;   // allows us to support inheritance
        private SelectionUIService      selectionUIService;
        private DesignerExtenders       designerExtenders;

        private ITypeDescriptorFilterService delegateFilterService;

        private bool                    largeIcons = false;  
        private bool                    autoArrange = true;  
        private PbrsForward             pbrsFwd;

        /// <include file='doc\CompositionDesigner.uex' path='docs/doc[@for="ComponentDocumentDesigner.Dispose"]/*' />
        /// <devdoc>
        ///    <para>Disposes of the resources (other than memory) used by 
        ///       the <see cref='System.Windows.Forms.Design.ComponentDocumentDesigner'/>.</para>
        /// </devdoc>
        protected override void Dispose(bool disposing) {
            if (disposing) {
                IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
                Debug.Assert(!CompModSwitches.CommonDesignerServices.Enabled || host != null, "IDesignerHost not found");

                if (host != null) {
                    host.RemoveService(typeof(IInheritanceService));
                    host.RemoveService(typeof(IEventHandlerService));
                    host.RemoveService(typeof(ISelectionUIService));
                    host.RemoveService(typeof(ComponentTray));

                    IComponentChangeService cs = (IComponentChangeService)GetService(typeof(IComponentChangeService));
                    Debug.Assert(!CompModSwitches.CommonDesignerServices.Enabled || cs != null, "IComponentChangeService not found");
                    if (cs != null) {
                        cs.ComponentAdded -= new ComponentEventHandler(OnComponentAdded);
                        cs.ComponentRemoved -= new ComponentEventHandler(OnComponentRemoved);
                    }
                }

                if (selectionUIService != null) {
                    selectionUIService.Dispose();
                    selectionUIService = null;
                }

                if (commandSet != null) {
                    commandSet.Dispose();
                    commandSet = null;
                }

                if (this.pbrsFwd != null) {
                    pbrsFwd.Dispose();
                    pbrsFwd = null;
                }

                if (compositionUI != null) {
                    compositionUI.Dispose();
                    compositionUI = null;
                }

                if (designerExtenders != null) {
                    designerExtenders.Dispose();
                    designerExtenders = null;
                }

                if (inheritanceService != null) {
                    inheritanceService.Dispose();
                    inheritanceService = null;
                }
            }
            base.Dispose(disposing);
        }

        /// <include file='doc\CompositionDesigner.uex' path='docs/doc[@for="ComponentDocumentDesigner.Control"]/*' />
        /// <devdoc>
        ///    <para>Gets  the control for this designer.</para>
        /// </devdoc>
        public Control Control {
            get {
                return compositionUI;
            }
        }

        /// <include file='doc\CompositionDesigner.uex' path='docs/doc[@for="ComponentDocumentDesigner.TrayAutoArrange"]/*' />
        /// <devdoc>
        ///    <para>Indicates whether the tray should auto arrange controls.</para>
        /// </devdoc>
        public bool TrayAutoArrange {
            get {
                return autoArrange;
            }

            set {
                autoArrange = value;
                Debug.Assert(compositionUI != null, "UI must be created by now.");
                compositionUI.AutoArrange = value;
            }
        }

        /// <include file='doc\CompositionDesigner.uex' path='docs/doc[@for="ComponentDocumentDesigner.TrayLargeIcon"]/*' />
        /// <devdoc>
        ///    <para>Indicates whether the tray should contain a large icon.</para>
        /// </devdoc>
        public bool TrayLargeIcon {
            get {
                return largeIcons;
            }

            set {
                largeIcons = value;
                Debug.Assert(compositionUI != null, "UI must be created by now.");
                compositionUI.ShowLargeIcons = value;
            }
        }

        /// <include file='doc\CompositionDesigner.uex' path='docs/doc[@for="ComponentDocumentDesigner.GetToolSupported"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether the specified tool is supported by this 
        ///       designer.</para>
        /// </devdoc>
        protected virtual bool GetToolSupported(ToolboxItem tool) {
            return true;
        }

        /// <include file='doc\CompositionDesigner.uex' path='docs/doc[@for="ComponentDocumentDesigner.Initialize"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       Initializes the designer with the specified component.</para>
        /// </devdoc>
        public override void Initialize(IComponent component) {
            base.Initialize(component);

            inheritanceService = new InheritanceService();

            ISite site = component.Site;
            IContainer container = null;            

            IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
            IExtenderProviderService exps = (IExtenderProviderService)GetService(typeof(IExtenderProviderService));
            if (exps != null) {
                designerExtenders = new DesignerExtenders(exps);
            }

            Debug.Assert(!CompModSwitches.CommonDesignerServices.Enabled || host != null, "IDesignerHost not found");
            if (host != null) {
                eventHandlerService = new EventHandlerService(null);
                selectionUIService = new SelectionUIService(host);
                
                host.AddService(typeof(IInheritanceService), inheritanceService);
                host.AddService(typeof(IEventHandlerService), eventHandlerService);
                host.AddService(typeof(ISelectionUIService), selectionUIService);
                
                compositionUI = new CompositionUI(this, site);

                host.AddService(typeof(ComponentTray), compositionUI);

                IComponentChangeService cs = (IComponentChangeService)GetService(typeof(IComponentChangeService));
                Debug.Assert(!CompModSwitches.CommonDesignerServices.Enabled || cs != null, "IComponentChangeService not found");
                if (cs != null) {
                    cs.ComponentAdded += new ComponentEventHandler(OnComponentAdded);
                    cs.ComponentRemoved += new ComponentEventHandler(OnComponentRemoved);
                }

                // Select this component.
                //
                ISelectionService ss = (ISelectionService)GetService(typeof(ISelectionService));
                if (ss != null) {
                    ss.SetSelectedComponents(new object[] {component}, SelectionTypes.Normal);
                }
            }

            // Set up our menu command set
            //
            if (site != null) {
                commandSet = new CompositionCommandSet(compositionUI, site);
                container = site.Container;
            }

            this.pbrsFwd = new PbrsForward(compositionUI, site);
            
            // Hook up our inheritance service and do a scan for inherited components.
            //
            inheritanceService.AddInheritedComponents(component, container);

            // Hook yourself up to the ITypeDescriptorFilterService so we can hide the
            // location property on all components being added to the designer.
            //
            IServiceContainer serviceContainer = (IServiceContainer)GetService(typeof(IServiceContainer));                                      
            if (serviceContainer != null) {
                delegateFilterService = (ITypeDescriptorFilterService)GetService(typeof(ITypeDescriptorFilterService));
                if (delegateFilterService != null) 
                    serviceContainer.RemoveService(typeof(ITypeDescriptorFilterService));

                serviceContainer.AddService(typeof(ITypeDescriptorFilterService), this);                                                        
            }
        }
        
        /// <include file='doc\CompositionDesigner.uex' path='docs/doc[@for="ComponentDocumentDesigner.OnComponentAdded"]/*' />
        /// <devdoc>
        ///     This provides a view for all controls on the form.
        /// </devdoc>
        /// <devdoc>
        ///     This provides a view for all controls on the form.
        /// </devdoc>
        private void OnComponentAdded(object sender, ComponentEventArgs ce) {
            if (ce.Component != Component) {
                compositionUI.AddComponent(ce.Component);
            }
        }

        /// <include file='doc\CompositionDesigner.uex' path='docs/doc[@for="ComponentDocumentDesigner.OnComponentRemoved"]/*' />
        /// <devdoc>
        ///     This provides a view for all controls on the form.
        /// </devdoc>
        /// <devdoc>
        ///     This provides a view for all controls on the form.
        /// </devdoc>
        private void OnComponentRemoved(object sender, ComponentEventArgs ce) {
            compositionUI.RemoveComponent(ce.Component);
        }

        /// <include file='doc\CompositionDesigner.uex' path='docs/doc[@for="ComponentDocumentDesigner.PreFilterProperties"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       Allows a
        ///       designer to filter the set of properties the component
        ///       it is designing will expose through the TypeDescriptor
        ///       object.</para>
        /// </devdoc>
        protected override void PreFilterProperties(IDictionary properties) {
            base.PreFilterProperties(properties);

            properties["TrayLargeIcon"] = TypeDescriptor.CreateProperty(this.GetType(), "TrayLargeIcon", typeof(bool),
                                                               BrowsableAttribute.No,
                                                               DesignOnlyAttribute.Yes,
                                                               CategoryAttribute.Design);
        }

        /// <include file='doc\CompositionDesigner.uex' path='docs/doc[@for="ComponentDocumentDesigner.IOleDragClient.CanModifyComponents"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para> Indicates whether the
        /// components can be changed by the designer.</para>
        /// </devdoc>
        bool IOleDragClient.CanModifyComponents {
            get {
                return(true);
            }
        }

        /// <include file='doc\CompositionDesigner.uex' path='docs/doc[@for="ComponentDocumentDesigner.IOleDragClient.AddComponent"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>Adds a component to the designer.</para>
        /// </devdoc>
        bool IOleDragClient.AddComponent(IComponent component, string name, bool firstAdd) {
            IContainer container = Component.Site.Container;

            if (container != null && name != null && container.Components[name] != null) {
                name = null;
            }

            IContainer curContainer = null;
            bool reinit = false;

            if (!firstAdd) {
                if (component.Site != null) {
                    curContainer = component.Site.Container;
                    curContainer.Remove(component);
                    reinit = true;
                }
    
                container.Add(component, name);
            }
            if (reinit) {
                IDesignerHost designerHost = (IDesignerHost)GetService(typeof(IDesignerHost));
                if (designerHost != null) {
                    IDesigner designer = designerHost.GetDesigner(component);
                    if (designer is ComponentDesigner) {
                        ((ComponentDesigner)designer).InitializeNonDefault();
                    }
                }
            }
            return curContainer != container;
        }

        /// <include file='doc\CompositionDesigner.uex' path='docs/doc[@for="ComponentDocumentDesigner.IOleDragClient.GetControlForComponent"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>Gets the instance of the control being used to visually represent the specified component.</para>
        /// </devdoc>
        Control IOleDragClient.GetControlForComponent(object component) {
            if (compositionUI != null) {
                return ((IOleDragClient)compositionUI).GetControlForComponent(component);
            }
            return null;
        }

        /// <include file='doc\CompositionDesigner.uex' path='docs/doc[@for="ComponentDocumentDesigner.IOleDragClient.GetDesignerControl"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para> Gets the control instance being used
        /// as the designer surface.</para>
        /// </devdoc>
        Control IOleDragClient.GetDesignerControl() {
            if (compositionUI != null) {
                return ((IOleDragClient)compositionUI).GetDesignerControl();
            }
            return null;
        }

        /// <include file='doc\CompositionDesigner.uex' path='docs/doc[@for="ComponentDocumentDesigner.IOleDragClient.IsDropOk"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>Gets a value indicating if it is valid to drop this type of a component on this client.</para>
        /// </devdoc>
        bool IOleDragClient.IsDropOk(IComponent component) {
            return true;
        }
        
        /// <include file='doc\CompositionDesigner.uex' path='docs/doc[@for="ComponentDocumentDesigner.IRootDesigner.SupportedTechnologies"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// The list of technologies that this designer can support
        /// for its view.  Examples of different technologies are
        /// Windows Forms and Web Forms.  Other object models can be
        /// supported at design time, but they most be able to
        /// provide a view in one of the supported technologies.
        /// </devdoc>
        ViewTechnology[] IRootDesigner.SupportedTechnologies {
            get {
                return new ViewTechnology[] {ViewTechnology.WindowsForms};
            }
        }
        
        /// <include file='doc\CompositionDesigner.uex' path='docs/doc[@for="ComponentDocumentDesigner.IRootDesigner.GetView"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// The view for this document.  The designer
        /// should assume that the view will be shown shortly
        /// after this call is made and make any necessary
        /// preparations.
        /// </devdoc>
        object IRootDesigner.GetView(ViewTechnology technology) {
            if (technology != ViewTechnology.WindowsForms) {
                throw new ArgumentException();
            }
            return compositionUI;
        }
        
        /// <include file='doc\CompositionDesigner.uex' path='docs/doc[@for="ComponentDocumentDesigner.IToolboxUser.GetToolSupported"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>Gets a value indicating whether the specified tool is supported by this 
        /// designer.</para>
        /// </devdoc>
        bool IToolboxUser.GetToolSupported(ToolboxItem tool) {
            return true;
        }

        /// <include file='doc\CompositionDesigner.uex' path='docs/doc[@for="ComponentDocumentDesigner.IToolboxUser.ToolPicked"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>Creates the specified tool.</para>
        /// </devdoc>
        void IToolboxUser.ToolPicked(ToolboxItem tool) {
            compositionUI.CreateComponentFromTool(tool);
            IToolboxService toolboxService = (IToolboxService)GetService(typeof(IToolboxService));
            if (toolboxService != null) {
                toolboxService.SelectedToolboxItemUsed();
            }
        }

        /// <include file='doc\CompositionDesigner.uex' path='docs/doc[@for="ComponentDocumentDesigner.ITypeDescriptorFilterService.FilterAttributes"]/*' />
        /// <summary>
        ///     ITypeDescriptorFilterService implementation.
        /// </summary>
        /// <internalonly/>
        bool ITypeDescriptorFilterService.FilterAttributes(IComponent component, IDictionary attributes) {
            if (delegateFilterService != null)
                return delegateFilterService.FilterAttributes(component, attributes);                
                
            return true;                
        }
        
        /// <include file='doc\CompositionDesigner.uex' path='docs/doc[@for="ComponentDocumentDesigner.ITypeDescriptorFilterService.FilterEvents"]/*' />
        /// <summary>
        ///     ITypeDescriptorFilterService implementation.
        /// </summary>
        /// <internalonly/>
        bool ITypeDescriptorFilterService.FilterEvents(IComponent component, IDictionary events) {
            if (delegateFilterService != null)
                return delegateFilterService.FilterEvents(component, events);                
                
            return true;                
        }
        
        /// <include file='doc\CompositionDesigner.uex' path='docs/doc[@for="ComponentDocumentDesigner.ITypeDescriptorFilterService.FilterProperties"]/*' />
        /// <summary>
        ///     ITypeDescriptorFilterService implementation.
        /// </summary>                      
        /// <internalonly/>
        bool ITypeDescriptorFilterService.FilterProperties(IComponent component, IDictionary properties) {                                    
            if (delegateFilterService != null)
                delegateFilterService.FilterProperties(component, properties);                
            
            PropertyDescriptor prop;

            string[] noBrowseProps = new string[] {
                "Location",
            };

            prop = (PropertyDescriptor)properties["Location"];
            if (prop != null) {
                properties["Location"] = TypeDescriptor.CreateProperty(prop.ComponentType, prop, BrowsableAttribute.No);
            }
            
            return true;                
        }

        private class WatermarkLabel : LinkLabel {
            private CompositionUI compositionUI;

            public WatermarkLabel(CompositionUI compositionUI) {
                this.compositionUI = compositionUI;
            }

            protected override void WndProc(ref Message m) {
                switch (m.Msg) {
                    case NativeMethods.WM_NCHITTEST:
                        // label returns HT_TRANSPARENT for everything, so all messages get
                        // routed to the parent.  Change this so we can tell what's going on.
                        //
                        Point pt = PointToClient(new Point((int)m.LParam));
                        if (PointInLink(pt.X, pt.Y) == null) {
                            m.Result = (IntPtr)NativeMethods.HTTRANSPARENT;
                            break;
                        }
                        base.WndProc(ref m);
                        break;
                    
                    case NativeMethods.WM_SETCURSOR:
                        if (OverrideCursor == null)
                            compositionUI.SetCursor();
                        else
                            base.WndProc(ref m);
                        break;

                    default:
                        base.WndProc(ref m);
                        break;
                }
            }
        }

        /// <include file='doc\CompositionDesigner.uex' path='docs/doc[@for="ComponentDocumentDesigner.CompositionUI"]/*' />
        /// <devdoc>
        ///      The composition UI is the full UI for our composition designer.  We
        ///      inherit from ComponentTray so we get most of the UI for free.
        /// </devdoc>
        private class CompositionUI : ComponentTray {

            private WatermarkLabel watermark;

            // How high is the top banner in the designer.
            private const int bannerHeight = 40;

            // The width of the border around the client rect.
            private const int borderWidth = 10;

            private IToolboxService toolboxService;
            private ComponentDocumentDesigner compositionDesigner;
            private IServiceProvider serviceProvider;

            private SelectionUIHandler      dragHandler;

            /// <include file='doc\CompositionDesigner.uex' path='docs/doc[@for="ComponentDocumentDesigner.CompositionUI.CompositionUI"]/*' />
            /// <devdoc>
            ///      Creates a new CompositionUI object.
            /// </devdoc>
            public CompositionUI(ComponentDocumentDesigner compositionDesigner, IServiceProvider provider) : base(compositionDesigner, provider) {
                this.compositionDesigner = compositionDesigner;
                this.serviceProvider = provider;

                this.watermark = new WatermarkLabel(this);
                watermark.TextAlign = System.Drawing.ContentAlignment.MiddleCenter;
                watermark.LinkClicked += new LinkLabelLinkClickedEventHandler(this.OnLinkClick);
                watermark.Dock = System.Windows.Forms.DockStyle.Fill;
                watermark.TabStop = false;
                watermark.Text = SR.GetString(SR.CompositionDesignerWaterMark);

                try {
                    int wmBegin = Int32.Parse(SR.GetString(SR.CompositionDesignerWaterMarkBegin1));
                    int wmLength = Int32.Parse(SR.GetString(SR.CompositionDesignerWaterMarkLength1));
                    watermark.Links.Add(wmBegin, wmLength, "ServerExplorer");

                    wmBegin = Int32.Parse(SR.GetString(SR.CompositionDesignerWaterMarkBegin2));
                    wmLength = Int32.Parse(SR.GetString(SR.CompositionDesignerWaterMarkLength2));
                    watermark.Links.Add(wmBegin, wmLength, "Toolbox");
                
                    wmBegin = Int32.Parse(SR.GetString(SR.CompositionDesignerWaterMarkBegin3));
                    wmLength = Int32.Parse(SR.GetString(SR.CompositionDesignerWaterMarkLength3));
                    watermark.Links.Add(wmBegin, wmLength, "CodeView");
                }
                catch (Exception e) {
                    Debug.WriteLine(e.ToString());
                }

                this.Controls.Add(watermark);
            }

            /// <include file='doc\CompositionDesigner.uex' path='docs/doc[@for="ComponentDocumentDesigner.CompositionUI.AddComponent"]/*' />
            /// <devdoc>
            ///      Adds a component to the tray.
            /// </devdoc>
            public override void AddComponent(IComponent component) {
                base.AddComponent(component);
                if (Controls.Count > 0) {
                    watermark.Visible = false;
                }
            }

            protected override bool CanCreateComponentFromTool(ToolboxItem tool) {
                return true;
            }

            internal override OleDragDropHandler GetOleDragHandler() {
                if (oleDragDropHandler == null) {
                    oleDragDropHandler = new OleDragDropHandler(this.DragHandler, serviceProvider, this);
                }
                return oleDragDropHandler;
            }

            /// <include file='doc\CompositionDesigner.uex' path='docs/doc[@for="ComponentDocumentDesigner.CompositionUI.DragHandler"]/*' />
            /// <devdoc>
            ///      Creates a selection UI drag handler for us to use.  You may override
            ///      this if you want to provide different drag semantics.
            /// </devdoc>
            internal override SelectionUIHandler DragHandler {
                get {
                    if (dragHandler == null) {
                        dragHandler = new CompositionSelectionUIHandler(compositionDesigner);
                    }
                    return dragHandler;
                }
            }

            private void OnLinkClick(object sender, LinkLabelLinkClickedEventArgs e) {
                IUIService uis = (IUIService)compositionDesigner.GetService(typeof(IUIService));
                if (uis != null) {
                    string s = (string)e.Link.LinkData;
                    if (s == "ServerExplorer")
                        uis.ShowToolWindow(StandardToolWindows.ServerExplorer);
                    else if (s == "Toolbox")
                        uis.ShowToolWindow(StandardToolWindows.Toolbox);
                    else {
                        Debug.Assert(s == "CodeView", "LinkData unknown: " + s);
                        IEventBindingService evt = (IEventBindingService)serviceProvider.GetService(typeof(IEventBindingService));
                        if (evt != null) {
                            evt.ShowCode();
                        }
                    }
                }
            }

            /// <include file='doc\CompositionDesigner.uex' path='docs/doc[@for="ComponentDocumentDesigner.CompositionUI.SetCursor"]/*' />
            /// <devdoc>
            ///      Sets the cursor.  We override to provide support for the toolbox.
            /// </devdoc>
            internal void SetCursor() {
                if (toolboxService == null) {
                    toolboxService = (IToolboxService)GetService(typeof(IToolboxService));
                }

                if (toolboxService == null || !toolboxService.SetCursor()) {
                    base.OnSetCursor();
                }
            }

            /// <include file='doc\CompositionDesigner.uex' path='docs/doc[@for="ComponentDocumentDesigner.CompositionUI.OnDragDrop"]/*' />
            /// <devdoc>
            ///      We don't want to allow drag/drop operations onto the banner area.
            /// </devdoc>
            protected override void OnDragDrop(DragEventArgs de) {
                Rectangle clientRect = this.ClientRectangle;

                if (clientRect.Contains(this.PointToClient(new Point(de.X, de.Y)))) {
                    base.OnDragDrop(de);
                    return;
                }
                else {
                    de.Effect = DragDropEffects.None;
                }
            }

            /// <include file='doc\CompositionDesigner.uex' path='docs/doc[@for="ComponentDocumentDesigner.CompositionUI.OnDragOver"]/*' />
            /// <devdoc>
            ///      We don't want to allow drag/drop operations onto the banner area.
            /// </devdoc>
            protected override void OnDragOver(DragEventArgs de) {
                Rectangle clientRect = this.ClientRectangle;

                if (clientRect.Contains(this.PointToClient(new Point(de.X, de.Y)))) {
                    base.OnDragOver(de);
                    return;
                }
                else {
                    de.Effect = DragDropEffects.None;
                }
            }

            protected override void OnResize(EventArgs e) {
                base.OnResize(e);
                if (watermark != null) {
                    watermark.Location = new Point(0, Size.Height/2);
                    watermark.Size = new Size(Width, Size.Height/2);
                }
            }

            /// <include file='doc\CompositionDesigner.uex' path='docs/doc[@for="ComponentDocumentDesigner.CompositionUI.OnSetCursor"]/*' />
            /// <devdoc>
            ///      Sets the cursor.  We override to provide support for the toolbox.
            /// </devdoc>
            protected override void OnSetCursor() {
                SetCursor();
            }

            /// <include file='doc\CompositionDesigner.uex' path='docs/doc[@for="ComponentDocumentDesigner.CompositionUI.RemoveComponent"]/*' />
            /// <devdoc>
            ///      Removes a component from the tray.
            /// </devdoc>
            public override void RemoveComponent(IComponent component) {
                base.RemoveComponent(component);
                if (Controls.Count == 1) {
                    watermark.Visible = true;
                }
            }

            /// <include file='doc\CompositionDesigner.uex' path='docs/doc[@for="ComponentDocumentDesigner.CompositionUI.WndProc"]/*' />
            /// <devdoc>
            ///      We override the wndproc of the control so we can intercept non client
            ///      messages.  We create the banner for the composition designer by
            ///      changing the dimensions of the non-client area.
            /// </devdoc>
            protected override void WndProc(ref Message m) {
                switch (m.Msg) {
                    default:
                        base.WndProc(ref m);
			break;
                }
            }

            /// <include file='doc\CompositionDesigner.uex' path='docs/doc[@for="ComponentDocumentDesigner.CompositionUI.CompositionSelectionUIHandler"]/*' />
            /// <devdoc>
            ///      This class inherits from the abstract SelectionUIHandler
            ///      class to provide a selection UI implementation for the
            ///      composition designer.
            /// </devdoc>
            private class CompositionSelectionUIHandler : SelectionUIHandler {

                private ComponentDocumentDesigner compositionDesigner;

                /// <include file='doc\CompositionDesigner.uex' path='docs/doc[@for="ComponentDocumentDesigner.CompositionUI.CompositionSelectionUIHandler.CompositionSelectionUIHandler"]/*' />
                /// <devdoc>
                ///      Creates a new selection UI handler for the given
                ///      composition designer.
                /// </devdoc>
                public CompositionSelectionUIHandler(ComponentDocumentDesigner compositionDesigner) {
                    this.compositionDesigner = compositionDesigner;
                }

                /// <include file='doc\CompositionDesigner.uex' path='docs/doc[@for="ComponentDocumentDesigner.CompositionUI.CompositionSelectionUIHandler.GetComponent"]/*' />
                /// <devdoc>
                ///      Retrieves the base component for the selection handler.
                /// </devdoc>
                protected override IComponent GetComponent() {
                    return compositionDesigner.Component;
                }

                /// <include file='doc\CompositionDesigner.uex' path='docs/doc[@for="ComponentDocumentDesigner.CompositionUI.CompositionSelectionUIHandler.GetControl"]/*' />
                /// <devdoc>
                ///      Retrieves the base component's UI control for the selection handler.
                /// </devdoc>
                protected override Control GetControl() {
                    return compositionDesigner.Control;
                }

                /// <include file='doc\CompositionDesigner.uex' path='docs/doc[@for="ComponentDocumentDesigner.CompositionUI.CompositionSelectionUIHandler.GetControl1"]/*' />
                /// <devdoc>
                ///      Retrieves the UI control for the given component.
                /// </devdoc>
                protected override Control GetControl(IComponent component) {
                    return TrayControl.FromComponent(component);
                }

                /// <include file='doc\CompositionDesigner.uex' path='docs/doc[@for="ComponentDocumentDesigner.CompositionUI.CompositionSelectionUIHandler.GetCurrentSnapSize"]/*' />
                /// <devdoc>
                ///      Retrieves the current grid snap size we should snap objects
                ///      to.
                /// </devdoc>
                protected override Size GetCurrentSnapSize() {
                    return new Size(8, 8);
                }

                /// <include file='doc\CompositionDesigner.uex' path='docs/doc[@for="ComponentDocumentDesigner.CompositionUI.CompositionSelectionUIHandler.GetService"]/*' />
                /// <devdoc>
                ///      We use this to request often-used services.
                /// </devdoc>
                protected override object GetService(Type serviceType) {
                    return compositionDesigner.GetService(serviceType);
                }

                /// <include file='doc\CompositionDesigner.uex' path='docs/doc[@for="ComponentDocumentDesigner.CompositionUI.CompositionSelectionUIHandler.GetShouldSnapToGrid"]/*' />
                /// <devdoc>
                ///      Determines if the selection UI handler should attempt to snap
                ///      objects to a grid.
                /// </devdoc>
                protected override bool GetShouldSnapToGrid() {
                    return false;
                }

                /// <include file='doc\CompositionDesigner.uex' path='docs/doc[@for="ComponentDocumentDesigner.CompositionUI.CompositionSelectionUIHandler.GetUpdatedRect"]/*' />
                /// <devdoc>
                ///      Given a rectangle, this updates the dimensions of it
                ///      with any grid snaps and returns a new rectangle.  If
                ///      no changes to the rectangle's size were needed, this
                ///      may return the same rectangle.
                /// </devdoc>
                public override Rectangle GetUpdatedRect(Rectangle originalRect, Rectangle dragRect, bool updateSize) {
                    Rectangle updatedRect;

                    if (GetShouldSnapToGrid()) {
                        Rectangle newRect = dragRect;

                        int left = dragRect.X;
                        int top = dragRect.Y;
                        int right = dragRect.X + dragRect.Width;
                        int bottom = dragRect.Y + dragRect.Height;

                        Size snapSize = new Size(8, 8);

                        int offsetX = (snapSize.Width / 2) * (left < 0 ? -1 : 1);
                        int offsetY = (snapSize.Height / 2) * (top < 0 ? -1 : 1);

                        newRect.X = ((left + offsetX) / snapSize.Width) * snapSize.Width;
                        newRect.Y = ((top + offsetY) / snapSize.Height) * snapSize.Height;

                        offsetX = (snapSize.Width / 2) * (right < 0 ? -1 : 1);
                        offsetY = (snapSize.Height / 2) * (bottom < 0 ? -1 : 1);

                        if (updateSize) {
                            newRect.Width = ((right + offsetX) / snapSize.Width) * snapSize.Width - newRect.X;
                            newRect.Height = ((bottom + offsetY) / snapSize.Height) * snapSize.Height - newRect.Y;
                        }

                        updatedRect = newRect;
                    }
                    else {
                        updatedRect = dragRect;
                    }

                    return updatedRect;
                }

                /// <include file='doc\CompositionDesigner.uex' path='docs/doc[@for="ComponentDocumentDesigner.CompositionUI.CompositionSelectionUIHandler.SetCursor"]/*' />
                /// <devdoc>
                ///     Asks the handler to set the appropriate cursor
                /// </devdoc>
                public override void SetCursor() {
                    compositionDesigner.compositionUI.OnSetCursor();
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\controlcollectioncodedomserializer.cs ===
//------------------------------------------------------------------------------
// <copyright file="ControlCollectionCodeDomSerializer.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms.Design {

    internal class ControlCollectionCodeDomSerializer : System.ComponentModel.Design.Serialization.CollectionCodeDomSerializer
    {
        protected override bool PreferAddRange {
            get {
                return false;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\commandset.cs ===
//------------------------------------------------------------------------------
// <copyright file="CommandSet.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms.Design {
    using System.Design;
    using System.Runtime.InteropServices;
    using System.Runtime.Serialization.Formatters.Binary;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.IO;
    using System;    
    using System.ComponentModel.Design;
    using System.ComponentModel.Design.Serialization;
    using System.Windows.Forms;
    using System.Drawing;
    using System.Drawing.Design;
    using System.Collections;
    using Microsoft.Win32;
    using System.Windows.Forms.Design;
    using System.Windows.Forms.ComponentModel;

    /// <include file='doc\CommandSet.uex' path='docs/doc[@for="CommandSet"]/*' />
    /// <devdoc>
    ///      This class implements the standard set of menu commands for
    ///      the form designer.  This set of command is shared between
    ///      the form designer (and other UI-based form packages), and
    ///      composition designer, which doesn't manipulate controls.
    ///      Therefore, this set of command should only contain commands
    ///      that are common to both functions.
    /// </devdoc>
    /// <internalonly/>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class CommandSet : IDisposable {
        protected ISite                   site;
        private CommandSetItem[]        commandSet;
        private IMenuCommandService     menuService;
        private IEventHandlerService    eventService;

        // Selection service fields.  We keep some state about the
        // currently selected components so we can determine proper
        // command enabling quickly.
        //
        private   ISelectionService       selectionService;
        private   ISelectionUIService     selectionUIService;
        protected int                     selCount;                // the current selection count
        protected IComponent              primarySelection;        // the primary selection, or null
        private   bool                    selectionInherited;      // the selection contains inherited components
        protected bool                    controlsOnlySelection;   // is the selection containing only controls or are there components in it? 

        // Selection sort constants
        //
        private const int SORT_HORIZONTAL  = 0;
        private const int SORT_VERTICAL    = 1;
        private const int SORT_ZORDER      = 2;

        private const string CF_DESIGNER =  "CF_DESIGNERCOMPONENTS";

        /// <include file='doc\CommandSet.uex' path='docs/doc[@for="CommandSet.CommandSet"]/*' />
        /// <devdoc>
        ///     Creates a new CommandSet object.  This object implements the set
        ///     of commands that the UI.Win32 form designer offers.
        /// </devdoc>
        public CommandSet(ISite site) {
            this.site = site;

            eventService = (IEventHandlerService)GetService(typeof(IEventHandlerService));
            Debug.Assert(eventService != null, "Command set must have the event service.  Is command set being initialized too early?");

            eventService.EventHandlerChanged += new EventHandler(this.OnEventHandlerChanged);

            IDesignerHost host = (IDesignerHost)site.GetService(typeof(IDesignerHost));
            Debug.Assert(!CompModSwitches.CommonDesignerServices.Enabled || host != null, "IDesignerHost not found");

            if (host != null) {
                host.Activated += new EventHandler(this.UpdateClipboardItems);
            }

            // Establish our set of commands
            //
            commandSet = new CommandSetItem[] {

                // Editing commands
                new CommandSetItem(
                                  this,
                                  new EventHandler(OnStatusDelete),
                                  new EventHandler(OnMenuDelete),
                                  MenuCommands.Delete),

                new CommandSetItem(
                                  this,
                                  new EventHandler(OnStatusCopy),
                                  new EventHandler(OnMenuCopy),
                                  MenuCommands.Copy),

                new CommandSetItem(
                                  this,
                                  new EventHandler(OnStatusCut),
                                  new EventHandler(OnMenuCut),
                                  MenuCommands.Cut),

                new ImmediateCommandSetItem(
                                           this,
                                           new EventHandler(OnStatusPaste),
                                           new EventHandler(OnMenuPaste),
                                           MenuCommands.Paste),


                // Miscellaneous commands
                new CommandSetItem(
                                  this,
                                  new EventHandler(OnStatusSelectAll),
                                  new EventHandler(OnMenuSelectAll),
                                  MenuCommands.SelectAll),

                new CommandSetItem(
                                  this,
                                  new EventHandler(OnStatusAlways),
                                  new EventHandler(OnMenuDesignerProperties),
                                  MenuCommands.DesignerProperties),

                // Keyboard commands
                new CommandSetItem(
                                  this,
                                  new EventHandler(OnStatusAlways),
                                  new EventHandler(OnKeyCancel),
                                  MenuCommands.KeyCancel),

                new CommandSetItem(
                                  this,
                                  new EventHandler(OnStatusAlways),
                                  new EventHandler(OnKeyCancel),
                                  MenuCommands.KeyReverseCancel),

                new CommandSetItem(
                                  this,
                                  new EventHandler(OnStatusAnySelection),
                                  new EventHandler(OnKeyDefault),
                                  MenuCommands.KeyDefaultAction),

                new CommandSetItem(
                                  this,
                                  new EventHandler(OnStatusAnySelection),
                                  new EventHandler(OnKeyMove),
                                  MenuCommands.KeyMoveUp),

                new CommandSetItem(
                                  this,
                                  new EventHandler(OnStatusAnySelection),
                                  new EventHandler(OnKeyMove),
                                  MenuCommands.KeyMoveDown),

                new CommandSetItem(
                                  this,
                                  new EventHandler(OnStatusAnySelection),
                                  new EventHandler(OnKeyMove),
                                  MenuCommands.KeyMoveLeft),

                new CommandSetItem(
                                  this,
                                  new EventHandler(OnStatusAnySelection),
                                  new EventHandler(OnKeyMove),
                                  MenuCommands.KeyMoveRight),

                new CommandSetItem(
                                  this,
                                  new EventHandler(OnStatusAnySelection),
                                  new EventHandler(OnKeyMove),
                                  MenuCommands.KeyNudgeUp),

                new CommandSetItem(
                                  this,
                                  new EventHandler(OnStatusAnySelection),
                                  new EventHandler(OnKeyMove),
                                  MenuCommands.KeyNudgeDown),

                new CommandSetItem(
                                  this,
                                  new EventHandler(OnStatusAnySelection),
                                  new EventHandler(OnKeyMove),
                                  MenuCommands.KeyNudgeLeft),

                new CommandSetItem(
                                  this,
                                  new EventHandler(OnStatusAnySelection),
                                  new EventHandler(OnKeyMove),
                                  MenuCommands.KeyNudgeRight),
            };

            selectionService = (ISelectionService)GetService(typeof(ISelectionService));
            Debug.Assert(selectionService != null, "CommandSet relies on the selection service, which is unavailable.");
            if (selectionService != null) {
                selectionService.SelectionChanged += new EventHandler(this.OnSelectionChanged);
            }

            if (MenuService != null) {
                for (int i = 0; i < commandSet.Length; i++) {
                    MenuService.AddCommand(commandSet[i]);
                }
            }
        }

        /// <include file='doc\CommandSet.uex' path='docs/doc[@for="CommandSet.MenuService"]/*' />
        /// <devdoc>
        ///      Retrieves the menu command service, which the command set
        ///      typically uses quite a bit.
        /// </devdoc>
        protected IMenuCommandService MenuService {
            get {
                if (menuService == null) {
                    menuService = (IMenuCommandService)GetService(typeof(IMenuCommandService));
                    Debug.Assert(menuService != null, "CommandSet relies on the menu command service, which is unavailable.");
                }

                return menuService;
            }
        }

        /// <include file='doc\CommandSet.uex' path='docs/doc[@for="CommandSet.SelectionCount"]/*' />
        /// <devdoc>
        ///      Retrieves the count of the currently selected objects.
        /// </devdoc>
        protected int SelectionCount {
            get {
                return selCount;
            }
        }

        /// <include file='doc\CommandSet.uex' path='docs/doc[@for="CommandSet.SelectionInherited"]/*' />
        /// <devdoc>
        ///      Determines if the selection contains any inherited components.
        /// </devdoc>
        protected bool SelectionInherited {
            get {
                return selectionInherited;
            }
        }

        /// <include file='doc\CommandSet.uex' path='docs/doc[@for="CommandSet.SelectionPrimary"]/*' />
        /// <devdoc>
        ///      Retrieves the current primary selection, if there is one.
        /// </devdoc>
        protected IComponent SelectionPrimary {
            get {
                return primarySelection;
            }
        }

        /// <include file='doc\CommandSet.uex' path='docs/doc[@for="CommandSet.SelectionService"]/*' />
        /// <devdoc>
        ///      Retrieves the selection service, which the command set
        ///      typically uses quite a bit.
        /// </devdoc>
        protected ISelectionService SelectionService {
            get {
                return selectionService;
            }
        }

        /// <include file='doc\CommandSet.uex' path='docs/doc[@for="CommandSet.SelectionUIService"]/*' />
        /// <devdoc>
        ///      Retrieves the selection UI service, which the command set
        ///      typically uses quite a bit.
        /// </devdoc>
        internal ISelectionUIService SelectionUIService {
            get {
                if (selectionUIService == null) {
                    selectionUIService = (ISelectionUIService)GetService(typeof(ISelectionUIService));
                    Debug.Assert(selectionUIService != null, "CommandSet relies on the selection UI service, which is unavailable.");
                }

                return selectionUIService;
            }
        }

        /// <include file='doc\CommandSet.uex' path='docs/doc[@for="CommandSet.CheckComponentEditor"]/*' />
        /// <devdoc>
        ///     Checks if an object supports ComponentEditors, and optionally launches
        ///     the editor.
        /// </devdoc>
        private bool CheckComponentEditor(object obj, bool launchEditor) {

            if (obj is IComponent) {
                try {
                    if (!launchEditor) {
                        return true;
                    }

                    ComponentEditor editor = (ComponentEditor)TypeDescriptor.GetEditor(obj, typeof(ComponentEditor));
                    if (editor == null) {
                        return false;
                    }

                    bool success = false;
                    IComponentChangeService changeService = (IComponentChangeService)GetService(typeof(IComponentChangeService));

                    if (changeService != null) {
                        try {
                            changeService.OnComponentChanging(obj, null);
                        }
                        catch (CheckoutException coEx) {
                            if (coEx == CheckoutException.Canceled) {
                                return false;
                            }
                            throw coEx;
                        }
                    }

                    if (editor is WindowsFormsComponentEditor) {

                        IWin32Window parent = null;

                        if (obj is IWin32Window) {
                            parent = (IWin32Window)parent;
                        }

                        success = ((WindowsFormsComponentEditor)editor).EditComponent(obj, parent);
                    }
                    else {
                        success = editor.EditComponent(obj);
                    }

                    if (success && changeService != null) {
                        // Now notify the change service that the change was successful.
                        //
                        changeService.OnComponentChanged(obj, null, null, null);
                    }
                    return true;
                }
                catch (Exception) {
                }
            }
            return false;
        }

        /// <include file='doc\CommandSet.uex' path='docs/doc[@for="CommandSet.Dispose"]/*' />
        /// <devdoc>
        ///     Disposes of this object, removing all commands from the menu service.
        /// </devdoc>
        public virtual void Dispose() {
            if (menuService != null) {
                for (int i = 0; i < commandSet.Length; i++) {
                    menuService.RemoveCommand(commandSet[i]);
                }
                menuService = null;
            }

            if (selectionService != null) {
                selectionService.SelectionChanged -= new EventHandler(this.OnSelectionChanged);
                selectionService = null;
            }

            if (eventService != null) {
                eventService.EventHandlerChanged -= new EventHandler(this.OnEventHandlerChanged);
                eventService = null;
            }

            IDesignerHost host = (IDesignerHost)site.GetService(typeof(IDesignerHost));
            Debug.Assert(!CompModSwitches.CommonDesignerServices.Enabled || host != null, "IDesignerHost not found");
            if (host != null) {
                host.Activated -= new EventHandler(this.UpdateClipboardItems);
            }

            site = null;
        }

        /// <include file='doc\CommandSet.uex' path='docs/doc[@for="CommandSet.GetCopySelection"]/*' />
        /// <devdoc>
        ///     Used to retrieve the selection for a copy.  The default implementation
        ///     retrieves the current selection.
        /// </devdoc>
        protected virtual ICollection GetCopySelection() {
            ICollection selectedComponents = SelectionService.GetSelectedComponents();
            object[] comps = new object[selectedComponents.Count];
            selectedComponents.CopyTo(comps, 0);
            SortSelection(comps, SORT_ZORDER);
            selectedComponents = comps;
            IDesignerHost host = (IDesignerHost)site.GetService(typeof(IDesignerHost));
            if (host != null) {
                ArrayList copySelection = new ArrayList();
                foreach (IComponent comp in selectedComponents) {
                    copySelection.Add(comp);
                    GetAssociatedComponents(comp, host, copySelection);
                }   
                selectedComponents = copySelection;
            }
            return selectedComponents;
        }

        private void GetAssociatedComponents(IComponent component, IDesignerHost host, ArrayList list) {
            ComponentDesigner designer = host.GetDesigner(component) as ComponentDesigner;
            if (designer == null) {
                return;
            }

            foreach (IComponent childComp in designer.AssociatedComponents) {
                list.Add(childComp);
                GetAssociatedComponents(childComp, host, list);
            }
        }

        /// <include file='doc\CommandSet.uex' path='docs/doc[@for="CommandSet.GetLocation"]/*' />
        /// <devdoc>
        ///     Used to retrieve the current location of the given component.
        /// </devdoc>
        private Point GetLocation(IComponent comp) {
            PropertyDescriptor prop = GetProperty(comp, "Location");

            if (prop != null) {
                try {
                    return(Point)prop.GetValue(comp);
                }
                catch (Exception e) {
                    Debug.Fail("Commands may be disabled, the location property was not accessible", e.ToString());
                }
            }
            return Point.Empty;
        }

        /// <include file='doc\CommandSet.uex' path='docs/doc[@for="CommandSet.GetProperty"]/*' />
        /// <devdoc>
        ///     Retrieves the given property on the given component.
        /// </devdoc>
        protected PropertyDescriptor GetProperty(object comp, string propName) {
            return TypeDescriptor.GetProperties(comp)[propName];
        }

        /// <include file='doc\CommandSet.uex' path='docs/doc[@for="CommandSet.GetService"]/*' />
        /// <devdoc>
        ///      Retrieves the requested service.
        /// </devdoc>
        protected virtual object GetService(Type serviceType) {
            if (site != null) {
                return site.GetService(serviceType);
            }
            return null;
        }

        /// <include file='doc\CommandSet.uex' path='docs/doc[@for="CommandSet.GetSize"]/*' />
        /// <devdoc>
        ///     Used to retrieve the current size of the given component.
        /// </devdoc>
        private Size GetSize(IComponent comp) {
            PropertyDescriptor prop = GetProperty(comp, "Size");
            if (prop != null) {
                return(Size)prop.GetValue(comp);
            }
            return Size.Empty;
        }

        /// <include file='doc\CommandSet.uex' path='docs/doc[@for="CommandSet.GetSnapInformation"]/*' />
        /// <devdoc>
        ///      Retrieves the snap information for the given component.  
        /// </devdoc>
        protected virtual void GetSnapInformation(IDesignerHost host, IComponent component, out Size snapSize, out IComponent snapComponent, out PropertyDescriptor snapProperty) {

            // This implementation is shared by all.  It just looks for snap properties on the base component.
            //
            IComponent currentSnapComponent = null;
            IContainer container = component.Site.Container;
            PropertyDescriptor gridSizeProp = null;
            PropertyDescriptor currentSnapProp = null;
            PropertyDescriptorCollection props;

            currentSnapComponent = host.RootComponent;
            props = TypeDescriptor.GetProperties(currentSnapComponent);

            currentSnapProp = props["SnapToGrid"];
            if (currentSnapProp != null&& currentSnapProp.PropertyType != typeof(bool)) {
                currentSnapProp = null;
            }

            gridSizeProp = props["GridSize"];
            if (gridSizeProp != null && gridSizeProp.PropertyType != typeof(Size)) {
                gridSizeProp = null;
            }

            // Finally, now that we've got the various properties and components, dole out the
            // values.
            //
            snapComponent = currentSnapComponent;
            snapProperty = currentSnapProp;
            if (gridSizeProp != null) {
                snapSize = (Size)gridSizeProp.GetValue(snapComponent);
            }
            else {
                snapSize = Size.Empty;
            }
        }

        /// <include file='doc\CommandSet.uex' path='docs/doc[@for="CommandSet.OnEventHandlerChanged"]/*' />
        /// <devdoc>
        ///      Called by the event handler service when the current event handler
        ///      has changed.  Here we invalidate all of our menu items so that
        ///      they can pick up the new event handler.
        /// </devdoc>
        private void OnEventHandlerChanged(object sender, EventArgs e) {
            OnUpdateCommandStatus();
        }

        /// <include file='doc\CommandSet.uex' path='docs/doc[@for="CommandSet.OnKeyCancel"]/*' />
        /// <devdoc>
        ///     Called for the two cancel commands we support.
        /// </devdoc>
        private void OnKeyCancel(object sender, EventArgs e) {
            OnKeyCancel(sender);
        }

        /// <include file='doc\CommandSet.uex' path='docs/doc[@for="CommandSet.OnKeyCancel1"]/*' />
        /// <devdoc>
        ///     Called for the two cancel commands we support.  Returns true
        ///     If we did anything with the cancel, or false if not.
        /// </devdoc>
        protected virtual bool OnKeyCancel(object sender) {
            bool handled = false;

            // The base implementation here just checks to see if we are dragging.
            // If we are, then we abort the drag.
            //
            ISelectionUIService uis = SelectionUIService;
            if (uis != null && uis.Dragging) {
                uis.EndDrag(true);
                handled = true;
            }
            else {
                IToolboxService tbx = (IToolboxService)GetService(typeof(IToolboxService));
                if (tbx != null && tbx.GetSelectedToolboxItem((IDesignerHost)GetService(typeof(IDesignerHost))) != null) {
                    tbx.SelectedToolboxItemUsed();

                    NativeMethods.POINT p = new NativeMethods.POINT();
                    NativeMethods.GetCursorPos(p);
                    IntPtr hwnd = NativeMethods.WindowFromPoint(p.x, p.y);
                    if (hwnd != IntPtr.Zero) {
                        NativeMethods.SendMessage(hwnd, NativeMethods.WM_SETCURSOR, hwnd, (IntPtr)NativeMethods.HTCLIENT);
                    }
                    else {
                        Cursor.Current = Cursors.Default;
                    }
                    handled = true;
                }
            }

            return handled;
        }

        /// <include file='doc\CommandSet.uex' path='docs/doc[@for="CommandSet.OnKeyDefault"]/*' />
        /// <devdoc>
        ///      Called for the "default" command, typically the Enter key.
        /// </devdoc>
        protected void OnKeyDefault(object sender, EventArgs e) {

            // Return key.  Handle it like a double-click on the
            // primary selection
            //
            ISelectionService selSvc = SelectionService;

            if (selSvc != null) {
                object pri = selSvc.PrimarySelection;
                if (pri != null && pri is IComponent) {
                    IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
                    if (host != null) {
                        IDesigner designer = host.GetDesigner((IComponent)pri);

                        if (designer != null) {
                            designer.DoDefaultAction();
                        }
                    }
                }
            }
        }

        /// <include file='doc\CommandSet.uex' path='docs/doc[@for="CommandSet.OnKeyMove"]/*' />
        /// <devdoc>
        ///      Called for all cursor movement commands.
        /// </devdoc>
        protected void OnKeyMove(object sender, EventArgs e) {
            // Arrow keys.  Begin a drag if the selection isn't locked.
            //
            ISelectionService selSvc = SelectionService;
            ISelectionUIService uiSvc = SelectionUIService;

            if (uiSvc != null && selSvc != null) {

                object comp = selSvc.PrimarySelection;
                if (comp != null && comp is IComponent) {

                    PropertyDescriptor lockedProp = TypeDescriptor.GetProperties(comp)["Locked"];
                    if (lockedProp == null  || (lockedProp.PropertyType == typeof(bool) && ((bool)lockedProp.GetValue(comp))) == false) {

                        CommandID cmd = ((MenuCommand)sender).CommandID;
                        bool invertSnap = false;
                        int moveOffsetX = 0;
                        int moveOffsetY = 0;

                        if (cmd.Equals(MenuCommands.KeyMoveUp)) {
                            moveOffsetY = -1;
                        }
                        else if (cmd.Equals(MenuCommands.KeyMoveDown)) {
                            moveOffsetY = 1;
                        }
                        else if (cmd.Equals(MenuCommands.KeyMoveLeft)) {
                            moveOffsetX = -1;
                        }
                        else if (cmd.Equals(MenuCommands.KeyMoveRight)) {
                            moveOffsetX = 1;
                        }
                        else if (cmd.Equals(MenuCommands.KeyNudgeUp)) {
                            moveOffsetY = -1;
                            invertSnap = true;
                        }
                        else if (cmd.Equals(MenuCommands.KeyNudgeDown)) {
                            moveOffsetY = 1;
                            invertSnap = true;
                        }
                        else if (cmd.Equals(MenuCommands.KeyNudgeLeft)) {
                            moveOffsetX = -1;
                            invertSnap = true;
                        }
                        else if (cmd.Equals(MenuCommands.KeyNudgeRight)) {
                            moveOffsetX = 1;
                            invertSnap = true;
                        }
                        else {
                            Debug.Fail("Unknown command mapped to OnKeyMove: " + cmd.ToString());
                        }

                        if (uiSvc.BeginDrag(SelectionRules.Moveable | SelectionRules.Visible, 0, 0)) {
                            bool snapOn = false;
                            Size snapSize = Size.Empty;
                            IComponent snapComponent = null;
                            PropertyDescriptor snapProperty = null;

                            // Gets the needed snap information
                            //
                            IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
                            DesignerTransaction trans = null;

                            try {
                                if (host != null) {
                                    GetSnapInformation(host, (IComponent)comp, out snapSize, out snapComponent, out snapProperty);

                                    if (selSvc.SelectionCount > 1) {
                                        trans = host.CreateTransaction(SR.GetString(SR.DragDropMoveComponents, selSvc.SelectionCount));
                                    }
                                    else {
                                        trans = host.CreateTransaction(SR.GetString(SR.DragDropMoveComponent, ((IComponent)comp).Site.Name));
                                    }
                                    if (snapProperty != null) {
                                        snapOn = (bool)snapProperty.GetValue(snapComponent);

                                        if (invertSnap) {
                                            snapOn = !snapOn;
                                            snapProperty.SetValue(snapComponent, snapOn);
                                        }
                                    }
                                }

                                if (snapOn && !snapSize.IsEmpty) {
                                    moveOffsetX *= snapSize.Width;
                                    moveOffsetY *= snapSize.Height;
                                }


                                // Now move the controls the correct # of pixels.
                                //
                                uiSvc.DragMoved(new Rectangle(moveOffsetX, moveOffsetY, 0, 0));
                                uiSvc.EndDrag(false);

                                if (host != null) {
                                    if (invertSnap && snapProperty != null) {
                                        snapOn = !snapOn;
                                        snapProperty.SetValue(snapComponent, snapOn);
                                    }
                                }
                            }
                            finally {
                                if (trans != null) {
                                    trans.Commit();
                                }
                            }
                        }
                    }
                }
            }
        }

        /// <include file='doc\CommandSet.uex' path='docs/doc[@for="CommandSet.OnMenuAlignByPrimary"]/*' />
        /// <devdoc>
        ///     Called for all alignment operations that key off of a primary
        ///     selection.
        /// </devdoc>
        protected void OnMenuAlignByPrimary(object sender, EventArgs e) {

            MenuCommand cmd = (MenuCommand)sender;
            CommandID id = cmd.CommandID;

            //Need to get the location for the primary control, we do this here
            //(instead of onselectionchange) because the control could be dragged 
            //around once it is selected and might have a new location
            Point primaryLocation = GetLocation(primarySelection);
            Size  primarySize     = GetSize(primarySelection);

            if (SelectionService == null) {
                return;
            }

            Cursor oldCursor = Cursor.Current;
            try {
                Cursor.Current = Cursors.WaitCursor;

                // Now loop through each of the components.
                //
                ICollection comps = SelectionService.GetSelectedComponents();


                // Inform the designer that we are about to monkey with a ton
                // of properties.
                //
                IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
                Debug.Assert(!CompModSwitches.CommonDesignerServices.Enabled || host != null, "IDesignerHost not found");
                DesignerTransaction trans = null;

                if (host != null) {
                    trans = host.CreateTransaction(SR.GetString(SR.CommandSetAlignByPrimary, comps.Count));
                }

                Point loc = Point.Empty;
                foreach(object obj in comps) {

                    if (obj == primarySelection) {
                        continue;
                    }

                    if (obj is IComponent && host != null) {
                        IDesigner des = host.GetDesigner((IComponent)obj);
                        if (!(des is ControlDesigner)) {
                            continue;
                        }
                    }

                    IComponent comp = (IComponent)obj;

                    PropertyDescriptorCollection props = TypeDescriptor.GetProperties(comp);

                    PropertyDescriptor locProp = props["Location"];
                    PropertyDescriptor sizeProp = props["Size"];
                    PropertyDescriptor lockProp = props["Locked"];

                    // Skip all components that are locked
                    //
                    if (lockProp != null) {
                        if ((bool)lockProp.GetValue(comp))
                            continue;
                    }

                    // Skip all components that don't have a location property
                    //
                    if (locProp == null || locProp.IsReadOnly) {
                        continue;
                    }

                    // Skip all components that don't have size if we're
                    // doing a size operation.
                    //
                    if (id.Equals(MenuCommands.AlignBottom) ||
                        id.Equals(MenuCommands.AlignHorizontalCenters) ||
                        id.Equals(MenuCommands.AlignVerticalCenters) ||
                        id.Equals(MenuCommands.AlignRight)) {
                        if (sizeProp == null || sizeProp.IsReadOnly) {
                            continue;
                        }
                    }

                    // Align bottom
                    //
                    if (id.Equals(MenuCommands.AlignBottom)) {
                        loc = (Point)locProp.GetValue(comp);
                        Size size = (Size)sizeProp.GetValue(comp);
                        loc.Y = primaryLocation.Y + primarySize.Height - size.Height;
                    }
                    // Align horizontal centers
                    //
                    else if (id.Equals(MenuCommands.AlignHorizontalCenters)) {
                        loc = (Point)locProp.GetValue(comp);
                        Size size = (Size)sizeProp.GetValue(comp);
                        loc.Y = primarySize.Height / 2 + primaryLocation.Y - size.Height / 2;
                    }
                    // Align left
                    //
                    else if (id.Equals(MenuCommands.AlignLeft)) {
                        loc = (Point)locProp.GetValue(comp);
                        loc.X = primaryLocation.X;
                    }
                    // Align right
                    //
                    else if (id.Equals(MenuCommands.AlignRight)) {
                        loc = (Point)locProp.GetValue(comp);
                        Size size = (Size)sizeProp.GetValue(comp);
                        loc.X = primaryLocation.X + primarySize.Width - size.Width;
                    }
                    // Align top
                    //
                    else if (id.Equals(MenuCommands.AlignTop)) {
                        loc = (Point)locProp.GetValue(comp);
                        loc.Y = primaryLocation.Y;
                    }
                    // Align vertical centers
                    //
                    else if (id.Equals(MenuCommands.AlignVerticalCenters)) {
                        loc = (Point)locProp.GetValue(comp);
                        Size size = (Size)sizeProp.GetValue(comp);
                        loc.X = primarySize.Width / 2 + primaryLocation.X - size.Width / 2;
                    }
                    else {
                        Debug.Fail("Unrecognized command: " + id.ToString());
                    }

                    locProp.SetValue(comp, loc);
                }

                if (trans != null) {
                    trans.Commit();
                }
            }
            finally {
                Cursor.Current = oldCursor;
            }
        }

        /// <include file='doc\CommandSet.uex' path='docs/doc[@for="CommandSet.OnMenuAlignToGrid"]/*' />
        /// <devdoc>
        ///     Called when the align->to grid menu item is selected.
        /// </devdoc>
        protected void OnMenuAlignToGrid(object sender, EventArgs e) {
            Size gridSize = Size.Empty;
            PropertyDescriptor locProp = null;
            PropertyDescriptor lockedProp = null;
            Point loc = Point.Empty;
            int delta;

            if (SelectionService == null) {
                return;
            }

            Cursor oldCursor = Cursor.Current;
            try {
                Cursor.Current = Cursors.WaitCursor;

                ICollection selectedComponents = SelectionService.GetSelectedComponents();
                IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
                Debug.Assert(!CompModSwitches.CommonDesignerServices.Enabled || host != null, "IDesignerHost not found");
                DesignerTransaction trans = null;

                try {
                    if (host != null) {
                        trans = host.CreateTransaction(SR.GetString(SR.CommandSetAlignToGrid, selectedComponents.Count));

                        IComponent baseComponent = host.RootComponent;
                        if (baseComponent != null && baseComponent is Control) {
                            PropertyDescriptor prop = GetProperty(baseComponent, "GridSize");
                            if (prop != null) {
                                gridSize = (Size)prop.GetValue(baseComponent);
                            }
                        }

                    }
                    // for each component, we round to the nearest snap offset for x and y
                    foreach(object comp in selectedComponents) {

                        // first check to see if the component is locked, if so - don't move it...
                        lockedProp = GetProperty(comp, "Locked");
                        if (lockedProp != null && ((bool)lockedProp.GetValue(comp)) == true) {
                            continue;
                        }

                        // if the designer for this component isn't a ControlDesigner (maybe
                        // it's something in the component tray) then don't try to align it to grid.
                        //
                        if (comp is IComponent && host != null) {
                            IDesigner des = host.GetDesigner((IComponent)comp);
                            if (!(des is ControlDesigner)) {
                                continue;
                            }
                        }

                        // get the location property
                        locProp = GetProperty(comp, "Location");

                        // get the current value
                        if (locProp == null || locProp.IsReadOnly) {
                            continue;
                        }
                        loc = (Point)locProp.GetValue(comp);

                        // round the x to the snap size
                        delta = loc.X % gridSize.Width;
                        if (delta < (gridSize.Width / 2)) {
                            loc.X -= delta;
                        }
                        else {
                            loc.X += (gridSize.Width - delta);
                        }

                        // round the y to the gridsize
                        delta = loc.Y % gridSize.Height;
                        if (delta < (gridSize.Height / 2)) {
                            loc.Y -= delta;
                        }
                        else {
                            loc.Y += (gridSize.Height - delta);
                        }

                        // set the value
                        locProp.SetValue(comp, loc);
                    }
                }
                finally {
                    if (trans != null) {
                        trans.Commit();
                    }
                }
            }
            finally {
                Cursor.Current = oldCursor;
            }
        }

        /// <include file='doc\CommandSet.uex' path='docs/doc[@for="CommandSet.OnMenuCenterSelection"]/*' />
        /// <devdoc>
        ///     Called when the center horizontally or center vertically menu item is selected.
        /// </devdoc>
        protected void OnMenuCenterSelection(object sender, EventArgs e) {

            MenuCommand cmd = (MenuCommand)sender;
            CommandID   cmdID = cmd.CommandID;

            if (SelectionService == null) {
                return;
            }

            Cursor oldCursor = Cursor.Current;
            try {
                Cursor.Current = Cursors.WaitCursor;

                // NOTE: this only works on Control types
                ICollection selectedComponents = SelectionService.GetSelectedComponents();
                Control     viewParent = null;
                Size        size = Size.Empty;
                Point       loc = Point.Empty;

                IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
                Debug.Assert(!CompModSwitches.CommonDesignerServices.Enabled || host != null, "IDesignerHost not found");
                DesignerTransaction trans = null;

                try {
                    if (host != null) {
                        string batchString;

                        if (cmdID == MenuCommands.CenterHorizontally) {
                            batchString = SR.GetString(SR.WindowsFormsCommandCenterX, selectedComponents.Count);
                        }
                        else {
                            batchString = SR.GetString(SR.WindowsFormsCommandCenterY, selectedComponents.Count);
                        }
                        trans = host.CreateTransaction(batchString);
                    }

                    //subhag calculate the union REctangle : ASURT 67753
                    //
                    int top = Int32.MaxValue;
                    int left = Int32.MaxValue;
                    int right = Int32.MinValue;
                    int bottom = Int32.MinValue;

                    foreach (object obj in selectedComponents) {
                        if (obj is Control) {

                            IComponent comp = (IComponent)obj;
                            PropertyDescriptorCollection props = TypeDescriptor.GetProperties(comp);

                            PropertyDescriptor locProp = props[ "Location"];
                            PropertyDescriptor sizeProp = props["Size"];

                            // Skip all components that don't have location and size properties
                            //
                            if (locProp == null || sizeProp == null || locProp.IsReadOnly || sizeProp.IsReadOnly) {
                                continue;
                            }

                            // Also, skip all locked componenents...
                            //
                            PropertyDescriptor lockProp = props["Locked"];
                            if (lockProp != null && (bool)lockProp.GetValue(comp) == true) {
                                return;
                            }

                            size = (Size)sizeProp.GetValue(comp);
                            loc = (Point)locProp.GetValue(comp);

                            //Get the parent to know the delta between parent client area and union rect
                            //
                            viewParent = ((Control)comp).Parent;
                            if (loc.X < left)
                                left = loc.X;
                            if (loc.Y < top)
                                top = loc.Y;
                            if (loc.X + size.Width > right)
                                right =  loc.X + size.Width;
                            if (loc.Y + size.Height > bottom)
                                bottom = loc.Y + size.Height;
                        }
                    }

                    int centerOfUnionRectX = (left + right) / 2;
                    int centerOfUnionRectY = (top + bottom) / 2;

                    int centerOfParentX = (viewParent.ClientSize.Width) / 2;
                    int centerOfParentY = (viewParent.ClientSize.Height) / 2;

                    int deltaX=0;
                    int deltaY=0;

                    bool shiftRight = false;
                    bool shiftBottom = false;

                    if (centerOfParentX >= centerOfUnionRectX) {
                        deltaX = centerOfParentX - centerOfUnionRectX;
                        shiftRight = true;
                    }
                    else
                        deltaX = centerOfUnionRectX - centerOfParentX;

                    if (centerOfParentY >= centerOfUnionRectY) {
                        deltaY = centerOfParentY - centerOfUnionRectY;
                        shiftBottom = true;
                    }
                    else
                        deltaY = centerOfUnionRectY - centerOfParentY;


                    foreach(object obj in selectedComponents) {
                        if (obj is Control) {

                            IComponent comp = (IComponent)obj;
                            PropertyDescriptorCollection props = TypeDescriptor.GetProperties(comp);

                            PropertyDescriptor locProp = props[ "Location"];
                            loc = (Point)locProp.GetValue(comp);

                            if (cmdID == MenuCommands.CenterHorizontally) {
                                if (shiftRight)
                                    loc.X += deltaX;
                                else
                                    loc.X -= deltaX;
                            }
                            else if (cmdID == MenuCommands.CenterVertically) {
                                if (shiftBottom)
                                    loc.Y += deltaY;
                                else
                                    loc.Y -= deltaY;
                            }
                            locProp.SetValue(comp, loc);
                        }
                    }
                }
                finally {
                    if (trans != null) {
                        trans.Commit();
                    }
                }
            }
            finally {
                Cursor.Current = oldCursor;
            }
        }

        /// <include file='doc\CommandSet.uex' path='docs/doc[@for="CommandSet.OnMenuCopy"]/*' />
        /// <devdoc>
        ///     Called when the copy menu item is selected.
        /// </devdoc>
        protected void OnMenuCopy(object sender, EventArgs e) {
            if (SelectionService == null) {
                return;
            }

            Cursor oldCursor = Cursor.Current;
            try {
                Cursor.Current = Cursors.WaitCursor;

                ICollection selectedComponents = GetCopySelection();
                IDesignerSerializationService ds = (IDesignerSerializationService)GetService(typeof(IDesignerSerializationService));
                Debug.Assert(ds != null, "No designer serialization service -- we cannot copy to clipboard");
                if (ds != null) {
                    object serializationData = ds.Serialize(selectedComponents);
                    Stream stream = new MemoryStream();
                    BinaryFormatter formatter = new BinaryFormatter();
                    formatter.Serialize(stream, serializationData);
                    stream.Seek(0, SeekOrigin.Begin);
                    IDataObject dataObj = new DataObject(CF_DESIGNER, stream);
                    Clipboard.SetDataObject(dataObj);
                }
                UpdateClipboardItems(null,null);
            }
            finally {
                Cursor.Current = oldCursor;
            }
        }

        /// <include file='doc\CommandSet.uex' path='docs/doc[@for="CommandSet.OnMenuCut"]/*' />
        /// <devdoc>
        ///     Called when the cut menu item is selected.
        /// </devdoc>
        protected void OnMenuCut(object sender, EventArgs e) {

            if (SelectionService == null) {
                return;
            }

            Cursor oldCursor = Cursor.Current;
            try {
                Cursor.Current = Cursors.WaitCursor;

                ICollection selectedComponents = GetCopySelection();
                IDesignerSerializationService ds = (IDesignerSerializationService)GetService(typeof(IDesignerSerializationService));
                Debug.Assert(ds != null, "No designer serialization service -- we cannot copy to clipboard");
                if (ds != null) {
                    object serializationData = ds.Serialize(selectedComponents);
                    Stream stream = new MemoryStream();
                    BinaryFormatter formatter = new BinaryFormatter();
                    formatter.Serialize(stream, serializationData);
                    stream.Seek(0, SeekOrigin.Begin);
                    IDataObject dataObj = new DataObject(CF_DESIGNER, stream);
                    Clipboard.SetDataObject(dataObj);

                    IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
                    Control commonParent = null;

                    if (host != null) {
                        DesignerTransaction trans = null;

                        try {

                            trans = host.CreateTransaction(SR.GetString(SR.CommandSetCutMultiple, selectedComponents.Count));

                            // clear the selected components so we aren't browsing them
                            //
                            SelectionService.SetSelectedComponents(new object[0], SelectionTypes.Replace);

                            int idx = 0;
                            // go backward so we destroy parents before children
                            foreach(object obj in selectedComponents) {
                                idx++;

                                // We should never delete the base component.
                                //
                                if (obj == host.RootComponent || !(obj is IComponent)) {
                                    continue;
                                }

                                if (idx == 1 && obj is Control) {
                                    commonParent = ((Control)obj).Parent;
                                }
                                else if (commonParent != null && obj is Control) {
                                    Control selectedControl = (Control)obj;

                                    if (selectedControl.Parent != commonParent && !commonParent.Contains(selectedControl)) {

                                        // look for internal parenting
                                        if (selectedControl == commonParent || selectedControl.Contains(commonParent)) {
                                            commonParent = selectedControl.Parent;
                                        }
                                        else {
                                            commonParent = null;
                                        }
                                    }

                                }

                                host.DestroyComponent((IComponent)obj);
                            }
                        }
                        finally {
                            if (trans != null)
                                trans.Commit();
                        }

                        if (commonParent != null) {
                            SelectionService.SetSelectedComponents(new object[]{commonParent}, SelectionTypes.Replace);
                        }
                        else {
                            SelectionService.SetSelectedComponents(new object[]{host.RootComponent}, SelectionTypes.Replace);
                        }
                    }
                }
            }
            finally {
                Cursor.Current = oldCursor;
            }
        }

        /// <include file='doc\CommandSet.uex' path='docs/doc[@for="CommandSet.OnMenuDelete"]/*' />
        /// <devdoc>
        ///     Called when the delete menu item is selected.
        /// </devdoc>
        protected void OnMenuDelete(object sender, EventArgs e) {
            Cursor oldCursor = Cursor.Current;
            try {
                Cursor.Current = Cursors.WaitCursor;
                if (site != null) {
                    IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
                    Debug.Assert(!CompModSwitches.CommonDesignerServices.Enabled || host != null, "IDesignerHost not found");

                    if (SelectionService == null) {
                        return;
                    }

                    if (host != null) {

                        IComponentChangeService changeService = (IComponentChangeService)GetService(typeof(IComponentChangeService));


                        ICollection comps = SelectionService.GetSelectedComponents();
                        string desc = SR.GetString(SR.CommandSetDelete, comps.Count);

                        DesignerTransaction trans = null;
                        Control commonParent = null;

                        try {
                            trans = host.CreateTransaction(desc);

                            int idx = 0;
                            SelectionService.SetSelectedComponents(new object[0], SelectionTypes.Replace);
                            foreach(object obj in comps) {
                                idx ++;

                                // If it's not a component, we can't delete it.  It also may have already been deleted
                                // as part of a parent operation, so we skip it.
                                //
                                if (!(obj is IComponent) || ((IComponent)obj).Site == null) {
                                    continue;
                                }

                                // We should never delete the base component.
                                //
                                if (obj == host.RootComponent) {
                                    continue;
                                }

                                if (idx == 1 && obj is Control) {
                                    commonParent = ((Control)obj).Parent;
                                }
                                else if (commonParent != null && obj is Control) {
                                    Control selectedControl = (Control)obj;

                                    if (selectedControl.Parent != commonParent && !commonParent.Contains(selectedControl)) {

                                        // look for internal parenting
                                        if (selectedControl == commonParent || selectedControl.Contains(commonParent)) {
                                            commonParent = selectedControl.Parent;
                                        }
                                        else {
                                            // start walking up until we find a common parent
                                            while (commonParent != null && !commonParent.Contains(selectedControl)) {
                                                commonParent = commonParent.Parent;
                                            }
                                        }
                                    }

                                }

                                ArrayList al = new ArrayList();
                                GetAssociatedComponents((IComponent)obj, host, al);
                                foreach(IComponent comp in al) {
                                    changeService.OnComponentChanging(comp, null);
                                }
                                host.DestroyComponent((IComponent)obj);
                            }
                        }
                        finally {
                            if (trans != null) {
                                trans.Commit();
                            }
                        }


                        if (commonParent != null) {

                            // if we have a common parent, select it's first child
                            //
                            if (commonParent.Controls.Count > 0) {
                                commonParent = commonParent.Controls[0];

                                // 126240 -- make sure we've got a sited thing.
                                //
                                while (commonParent != null && commonParent.Site == null) {
                                    commonParent = commonParent.Parent;
                                }
                            }

                            SelectionService.SetSelectedComponents(new object[]{commonParent}, SelectionTypes.Replace);
                        }
                        else {
                            SelectionService.SetSelectedComponents(new object[]{host.RootComponent}, SelectionTypes.Replace);
                        }
                    }
                }
            }
            finally {
                Cursor.Current = oldCursor;
            }
        }

        /// <include file='doc\CommandSet.uex' path='docs/doc[@for="CommandSet.OnMenuPaste"]/*' />
        /// <devdoc>
        ///     Called when the paste menu item is selected.
        /// </devdoc>
        protected void OnMenuPaste(object sender, EventArgs e) {
            Cursor oldCursor = Cursor.Current;

            try {
                Cursor.Current = Cursors.WaitCursor;

                IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
                Debug.Assert(!CompModSwitches.CommonDesignerServices.Enabled || host != null, "IDesignerHost not found");
                if (host == null) return;   // nothing we can do here!

                IDataObject dataObj = Clipboard.GetDataObject();
                ICollection components = null;
                bool createdItems = false;

                // We understand two things:  CF_DESIGNER, and toolbox items.
                //
                object data = dataObj.GetData(CF_DESIGNER);

                DesignerTransaction trans = null;

                try {
                    trans = host.CreateTransaction(SR.GetString(SR.CommandSetPaste, 0));

                    if (data is Stream) {
                        // CF_DESIGNER was put on the clipboard by us using the designer
                        // serialization service.
                        //
                        IDesignerSerializationService ds = (IDesignerSerializationService)GetService(typeof(IDesignerSerializationService));
                        if (ds != null) {
                            BinaryFormatter formatter = new BinaryFormatter();
                            ((Stream)data).Seek(0, SeekOrigin.Begin);
                            object serializationData = formatter.Deserialize((Stream)data);
                            components = ds.Deserialize(serializationData);
                        }
                    }
                    else {
                        // Now check for a toolbox item.
                        //
                        IToolboxService ts = (IToolboxService)GetService(typeof(IToolboxService));

                        if (ts != null && ts.IsSupported(dataObj, host)) {
                            ToolboxItem ti = ts.DeserializeToolboxItem(dataObj, host);
                            if (ti != null) {
                                components = ti.CreateComponents(host);

                                foreach(object obj in components) {
                                    // ASURT 39016.
                                    //
                                    if (obj is IComponent) {
                                        IComponent component = (IComponent)obj;
                                        IDesigner designer = host.GetDesigner(component);
                                        if (designer is ComponentDesigner) {
                                            ((ComponentDesigner)designer).OnSetComponentDefaults();
                                        }
                                    }
                                }
                                createdItems = true;
                            }
                        }
                    }
                }
                finally {
                    if (trans != null) {
                        trans.Commit();
                        trans = null;
                    }
                }

                // Now, if we got some components, hook 'em up!
                //
                if (components != null && components.Count > 0) {
                    IComponent curComp;
                    string name;

                    ArrayList selectComps = new ArrayList();
                    ArrayList controls = new ArrayList();

                    try {
                        trans = host.CreateTransaction(SR.GetString(SR.CommandSetPaste, components.Count));

                        // if the selected item is a frame designer, add to that, otherwise
                        // add to the form
                        IComponent selectedComponent = null;
                        IDesigner designer = null;
                        IDesigner baseDesigner=null;

                        bool dragClient = false;

                        foreach(object obj in components) {
                            name = null;

                            // see if we can fish out the name
                            if (obj is IComponent) {
                                curComp = (IComponent)obj;
                                if (curComp.Site != null) {
                                    name = curComp.Site.Name;
                                }
                            }
                            else {
                                continue;
                            }

                            IContainer container = host.Container;
                            IComponent baseComponent = host.RootComponent;

                            selectedComponent = (IComponent)SelectionService.PrimarySelection;

                            if (selectedComponent == null) {
                                selectedComponent = baseComponent;
                            }

                            baseDesigner = host.GetDesigner(baseComponent);

                            dragClient = false;
                            while (!dragClient && selectedComponent != null) {
                                designer = host.GetDesigner(selectedComponent);

                                if (designer is IOleDragClient) {
                                    dragClient = true;
                                }
                                else {
                                    // if we've already got the base designer, quit
                                    if (baseDesigner == designer) {
                                        break;
                                    }
                                    else if (designer != null && selectedComponent is Control) {
                                        selectedComponent = ((Control)selectedComponent).Parent;
                                    }
                                    else {
                                        selectedComponent = host.RootComponent;
                                    }
                                    continue;
                                }
                            }

                            if (dragClient) {
                                Control c = curComp as Control;

                                // these adds automatically fixup children so we skip them
                                if (c == null || c.Parent == null) {
                                    bool changeName = false;

                                    if (c != null) {

                                        // if the text is the same as the name, remember it.
                                        // After we add the control, we'll update the text with
                                        // the new name.
                                        //
                                        if (name != null && name.Equals(c.Text)) {
                                            changeName = true;
                                        }
                                    }

                                    if (!((IOleDragClient)designer).AddComponent(curComp, name, createdItems)) {
                                        continue;
                                    }

                                    Control designerControl = ((IOleDragClient)designer).GetControlForComponent(curComp);
                                    if (designerControl != null) {
                                        controls.Add(designerControl);
                                    }

                                    if (TypeDescriptor.GetAttributes(curComp).Contains(DesignTimeVisibleAttribute.Yes)) {
                                        selectComps.Add(curComp);
                                    }

                                    if (changeName) {
                                        PropertyDescriptorCollection props = TypeDescriptor.GetProperties(curComp);
                                        PropertyDescriptor nameProp = props["Name"];
                                        if (nameProp != null && nameProp.PropertyType == typeof(string)) {
                                            string newName = (string)nameProp.GetValue(curComp);
                                            if (!newName.Equals(name)) {
                                                PropertyDescriptor textProp = props["Text"];
                                                if (textProp != null && textProp.PropertyType == nameProp.PropertyType) {
                                                    textProp.SetValue(curComp, nameProp.GetValue(curComp));
                                                }
                                            }
                                        }
                                    }

                                }
                            }
                            else {
                                if (container != null && container.Components[name] != null) {
                                    name = null;
                                }

                                container.Add(curComp, name);
                                continue;
                            }
                        }

                        //Here, we dived our list of 'controls' into 2 parts: 1) those controls
                        //that have ControlDesigners, and 2) those controls that belong in the 
                        //component tray.  For the scenario 1, we'll center them on the designer
                        //suface.  For scenario 2, we'll let the component tray adjust them
                        //
                        ArrayList compsWithControlDesigners = new ArrayList();
                        ArrayList compsForComponentTray = new ArrayList();

                        foreach (Control c in controls) {
                            IDesigner des = host.GetDesigner((IComponent)c);
                            if (des is ControlDesigner) {
                                compsWithControlDesigners.Add(c);
                            }
                            else {
                                compsForComponentTray.Add(c);
                            }
                        }

                        if (compsWithControlDesigners.Count > 0) {
                            // Update the control positions.  We want to keep the entire block
                            // of controls relative to each other, but relocate them within
                            // the container.
                            //
                            UpdatePastePositions(compsWithControlDesigners);
                        }

                        if (compsForComponentTray.Count > 0) {
                            // Try to get our component tray service, if we can - notify the tray
                            // to adjust the locs of these components
                            ComponentTray tray = (ComponentTray)GetService(typeof(ComponentTray));
                            Debug.Assert(tray != null, "Failed to get ComponentTray service");
                            if (tray != null) {
                                tray.UpdatePastePositions(compsForComponentTray);
                            }                            
                        }

                        // Update the tab indices of all the components.  We must first sort the
                        // components by their existing tab indices or else we will not preserve their
                        // original intent.
                        //
                        controls.Sort(new TabIndexCompare());
                        foreach(Control c in controls) {
                            UpdatePasteTabIndex(c, c.Parent);
                        }

                        // finally select all the components we added
                        SelectionService.SetSelectedComponents((object[])selectComps.ToArray(), SelectionTypes.Replace);

                        // and bring them to the front
                        MenuCommand btf = MenuService.FindCommand(MenuCommands.BringToFront);
                        if (btf != null) {
                            btf.Invoke();
                        }
                    }
                    finally {
                        if (trans != null)
                            trans.Commit();
                    }
                }
            }
            finally {
                Cursor.Current = oldCursor;
            }
        }

        /// <include file='doc\CommandSet.uex' path='docs/doc[@for="CommandSet.OnMenuSelectAll"]/*' />
        /// <devdoc>
        ///     Called when the select all menu item is selected.
        /// </devdoc>
        protected void OnMenuSelectAll(object sender, EventArgs e) {

            Cursor oldCursor = Cursor.Current;
            try {
                Cursor.Current = Cursors.WaitCursor;
                if (site != null) {

                    Debug.Assert(SelectionService != null, "We need the SelectionService, but we can't find it!");
                    if (SelectionService == null) {
                        return;
                    }

                    IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
                    Debug.Assert(!CompModSwitches.CommonDesignerServices.Enabled || host != null, "IDesignerHost not found");

                    if (host != null) {
                        ComponentCollection components = host.Container.Components;
                        object[] selComps;
                        if (components == null || components.Count == 0) {
                            selComps = new IComponent[0];
                        }
                        else {
                            selComps = new object[components.Count - 1];
                            object baseComp = host.RootComponent;
                            int j = 0;
                            foreach (IComponent comp in components) {
                                if (baseComp == comp) continue;
                                selComps[j++] = comp;
                            }
                        }
                        SelectionService.SetSelectedComponents(selComps, SelectionTypes.Replace);
                    }
                }
            }
            finally {
                Cursor.Current = oldCursor;
            }
        }

        /// <include file='doc\CommandSet.uex' path='docs/doc[@for="CommandSet.OnMenuShowGrid"]/*' />
        /// <devdoc>
        ///     Called when the show grid menu item is selected.
        /// </devdoc>
        protected void OnMenuShowGrid(object sender, EventArgs e) {

            if (site != null) {

                IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
                Debug.Assert(!CompModSwitches.CommonDesignerServices.Enabled || host != null, "IDesignerHost not found");

                if (host != null) {
                    DesignerTransaction trans = null;

                    try {
                        trans = host.CreateTransaction();

                        IComponent baseComponent = host.RootComponent;
                        if (baseComponent != null && baseComponent is Control) {
                            PropertyDescriptor prop = GetProperty(baseComponent, "DrawGrid");
                            if (prop != null) {
                                bool drawGrid = (bool)prop.GetValue(baseComponent);
                                prop.SetValue(baseComponent, !drawGrid);
                                ((MenuCommand)sender).Checked = !drawGrid;
                            }
                        }
                    }
                    finally {
                        if (trans != null)
                            trans.Commit();
                    }
                }
            }
        }

        /// <include file='doc\CommandSet.uex' path='docs/doc[@for="CommandSet.OnMenuSizingCommand"]/*' />
        /// <devdoc>
        ///     Handles the various size to commands.
        /// </devdoc>
        protected void OnMenuSizingCommand(object sender, EventArgs e) {
            MenuCommand cmd = (MenuCommand)sender;
            CommandID   cmdID = cmd.CommandID;

            if (SelectionService == null || SelectionUIService == null) {
                return;
            }

            Cursor oldCursor = Cursor.Current;
            try {
                Cursor.Current = Cursors.WaitCursor;

                ICollection sel = SelectionService.GetSelectedComponents();
                object[] selectedObjects = new object[sel.Count];
                sel.CopyTo(selectedObjects, 0);
                selectedObjects = SelectionUIService.FilterSelection(selectedObjects, SelectionRules.Visible);
                object selPrimary = SelectionService.PrimarySelection;

                Size primarySize = Size.Empty;
                Size itemSize = Size.Empty;
                PropertyDescriptor sizeProp;
                if (selPrimary is IComponent) {
                    sizeProp = GetProperty((IComponent)selPrimary, "Size");
                    if (sizeProp == null) {
                        //if we couldn't get a valid size for our primary selection, we'll fail silently
                        return;
                    }
                    primarySize = (Size)sizeProp.GetValue((IComponent)selPrimary);

                }
                if (selPrimary == null) {
                    return;
                }

                Debug.Assert(null != selectedObjects, "queryStatus should have disabled this");

                IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
                Debug.Assert(!CompModSwitches.CommonDesignerServices.Enabled || host != null, "IDesignerHost not found");
                DesignerTransaction trans = null;

                try {
                    if (host != null) {
                        trans = host.CreateTransaction(SR.GetString(SR.CommandSetSize, selectedObjects.Length));
                    }

                    foreach(object obj in selectedObjects) {

                        if (obj.Equals(selPrimary))
                            continue;

                        if (!(obj is IComponent)) {
                            continue;
                        }

                        //if the component is locked, no sizing is allowed...
                        PropertyDescriptor lockedDesc = GetProperty(obj, "Locked");
                        if (lockedDesc != null && (bool)lockedDesc.GetValue(obj)) {
                            continue;
                        }

                        IComponent comp = (IComponent)obj;

                        sizeProp = GetProperty(comp, "Size");

                        // Skip all components that don't have a size property
                        //
                        if (sizeProp == null || sizeProp.IsReadOnly) {
                            continue;
                        }

                        itemSize = (Size)sizeProp.GetValue(comp);

                        if (cmdID == MenuCommands.SizeToControlHeight ||
                            cmdID == MenuCommands.SizeToControl) {

                            itemSize.Height = primarySize.Height;
                        }

                        if (cmdID == MenuCommands.SizeToControlWidth ||
                            cmdID == MenuCommands.SizeToControl) {

                            itemSize.Width = primarySize.Width;
                        }

                        sizeProp.SetValue(comp, itemSize);
                    }
                }
                finally {
                    if (trans != null) {
                        trans.Commit();
                    }
                }
            }
            finally {
                Cursor.Current = oldCursor;
            }
        }

        /// <include file='doc\CommandSet.uex' path='docs/doc[@for="CommandSet.OnMenuSizeToGrid"]/*' />
        /// <devdoc>
        ///     Called when the size->to grid menu item is selected.
        /// </devdoc>
        protected void OnMenuSizeToGrid(object sender, EventArgs e) {

            if (SelectionService == null || SelectionUIService == null) {
                return;
            }

            Cursor oldCursor = Cursor.Current;
            IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
            Debug.Assert(!CompModSwitches.CommonDesignerServices.Enabled || host != null, "IDesignerHost not found");
            DesignerTransaction trans = null;

            try {
                Cursor.Current = Cursors.WaitCursor;

                ICollection sel = SelectionService.GetSelectedComponents();
                object[] selectedObjects = new object[sel.Count];
                sel.CopyTo(selectedObjects, 0);
                selectedObjects = SelectionUIService.FilterSelection(selectedObjects, SelectionRules.Visible);
                Size size = Size.Empty;
                Point loc = Point.Empty;

                Debug.Assert(null != selectedObjects, "queryStatus should have disabled this");
                Size grid = Size.Empty;
                PropertyDescriptor sizeProp = null;
                PropertyDescriptor locProp = null;

                if (host != null) {
                    trans = host.CreateTransaction(SR.GetString(SR.CommandSetSizeToGrid, selectedObjects.Length));

                    IComponent baseComponent = host.RootComponent;
                    if (baseComponent != null && baseComponent is Control) {
                        PropertyDescriptor prop = GetProperty(baseComponent, "CurrentGridSize");
                        if (prop != null) {
                            grid = (Size)prop.GetValue(baseComponent);
                        }
                    }
                }

                foreach(object obj in selectedObjects) {

                    if (!(obj is IComponent)) {
                        continue;
                    }

                    IComponent comp = (IComponent)obj;

                    sizeProp = GetProperty(comp, "Size");
                    locProp = GetProperty(comp, "Location");

                    Debug.Assert(sizeProp != null, "No size property on component");
                    Debug.Assert(locProp != null, "No location property on component");

                    if (sizeProp == null || locProp == null || sizeProp.IsReadOnly || locProp.IsReadOnly) {
                        continue;
                    }

                    size = (Size)sizeProp.GetValue(comp);
                    loc = (Point)locProp.GetValue(comp);

                    size.Width  = ((size.Width + (grid.Width/2)) / grid.Width) * grid.Width;
                    size.Height = ((size.Height + (grid.Height/2)) / grid.Height) * grid.Height;
                    loc.X = (loc.X / grid.Width) * grid.Width;
                    loc.Y = (loc.Y / grid.Height) * grid.Height;

                    sizeProp.SetValue(comp, size);
                    locProp.SetValue(comp, loc);
                }
            }
            finally {
                if (trans != null) {
                    trans.Commit();
                }
                Cursor.Current = oldCursor;
            }
        }

        /// <include file='doc\CommandSet.uex' path='docs/doc[@for="CommandSet.OnMenuDesignerProperties"]/*' />
        /// <devdoc>
        ///     Called when the properties menu item is selected on the Context menu
        /// </devdoc>
        protected void OnMenuDesignerProperties(object sender, EventArgs e) {

            // first, look if the currently selected object has a component editor...
            object obj = SelectionService.PrimarySelection;

            if (CheckComponentEditor(obj, true)) {
                return;
            }

            IMenuCommandService menuSvc = (IMenuCommandService)GetService(typeof(IMenuCommandService));
            if (menuSvc != null) {
                if (menuSvc.GlobalInvoke(MenuCommands.PropertiesWindow)) {
                    return;
                }
            }
            Debug.Assert(false, "Invoking pbrs command failed");
        }

        /// <include file='doc\CommandSet.uex' path='docs/doc[@for="CommandSet.OnMenuSnapToGrid"]/*' />
        /// <devdoc>
        ///     Called when the snap to grid menu item is selected.
        /// </devdoc>
        protected void OnMenuSnapToGrid(object sender, EventArgs e) {
            if (site != null) {

                IDesignerHost host = (IDesignerHost)site.GetService(typeof(IDesignerHost));

                if (host != null) {
                    DesignerTransaction trans = null;

                    try {
                        trans = host.CreateTransaction(SR.GetString(SR.CommandSetPaste, 0));

                        IComponent baseComponent = host.RootComponent;
                        if (baseComponent != null && baseComponent is Control) {
                            PropertyDescriptor prop = GetProperty(baseComponent, "SnapToGrid");
                            if (prop != null) {
                                bool snapToGrid = (bool)prop.GetValue(baseComponent);
                                prop.SetValue(baseComponent, !snapToGrid);
                                ((MenuCommand)sender).Checked = !snapToGrid;
                            }
                        }
                    }
                    finally {
                        if (trans != null)
                            trans.Commit();
                    }
                }
            }

        }

        /// <include file='doc\CommandSet.uex' path='docs/doc[@for="CommandSet.OnMenuSpacingCommand"]/*' />
        /// <devdoc>
        ///     Called when a spacing command is selected
        ///
        /// </devdoc>
        protected void OnMenuSpacingCommand(object sender, EventArgs e) {

            MenuCommand cmd = (MenuCommand)sender;
            CommandID cmdID = cmd.CommandID;
            DesignerTransaction trans = null;

            if (SelectionService == null || SelectionUIService == null) {
                return;
            }

            Cursor oldCursor = Cursor.Current;
            IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
            Debug.Assert(!CompModSwitches.CommonDesignerServices.Enabled || host != null, "IDesignerHost not found");

            try {
                Cursor.Current = Cursors.WaitCursor;

                // Inform the designer that we are about to monkey with a ton
                // of properties.
                //
                Size grid = Size.Empty;
                ICollection sel = SelectionService.GetSelectedComponents();
                object[] selectedObjects = new object[sel.Count];
                sel.CopyTo(selectedObjects, 0);

                if (host != null) {
                    trans = host.CreateTransaction(SR.GetString(SR.CommandSetFormatSpacing, selectedObjects.Length));

                    IComponent baseComponent = host.RootComponent;
                    if (baseComponent != null && baseComponent is Control) {
                        PropertyDescriptor prop = GetProperty(baseComponent, "CurrentGridSize");
                        if (prop != null) {
                            grid = (Size)prop.GetValue(baseComponent);
                        }
                    }
                }

                selectedObjects = SelectionUIService.FilterSelection(selectedObjects, SelectionRules.Visible);

                int       nEqualDelta = 0;

                Debug.Assert(null != selectedObjects, "queryStatus should have disabled this");

                PropertyDescriptor curSizeDesc=null, lastSizeDesc=null;
                PropertyDescriptor curLocDesc=null, lastLocDesc=null;
                Size curSize=Size.Empty, lastSize=Size.Empty;
                Point curLoc=Point.Empty, lastLoc=Point.Empty;
                Point primaryLoc=Point.Empty;
                IComponent curComp=null, lastComp=null;
                int sort = -1;

                // Must sort differently if we're horizontal or vertical...
                //
                if (cmdID == MenuCommands.HorizSpaceConcatenate ||
                    cmdID == MenuCommands.HorizSpaceDecrease ||
                    cmdID == MenuCommands.HorizSpaceIncrease ||
                    cmdID == MenuCommands.HorizSpaceMakeEqual) {
                    sort = SORT_HORIZONTAL;
                }
                else if (cmdID == MenuCommands.VertSpaceConcatenate ||
                         cmdID == MenuCommands.VertSpaceDecrease ||
                         cmdID == MenuCommands.VertSpaceIncrease ||
                         cmdID == MenuCommands.VertSpaceMakeEqual) {
                    sort = SORT_VERTICAL;
                }
                else {
                    throw new ArgumentException(SR.GetString(SR.CommandSetUnknownSpacingCommand));
                }

                SortSelection(selectedObjects, sort);

                //now that we're sorted, lets get our primary selection and it's index
                //
                object primary = SelectionService.PrimarySelection;
                int primaryIndex = 0;
                if (primary != null)
                    primaryIndex = Array.IndexOf(selectedObjects, primary);


                // And compute delta values for Make Equal
                if (cmdID == MenuCommands.HorizSpaceMakeEqual ||
                    cmdID == MenuCommands.VertSpaceMakeEqual) {
                    int total, n;

                    total = 0;
                    for (n = 0; n < selectedObjects.Length; n++) {

                        curSize = Size.Empty;

                        if (selectedObjects[n] is IComponent) {
                            curComp = (IComponent)selectedObjects[n];

                            curSizeDesc = GetProperty(curComp, "Size");
                            if (curSizeDesc != null) {
                                curSize = (Size)curSizeDesc.GetValue(curComp);
                            }
                        }

                        if (sort == SORT_HORIZONTAL) {
                            total += curSize.Width;
                        }
                        else {
                            total += curSize.Height;
                        }
                    }

                    lastComp = curComp = null;
                    curSize = Size.Empty;
                    curLoc = Point.Empty;

                    for (n = 0; n < selectedObjects.Length; n++) {
                        if (selectedObjects[n] is IComponent) {
                            curComp = (IComponent)selectedObjects[n];

                            // only get the descriptors if we've changed component types
                            if (lastComp == null || curComp.GetType() != lastComp.GetType()) {
                                curSizeDesc = GetProperty(curComp, "Size");
                                curLocDesc = GetProperty(curComp, "Location");
                            }
                            lastComp = curComp;

                            if (curLocDesc != null) {
                                curLoc = (Point)curLocDesc.GetValue(curComp);
                            }
                            else {
                                continue;
                            }

                            if (curSizeDesc != null) {
                                curSize = (Size)curSizeDesc.GetValue(curComp);
                            }
                            else {
                                continue;
                            }

                            if (!curSize.IsEmpty && !curLoc.IsEmpty) {
                                break;
                            }
                        }
                    }

                    for (n = selectedObjects.Length - 1; n >= 0; n--) {
                        if (selectedObjects[n] is IComponent) {
                            curComp = (IComponent)selectedObjects[n];

                            // only get the descriptors if we've changed component types
                            if (lastComp == null || curComp.GetType() != lastComp.GetType()) {
                                curSizeDesc = GetProperty(curComp, "Size");
                                curLocDesc = GetProperty(curComp, "Location");
                            }
                            lastComp = curComp;

                            if (curLocDesc != null) {
                                lastLoc = (Point)curLocDesc.GetValue(curComp);
                            }
                            else {
                                continue;
                            }

                            if (curSizeDesc != null) {
                                lastSize = (Size)curSizeDesc.GetValue(curComp);
                            }
                            else {
                                continue;
                            }

                            if (curSizeDesc != null && curLocDesc != null) {
                                break;
                            }
                        }
                    }

                    if (curSizeDesc != null && curLocDesc != null) {
                        if (sort == SORT_HORIZONTAL) {
                            nEqualDelta = (lastSize.Width + lastLoc.X - curLoc.X - total) / (selectedObjects.Length - 1);
                        }
                        else {
                            nEqualDelta = (lastSize.Height + lastLoc.Y - curLoc.Y - total) / (selectedObjects.Length - 1);
                        }
                        if (nEqualDelta < 0) nEqualDelta = 0;
                    }
                }


                curComp = lastComp = null;

                if (primary != null) {
                    PropertyDescriptor primaryLocDesc = GetProperty(primary, "Location");
                    if (primaryLocDesc != null) {
                        primaryLoc = (Point)primaryLocDesc.GetValue(primary);
                    }
                }

                // Finally move the components
                //
                for (int n = 0; n < selectedObjects.Length; n++) {

                    curComp = (IComponent)selectedObjects[n];

                    PropertyDescriptorCollection props = TypeDescriptor.GetProperties(curComp);

                    //Check to see if the component we are about to move is locked...
                    //
                    PropertyDescriptor lockedDesc = props[ "Locked"];
                    if (lockedDesc != null && (bool)lockedDesc.GetValue(curComp)) {
                        continue; // locked property of our component is true, so don't move it
                    }

                    if (lastComp == null || lastComp.GetType() != curComp.GetType()) {
                        curSizeDesc = props["Size"];
                        curLocDesc = props["Location"];
                    }
                    else {
                        curSizeDesc = lastSizeDesc;
                        curLocDesc = lastLocDesc;
                    }

                    if (curLocDesc != null) {
                        curLoc = (Point)curLocDesc.GetValue(curComp);
                    }
                    else {
                        continue;
                    }

                    if (curSizeDesc != null) {
                        curSize = (Size)curSizeDesc.GetValue(curComp);
                    }
                    else {
                        continue;
                    }

                    int lastIndex = Math.Max(0, n-1);
                    lastComp = (IComponent)selectedObjects[lastIndex];
                    if (lastComp.GetType() != curComp.GetType()) {
                        lastSizeDesc = GetProperty(lastComp, "Size");
                        lastLocDesc = GetProperty(lastComp, "Location");
                    }
                    else {
                        lastSizeDesc = curSizeDesc;
                        lastLocDesc = curLocDesc;
                    }

                    if (lastLocDesc != null) {
                        lastLoc = (Point)lastLocDesc.GetValue(lastComp);
                    }
                    else {
                        continue;
                    }

                    if (lastSizeDesc != null) {
                        lastSize = (Size)lastSizeDesc.GetValue(lastComp);
                    }
                    else {
                        continue;
                    }

                    if (cmdID == MenuCommands.HorizSpaceConcatenate && n > 0) {
                        curLoc.X = lastLoc.X + lastSize.Width;
                    }
                    else if (cmdID == MenuCommands.HorizSpaceDecrease) {
                        if (primaryIndex < n) {
                            curLoc.X -= grid.Width * (n - primaryIndex);
                            if (curLoc.X < primaryLoc.X)
                                curLoc.X = primaryLoc.X;
                        }
                        else if (primaryIndex > n) {
                            curLoc.X += grid.Width * (primaryIndex - n);
                            if (curLoc.X > primaryLoc.X)
                                curLoc.X = primaryLoc.X;
                        }
                    }
                    else if (cmdID == MenuCommands.HorizSpaceIncrease) {
                        if (primaryIndex < n) {
                            curLoc.X += grid.Width * (n - primaryIndex);
                        }
                        else if (primaryIndex > n) {
                            curLoc.X -= grid.Width * (primaryIndex - n);
                        }

                    }
                    else if (cmdID == MenuCommands.HorizSpaceMakeEqual && n > 0) {
                        curLoc.X = lastLoc.X + lastSize.Width + nEqualDelta;
                    }
                    else if (cmdID == MenuCommands.VertSpaceConcatenate && n > 0) {
                        curLoc.Y = lastLoc.Y + lastSize.Height;
                    }
                    else if (cmdID == MenuCommands.VertSpaceDecrease) {
                        if (primaryIndex < n) {
                            curLoc.Y -= grid.Height * (n - primaryIndex);
                            if (curLoc.Y < primaryLoc.Y)
                                curLoc.Y = primaryLoc.Y;
                        }
                        else if (primaryIndex > n) {
                            curLoc.Y += grid.Height * (primaryIndex - n);
                            if (curLoc.Y > primaryLoc.Y)
                                curLoc.Y = primaryLoc.Y;
                        }
                    }
                    else if (cmdID == MenuCommands.VertSpaceIncrease) {
                        if (primaryIndex < n) {
                            curLoc.Y += grid.Height * (n - primaryIndex);
                        }
                        else if (primaryIndex > n) {
                            curLoc.Y -= grid.Height * (primaryIndex - n);
                        }
                    }
                    else if (cmdID == MenuCommands.VertSpaceMakeEqual && n > 0) {
                        curLoc.Y = lastLoc.Y + lastSize.Height + nEqualDelta;
                    }

                    if (!curLocDesc.IsReadOnly) {
                        curLocDesc.SetValue(curComp, curLoc);
                    }

                    lastComp = curComp;
                }
            }
            finally {
                if (trans != null) {
                    trans.Commit();
                }
                Cursor.Current = oldCursor;
            }
        }

        /// <include file='doc\CommandSet.uex' path='docs/doc[@for="CommandSet.OnSelectionChanged"]/*' />
        /// <devdoc>
        ///     Called when the current selection changes.  Here we determine what
        ///     commands can and can't be enabled.
        /// </devdoc>
        protected void OnSelectionChanged(object sender, EventArgs e) {

            if (SelectionService == null || SelectionUIService == null) {
                return;
            }

            // Update our cached selection counts.
            //
            selCount = SelectionService.SelectionCount;

            IDesignerHost designerHost = (IDesignerHost)GetService(typeof(IDesignerHost));
            Debug.Assert(designerHost != null, "Failed to get designer host");

            // if the base component is selected, we'll say that nothing's selected
            // so we don't get wierd behavior
            if (selCount > 0 && designerHost != null) {
                object baseComponent = designerHost.RootComponent;
                if (baseComponent != null && SelectionService.GetComponentSelected(baseComponent)) {
                    selCount = 0;
                }
            }

            object primary = SelectionService.PrimarySelection;

            if (primary is IComponent) {
                primarySelection = (IComponent)primary;
            }
            else {
                primarySelection = null;
            }

            selectionInherited = false;
            controlsOnlySelection = true;

            if (selCount > 0) {
                ICollection selection = SelectionService.GetSelectedComponents();
                foreach(object obj in selection) {
                    if (!(obj is Control)) {
                        controlsOnlySelection = false;
                    }

                    if (!TypeDescriptor.GetAttributes(obj)[typeof(InheritanceAttribute)].Equals(InheritanceAttribute.NotInherited)) {
                        selectionInherited = true;
                        break;
                    }
                }
            }

            OnUpdateCommandStatus();
        }

        /// <include file='doc\CommandSet.uex' path='docs/doc[@for="CommandSet.OnStatusAlways"]/*' />
        /// <devdoc>
        ///     Determines the status of a menu command.  Commands with this event
        ///     handler are always enabled.
        /// </devdoc>
        protected void OnStatusAlways(object sender, EventArgs e) {
            MenuCommand cmd = (MenuCommand)sender;
            cmd.Enabled = true;
        }

        /// <include file='doc\CommandSet.uex' path='docs/doc[@for="CommandSet.OnStatusAnySelection"]/*' />
        /// <devdoc>
        ///     Determines the status of a menu command.  Commands with this event
        ///     handler are enabled when one or more objects are selected.
        /// </devdoc>
        protected void OnStatusAnySelection(object sender, EventArgs e) {
            MenuCommand cmd = (MenuCommand)sender;
            cmd.Enabled = selCount > 0;
        }

        /// <include file='doc\CommandSet.uex' path='docs/doc[@for="CommandSet.OnStatusCopy"]/*' />
        /// <devdoc>
        ///      Status for the copy command.  This is enabled when
        ///      there is something juicy selected.
        /// </devdoc>
        protected void OnStatusCopy(object sender, EventArgs e) {
            MenuCommand cmd = (MenuCommand)sender;
            bool enable = false;

            IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
            if (!selectionInherited && host != null && !host.Loading) {
                ISelectionService selSvc = (ISelectionService)GetService(typeof(ISelectionService));
                Debug.Assert(!CompModSwitches.CommonDesignerServices.Enabled || selSvc != null, "ISelectionService not found");

                if (selSvc != null) {

                    // There must also be a component in the mix, and not the base component
                    //
                    ICollection selectedComponents = selSvc.GetSelectedComponents();

                    object baseComp = host.RootComponent;
                    if (!selSvc.GetComponentSelected(baseComp)) {
                        foreach(object obj in selectedComponents) {
                            if (obj is IComponent) {
                                enable = true;
                                break;
                            }
                        }
                    }
                }
            }

            cmd.Enabled = enable;
        }

        /// <include file='doc\CommandSet.uex' path='docs/doc[@for="CommandSet.OnStatusCut"]/*' />
        /// <devdoc>
        ///      Status for the cut command.  This is enabled when
        ///      there is something juicy selected and that something
        ///      does not contain any inherited components.
        /// </devdoc>
        protected void OnStatusCut(object sender, EventArgs e) {
            OnStatusDelete(sender, e);
            if (((MenuCommand)sender).Enabled) {
                OnStatusCopy(sender, e);
            }
        }

        /// <include file='doc\CommandSet.uex' path='docs/doc[@for="CommandSet.OnStatusDelete"]/*' />
        /// <devdoc>
        ///      Status for the delete command.  This is enabled when there
        ///      is something selected and that something does not contain
        ///      inherited components.
        /// </devdoc>
        protected void OnStatusDelete(object sender, EventArgs e) {
            if (selectionInherited) {
                MenuCommand cmd = (MenuCommand)sender;
                cmd.Enabled = false;
            }
            else {
                OnStatusAnySelection(sender, e);
            }
        }

        /// <include file='doc\CommandSet.uex' path='docs/doc[@for="CommandSet.OnStatusNYI"]/*' />
        /// <devdoc>
        ///     Determines the status of a menu command.  Commands with this event are
        ///     considered to be not yet implemented and are disabled.
        /// </devdoc>
        protected void OnStatusNYI(object sender, EventArgs e) {
            MenuCommand cmd = (MenuCommand)sender;
            cmd.Enabled = false;
        }


        /// <include file='doc\CommandSet.uex' path='docs/doc[@for="CommandSet.OnStatusPaste"]/*' />
        /// <devdoc>
        ///     Determines the status of a menu command.  Commands with this event are
        ///     enabled when there is something yummy on the clipboard.
        /// </devdoc>
        protected void OnStatusPaste(object sender, EventArgs e) {
            MenuCommand cmd = (MenuCommand)sender;
            IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));

            // Before we even look at the data format, check to see if the thing we're going to paste
            // into is privately inherited.  If it is, then we definitely cannot paste.
            //
            if (primarySelection != null) {

                Debug.Assert(!CompModSwitches.CommonDesignerServices.Enabled || host != null, "IDesignerHost not found");

                if (host != null && host.GetDesigner(primarySelection) is ParentControlDesigner) {

                    // This component is a target for our paste operation.  We must ensure
                    // that it is not privately inherited.
                    //
                    InheritanceAttribute attr = (InheritanceAttribute)TypeDescriptor.GetAttributes(primarySelection)[typeof(InheritanceAttribute)];
                    Debug.Assert(attr != null, "Type descriptor gave us a null attribute -- problem in type descriptor");
                    if (attr.InheritanceLevel == InheritanceLevel.InheritedReadOnly) {
                        cmd.Enabled = false;
                        return;
                    }
                }
            }

            // Not being inherited.  Now look at the contents of the data
            //
            IDataObject dataObj = Clipboard.GetDataObject();
            bool enable = false;

            if (dataObj != null) {
                if (dataObj.GetDataPresent(CF_DESIGNER)) {
                    enable = true;
                }
                else {
                    // Not ours, check to see if the toolbox service understands this
                    //
                    IToolboxService ts = (IToolboxService)GetService(typeof(IToolboxService));
                    if (ts != null) {
                        enable = (host != null ? ts.IsSupported(dataObj, host) : ts.IsToolboxItem(dataObj));
                    }
                }
            }

            cmd.Enabled = enable;
        }

        protected virtual void OnStatusSelectAll(object sender, EventArgs e) {
            MenuCommand cmd = (MenuCommand)sender;

            IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));

            cmd.Enabled = host.Container.Components.Count > 1;
        }

        /// <include file='doc\CommandSet.uex' path='docs/doc[@for="CommandSet.OnUpdateCommandStatus"]/*' />
        /// <devdoc>
        ///      This is called when the selection has changed.  Anyone using CommandSetItems
        ///      that need to update their status based on selection changes should override
        ///      this and update their own commands at this time.  The base implementaion
        ///      runs through all base commands and calls UpdateStatus on them.
        /// </devdoc>
        protected virtual void OnUpdateCommandStatus() {
            // Now whip through all of the commands and ask them to update.
            //
            for (int i = 0; i < commandSet.Length; i++) {
                commandSet[i].UpdateStatus();
            }
        }

        /// <include file='doc\CommandSet.uex' path='docs/doc[@for="CommandSet.SortSelection"]/*' />
        /// <devdoc>
        ///     called by the formatting commands when we need a given selection array sorted.
        ///     Sorting the array sorts by x from left to right, and by Y from top to bottom.
        /// </devdoc>
        private void SortSelection(object[] selectedObjects, int nSortBy) {
            IComparer comp = null;

            switch (nSortBy) {
                case SORT_HORIZONTAL:
                    comp = new ComponentLeftCompare();
                    break;
                case SORT_VERTICAL:
                    comp = new ComponentTopCompare();
                    break;
                case SORT_ZORDER:
                    comp = new ControlZOrderCompare();
                    break;
                default:
                    return;
            }
            Array.Sort(selectedObjects, comp);
        }

        private void TestCommandCut(string[] args) {
            this.OnMenuCut(null, EventArgs.Empty);
        }

        private void TestCommandCopy(string[] args) {
            this.OnMenuCopy(null, EventArgs.Empty);
        }

        private void TestCommandPaste(string[] args) {
            this.OnMenuPaste(null, EventArgs.Empty);
        }

        /// <include file='doc\CommandSet.uex' path='docs/doc[@for="CommandSet.UpdateClipboardItems"]/*' />
        /// <devdoc>
        ///     Common function that updates the status of clipboard menu items only
        /// </devdoc>
        private void UpdateClipboardItems(object s, EventArgs e) {
            int itemCount = 0;
            CommandSetItem curItem;
            for (int i = 0; itemCount < 3 && i < commandSet.Length; i++) {
                curItem = commandSet[i];
                if (curItem.CommandID == MenuCommands.Paste ||
                    curItem.CommandID == MenuCommands.Copy ||
                    curItem.CommandID == MenuCommands.Cut) {
                    itemCount++;
                    curItem.UpdateStatus();
                }
            }
        }

        private void UpdatePastePositions(ArrayList controls) {
            if (controls.Count == 0) {
                return;
            }

            // Find the offset to apply to these controls.  The offset
            // is the location needed to center the controls in the parent.
            // If there is no parent, we relocate to 0, 0.
            //
            Control parentControl = ((Control)controls[0]).Parent;
            Point min = ((Control)controls[0]).Location;
            Point max = min;
            foreach(Control c in controls) {
                Point loc = c.Location;
                Size size = c.Size;
                if (min.X > loc.X) {
                    min.X = loc.X;
                }
                if (min.Y > loc.Y) {
                    min.Y = loc.Y;
                }
                if (max.X < loc.X + size.Width) {
                    max.X = loc.X + size.Width;
                }
                if (max.Y < loc.Y + size.Height) {
                    max.Y = loc.Y + size.Height;
                }
            }

            // We have the bounding rect for the controls.  Next,
            // offset this rect so that we center it in the parent.
            // If we have no parent, the offset will position the 
            // control at 0, 0, to whatever parent we eventually
            // get.
            //
            Point offset = new Point(-min.X, -min.Y);

            // Look to ensure that we're not going to paste this control over
            // the top of another control.  We only do this for the first
            // control because preserving the relationship between controls
            // is more important than obscuring a control.
            //
            if (parentControl != null) {

                bool bumpIt;
                bool wrapped = false;
                Size parentSize = parentControl.ClientSize;
                Size gridSize = Size.Empty;
                Point parentOffset = new Point(parentSize.Width / 2, parentSize.Height / 2);
                parentOffset.X -= (max.X - min.X) / 2;
                parentOffset.Y -= (max.Y - min.Y) / 2;

                do {
                    bumpIt = false;

                    // Cycle through the controls on the parent.  We're
                    // interested in controls that (a) are not in our
                    // set of controls and (b) have a location ==
                    // to our current bumpOffset OR (c) are the same
                    // size as our parent.  If we find such a
                    // control, we increment the bump offset by one
                    // grid size.
                    //
                    foreach (Control child in parentControl.Controls) {

                        Rectangle childBounds = child.Bounds;

                        if (controls.Contains(child)) {
                            // We still want to bump if the child is the same size as the parent.
                            // Otherwise the child would overlay exactly on top of the parent.
                            //
                            if (!child.Size.Equals(parentSize)) {
                                continue;
                            }

                            // We're dealing with our own pasted control, so 
                            // offset its bounds. We don't use parent offset here
                            // because, well, we're comparing against the parent!
                            //
                            childBounds.Offset(offset);
                        }

                        // We need only compare against one of our pasted controls, so 
                        // pick the first one.
                        //
                        Control pasteControl = (Control)controls[0];
                        Rectangle pasteControlBounds = pasteControl.Bounds;
                        pasteControlBounds.Offset(offset);
                        pasteControlBounds.Offset(parentOffset);

                        if (pasteControlBounds.Equals(childBounds)) {

                            bumpIt = true;

                            if (gridSize.IsEmpty) {
                                IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
                                IComponent baseComponent = host.RootComponent;
                                if (baseComponent != null && baseComponent is Control) {
                                    PropertyDescriptor gs = GetProperty(baseComponent, "GridSize");
                                    if (gs != null) {
                                        gridSize = (Size)gs.GetValue(baseComponent);
                                    }
                                }
                                if (gridSize.IsEmpty) {
                                    gridSize.Width = 8;
                                    gridSize.Height = 8;
                                }
                            }

                            parentOffset += gridSize;

                            // Extra check:  If the end of our control group is > the
                            // parent size, bump back to zero.  We still allow further
                            // bumps after this so we can continue to offset, but if
                            // we cycle again then we quit so we won't loop indefinitely.
                            // We only do this if we're a group.  If we're a single control
                            // we use the beginning of the control + a grid size.
                            //
                            int groupEndX;
                            int groupEndY;

                            if (controls.Count > 1) {
                                groupEndX = parentOffset.X + max.X - min.X;
                                groupEndY = parentOffset.Y + max.Y - min.Y;
                            }
                            else {
                                groupEndX = parentOffset.X + gridSize.Width;
                                groupEndY = parentOffset.Y + gridSize.Height;
                            }

                            if (groupEndX > parentSize.Width || groupEndY > parentSize.Height) {
                                parentOffset.X = 0;
                                parentOffset.Y = 0;

                                if (wrapped) {
                                    bumpIt = false;
                                }
                                else {
                                    wrapped = true;
                                }
                            }
                            break;
                        }
                    }
                } while (bumpIt);

                offset.Offset(parentOffset.X, parentOffset.Y);
            }

            // Now, for each control, update the offset.
            //
            foreach(Control c in controls) {
                Point newLoc = c.Location;
                newLoc.Offset(offset.X, offset.Y);
                c.Location = newLoc;
            }
        }

        private void UpdatePasteTabIndex(Control componentControl, object parentComponent) {
            Control parentControl = parentComponent as Control;

            if (parentControl == null || componentControl == null) {
                return;
            }

            bool tabIndexCollision = false;
            int  tabIndexOriginal = componentControl.TabIndex;

            // Find the next highest tab index
            //
            int nextTabIndex = 0;
            foreach(Control c in parentControl.Controls) {
                int t = c.TabIndex;
                if (nextTabIndex <= t) {
                    nextTabIndex = t + 1;
                }

                if (t == tabIndexOriginal) {
                    tabIndexCollision = true;
                }
            }

            if (tabIndexCollision) {
                componentControl.TabIndex = nextTabIndex;
            }
        }

        /// <include file='doc\CommandSet.uex' path='docs/doc[@for="CommandSet.CommandSetItem"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///     We extend MenuCommand for our command set items.  A command set item
        ///     is a menu command with an added delegate that is used to determine the
        ///     flags for the menu item.  We have different classes of delegates here.
        ///     For example, many  menu items may be enabled when there is at least
        ///     one object selected, while others are only enabled if there is more than
        ///     one object or if there is a primary selection.
        /// </devdoc>
        protected class CommandSetItem : MenuCommand {
            private EventHandler         statusHandler;
            private IEventHandlerService eventService;

            /// <include file='doc\CommandSet.uex' path='docs/doc[@for="CommandSet.CommandSetItem.CommandSetItem"]/*' />
            /// <devdoc>
            ///     Creates a new CommandSetItem.
            /// </devdoc>
            public CommandSetItem(CommandSet commandSet, EventHandler statusHandler, EventHandler invokeHandler, CommandID id)
            : base(invokeHandler, id) {
                this.eventService = commandSet.eventService;
                this.statusHandler = statusHandler;
            }

            /// <include file='doc\CommandSet.uex' path='docs/doc[@for="CommandSet.CommandSetItem.Invoke"]/*' />
            /// <devdoc>
            ///     This may be called to invoke the menu item.
            /// </devdoc>
            public override void Invoke() {
                // We allow outside parties to override the availability of particular menu commands.
                //
                if (eventService != null) {
                    IMenuStatusHandler msh = (IMenuStatusHandler)eventService.GetHandler(typeof(IMenuStatusHandler));
                    if (msh != null && msh.OverrideInvoke(this)) {
                        return;
                    }
                }

                base.Invoke();
            }

            /// <include file='doc\CommandSet.uex' path='docs/doc[@for="CommandSet.CommandSetItem.UpdateStatus"]/*' />
            /// <devdoc>
            ///     Called when the status of this command should be re-queried.
            /// </devdoc>
            public void UpdateStatus() {

                // We allow outside parties to override the availability of particular menu commands.
                //
                if (eventService != null) {
                    IMenuStatusHandler msh = (IMenuStatusHandler)eventService.GetHandler(typeof(IMenuStatusHandler));
                    if (msh != null && msh.OverrideStatus(this)) {
                        return;
                    }
                }

                if (statusHandler != null) {
                    try {
                        statusHandler.Invoke(this, EventArgs.Empty);
                    }
                    catch {
                    }
                }
            }
        }

        /// <include file='doc\CommandSet.uex' path='docs/doc[@for="CommandSet.ImmediateCommandSetItem"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///      The immediate command set item is used for commands that cannot be cached.  Commands
        ///      such as Paste that get outside stimulus cannot be cached by our menu system, so 
        ///      they get an ImmediateCommandSetItem instead of a CommandSetItem.
        /// </devdoc>
        protected class ImmediateCommandSetItem : CommandSetItem {

            /// <include file='doc\CommandSet.uex' path='docs/doc[@for="CommandSet.ImmediateCommandSetItem.ImmediateCommandSetItem"]/*' />
            /// <devdoc>
            ///     Creates a new ImmediateCommandSetItem.
            /// </devdoc>
            public ImmediateCommandSetItem(CommandSet commandSet, EventHandler statusHandler, EventHandler invokeHandler, CommandID id)
            : base(commandSet, statusHandler, invokeHandler, id) {
            }

            /// <include file='doc\CommandSet.uex' path='docs/doc[@for="CommandSet.ImmediateCommandSetItem.OleStatus"]/*' />
            /// <devdoc>
            ///      Overrides OleStatus in MenuCommand to invoke our status handler first.
            /// </devdoc>
            public override int OleStatus {
                get {
                    UpdateStatus();
                    return base.OleStatus;
                }
            }
        }

        /// <include file='doc\CommandSet.uex' path='docs/doc[@for="CommandSet.ComponentLeftCompare"]/*' />
        /// <devdoc>
        ///      Component comparer that compares the left property of a component.
        /// </devdoc>
        private class ComponentLeftCompare : IComparer {
            public int Compare(object p, object q) {
                PropertyDescriptor pProp = TypeDescriptor.GetProperties(p)["Location"];
                PropertyDescriptor qProp = TypeDescriptor.GetProperties(q)["Location"];

                Point pLoc = (Point)pProp.GetValue(p);
                Point qLoc = (Point)qProp.GetValue(q);

                //if our lefts are equal, then compare tops
                if (pLoc.X == qLoc.X) {
                    return pLoc.Y - qLoc.Y;
                }

                return pLoc.X - qLoc.X;
            }
        }

        /// <include file='doc\CommandSet.uex' path='docs/doc[@for="CommandSet.ComponentTopCompare"]/*' />
        /// <devdoc>
        ///      Component comparer that compares the top property of a component.
        /// </devdoc>
        private class ComponentTopCompare : IComparer {
            public int Compare(object p, object q) {
                PropertyDescriptor pProp = TypeDescriptor.GetProperties(p)["Location"];
                PropertyDescriptor qProp = TypeDescriptor.GetProperties(q)["Location"];

                Point pLoc = (Point)pProp.GetValue(p);
                Point qLoc = (Point)qProp.GetValue(q);

                //if our tops are equal, then compare lefts
                if (pLoc.Y == qLoc.Y) {
                    return pLoc.X - qLoc.X;
                }

                return pLoc.Y - qLoc.Y;
            }
        }

        private class ControlZOrderCompare : IComparer {

            public int Compare(object p, object q) {
                if (p == null) {
                    return -1;
                }
                else if (q == null) {
                    return 1;
                }
                else if (p == q) {
                    return 0;
                }

                Control c1 = p as Control;
                Control c2 = q as Control;

                if (c1 == null || c2 == null) {
                    return 1;
                }

                if (c1.Parent == c2.Parent && c1.Parent != null) {
                    return c1.Parent.Controls.GetChildIndex(c1) - c1.Parent.Controls.GetChildIndex(c2);
                }
                return 1;
            }
        }

        private class TabIndexCompare : IComparer {
            public int Compare(object p, object q) {
                Control c1 = p as Control;
                Control c2 = q as Control;

                if (c1 == c2) {
                    return 0;
                }

                if (c1 == null) {
                    return -1;
                }

                if (c2 == null) {
                    return 1;
                }

                return c1.TabIndex - c2.TabIndex;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\controlcodedomserializer.cs ===
//------------------------------------------------------------------------------
// <copyright file="ControlCodeDomSerializer.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms.Design {

    using System;
    using System.Design;
    using System.CodeDom;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.ComponentModel.Design.Serialization;
    using System.Diagnostics;
    using System.Reflection;
    using System.Text;

    
    /// <include file='doc\ControlCodeDomSerializer.uex' path='docs/doc[@for="ControlCodeDomSerializer"]/*' />
    /// <devdoc>
    ///     Control's provide their own serializer so they can write out resource hierarchy
    ///     information.  We delegate nearly everything to our base class's serializer.
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class ControlCodeDomSerializer : CodeDomSerializer {
    
        /// <include file='doc\ControlCodeDomSerializer.uex' path='docs/doc[@for="ControlCodeDomSerializer.Deserialize"]/*' />
        /// <devdoc>
        ///     Deserilizes the given CodeDom object into a real object.  This
        ///     will use the serialization manager to create objects and resolve
        ///     data types.  The root of the object graph is returned.
        /// </devdoc>
        public override object Deserialize(IDesignerSerializationManager manager, object codeObject) {
            if (manager == null || codeObject == null) {
                throw new ArgumentNullException( manager == null ? "manager" : "codeObject");
            }
            
            // Find our base class's serializer.  
            //
            CodeDomSerializer serializer = (CodeDomSerializer)manager.GetSerializer(typeof(Component), typeof(CodeDomSerializer));
            if (serializer == null) {
                Debug.Fail("Unable to find a CodeDom serializer for 'Component'.  Has someone tampered with the serialization providers?");
                return null;
            }
            
            return serializer.Deserialize(manager, codeObject);
        }

        private bool HasMixedInheritedChildren(Control parent) {
            
            bool inheritedChildren = false;
            bool nonInheritedChildren = false;

            foreach(Control c in parent.Controls) {
                InheritanceAttribute ia = (InheritanceAttribute)TypeDescriptor.GetAttributes(c)[typeof(InheritanceAttribute)];
                if (ia != null && ia.InheritanceLevel != InheritanceLevel.NotInherited) {
                    inheritedChildren = true;
                }
                else {
                    nonInheritedChildren = true;
                }

                if (inheritedChildren && nonInheritedChildren) {
                    return true;
                }
            }

            return false;
        }

        protected bool HasSitedNonInheritedChildren(Control parent) {
            if (!parent.HasChildren) {
                return false;
            }

            foreach (Control c in parent.Controls) {
                if (c.Site != null && c.Site.Container == parent.Site.Container) {

                    // Also check to make sure this sited control isn't inherited.
                    // It does no good to suspend / resume an inherited control
                    // if we don't add any of our own controls to it.
                    //
                    InheritanceAttribute ia = (InheritanceAttribute)TypeDescriptor.GetAttributes(c)[typeof(InheritanceAttribute)];
                    if (ia != null && ia.InheritanceLevel == InheritanceLevel.NotInherited) {
                        return true;
                    }
                }
            }
            return false;
        }
        
        /// <include file='doc\ControlCodeDomSerializer.uex' path='docs/doc[@for="ControlCodeDomSerializer.Serialize"]/*' />
        /// <devdoc>
        ///     Serializes the given object into a CodeDom object.
        /// </devdoc>
        public override object Serialize(IDesignerSerializationManager manager, object value) {
            
            if (manager == null || value == null) {
                throw new ArgumentNullException( manager == null ? "manager" : "value");
            }
            
            // Find our base class's serializer.  
            //
            CodeDomSerializer serializer = (CodeDomSerializer)manager.GetSerializer(typeof(Component), typeof(CodeDomSerializer));
            if (serializer == null) {
                Debug.Fail("Unable to find a CodeDom serializer for 'Component'.  Has someone tampered with the serialization providers?");
                return null;
            }
            
            // Now ask it to serializer
            //
            object retVal = serializer.Serialize(manager, value);

            InheritanceAttribute inheritanceAttribute = (InheritanceAttribute)TypeDescriptor.GetAttributes(value)[typeof(InheritanceAttribute)];
            InheritanceLevel inheritanceLevel = InheritanceLevel.NotInherited;
            
            if (inheritanceAttribute != null) {
                inheritanceLevel = inheritanceAttribute.InheritanceLevel;
            }

            if (inheritanceLevel != InheritanceLevel.InheritedReadOnly) {
                
                // Next, see if we are in localization mode.  If we are, and if we can get
                // to a ResourceManager through the service provider, then emit the hierarchy information for
                // this object.  There is a small fragile assumption here:  The resource manager is demand
                // created, so if all of the properties of this control had default values it is possible
                // there will be no resource manager for us.  I'm letting that slip a bit, however, because
                // for Control classes, we always emit at least the location / size information for the
                // control.
                //
                IDesignerHost host = (IDesignerHost)manager.GetService(typeof(IDesignerHost));
                if (host != null) {
                    PropertyDescriptor prop = TypeDescriptor.GetProperties(host.RootComponent)["Localizable"];
                    if (prop != null && prop.PropertyType == typeof(bool) && ((bool)prop.GetValue(host.RootComponent))) {
                        SerializeControlHierarchy(manager, host, value);
                    }
                }
                
                if (retVal is CodeStatementCollection) {
                     
                    // Serialize a suspend / resume pair.
                    //
                    if (HasSitedNonInheritedChildren((Control)value)) {
                        SerializeSuspendResume(manager, ((CodeStatementCollection)retVal), value, "SuspendLayout");
                        SerializeSuspendResume(manager, ((CodeStatementCollection)retVal), value, "ResumeLayout");
                    }

                    // And now serialize the correct z-order relationships for the controls.  We only need to 
                    // do this if there are controls in the collection that are inherited.
                    //
                    if (HasMixedInheritedChildren((Control)value)) {
                        SerializeZOrder(manager, (CodeStatementCollection)retVal, (Control)value);
                    }
                }
            }

            return retVal;
        }
        
        /// <include file='doc\ControlCodeDomSerializer.uex' path='docs/doc[@for="ControlCodeDomSerializer.SerializeControlHierarchy"]/*' />
        /// <devdoc>
        ///     This writes out our control hierarchy information if there is a resource manager available for us to write to.
        /// </devdoc>
        private void SerializeControlHierarchy(IDesignerSerializationManager manager, IDesignerHost host, object value) {
                        
            Control control = value as Control;
            
            if (control != null) {
            
                // Object name
                //
                string name;
                
                if (control == host.RootComponent) {
                    name = "$this";

                    // For the root component, we also take this as
                    // an opportunity to emit information for all non-visual components in the container too.
                    //
                    foreach(IComponent component in host.Container.Components) {
                        // Skip controls
                        if (component is Control) {
                            continue;
                        }

                        // Skip privately inherited components
                        if (TypeDescriptor.GetAttributes(component).Contains(InheritanceAttribute.InheritedReadOnly)) {
                            continue;
                        }

                        // Now emit the data
                        string componentName = manager.GetName(component);
                        string componentTypeName = component.GetType().AssemblyQualifiedName;

                        if (componentName != null) {
                            SerializeResourceInvariant(manager, ">>" + componentName + ".Name", componentName);
                            SerializeResourceInvariant(manager, ">>" + componentName + ".Type", componentTypeName);
                        }
                    }
                }
                else {
                    name = manager.GetName(value);

                    // if we get null back, this must be an unsited control
                    if (name == null) {
                        Debug.Assert(!(value is IComponent) || ((IComponent)value).Site == null, "Unnamed, sited control in hierarchy");
                        return;
                    }
                }
                
                SerializeResourceInvariant(manager, ">>" + name + ".Name", manager.GetName(value));
                                
                // Object type
                //
                SerializeResourceInvariant(manager, ">>" + name + ".Type", control.GetType().AssemblyQualifiedName);
                
                // Parent
                //
                Control parent = control.Parent;
                if (parent != null && parent.Site != null) {
                    string parentName;
                     
                    if (parent == host.RootComponent) {
                        parentName = "$this";
                    }
                    else {
                        parentName = manager.GetName(parent);
                    }
                    
                    if (parentName != null) {
                        SerializeResourceInvariant(manager, ">>" + name + ".Parent", parentName);
                    }
                    
                    // Z-Order
                    //
                    for (int i = 0; i < parent.Controls.Count; i++) {
                        if (parent.Controls[i] == control) {
                            SerializeResourceInvariant(manager, ">>" + name + ".ZOrder", i.ToString());
                            break;
                        }
                    }
                }                                                                                   
            }
        }

        /// <devdoc>
        ///     Serializes a SuspendLayout / ResumeLayout.
        /// </devdoc>
        private void SerializeSuspendResume(IDesignerSerializationManager manager, CodeStatementCollection statements, object value, string methodName) {
        
            Debug.WriteLineIf(traceSerialization.TraceVerbose, "ControlCodeDomSerializer::SerializeSuspendResume(" + methodName + ")");
            Debug.Indent();
            
            string name = manager.GetName(value);
            Debug.WriteLineIf(traceSerialization.TraceVerbose, name + "." + methodName);
            
            // Assemble a cast to ISupportInitialize, and then invoke the method.
            //
            CodeExpression field = SerializeToReferenceExpression(manager, value);
            CodeMethodReferenceExpression method = new CodeMethodReferenceExpression(field, methodName);
            CodeMethodInvokeExpression methodInvoke = new CodeMethodInvokeExpression();
            methodInvoke.Method = method;
            CodeExpressionStatement statement = new CodeExpressionStatement(methodInvoke);
            
            if (methodName == "SuspendLayout") {
                statement.UserData["statement-ordering"] = "begin";
            }
            else {
                methodInvoke.Parameters.Add(new CodePrimitiveExpression(false));
                statement.UserData["statement-ordering"] = "end";
            }

            statements.Add(statement);
            Debug.Unindent();
        }

        /// <devdoc>
        ///     Serializes a series of SetChildIndex() statements for each control iln a child control collection in
        ///     reverse order.
        /// </devdoc>
        private void SerializeZOrder(IDesignerSerializationManager manager, CodeStatementCollection statements, Control control) {

            Debug.WriteLineIf(traceSerialization.TraceVerbose, "ControlCodeDomSerializer::SerializeZOrder()");
            Debug.Indent();

            // Push statements in reverse order so the first guy in the
            // collection is the last one to be brought to the front.
            //
            for (int i = control.Controls.Count - 1; i >= 0; i--) {

                // Only serialize this control if it is (a) sited and
                // (b) not being privately inherited
                //
                Control child = control.Controls[i];
                if (child.Site == null || child.Site.Container != control.Site.Container) {
                    continue;
                }

                InheritanceAttribute attr = (InheritanceAttribute)TypeDescriptor.GetAttributes(child)[typeof(InheritanceAttribute)];
                if (attr.InheritanceLevel == InheritanceLevel.InheritedReadOnly) {
                    continue;
                }
                
                // Create the "control.Controls.SetChildIndex" call
                //
                CodeExpression controlsCollection = new CodePropertyReferenceExpression(SerializeToReferenceExpression(manager, control), "Controls");
                CodeMethodReferenceExpression method = new CodeMethodReferenceExpression(controlsCollection, "SetChildIndex");
                CodeMethodInvokeExpression methodInvoke = new CodeMethodInvokeExpression();
                methodInvoke.Method = method;

                // Fill in parameters
                //
                CodeExpression childControl = SerializeToReferenceExpression(manager, child);
                methodInvoke.Parameters.Add(childControl);
                methodInvoke.Parameters.Add(SerializeToExpression(manager, 0));

                CodeExpressionStatement statement = new CodeExpressionStatement(methodInvoke);
                statements.Add(statement);
            }
        
            Debug.Unindent();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\datagridcolumnstylemappingnameeditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataGridColumnStyleMappingNameEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms.Design {

    using System.Design;
    using System;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Drawing;
    using System.Drawing.Design;
    
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class DataGridColumnStyleMappingNameEditor : UITypeEditor {

        private DesignBindingPicker designBindingPicker;
        
        public override object EditValue(ITypeDescriptorContext context,  IServiceProvider  provider, object value) {
            if (provider != null) {
                IWindowsFormsEditorService edSvc = (IWindowsFormsEditorService)provider.GetService(typeof(IWindowsFormsEditorService));

                if (edSvc != null && context.Instance != null) {
                    if (designBindingPicker == null) {
                        designBindingPicker = new DesignBindingPicker(context, /*multiple DataSources*/ false, /*select lists*/ false);
                    }
                    object instance = context.Instance;
                    DataGridColumnStyle columnStyle = (DataGridColumnStyle) context.Instance;
                    if (columnStyle.DataGridTableStyle == null || columnStyle.DataGridTableStyle.DataGrid == null)
                        return value;
                    PropertyDescriptor dataSourceProperty = TypeDescriptor.GetProperties(columnStyle.DataGridTableStyle.DataGrid)["DataSource"];
                    if (dataSourceProperty != null) {
                        object dataSource = dataSourceProperty.GetValue(columnStyle.DataGridTableStyle.DataGrid);
                        if (dataSource != null) {
                            designBindingPicker.Start(context, edSvc, dataSource, new DesignBinding(null, (string)value));
                            edSvc.DropDownControl(designBindingPicker);
                            if (designBindingPicker.SelectedItem != null) {
                                if (String.Empty.Equals(designBindingPicker.SelectedItem.DataMember) || designBindingPicker.SelectedItem.DataMember == null)
                                    value = "";
                                else
                                    value = designBindingPicker.SelectedItem.DataField;
                            }
                            designBindingPicker.End();
                        } else {
                            // ASURT 61510: do not throw the exception ( the exception was added in bug 37841 )
                            designBindingPicker.Start(context, edSvc, dataSource, new DesignBinding(null, (string) value));
                            edSvc.DropDownControl(designBindingPicker);
                            designBindingPicker.End();
                        }
                    }
                }
            }

            return value;
        }

        public override UITypeEditorEditStyle GetEditStyle(ITypeDescriptorContext context) {
            return UITypeEditorEditStyle.DropDown;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\datagridcolumncollectioneditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataGridColumnCollectionEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms.Design {

    using System;
    using System.ComponentModel.Design;

    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class DataGridColumnCollectionEditor : CollectionEditor {
    
        public DataGridColumnCollectionEditor(Type type ) : base(type) {
        }
        
        /// <include file='doc\DataGridColumnCollectionEditor.uex' path='docs/doc[@for="DataGridColumnCollectionEditor.CreateNewItemTypes"]/*' />
        /// <devdoc>
        ///      Retrieves the data types this collection can contain.  The default 
        ///      implementation looks inside of the collection for the Item property
        ///      and returns the returning datatype of the item.  Do not call this
        ///      method directly.  Instead, use the ItemTypes property.  Use this
        ///      method to override the default implementation.
        /// </devdoc>
        protected override Type[] CreateNewItemTypes() {
            return new Type[] {
                typeof(DataGridTextBoxColumn),
                typeof(DataGridBoolColumn)
            };
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\controldesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="ControlDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms.Design {
    using System.Design;
    using Accessibility;
    using System.Runtime.Serialization.Formatters;
    using System.Threading;
    using System.Runtime.InteropServices;    
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.Security;
    using System.Security.Permissions;
    using System.Collections;
    using System.ComponentModel.Design;
    using System.Windows.Forms;
    using System.Drawing;
    using System.Drawing.Design;
    using Microsoft.Win32;
    using Timer = System.Windows.Forms.Timer;

    /// <include file='doc\ControlDesigner.uex' path='docs/doc[@for="ControlDesigner"]/*' />
    /// <devdoc>
    ///    <para> 
    ///       Provides a designer that can design components
    ///       that extend Control.</para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public class ControlDesigner : ComponentDesigner {
    
        /// <include file='doc\ControlDesigner.uex' path='docs/doc[@for="ControlDesigner.InvalidPoint"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>


        protected static readonly Point InvalidPoint = new Point(int.MinValue, int.MinValue);
        
        private   IDesignerHost         host;           // the host for our designer
        private   IDesignerTarget       designerTarget; // the target window proc for the control.
        
        private   bool                  liveRegion;     // is the mouse is over a live region of the control?
        private   bool                  inHitTest;      // A popular way to implement GetHitTest is by WM_NCHITTEST...which would cause a cycle.
        private   bool                  hasLocation;    // Do we have a location property?
        private   bool                  locationChecked;// And did we check it
        private   bool                  locked;         // signifies if this control is locked or not
        private   bool                  initializing;

        // Services that we use enough to cache
        //
        private ISelectionUIService     selectionUISvc;
        private IEventHandlerService    eventSvc;
        private IToolboxService         toolboxSvc;
        private InheritanceUI           inheritanceUI;

        // transient values that are used during mouse drags
        //
        private Point               mouseDragLast = InvalidPoint;   // the last position of the mouse during a drag.
        private bool                mouseDragMoved;                 // has the mouse been moved during this drag?
        private int                 lastMoveScreenX;
        private int                 lastMoveScreenY;

        // Values used to simulate double clicks for controls that don't support them.
        //
        private int lastClickMessageTime;
        private int lastClickMessagePositionX;
        private int lastClickMessagePositionY;

        private Point                         downPos = Point.Empty;     // point used to track first down of a double click
        private EventHandler                  dockChanged = null;        // Delegate used to dirty the selectionUIItem when needed.
        private event EventHandler            disposingHandler;
        private CollectionChangeEventHandler  dataBindingsCollectionChanged;
        private Exception                     thrownException;
        private bool                          ctrlSelect;                // if the CTRL key was down at the mouse down
        private bool                          toolPassThrough;           // a tool is selected, allow the parent to draw a rect for it.
        private bool                          removalNotificationHooked = false;
        private bool                          revokeDragDrop = true;
        private bool                          hadDragDrop;

        private DesignerControlCollection     controls;

        private static bool                     inContextMenu = false;

        /// <devdoc>
        ///     Accessor for AllowDrop.  Since we often turn this on, we shadow it
        ///     so it doesn't show up to the user.
        /// </devdoc>
        private bool AllowDrop {
            get {
                return (bool)ShadowProperties["AllowDrop"];
            }
            set {
                ShadowProperties["AllowDrop"] = value;
            }
        }

        [DesignerSerializationVisibility(DesignerSerializationVisibility.Content)]
        private DesignerControlCollection Controls {
            get {
                if (controls == null) {
                    controls = new DesignerControlCollection(Control);
                }   
                return controls;
            }
        }

        private Point Location {
            get {
                Point loc = Control.Location;

                ScrollableControl p = Control.Parent as ScrollableControl;
                if (p != null) {
                    Point pt = p.AutoScrollPosition;
                    loc.Offset(-pt.X, -pt.Y);
                }
                return loc;
            }
            set {
                ScrollableControl p = Control.Parent as ScrollableControl;
                if (p != null) {
                    Point pt = p.AutoScrollPosition;
                    value.Offset(pt.X, pt.Y);
                }
                Control.Location = value;
            }
        }

        private bool ShouldSerializeAllowDrop() {
            return AllowDrop != hadDragDrop;
        }

        /// <include file='doc\ControlDesigner.uex' path='docs/doc[@for="ControlDesigner.AssociatedComponents"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Retrieves a list of assosciated components.  These are components that should be incluced in a cut or copy operation on this component.
        ///    </para>
        /// </devdoc>
        public override ICollection AssociatedComponents {
            get {
                ArrayList sitedChildren = null;
                
                foreach (Control c in Control.Controls) {
                    if (c.Site != null) {
                        if (sitedChildren == null) {
                            sitedChildren = new ArrayList();
                        }
                        sitedChildren.Add(c);
                    }
                }

                if (sitedChildren != null) {
                    return sitedChildren;
                }
                return base.AssociatedComponents;
            }
        }

        /// <devdoc>
        ///     Accessor method for the context menu property on control.  We shadow
        ///     this property at design time.
        /// </devdoc>
        private ContextMenu ContextMenu {
            get {
                return (ContextMenu)ShadowProperties["ContextMenu"];
            }
            set {
                ContextMenu oldValue = (ContextMenu)ShadowProperties["ContextMenu"];

                if (oldValue != value) {
                    EventHandler disposedHandler = new EventHandler(DetachContextMenu);

                    if (oldValue != null) {
                        oldValue.Disposed -= disposedHandler;
                    }

                    ShadowProperties["ContextMenu"] = value;

                    if (value != null) {
                        value.Disposed += disposedHandler;
                    }                    
                }

            }
        }

        /// <include file='doc\ControlDesigner.uex' path='docs/doc[@for="ControlDesigner.accessibilityObj"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected AccessibleObject accessibilityObj = null;
        
        /// <include file='doc\ControlDesigner.uex' path='docs/doc[@for="ControlDesigner.AccessibilityObject"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual AccessibleObject AccessibilityObject {
            get {
                if (accessibilityObj == null) {
                    accessibilityObj = new ControlDesignerAccessibleObject(this, Control);
                }
                return accessibilityObj;
            }
        }                   
                   
        /// <include file='doc\ControlDesigner.uex' path='docs/doc[@for="ControlDesigner.Control"]/*' />
        /// <devdoc>
        ///     Retrieves the control we're designing.
        /// </devdoc>
        public virtual Control Control {
            get {
                return(Control)Component;
            }
        }
        
        private IDesignerTarget DesignerTarget {
            get {
                return designerTarget;
            }
            set {
                this.designerTarget = value;
            }
        }

        /// <devdoc>
        ///     Accessor method for the enabled property on control.  We shadow
        ///     this property at design time.
        /// </devdoc>
        private bool Enabled {
            get {
                return (bool)ShadowProperties["Enabled"];
            }
            set {
                ShadowProperties["Enabled"] = value;
            }
        }
        
        /// <include file='doc\ControlDesigner.uex' path='docs/doc[@for="ControlDesigner.EnableDragRect"]/*' />
        /// <devdoc>
        ///     Determines whether drag rects can be drawn on this designer.
        /// </devdoc>
        protected virtual bool EnableDragRect {
            get {
                return false;
            }
        }

        internal Exception Exception {
            get {
                return thrownException;
            }
            set {
                if (thrownException == null) {
                    thrownException = value;
                    DisplayError(value);

                    // hide all the child controls.
                    //
                    foreach (Control c in Control.Controls) {
                        c.Visible = false;
                    }

                    Control.Invalidate(true);
                }
            }
        }

        /// <devdoc>
        ///     Gets / Sets this controls locked property
        ///
        /// </devdoc>
        private bool Locked {
            get {
                return locked;
            }

            set{
                if (locked != value) {
                    locked = value;

                    if (selectionUISvc == null) {
                        selectionUISvc = (ISelectionUIService)GetService(typeof(ISelectionUIService));
                    }

                    Debug.Assert(selectionUISvc != null, "Unable to get to selection UI service -- we will not be able to drag components.");

                    if (selectionUISvc == null) return;

                    selectionUISvc.SyncComponent(Component);
                }
            }
        }

        private string Name {
            get {
                return Component.Site.Name;
            }
            set {
            }
        }

        /// <include file='doc\ControlDesigner.uex' path='docs/doc[@for="ControlDesigner.SelectionRules"]/*' />
        /// <devdoc>
        ///     Retrieves a set of rules concerning the movement capabilities of a component.
        ///     This should be one or more flags from the SelectionRules class.  If no designer
        ///     provides rules for a component, the component will not get any UI services.
        /// </devdoc>
        public virtual SelectionRules SelectionRules {
            get {
                SelectionRules rules = SelectionRules.Visible;
                object component = Component;

                rules = SelectionRules.Visible;
                
                PropertyDescriptor prop;
                PropertyDescriptorCollection props = TypeDescriptor.GetProperties(component);
                if ((prop = props["Location"]) != null &&
                    !prop.IsReadOnly) {
                    rules |= SelectionRules.Moveable;
                }

                if ((prop = props["Size"]) != null &&
                    !prop.IsReadOnly) {
                    rules |= SelectionRules.AllSizeable;
                }

                PropertyDescriptor propDock = props["Dock"];
                if (propDock != null) {
                    DockStyle dock = (DockStyle)(int)propDock.GetValue(component);
                    switch (dock) {
                        case DockStyle.Top:
                            rules &= ~(SelectionRules.Moveable | SelectionRules.TopSizeable | SelectionRules.LeftSizeable | SelectionRules.RightSizeable);
                            break;
                        case DockStyle.Left:
                            rules &= ~(SelectionRules.Moveable | SelectionRules.TopSizeable | SelectionRules.LeftSizeable | SelectionRules.BottomSizeable);
                            break;
                        case DockStyle.Right:
                            rules &= ~(SelectionRules.Moveable | SelectionRules.TopSizeable | SelectionRules.BottomSizeable | SelectionRules.RightSizeable);
                            break;
                        case DockStyle.Bottom:
                            rules &= ~(SelectionRules.Moveable | SelectionRules.LeftSizeable | SelectionRules.BottomSizeable | SelectionRules.RightSizeable);
                            break;
                    }
                }

                PropertyDescriptor pd = props["Locked"];
                if (pd != null) {
                    Object value = pd.GetValue(component);

                    // make sure that value is a boolean, in case someone else added this property
                    //
                    if (value is bool && (bool)value == true) {
                        rules = SelectionRules.Locked | SelectionRules.Visible;
                    }
                }

                return rules;
            }
        }

        /// <devdoc>
        ///     Accessor method for the visible property on control.  We shadow
        ///     this property at design time.
        /// </devdoc>
        private bool Visible {
            get {
                return (bool)ShadowProperties["Visible"];
            }
            set {
                ShadowProperties["Visible"] = value;
            }
        }

        /// <include file='doc\ControlDesigner.uex' path='docs/doc[@for="ControlDesigner.BaseWndProc"]/*' />
        /// <devdoc>
        ///     Default processing for messages.  This method causes the message to
        ///     get processed by windows, skipping the control.  This is useful if
        ///     you want to block this message from getting to the control, but 
        ///     you do not want to block it from getting to Windows itself because
        ///     it causes other messages to be generated.
        /// </devdoc>
        [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        protected void BaseWndProc(ref Message m) {
            m.Result = NativeMethods.DefWindowProc(m.HWnd, m.Msg, m.WParam, m.LParam);
        }
        
         /// <include file='doc\ControlDesigner.uex' path='docs/doc[@for="ControlDesigner.CanBeParentedTo"]/*' />
         /// <devdoc>
        ///     Determines if the this designer can be parented to the specified desinger --
        ///     generally this means if the control for this designer can be parented into the
        ///     given ParentControlDesigner's designer.
        /// </devdoc>
        public virtual bool CanBeParentedTo(IDesigner parentDesigner) {
           return (parentDesigner is ParentControlDesigner && !Control.Contains(((ParentControlDesigner)parentDesigner).Control));
        }
                
        private void DataBindingsCollectionChanged(object sender, CollectionChangeEventArgs e) {

            // It is possible to use the control designer with NON CONTROl types.
            //
            Control ctl = Component as Control;

            if (ctl != null) {
                if (ctl.DataBindings.Count == 0 && removalNotificationHooked) {
                    // remove the notification for the ComponentRemoved event
                    IComponentChangeService csc = (IComponentChangeService) GetService(typeof(IComponentChangeService));
                    if (csc != null) {
                        csc.ComponentRemoved -= new ComponentEventHandler(DataSource_ComponentRemoved);
                    }
                    removalNotificationHooked = false;
                }
                else if (ctl.DataBindings.Count > 0 && !removalNotificationHooked) {
                    // add he notification for the ComponentRemoved event
                    IComponentChangeService csc = (IComponentChangeService) GetService(typeof(IComponentChangeService));
                    if (csc != null) {
                        csc.ComponentRemoved += new ComponentEventHandler(DataSource_ComponentRemoved);
                    }
                    removalNotificationHooked = true;
                }
            }
        }

        private void DataSource_ComponentRemoved(object sender, ComponentEventArgs e) {
            
            // It is possible to use the control designer with NON CONTROl types.
            //
            Control ctl = Component as Control;

            if (ctl != null) {
                Debug.Assert(ctl.DataBindings.Count > 0, "we should not be notified if the control has no dataBindings");
    
                ctl.DataBindings.CollectionChanged -= dataBindingsCollectionChanged;
                for (int i = 0; i < ctl.DataBindings.Count; i ++) {
                    Binding binding = ctl.DataBindings[i];
                    if (binding.DataSource == e.Component) {
                        // remove the binding from the control's collection
                        // this will also remove the binding from the bindingManagerBase's bindingscollection
                        // NOTE: we can't remove the bindingManager from the bindingContext, cause there may
                        // be some complex bound controls ( such as the dataGrid, or the ComboBox, or the ListBox )
                        // that still use that bindingManager
                        ctl.DataBindings.Remove(binding);
                    }
                }
    
                // if after removing those bindings the collection is empty, then
                // unhook the changeNotificationService
                //
                if (ctl.DataBindings.Count == 0) {
                    IComponentChangeService csc = (IComponentChangeService)GetService(typeof(IComponentChangeService));
                    if (csc != null) {
                        csc.ComponentRemoved -= new ComponentEventHandler(DataSource_ComponentRemoved);
                    }
                    removalNotificationHooked = false;
                }
                ctl.DataBindings.CollectionChanged += dataBindingsCollectionChanged;
            }
        }

        /// <include file='doc\ControlDesigner.uex' path='docs/doc[@for="ControlDesigner.DefWndProc"]/*' />
        /// <devdoc>
        ///     Default processing for messages.  This method causes the message to
        ///     get processed by the control, rather than the designer.
        /// </devdoc>
        [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        protected void DefWndProc(ref Message m) {
            designerTarget.DefWndProc(ref m);
        }

        private void DetachContextMenu(object sender, EventArgs e) {
            ContextMenu = null;
        }

        /// <include file='doc\ControlDesigner.uex' path='docs/doc[@for="ControlDesigner.DisplayError"]/*' />
        /// <devdoc>
        ///      Displays the given exception to the user.
        /// </devdoc>
        protected void DisplayError(Exception e) {
            IUIService uis = (IUIService)GetService(typeof(IUIService));
            if (uis != null) {
                uis.ShowError(e);
            }
            else {
                string message = e.Message;
                if (message == null || message.Length == 0) {
                    message = e.ToString();
                }
                MessageBox.Show(Control, message, null, MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
            }
        }

        /// <include file='doc\ControlDesigner.uex' path='docs/doc[@for="ControlDesigner.Dispose"]/*' />
        /// <devdoc>
        ///      Disposes of this object.
        /// </devdoc>
        protected override void Dispose(bool disposing) {
        
            if (disposing) {
                if (Control != null) {

                    if (dataBindingsCollectionChanged != null) {
                        Control.DataBindings.CollectionChanged -= dataBindingsCollectionChanged;
                    }

                    if (Inherited && inheritanceUI != null) {
                        inheritanceUI.RemoveInheritedControl(Control);
                    }

                    if (removalNotificationHooked) {
                        IComponentChangeService csc = (IComponentChangeService) GetService(typeof(IComponentChangeService));
                        if (csc != null) {
                            csc.ComponentRemoved -= new ComponentEventHandler(DataSource_ComponentRemoved);
                        }
                        removalNotificationHooked = false;
                    }

                    if (disposingHandler != null) {
                        disposingHandler(this, EventArgs.Empty);
                    }

                    UnhookChildControls(Control);
                    // Cancel any drag we are currently performing...
                    OnMouseDragEnd(true);
                }

                if (ContextMenu != null) {
                    ContextMenu.Disposed -= new EventHandler(this.DetachContextMenu);
                }

                if (designerTarget != null) {
                    designerTarget.Dispose();
                }

                downPos = Point.Empty;

                // Hook up the property change notification so that we can dirty the SelectionUIItem when needed.
                if (dockChanged != null) {
                    Control.DockChanged -= dockChanged;
                }

                Control.ControlAdded -= new ControlEventHandler(OnControlAdded);
                Control.ControlRemoved -= new ControlEventHandler(OnControlRemoved);
            }

            base.Dispose(disposing);
        }

        /// <include file='doc\ControlDesigner.uex' path='docs/doc[@for="ControlDesigner.EnableDragDrop"]/*' />
        /// <devdoc>
        ///      Enables or disables drag/drop support.  This 
        ///      hooks drag event handlers to the control.
        /// </devdoc>
        protected void EnableDragDrop(bool value) {
            Control rc = Control;
            
            if (rc == null) {
                return;
            }
            
            if (value) {
                rc.DragDrop += new DragEventHandler(this.OnDragDrop);
                rc.DragOver += new DragEventHandler(this.OnDragOver);
                rc.DragEnter += new DragEventHandler(this.OnDragEnter);
                rc.DragLeave += new EventHandler(this.OnDragLeave);
                rc.GiveFeedback += new GiveFeedbackEventHandler(this.OnGiveFeedback);
                hadDragDrop = rc.AllowDrop;
                if (!hadDragDrop) {
                    rc.AllowDrop = true;
                }
                revokeDragDrop = false;
            }
            else {
                rc.DragDrop -= new DragEventHandler(this.OnDragDrop);
                rc.DragOver -= new DragEventHandler(this.OnDragOver);
                rc.DragEnter -= new DragEventHandler(this.OnDragEnter);
                rc.DragLeave -= new EventHandler(this.OnDragLeave);
                rc.GiveFeedback -= new GiveFeedbackEventHandler(this.OnGiveFeedback);
                if (!hadDragDrop) {
                    rc.AllowDrop = false;
                }
                revokeDragDrop = true;
            }
        }

        /// <include file='doc\ControlDesigner.uex' path='docs/doc[@for="ControlDesigner.GetHitTest"]/*' />
        /// <devdoc>
        ///     Allows your component to support a design time user interface.  A TabStrip
        ///     control, for example, has a design time user interface that allows the user
        ///     to click the tabs to change tabs.  To implement this, TabStrip returns
        ///     true whenever the given point is within its tabs.
        /// </devdoc>
        protected virtual bool GetHitTest(Point point) {
            return false;
        }
        
        /// <devdoc>
        ///     Given an LParam as a parameter, this extracts a point in parent
        ///     coordinates.
        /// </devdoc>
        private int GetParentPointFromLparam(IntPtr lParam) {
            Point pt = new Point(NativeMethods.Util.SignedLOWORD((int)lParam), NativeMethods.Util.SignedHIWORD((int)lParam));
            pt = Control.PointToScreen(pt);
            pt = Control.Parent.PointToClient(pt);
            return NativeMethods.Util.MAKELONG(pt.X, pt.Y);
        }

        /// <include file='doc\ControlDesigner.uex' path='docs/doc[@for="ControlDesigner.HookChildControls"]/*' />
        /// <devdoc>
        ///     Hooks the children of the given control.  We need to do this for
        ///     child controls that are not in design mode, which is the case
        ///     for composite controls.
        /// </devdoc>
        protected void HookChildControls(Control firstChild) {
            
            foreach(Control child in firstChild.Controls) {                

                if (child != null && host != null) {
                    if (!(host.GetDesigner(child) is ControlDesigner)) {

                        // No, no designer means we must replace the window target in this
                        // control.
                        //
                        IWindowTarget oldTarget = child.WindowTarget;

                        if (!(oldTarget is ChildWindowTarget)) {
                            child.WindowTarget = new ChildWindowTarget(this, oldTarget);
                        }
                    
                        // ASURT 45655: Some controls (primarily RichEdit) will register themselves as
                        // drag-drop source/targets when they are instantiated. We have to RevokeDragDrop() 
                        // for them so that the ParentControlDesigner()'s drag-drop support can work 
                        // correctly. Normally, the hwnd for the child control is not created at this time,
                        // and we will use the WM_CREATE message in ChildWindowTarget's WndProc() to revoke
                        // drag-drop. But, if the handle was already created for some reason, we will need
                        // to revoke drag-drop right away.
                        //
                        if (child.IsHandleCreated) {
                            Application.OleRequired();
                            NativeMethods.RevokeDragDrop(child.Handle);
                        }

                        // We only hook the children's children if there was no designer.
                        // We leave it up to the designer to hook its own children.
                        //
                        HookChildControls(child);
                    }
                }
            }
        }

        /// <devdoc>
        ///     Hooks the peer handles of the given child control.  We need
        ///     to do this to handle windows that are not associated with
        ///     a control (such as the combo box edit), and for controls
        ///     that are not in design mode (such as child controls on a
        ///     user control).
        /// </devdoc>
        internal void HookChildHandles(IntPtr firstChild) {
            IntPtr hwndChild = firstChild;

            while (hwndChild != IntPtr.Zero) {

                // Is it a control?
                //
                Control child = Control.FromHandle(hwndChild);
                if (child == null) {

                    // ASURT 45655: Some controls (primarily RichEdit) will register themselves as
                    // drag-drop source/targets when they are instantiated. Since these hwnds do not
                    // have a Windows Forms control associated with them, we have to RevokeDragDrop() 
                    // for them so that the ParentControlDesigner()'s drag-drop support can work 
                    // correctly.
                    //
                    NativeMethods.RevokeDragDrop(hwndChild);
                    
                    // No control.  We must subclass this control.
                    //
                    new ChildSubClass(this, hwndChild);
                }

                // Now do the children of this window.
                //
                HookChildHandles(NativeMethods.GetWindow(hwndChild, NativeMethods.GW_CHILD));
                hwndChild = NativeMethods.GetWindow(hwndChild, NativeMethods.GW_HWNDNEXT);
            }
        }

        /// <include file='doc\ControlDesigner.uex' path='docs/doc[@for="ControlDesigner.Initialize"]/*' />
        /// <devdoc>
        ///     Called by the host when we're first initialized.
        /// </devdoc>
        public override void Initialize(IComponent component) {
            // Visibility works as follows:  If the control's property is not actually set, then 
            // set our shadow to true.  Otherwise, grab the shadow value from the control directly and
            // then set the control to be visible if it is not the root component.  Root components
            // will be set to visible = true in their own time by the view.
            //
            PropertyDescriptor visibleProp = TypeDescriptor.GetProperties(component.GetType())["Visible"];
            if (visibleProp == null || visibleProp.PropertyType != typeof(bool) || !visibleProp.ShouldSerializeValue(component)) 
            {
                Visible = true;
            }
            else 
            {
                Visible = (bool)visibleProp.GetValue(component);
            }

            PropertyDescriptor enabledProp = TypeDescriptor.GetProperties(component.GetType())["Enabled"];
            if (enabledProp == null || enabledProp.PropertyType != typeof(bool) || !enabledProp.ShouldSerializeValue(component)) 
            {
                Enabled = true;
            }
            else 
            {
                Enabled = (bool)enabledProp.GetValue(component);
            }


            initializing = true;
            base.Initialize(component);
            initializing = false;

            // And get other commonly used services.
            //
            host = (IDesignerHost)GetService(typeof(IDesignerHost));
            
            // Hook up the property change notifications we need to track.  One for docking,
            // and another for data binding.  More for control add / remove notifications
            //
            dockChanged = new EventHandler(this.OnControlDockChanged);
            Control.DockChanged += dockChanged;

            dataBindingsCollectionChanged = new CollectionChangeEventHandler(DataBindingsCollectionChanged);
            Control.DataBindings.CollectionChanged += dataBindingsCollectionChanged;

            Control.ControlAdded += new ControlEventHandler(OnControlAdded);
            Control.ControlRemoved += new ControlEventHandler(OnControlRemoved);

            // Replace the control's window target with our own.  This
            // allows us to hook messages.
            //
            this.DesignerTarget = new DesignerWindowTarget(this);
            
            // If the handle has already been created for this control, invoke OnCreateHandle so we
            // can hookup our child control subclass.
            //
            if (Control.IsHandleCreated) {
                OnCreateHandle();
            }
            
            // If we are an inherited control, notify our inheritance UI
            //
            if (Inherited && host != null && host.RootComponent != component) {
                inheritanceUI = (InheritanceUI)GetService(typeof(InheritanceUI));
                if (inheritanceUI != null) {
                    inheritanceUI.AddInheritedControl(Control, InheritanceAttribute.InheritanceLevel);
                }
            }

            if (host == null || host.RootComponent != component) {
                Control.Visible = true;
            }
            
            // Always make controls enabled, event inherited ones.  Otherwise we won't be able
            // to select them.
            //
            Control.Enabled = true;
            
            // And force some shadow properties that we change in the course of
            // initializing the form.
            //
            AllowDrop = Control.AllowDrop;
        }
        
        /// <include file='doc\ControlDesigner.uex' path='docs/doc[@for="ControlDesigner.InitializeNonDefault"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void InitializeNonDefault() {
            base.InitializeNonDefault();
            
            // unhook any sited children that got ChildWindowTargets
            foreach (Control c in Control.Controls) {
                  if (c != null) {
                     ISite site = c.Site;
                     if (site != null && c.WindowTarget is ChildWindowTarget) {
                        c.WindowTarget = ((ChildWindowTarget)c.WindowTarget).OldWindowTarget;
                     }
                  }
            }
        }

        /// <devdoc>
        ///     Determines if the given mouse click is a double click or not.  We must
        ///     handle this ourselves for controls that don't have the CS_DOUBLECLICKS style
        ///     set.
        /// </devdoc>
        private bool IsDoubleClick(int x, int y) {
            bool doubleClick = false;

            int wait = SystemInformation.DoubleClickTime;
            int elapsed = SafeNativeMethods.GetTickCount() -  lastClickMessageTime;

            if (elapsed <= wait) {
                Size dblClick = SystemInformation.DoubleClickSize;

                if (x >= lastClickMessagePositionX - dblClick.Width
                    && x <= lastClickMessagePositionX + dblClick.Width
                    && y >= lastClickMessagePositionY - dblClick.Height
                    && y <= lastClickMessagePositionY + dblClick.Height) {

                    doubleClick = true;
                }
            }

            if (!doubleClick) {
                lastClickMessagePositionX = x;
                lastClickMessagePositionY = y;
                lastClickMessageTime = SafeNativeMethods.GetTickCount();
            }
            else {
                lastClickMessagePositionX = lastClickMessagePositionY = 0;
                lastClickMessageTime = 0;
            }

            return doubleClick;
        }

        private bool IsMouseMessage(int msg) {
        
            if (msg >= NativeMethods.WM_MOUSEFIRST && msg <= NativeMethods.WM_MOUSELAST) {
                return true;
            }
        
            switch (msg) {
                // WM messages not covered by the above block
                case NativeMethods.WM_MOUSEHOVER:
                case NativeMethods.WM_MOUSELEAVE:
        
                // WM_NC messages
                case NativeMethods.WM_NCMOUSEMOVE:
                case NativeMethods.WM_NCLBUTTONDOWN:
                case NativeMethods.WM_NCLBUTTONUP:
                case NativeMethods.WM_NCLBUTTONDBLCLK:
                case NativeMethods.WM_NCRBUTTONDOWN:
                case NativeMethods.WM_NCRBUTTONUP:
                case NativeMethods.WM_NCRBUTTONDBLCLK:
                case NativeMethods.WM_NCMBUTTONDOWN:
                case NativeMethods.WM_NCMBUTTONUP:
                case NativeMethods.WM_NCMBUTTONDBLCLK:
                case NativeMethods.WM_NCMOUSEHOVER:
                case NativeMethods.WM_NCMOUSELEAVE:
                case NativeMethods.WM_NCXBUTTONDOWN:
                case NativeMethods.WM_NCXBUTTONUP:
                case NativeMethods.WM_NCXBUTTONDBLCLK:
        
                    return true;
                default:
                    return false;
            }
        }

        /// <include file='doc\ControlDesigner.uex' path='docs/doc[@for="ControlDesigner.OnContextMenu"]/*' />
        /// <devdoc>
        ///     Called when the context menu should be displayed
        /// </devdoc>
        protected virtual void OnContextMenu(int x, int y) {
            IMenuCommandService mcs = (IMenuCommandService)GetService(typeof(IMenuCommandService));
            if (mcs != null) {
                mcs.ShowContextMenu(MenuCommands.SelectionMenu, x, y);
            }
        }

        /// <devdoc>
        ///     Called in response to a new control being added to this designer's control.
        ///     We check to see if the control has an associated ControlDesigner.  If it
        ///     doesn't, we hook its window target so we can sniff messages and make
        ///     it ui inactive.
        /// </devdoc>
        private void OnControlAdded(object sender, ControlEventArgs e) {
            if (e.Control != null && host != null) {
                if (!(host.GetDesigner(e.Control) is ControlDesigner)) {

                    // No, no designer means we must replace the window target in this
                    // control.
                    //
                    IWindowTarget oldTarget = e.Control.WindowTarget;

                    if (!(oldTarget is ChildWindowTarget)) {
                        e.Control.WindowTarget = new ChildWindowTarget(this, oldTarget);
                    }

                    // ASURT 45655: Some controls (primarily RichEdit) will register themselves as
                    // drag-drop source/targets when they are instantiated. We have to RevokeDragDrop() 
                    // for them so that the ParentControlDesigner()'s drag-drop support can work 
                    // correctly. Normally, the hwnd for the child control is not created at this time,
                    // and we will use the WM_CREATE message in ChildWindowTarget's WndProc() to revoke
                    // drag-drop. But, if the handle was already created for some reason, we will need
                    // to revoke drag-drop right away.
                    //
                    if (e.Control.IsHandleCreated) {
                        Application.OleRequired();
                        NativeMethods.RevokeDragDrop(e.Control.Handle);
                    }

                    // We only hook the control's children if there was no designer.
                    // We leave it up to the designer to hook its own children.
                    //
                    HookChildControls(e.Control);
                }
            }
        }

        /// <devdoc>
        ///      For controls, we sync their dock changed event so our component can track their location.
        /// </devdoc>
        private void OnControlDockChanged(object sender, EventArgs e) {
            if (selectionUISvc == null) {
                selectionUISvc = (ISelectionUIService)GetService(typeof(ISelectionUIService));
            }
            if (selectionUISvc != null) {
                selectionUISvc.SyncComponent((IComponent)sender);
            }
        }

        /// <devdoc>
        ///     Called in response to a control being removed from this designer's control.
        ///     If we previously changed out this control's window target, we undo that
        ///     work here.
        /// </devdoc>
        private void OnControlRemoved(object sender, ControlEventArgs e) {
            if (e.Control != null) {

                // No, no designer means we must replace the window target in this
                // control.
                //
                IWindowTarget oldTarget = e.Control.WindowTarget;

                if (oldTarget is ChildWindowTarget) {
                    e.Control.WindowTarget = ((ChildWindowTarget)oldTarget).OldWindowTarget;
                }

                UnhookChildControls(e.Control);
            }
        }

        /// <include file='doc\ControlDesigner.uex' path='docs/doc[@for="ControlDesigner.OnCreateHandle"]/*' />
        /// <devdoc>
        ///      This is called immediately after the control handle has been created.
        /// </devdoc>
        protected virtual void OnCreateHandle() {
            OnHandleChange();
            
            if (revokeDragDrop) {
                int n = NativeMethods.RevokeDragDrop(Control.Handle);
            }
        }

        /// <devdoc>
        ///      Event handler for our drag enter event.  The host will call us with
        ///      this when an OLE drag event happens.
        /// </devdoc>
        private void  OnDragEnter(object s, DragEventArgs e) {
            OnDragEnter(e);
        }

        /// <include file='doc\ControlDesigner.uex' path='docs/doc[@for="ControlDesigner.OnDragEnter1"]/*' />
        /// <devdoc>
        ///     Called when a drag-drop operation enters the control designer view
        ///
        /// </devdoc>
        protected virtual void OnDragEnter(DragEventArgs de) {
        }

        /// <devdoc>
        ///      Event handler for our drag drop event.  The host will call us with
        ///      this when an OLE drag event happens.
        /// </devdoc>
        private void OnDragDrop(object s, DragEventArgs e) {
            OnDragDrop(e);
        }

        /// <include file='doc\ControlDesigner.uex' path='docs/doc[@for="ControlDesigner.OnDragDrop1"]/*' />
        /// <devdoc>
        ///     Called when a drag drop object is dropped onto the control designer view
        /// </devdoc>
        protected virtual void OnDragDrop(DragEventArgs de) {
        }

        /// <devdoc>
        ///      Event handler for our drag leave event.  The host will call us with
        ///      this when an OLE drag event happens.
        /// </devdoc>
        private void OnDragLeave(object s, EventArgs e) {
            OnDragLeave(e);
        }

        /// <include file='doc\ControlDesigner.uex' path='docs/doc[@for="ControlDesigner.OnDragLeave1"]/*' />
        /// <devdoc>
        ///     Called when a drag-drop operation leaves the control designer view
        ///
        /// </devdoc>
        protected virtual void OnDragLeave(EventArgs e) {
        }

        /// <devdoc>
        ///      Event handler for our drag over event.  The host will call us with
        ///      this when an OLE drag event happens.
        /// </devdoc>
        private void OnDragOver(object s, DragEventArgs e) {
            OnDragOver(e);
        }

        /// <include file='doc\ControlDesigner.uex' path='docs/doc[@for="ControlDesigner.OnDragOver1"]/*' />
        /// <devdoc>
        ///     Called when a drag drop object is dragged over the control designer view
        /// </devdoc>
        protected virtual void OnDragOver(DragEventArgs de) {
        }

        /// <devdoc>
        ///      Event handler for our GiveFeedback event, which is called when a drag operation
        ///      is in progress.  The host will call us with
        ///      this when an OLE drag event happens.
        /// </devdoc>
        private void OnGiveFeedback(object s, GiveFeedbackEventArgs e) {
            OnGiveFeedback(e);
        }

        /// <include file='doc\ControlDesigner.uex' path='docs/doc[@for="ControlDesigner.OnGiveFeedback1"]/*' />
        /// <devdoc>
        ///      Event handler for our GiveFeedback event, which is called when a drag operation
        ///      is in progress.  The host will call us with
        ///      this when an OLE drag event happens.
        /// </devdoc>
        protected virtual void OnGiveFeedback(GiveFeedbackEventArgs e) {
        }
        
        /// <devdoc>
        ///      This is called whenever the control handle changes.
        /// </devdoc>
        private void OnHandleChange() {
            // We must now traverse child handles for this control.  There are
            // three types of child handles and we are interested in two of
            // them:
            //
            //  1.  Child handles that do not have a Control associated
            //      with them.  We must subclass these and prevent them
            //      from getting design-time events.
            //
            // 2.   Child handles that do have a Control associated
            //      with them, but the control does not have a designer.
            //      We must hook the WindowTarget on these controls and
            //      prevent them from getting design-time events.
            //
            // 3.   Child handles that do have a Control associated
            //      with them, and the control has a designer.  We
            //      ignore these and let the designer handle their
            //      messages.
            //
            HookChildHandles(NativeMethods.GetWindow(Control.Handle, NativeMethods.GW_CHILD));
            HookChildControls(Control);
        }

        /// <devdoc>
        ///     Called in response to a double-click of the left mouse button.  We
        ///     Just call this on the event service
        /// </devdoc>
        private void OnMouseDoubleClick() {

            try {
               DoDefaultAction();
            }
            catch (Exception e) {
                DisplayError(e);
            }
        }
        
        /// <include file='doc\ControlDesigner.uex' path='docs/doc[@for="ControlDesigner.OnMouseDragBegin"]/*' />
        /// <devdoc>
        ///     Called in response to the left mouse button being pressed on a
        ///     component.  This does two things.  First, it ensures that the
        ///     component is selected.  Second, it uses the ISelectionUIService
        ///     to begin a drag of all selected components.
        /// </devdoc>
        protected virtual void OnMouseDragBegin(int x, int y) {

            // Ignore another mouse down if we are already in a drag.
            //
            if (mouseDragLast != InvalidPoint) {
                return;
            }

            mouseDragLast = new Point(x, y);

            // If the CTRL key isn't down, select this component,
            // otherwise, we wait until the mouse up
            //
            // Make sure the component is selected
            //

            ctrlSelect = (Control.ModifierKeys & Keys.Control) != 0;

            if (!ctrlSelect) {
                ISelectionService sel = (ISelectionService)GetService(typeof(ISelectionService));
                if (sel != null) {
                    SelectionTypes type = SelectionTypes.Click;
                    if (!sel.GetComponentSelected(Component)) {
                        type |= SelectionTypes.MouseDown;
                    }

                    sel.SetSelectedComponents(new object[] {Component}, type);
                }
            }

            Control.Capture = true;
        }

        /// <include file='doc\ControlDesigner.uex' path='docs/doc[@for="ControlDesigner.OnMouseDragEnd"]/*' />
        /// <devdoc>
        ///     Called at the end of a drag operation.  This either commits or rolls back the
        ///     drag.
        /// </devdoc>
        protected virtual void OnMouseDragEnd(bool cancel) {

            mouseDragLast = InvalidPoint;
            Control.Capture = false;

            if (!mouseDragMoved) {
                if (!cancel) {
                    ISelectionService sel = (ISelectionService)GetService(typeof(ISelectionService));
                    bool shiftSelect = (Control.ModifierKeys & Keys.Shift) != 0;
                    if (!shiftSelect && (ctrlSelect || (sel != null && !sel.GetComponentSelected(Component)))) {
                        if (sel != null) {
                            SelectionTypes type = SelectionTypes.Click;
                            if (!sel.GetComponentSelected(Component)) {
                                type |= SelectionTypes.MouseDown;
                            }
                            sel.SetSelectedComponents(new object[] {Component}, type);
                        }
                        ctrlSelect = false;
                    }
                }
                return;
            }
            mouseDragMoved = false;
            ctrlSelect = false;

            // And now finish the drag.
            //
            if (selectionUISvc == null) {
                selectionUISvc = (ISelectionUIService)GetService(typeof(ISelectionUIService));
            }

            Debug.Assert(!cancel && selectionUISvc != null, "Unable to get to selection UI service -- we will not be able to drag components.");

            if (selectionUISvc == null) {
                return;
            }

            // We must check to ensure that UI service is still in drag mode.  It is
            // possible that the user hit escape, which will cancel drag mode.
            //
            if (selectionUISvc.Dragging) {
                selectionUISvc.EndDrag(cancel);
            }
        }

        /// <include file='doc\ControlDesigner.uex' path='docs/doc[@for="ControlDesigner.OnMouseDragMove"]/*' />
        /// <devdoc>
        ///     Called for each movement of the mouse.  This will check to see if a drag operation
        ///     is in progress.  If so, it will pass the updated drag dimensions on to the selection
        ///     UI service.
        /// </devdoc>
        protected virtual void OnMouseDragMove(int x, int y) {

            if (!mouseDragMoved) {

                Size minDrag = SystemInformation.DragSize;
                Size minDblClick = SystemInformation.DoubleClickSize;

                minDrag.Width = Math.Max(minDrag.Width, minDblClick.Width);
                minDrag.Height = Math.Max(minDrag.Height, minDblClick.Height);

                // we have to make sure the mouse moved farther than
                // the minimum drag distance before we actually start
                // the drag
                //
                if (mouseDragLast == InvalidPoint ||
                    (Math.Abs(mouseDragLast.X - x) < minDrag.Width &&
                     Math.Abs(mouseDragLast.Y - y) < minDrag.Height)) {
                    return;
                }
                else {
                    mouseDragMoved = true;

                    // we're on the move, so we're not in a ctrlSelect
                    //
                    ctrlSelect = false;
                }
            }

            bool releaseCapture = true;

            // Make sure the component is selected
            //
            ISelectionService sel = (ISelectionService)GetService(typeof(ISelectionService));
            if (sel != null) {
                SelectionTypes type = SelectionTypes.Click;
                if (!sel.GetComponentSelected(Component)) {
                    type |= SelectionTypes.MouseDown;
                    sel.SetSelectedComponents(new object[] {Component}, type);
                }
            }

            // Now request that the UI service begin the drag
            //
            if (selectionUISvc == null) {
                selectionUISvc = (ISelectionUIService)GetService(typeof(ISelectionUIService));
            }

            Debug.Assert(selectionUISvc != null, "Unable to get to selection UI service -- we will not be able to drag components.");

            if (selectionUISvc != null) {
                // note: these are already in screen coords.
                // make sure we don't drag onto ourselves!
                try {
                    releaseCapture = !selectionUISvc.BeginDrag(SelectionRules.Visible | SelectionRules.Moveable, mouseDragLast.X, mouseDragLast.Y);
                }
                catch(Exception e) {
                    DisplayError(e);
                }
                if (releaseCapture && Control != null) {
                    Control.Capture = false;
                }
            }

            mouseDragLast = InvalidPoint;
            mouseDragMoved = false;
        }

        /// <include file='doc\ControlDesigner.uex' path='docs/doc[@for="ControlDesigner.OnMouseEnter"]/*' />
        /// <devdoc>
        ///     Called when the mouse first enters the control. This is forwarded to the parent
        ///     designer to enable the container selector.
        /// </devdoc>
        protected virtual void OnMouseEnter() {

            Control ctl = Control;
            Control parent = ctl;

            object parentDesigner = null;
            while (parentDesigner == null && parent != null) {
                parent = parent.Parent;
                if (parent != null) {
                    object d = host.GetDesigner(parent);
                    if (d != this) {
                        parentDesigner = d;
                    }
                }
            }

            if (parentDesigner != null && parentDesigner is ControlDesigner) {
                ((ControlDesigner)parentDesigner).OnMouseEnter();
            }
        }

        /// <include file='doc\ControlDesigner.uex' path='docs/doc[@for="ControlDesigner.OnMouseHover"]/*' />
        /// <devdoc>
        ///     Called after the mouse hovers over the control. This is forwarded to the parent
        ///     designer to enabled the container selector.
        /// </devdoc>
        protected virtual void OnMouseHover() {

            Control ctl = Control;
            Control parent = ctl;

            object parentDesigner = null;
            while (parentDesigner == null && parent != null) {
                parent = parent.Parent;
                if (parent != null) {
                    object d = host.GetDesigner(parent);
                    if (d != this) {
                        parentDesigner = d;
                    }
                }
            }

            if (parentDesigner != null && parentDesigner is ControlDesigner) {
                ((ControlDesigner)parentDesigner).OnMouseHover();
            }
        }

        /// <include file='doc\ControlDesigner.uex' path='docs/doc[@for="ControlDesigner.OnMouseLeave"]/*' />
        /// <devdoc>
        ///     Called when the mouse first enters the control. This is forwarded to the parent
        ///     designer to enable the container selector.
        /// </devdoc>
        protected virtual void OnMouseLeave() {

            Control ctl = Control;
            Control parent = ctl;

            object parentDesigner = null;
            while (parentDesigner == null && parent != null) {
                parent = parent.Parent;
                if (parent != null) {
                    object d = host.GetDesigner(parent);
                    if (d != this) {
                        parentDesigner = d;
                    }
                }
            }

            if (parentDesigner != null && parentDesigner is ControlDesigner) {
                ((ControlDesigner)parentDesigner).OnMouseLeave();
            }
        }

        /// <include file='doc\ControlDesigner.uex' path='docs/doc[@for="ControlDesigner.OnPaintAdornments"]/*' />
        /// <devdoc>
        ///     Called when the control we're designing has finished painting.  This method
        ///     gives the designer a chance to paint any additional adornments on top of the
        ///     control.
        /// </devdoc>
        protected virtual void OnPaintAdornments(PaintEventArgs pe) {

            // If this control is being inherited, paint it
            //
            if (inheritanceUI != null && pe.ClipRectangle.IntersectsWith(inheritanceUI.InheritanceGlyphRectangle)) {
                pe.Graphics.DrawImage(inheritanceUI.InheritanceGlyph, 0, 0);
            }
        }
        
        /// <include file='doc\ControlDesigner.uex' path='docs/doc[@for="ControlDesigner.OnSetCursor"]/*' />
        /// <devdoc>
        ///     Called each time the cursor needs to be set.  The ControlDesigner behavior here
        ///     will set the cursor to one of three things:
        ///     1.  If the toolbox service has a tool selected, it will allow the toolbox service to
        ///     set the cursor.
        ///     2.  If the selection UI service shows a locked selection, or if there is no location
        ///     property on the control, then the default arrow will be set.
        ///     3.  Otherwise, the four headed arrow will be set to indicate that the component can
        ///     be clicked and moved.
        ///     4.  If the user is currently dragging a component, the crosshair cursor will be used
        ///     instead of the four headed arrow.
        /// </devdoc>
        protected virtual void OnSetCursor() {

            if (Control.Dock != DockStyle.None) {
                Cursor.Current = Cursors.Default;
            }
            else {

                if (toolboxSvc == null) {
                    toolboxSvc = (IToolboxService)GetService(typeof(IToolboxService));
                }

                if (toolboxSvc != null && toolboxSvc.SetCursor()) {
                    return;
                }

                if (!locationChecked) {
                    locationChecked = true;
                    
                    try {
                        hasLocation = TypeDescriptor.GetProperties(Component)["Location"] != null;
                    }
                    catch {
                    }
                }
                
                if (!hasLocation) {
                    Cursor.Current = Cursors.Default;
                    return;
                }
    
                if (Locked) {
                    Cursor.Current = Cursors.Default;
                    return;
                }
    
                Cursor.Current = Cursors.SizeAll;
            }
        }

        /// <include file='doc\ControlDesigner.uex' path='docs/doc[@for="ControlDesigner.OnSetComponentDefaults"]/*' />
        /// <devdoc>
        ///     Called when the designer is intialized.  This allows the designer to provide some
        ///     meaningful default values in the component.  The default implementation of this
        ///     sets the components's default property to it's name, if that property is a string.
        /// </devdoc>
        public override void OnSetComponentDefaults() {

            // Don't call base.
            //
            ISite site = Component.Site;
            if (site != null) {
                PropertyDescriptor textProp = TypeDescriptor.GetProperties(Component)["Text"];
                if (textProp != null && textProp.IsBrowsable) {
                    textProp.SetValue(Component, site.Name);
                }
            }
        }

        /// <devdoc>
        ///     Paints a red rectangle with a red X, painted on a white background.  Used
        ///     when the control has thrown an exception.
        /// </devdoc>
        private void PaintException(PaintEventArgs e, Exception ex) {
            StringFormat stringFormat = new StringFormat();
            stringFormat.Alignment = StringAlignment.Near;
            stringFormat.LineAlignment = StringAlignment.Near;

            string exceptionText = ex.ToString();
            stringFormat.SetMeasurableCharacterRanges(new CharacterRange[] {new CharacterRange(0, exceptionText.Length)});

            // rendering calculations...
            //
            int penThickness = 2;
            Size glyphSize = SystemInformation.IconSize;
            int marginX = penThickness * 2;
            int marginY = penThickness * 2;

            Rectangle clientRectangle = Control.ClientRectangle;
            
            Rectangle borderRectangle = clientRectangle;
            borderRectangle.X++;
            borderRectangle.Y++;
            borderRectangle.Width -=2;
            borderRectangle.Height-=2;
            
            Rectangle imageRect = new Rectangle(marginX, marginY, glyphSize.Width, glyphSize.Height);
            
            Rectangle textRect = clientRectangle;
            textRect.X = imageRect.X + imageRect.Width + 2 * marginX;
            textRect.Y = imageRect.Y;
            textRect.Width -= (textRect.X + marginX + penThickness);
            textRect.Height -= (textRect.Y + marginY + penThickness);

            using (Font errorFont = new Font(Control.Font.FontFamily, Math.Max(SystemInformation.ToolWindowCaptionHeight - SystemInformation.BorderSize.Height - 2, Control.Font.Height), GraphicsUnit.Pixel)) {

                using(Region textRegion = e.Graphics.MeasureCharacterRanges(exceptionText, errorFont, textRect, stringFormat)[0]) {
                    // paint contents... clipping optimizations for less flicker...
                    //
                    Region originalClip = e.Graphics.Clip;

                    e.Graphics.ExcludeClip(textRegion);
                    e.Graphics.ExcludeClip(imageRect);
                    try {
                        e.Graphics.FillRectangle(Brushes.White, clientRectangle);
                    }
                    finally {
                        e.Graphics.Clip = originalClip;
                    }

                    using (Pen pen = new Pen(Color.Red, penThickness)) {
                        e.Graphics.DrawRectangle(pen, borderRectangle);
                    }

                    Icon err = SystemIcons.Error;

                    e.Graphics.FillRectangle(Brushes.White, imageRect);
                    e.Graphics.DrawIcon(err, imageRect.X, imageRect.Y);

                    textRect.X++;
                    e.Graphics.IntersectClip(textRegion);
                    try {
                        e.Graphics.FillRectangle(Brushes.White, textRect);
                        e.Graphics.DrawString(exceptionText, errorFont, new SolidBrush(Control.ForeColor), textRect, stringFormat);
                    }
                    finally {
                        e.Graphics.Clip = originalClip;
                    }
                }
            }
        }
        
        /// <include file='doc\ControlDesigner.uex' path='docs/doc[@for="ControlDesigner.PreFilterProperties"]/*' />
        /// <devdoc>
        ///      Allows a designer to filter the set of properties
        ///      the component it is designing will expose through the
        ///      TypeDescriptor object.  This method is called
        ///      immediately before its corresponding "Post" method.
        ///      If you are overriding this method you should call
        ///      the base implementation before you perform your own
        ///      filtering.
        /// </devdoc>
        protected override void PreFilterProperties(IDictionary properties) {
            base.PreFilterProperties(properties);
            
            PropertyDescriptor prop;

            // Handle shadowed properties
            //
            string[] shadowProps = new string[] {
                "Visible",
                "Enabled",
                "ContextMenu",
                "AllowDrop",
                "Location",
                "Name"
            };

            Attribute[] empty = new Attribute[0];

            for (int i = 0; i < shadowProps.Length; i++) {
                prop = (PropertyDescriptor)properties[shadowProps[i]];
                if (prop != null) {
                    properties[shadowProps[i]] = TypeDescriptor.CreateProperty(typeof(ControlDesigner), prop, empty);
                }
            }

            // replace this one seperately because it is of a different type (DesignerControlCollection) than
            // the original property (ControlCollection)
            //
            PropertyDescriptor controlsProp = (PropertyDescriptor)properties["Controls"];

            if (controlsProp != null) {
                Attribute[] attrs = new Attribute[controlsProp.Attributes.Count];
                controlsProp.Attributes.CopyTo(attrs, 0);
                properties["Controls"] = TypeDescriptor.CreateProperty(typeof(ControlDesigner), "Controls", typeof(DesignerControlCollection), attrs);
            }

            // Now we add our own design time properties.
            //
            properties["Locked"] = TypeDescriptor.CreateProperty(typeof(ControlDesigner), "Locked", typeof(bool),
                                                        new DefaultValueAttribute(false),
                                                        BrowsableAttribute.Yes,
                                                        CategoryAttribute.Design,
                                                        DesignOnlyAttribute.Yes,
                                                        new SRDescriptionAttribute(SR.lockedDescr));
        }
        
        /// <devdoc>
        ///     Returns true if the enabled property should be persisted in code gen.
        /// </devdoc>
        private bool ShouldSerializeEnabled() {
            return ShadowProperties.ShouldSerializeValue("Enabled", true);
        }

        /// <devdoc>
        ///     Returns true if the visible property should be persisted in code gen.
        /// </devdoc>
        private bool ShouldSerializeVisible() {
            return ShadowProperties.ShouldSerializeValue("Visible", true);
        }

        private bool ShouldSerializeName() {
            return initializing ? false
                : ShadowProperties.ShouldSerializeValue("Name", true);
        }

        /// <include file='doc\ControlDesigner.uex' path='docs/doc[@for="ControlDesigner.UnhookChildControls"]/*' />
        /// <devdoc>
        ///     Hooks the children of the given control.  We need to do this for
        ///     child controls that are not in design mode, which is the case
        ///     for composite controls.
        /// </devdoc>
        protected void UnhookChildControls(Control firstChild) {

            if (host == null) {
                host = (IDesignerHost)GetService(typeof(IDesignerHost));
            }

            foreach(Control child in firstChild.Controls) {                

                if (child != null) {

                    // No, no designer means we must replace the window target in this
                    // control.
                    //
                    IWindowTarget oldTarget = child.WindowTarget;

                    if (oldTarget is ChildWindowTarget) {
                        child.WindowTarget = ((ChildWindowTarget)oldTarget).OldWindowTarget;
                    }
                }

                UnhookChildControls(child);
            }
        }

        /// <include file='doc\ControlDesigner.uex' path='docs/doc[@for="ControlDesigner.WndProc"]/*' />
        /// <devdoc>
        ///     This method should be called by the extending designer for each message
        ///     the control would normally receive.  This allows the designer to pre-process
        ///     messages before allowing them to be routed to the control.
        /// </devdoc>
        [
            SecurityPermission(SecurityAction.InheritanceDemand, Flags=SecurityPermissionFlag.UnmanagedCode),
            SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)
        ]
        protected virtual void WndProc(ref Message m) {

            IMouseHandler mouseHandler = null;

            // We look at WM_NCHITTEST to determine if the mouse
            // is in a live region of the control
            //
            if (m.Msg == NativeMethods.WM_NCHITTEST) {
                if (!inHitTest) {
                    inHitTest = true;
                    Point pt = new Point((short)NativeMethods.Util.LOWORD((int)m.LParam),
                                         (short)NativeMethods.Util.HIWORD((int)m.LParam));
                    try {
                        liveRegion = GetHitTest(pt);
                    }
                    catch (Exception) {
                        liveRegion = false;
                    }
                    inHitTest = false;
                }
            }

            // Check to see if the mouse
            // is in a live region of the control
            // and that the context key is not being fired
            //
            bool isContextKey = (m.Msg == NativeMethods.WM_CONTEXTMENU);
            
            if (liveRegion && (IsMouseMessage(m.Msg) || isContextKey)) {
                // ASURT 70725: The ActiveX DataGrid control brings up a context menu on right mouse down when 
                // it is in edit mode.
                // And, when we generate a WM_CONTEXTMENU message later, it calls DefWndProc() which by default
                // calls the parent (formdesigner). The FormDesigner then brings up the AxHost context menu.
                // This code causes recursive WM_CONTEXTMENU messages to be ignored till we return from the 
                // live region message.
                //
                if (m.Msg == NativeMethods.WM_CONTEXTMENU) {
                    Debug.Assert(!inContextMenu, "Recursively hitting live region for context menu!!!");
                    inContextMenu = true;
                }
                
                try {
                    DefWndProc(ref m);
                }
                finally {
                    if (m.Msg == NativeMethods.WM_CONTEXTMENU) {
                        inContextMenu = false;
                    }
                }
                return;
            }

            // Get the x and y coordniates of the mouse message
            //
            int x = 0, y = 0;

            // Look for a mouse handler.
            //
            // CONSIDER : BrianPe, 4/26/99 - I really don't like this one bit.  We need a
            //          : centralized handler so we can do a global override for the tab order
            //          : UI, but the designer is a natural fit for an object oriented UI.
            //
            if (m.Msg >= NativeMethods.WM_MOUSEFIRST && m.Msg <= NativeMethods.WM_MOUSELAST
                || m.Msg >= NativeMethods.WM_NCMOUSEMOVE && m.Msg <= NativeMethods.WM_NCMBUTTONDBLCLK
                || m.Msg == NativeMethods.WM_SETCURSOR) {

                if (eventSvc == null) {
                    eventSvc = (IEventHandlerService)GetService(typeof(IEventHandlerService));
                }
                if (eventSvc != null) {
                    mouseHandler = (IMouseHandler)eventSvc.GetHandler(typeof(IMouseHandler));
                }
            }
            
            if (m.Msg >= NativeMethods.WM_MOUSEFIRST && m.Msg <= NativeMethods.WM_MOUSELAST) {
            
                NativeMethods.POINT pt = new NativeMethods.POINT();
                pt.x = NativeMethods.Util.SignedLOWORD((int)m.LParam);
                pt.y = NativeMethods.Util.SignedHIWORD((int)m.LParam);
                NativeMethods.MapWindowPoints(m.HWnd, IntPtr.Zero, pt, 1);
                x = pt.x;
                y = pt.y;
            }
            else if (m.Msg >= NativeMethods.WM_NCMOUSEMOVE && m.Msg <= NativeMethods.WM_NCMBUTTONDBLCLK) {
                x = NativeMethods.Util.SignedLOWORD((int)m.LParam);
                y = NativeMethods.Util.SignedHIWORD((int)m.LParam);
            }

            // This is implemented on the base designer for
            // UI activation support.  We call it so that
            // we can support UI activation.
            //
            MouseButtons button = MouseButtons.None;

            switch (m.Msg) {
                case NativeMethods.WM_CREATE:
                    DefWndProc(ref m);
                    
                    // Only call OnCreateHandle if this is our OWN
                    // window handle -- the designer window procs are
                    // re-entered for child controls.
                    //
                    if (m.HWnd == Control.Handle) {
                        OnCreateHandle();
                    }
                    break;
                 
                case NativeMethods.WM_GETOBJECT:
                    // See "How to Handle WM_GETOBJECT" in MSDN
                    if (NativeMethods.OBJID_CLIENT == (int)m.LParam) {
        
                        // Get the IAccessible GUID
                        //
                        Guid IID_IAccessible = new Guid(NativeMethods.uuid_IAccessible);
        
                        // Get an Lresult for the accessibility Object for this control
                        //
                        IntPtr punkAcc;
                        try {
                            IAccessible iacc = (IAccessible)this.AccessibilityObject;
                            
                            if (iacc == null) {
                                // Accessibility is not supported on this control
                                //
                                m.Result = (IntPtr)0;
                            }
                            else {
                                // Obtain the Lresult
                                //
                                punkAcc = Marshal.GetIUnknownForObject(iacc);
                                
                                try {
                                    m.Result = UnsafeNativeMethods.LresultFromObject(ref IID_IAccessible, m.WParam, punkAcc);
                                }
                                finally {
                                    Marshal.Release(punkAcc);
                                }
                            }
                        }
                        catch (Exception e) {
                            throw e;
                        }
                    }
                    else {  // m.lparam != OBJID_CLIENT, so do default message processing
                        DefWndProc(ref m);
                    }       
                    break;

                case NativeMethods.WM_MBUTTONDOWN:
                case NativeMethods.WM_MBUTTONUP:
                case NativeMethods.WM_MBUTTONDBLCLK:
                case NativeMethods.WM_NCMOUSEHOVER:
                case NativeMethods.WM_NCMOUSELEAVE:
                case NativeMethods.WM_MOUSEWHEEL:
                case NativeMethods.WM_NCMBUTTONDOWN:
                case NativeMethods.WM_NCMBUTTONUP:
                case NativeMethods.WM_NCMBUTTONDBLCLK:
                    // We intentionally eat these messages.
                    //
                    break;

                case NativeMethods.WM_MOUSEHOVER:
                    if (mouseHandler != null) {
                        mouseHandler.OnMouseHover(Component);
                    }
                    else {
                        OnMouseHover();
                    }
                    break;
                    
                case NativeMethods.WM_MOUSELEAVE:
                    OnMouseLeave();
                    BaseWndProc(ref m);
                    break;
                
                case NativeMethods.WM_NCLBUTTONDBLCLK:
                case NativeMethods.WM_LBUTTONDBLCLK:
                case NativeMethods.WM_NCRBUTTONDBLCLK:
                case NativeMethods.WM_RBUTTONDBLCLK:
                
                    if ((m.Msg == NativeMethods.WM_NCRBUTTONDBLCLK || m.Msg == NativeMethods.WM_RBUTTONDBLCLK)) {
                        button = MouseButtons.Right;
                    }
                    else {
                        button = MouseButtons.Left;
                    }
                    
                    if (button == MouseButtons.Left) {
    
                        // We handle doubleclick messages, and we also process
                        // our own simulated double clicks for controls that don't
                        // specify CS_WANTDBLCLKS.
                        //
                        if (mouseHandler != null) {
                            mouseHandler.OnMouseDoubleClick(Component);
                        }
                        else {
                            OnMouseDoubleClick();
                        }
                    }
                    break;

                case NativeMethods.WM_NCLBUTTONDOWN:
                case NativeMethods.WM_LBUTTONDOWN:
                case NativeMethods.WM_NCRBUTTONDOWN:
                case NativeMethods.WM_RBUTTONDOWN:

                    if ((m.Msg == NativeMethods.WM_NCRBUTTONDOWN || m.Msg == NativeMethods.WM_RBUTTONDOWN)) {
                        button = MouseButtons.Right;
                    }
                    else {
                        button = MouseButtons.Left;
                    }

                    // We don't really want the focus, but we want to focus the designer.
                    // Below we handle WM_SETFOCUS and do the right thing.
                    //
                    NativeMethods.SendMessage(Control.Handle, NativeMethods.WM_SETFOCUS, 0, 0);

                    // We simulate doubleclick for things that don't...
                    //
                    if (button == MouseButtons.Left && IsDoubleClick(x, y)) {
                        if (mouseHandler != null) {
                            mouseHandler.OnMouseDoubleClick(Component);
                        }
                        else {
                            OnMouseDoubleClick();
                        }
                    }
                    else {
                    
                        toolPassThrough = false;
                        
                        if (!this.EnableDragRect && button == MouseButtons.Left) {
                            
                            if (toolboxSvc == null) {
                                toolboxSvc = (IToolboxService)GetService(typeof(IToolboxService));
                            }
                            
                            if (toolboxSvc != null && toolboxSvc.GetSelectedToolboxItem((IDesignerHost)GetService(typeof(IDesignerHost))) != null) {
                                // there is a tool to be dragged, so set passthrough and pass to the parent.
                                toolPassThrough = true;
                            }
                        }
                        else {
                            toolPassThrough = false;
                        }
                        
                            
                        if (toolPassThrough) {
                            NativeMethods.SendMessage(Control.Parent.Handle, m.Msg, m.WParam, (IntPtr)GetParentPointFromLparam(m.LParam));
                            return;
                        }    
                        
                        if (mouseHandler != null) {
                            mouseHandler.OnMouseDown(Component, button, x, y);
                        }
                        else if (button == MouseButtons.Left) {
                            OnMouseDragBegin(x,y);

                        }
                        else if (button == MouseButtons.Right) {
                            ISelectionService selSvc = (ISelectionService)GetService(typeof(ISelectionService));
                            if (selSvc != null) {
                                selSvc.SetSelectedComponents(new object[] {Component}, SelectionTypes.Click);
                            }
                        }
                        
                        lastMoveScreenX = x;
                        lastMoveScreenY = y;
                    }
                    break;

                case NativeMethods.WM_NCMOUSEMOVE:
                case NativeMethods.WM_MOUSEMOVE:

                    if (((int)m.WParam & NativeMethods.MK_LBUTTON) != 0) {
                        button = MouseButtons.Left;
                    }
                    else if (((int)m.WParam & NativeMethods.MK_RBUTTON) != 0) {
                        button = MouseButtons.Right;
                        toolPassThrough = false;
                    }
                    else {
                        toolPassThrough = false;
                    }
                    

                    if (lastMoveScreenX != x || lastMoveScreenY != y) {
                    
                        if (toolPassThrough) {
                            NativeMethods.SendMessage(Control.Parent.Handle, m.Msg, m.WParam, (IntPtr)GetParentPointFromLparam(m.LParam));
                            return;
                        }    
                                                    
                        if (mouseHandler != null) {
                            mouseHandler.OnMouseMove(Component, x, y);
                        }
                        else if (button == MouseButtons.Left) {
                            OnMouseDragMove(x, y);
                        }
                    }
                    lastMoveScreenX = x;
                    lastMoveScreenY = y;
                    BaseWndProc(ref m);
                    break;

                case NativeMethods.WM_NCLBUTTONUP:
                case NativeMethods.WM_LBUTTONUP:
                case NativeMethods.WM_NCRBUTTONUP:
                case NativeMethods.WM_RBUTTONUP:

                    // This is implemented on the base designer for
                    // UI activation support.
                    //
                    if ((m.Msg == NativeMethods.WM_NCRBUTTONDOWN || m.Msg == NativeMethods.WM_RBUTTONDOWN)) {
                        button = MouseButtons.Right;
                    }
                    else {
                        button = MouseButtons.Left;
                    }
                    
                    bool moved = mouseDragMoved;

                    // And terminate the drag.
                    //
                    if (mouseHandler != null) {
                        mouseHandler.OnMouseUp(Component, button);
                    }
                    else {
                        if (toolPassThrough) {
                            NativeMethods.SendMessage(Control.Parent.Handle, m.Msg, m.WParam, (IntPtr)GetParentPointFromLparam(m.LParam));
                            toolPassThrough = false;
                            return;
                        }    
                        
                        if (button == MouseButtons.Left) {
                            OnMouseDragEnd(false);
                        }
                    }
                    
                    // clear any pass through.
                    toolPassThrough = false;
                    
                    BaseWndProc(ref m);
                    break;

                case NativeMethods.WM_PAINT:
                    // First, save off the update region and
                    // call our base class.
                    //
                    if (OleDragDropHandler.FreezePainting) {
                        NativeMethods.ValidateRect(m.HWnd, IntPtr.Zero);
                        break;
                    }
                    
                    NativeMethods.RECT clip = new NativeMethods.RECT();
                    IntPtr hrgn = NativeMethods.CreateRectRgn(0, 0, 0, 0);
                    NativeMethods.GetUpdateRgn(m.HWnd, hrgn, false);
                    NativeMethods.GetUpdateRect(m.HWnd, ref clip, false);
                    Region r = Region.FromHrgn(hrgn);
                    
                    try {
                        // Call the base class to do its own painting.
                        //
                        if (thrownException == null) {
                            DefWndProc(ref m);
                        }
                        
                        // Now do our own painting.
                        //
                        Graphics gr = Graphics.FromHwnd(m.HWnd);
                        if (m.HWnd != Control.Handle) {
                            // Re-map the clip rect we pass to the paint event args 
                            // to our child coordinates.
                            //
                            NativeMethods.POINT pt = new NativeMethods.POINT();
                            pt.x = 0;
                            pt.y = 0;
                            NativeMethods.MapWindowPoints(m.HWnd, Control.Handle, pt, 1);
                            gr.TranslateTransform(-pt.x, -pt.y);

                            NativeMethods.MapWindowPoints(m.HWnd, Control.Handle, ref clip, 2);
                        }
                        
                        Rectangle paintRect = new Rectangle(clip.left, clip.top, clip.right - clip.left, clip.bottom - clip.top);
                        
                        PaintEventArgs pevent = new PaintEventArgs(gr, paintRect);
                        
                        try {
                            gr.Clip = r;
                            if (thrownException == null) {
                                OnPaintAdornments(pevent);
                            }
                            else {
                                UnsafeNativeMethods.PAINTSTRUCT ps = new UnsafeNativeMethods.PAINTSTRUCT();                  
                                IntPtr dc = UnsafeNativeMethods.BeginPaint(m.HWnd, ref ps);
                                PaintException(pevent, thrownException);
                                UnsafeNativeMethods.EndPaint(m.HWnd, ref ps);
                            }
                        }
                        finally {
                            // pevent will dispose the graphics object... no need to do that separately...
                            //
                            if (pevent != null) {
                                pevent.Dispose();
                            }
                            else {
                                gr.Dispose();
                            }
                        }
                    }
                    finally {
                       r.Dispose();
                       NativeMethods.DeleteObject(hrgn);
                    }
                    break;

                case NativeMethods.WM_SETCURSOR:
                    // We always handle setting the cursor ourselves.
                    //
                    if (liveRegion) {
                        DefWndProc(ref m);
                        break;
                    }

                    if (mouseHandler != null) {
                        mouseHandler.OnSetCursor(Component);
                    }
                    else {
                        OnSetCursor();
                    }
                    break;

                case NativeMethods.WM_SIZE:
                    if (this.thrownException != null) {
                        Control.Invalidate();
                    }
                    DefWndProc(ref m);
                    break;
                case NativeMethods.WM_CANCELMODE:
                    // When we get cancelmode (i.e. you tabbed away to another window)
                    // then we want to cancel any pending drag operation!
                    //
                    OnMouseDragEnd(true);
                    DefWndProc(ref m);
                    break;

                case NativeMethods.WM_SETFOCUS:
                    // We always eat the focus.
                    //
                    if (host != null && host.RootComponent != null) {
                        IDesigner d = host.GetDesigner(host.RootComponent);
                        if (d is IRootDesigner) {
                            IRootDesigner rd = (IRootDesigner)d;
                            ViewTechnology[] techs = rd.SupportedTechnologies;
                            foreach(ViewTechnology t in techs) {
                                if (t == ViewTechnology.WindowsForms) {
                                    ((Control)rd.GetView(t)).Focus();
                                    break;
                                }
                            }
                        }
                    }
                    break;

                case NativeMethods.WM_CONTEXTMENU:
                    if (inContextMenu) {
                        break;
                    }

                    // We handle this in addition to a right mouse button.
                    // Why?  Because we often eat the right mouse button, so
                    // it may never generate a WM_CONTEXTMENU.  However, the
                    // system may generate one in response to an F-10.
                    //
                    x = NativeMethods.Util.SignedLOWORD((int)m.LParam);
                    y = NativeMethods.Util.SignedHIWORD((int)m.LParam);
                    if (x == -1 && y == -1) {
                        // for shift-F10
                        Point p = Cursor.Position;
                        x = p.X;
                        y = p.Y;
                    }
                    OnContextMenu(x, y);
                    break;

                default:
                
                    if (m.Msg == NativeMethods.WM_MOUSEENTER) {
                        OnMouseEnter();
                        BaseWndProc(ref m);
                    }
                    // We eat all key handling to the control.  Controls generally
                    // should not be getting focus anyway, so this shouldn't happen.
                    // However, we want to prevent this as much as possible.
                    //
                    else if (m.Msg < NativeMethods.WM_KEYFIRST || m.Msg > NativeMethods.WM_KEYLAST) {
                        DefWndProc(ref m);
                    }
                    break;
            }
        }

        /// <devdoc>
        ///     This is a subclass window that we attach to all child windows.
        ///     We use this to disable a child hwnd's UI during design time.
        /// </devdoc>
        private class ChildSubClass : NativeWindow, IDesignerTarget {
            private ControlDesigner designer;

            /// <devdoc>
            ///     Creates a new ChildSubClass object.  This subclasses
            ///     the given hwnd immediately.
            /// </devdoc>
            public ChildSubClass(ControlDesigner designer, IntPtr hwnd) {
                this.designer = designer;
                if (designer != null) {
                    designer.disposingHandler += new EventHandler(this.OnDesignerDisposing);
                }
                AssignHandle(hwnd);
            }

            void IDesignerTarget.DefWndProc(ref Message m) {
                base.DefWndProc(ref m);
            }
            
            public void Dispose() {
                designer = null;
            }
            
            private void OnDesignerDisposing(object sender, EventArgs e) {
                Dispose();
            }
            
            /// <include file='doc\ControlDesigner.uex' path='docs/doc[@for="ControlDesigner.ChildSubClass.WndProc"]/*' />
            /// <devdoc>
            ///     Overrides Window's WndProc to process messages.
            /// </devdoc>
            protected override void WndProc(ref Message m) {
            
                if (designer == null) {
                    DefWndProc(ref m);
                    return;
                }
               
                // We want these messages to go through the designer's WndProc
                // method, and we want people to be able to do default processing
                // with the designer's DefWndProc.  So, we stuff ourselves into
                // the designers window target and call their WndProc.
                //
                IDesignerTarget designerTarget = designer.DesignerTarget;
                
                designer.DesignerTarget = this;
                
                Debug.Assert(m.HWnd == this.Handle, "Message handle differs from target handle");
                
                try {
                   designer.WndProc(ref m);
                }
                catch (Exception ex){
                    designer.Exception = ex;
                }
                finally {
                   // make sure the designer wasn't destroyed
                   //
                   if (designer != null && designer.Component != null) {
                       designer.DesignerTarget = designerTarget;
                   }
                }
            }
        }

        /// <devdoc>
        ///     This is a subclass class that attaches to a control instance.
        ///     Controls can be subclasses by hooking their IWindowTarget
        ///     interface.  We use this to disable a child hwnd's UI during
        ///     design time.
        /// </devdoc>
        private class ChildWindowTarget : IWindowTarget, IDesignerTarget {
            private ControlDesigner designer;
            private IWindowTarget oldWindowTarget;
            private IntPtr handle = IntPtr.Zero;

            /// <include file='doc\ControlDesigner.uex' path='docs/doc[@for="ControlDesigner.ChildWindowTarget.ChildWindowTarget"]/*' />
            /// <devdoc>
            ///     Creates a new ChildWindowTarget object.  This hooks the
            ///     given control's window target.
            /// </devdoc>
            public ChildWindowTarget(ControlDesigner designer, IWindowTarget oldWindowTarget) {
                this.designer = designer;
                this.oldWindowTarget = oldWindowTarget;
            }

            public IWindowTarget OldWindowTarget {
                get {
                    return oldWindowTarget;
                }
            }

            public ControlDesigner Designer {
                get {
                    return designer;
                }
            }

            /// <include file='doc\ControlDesigner.uex' path='docs/doc[@for="ControlDesigner.ChildWindowTarget.DefWndProc"]/*' />
            /// <devdoc>
            ///     Causes default window processing for the given message.  We
            ///     just forward this on to the old control target.
            /// </devdoc>
            public void DefWndProc(ref Message m) {
                oldWindowTarget.OnMessage(ref m);
            }
            
            public void Dispose() {
                // Do nothing.  We will pick this up through a null DesignerTarget property
                // when we come out of the message loop.
            }
            
            /// <include file='doc\ControlDesigner.uex' path='docs/doc[@for="ControlDesigner.ChildWindowTarget.OnHandleChange"]/*' />
            /// <devdoc>
            ///      Called when the window handle of the control has changed.
            /// </devdoc>
            public void OnHandleChange(IntPtr newHandle) {
                handle = newHandle;
                oldWindowTarget.OnHandleChange(newHandle);
            }

            /// <include file='doc\ControlDesigner.uex' path='docs/doc[@for="ControlDesigner.ChildWindowTarget.OnMessage"]/*' />
            /// <devdoc>
            ///      Called to do control-specific processing for this window.
            /// </devdoc>
            public void OnMessage(ref Message m) {
            
                // If the designer has jumped ship, the continue
                // partying on messages, but send them back to the original control.
                if (designer.Component == null) {
                    oldWindowTarget.OnMessage(ref m);
                    return;
                }
            
                // We want these messages to go through the designer's WndProc
                // method, and we want people to be able to do default processing
                // with the designer's DefWndProc.  So, we stuff the old window
                // target into the designer's target and then call their
                // WndProc.
                //
                IDesignerTarget designerTarget = designer.DesignerTarget;
                
                designer.DesignerTarget = this;
                
                try {
                    designer.WndProc(ref m);
                }
                catch (Exception ex) {
                    designer.Exception = ex;
                }
                finally {
                
                    // If the designer disposed us, then we should follow suit.
                    //
                    if (designer.DesignerTarget == null) {
                        designerTarget.Dispose();
                    }
                    else {
                        designer.DesignerTarget = designerTarget;
                    }
                    
                    // ASURT 45655: Controls (primarily RichEdit) will register themselves as
                    // drag-drop source/targets when they are instantiated. Normally, when they
                    // are being designed, we will RevokeDragDrop() in their designers. The problem
                    // occurs when these controls are inside a UserControl. At that time, we do not
                    // have a designer for these controls, and they prevent the ParentControlDesigner's
                    // drag-drop from working. What we do is to loop through all child controls that 
                    // do not have a designer (in HookChildControls()), and RevokeDragDrop() after
                    // their handles have been created.
                    //
                    if (m.Msg == NativeMethods.WM_CREATE) {
                        Debug.Assert(handle != IntPtr.Zero, "Handle for control not created");
                        NativeMethods.RevokeDragDrop(handle);
                    }
                }
            }
        }

        /// <devdoc>
        ///     This class is the interface the designer will use to funnel messages
        ///     back to the control.
        /// </devdoc>
        private interface IDesignerTarget : IDisposable {
            /// <include file='doc\ControlDesigner.uex' path='docs/doc[@for="ControlDesigner.IDesignerTarget.DefWndProc"]/*' />
            /// <devdoc>
            ///     Causes default window processing for the given message.  We
            ///     just forward this on to the old control target.
            /// </devdoc>
            void DefWndProc(ref Message m);
        }

        /// <devdoc>
        ///     This class replaces Control's window target, which effectively subclasses
        ///     the control in a handle-independent way.
        /// </devdoc>
        private class DesignerWindowTarget : IWindowTarget, IDesignerTarget, IDisposable {
            internal ControlDesigner designer;
            internal IWindowTarget oldTarget;

            /// <include file='doc\ControlDesigner.uex' path='docs/doc[@for="ControlDesigner.DesignerWindowTarget.DesignerWindowTarget"]/*' />
            /// <devdoc>
            ///     Creates a new DesignerTarget object.
            /// </devdoc>
            public DesignerWindowTarget(ControlDesigner designer) {

                Control control = designer.Control;

                this.designer = designer;
                this.oldTarget = control.WindowTarget;
                control.WindowTarget = this;
            }

            /// <include file='doc\ControlDesigner.uex' path='docs/doc[@for="ControlDesigner.DesignerWindowTarget.DefWndProc"]/*' />
            /// <devdoc>
            ///     Causes default window processing for the given message.  We
            ///     just forward this on to the old control target.
            /// </devdoc>
            public void DefWndProc(ref Message m) {
                oldTarget.OnMessage(ref m);
            }

            /// <include file='doc\ControlDesigner.uex' path='docs/doc[@for="ControlDesigner.DesignerWindowTarget.Dispose"]/*' />
            /// <devdoc>
            ///      Disposes this window target.  This re-establishes the
            ///      prior window target.
            /// </devdoc>
            public void Dispose() {
                if (designer != null) {
                    designer.Control.WindowTarget = oldTarget;
                    designer = null;
                }
            }

            /// <include file='doc\ControlDesigner.uex' path='docs/doc[@for="ControlDesigner.DesignerWindowTarget.OnHandleChange"]/*' />
            /// <devdoc>
            ///      Called when the window handle of the control has changed.
            /// </devdoc>
            public void OnHandleChange(IntPtr newHandle) {
                oldTarget.OnHandleChange(newHandle);
                if (newHandle != IntPtr.Zero) {
                    designer.OnHandleChange();
                }
            }

            /// <include file='doc\ControlDesigner.uex' path='docs/doc[@for="ControlDesigner.DesignerWindowTarget.OnMessage"]/*' />
            /// <devdoc>
            ///      Called to do control-specific processing for this window.
            /// </devdoc>
            public void OnMessage(ref Message m) {

                // We want these messages to go through the designer's WndProc
                // method, and we want people to be able to do default processing
                // with the designer's DefWndProc.  So, we stuff ourselves into
                // the designers window target and call their WndProc.
                //
                ControlDesigner currentDesigner = designer;

                if (currentDesigner != null) {
                    IDesignerTarget designerTarget = currentDesigner.DesignerTarget;
                    currentDesigner.DesignerTarget = this;

                   try {
                       currentDesigner.WndProc(ref m);
                   }
                   catch (Exception ex) {
                       designer.Exception = ex;
                   }
                   finally {
                       if (currentDesigner != null) {
                            currentDesigner.DesignerTarget = designerTarget;
                       }
                   }
                }
                else {
                    DefWndProc(ref m);
                }
            }
        }
                
        /// <include file='doc\ControlDesigner.uex' path='docs/doc[@for="ControlDesignerAccessibleObject"]/*' />        
        [ComVisible(true)]        
        public class ControlDesignerAccessibleObject : AccessibleObject {
        
            private ControlDesigner designer = null;
            private Control control = null;
            private IDesignerHost host = null;
            private ISelectionService selSvc = null;
        
            /// <include file='doc\ControlDesigner.uex' path='docs/doc[@for="ControlDesigner.ControlDesignerAccessibleObject.ControlDesignerAccessibleObject"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public ControlDesignerAccessibleObject(ControlDesigner designer, Control control) {
                this.designer = designer;
                this.control = control;
            }
            
            /// <include file='doc\ControlDesigner.uex' path='docs/doc[@for="ControlDesigner.ControlDesignerAccessibleObject.Bounds"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public override Rectangle Bounds {
                get {
                    return control.AccessibilityObject.Bounds;
                }
            }
            
            /// <include file='doc\ControlDesigner.uex' path='docs/doc[@for="ControlDesigner.ControlDesignerAccessibleObject.Description"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public override string Description {
                get {
                    return control.AccessibilityObject.Description;
                }
            }
            
            private IDesignerHost DesignerHost {
                get {
                    if (host == null) {
                        host = (IDesignerHost)designer.GetService(typeof(IDesignerHost));
                    }
                    return host;
                }
            }
            
            /// <include file='doc\ControlDesigner.uex' path='docs/doc[@for="ControlDesigner.ControlDesignerAccessibleObject.DefaultAction"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public override string DefaultAction {
                get {
                    return "";
                }
            }
            
            /// <include file='doc\ControlDesigner.uex' path='docs/doc[@for="ControlDesigner.ControlDesignerAccessibleObject.Name"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public override string Name {
                get {
                    return control.Name;
                }
            }
            
            /// <include file='doc\ControlDesigner.uex' path='docs/doc[@for="ControlDesigner.ControlDesignerAccessibleObject.Parent"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public override AccessibleObject Parent {
                get {
                    return control.AccessibilityObject.Parent;
                }
            }
            
            /// <include file='doc\ControlDesigner.uex' path='docs/doc[@for="ControlDesigner.ControlDesignerAccessibleObject.Role"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public override AccessibleRole Role {
                get {
                    return control.AccessibilityObject.Role;
                }
            }
            
            private ISelectionService SelectionService {
                get {
                    if (selSvc == null) {
                        selSvc = (ISelectionService)designer.GetService(typeof(ISelectionService));
                    }
                    
                    return selSvc;
                }
            }
            
            /// <include file='doc\ControlDesigner.uex' path='docs/doc[@for="ControlDesigner.ControlDesignerAccessibleObject.State"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public override AccessibleStates State {
                get {
                    AccessibleStates state = control.AccessibilityObject.State;
                    
                    ISelectionService s = SelectionService;
                    if (s != null) {
                        if (s.GetComponentSelected(this.control)) {
                            state |= AccessibleStates.Selected;
                        }
                        if (s.PrimarySelection == this.control) {
                            state |= AccessibleStates.Focused;
                        }
                    }
                    
                    return state;
                }
            }
            
            /// <include file='doc\ControlDesigner.uex' path='docs/doc[@for="ControlDesigner.ControlDesignerAccessibleObject.Value"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public override string Value {
                get {
                    return control.AccessibilityObject.Value;
                }
            }
            
            /// <include file='doc\ControlDesigner.uex' path='docs/doc[@for="ControlDesigner.ControlDesignerAccessibleObject.GetChild"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public override AccessibleObject GetChild(int index) {
                Debug.WriteLineIf(CompModSwitches.MSAA.TraceInfo, "ControlDesignerAccessibleObject.GetChild(" + index.ToString() + ")"); 
                
                Control.ControlAccessibleObject childAccObj = control.AccessibilityObject.GetChild(index) as Control.ControlAccessibleObject;
                if (childAccObj != null) {
                    AccessibleObject cao = GetDesignerAccessibleObject(childAccObj);
                    if (cao != null) {
                        return cao;
                    }
                }
                
                return control.AccessibilityObject.GetChild(index);
            }
            
            /// <include file='doc\ControlDesigner.uex' path='docs/doc[@for="ControlDesignerAccessibleObject.GetChildCount"]/*' />
            public override int GetChildCount() {
                return control.AccessibilityObject.GetChildCount();
            }
            private AccessibleObject GetDesignerAccessibleObject(Control.ControlAccessibleObject cao) {
                if (cao == null) {
                    return null;
                }
                ControlDesigner ctlDesigner = DesignerHost.GetDesigner(cao.Owner) as ControlDesigner;
                if (ctlDesigner != null) {
                    return ctlDesigner.AccessibilityObject;
                }   
                return null; 
            }
            
            /// <include file='doc\ControlDesigner.uex' path='docs/doc[@for="ControlDesignerAccessibleObject.GetFocused"]/*' />
            public override AccessibleObject GetFocused() {
                if ((this.State & AccessibleStates.Focused) != 0) {
                    return this;
                }
                return base.GetFocused();
            }
            
            /// <include file='doc\ControlDesigner.uex' path='docs/doc[@for="ControlDesignerAccessibleObject.GetSelected"]/*' />
            public override AccessibleObject GetSelected() {
                if ((this.State & AccessibleStates.Selected) != 0) {
                    return this;
                }
                return base.GetFocused();
            }
            
            /// <include file='doc\ControlDesigner.uex' path='docs/doc[@for="ControlDesignerAccessibleObject.HitTest"]/*' />
            public override AccessibleObject HitTest(int x, int y) {
                return control.AccessibilityObject.HitTest(x, y);
            }
        }

        [ListBindable(false)]
        internal class DesignerControlCollection : Control.ControlCollection, IList {

            Control.ControlCollection realCollection;
            
            public DesignerControlCollection(Control owner) : base(owner) {
                this.realCollection = owner.Controls;
            }

             /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ControlCollection.Count"]/*' />
            /// <devdoc>
            ///     Retrieves the number of child controls.
            /// </devdoc>
            public new int Count {
                get {
                    return realCollection.Count;
                }
            }

            /// <include file='doc\Control.uex' path='docs/doc[@for="ControlCollection.ICollection.SyncRoot"]/*' />
            /// <internalonly/>
            object ICollection.SyncRoot {
                get {
                    return this;
                }
            }

            /// <include file='doc\Control.uex' path='docs/doc[@for="ControlCollection.ICollection.IsSynchronized"]/*' />
            /// <internalonly/>
            bool ICollection.IsSynchronized {
                get {
                    return false;
                }
            }
            
            /// <include file='doc\Control.uex' path='docs/doc[@for="ControlCollection.IList.IsFixedSize"]/*' />
            /// <internalonly/>
            bool IList.IsFixedSize {
                get {
                    return false;
                }
            }
            
            /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ControlCollection.IsReadOnly"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public new bool IsReadOnly {
                get {
                    return realCollection.IsReadOnly;
                }
            }

            
            /// <include file='doc\Control.uex' path='docs/doc[@for="ControlCollection.IList.Add"]/*' />
            /// <internalonly/>
            int IList.Add(object control) {
                return ((IList)realCollection).Add(control);
            }

            public override void Add(Control c) {
                realCollection.Add(c);
            }
            
            /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ControlCollection.AddRange"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public override void AddRange(Control[] controls) {
                realCollection.AddRange(controls);
            }
            
            /// <include file='doc\Control.uex' path='docs/doc[@for="ControlCollection.IList.Contains"]/*' />
            /// <internalonly/>
            bool IList.Contains(object control) {
                return ((IList)realCollection).Contains(control);
            }

            public new void CopyTo(Array dest, int index) {
                realCollection.CopyTo(dest, index);
            }

            /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ControlCollection.Equals"]/*' />
            /// <internalonly/>
            public override bool Equals(object other) {
                return realCollection.Equals(other);
            }

            public new IEnumerator GetEnumerator() {
               return realCollection.GetEnumerator();
            }

            /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ControlCollection.GetHashCode"]/*' />
            /// <internalonly/>
            public override int GetHashCode() {
                return realCollection.GetHashCode();
            }
            
            /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ControlCollection.SetChildIndex"]/*' />
            /// <devdoc>
            ///     Sets the index of the specified
            ///     child control in this array.  An ArgumentException
            ///     is thrown if child is not parented to this
            ///     Control.
            /// </devdoc>
            public new void SetChildIndex(Control child, int newIndex) {
                realCollection.SetChildIndex(child, newIndex);
            }

            /// <include file='doc\Control.uex' path='docs/doc[@for="ControlCollection.IList.IndexOf"]/*' />
            /// <internalonly/>
            int IList.IndexOf(object control) {
                return ((IList)realCollection).IndexOf(control);
            }
            
            /// <include file='doc\Control.uex' path='docs/doc[@for="ControlCollection.IList.Insert"]/*' />
            /// <internalonly/>
            void IList.Insert(int index, object value) {
                ((IList)realCollection).Insert(index, value);
            }
                      
            /// <include file='doc\Control.uex' path='docs/doc[@for="ControlCollection.IList.Remove"]/*' />
            /// <internalonly/>
            void IList.Remove(object control) {
                ((IList)realCollection).Remove(control);                
            }

            /// <include file='doc\Control.uex' path='docs/doc[@for="ControlCollection.IList.Remove"]/*' />
            /// <internalonly/>
            void IList.RemoveAt(int index) {
                ((IList)realCollection).RemoveAt(index);                
            }
            
            /// <include file='doc\Control.uex' path='docs/doc[@for="ControlCollection.IList.this"]/*' />
            /// <internalonly/>
            object IList.this[int index] {
                get {
                    return ((IList)realCollection)[index];
                }
                set {
                    throw new NotSupportedException();
                }
            }

            /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ControlCollection.Clear"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public override void Clear() {
                
                // only remove the sited components
                //
                for (int i = realCollection.Count - 1; i >= 0; i--) {
                    if (realCollection[i] != null && realCollection[i].Site != null) {
                        realCollection.RemoveAt(i);
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\controlcommandset.cs ===
//------------------------------------------------------------------------------
// <copyright file="ControlCommandSet.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms.Design {
    using System.Design;
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.Collections;
    using Microsoft.Win32;    
    using System.ComponentModel.Design;
    using System.Drawing;
    using System.Windows.Forms;
    using System.Windows.Forms.ComponentModel;
    using System.Windows.Forms.Design;

    /// <include file='doc\ControlCommandSet.uex' path='docs/doc[@for="ControlCommandSet"]/*' />
    /// <devdoc>
    ///      This class implements menu commands that are specific to designers that
    ///      manipulate controls.
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class ControlCommandSet : CommandSet {
        private CommandSetItem[]        commandSet;
        private TabOrder                tabOrder;
        private Control                 baseControl;

        /// <include file='doc\ControlCommandSet.uex' path='docs/doc[@for="ControlCommandSet.ControlCommandSet"]/*' />
        /// <devdoc>
        ///     Creates a new CommandSet object.  This object implements the set
        ///     of commands that the UI.Win32 form designer offers.
        /// </devdoc>
        public ControlCommandSet(ISite site) : base(site) {
        
            // Establish our set of commands
            //
            commandSet = new CommandSetItem[] {

                // Allignment commands
                new CommandSetItem(
                                  this,
                                  new EventHandler(OnStatusMultiSelectPrimary),
                                  new EventHandler(OnMenuAlignByPrimary),
                                  MenuCommands.AlignLeft),

                new CommandSetItem(
                                  this,
                                  new EventHandler(OnStatusMultiSelectPrimary),
                                  new EventHandler(OnMenuAlignByPrimary),
                                  MenuCommands.AlignTop),

                new CommandSetItem(
                                  this,
                                  new EventHandler(OnStatusControlsOnlySelection),
                                  new EventHandler(OnMenuAlignToGrid),
                                  MenuCommands.AlignToGrid),

                new CommandSetItem(
                                  this,
                                  new EventHandler(OnStatusMultiSelectPrimary),
                                  new EventHandler(OnMenuAlignByPrimary),
                                  MenuCommands.AlignBottom),

                new CommandSetItem(
                                  this,
                                  new EventHandler(OnStatusMultiSelectPrimary),
                                  new EventHandler(OnMenuAlignByPrimary),
                                  MenuCommands.AlignHorizontalCenters),

                new CommandSetItem(
                                  this,
                                  new EventHandler(OnStatusMultiSelectPrimary),
                                  new EventHandler(OnMenuAlignByPrimary),
                                  MenuCommands.AlignRight),

                new CommandSetItem(
                                  this,
                                  new EventHandler(OnStatusMultiSelectPrimary),
                                  new EventHandler(OnMenuAlignByPrimary),
                                  MenuCommands.AlignVerticalCenters),


                // Centering commands
                new CommandSetItem(
                                  this,
                                  new EventHandler(OnStatusControlsOnlySelection),
                                  new EventHandler(OnMenuCenterSelection),
                                  MenuCommands.CenterHorizontally),

                new CommandSetItem(
                                  this,
                                  new EventHandler(OnStatusControlsOnlySelection),
                                  new EventHandler(OnMenuCenterSelection),
                                  MenuCommands.CenterVertically),


                // Spacing commands
                new CommandSetItem(
                                  this,
                                  new EventHandler(OnStatusMultiSelect),
                                  new EventHandler(OnMenuSpacingCommand),
                                  MenuCommands.HorizSpaceConcatenate),

                new CommandSetItem(
                                  this,
                                  new EventHandler(OnStatusMultiSelect),
                                  new EventHandler(OnMenuSpacingCommand),
                                  MenuCommands.HorizSpaceDecrease),

                new CommandSetItem(
                                  this,
                                  new EventHandler(OnStatusMultiSelect),
                                  new EventHandler(OnMenuSpacingCommand),
                                  MenuCommands.HorizSpaceIncrease),

                new CommandSetItem(
                                  this,
                                  new EventHandler(OnStatusMultiSelect),
                                  new EventHandler(OnMenuSpacingCommand),
                                  MenuCommands.HorizSpaceMakeEqual),

                new CommandSetItem(
                                  this,
                                  new EventHandler(OnStatusMultiSelect),
                                  new EventHandler(OnMenuSpacingCommand),
                                  MenuCommands.VertSpaceConcatenate),

                new CommandSetItem(
                                  this,
                                  new EventHandler(OnStatusMultiSelect),
                                  new EventHandler(OnMenuSpacingCommand),
                                  MenuCommands.VertSpaceDecrease),

                new CommandSetItem(
                                  this,
                                  new EventHandler(OnStatusMultiSelect),
                                  new EventHandler(OnMenuSpacingCommand),
                                  MenuCommands.VertSpaceIncrease),

                new CommandSetItem(
                                  this,
                                  new EventHandler(OnStatusMultiSelect),
                                  new EventHandler(OnMenuSpacingCommand),
                                  MenuCommands.VertSpaceMakeEqual),


                // Sizing commands
                new CommandSetItem(
                                  this,
                                  new EventHandler(OnStatusMultiSelectPrimary),
                                  new EventHandler(OnMenuSizingCommand),
                                  MenuCommands.SizeToControl),

                new CommandSetItem(
                                  this,
                                  new EventHandler(OnStatusMultiSelectPrimary),
                                  new EventHandler(OnMenuSizingCommand),
                                  MenuCommands.SizeToControlWidth),

                new CommandSetItem(
                                  this,
                                  new EventHandler(OnStatusMultiSelectPrimary),
                                  new EventHandler(OnMenuSizingCommand),
                                  MenuCommands.SizeToControlHeight),

                new CommandSetItem(
                                  this,
                                  new EventHandler(OnStatusControlsOnlySelection),
                                  new EventHandler(OnMenuSizeToGrid),
                                  MenuCommands.SizeToGrid),


                // Z-Order commands
                new CommandSetItem(
                                  this,
                                  new EventHandler(OnStatusZOrder),
                                  new EventHandler(OnMenuZOrderSelection),
                                  MenuCommands.BringToFront),

                new CommandSetItem(
                                  this,
                                  new EventHandler(OnStatusZOrder),
                                  new EventHandler(OnMenuZOrderSelection),
                                  MenuCommands.SendToBack),

                // Miscellaneous commands
                new CommandSetItem(
                                  this,
                                  new EventHandler(OnStatusShowGrid),
                                  new EventHandler(OnMenuShowGrid),
                                  MenuCommands.ShowGrid),

                new CommandSetItem(
                                  this,
                                  new EventHandler(OnStatusSnapToGrid),
                                  new EventHandler(OnMenuSnapToGrid),
                                  MenuCommands.SnapToGrid),

                new CommandSetItem(
                                  this,
                                  new EventHandler(OnStatusAnyControls),
                                  new EventHandler(OnMenuTabOrder),
                                  MenuCommands.TabOrder),

                new CommandSetItem(
                                  this,
                                  new EventHandler(OnStatusLockControls),
                                  new EventHandler(OnMenuLockControls),
                                  MenuCommands.LockControls),

                // Keyboard commands
                new CommandSetItem(
                                  this,
                                  new EventHandler(OnStatusAlways),
                                  new EventHandler(OnKeySize),
                                  MenuCommands.KeySizeWidthIncrease),

                new CommandSetItem(
                                  this,
                                  new EventHandler(OnStatusAlways),
                                  new EventHandler(OnKeySize),
                                  MenuCommands.KeySizeHeightIncrease),

                new CommandSetItem(
                                  this,
                                  new EventHandler(OnStatusAlways),
                                  new EventHandler(OnKeySize),
                                  MenuCommands.KeySizeWidthDecrease),

                new CommandSetItem(
                                  this,
                                  new EventHandler(OnStatusAlways),
                                  new EventHandler(OnKeySize),
                                  MenuCommands.KeySizeHeightDecrease),

                new CommandSetItem(
                                  this,
                                  new EventHandler(OnStatusAlways),
                                  new EventHandler(OnKeySize),
                                  MenuCommands.KeyNudgeWidthIncrease),

                new CommandSetItem(
                                  this,
                                  new EventHandler(OnStatusAlways),
                                  new EventHandler(OnKeySize),
                                  MenuCommands.KeyNudgeHeightIncrease),

                new CommandSetItem(
                                  this,
                                  new EventHandler(OnStatusAlways),
                                  new EventHandler(OnKeySize),
                                  MenuCommands.KeyNudgeWidthDecrease),

                new CommandSetItem(
                                  this,
                                  new EventHandler(OnStatusAlways),
                                  new EventHandler(OnKeySize),
                                  MenuCommands.KeyNudgeHeightDecrease),

                new CommandSetItem(
                                  this,
                                  new EventHandler(OnStatusAlways),
                                  new EventHandler(OnKeySelect),
                                  MenuCommands.KeySelectNext),

                new CommandSetItem(
                                  this,
                                  new EventHandler(OnStatusAlways),
                                  new EventHandler(OnKeySelect),
                                  MenuCommands.KeySelectPrevious),
            };

            if (MenuService != null) {
                for (int i = 0; i < commandSet.Length; i++) {
                    MenuService.AddCommand(commandSet[i]);
                }
            }
            
            // Get the base control object.
            //
            IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
            if (host != null) {
                IComponent comp = host.RootComponent;
                if (comp is Control) {
                    baseControl = (Control)comp;
                }
            }
        }

        /// <include file='doc\ControlCommandSet.uex' path='docs/doc[@for="ControlCommandSet.Dispose"]/*' />
        /// <devdoc>
        ///     Disposes of this object, removing all commands from the menu service.
        /// </devdoc>
        public override void Dispose() {
            if (MenuService != null) {
                for (int i = 0; i < commandSet.Length; i++) {
                    MenuService.RemoveCommand(commandSet[i]);
                }
            }
            base.Dispose();
        }

        /// <include file='doc\ControlCommandSet.uex' path='docs/doc[@for="ControlCommandSet.GetSnapInformation"]/*' />
        /// <devdoc>
        ///      Retrieves the snap information for the given component.  
        /// </devdoc>
        protected override void GetSnapInformation(IDesignerHost host, IComponent component, out Size snapSize, out IComponent snapComponent, out PropertyDescriptor snapProperty) {
        
            IComponent currentSnapComponent = null;
            IContainer container = component.Site.Container;
            PropertyDescriptor gridSizeProp = null;
            PropertyDescriptor currentSnapProp = null;
            PropertyDescriptorCollection props;
        
            // This implementation is specific to controls.  It looks in the parent hierarchy for an object with a 
            // snap property.  If it fails to find one, it just gets the base component.
            //
            if (component is Control) {
                Control c = ((Control)component).Parent;
                while (c != null && currentSnapComponent == null) {
                    props = TypeDescriptor.GetProperties(c);
                    currentSnapProp = props["SnapToGrid"];
                    if (currentSnapProp != null) {
                        if (currentSnapProp.PropertyType == typeof(bool) && c.Site != null && c.Site.Container == container) {
                            currentSnapComponent = c;
                        }
                        else {
                            currentSnapProp = null;
                        }
                    }
                    
                    c = c.Parent;
                }
            }
            
            if (currentSnapComponent == null) {
                currentSnapComponent = host.RootComponent;
            }
            
            props = TypeDescriptor.GetProperties(currentSnapComponent);
            
            if (currentSnapProp == null) {
                currentSnapProp = props["SnapToGrid"];
                if (currentSnapProp != null&& currentSnapProp.PropertyType != typeof(bool)) {
                    currentSnapProp = null;
                }
            }
            
            if (gridSizeProp == null) {
                gridSizeProp = props["GridSize"];
                if (gridSizeProp != null && gridSizeProp.PropertyType != typeof(Size)) {
                    gridSizeProp = null;
                }
            }
            
            // Finally, now that we've got the various properties and components, dole out the
            // values.
            //
            snapComponent = currentSnapComponent;
            snapProperty = currentSnapProp;
            if (gridSizeProp != null) {
                snapSize = (Size)gridSizeProp.GetValue(snapComponent);
            }
            else {
                snapSize = Size.Empty;
            }
        }
        
        /// <include file='doc\ControlCommandSet.uex' path='docs/doc[@for="ControlCommandSet.OnKeyCancel"]/*' />
        /// <devdoc>
        ///     Called for the two cancel commands we support.
        /// </devdoc>
        protected override bool OnKeyCancel(object sender) {

            // The base implementation here just checks to see if we are dragging.
            // If we are, then we abort the drag.
            //
            if (!base.OnKeyCancel(sender)) {
                MenuCommand cmd = (MenuCommand)sender;
                bool reverse = (cmd.CommandID.Equals(MenuCommands.KeyReverseCancel));
                RotateParentSelection(reverse);
                return true;
            }
            
            return false;
        }

        /// <include file='doc\ControlCommandSet.uex' path='docs/doc[@for="ControlCommandSet.OnKeySize"]/*' />
        /// <devdoc>
        ///     Called for the various sizing commands we support.
        /// </devdoc>
        protected void OnKeySize(object sender, EventArgs e) {

            // Arrow keys.  Begin a drag if the selection isn't locked.
            //
            ISelectionService selSvc = SelectionService;
            ISelectionUIService uiSvc = SelectionUIService;

            if (uiSvc != null && selSvc != null) {
                //added to remove the selection rectangle: bug(54692)
                //
                uiSvc.Visible = false;
                object comp = selSvc.PrimarySelection;
                if (comp != null && comp is IComponent) {

                    PropertyDescriptor lockedProp = TypeDescriptor.GetProperties(comp)["Locked"];
                    if (lockedProp == null  || (lockedProp.PropertyType == typeof(bool) && ((bool)lockedProp.GetValue(comp))) == false) {

                        SelectionRules rules = SelectionRules.Visible;
                        CommandID cmd = ((MenuCommand)sender).CommandID;
                        bool invertSnap = false;
                        int moveOffsetX = 0;
                        int moveOffsetY = 0;

                        if (cmd.Equals(MenuCommands.KeySizeHeightDecrease)) {
                            moveOffsetY = -1;
                            rules |= SelectionRules.BottomSizeable;
                        }
                        else if (cmd.Equals(MenuCommands.KeySizeHeightIncrease)) {
                            moveOffsetY = 1;
                            rules |= SelectionRules.BottomSizeable;
                        }
                        else if (cmd.Equals(MenuCommands.KeySizeWidthDecrease)) {
                            moveOffsetX = -1;
                            rules |= SelectionRules.RightSizeable;
                        }
                        else if (cmd.Equals(MenuCommands.KeySizeWidthIncrease)) {
                            moveOffsetX = 1;
                            rules |= SelectionRules.RightSizeable;
                        }
                        else if (cmd.Equals(MenuCommands.KeyNudgeHeightDecrease)) {
                            moveOffsetY = -1;
                            invertSnap = true;
                            rules |= SelectionRules.BottomSizeable;
                        }
                        else if (cmd.Equals(MenuCommands.KeyNudgeHeightIncrease)) {
                            moveOffsetY = 1;
                            invertSnap = true;
                            rules |= SelectionRules.BottomSizeable;
                        }
                        else if (cmd.Equals(MenuCommands.KeyNudgeWidthDecrease)) {
                            moveOffsetX = -1;
                            invertSnap = true;
                            rules |= SelectionRules.RightSizeable;
                        }
                        else if (cmd.Equals(MenuCommands.KeyNudgeWidthIncrease)) {
                            moveOffsetX = 1;
                            invertSnap = true;
                            rules |= SelectionRules.RightSizeable;
                        }
                        else {
                            Debug.Fail("Unknown command mapped to OnKeySize: " + cmd.ToString());
                        }

                        if (uiSvc.BeginDrag(rules, 0, 0)) {
                            bool snapOn = false;
                            Size snapSize = Size.Empty;
                            IComponent snapComponent = null;
                            PropertyDescriptor snapProperty = null;
                            
                            // Gets the needed snap information
                            //
                            IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
                            DesignerTransaction trans = null;

                            try {                            
                                if (host != null) {
                                    GetSnapInformation(host, (IComponent)comp, out snapSize, out snapComponent, out snapProperty);
                                
                                    if (selSvc.SelectionCount > 1) {
                                        trans = host.CreateTransaction(SR.GetString(SR.DragDropSizeComponents, selSvc.SelectionCount));
                                    }
                                    else {
                                        trans = host.CreateTransaction(SR.GetString(SR.DragDropSizeComponent, ((IComponent)comp).Site.Name));
                                    }
                                    
                                    if (snapProperty != null) {
                                        snapOn = (bool)snapProperty.GetValue(snapComponent);
                                        
                                        if (invertSnap) {
                                            snapOn = !snapOn;
                                            snapProperty.SetValue(snapComponent, snapOn);
                                        }
                                    }
                                }
                                
                                if (snapOn && !snapSize.IsEmpty) {
                                    moveOffsetX *= snapSize.Width;
                                    moveOffsetY *= snapSize.Height;
                                }
                                
                                
                                // Now move the controls the correct # of pixels.
                                //
                                uiSvc.DragMoved(new Rectangle(0, 0, moveOffsetX, moveOffsetY));
                                uiSvc.EndDrag(false);
                                
                                if (host != null) {
                                    if (invertSnap && snapProperty != null) {
                                        snapOn = !snapOn;
                                        snapProperty.SetValue(snapComponent, snapOn);
                                    }
                                }
                            }
                            finally {
                                if (trans != null) {
                                    trans.Commit();
                                    uiSvc.Visible = true;
                                }
                            }
                        }
                    }
                }
                
                uiSvc.Visible = true;
            }
        }

        /// <include file='doc\ControlCommandSet.uex' path='docs/doc[@for="ControlCommandSet.OnKeySelect"]/*' />
        /// <devdoc>
        ///     Called for selection via the tab key.
        /// </devdoc>
        protected void OnKeySelect(object sender, EventArgs e) {
            MenuCommand cmd = (MenuCommand)sender;
            bool reverse = (cmd.CommandID.Equals(MenuCommands.KeySelectPrevious));
            RotateTabSelection(reverse);
        }

        /// <include file='doc\ControlCommandSet.uex' path='docs/doc[@for="ControlCommandSet.OnMenuLockControls"]/*' />
        /// <devdoc>
        ///     Called when the lock controls menu item is selected.
        /// </devdoc>
        protected void OnMenuLockControls(object sender, EventArgs e) {
            Cursor oldCursor = Cursor.Current;
            try {
                Cursor.Current = Cursors.WaitCursor;

                IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));

                if (host != null) {
                    ComponentCollection components = host.Container.Components;

                    if (components != null && components.Count > 0) {
                        DesignerTransaction trans = null;
                        
                        try {
                            trans = host.CreateTransaction(SR.GetString(SR.CommandSetLockControls, components.Count));
                            MenuCommand cmd = (MenuCommand)sender;
                            bool targetValue = !cmd.Checked;

                            foreach (IComponent comp in components) {
                                PropertyDescriptor prop = GetProperty(comp, "Locked");
                                //check to see the prop is not null & not readonly
                                if (prop == null) {
                                    continue;
                                }
                                if (prop.IsReadOnly) {
                                    continue;
                                }
                                
                                prop.SetValue(comp, targetValue);
                            }
                            
                            cmd.Checked = targetValue;
                        }
                        finally {
                            if (trans != null)
                                trans.Commit();
                        }
                    }
                }
            }
            finally {
                Cursor.Current = oldCursor;
            }
        }

        /// <include file='doc\ControlCommandSet.uex' path='docs/doc[@for="ControlCommandSet.OnMenuNever"]/*' />
        /// <devdoc>
        ///     This should never be called.  It is a placeholder for
        ///     menu items that we temporarially want to disable.
        /// </devdoc>
        private void OnMenuNever(object sender, EventArgs e) {
            Debug.Fail("This menu item should never be invoked.");
        }

        /// <include file='doc\ControlCommandSet.uex' path='docs/doc[@for="ControlCommandSet.OnMenuTabOrder"]/*' />
        /// <devdoc>
        ///     Called to display or destroy the tab order UI.
        /// </devdoc>
        private void OnMenuTabOrder(object sender, EventArgs e) {
            MenuCommand cmd = (MenuCommand)sender;
            if (cmd.Checked) {
                Debug.Assert(tabOrder != null, "Tab order and menu enabling are out of sync");
                if (tabOrder != null) {
                    tabOrder.Dispose();
                    tabOrder = null;
                }
                cmd.Checked = false;
            }
            else {
                //if we're creating a tab order view, set the focus to the base comp, 
                //this prevents things such as the menu editor service getting screwed up.
                //
                ISelectionService selSvc = SelectionService;
                IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
                if (host != null && selSvc != null) {
                    object baseComp = host.RootComponent;
                    if (baseComp != null) {
                        selSvc.SetSelectedComponents(new object[] {baseComp}, SelectionTypes.Replace);
                    }
                }

                tabOrder = new TabOrder((IDesignerHost)GetService(typeof(IDesignerHost)));
                cmd.Checked = true;
            }
        }

        /// <include file='doc\ControlCommandSet.uex' path='docs/doc[@for="ControlCommandSet.OnMenuZOrderSelection"]/*' />
        /// <devdoc>
        ///     Called when the zorder->send to back menu item is selected.
        /// </devdoc>
        private void OnMenuZOrderSelection(object sender, EventArgs e) {
            MenuCommand cmd = (MenuCommand)sender;
            CommandID cmdID = cmd.CommandID;

            Debug.Assert(SelectionService != null, "Need SelectionService for sizing command");

            if (SelectionService == null) {
                return;
            }

            Cursor oldCursor = Cursor.Current;
            try {
                Cursor.Current = Cursors.WaitCursor;


                IComponentChangeService ccs = (IComponentChangeService)GetService(typeof(IComponentChangeService));
                IDesignerHost designerHost = (IDesignerHost)GetService(typeof(IDesignerHost));
                DesignerTransaction trans = null;
                
                try {
                    string batchString;

                    // NOTE: this only works on Control types
                    ICollection sel = SelectionService.GetSelectedComponents();
                    object[] selectedComponents = new object[sel.Count];
                    sel.CopyTo(selectedComponents, 0);

                    if (cmdID == MenuCommands.BringToFront) {
                        batchString = SR.GetString(SR.CommandSetBringToFront, selectedComponents.Length);
                    }
                    else {
                        batchString = SR.GetString(SR.CommandSetSendToBack, selectedComponents.Length);
                    }
                    
                    // sort the components by their current zOrder
                    Array.Sort(selectedComponents, new ControlComparer());

                    trans = designerHost.CreateTransaction(batchString);
                    
                    int len = selectedComponents.Length;
                    for (int i = len-1; i >= 0; i--) {
                        if (selectedComponents[i] is Control) {
                            Control parent = ((Control)selectedComponents[i]).Parent;
                            PropertyDescriptor controlsProp = null;
                            if (ccs != null && parent != null) {
                                try {
                                    controlsProp = TypeDescriptor.GetProperties(parent)["Controls"];
                                    if (controlsProp != null) {
                                        ccs.OnComponentChanging(parent, controlsProp);
                                    }
                                }
                                catch (CheckoutException ex) {
                                    if (ex == CheckoutException.Canceled) {
                                        return;
                                    }
                                    throw ex;
                                }
                            }


                            if (cmdID == MenuCommands.BringToFront) {

                                // we do this backwards to maintain zorder
                                Control otherControl = selectedComponents[len-i-1] as Control;
                                if (otherControl != null) {
                                    otherControl.BringToFront();
                                }
                            }
                            else if (cmdID == MenuCommands.SendToBack) {
                                ((Control)selectedComponents[i]).SendToBack();
                            }

                            if (ccs != null ) {
                                if (controlsProp != null && parent != null) {
                                    ccs.OnComponentChanged(parent, controlsProp, null, null);
                                }
                            }
                        }
                    }
                }
                finally {
                    // now we need to regenerate so the ordering is right.
                    if (trans != null)
                        trans.Commit();
                }
            }
            finally {
                Cursor.Current = oldCursor;
            }
        }

        /// <include file='doc\ControlCommandSet.uex' path='docs/doc[@for="ControlCommandSet.OnStatusAnyControls"]/*' />
        /// <devdoc>
        ///     Determines the status of a menu command.  Commands with this event
        ///     handler are enabled when there is one or more controls on the design
        ///     surface.
        /// </devdoc>
        protected void OnStatusAnyControls(object sender, EventArgs e) {
            MenuCommand cmd = (MenuCommand)sender;
            bool enabled = false;
            if (baseControl != null && baseControl.Controls.Count > 0) {
                enabled = true;
            }
            cmd.Enabled = enabled;
        }

        /// <include file='doc\CommandSet.uex' path='docs/doc[@for="CommandSet.OnStatusAnySelection"]/*' />
        /// <devdoc>
        ///     Determines the status of a menu command.  Commands with this event
        ///     handler are enabled when one or more objects are selected.
        /// </devdoc>
        protected void OnStatusControlsOnlySelection(object sender, EventArgs e) {
            MenuCommand cmd = (MenuCommand)sender;
            cmd.Enabled = (selCount > 0) && controlsOnlySelection;
        }

        protected void OnStatusLockControls(object sender, EventArgs e) {
            MenuCommand cmd = (MenuCommand)sender;
            
            if (baseControl == null) {
                cmd.Enabled = false;
                return;
            }

            cmd.Enabled = controlsOnlySelection;
            cmd.Checked = false;
            PropertyDescriptor lockedProp = null;

            //Get the locked property of the base control first...
            //
            lockedProp = TypeDescriptor.GetProperties(baseControl)["Locked"];
            if (lockedProp != null && ((bool)lockedProp.GetValue(baseControl)) == true) {
                cmd.Checked = true;
                return;
            }

            IDesignerHost host = (IDesignerHost)site.GetService(typeof(IDesignerHost));

            if (host == null) {
                return;
            }

            ComponentDesigner baseDesigner = host.GetDesigner(baseControl) as ComponentDesigner;

            foreach (object component in baseDesigner.AssociatedComponents) {
                lockedProp = TypeDescriptor.GetProperties(component)["Locked"];
                if (lockedProp != null && ((bool)lockedProp.GetValue(component)) == true) {
                    cmd.Checked = true;
                    return;
                }
            }
        }
        
        /// <include file='doc\ControlCommandSet.uex' path='docs/doc[@for="ControlCommandSet.OnStatusMultiSelect"]/*' />
        /// <devdoc>
        ///     Determines the status of a menu command.  Commands with this event
        ///     handler are enabled when more than one object is selected.
        /// </devdoc>
        protected void OnStatusMultiSelect(object sender, EventArgs e) {
            MenuCommand cmd = (MenuCommand)sender;
            cmd.Enabled = controlsOnlySelection && selCount > 1;
        }

        /// <include file='doc\ControlCommandSet.uex' path='docs/doc[@for="ControlCommandSet.OnStatusMultiSelectPrimary"]/*' />
        /// <devdoc>
        ///     Determines the status of a menu command.  Commands with this event
        ///     handler are enabled when more than one object is selected and one
        ///     of them is marked as the primary selection.
        /// </devdoc>
        protected void OnStatusMultiSelectPrimary(object sender, EventArgs e) {
            MenuCommand cmd = (MenuCommand)sender;
            cmd.Enabled = controlsOnlySelection && selCount > 1 && primarySelection != null;
        }

        /// <include file='doc\ControlCommandSet.uex' path='docs/doc[@for="ControlCommandSet.OnStatusShowGrid"]/*' />
        /// <devdoc>
        ///     Determines the status of a menu command.  This event handler is
        ///     dedicated to the ShowGrid item.
        /// </devdoc>
        protected void OnStatusShowGrid(object sender, EventArgs e) {

            if (site != null) {

                IDesignerHost host = (IDesignerHost)site.GetService(typeof(IDesignerHost));
                Debug.Assert(!CompModSwitches.CommonDesignerServices.Enabled || host != null, "IDesignerHost not found");

                if (host != null) {

                    IComponent baseComponent = host.RootComponent;
                    if (baseComponent != null && baseComponent is Control) {
                        PropertyDescriptor prop = GetProperty(baseComponent, "DrawGrid");
                        if (prop != null) {
                            bool drawGrid = (bool)prop.GetValue(baseComponent);
                            MenuCommand cmd = (MenuCommand)sender;
                            cmd.Enabled = true;
                            cmd.Checked = drawGrid;
                        }
                    }
                }
            }


        }

        /// <include file='doc\ControlCommandSet.uex' path='docs/doc[@for="ControlCommandSet.OnStatusSnapToGrid"]/*' />
        /// <devdoc>
        ///     Determines the status of a menu command.  This event handler is
        ///     dedicated to the SnapToGrid item.
        /// </devdoc>
        protected void OnStatusSnapToGrid(object sender, EventArgs e) {
            if (site != null) {

                IDesignerHost host = (IDesignerHost)site.GetService(typeof(IDesignerHost));
                Debug.Assert(!CompModSwitches.CommonDesignerServices.Enabled || host != null, "IDesignerHost not found");

                if (host != null) {
                    IComponent baseComponent = host.RootComponent;
                    if (baseComponent != null && baseComponent is Control) {
                        PropertyDescriptor prop = GetProperty(baseComponent, "SnapToGrid");
                        if (prop != null) {
                            bool snapToGrid = (bool)prop.GetValue(baseComponent);
                            MenuCommand cmd = (MenuCommand)sender;
                            cmd.Enabled = controlsOnlySelection;
                            cmd.Checked = snapToGrid;
                        }
                    }
                }
            }

        }

        /// <include file='doc\ControlCommandSet.uex' path='docs/doc[@for="ControlCommandSet.OnStatusZOrder"]/*' />
        /// <devdoc>
        ///     Determines the status of a menu command.  Commands with this event
        ///     handler are enabled for zordering.  The rules are:
        ///
        ///      1) More than one component on the form
        ///      2) At least one Control-derived component must be selected
        ///      3) The form must not be selected
        /// </devdoc>
        private void OnStatusZOrder(object sender, EventArgs e) {
            MenuCommand cmd = (MenuCommand)sender;
            IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
            if (host != null) {
                ComponentCollection comps = host.Container.Components;
                object   baseComp = host.RootComponent;

                // The form by itself is one component, so this means
                // we need more than two.
                bool enable = (comps != null && comps.Count > 2 && controlsOnlySelection);

                if (enable) {
                    Debug.Assert(SelectionService != null, "Need SelectionService for sizing command");

                    if (SelectionService == null) {
                        return;
                    }

                    // There must also be a control in the mix, and not the base component, and
                    // it cannot be privately inherited.
                    //
                    ICollection selectedComponents = SelectionService.GetSelectedComponents();

                    enable = false;
                    foreach(object obj in selectedComponents) {
                        if (obj is Control &&
                            !TypeDescriptor.GetAttributes(obj)[typeof(InheritanceAttribute)].Equals(InheritanceAttribute.InheritedReadOnly)) {
                            enable = true;
                        }

                        // if the form is in there we're always false.
                        if (obj == baseComp) {
                            enable = false;
                            break;
                        }
                    }
                }


                cmd.Enabled = enable;
                return;
            }
            cmd.Enabled = false;
        }

        /// <include file='doc\ControlCommandSet.uex' path='docs/doc[@for="ControlCommandSet.OnUpdateCommandStatus"]/*' />
        /// <devdoc>
        ///      This is called when the selection has changed.  Anyone using CommandSetItems
        ///      that need to update their status based on selection changes should override
        ///      this and update their own commands at this time.  The base implementaion
        ///      runs through all base commands and calls UpdateStatus on them.
        /// </devdoc>
        protected override void OnUpdateCommandStatus() {
            // Now whip through all of the commands and ask them to update.
            //
            for (int i = 0; i < commandSet.Length; i++) {
                commandSet[i].UpdateStatus();
            }
            base.OnUpdateCommandStatus();
        }

        /// <include file='doc\ControlCommandSet.uex' path='docs/doc[@for="ControlCommandSet.RotateParentSelection"]/*' />
        /// <devdoc>
        ///     Rotates the selection to the next parent element.  If backwards is
        ///     set, this will rotate to the first child element.
        /// </devdoc>
        private void RotateParentSelection(bool backwards) {
            Control current;
            Control next;
            ISelectionService selSvc = SelectionService;
            IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));

            if (selSvc == null || host == null || !(host.RootComponent is Control)) {
                return;
            }

            IContainer container = host.Container;

            object component = selSvc.PrimarySelection;
            if (component is Control) {
                current = (Control)component;
            }
            else {
                current = (Control)host.RootComponent;
            }

            if (backwards) {
                if (current.Controls.Count > 0) {
                    next = current.Controls[0];
                }
                else {
                    next = current;
                }
            }
            else {
                next = current.Parent;
                if (next == null || next.Site == null || next.Site.Container != container) {
                    next = current;
                }
            }

            selSvc.SetSelectedComponents(new object[] {next}, SelectionTypes.Replace);
        }
        
        /// <include file='doc\ControlCommandSet.uex' path='docs/doc[@for="ControlCommandSet.RotateTabSelection"]/*' />
        /// <devdoc>
        ///     Rotates the selection to the element next in the tab index.  If backwards
        ///     is set, this will rotate to the previous tab index.
        /// </devdoc>
        private void RotateTabSelection(bool backwards) {
            Control ctl;
            Control baseCtl;
            object targetSelection = null;
            object currentSelection;

            ISelectionService selSvc = SelectionService;
            IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));

            if (selSvc == null || host == null || !(host.RootComponent is Control)) {
                return;
            }

            IContainer container = host.Container;
            baseCtl = (Control)host.RootComponent;
            
            // We must handle two cases of logic here.  We are responsible for handling
            // selection within ourself, and also for components on the tray.  For our
            // own tabbing around, we want to go by tab-order.  When we get to the end
            // of the form, however, we go by selection order into the tray.  And, 
            // when we're at the end of the tray we start back at the form.  We must
            // reverse this logic to go backwards.

            currentSelection = selSvc.PrimarySelection;
            
            if (currentSelection is Control) {
            
                // Our current selection is a control.  Select the next control in 
                // the z-order.
                //
                ctl = (Control)currentSelection;
            
                while (null != (ctl = baseCtl.GetNextControl(ctl, !backwards))) {
                    if (ctl.Site != null && ctl.Site.Container == container) {
                        break;
                    }
                }
                
                targetSelection = ctl;
            }

            if (targetSelection == null) {
                ComponentTray tray = (ComponentTray)GetService(typeof(ComponentTray));
                if (tray != null) {
                    targetSelection = tray.GetNextComponent((IComponent)currentSelection, !backwards);
                }
                
                if (targetSelection == null) {
                    targetSelection = baseCtl;
                }
            }

            selSvc.SetSelectedComponents(new object[] {targetSelection}, SelectionTypes.Replace);
        }
        
        /// <include file='doc\ControlCommandSet.uex' path='docs/doc[@for="ControlCommandSet.ControlComparer"]/*' />
        /// <devdoc>
        ///    <para>Compares two controls for equality.</para>
        /// </devdoc>
        private class ControlComparer : IComparer {

            /// <include file='doc\ControlCommandSet.uex' path='docs/doc[@for="ControlCommandSet.ControlComparer.Compare"]/*' />
            /// <devdoc>
            ///    <para>Compares two controls for equality.</para>
            /// </devdoc>
            public int Compare(object x, object y) {

                // we want to sort items here based on their z-order
                //

                // if they have the same parent,
                // return the comparison based on z-order
                //
                // otherwise based on parent handles so parent groupings
                // will be together
                //
                // otherwise just put non-controls ahead of controls.
                if (x == y) {
                    return 0;
                }


                if (x is Control && y is Control) {
                    Control cX = (Control)x;
                    Control cY = (Control)y;
                    if (cX.Parent == cY.Parent) {
                        Control parent = cX.Parent;
                        if (parent == null) {
                            return 0;
                        }
                        else if (parent.Controls.GetChildIndex(cX) > parent.Controls.GetChildIndex(cY)) {
                            return -1;
                        }
                        else {
                            return 1;
                        }
                    }
                    else if (cX.Parent == null || cX.Contains(cY)) {
                        return 1;
                    }
                    else if (cY.Parent == null || cY.Contains(cX)) {
                        return -1;
                    }
                    else {
                        return (int)cX.Parent.Handle - (int)cY.Parent.Handle;
                    }
                }
                else if (y is Control) {
                    return -1;
                }
                else if (x is Control) {
                    return 1;
                }
                else {
                    return 0;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\datamemberfieldconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataMemberFieldConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms.Design {

    using System;
    using System.Globalization;
    using System.ComponentModel;
    
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class DataMemberFieldConverter : TypeConverter {
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) {
            if (sourceType == typeof(string))
                return true;
            return base.CanConvertFrom(context, sourceType);
        }

        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) {
            if (value != null && value.Equals(System.Design.SR.GetString(System.Design.SR.None)))
                return String.Empty;
            else
                return value;
        }

        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
            if (destinationType == typeof(string) && (value == null || value.Equals(String.Empty))) 
                return System.Design.SR.GetString(System.Design.SR.None);

            return base.ConvertTo(context, culture, value, destinationType);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\datagriddesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataGridDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms.Design {
    using System.Design;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.Collections;   
    using System.Windows.Forms;    
    using System.Data;
    using System.ComponentModel.Design;
    using System.Drawing;
    using Microsoft.Win32;
    using System.Windows.Forms.ComponentModel;


    /// <include file='doc\DataGridDesigner.uex' path='docs/doc[@for="DataGridDesigner"]/*' />
    /// <devdoc>
    ///    <para>Provides a base designer for data grids.</para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class DataGridDesigner : System.Windows.Forms.Design.ControlDesigner {
        /// <include file='doc\DataGridDesigner.uex' path='docs/doc[@for="DataGridDesigner.designerVerbs"]/*' />
        /// <devdoc>
        ///    <para>Gets the design-time verbs suppoted by the component associated with the 
        ///       designer.</para>
        /// </devdoc>
        protected DesignerVerbCollection designerVerbs;
        private IComponentChangeService changeNotificationService = null;

        /// <include file='doc\DataGridDesigner.uex' path='docs/doc[@for="DataGridDesigner.DataGridDesigner"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Windows.Forms.Design.DataGridDesigner'/> class.</para>
        /// </devdoc>
        public DataGridDesigner() {
            designerVerbs = new DesignerVerbCollection();
            designerVerbs.Add(new DesignerVerb(SR.GetString(SR.DataGridAutoFormatString), new EventHandler(this.OnAutoFormat)));
        }

        public override void Initialize(IComponent component) {
            base.Initialize(component);

            IDesignerHost dh = (IDesignerHost) this.GetService(typeof(IDesignerHost));
            if (dh != null) {
                changeNotificationService = (IComponentChangeService) dh.GetService(typeof(IComponentChangeService));
                if (changeNotificationService != null)
                    changeNotificationService.ComponentRemoved += new ComponentEventHandler(DataSource_ComponentRemoved);
            }
        }

        private void DataSource_ComponentRemoved(object sender, ComponentEventArgs e) {
            DataGrid d = (DataGrid) this.Component;
            if (e.Component == d.DataSource)
                d.DataSource = null;
        }

        protected override void Dispose(bool disposing) {
            if (disposing) {
                if (changeNotificationService != null)
                    changeNotificationService.ComponentRemoved -= new ComponentEventHandler(DataSource_ComponentRemoved);
            }
            base.Dispose(disposing);
        }

        /// <include file='doc\DataGridDesigner.uex' path='docs/doc[@for="DataGridDesigner.Verbs"]/*' />
        /// <devdoc>
        ///    <para>Gets the design-time verbs supported by the component associated with the 
        ///       designer.</para>
        /// </devdoc>
        public override DesignerVerbCollection Verbs {
            get {
                return designerVerbs;
            }
        }

        /// <include file='doc\DataGridDesigner.uex' path='docs/doc[@for="DataGridDesigner.OnAutoFormat"]/*' />
        /// <devdoc>
        ///    <para>Raises the AutoFormat event.</para>
        /// </devdoc>
        public void OnAutoFormat(object sender, EventArgs e) {
            object o = Component;
            Debug.Assert(o is DataGrid, "DataGrid type expected.");
            DataGrid dgrid = (DataGrid)o;            
            DataGridAutoFormatDialog dialog = new DataGridAutoFormatDialog(dgrid);
            if (dialog.ShowDialog() == DialogResult.OK) {
                DataRow selectedData = dialog.SelectedData;
                if (selectedData != null) {
                    PropertyDescriptorCollection gridProperties = TypeDescriptor.GetProperties(typeof(DataGrid));
                    foreach (DataColumn c in selectedData.Table.Columns) {
                        object value = selectedData[c];
                        PropertyDescriptor prop = gridProperties[c.ColumnName];
                        if (prop != null) {
                            if (Convert.IsDBNull(value)  || value.ToString().Length == 0) {
                                prop.ResetValue(dgrid);
                            }
                            else {
                                try {
                                    TypeConverter converter = prop.Converter;
                                    object convertedValue = converter.ConvertFromString(value.ToString());
                                    prop.SetValue(dgrid, convertedValue);
                                }
                                catch (Exception) {
                                    // Ignore errors... the only one we really care about is Font names.
                                    // The TypeConverter will throw if the font isn't on the user's machine
                                }
                            }
                        }
                    }
                }
                // now invalidate the grid
                dgrid.Invalidate();
            }
        }

        /// <include file='doc\DataGridDesigner.uex' path='docs/doc[@for="DataGridDesigner.OnPopulateGrid"]/*' />
        /// <devdoc>
        ///    <para>Raises the PopulateGrid event.</para>
        /// </devdoc>
        public void OnPopulateGrid(object sender, EventArgs evevent) {
            object o = Component;
            Debug.Assert(o is DataGrid, "DataGrid type expected.");
            DataGrid dgrid = (DataGrid)o;
            dgrid.Cursor = Cursors.WaitCursor;
            try {
                if (dgrid.DataSource == null) {
                    throw new NullReferenceException(SR.GetString(SR.DataGridPopulateError));
                }

                dgrid.SubObjectsSiteChange(false);
                // dgrid.PopulateColumns();
                dgrid.SubObjectsSiteChange(true); }
            finally {
                dgrid.Cursor = Cursors.Default;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\datagridtablestylemappingnameeditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataGridTableStyleMappingNameEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms.Design {

    using System.Design;
    using System;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Drawing;
    using System.Drawing.Design;
    
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class DataGridTableStyleMappingNameEditor : UITypeEditor {

        private DesignBindingPicker designBindingPicker;
        
        public override object EditValue(ITypeDescriptorContext context,  IServiceProvider  provider, object value) {
            if (provider != null) {
                IWindowsFormsEditorService edSvc = (IWindowsFormsEditorService)provider.GetService(typeof(IWindowsFormsEditorService));

                if (edSvc != null && context.Instance != null) {
                    if (designBindingPicker == null) {
                        designBindingPicker = new DesignBindingPicker(context, /*multiple DataSources*/ false, /*select lists*/ true);
                    }
                    object instance = context.Instance;
                    DataGridTableStyle tableStyle = (DataGridTableStyle) context.Instance;
                    if (tableStyle.DataGrid == null)
                        return value;
                    PropertyDescriptor dataSourceProperty = TypeDescriptor.GetProperties(tableStyle.DataGrid)["DataSource"];
                    if (dataSourceProperty != null) {
                        object dataSource = dataSourceProperty.GetValue(tableStyle.DataGrid);
                        if (dataSource != null) {
                            designBindingPicker.Start(context, edSvc, dataSource, new DesignBinding(dataSource, (string)value));
                            edSvc.DropDownControl(designBindingPicker);
                            if (designBindingPicker.SelectedItem != null) {
                                if (String.Empty.Equals(designBindingPicker.SelectedItem.DataMember) || designBindingPicker.SelectedItem.DataMember == null)
                                    value = "";
                                else
                                    value = designBindingPicker.SelectedItem.DataField;
                            }
                            designBindingPicker.End();
                        } else {
                            // ASURT 61510: do not throw the exception ( the exception was added in bug 37841 )
                            designBindingPicker.Start(context, edSvc, dataSource, new DesignBinding(null, (string) value));
                            edSvc.DropDownControl(designBindingPicker);
                            designBindingPicker.End();
                        }
                    }
                }
            }

            return value;
        }

        public override UITypeEditorEditStyle GetEditStyle(ITypeDescriptorContext context) {
            return UITypeEditorEditStyle.DropDown;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\datagridautoformatdialog.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataGridAutoFormatDialog.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms.Design {

    using System;
    using System.Design;
    using System.Diagnostics;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Data;
    using System.Windows.Forms;
    using System.Drawing;
    using System.Xml;
    using System.IO;
    using System.Globalization;

    /// <include file='doc\DataGridAutoFormatDialog.uex' path='docs/doc[@for="DataGridAutoFormatDialog"]/*' />
    /// <internalonly/>
    /// <devdoc>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class DataGridAutoFormatDialog : Form {
    
        private DataGrid dgrid;

        private DataTable schemeTable;
        // private PictureBox schemePicture;
        DataSet dataSet = new DataSet();
        private AutoFormatDataGrid dataGrid;
        private DataGridTableStyle tableStyle;
        private Button button2;
        private Button button1;
        private ListBox schemeName;
        private Label formats;
        private Label preview;
        private bool IMBusy = false;

        private int selectedIndex = -1;

        public DataGridAutoFormatDialog(DataGrid dgrid) {
            this.dgrid = dgrid;

            this.ShowInTaskbar = false;
            dataSet.Locale = CultureInfo.InvariantCulture;
            dataSet.ReadXmlSchema(new XmlTextReader(new StringReader(scheme)));
            dataSet.ReadXml( new StringReader(data), XmlReadMode.IgnoreSchema);
            schemeTable = dataSet.Tables["Scheme"];
            
            IMBusy = true;

            InitializeComponent();
            
            AddDataToDataGrid();
            AddStyleSheetInformationToDataGrid();

            if (dgrid.Site != null) {
                IUIService uiService = (IUIService)dgrid.Site.GetService(typeof(IUIService));
                if (uiService != null) {
                    Font f = (Font)uiService.Styles["DialogFont"];
                    if (f != null) {
                        this.Font = f;
                    }
                }
            }

            this.Focus();
            IMBusy = false;
        }

        private void AddStyleSheetInformationToDataGrid() {
            System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(DataGridAutoFormatDialog));
            DataGridTableStyle dGTStyle = new DataGridTableStyle();
            dGTStyle.MappingName = "Table1";
            DataGridColumnStyle col1 = new DataGridTextBoxColumn();
            col1.MappingName = "First Name";
            col1.HeaderText = resources.GetString("table.FirstColumn");

            DataGridColumnStyle col2 = new DataGridTextBoxColumn();
            col2.MappingName = "Last Name";
            col2.HeaderText = resources.GetString("table.FirstColumn");

            dGTStyle.GridColumnStyles.Add(col1);
            dGTStyle.GridColumnStyles.Add(col2);

            // ASURT 92086: I have to change the names of the schemes to stuff from resources,
            DataRowCollection drc = dataSet.Tables["Scheme"].Rows;
            DataRow dr;
            dr = drc[0];
            dr["SchemeName"] = resources.GetString("schemeName.Default");
            dr = drc[1];
            dr["SchemeName"] = resources.GetString("schemeName.Professional1");
            dr = drc[2];
            dr["SchemeName"] = resources.GetString("schemeName.Professional2");
            dr = drc[3];
            dr["SchemeName"] = resources.GetString("schemeName.Professional3");
            dr = drc[4];
            dr["SchemeName"] = resources.GetString("schemeName.Professional4");
            dr = drc[5];
            dr["SchemeName"] = resources.GetString("schemeName.Classic");
            dr = drc[6];
            dr["SchemeName"] = resources.GetString("schemeName.Simple");
            dr = drc[7];
            dr["SchemeName"] = resources.GetString("schemeName.Colorful1");
            dr = drc[8];
            dr["SchemeName"] = resources.GetString("schemeName.Colorful2");
            dr = drc[9];
            dr["SchemeName"] = resources.GetString("schemeName.Colorful3");
            dr = drc[10];
            dr["SchemeName"] = resources.GetString("schemeName.Colorful4");
            dr = drc[11];
            dr["SchemeName"] = resources.GetString("schemeName.256Color1");
            dr = drc[12];
            dr["SchemeName"] = resources.GetString("schemeName.256Color2");

            this.dataGrid.TableStyles.Add(dGTStyle);
            this.tableStyle = dGTStyle;
        }

        private void AddDataToDataGrid() {
            DataTable dTable = new DataTable("Table1");
            dTable.Columns.Add(new DataColumn("First Name"));
            dTable.Columns.Add(new DataColumn("Last Name"));

            DataRow dRow = dTable.NewRow();
            dRow["First Name"] = "Robert";
            dRow["Last Name"] = "Brown";
            dTable.Rows.Add(dRow);

            dRow = dTable.NewRow();
            dRow["First Name"] = "Nate";
            dRow["Last Name"] = "Sun";
            dTable.Rows.Add(dRow);

            dRow = dTable.NewRow();
            dRow["First Name"] = "Carole";
            dRow["Last Name"] = "Poland";
            dTable.Rows.Add(dRow);

            this.dataGrid.SetDataBinding(dTable, "");
        }

        private void AutoFormat_HelpRequested(object sender, HelpEventArgs e) {
            if (dgrid == null || dgrid.Site == null)
                return;
            IDesignerHost host = dgrid.Site.GetService(typeof(IDesignerHost)) as IDesignerHost;
            if (host == null) {
                Debug.Fail("Unable to get IDesignerHost.");
                return;
            }

            IHelpService helpService = host.GetService(typeof(IHelpService)) as IHelpService;
            if (helpService != null) {
                helpService.ShowHelpFromKeyword("vs.DataGridAutoFormatDialog");
            }
            else {
                Debug.Fail("Unable to get IHelpService.");
            }
        }

        private void Button1_Clicked(object sender, EventArgs e) {
            selectedIndex = schemeName.SelectedIndex;
        }

        private void InitializeComponent() {
            System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(DataGridAutoFormatDialog));
            formats = new System.Windows.Forms.Label();
            schemeName = new System.Windows.Forms.ListBox();
            dataGrid = new AutoFormatDataGrid();
            preview = new System.Windows.Forms.Label();
            button1 = new System.Windows.Forms.Button();
            button2 = new System.Windows.Forms.Button();
            ((System.ComponentModel.ISupportInitialize)(this.dataGrid)).BeginInit();
            dataGrid.SuspendLayout();
            SuspendLayout();
            // 
            // formats
            // 
            formats.AccessibleDescription = ((string)(resources.GetObject("formats.AccessibleDescription")));
            formats.AccessibleName = ((string)(resources.GetObject("formats.AccessibleName")));
            formats.Anchor = ((System.Windows.Forms.AnchorStyles)(resources.GetObject("formats.Anchor")));
            formats.AutoSize = ((bool)(resources.GetObject("formats.AutoSize")));
            formats.Cursor = ((System.Windows.Forms.Cursor)(resources.GetObject("formats.Cursor")));
            formats.Dock = ((System.Windows.Forms.DockStyle)(resources.GetObject("formats.Dock")));
            formats.Enabled = ((bool)(resources.GetObject("formats.Enabled")));
            formats.Font = ((System.Drawing.Font)(resources.GetObject("formats.Font")));
            formats.Image = ((System.Drawing.Image)(resources.GetObject("formats.Image")));
            formats.ImageAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("formats.ImageAlign")));
            formats.ImageIndex = ((int)(resources.GetObject("formats.ImageIndex")));
            formats.ImeMode = ((System.Windows.Forms.ImeMode)(resources.GetObject("formats.ImeMode")));
            formats.Location = ((System.Drawing.Point)(resources.GetObject("formats.Location")));
            formats.Name = "formats";
            formats.RightToLeft = ((System.Windows.Forms.RightToLeft)(resources.GetObject("formats.RightToLeft")));
            formats.Size = ((System.Drawing.Size)(resources.GetObject("formats.Size")));
            formats.TabIndex = ((int)(resources.GetObject("formats.TabIndex")));
            formats.Text = resources.GetString("formats.Text");
            formats.TextAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("formats.TextAlign")));
            formats.Visible = ((bool)(resources.GetObject("formats.Visible")));
            // 
            // schemeName
            // 
            schemeName.DataSource = schemeTable;
            schemeName.DisplayMember = "SchemeName";
            schemeName.SelectedIndexChanged += new EventHandler(this.SchemeName_SelectionChanged);
            schemeName.AccessibleDescription = ((string)(resources.GetObject("schemeName.AccessibleDescription")));
            schemeName.AccessibleName = ((string)(resources.GetObject("schemeName.AccessibleName")));
            schemeName.Anchor = ((System.Windows.Forms.AnchorStyles)(resources.GetObject("schemeName.Anchor")));
            schemeName.BackgroundImage = ((System.Drawing.Image)(resources.GetObject("schemeName.BackgroundImage")));
            schemeName.ColumnWidth = ((int)(resources.GetObject("schemeName.ColumnWidth")));
            schemeName.Cursor = ((System.Windows.Forms.Cursor)(resources.GetObject("schemeName.Cursor")));
            schemeName.Dock = ((System.Windows.Forms.DockStyle)(resources.GetObject("schemeName.Dock")));
            schemeName.Enabled = ((bool)(resources.GetObject("schemeName.Enabled")));
            schemeName.Font = ((System.Drawing.Font)(resources.GetObject("schemeName.Font")));
            schemeName.HorizontalExtent = ((int)(resources.GetObject("schemeName.HorizontalExtent")));
            schemeName.HorizontalScrollbar = ((bool)(resources.GetObject("schemeName.HorizontalScrollbar")));
            schemeName.ImeMode = ((System.Windows.Forms.ImeMode)(resources.GetObject("schemeName.ImeMode")));
            schemeName.IntegralHeight = ((bool)(resources.GetObject("schemeName.IntegralHeight")));
            schemeName.ItemHeight = ((int)(resources.GetObject("schemeName.ItemHeight")));
            schemeName.Location = ((System.Drawing.Point)(resources.GetObject("schemeName.Location")));
            schemeName.Name = "schemeName";
            schemeName.RightToLeft = ((System.Windows.Forms.RightToLeft)(resources.GetObject("schemeName.RightToLeft")));
            schemeName.ScrollAlwaysVisible = ((bool)(resources.GetObject("schemeName.ScrollAlwaysVisible")));
            schemeName.Size = ((System.Drawing.Size)(resources.GetObject("schemeName.Size")));
            schemeName.TabIndex = ((int)(resources.GetObject("schemeName.TabIndex")));
            schemeName.Visible = ((bool)(resources.GetObject("schemeName.Visible")));
            // 
            // dataGrid
            // 
            dataGrid.AccessibleDescription = ((string)(resources.GetObject("dataGrid.AccessibleDescription")));
            dataGrid.AccessibleName = ((string)(resources.GetObject("dataGrid.AccessibleName")));
            dataGrid.Anchor = ((System.Windows.Forms.AnchorStyles)(resources.GetObject("dataGrid.Anchor")));
            dataGrid.BackgroundImage = ((System.Drawing.Image)(resources.GetObject("dataGrid.BackgroundImage")));
            dataGrid.CaptionFont = ((System.Drawing.Font)(resources.GetObject("dataGrid.CaptionFont")));
            dataGrid.CaptionText = resources.GetString("dataGrid.CaptionText");
            dataGrid.Cursor = ((System.Windows.Forms.Cursor)(resources.GetObject("dataGrid.Cursor")));
            dataGrid.DataMember = "";
            dataGrid.Dock = ((System.Windows.Forms.DockStyle)(resources.GetObject("dataGrid.Dock")));
            dataGrid.Enabled = ((bool)(resources.GetObject("dataGrid.Enabled")));
            dataGrid.Font = ((System.Drawing.Font)(resources.GetObject("dataGrid.Font")));
            dataGrid.ImeMode = ((System.Windows.Forms.ImeMode)(resources.GetObject("dataGrid.ImeMode")));
            dataGrid.Location = ((System.Drawing.Point)(resources.GetObject("dataGrid.Location")));
            dataGrid.Name = "dataGrid";
            dataGrid.RightToLeft = ((System.Windows.Forms.RightToLeft)(resources.GetObject("dataGrid.RightToLeft")));
            dataGrid.Size = ((System.Drawing.Size)(resources.GetObject("dataGrid.Size")));
            dataGrid.TabIndex = ((int)(resources.GetObject("dataGrid.TabIndex")));
            dataGrid.Visible = ((bool)(resources.GetObject("dataGrid.Visible")));
            // 
            // preview
            // 
            preview.AccessibleDescription = ((string)(resources.GetObject("preview.AccessibleDescription")));
            preview.AccessibleName = ((string)(resources.GetObject("preview.AccessibleName")));
            preview.Anchor = ((System.Windows.Forms.AnchorStyles)(resources.GetObject("preview.Anchor")));
            preview.AutoSize = ((bool)(resources.GetObject("preview.AutoSize")));
            preview.Cursor = ((System.Windows.Forms.Cursor)(resources.GetObject("preview.Cursor")));
            preview.Dock = ((System.Windows.Forms.DockStyle)(resources.GetObject("preview.Dock")));
            preview.Enabled = ((bool)(resources.GetObject("preview.Enabled")));
            preview.Font = ((System.Drawing.Font)(resources.GetObject("preview.Font")));
            preview.Image = ((System.Drawing.Image)(resources.GetObject("preview.Image")));
            preview.ImageAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("preview.ImageAlign")));
            preview.ImageIndex = ((int)(resources.GetObject("preview.ImageIndex")));
            preview.ImeMode = ((System.Windows.Forms.ImeMode)(resources.GetObject("preview.ImeMode")));
            preview.Location = ((System.Drawing.Point)(resources.GetObject("preview.Location")));
            preview.Name = "preview";
            preview.RightToLeft = ((System.Windows.Forms.RightToLeft)(resources.GetObject("preview.RightToLeft")));
            preview.Size = ((System.Drawing.Size)(resources.GetObject("preview.Size")));
            preview.TabIndex = ((int)(resources.GetObject("preview.TabIndex")));
            preview.Text = resources.GetString("preview.Text");
            preview.TextAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("preview.TextAlign")));
            preview.Visible = ((bool)(resources.GetObject("preview.Visible")));
            // 
            // button1
            // 
            button1.DialogResult = DialogResult.OK;
            button1.Click += new EventHandler(Button1_Clicked);
            button1.AccessibleDescription = ((string)(resources.GetObject("button1.AccessibleDescription")));
            button1.AccessibleName = ((string)(resources.GetObject("button1.AccessibleName")));
            button1.Anchor = ((System.Windows.Forms.AnchorStyles)(resources.GetObject("button1.Anchor")));
            button1.BackgroundImage = ((System.Drawing.Image)(resources.GetObject("button1.BackgroundImage")));
            button1.Cursor = ((System.Windows.Forms.Cursor)(resources.GetObject("button1.Cursor")));
            button1.Dock = ((System.Windows.Forms.DockStyle)(resources.GetObject("button1.Dock")));
            button1.Enabled = ((bool)(resources.GetObject("button1.Enabled")));
            button1.FlatStyle = ((System.Windows.Forms.FlatStyle)(resources.GetObject("button1.FlatStyle")));
            button1.Font = ((System.Drawing.Font)(resources.GetObject("button1.Font")));
            button1.Image = ((System.Drawing.Image)(resources.GetObject("button1.Image")));
            button1.ImageAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("button1.ImageAlign")));
            button1.ImageIndex = ((int)(resources.GetObject("button1.ImageIndex")));
            button1.ImeMode = ((System.Windows.Forms.ImeMode)(resources.GetObject("button1.ImeMode")));
            button1.Location = ((System.Drawing.Point)(resources.GetObject("button1.Location")));
            button1.Name = "button1";
            button1.RightToLeft = ((System.Windows.Forms.RightToLeft)(resources.GetObject("button1.RightToLeft")));
            button1.Size = ((System.Drawing.Size)(resources.GetObject("button1.Size")));
            button1.TabIndex = ((int)(resources.GetObject("button1.TabIndex")));
            button1.Text = resources.GetString("button1.Text");
            button1.TextAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("button1.TextAlign")));
            button1.Visible = ((bool)(resources.GetObject("button1.Visible")));
            // 
            // button2
            // 
            button2.DialogResult = DialogResult.Cancel;
            button2.AccessibleDescription = ((string)(resources.GetObject("button2.AccessibleDescription")));
            button2.AccessibleName = ((string)(resources.GetObject("button2.AccessibleName")));
            button2.Anchor = ((System.Windows.Forms.AnchorStyles)(resources.GetObject("button2.Anchor")));
            button2.BackgroundImage = ((System.Drawing.Image)(resources.GetObject("button2.BackgroundImage")));
            button2.Cursor = ((System.Windows.Forms.Cursor)(resources.GetObject("button2.Cursor")));
            button2.Dock = ((System.Windows.Forms.DockStyle)(resources.GetObject("button2.Dock")));
            button2.Enabled = ((bool)(resources.GetObject("button2.Enabled")));
            button2.FlatStyle = ((System.Windows.Forms.FlatStyle)(resources.GetObject("button2.FlatStyle")));
            button2.Font = ((System.Drawing.Font)(resources.GetObject("button2.Font")));
            button2.Image = ((System.Drawing.Image)(resources.GetObject("button2.Image")));
            button2.ImageAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("button2.ImageAlign")));
            button2.ImageIndex = ((int)(resources.GetObject("button2.ImageIndex")));
            button2.ImeMode = ((System.Windows.Forms.ImeMode)(resources.GetObject("button2.ImeMode")));
            button2.Location = ((System.Drawing.Point)(resources.GetObject("button2.Location")));
            button2.Name = "button2";
            button2.RightToLeft = ((System.Windows.Forms.RightToLeft)(resources.GetObject("button2.RightToLeft")));
            button2.Size = ((System.Drawing.Size)(resources.GetObject("button2.Size")));
            button2.TabIndex = ((int)(resources.GetObject("button2.TabIndex")));
            button2.Text = resources.GetString("button2.Text");
            button2.TextAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("button2.TextAlign")));
            button2.Visible = ((bool)(resources.GetObject("button2.Visible")));
            // 
            // Win32Form1
            // 
            CancelButton = button2;
            AcceptButton = button1;

            // hook up the help event
            this.HelpRequested += new HelpEventHandler(this.AutoFormat_HelpRequested);

            AccessibleDescription = ((string)(resources.GetObject("$this.AccessibleDescription")));
            AccessibleName = ((string)(resources.GetObject("$this.AccessibleName")));
            Anchor = ((System.Windows.Forms.AnchorStyles)(resources.GetObject("$this.Anchor")));
            AutoScaleBaseSize = ((System.Drawing.Size)(resources.GetObject("$this.AutoScaleBaseSize")));
            AutoScroll = ((bool)(resources.GetObject("$this.AutoScroll")));
            AutoScrollMargin = ((System.Drawing.Size)(resources.GetObject("$this.AutoScrollMargin")));
            AutoScrollMinSize = ((System.Drawing.Size)(resources.GetObject("$this.AutoScrollMinSize")));
            BackgroundImage = ((System.Drawing.Image)(resources.GetObject("$this.BackgroundImage")));
            ClientSize = ((System.Drawing.Size)(resources.GetObject("$this.ClientSize")));
            Controls.AddRange(new System.Windows.Forms.Control[] {this.button2,
                   button1,
                   preview,
                   dataGrid,
                   schemeName,
                   formats});
            Cursor = ((System.Windows.Forms.Cursor)(resources.GetObject("$this.Cursor")));
            Dock = ((System.Windows.Forms.DockStyle)(resources.GetObject("$this.Dock")));
            Enabled = ((bool)(resources.GetObject("$this.Enabled")));
            Font = ((System.Drawing.Font)(resources.GetObject("$this.Font")));
            FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
            ImeMode = ((System.Windows.Forms.ImeMode)(resources.GetObject("$this.ImeMode")));
            Location = ((System.Drawing.Point)(resources.GetObject("$this.Location")));
            MaximizeBox = false;
            MaximumSize = ((System.Drawing.Size)(resources.GetObject("$this.MaximumSize")));
            MinimizeBox = false;
            MinimumSize = ((System.Drawing.Size)(resources.GetObject("$this.MinimumSize")));
            Name = "Win32Form1";
            RightToLeft = ((System.Windows.Forms.RightToLeft)(resources.GetObject("$this.RightToLeft")));
            StartPosition = ((System.Windows.Forms.FormStartPosition)(resources.GetObject("$this.StartPosition")));
            Text = resources.GetString("$this.Text");
            Visible = ((bool)(resources.GetObject("$this.Visible")));
            ((System.ComponentModel.ISupportInitialize)(this.dataGrid)).EndInit();
            dataGrid.ResumeLayout(false);
            ResumeLayout(false);
        }

        private bool IsTableProperty(string propName) {
            if (propName.Equals("HeaderColor"))
                return true;
            if (propName.Equals("AlternatingBackColor"))
                return true;
            if (propName.Equals("BackColor"))
                return true;
            if (propName.Equals("ForeColor"))
                return true;
            if (propName.Equals("GridLineColor"))
                return true;
            if (propName.Equals("GridLineStyle"))
                return true;
            if (propName.Equals("HeaderBackColor"))
                return true;
            if (propName.Equals("HeaderForeColor"))
                return true;
            if (propName.Equals("LinkColor"))
                return true;
            if (propName.Equals("LinkHoverColor"))
                return true;
            if (propName.Equals("SelectionForeColor"))
                return true;
            if (propName.Equals("SelectionBackColor"))
                return true;
            if (propName.Equals("HeaderFont"))
                return true;
            return false;
        }

        private void SchemeName_SelectionChanged(object sender, EventArgs e) {
            if (IMBusy)
                return;

            DataRow row = ((DataRowView)schemeName.SelectedItem).Row;
            if (row != null) {
                PropertyDescriptorCollection gridProperties = TypeDescriptor.GetProperties(typeof(DataGrid));
                PropertyDescriptorCollection gridTableStyleProperties = TypeDescriptor.GetProperties(typeof(DataGridTableStyle));

                foreach (DataColumn c in row.Table.Columns) {
                    object value = row[c];
                    PropertyDescriptor prop;
                    object component;

                    if (IsTableProperty(c.ColumnName)) {
                        prop = gridTableStyleProperties[c.ColumnName];
                        component = this.tableStyle;
                    }
                    else {
                        prop = gridProperties[c.ColumnName];
                        component = this.dataGrid;
                    }

                    if (prop != null) {
                        if (Convert.IsDBNull(value)  || value.ToString().Length == 0) {
                            prop.ResetValue(component);
                        }
                        else {
                            try {
                                // Ignore errors setting up the preview...
                                // The only one that really needs to be handled is the font property,
                                // where the font in the scheme may not exist on the machine. (#56516)
                            
                                TypeConverter converter = prop.Converter;
                                object convertedValue = converter.ConvertFromString(value.ToString());
                                prop.SetValue(component, convertedValue);
                            }
                            catch (Exception) {
                            }
                        }
                    }
                }
            }
            /*
            string pictureName = row["SchemePicture"].ToString();
            Bitmap picture = new Bitmap(typeof(DataGridAutoFormatDialog),pictureName);
            schemePicture.Image = picture;
            */
        }

        public DataRow SelectedData {
            get {
                if (schemeName != null) {
                    // ListBox uses Windows.SendMessage(.., win.LB_GETCURSEL,... ) to determine the selection
                    // by the time that DataGridDesigner needs this information
                    // the call to SendMessage will fail. this is why we save
                    // the selectedIndex
                    return ((DataRowView)schemeName.Items[this.selectedIndex]).Row;
                }
                return null;
            }
        }

        internal const string scheme ="<xsd:schema id=\"pulica\" xmlns=\"\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:msdata=\"urn:schemas-microsoft-com:xml-msdata\">" + 
  "<xsd:element name=\"Scheme\">" +
    "<xsd:complexType>" +
      "<xsd:all>" +
        "<xsd:element name=\"SchemeName\" minOccurs=\"0\" type=\"xsd:string\"/>" +
        "<xsd:element name=\"SchemePicture\" minOccurs=\"0\" type=\"xsd:string\"/>" +
        "<xsd:element name=\"BorderStyle\" minOccurs=\"0\" type=\"xsd:string\"/>" +
        "<xsd:element name=\"FlatMode\" minOccurs=\"0\" type=\"xsd:string\"/>" +
        "<xsd:element name=\"Font\" minOccurs=\"0\" type=\"xsd:string\"/>" +
        "<xsd:element name=\"CaptionFont\" minOccurs=\"0\" type=\"xsd:string\"/>" +
        "<xsd:element name=\"HeaderFont\" minOccurs=\"0\" type=\"xsd:string\"/>" +
        "<xsd:element name=\"AlternatingBackColor\" minOccurs=\"0\" type=\"xsd:string\"/>" +
        "<xsd:element name=\"BackColor\" minOccurs=\"0\" type=\"xsd:string\"/>" +
        "<xsd:element name=\"BackgroundColor\" minOccurs=\"0\" type=\"xsd:string\"/>" +
        "<xsd:element name=\"CaptionForeColor\" minOccurs=\"0\" type=\"xsd:string\"/>" +
        "<xsd:element name=\"CaptionBackColor\" minOccurs=\"0\" type=\"xsd:string\"/>" +
        "<xsd:element name=\"ForeColor\" minOccurs=\"0\" type=\"xsd:string\"/>" +
        "<xsd:element name=\"GridLineColor\" minOccurs=\"0\" type=\"xsd:string\"/>" +
        "<xsd:element name=\"GridLineStyle\" minOccurs=\"0\" type=\"xsd:string\"/>" +
        "<xsd:element name=\"HeaderBackColor\" minOccurs=\"0\" type=\"xsd:string\"/>" +
        "<xsd:element name=\"HeaderForeColor\" minOccurs=\"0\" type=\"xsd:string\"/>" +
        "<xsd:element name=\"LinkColor\" minOccurs=\"0\" type=\"xsd:string\"/>" +
        "<xsd:element name=\"LinkHoverColor\" minOccurs=\"0\" type=\"xsd:string\"/>" +
        "<xsd:element name=\"ParentRowsBackColor\" minOccurs=\"0\" type=\"xsd:string\"/>" +
        "<xsd:element name=\"ParentRowsForeColor\" minOccurs=\"0\" type=\"xsd:string\"/>" +
        "<xsd:element name=\"SelectionForeColor\" minOccurs=\"0\" type=\"xsd:string\"/>" +
        "<xsd:element name=\"SelectionBackColor\" minOccurs=\"0\" type=\"xsd:string\"/>" +
      "</xsd:all>" +
    "</xsd:complexType>" +
  "</xsd:element>" +
"</xsd:schema>";
        internal const string data =
"<pulica>" +
  "<Scheme>" +
    "<SchemeName>Default</SchemeName>" +
    "<SchemePicture>default.bmp</SchemePicture>" +
    "<BorderStyle></BorderStyle>" +
    "<FlatMode></FlatMode>" +
    "<CaptionFont></CaptionFont>" +
    "<Font></Font>" +
    "<HeaderFont></HeaderFont>" +
    "<AlternatingBackColor></AlternatingBackColor>" +
    "<BackColor></BackColor>" +
    "<CaptionForeColor></CaptionForeColor>" +
    "<CaptionBackColor></CaptionBackColor>" +
    "<ForeColor></ForeColor>" +
    "<GridLineColor></GridLineColor>" +
    "<GridLineStyle></GridLineStyle>" +
    "<HeaderBackColor></HeaderBackColor>" +
    "<HeaderForeColor></HeaderForeColor>" +
    "<LinkColor></LinkColor>" +
    "<LinkHoverColor></LinkHoverColor>" +
    "<ParentRowsBackColor></ParentRowsBackColor>" +
    "<ParentRowsForeColor></ParentRowsForeColor>" +
    "<SelectionForeColor></SelectionForeColor>" +
    "<SelectionBackColor></SelectionBackColor>" +
  "</Scheme>" +
  "<Scheme>" +
    "<SchemeName>Professional 1</SchemeName>" +
    "<SchemePicture>professional1.bmp</SchemePicture>" +
    "<CaptionFont>Verdana, 10pt</CaptionFont>" +
    "<AlternatingBackColor>LightGray</AlternatingBackColor>" +
    "<CaptionForeColor>Navy</CaptionForeColor>" +
    "<CaptionBackColor>White</CaptionBackColor>" +
    "<ForeColor>Black</ForeColor>" +
    "<BackColor>DarkGray</BackColor>" +
    "<GridLineColor>Black</GridLineColor>" +
    "<GridLineStyle>None</GridLineStyle>" +
    "<HeaderBackColor>Silver</HeaderBackColor>" +
    "<HeaderForeColor>Black</HeaderForeColor>" +
    "<LinkColor>Navy</LinkColor>" +
    "<LinkHoverColor>Blue</LinkHoverColor>" +
    "<ParentRowsBackColor>White</ParentRowsBackColor>" +
    "<ParentRowsForeColor>Black</ParentRowsForeColor>" +
    "<SelectionForeColor>White</SelectionForeColor>" +
    "<SelectionBackColor>Navy</SelectionBackColor>" +
  "</Scheme>" +
  "<Scheme>" +
    "<SchemeName>Professional 2</SchemeName>" +
    "<SchemePicture>professional2.bmp</SchemePicture>" +
    "<BorderStyle>FixedSingle</BorderStyle>" +
    "<FlatMode>True</FlatMode>" +
    "<CaptionFont>Tahoma, 8pt</CaptionFont>" +
    "<AlternatingBackColor>Gainsboro</AlternatingBackColor>" +
    "<BackColor>Silver</BackColor>" +
    "<CaptionForeColor>White</CaptionForeColor>" +
    "<CaptionBackColor>DarkSlateBlue</CaptionBackColor>" +
    "<ForeColor>Black</ForeColor>" +
    "<GridLineColor>White</GridLineColor>" +
    "<HeaderBackColor>DarkGray</HeaderBackColor>" +
    "<HeaderForeColor>Black</HeaderForeColor>" +
    "<LinkColor>DarkSlateBlue</LinkColor>" +
    "<LinkHoverColor>RoyalBlue</LinkHoverColor>" +
    "<ParentRowsBackColor>Black</ParentRowsBackColor>" +
    "<ParentRowsForeColor>White</ParentRowsForeColor>" +
    "<SelectionForeColor>White</SelectionForeColor>" +
    "<SelectionBackColor>DarkSlateBlue</SelectionBackColor>" +
  "</Scheme>" +
  "<Scheme>" +
    "<SchemeName>Professional 3</SchemeName>" +
    "<SchemePicture>professional3.bmp</SchemePicture>" +
    "<BorderStyle>None</BorderStyle>" +
    "<FlatMode>True</FlatMode>" +
    "<CaptionFont>Tahoma, 8pt, style=1</CaptionFont>" +
    "<HeaderFont>Tahoma, 8pt, style=1</HeaderFont>" +
    "<Font>Tahoma, 8pt</Font>" +
    "<AlternatingBackColor>LightGray</AlternatingBackColor>" +
    "<BackColor>Gainsboro</BackColor>" +
    "<BackgroundColor>Silver</BackgroundColor>" +
    "<CaptionForeColor>MidnightBlue</CaptionForeColor>" +
    "<CaptionBackColor>LightSteelBlue</CaptionBackColor>" +
    "<ForeColor>Black</ForeColor>" +
    "<GridLineColor>DimGray</GridLineColor>" +
    "<GridLineStyle>None</GridLineStyle>" +
    "<HeaderBackColor>MidnightBlue</HeaderBackColor>" +
    "<HeaderForeColor>White</HeaderForeColor>" +
    "<LinkColor>MidnightBlue</LinkColor>" +
    "<LinkHoverColor>RoyalBlue</LinkHoverColor>" +
    "<ParentRowsBackColor>DarkGray</ParentRowsBackColor>" +
    "<ParentRowsForeColor>Black</ParentRowsForeColor>" +
    "<SelectionForeColor>White</SelectionForeColor>" +
    "<SelectionBackColor>CadetBlue</SelectionBackColor>" +
  "</Scheme>" +
  "<Scheme>" +
    "<SchemeName>Professional 4</SchemeName>" +
    "<SchemePicture>professional4.bmp</SchemePicture>" +
    "<BorderStyle>None</BorderStyle>" +
    "<FlatMode>True</FlatMode>" +
    "<CaptionFont>Tahoma, 8pt, style=1</CaptionFont>" +
    "<HeaderFont>Tahoma, 8pt, style=1</HeaderFont>" +
    "<Font>Tahoma, 8pt</Font>" +
    "<AlternatingBackColor>Lavender</AlternatingBackColor>" +
    "<BackColor>WhiteSmoke</BackColor>" +
    "<BackgroundColor>LightGray</BackgroundColor>" +
    "<CaptionForeColor>MidnightBlue</CaptionForeColor>" +
    "<CaptionBackColor>LightSteelBlue</CaptionBackColor>" +
    "<ForeColor>MidnightBlue</ForeColor>" +
    "<GridLineColor>Gainsboro</GridLineColor>" +
    "<GridLineStyle>None</GridLineStyle>" +
    "<HeaderBackColor>MidnightBlue</HeaderBackColor>" +
    "<HeaderForeColor>WhiteSmoke</HeaderForeColor>" +
    "<LinkColor>Teal</LinkColor>" +
    "<LinkHoverColor>DarkMagenta</LinkHoverColor>" +
    "<ParentRowsBackColor>Gainsboro</ParentRowsBackColor>" +
    "<ParentRowsForeColor>MidnightBlue</ParentRowsForeColor>" +
    "<SelectionForeColor>WhiteSmoke</SelectionForeColor>" +
    "<SelectionBackColor>CadetBlue</SelectionBackColor>" +
  "</Scheme>" +
  "<Scheme>" +
    "<SchemeName>Classic</SchemeName>" +
    "<SchemePicture>classic.bmp</SchemePicture>" +
    "<BorderStyle>FixedSingle</BorderStyle>" +
    "<FlatMode>True</FlatMode>" +
    "<Font>Times New Roman, 9pt</Font>" +
    "<HeaderFont>Tahoma, 8pt, style=1</HeaderFont>" +
    "<CaptionFont>Tahoma, 8pt, style=1</CaptionFont>" +
    "<AlternatingBackColor>WhiteSmoke</AlternatingBackColor>" +
    "<BackColor>Gainsboro</BackColor>" +
    "<BackgroundColor>DarkGray</BackgroundColor>" +
    "<CaptionForeColor>Black</CaptionForeColor>" +
    "<CaptionBackColor>DarkKhaki</CaptionBackColor>" +
    "<ForeColor>Black</ForeColor>" +
    "<GridLineColor>Silver</GridLineColor>" +
    "<HeaderBackColor>Black</HeaderBackColor>" +
    "<HeaderForeColor>White</HeaderForeColor>" +
    "<LinkColor>DarkSlateBlue</LinkColor>" +
    "<LinkHoverColor>Firebrick</LinkHoverColor>" +
    "<ParentRowsForeColor>Black</ParentRowsForeColor>" +
    "<ParentRowsBackColor>LightGray</ParentRowsBackColor>" +
    "<SelectionForeColor>White</SelectionForeColor>" +
    "<SelectionBackColor>Firebrick</SelectionBackColor>" +
  "</Scheme>" +
  "<Scheme>" +
    "<SchemeName>Simple</SchemeName>" +
    "<SchemePicture>Simple.bmp</SchemePicture>" +
    "<BorderStyle>FixedSingle</BorderStyle>" +
    "<FlatMode>True</FlatMode>" +
    "<Font>Courier New, 9pt</Font>" +
    "<HeaderFont>Courier New, 10pt, style=1</HeaderFont>" +
    "<CaptionFont>Courier New, 10pt, style=1</CaptionFont>" +
    "<AlternatingBackColor>White</AlternatingBackColor>" +
    "<BackColor>White</BackColor>" +
    "<BackgroundColor>Gainsboro</BackgroundColor>" +
    "<CaptionForeColor>Black</CaptionForeColor>" +
    "<CaptionBackColor>Silver</CaptionBackColor>" +
    "<ForeColor>DarkSlateGray</ForeColor>" +
    "<GridLineColor>DarkGray</GridLineColor>" +
    "<HeaderBackColor>DarkGreen</HeaderBackColor>" +
    "<HeaderForeColor>White</HeaderForeColor>" +
    "<LinkColor>DarkGreen</LinkColor>" +
    "<LinkHoverColor>Blue</LinkHoverColor>" +
    "<ParentRowsForeColor>Black</ParentRowsForeColor>" +
    "<ParentRowsBackColor>Gainsboro</ParentRowsBackColor>" +
    "<SelectionForeColor>Black</SelectionForeColor>" +
    "<SelectionBackColor>DarkSeaGreen</SelectionBackColor>" +
  "</Scheme>" +
  "<Scheme>" +
    "<SchemeName>Colorful 1</SchemeName>" +
    "<SchemePicture>colorful1.bmp</SchemePicture>" +
    "<BorderStyle>FixedSingle</BorderStyle>" +
    "<FlatMode>True</FlatMode>" +
    "<Font>Tahoma, 8pt</Font>" +
    "<CaptionFont>Tahoma, 9pt, style=1</CaptionFont>" +
    "<HeaderFont>Tahoma, 9pt, style=1</HeaderFont>" +
    "<AlternatingBackColor>LightGoldenrodYellow</AlternatingBackColor>" +
    "<BackColor>White</BackColor>" +
    "<BackgroundColor>LightGoldenrodYellow</BackgroundColor>" +
    "<CaptionForeColor>DarkSlateBlue</CaptionForeColor>" +
    "<CaptionBackColor>LightGoldenrodYellow</CaptionBackColor>" +
    "<ForeColor>DarkSlateBlue</ForeColor>" +
    "<GridLineColor>Peru</GridLineColor>" +
    "<GridLineStyle>None</GridLineStyle>" +
    "<HeaderBackColor>Maroon</HeaderBackColor>" +
    "<HeaderForeColor>LightGoldenrodYellow</HeaderForeColor>" +
    "<LinkColor>Maroon</LinkColor>" +
    "<LinkHoverColor>SlateBlue</LinkHoverColor>" +
    "<ParentRowsBackColor>BurlyWood</ParentRowsBackColor>" +
    "<ParentRowsForeColor>DarkSlateBlue</ParentRowsForeColor>" +
    "<SelectionForeColor>GhostWhite</SelectionForeColor>" +
    "<SelectionBackColor>DarkSlateBlue</SelectionBackColor>" +
  "</Scheme>" +
  "<Scheme>" +
    "<SchemeName>Colorful 2</SchemeName>" +
    "<SchemePicture>colorful2.bmp</SchemePicture>" +
    "<BorderStyle>None</BorderStyle>" +
    "<FlatMode>True</FlatMode>" +
    "<Font>Tahoma, 8pt</Font>" +
    "<CaptionFont>Tahoma, 8pt, style=1</CaptionFont>" +
    "<HeaderFont>Tahoma, 8pt, style=1</HeaderFont>" +
    "<AlternatingBackColor>GhostWhite</AlternatingBackColor>" +
    "<BackColor>GhostWhite</BackColor>" +
    "<BackgroundColor>Lavender</BackgroundColor>" +
    "<CaptionForeColor>White</CaptionForeColor>" +
    "<CaptionBackColor>RoyalBlue</CaptionBackColor>" +
    "<ForeColor>MidnightBlue</ForeColor>" +
    "<GridLineColor>RoyalBlue</GridLineColor>" +
    "<HeaderBackColor>MidnightBlue</HeaderBackColor>" +
    "<HeaderForeColor>Lavender</HeaderForeColor>" +
    "<LinkColor>Teal</LinkColor>" +
    "<LinkHoverColor>DodgerBlue</LinkHoverColor>" +
    "<ParentRowsBackColor>Lavender</ParentRowsBackColor>" +
    "<ParentRowsForeColor>MidnightBlue</ParentRowsForeColor>" +
    "<SelectionForeColor>PaleGreen</SelectionForeColor>" +
    "<SelectionBackColor>Teal</SelectionBackColor>" +
  "</Scheme>" +
  "<Scheme>" +
    "<SchemeName>Colorful 3</SchemeName>" +
    "<SchemePicture>colorful3.bmp</SchemePicture>" +
    "<BorderStyle>None</BorderStyle>" +
    "<FlatMode>True</FlatMode>" +
    "<Font>Tahoma, 8pt</Font>" +
    "<CaptionFont>Tahoma, 8pt, style=1</CaptionFont>" +
    "<HeaderFont>Tahoma, 8pt, style=1</HeaderFont>" +
    "<AlternatingBackColor>OldLace</AlternatingBackColor>" +
    "<BackColor>OldLace</BackColor>" +
    "<BackgroundColor>Tan</BackgroundColor>" +
    "<CaptionForeColor>OldLace</CaptionForeColor>" +
    "<CaptionBackColor>SaddleBrown</CaptionBackColor>" +
    "<ForeColor>DarkSlateGray</ForeColor>" +
    "<GridLineColor>Tan</GridLineColor>" +
    "<GridLineStyle>Solid</GridLineStyle>" +
    "<HeaderBackColor>Wheat</HeaderBackColor>" +
    "<HeaderForeColor>SaddleBrown</HeaderForeColor>" +
    "<LinkColor>DarkSlateBlue</LinkColor>" +
    "<LinkHoverColor>Teal</LinkHoverColor>" +
    "<ParentRowsBackColor>OldLace</ParentRowsBackColor>" +
    "<ParentRowsForeColor>DarkSlateGray</ParentRowsForeColor>" +
    "<SelectionForeColor>White</SelectionForeColor>" +
    "<SelectionBackColor>SlateGray</SelectionBackColor>" +
  "</Scheme>" +
  "<Scheme>" +
    "<SchemeName>Colorful 4</SchemeName>" +
    "<SchemePicture>colorful4.bmp</SchemePicture>" +
    "<BorderStyle>FixedSingle</BorderStyle>" +
    "<FlatMode>True</FlatMode>" +
    "<Font>Tahoma, 8pt</Font>" +
    "<CaptionFont>Tahoma, 8pt, style=1</CaptionFont>" +
    "<HeaderFont>Tahoma, 8pt, style=1</HeaderFont>" +
    "<AlternatingBackColor>White</AlternatingBackColor>" +
    "<BackColor>White</BackColor>" +
    "<BackgroundColor>Ivory</BackgroundColor>" +
    "<CaptionForeColor>Lavender</CaptionForeColor>" +
    "<CaptionBackColor>DarkSlateBlue</CaptionBackColor>" +
    "<ForeColor>Black</ForeColor>" +
    "<GridLineColor>Wheat</GridLineColor>" +
    "<HeaderBackColor>CadetBlue</HeaderBackColor>" +
    "<HeaderForeColor>Black</HeaderForeColor>" +
    "<LinkColor>DarkSlateBlue</LinkColor>" +
    "<LinkHoverColor>LightSeaGreen</LinkHoverColor>" +
    "<ParentRowsBackColor>Ivory</ParentRowsBackColor>" +
    "<ParentRowsForeColor>Black</ParentRowsForeColor>" +
    "<SelectionForeColor>DarkSlateBlue</SelectionForeColor>" +
    "<SelectionBackColor>Wheat</SelectionBackColor>" +
  "</Scheme>" +
  "<Scheme>" +
    "<SchemeName>256 Color 1</SchemeName>" +
    "<SchemePicture>256_1.bmp</SchemePicture>" +
    "<Font>Tahoma, 8pt</Font>" +
    "<CaptionFont>Tahoma, 8 pt</CaptionFont>" +
    "<HeaderFont>Tahoma, 8pt</HeaderFont>" +
    "<AlternatingBackColor>Silver</AlternatingBackColor>" +
    "<BackColor>White</BackColor>" +
    "<CaptionForeColor>White</CaptionForeColor>" +
    "<CaptionBackColor>Maroon</CaptionBackColor>" +
    "<ForeColor>Black</ForeColor>" +
    "<GridLineColor>Silver</GridLineColor>" +
    "<HeaderBackColor>Silver</HeaderBackColor>" +
    "<HeaderForeColor>Black</HeaderForeColor>" +
    "<LinkColor>Maroon</LinkColor>" +
    "<LinkHoverColor>Red</LinkHoverColor>" +
    "<ParentRowsBackColor>Silver</ParentRowsBackColor>" +
    "<ParentRowsForeColor>Black</ParentRowsForeColor>" +
    "<SelectionForeColor>White</SelectionForeColor>" +
    "<SelectionBackColor>Maroon</SelectionBackColor>" +
  "</Scheme>" +
  "<Scheme>" +
    "<SchemeName>256 Color 2</SchemeName>" +
    "<SchemePicture>256_2.bmp</SchemePicture>" +
    "<BorderStyle>FixedSingle</BorderStyle>" +
    "<FlatMode>True</FlatMode>" +
    "<CaptionFont>Microsoft Sans Serif, 10 pt, style=1</CaptionFont>" +
    "<Font>Tahoma, 8pt</Font>" +
    "<HeaderFont>Tahoma, 8pt</HeaderFont>" +
    "<AlternatingBackColor>White</AlternatingBackColor>" +
    "<BackColor>White</BackColor>" +
    "<CaptionForeColor>White</CaptionForeColor>" +
    "<CaptionBackColor>Teal</CaptionBackColor>" +
    "<ForeColor>Black</ForeColor>" +
    "<GridLineColor>Silver</GridLineColor>" +
    "<HeaderBackColor>Black</HeaderBackColor>" +
    "<HeaderForeColor>White</HeaderForeColor>" +
    "<LinkColor>Purple</LinkColor>" +
    "<LinkHoverColor>Fuchsia</LinkHoverColor>" +
    "<ParentRowsBackColor>Gray</ParentRowsBackColor>" +
    "<ParentRowsForeColor>White</ParentRowsForeColor>" +
    "<SelectionForeColor>White</SelectionForeColor>" +
    "<SelectionBackColor>Maroon</SelectionBackColor>" +
  "</Scheme>" +
"</pulica>";

    private class AutoFormatDataGrid : DataGrid {
        protected override void OnKeyDown(KeyEventArgs e) {
        }
        protected override bool ProcessDialogKey(Keys keyData) {
            return false;
        }
        protected override bool ProcessKeyPreview(ref Message m) { 
            return false;
        }
        protected override void OnMouseDown(MouseEventArgs e) {}
        protected override void OnMouseUp(MouseEventArgs e) {}
        protected override void OnMouseMove(MouseEventArgs e) {}
    }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\datamemberlisteditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataMemberListEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms.Design {

    using System.Design;
    using System;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Drawing;
    using System.Drawing.Design;
    
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class DataMemberListEditor : UITypeEditor {

        private DesignBindingPicker designBindingPicker;
        
        public override object EditValue(ITypeDescriptorContext context,  IServiceProvider  provider, object value) {
            if (provider != null) {
                IWindowsFormsEditorService edSvc = (IWindowsFormsEditorService)provider.GetService(typeof(IWindowsFormsEditorService));

                if (edSvc != null && context.Instance != null) {
                    if (designBindingPicker == null) {
                        designBindingPicker = new DesignBindingPicker(context, /*multiple DataSources*/ false, /*select lists*/ true);
                    }
                    PropertyDescriptor dataSourceProperty = TypeDescriptor.GetProperties(context.Instance)["DataSource"];
                    if (dataSourceProperty != null) {
                        object dataSource = dataSourceProperty.GetValue(context.Instance);
                        if (dataSource != null) {
                            designBindingPicker.Start(context, edSvc, dataSource, new DesignBinding(dataSource, (string)value));
                            edSvc.DropDownControl(designBindingPicker);
                            if (designBindingPicker.SelectedItem != null) {
                                value = designBindingPicker.SelectedItem.DataMember;
                            }
                            designBindingPicker.End();
                        } else {
                            // bug 61510: do not throw the exception ( the exception was added in bug 37841 )
                            designBindingPicker.Start(context, edSvc, dataSource, new DesignBinding(null, (string) value));
                            edSvc.DropDownControl(designBindingPicker);
                            designBindingPicker.End();
                        }
                    }
                }
            }

            return value;
        }

        public override UITypeEditorEditStyle GetEditStyle(ITypeDescriptorContext context) {
            return UITypeEditorEditStyle.DropDown;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\datamemberfieldeditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataMemberFieldEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms.Design {

    using System;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Drawing;
    using System.Drawing.Design;
    using System.Design;
    
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class DataMemberFieldEditor : UITypeEditor {

        private DesignBindingPicker designBindingPicker;
        
        public override object EditValue(ITypeDescriptorContext context,  IServiceProvider  provider, object value) {
            if (provider != null) {
                IWindowsFormsEditorService edSvc = (IWindowsFormsEditorService)provider.GetService(typeof(IWindowsFormsEditorService));

                if (edSvc != null && context.Instance != null) {
                    if (designBindingPicker == null) {
                        designBindingPicker = new DesignBindingPicker(context, /*multiple DataSources*/ false, /*select lists*/ false);
                    }
                    PropertyDescriptor dataSourceProperty = TypeDescriptor.GetProperties(context.Instance)["DataSource"];
                    if (dataSourceProperty != null) {
                        object dataSource = dataSourceProperty.GetValue(context.Instance);
                        if (dataSource != null) {
                            designBindingPicker.Start(context, edSvc, dataSource, new DesignBinding(dataSource, (string)value));
                            edSvc.DropDownControl(designBindingPicker);
                            if (designBindingPicker.SelectedItem != null) {
                                value = designBindingPicker.SelectedItem.DataMember;
                            }
                            designBindingPicker.End();
                        } else {
                            // bug 61510: do not throw the exception ( the exception was added in bug 37841 )
                            designBindingPicker.Start(context, edSvc, dataSource, new DesignBinding(null, (string) value));
                            edSvc.DropDownControl(designBindingPicker);
                            designBindingPicker.End();
                        }
                    }
                }
            }

            return value;
        }

        public override UITypeEditorEditStyle GetEditStyle(ITypeDescriptorContext context) {
            return UITypeEditorEditStyle.DropDown;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\designbindingconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="DesignBindingConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms.Design {

    using System;
    using System.Design;
    using System.ComponentModel;
    using System.Globalization;
    
    /// <include file='doc\DesignBindingConverter.uex' path='docs/doc[@for="DesignBindingConverter"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Converts data bindings for use in the design-time environment.
    ///    </para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class DesignBindingConverter : TypeConverter {
        
        public override bool CanConvertTo(ITypeDescriptorContext context, Type sourceType) {
            return (typeof(string) == sourceType);
        }

        public override bool CanConvertFrom(ITypeDescriptorContext context, Type destType) {
            return (typeof(string) == destType);
        }
        
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type sourceType) {
            DesignBinding designBinding = (DesignBinding) value;
            if (designBinding.IsNull) {
                return SR.GetString(SR.DataGridNoneString);
            }
            else {
                string name = "";
                if (designBinding.DataSource is IComponent) {
                    IComponent component = (IComponent) designBinding.DataSource;
                    if (component.Site != null) {
                        name = component.Site.Name;
                    }
                }
                if (name.Length == 0) {
                    name = "(List)";
                }
                
                name += " - " + designBinding.DataMember;
                return name;
            }
        }

        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) {
            string text = (string) value;
            if (text == null || text.Length == 0 || String.Compare(text,SR.GetString(SR.DataGridNoneString),true, CultureInfo.CurrentCulture) == 0) {
                return DesignBinding.Null;
            }
            else {
                int dash = text.IndexOf("-");
                if (dash == -1) {
                    throw new ArgumentException(SR.GetString(SR.DesignBindingBadParseString, text));
                }
                string componentName = text.Substring(0,dash - 1).Trim();
                string dataMember = text.Substring(dash + 1).Trim();
                
                if (context == null || context.Container == null) {
                    throw new ArgumentException(SR.GetString(SR.DesignBindingContextRequiredWhenParsing, text));
                }
                IComponent dataSource = context.Container.Components[componentName];
                if (dataSource == null) {
                    if (String.Compare(componentName,"(List)",true, CultureInfo.InvariantCulture) == 0) {
                        return null;
                    }
                    throw new ArgumentException(SR.GetString(SR.DesignBindingComponentNotFound, componentName));
                }
                return new DesignBinding(dataSource,dataMember);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\datasourceconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataSourceConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms.Design {

    using System;
    using System.Collections;
    using System.ComponentModel;
    
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class DataSourceConverter : ReferenceConverter {
    
        public DataSourceConverter() : base(typeof(IListSource)) {
        }

        ReferenceConverter listConverter = new ReferenceConverter(typeof(IList));

        public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context) {
            StandardValuesCollection listSources = base.GetStandardValues(context);
            StandardValuesCollection lists = listConverter.GetStandardValues(context);
            
            ArrayList listsList = new ArrayList();
            foreach (object listSource in listSources) {
                if (listSource != null) {
                    // bug 46563: work around the TableMappings property on the OleDbDataAdapter
                    ListBindableAttribute listBindable = (ListBindableAttribute) TypeDescriptor.GetAttributes(listSource)[typeof(ListBindableAttribute)];
                    if (listBindable != null && !listBindable.ListBindable)
                        continue;
                    listsList.Add(listSource);
                }
            }
            foreach (object list in lists) {
                if (list!= null) {
                    // bug 46563: work around the TableMappings property on the OleDbDataAdapter
                    ListBindableAttribute listBindable = (ListBindableAttribute) TypeDescriptor.GetAttributes(list)[typeof(ListBindableAttribute)];
                    if (listBindable != null && !listBindable.ListBindable)
                        continue;
                    listsList.Add(list);
                }
            }
            // bug 71417: add a null list to reset the dataSource
            listsList.Add(null);
            
            return new StandardValuesCollection(listsList);
        }   
        
        public override bool GetStandardValuesExclusive(ITypeDescriptorContext context) {
            return true;
        }

        public override bool GetStandardValuesSupported(ITypeDescriptorContext context) {
            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\designbinding.cs ===
//------------------------------------------------------------------------------
// <copyright file="DesignBinding.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms.Design {

    using System;
    using System.ComponentModel;
    using System.Drawing.Design;
    using System.Globalization;
    
    [
    System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode),
    Editor("System.Windows.Forms.Design.DesignBindingEditor, " + AssemblyRef.SystemDesign,typeof(UITypeEditor))
    ]    
    internal class DesignBinding {
        
        private object dataSource;
        private string dataMember;
             
        public static DesignBinding Null = new DesignBinding(null, null);

        public DesignBinding(object dataSource, string dataMember) {
            this.dataSource = dataSource;
            this.dataMember = dataMember;
        }
            
        public bool IsNull {
            get {
                return (dataSource == null);
            }
        }
            
        public object DataSource {
            get {
                return dataSource;
            }
        }
            
        public string DataMember {
            get {
                return dataMember;
            }
        }

        public string DataField {
            get {
                int lastDot = dataMember.LastIndexOf(".");
                if (lastDot == -1) {
                    return dataMember;
                } else {
                    return dataMember.Substring(lastDot+1);
                }
            }
        }
        
        public bool Equals(object dataSource, string dataMember) {
            return (dataSource == this.dataSource && String.Compare(dataMember, this.dataMember, true, CultureInfo.InvariantCulture) == 0);
        }
    }            

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\designbindingeditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="DesignBindingEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms.Design {

    using System;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Drawing;
    using System.Drawing.Design;
    
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class DesignBindingEditor : UITypeEditor {

        private DesignBindingPicker designBindingPicker;
        
        public override object EditValue(ITypeDescriptorContext context,  IServiceProvider  provider, object value) {
            if (provider != null) {
                IWindowsFormsEditorService edSvc = (IWindowsFormsEditorService)provider.GetService(typeof(IWindowsFormsEditorService));

                if (edSvc != null) {
                    if (designBindingPicker == null) {
                        designBindingPicker = new DesignBindingPicker(context, /*multiple DataSources*/ true, /*select lists*/ false);
                    }
                    designBindingPicker.Start(context, edSvc, null, (DesignBinding) value);
                    edSvc.DropDownControl(designBindingPicker);
                    value = designBindingPicker.SelectedItem;
                    designBindingPicker.End();
                }
            }

            return value;
        }

        public override UITypeEditorEditStyle GetEditStyle(ITypeDescriptorContext context) {
            return UITypeEditorEditStyle.DropDown;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\datetimepickerdesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="DateTimePickerDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms.Design {
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.ComponentModel.Design;
    using System.Windows.Forms;
    using System.Drawing;
    using Microsoft.Win32;

    /// <include file='doc\DateTimePickerDesigner.uex' path='docs/doc[@for="DateTimePickerDesigner"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides rich design time behavior for the
    ///       DateTimePicker control.
    ///    </para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class DateTimePickerDesigner : ControlDesigner {

        /// <include file='doc\DateTimePickerDesigner.uex' path='docs/doc[@for="DateTimePickerDesigner.OnSetComponentDefaults"]/*' />
        /// <devdoc>
        ///     Called when the designer is intialized.  This allows the designer to provide some
        ///     meaningful default values in the control.
        /// </devdoc>
        public override void OnSetComponentDefaults() {
            // Don't call super!
            //
        }
    
        /// <include file='doc\DateTimePickerDesigner.uex' path='docs/doc[@for="DateTimePickerDesigner.SelectionRules"]/*' />
        /// <devdoc>
        ///     Retrieves a set of rules concerning the movement capabilities of a component.
        ///     This should be one or more flags from the SelectionRules class.  If no designer
        ///     provides rules for a component, the component will not get any UI services.
        /// </devdoc>
        public override SelectionRules SelectionRules {
            get {
                SelectionRules rules = base.SelectionRules;
                rules &= ~(SelectionRules.TopSizeable | SelectionRules.BottomSizeable);
                return rules;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\designbindingvalueuihandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="DesignBindingValueUIHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms.Design {

    using System;
    using System.Collections;
    using System.Windows.Forms;
    using Microsoft.Win32;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Drawing.Design;    
    using System.Drawing;

    /// <include file='doc\DesignBindingValueUIHandler.uex' path='docs/doc[@for="DesignBindingValueUIHandler"]/*' />
    /// <internalonly/>
    /// <devdoc>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class DesignBindingValueUIHandler : IDisposable {

        private Bitmap dataBitmap;

        internal Bitmap DataBitmap {
            get {
                if (dataBitmap == null) {
                    dataBitmap = new Bitmap(typeof(DesignBindingValueUIHandler), "BoundProperty.bmp");
                    dataBitmap.MakeTransparent();
                }
                return dataBitmap;
            }
        }


        internal void OnGetUIValueItem(ITypeDescriptorContext context, PropertyDescriptor propDesc, ArrayList valueUIItemList){        
            if (context.Instance is Control) {
                Control control = (Control) context.Instance;
                foreach (Binding binding in control.DataBindings) {
                    if (binding.PropertyName.Equals(propDesc.Name)) {
                        valueUIItemList.Add(new LocalUIItem(this, binding));
                    }
                }
            }    
        }

        class LocalUIItem : PropertyValueUIItem {
            Binding binding;

            internal LocalUIItem(DesignBindingValueUIHandler handler, Binding binding) : base(handler.DataBitmap, new PropertyValueUIItemInvokeHandler(handler.OnPropertyValueUIItemInvoke), GetToolTip(binding)) {
                this.binding = binding;
            }

            internal Binding Binding {
                get {
                    return binding;
                }
            }

            static string GetToolTip(Binding binding) {
                string name = "";
                if (binding.DataSource is IComponent) {
                    IComponent comp = (IComponent) binding.DataSource;
                    if (comp.Site != null) {
                        name = comp.Site.Name;
                    }
                }
                if (name.Length == 0) {
                    name = "(List)";
                }
                name += " - " + binding.BindingMemberInfo.BindingMember;
                return name;
            }
        }

        private void OnPropertyValueUIItemInvoke(ITypeDescriptorContext context, PropertyDescriptor descriptor, PropertyValueUIItem invokedItem) {
            LocalUIItem localItem = (LocalUIItem) invokedItem;
             IServiceProvider  sop = null;
            Control control = localItem.Binding.Control;
            if (control.Site != null) {
               sop = ( IServiceProvider ) control.Site.GetService(typeof( IServiceProvider ));
            }
            if (sop != null) {
                AdvancedBindingPropertyDescriptor advancedPropDesc = new AdvancedBindingPropertyDescriptor();
                AdvancedBindingObject advancedObject = (AdvancedBindingObject) advancedPropDesc.GetValue(control.DataBindings);
                AdvancedBindingPropertyDescriptor.advancedBindingEditor.EditValue(context, sop, advancedObject);
            }
        }

        public void Dispose() {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\designbindingpropertydescriptor.cs ===
//------------------------------------------------------------------------------
// <copyright file="DesignBindingPropertyDescriptor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms.Design {

    using System;
    using System.ComponentModel;
    
    /// <include file='doc\DesignBindingPropertyDescriptor.uex' path='docs/doc[@for="DesignBindingPropertyDescriptor"]/*' />
    /// <devdoc>
    ///    <para>Provides a property descriptor for design time data binding properties.</para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class DesignBindingPropertyDescriptor : PropertyDescriptor {

        private static TypeConverter designBindingConverter = new DesignBindingConverter();
        private PropertyDescriptor property;
            
        internal DesignBindingPropertyDescriptor(PropertyDescriptor property, Attribute[] attrs) : base(property.Name, attrs) {
            this.property = property;
        }
            
        /// <include file='doc\DesignBindingPropertyDescriptor.uex' path='docs/doc[@for="DesignBindingPropertyDescriptor.ComponentType"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the type of the component that owns the property.</para>
        /// </devdoc>
        public override Type ComponentType {
            get {
                return typeof(ControlBindingsCollection);
            }
        }

        /// <include file='doc\DesignBindingPropertyDescriptor.uex' path='docs/doc[@for="DesignBindingPropertyDescriptor.Converter"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the type converter.</para>
        /// </devdoc>
        public override TypeConverter Converter {
            get {
                return designBindingConverter;
            }
        }

        /// <include file='doc\DesignBindingPropertyDescriptor.uex' path='docs/doc[@for="DesignBindingPropertyDescriptor.IsReadOnly"]/*' />
        /// <devdoc>
        ///    <para>Indicates whether the property is read-only.</para>
        /// </devdoc>
        public override bool IsReadOnly {
            get {
                return false;
            }
        }

        /// <include file='doc\DesignBindingPropertyDescriptor.uex' path='docs/doc[@for="DesignBindingPropertyDescriptor.PropertyType"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the type of the property.</para>
        /// </devdoc>
        public override Type PropertyType {
            get {
                return typeof(DesignBinding);
            }
        }
            
        /// <include file='doc\DesignBindingPropertyDescriptor.uex' path='docs/doc[@for="DesignBindingPropertyDescriptor.CanResetValue"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether the specified component can reset the value 
        ///       of the property.</para>
        /// </devdoc>
        public override bool CanResetValue(object component) {
            if (component is AdvancedBindingObject) {
                component = ((AdvancedBindingObject)component).Bindings;
            }
            return !GetBinding((ControlBindingsCollection)component, property).IsNull;
        }
            
        /// <include file='doc\DesignBindingPropertyDescriptor.uex' path='docs/doc[@for="DesignBindingPropertyDescriptor.GetValue"]/*' />
        /// <devdoc>
        ///    <para>Gets a value from the specified component.</para>
        /// </devdoc>
        public override object GetValue(object component) {
            if (component is AdvancedBindingObject) {
                component = ((AdvancedBindingObject)component).Bindings;
            }
            return GetBinding((ControlBindingsCollection)component, property);
        }
            
        /// <include file='doc\DesignBindingPropertyDescriptor.uex' path='docs/doc[@for="DesignBindingPropertyDescriptor.ResetValue"]/*' />
        /// <devdoc>
        ///    <para>Resets the value of the specified component.</para>
        /// </devdoc>
        public override void ResetValue(object component) {
            if (component is AdvancedBindingObject) {
                component = ((AdvancedBindingObject)component).Bindings;
            }
            SetBinding((ControlBindingsCollection)component, property, DesignBinding.Null);
        }
            
        /// <include file='doc\DesignBindingPropertyDescriptor.uex' path='docs/doc[@for="DesignBindingPropertyDescriptor.SetValue"]/*' />
        /// <devdoc>
        ///    <para>Sets the specified value for the specified component.</para>
        /// </devdoc>
        public override void SetValue(object component, object value) {
            if (component is AdvancedBindingObject) {
                component = ((AdvancedBindingObject)component).Bindings;
            }
            SetBinding((ControlBindingsCollection)component, property, (DesignBinding)value);
            OnValueChanged(component, EventArgs.Empty);
        }
            
        /// <include file='doc\DesignBindingPropertyDescriptor.uex' path='docs/doc[@for="DesignBindingPropertyDescriptor.ShouldSerializeValue"]/*' />
        /// <devdoc>
        ///    <para>Indicates whether the specified component should persist the value.</para>
        /// </devdoc>
        public override bool ShouldSerializeValue(object component) {
            return false;
        }
            
        private static void SetBinding(ControlBindingsCollection bindings, PropertyDescriptor property, DesignBinding designBinding) {
            // this means it couldn't be parsed.
            if (designBinding == null)
                return;
            Binding listBinding = bindings[property.Name];
            if (listBinding != null) {
                bindings.Remove(listBinding);
            }
            if (!designBinding.IsNull) {
                bindings.Add(property.Name, designBinding.DataSource, designBinding.DataMember);
            }
        }
            
        private static DesignBinding GetBinding(ControlBindingsCollection bindings, PropertyDescriptor property) {
            Binding listBinding = bindings[property.Name];
            if (listBinding == null)
                return DesignBinding.Null;
            else
                return new DesignBinding(listBinding.DataSource, listBinding.BindingMemberInfo.BindingMember);
        }     
    }        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\designbindingpicker.cs ===
//------------------------------------------------------------------------------
// <copyright file="DesignBindingPicker.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms.Design {

    using System;
    using System.Design;
    using System.Windows.Forms;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Collections;
    using System.Drawing;
    using System.Drawing.Design;
    
    /// <include file='doc\DesignBindingPicker.uex' path='docs/doc[@for="DesignBindingPicker"]/*' />
    /// <internalonly/>
    /// <devdoc>
    /// </devdoc>
    [
    System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode),
    ToolboxItem(false),
    DesignTimeVisible(false)
    ]
    internal class DesignBindingPicker : TreeView {
    
        IWindowsFormsEditorService edSvc;

        bool multipleDataSources;
        bool selectLists;

        bool expansionSignClicked = false;

        private const int MaximumDepth = 10;

        private static readonly int BINDER_IMAGE = 0;
        private static readonly int COLUMN_IMAGE = 1;
        private static readonly int NONE_IMAGE = 2;

        private bool allowSelection = false;
        private DesignBinding selectedItem = null;
        private TreeNode selectedNode = null;

        public DesignBinding SelectedItem {
            get {
                return selectedItem;
            }
        }

        private bool ExpansionSignClicked {
            get {
                return this.expansionSignClicked;
            }
            set {
                this.expansionSignClicked = value;
            }
        }

        protected override void OnAfterExpand(TreeViewEventArgs e) {
            base.OnAfterExpand(e);
            ExpansionSignClicked = false;
        }

        protected override void OnBeforeExpand(TreeViewCancelEventArgs e) {
            ExpansionSignClicked = true;
            base.OnBeforeExpand(e);
        }

        protected override void OnBeforeCollapse(TreeViewCancelEventArgs e) {
            ExpansionSignClicked = true;
            base.OnBeforeCollapse(e);
        }

        protected override void OnAfterCollapse(TreeViewEventArgs e) {
            base.OnAfterCollapse(e);
            ExpansionSignClicked = false;
        }

        private TreeNode GetNodeAtXAndY(int x, int y) {
            NativeMethods.TV_HITTESTINFO tvhi = new NativeMethods.TV_HITTESTINFO();

            tvhi.pt_x = x;
            tvhi.pt_y = y;

            IntPtr hnode = UnsafeNativeMethods.SendMessage(this.Handle, NativeMethods.TVM_HITTEST, 0, tvhi);

            if (hnode == IntPtr.Zero)
                return null;
            if (tvhi.flags == NativeMethods.TVHT_ONITEMLABEL || tvhi.flags == NativeMethods.TVHT_ONITEMICON)
                return this.GetNodeAt(x,y);
                //return NodeFromHandle(hnode);
            return null;
        }

        protected override void WndProc(ref Message m) {
            if (m.Msg == NativeMethods.WM_LBUTTONDOWN) {
                base.WndProc(ref m);
                if (!allowSelection)
                    return;
                SetSelectedItem(GetNodeAtXAndY((int)(short)m.LParam, (int)m.LParam >> 16));
                if (selectedItem != null && !this.ExpansionSignClicked)
                    edSvc.CloseDropDown();
                this.ExpansionSignClicked = false;
            } else {
                base.WndProc(ref m);
            }
        }

        protected override bool IsInputKey(Keys key) {
            if (key == Keys.Return)
                return true;
            else
                return base.IsInputKey(key);
        }

        protected override void OnKeyUp(KeyEventArgs e) {

            base.OnKeyUp(e);

            if (e.KeyData == Keys.Return) {
                SetSelectedItem(this.SelectedNode);
                if (selectedItem != null) {
                    edSvc.CloseDropDown();
                }
            }
        }
        
        /// <include file='doc\DesignBindingPicker.uex' path='docs/doc[@for="DesignBindingPicker.DataSourceNode"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        internal class DataSourceNode : TreeNode {

            private IComponent dataSource;

            public DataSourceNode(IComponent dataSource) : base(dataSource.Site.Name, BINDER_IMAGE, BINDER_IMAGE) {
                this.dataSource = dataSource;
            }

            public IComponent DataSource {
                get {
                    return dataSource;
                }
            }
        }

        /// <include file='doc\DesignBindingPicker.uex' path='docs/doc[@for="DesignBindingPicker.DataMemberNode"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        internal class DataMemberNode : TreeNode {

            bool isList;
            string dataMember;
            
            public DataMemberNode(string dataMember, string dataField, bool isList) : base(dataField, COLUMN_IMAGE, COLUMN_IMAGE) {
                this.dataMember = dataMember;
                this.isList = isList;
            }

            public bool IsList {
                get {
                    return isList;
                }
            }
            
            // this returns the fully qualified string ( ex: DataSource.DataField)
            public string DataMember {
                get {
                    return dataMember;
                }
            }

            // this returns the dataField ( ex: the DataField part of the DataSource.DataField )
            public string DataField {
                get {
                    return this.Text;
                }
            }
            
            public IComponent DataSource {
                get {
                    TreeNode curNode = this;
                    while (curNode is DataMemberNode) {
                        curNode = curNode.Parent;
                    }
                    if (curNode is DataSourceNode) {
                        return ((DataSourceNode) curNode).DataSource;
                    }
                    else {
                        return null;
                    }
                }
            }
        }

        /// <include file='doc\DesignBindingPicker.uex' path='docs/doc[@for="DesignBindingPicker.NoneNode"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        internal class NoneNode : TreeNode {

            public NoneNode() : base(SR.GetString(SR.DataGridNoneString), NONE_IMAGE, NONE_IMAGE) {
            }
        }

        public DesignBindingPicker(ITypeDescriptorContext context, bool multipleDataSources, bool selectLists) {
            this.multipleDataSources = multipleDataSources;
            this.selectLists = selectLists;

            Image images = new Bitmap(typeof(DesignBindingPicker), "DataPickerImages.bmp");
            ImageList imageList = new ImageList();
            imageList.TransparentColor = Color.Lime;
            imageList.Images.AddStrip(images);
            ImageList = imageList;
        }

        // Properties window will set focus to us which causes selection,
        // so we need to wait til after we call DropDownControl to receive selection notices.
        public bool AllowSelection {
            get {
                return allowSelection;
            }
            set {
                this.allowSelection = value;
            }
        }

        public void Start(ITypeDescriptorContext context, IWindowsFormsEditorService edSvc, object dataSource, DesignBinding selectedItem) {
            this.edSvc = edSvc;
            this.selectedItem = selectedItem;
            this.ExpansionSignClicked = false;
            if (context == null || context.Container == null)
                return;
            FillDataSources(context, dataSource);
            this.Width = GetMaxItemWidth(Nodes) + (SystemInformation.VerticalScrollBarWidth * 2);
        }
        
        public void End() {
            Nodes.Clear();
            edSvc = null;
            selectedItem = null;
            this.ExpansionSignClicked = false;
        }

        protected void FillDataSource(BindingContext bindingManager, object component) {
            if (component is IListSource || component is IList || component is Array) {
                CurrencyManager listManager = (CurrencyManager)bindingManager[component];
                PropertyDescriptorCollection properties = listManager.GetItemProperties();
                if (properties.Count > 0) {
                    TreeNodeCollection nodes = this.Nodes;

                    if (multipleDataSources) {
                        TreeNode dataSourceNode = new DataSourceNode((IComponent)component);
                        Nodes.Add(dataSourceNode);
                        if (selectedItem != null && selectedItem.Equals(component, "")) {
                            selectedNode = dataSourceNode;
                        }        
                        nodes = dataSourceNode.Nodes;
                    }
                    
                    for (int j = 0; j < properties.Count; j++) {
                        FillDataMembers(bindingManager, component, properties[j].Name, properties[j].Name, typeof(IList).IsAssignableFrom(properties[j].PropertyType), nodes, 0);
                    }
                }
            }        
        }
        
        protected void FillDataSources(ITypeDescriptorContext context, object dataSource) {
            Nodes.Clear();
            BindingContext bindingManager = new BindingContext();
            
            if (multipleDataSources) {
                ComponentCollection components = context.Container.Components;
                foreach (IComponent comp in components) {
                    FillDataSource(bindingManager, comp);
                }
            }
            else {
                FillDataSource(bindingManager, dataSource);
            }
            
            TreeNode noneNode = new NoneNode();
            /* bug 74291: we should let the user have a noneNode
            // bug 49873: if we do not select lists and we have nodes, then do not allow the 
            // user to select the None node, cause this would not be allowed in the backEnd
            //
            if (Nodes.Count == 0 && !this.selectLists)
                Nodes.Add(noneNode);
            */
            Nodes.Add(noneNode);
            if (selectedNode == null) {
                selectedNode = noneNode;
            }
            
            this.SelectedNode = selectedNode;
            selectedNode = null;
            selectedItem = null;
            allowSelection = true;
        }

        protected void FillDataMembers(BindingContext bindingManager, object dataSource, string dataMember, string propertyName, bool isList, TreeNodeCollection nodes, int depth) {
            if (depth > MaximumDepth)
                return;
            if (!isList && selectLists)
                return;

            DataMemberNode dataMemberNode = new DataMemberNode(dataMember, propertyName, isList);
            nodes.Add(dataMemberNode);
            if (selectedItem != null && selectedItem.Equals(dataSource, dataMember)) {
                selectedNode = dataMemberNode;
            }            
            
            if (isList) {
                CurrencyManager listManager = (CurrencyManager)bindingManager[dataSource, dataMember];
                PropertyDescriptorCollection properties = listManager.GetItemProperties();
                for (int i = 0; i < properties.Count; i++) {
                    ListBindableAttribute listBindable = (ListBindableAttribute) properties[i].Attributes[typeof(ListBindableAttribute)];

                    // if the attribute exists and it is false, then skip this property.
                    //
                    if (listBindable != null && !listBindable.ListBindable)
                        continue;
                    FillDataMembers(bindingManager, dataSource, dataMember + "." + properties[i].Name, properties[i].Name, typeof(IList).IsAssignableFrom(properties[i].PropertyType), dataMemberNode.Nodes, depth + 1);
                }
            }
        }

        private int GetMaxItemWidth(TreeNodeCollection nodes) {

            int maxWidth = 0;

            // first, get the width of all our nodes
            //
            foreach (TreeNode node in nodes) {
                Rectangle bounds = node.Bounds;
                int w = bounds.Left + bounds.Width;
                bool expanded = node.IsExpanded;

                try {
                    maxWidth = Math.Max(w, maxWidth);
                    node.Expand();
                    maxWidth = Math.Max(maxWidth, GetMaxItemWidth(node.Nodes));
                }
                finally {
                    if (!expanded) {
                        node.Collapse();
                    }
                }
            }
            return maxWidth;
        }

        private void SetSelectedItem(TreeNode node) {
            selectedItem = null;

            if (node is DataMemberNode) {
                DataMemberNode dataMemberNode = (DataMemberNode) node;
                if (selectLists == dataMemberNode.IsList) {
                    selectedItem = new DesignBinding(dataMemberNode.DataSource, dataMemberNode.DataMember);
                }
            }
            else if (node is NoneNode) {
                selectedItem = DesignBinding.Null;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\designerframe.cs ===
//------------------------------------------------------------------------------
// <copyright file="DesignerFrame.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms.Design {

    using System.Collections;    
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.Design;
    using System.ComponentModel.Design;
    using System.Windows.Forms;
    using System.Drawing;
    using Microsoft.Win32;

    /// <include file='doc\DesignerFrame.uex' path='docs/doc[@for="DesignerFrame"]/*' />
    /// <internalonly/>
    /// <devdoc>
    ///     This class implements our design time document.  This is the outer window
    ///     that encompases a designer.  It maintains a control hierarchy that
    ///     looks like this:
    ///
    ///         DesignerFrame
    ///             ScrollableControl
    ///                 Designer 
    ///             Splitter
    ///             ScrollableControl
    ///                 Component Tray
    ///
    ///     The splitter and second scrollable control are created on demand
    ///     when a tray is added.
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class DesignerFrame : Control, IOverlayService, ISplitWindowService {
        private ISite               designerSite;
        private OverlayControl      designerRegion;
        private Splitter            splitter;
        private Control             designer;
        
       
        /// <include file='doc\DesignerFrame.uex' path='docs/doc[@for="DesignerFrame.DesignerFrame"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Windows.Forms.Design.DesignerFrame'/> class.</para>
        /// </devdoc>
        public DesignerFrame(ISite site) {
            this.Text = "DesignerFrame";
            this.designerSite = site;
            this.designerRegion = new OverlayControl(site);

            this.Controls.Add(designerRegion);
            
            // Now we must configure our designer to be at the correct
            // location, and setup the autoscrolling for its container.
            //
            designerRegion.AutoScroll = true;
            designerRegion.Dock = DockStyle.Fill;
            SystemEvents.UserPreferenceChanged += new UserPreferenceChangedEventHandler(OnUserPreferenceChanged);
        }
       
        protected override void Dispose(bool disposing) {
            if (disposing) {
                if (this.designer != null) {
                    Control designerHolder = this.designer;
                    this.designer = null;
                    designerHolder.Visible = false;
                    designerHolder.Parent = null;
                    SystemEvents.UserPreferenceChanged -= new UserPreferenceChangedEventHandler(OnUserPreferenceChanged);
                }
            }
            base.Dispose(disposing);
        }

        private void ForceDesignerRedraw(bool focus) {
            if (designer != null && designer.IsHandleCreated) {
                NativeMethods.SendMessage(designer.Handle, NativeMethods.WM_NCACTIVATE, focus ? 1 : 0, 0);
                SafeNativeMethods.RedrawWindow(designer.Handle, null, IntPtr.Zero, NativeMethods.RDW_FRAME);
            }
        }
        
        /// <include file='doc\DesignerFrame.uex' path='docs/doc[@for="DesignerFrame.Initialize"]/*' />
        /// <devdoc>
        ///     Initializes this frame with the given designer view.
        /// </devdoc>
        public void Initialize(Control view) {
            this.designer = view;

            if (designer is Form) {
                ((Form)designer).TopLevel = false;
            }
            
            designerRegion.Controls.Add(designer);
            SyncDesignerUI();
            
            designer.Visible = true;
            designer.Enabled = true;
        }

        /// <include file='doc\DesignerFrame.uex' path='docs/doc[@for="DesignerFrame.OnGotFocus"]/*' />
        /// <devdoc>
        ///     When we get an lose focus, we need to make sure the form
        ///     designer knows about it so it'll paint it's caption right.
        /// </devdoc>
        protected override void OnGotFocus(EventArgs e) {
            ForceDesignerRedraw(true);
            
            ISelectionService selSvc = (ISelectionService)designerSite.GetService(typeof(ISelectionService));
            if (selSvc != null) {
                Control ctrl = selSvc.PrimarySelection as Control;
                if (ctrl != null) {
                    UnsafeNativeMethods.NotifyWinEvent((int)AccessibleEvents.Focus, ctrl.Handle, NativeMethods.OBJID_CLIENT, 0);
                }
            }
        }
        
        /// <include file='doc\DesignerFrame.uex' path='docs/doc[@for="DesignerFrame.OnLostFocus"]/*' />
        /// <devdoc>
        ///     When we get an lose focus, we need to make sure the form
        ///     designer knows about it so it'll paint it's caption right.
        /// </devdoc>
        protected override void OnLostFocus(EventArgs e) {
            ForceDesignerRedraw(false);
        }

        void OnSplitterMoved(object sender, SplitterEventArgs e) {
            // Dirty the designer.
            //
            IComponentChangeService cs = designerSite.GetService(typeof(IComponentChangeService)) as IComponentChangeService;
            if (cs != null) {
                try {
                    cs.OnComponentChanging(designerSite.Component, null);
                    cs.OnComponentChanged(designerSite.Component, null, null, null);
                }
                catch {
                }
            }
        }

        void OnUserPreferenceChanged(object sender, UserPreferenceChangedEventArgs e) {
            if (e.Category == UserPreferenceCategory.Window) {
                SyncDesignerUI();
            }
        }

        /// <include file='doc\DesignerFrame.uex' path='docs/doc[@for="DesignerFrame.ProcessDialogKey"]/*' />
        /// <devdoc>
        ///     We override this to do nothing.  Otherwise, all the nice keyboard m
        ///     messages we want would get run through the Form's keyboard handling
        ///     procedure.
        /// </devdoc>
        protected override bool ProcessDialogKey(Keys keyData) {
            return false;
        }

        void SyncDesignerUI() {
            Size selectionSize = new Size(0, 0);
            ISelectionUIService uis = (ISelectionUIService)designerSite.GetService(typeof(ISelectionUIService));
            if (uis != null) {
                selectionSize = uis.GetAdornmentDimensions(AdornmentType.Maximum);
            }
            
            designerRegion.AutoScrollMargin = selectionSize;
            designer.Location = new Point(selectionSize.Width, selectionSize.Height);
            
            if (uis != null) {
                uis.SyncSelection();
            }

        }

        /// <include file='doc\DesignerFrame.uex' path='docs/doc[@for="DesignerFrame.WndProc"]/*' />
        /// <devdoc>
        ///     Base wndProc. All messages are sent to wndProc after getting filtered
        ///     through the preProcessMessage function. Inheriting controls should
        ///     call base.wndProc for any messages that they don't handle.
        /// </devdoc>
        protected override void WndProc(ref Message m) {
            switch (m.Msg) {
                // Provide keyboard access for scrolling
                case NativeMethods.WM_KEYDOWN:
                    int wScrollNotify = 0;
                    int msg = 0;

                    int keycode = (int)m.WParam & 0xFFFF;
                    switch ((Keys)keycode) {
                        case Keys.Up:
                            wScrollNotify = NativeMethods.SB_LINEUP;
                            msg = NativeMethods.WM_VSCROLL;
                            break; 
                        case Keys.Down:
                            wScrollNotify = NativeMethods.SB_LINEDOWN;
                            msg = NativeMethods.WM_VSCROLL;
                            break; 
                        case Keys.PageUp:
                            wScrollNotify = NativeMethods.SB_PAGEUP;
                            msg = NativeMethods.WM_VSCROLL;
                            break; 
                        case Keys.PageDown:
                            wScrollNotify = NativeMethods.SB_PAGEDOWN;
                            msg = NativeMethods.WM_VSCROLL;
                            break; 
                        case Keys.Home:
                            wScrollNotify = NativeMethods.SB_TOP;
                            msg = NativeMethods.WM_VSCROLL;
                            break; 
                        case Keys.End:
                            wScrollNotify = NativeMethods.SB_BOTTOM;
                            msg = NativeMethods.WM_VSCROLL;
                            break; 
                        case Keys.Left:
                            wScrollNotify = NativeMethods.SB_LINEUP;
                            msg = NativeMethods.WM_HSCROLL;
                            break; 
                        case Keys.Right:
                            wScrollNotify = NativeMethods.SB_LINEDOWN;
                            msg = NativeMethods.WM_HSCROLL;
                            break; 
                    }
                    if ((msg == NativeMethods.WM_VSCROLL)
                        || (msg == NativeMethods.WM_HSCROLL)) {
                        // Send a message to ourselves to scroll
                        NativeMethods.SendMessage(designerRegion.Handle, msg, NativeMethods.Util.MAKELONG(wScrollNotify, 0), 0);
                        return;
                    }
                    break;
                case NativeMethods.WM_CONTEXTMENU:
                    NativeMethods.SendMessage(designer.Handle, m.Msg, m.WParam, m.LParam);
                    return;
            }
        
            base.WndProc(ref m);
        }
        
        /// <include file='doc\DesignerFrame.uex' path='docs/doc[@for="DesignerFrame.IOverlayService.PushOverlay"]/*' />
        /// <devdoc>
        ///     Pushes the given control on top of the overlay list.  This is a "push"
        ///     operation, meaning that it forces this control to the top of the existing
        ///     overlay list.
        /// </devdoc>
        void IOverlayService.PushOverlay(Control control) {
            designerRegion.PushOverlay(control);
        }

        /// <include file='doc\DesignerFrame.uex' path='docs/doc[@for="DesignerFrame.IOverlayService.RemoveOverlay"]/*' />
        /// <devdoc>
        ///     Removes the given control from the overlay list.  Unlike pushOverlay,
        ///     this can remove a control from the middle of the overlay list.
        /// </devdoc>
        void IOverlayService.RemoveOverlay(Control control) {
            designerRegion.RemoveOverlay(control);
        }
        
        /// <include file='doc\DesignerFrame.uex' path='docs/doc[@for="DesignerFrame.ISplitWindowService.AddSplitWindow"]/*' />
        /// <devdoc>
        ///      Requests the service to add a window 'pane'.
        /// </devdoc>
        void ISplitWindowService.AddSplitWindow(Control window) {
            if (splitter == null) {
                splitter = new Splitter();
                splitter.BackColor = SystemColors.Control;
                splitter.BorderStyle = BorderStyle.Fixed3D;
                splitter.Height = 7;
                splitter.Dock = DockStyle.Bottom;
                splitter.SplitterMoved += new SplitterEventHandler(this.OnSplitterMoved);
            }
            
            SuspendLayout();
            window.Dock = DockStyle.Bottom;
            
            // Compute a minimum height for this window.
            //
            int minHeight = 80;
            if (window.Height < minHeight) {
                window.Height = minHeight;
            }
            
            Controls.Add(splitter);
            Controls.Add(window);
            ResumeLayout();
        }

        /// <include file='doc\DesignerFrame.uex' path='docs/doc[@for="DesignerFrame.ISplitWindowService.RemoveSplitWindow"]/*' />
        /// <devdoc>
        ///      Requests the service to remove a window 'pane'.
        /// </devdoc>
        void ISplitWindowService.RemoveSplitWindow(Control window) {
            SuspendLayout();
            Controls.Remove(window);
            Controls.Remove(splitter);
            ResumeLayout();
        }
        
        /// <include file='doc\DesignerFrame.uex' path='docs/doc[@for="DesignerFrame.OverlayControl"]/*' />
        /// <devdoc>
        ///     This is a scrollable control that supports additional floating
        ///     overlay controls.
        /// </devdoc>
        private class OverlayControl : ScrollableControl {
            private ArrayList            overlayList;
            private bool[]               overlayVisibility;
            private IServiceProvider provider;
            
            /// <include file='doc\DesignerFrame.uex' path='docs/doc[@for="DesignerFrame.OverlayControl.OverlayControl"]/*' />
            /// <devdoc>
            ///     Creates a new overlay control.
            /// </devdoc>
            public OverlayControl(IServiceProvider provider) {
                this.provider = provider;
                overlayList = new ArrayList();
                AutoScroll = true;
            }
            
            protected override AccessibleObject CreateAccessibilityInstance() {
                return new OverlayControlAccessibleObject(this);
            }
            
            /// <include file='doc\DesignerFrame.uex' path='docs/doc[@for="DesignerFrame.OverlayControl.OverlayVisible"]/*' />
            /// <devdoc>
            ///     Determines if the overlay is currently visible.
            /// </devdoc>
            public bool OverlayVisible {
                set {
                    if (!value) {
                        if (overlayVisibility != null) {
                            return;
                        }
                        
                        overlayVisibility = new bool[overlayList.Count];
                    }
                    
                    for (int i = 0; i < overlayList.Count; i++) {
                        Control c = (Control)overlayList[i];
                        if (value) {
                            if (overlayVisibility != null && overlayVisibility.Length > i) {
                                c.Visible = overlayVisibility[i];
                            }
                        }
                        else {
                            overlayVisibility[i] = c.Visible;
                            c.Visible = false;
                        }
                    }
                    
                    if (value) {
                        overlayVisibility = null;
                    }
                }
            }
            
            /// <include file='doc\DesignerFrame.uex' path='docs/doc[@for="DesignerFrame.OverlayControl.OnCreateControl"]/*' />
            /// <devdoc>
            ///     At handle creation time we request the designer's handle and
            ///     parent it.
            /// </devdoc>
            protected override void OnCreateControl() {
                base.OnCreateControl();
                
                // Loop through all of the overlays, create them, and hook them up
                //
                if (overlayList != null) {
                    foreach(Control c in overlayList) {
                        ParentOverlay(c);
                    }
                }
                
                // We've reparented everything, which means that our selection UI is probably
                // out of sync.  Ask it to sync.
                //
                ISelectionUIService selUISvc = (ISelectionUIService)provider.GetService(typeof(ISelectionUIService));
                if (selUISvc != null) {
                    selUISvc.SyncSelection();
                }
            }

            /// <include file='doc\DesignerFrame.uex' path='docs/doc[@for="DesignerFrame.OverlayControl.OnLayout"]/*' />
            /// <devdoc>
            ///     We override onLayout to provide our own custom layout functionality.
            ///     This just overlaps all of the controls.
            /// </devdoc>
            protected override void OnLayout(LayoutEventArgs e) {
                base.OnLayout(e);
                Rectangle client = DisplayRectangle;

                // Loop through all of the overlays and size them.  Also make
                // sure that they are still on top of the zorder, because a handle
                // recreate could have changed this.
                //
                if (overlayList != null) {
                    foreach(Control c in overlayList) {
                        c.Bounds = client;
                    }
                }
            }

            /// <include file='doc\DesignerFrame.uex' path='docs/doc[@for="DesignerFrame.OverlayControl.ParentOverlay"]/*' />
            /// <devdoc>
            ///     Called to parent an overlay window into our document.  This assumes that
            ///     we call in reverse stack order, as it always pushes to the top of the
            ///     z-order.
            /// </devdoc>
            private void ParentOverlay(Control control) {
                NativeMethods.SetParent(control.Handle, Handle);
                SafeNativeMethods.SetWindowPos(control.Handle, (IntPtr)NativeMethods.HWND_TOP, 0, 0, 0, 0,
                                     NativeMethods.SWP_NOSIZE | NativeMethods.SWP_NOMOVE);
            }
            
            /// <include file='doc\DesignerFrame.uex' path='docs/doc[@for="DesignerFrame.OverlayControl.PushOverlay"]/*' />
            /// <devdoc>
            ///     Pushes the given control on top of the overlay list.  This is a "push"
            ///     operation, meaning that it forces this control to the top of the existing
            ///     overlay list.
            /// </devdoc>
            public void PushOverlay(Control control) {
                Debug.Assert(overlayList.IndexOf(control)==-1, "Duplicate overlay in overlay service :" + control.GetType().FullName);
                overlayList.Add(control);

                // We cheat a bit here.  We need to have these components parented, but we don't
                // want them to effect our layout.
                //
                if (IsHandleCreated) {
                    ParentOverlay(control);
                    control.Bounds = DisplayRectangle;
                }
            }

            /// <include file='doc\DesignerFrame.uex' path='docs/doc[@for="DesignerFrame.OverlayControl.RemoveOverlay"]/*' />
            /// <devdoc>
            ///     Removes the given control from the overlay list.  Unlike pushOverlay,
            ///     this can remove a control from the middle of the overlay list.
            /// </devdoc>
            public void RemoveOverlay(Control control) {
                Debug.Assert(overlayList.IndexOf(control)!=-1, "Control is not in overlay service :" + control.GetType().FullName);
                overlayList.Remove(control);
                control.Visible = false;
                control.Parent = null;
            }
            
            /// <devdoc>
            ///     Need to know when child windows are created so we can properly set the Z-order
            /// </devdoc>
            protected override void WndProc(ref Message m) {
                base.WndProc(ref m);
                
                if (m.Msg == NativeMethods.WM_PARENTNOTIFY && NativeMethods.Util.LOWORD((int)m.WParam) == (short)NativeMethods.WM_CREATE) {
                    if (overlayList != null) {
                        bool ourWindow = false;
                        foreach(Control c in overlayList) {
                            if (c.IsHandleCreated && m.LParam == c.Handle) {
                                ourWindow = true;
                                break;
                            }
                        }
                        
                        if (!ourWindow) {
                            foreach(Control c in overlayList) {
                                SafeNativeMethods.SetWindowPos(c.Handle, (IntPtr)NativeMethods.HWND_TOP, 0, 0, 0, 0,
                                                     NativeMethods.SWP_NOSIZE | NativeMethods.SWP_NOMOVE);
                            }
                        }
                    }
                }
                else if ((m.Msg == NativeMethods.WM_VSCROLL || m.Msg == NativeMethods.WM_HSCROLL) && provider != null) {
                    ISelectionUIService selUISvc = (ISelectionUIService)provider.GetService(typeof(ISelectionUIService));
                    if (selUISvc != null) {
                        selUISvc.SyncComponent(null);
                    }
                }
            }
            
            public class OverlayControlAccessibleObject : Control.ControlAccessibleObject {
                public OverlayControlAccessibleObject(OverlayControl owner) : base(owner) {
                }
                
                public override AccessibleObject HitTest(int x, int y) {
                    // Since the SelectionUIOverlay in first in the z-order, it normally gets
                    // returned from accHitTest. But we'd rather expose the form that is being
                    // designed.
                    //
                    foreach(Control c in Owner.Controls) {
                        AccessibleObject cao = c.AccessibilityObject;
                        if (cao.Bounds.Contains(x, y)) {
                            return cao;
                        }
                    }
                    
                    return base.HitTest(x, y);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\eventhandlerservice.cs ===
//------------------------------------------------------------------------------
// <copyright file="EventHandlerService.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms.Design {

    using System.Diagnostics;
    using System;
    using System.Windows.Forms;

    /// <include file='doc\EventHandlerService.uex' path='docs/doc[@for="EventHandlerService"]/*' />
    /// <internalonly/>
    /// <devdoc>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public sealed class EventHandlerService : IEventHandlerService {

        // We cache the last requested handler for speed.
        //
        private object  lastHandler;
        private Type    lastHandlerType;

        // The handler stack
        //
        private HandlerEntry handlerHead;

        // Our change event
        //
        private EventHandler changedEvent;

        private readonly Control focusWnd;

        /// <include file='doc\EventHandlerService.uex' path='docs/doc[@for="EventHandlerService.EventHandlerService"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public EventHandlerService(Control focusWnd) {
            this.focusWnd = focusWnd;
        }


        /// <include file='doc\EventHandlerService.uex' path='docs/doc[@for="EventHandlerService.EventHandlerChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public event EventHandler EventHandlerChanged {
            add {
                changedEvent += value;
            }
            remove {
                changedEvent -= value;
            }
        }

        /// <include file='doc\EventHandlerService.uex' path='docs/doc[@for="EventHandlerService.FocusWindow"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Control FocusWindow {
            get {
                return focusWnd;
            }
        }
        
        /// <include file='doc\EventHandlerService.uex' path='docs/doc[@for="EventHandlerService.GetHandler"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       Gets the currently active event handler of the specified type.</para>
        /// </devdoc>
        public object GetHandler(Type handlerType) {
            if (handlerType == lastHandlerType) {
                return lastHandler;
            }

            for (HandlerEntry entry = handlerHead; entry != null; entry = entry.next) {
                if (entry.handler != null && handlerType.IsInstanceOfType(entry.handler)) {
                    lastHandlerType = handlerType;
                    lastHandler = entry.handler;
                    return entry.handler;
                }
            }
            return null;
        }

        /// <include file='doc\EventHandlerService.uex' path='docs/doc[@for="EventHandlerService.OnEventHandlerChanged"]/*' />
        /// <devdoc>
        ///      Fires an OnEventHandlerChanged event.
        /// </devdoc>
        private void OnEventHandlerChanged(EventArgs e) {
            if (changedEvent != null) {
                ((EventHandler)changedEvent)(this, e);
            }
        }

        /// <include file='doc\EventHandlerService.uex' path='docs/doc[@for="EventHandlerService.PopHandler"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       Pops
        ///       the given handler off of the stack.</para>
        /// </devdoc>
        public void PopHandler(object handler) {
            for (HandlerEntry entry = handlerHead; entry != null; entry = entry.next) {
                if (entry.handler == handler) {
                    handlerHead = entry.next;
                    lastHandler = null;
                    lastHandlerType = null;
                    OnEventHandlerChanged(EventArgs.Empty);
                    break;
                }
            }
        }

        /// <include file='doc\EventHandlerService.uex' path='docs/doc[@for="EventHandlerService.PushHandler"]/*' />
        /// <devdoc>
        ///    <para>Pushes a new event handler on the stack.</para>
        /// </devdoc>
        public void PushHandler(object handler) {
            handlerHead = new HandlerEntry(handler, handlerHead);
            OnEventHandlerChanged(EventArgs.Empty);
        }

        /// <include file='doc\EventHandlerService.uex' path='docs/doc[@for="EventHandlerService.HandlerEntry"]/*' />
        /// <devdoc>
        ///     Contains a single node of our handler stack.  We typically
        ///     have very few handlers, and the handlers are long-living, so
        ///     I just implemented this as a linked list.
        /// </devdoc>
        private sealed class HandlerEntry {
            public object       handler;
            public HandlerEntry next;

            /// <include file='doc\EventHandlerService.uex' path='docs/doc[@for="EventHandlerService.HandlerEntry.HandlerEntry"]/*' />
            /// <devdoc>
            ///     Creates a new handler entry objet.
            /// </devdoc>
            public HandlerEntry(object handler, HandlerEntry next) {
                this.handler = handler;
                this.next = next;
            }
        }
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\designerextenders.cs ===
//------------------------------------------------------------------------------
// <copyright file="DesignerExtenders.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms.Design {
    
    using System;
    using System.CodeDom;
    using System.CodeDom.Compiler;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Design;
    using System.Diagnostics;
    using System.Globalization;
    using System.Reflection;

    /// <devdoc>
    ///     This class provides the Modifiers property to components.  It is shared between
    ///     the document designer and the component document designer.
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class DesignerExtenders {
    
        private IExtenderProvider[] providers;
        private IExtenderProviderService extenderService;
    
        /// <include file='doc\DesignerExtenders.uex' path='docs/doc[@for="DesignerExtenders.AddExtenderProviders"]/*' />
        /// <devdoc>
        ///     This is called by a root designer to add the correct extender providers.
        /// </devdoc>
        public DesignerExtenders(IExtenderProviderService ex) {
            this.extenderService = ex;
            if (providers == null) {
                providers = new IExtenderProvider[] {
                    new ModifiersExtenderProvider(),
                    new ModifiersInheritedExtenderProvider()
                };
            }
            
            for (int i = 0; i < providers.Length; i++) {
                ex.AddExtenderProvider(providers[i]);
            }
        }
        
        /// <include file='doc\DesignerExtenders.uex' path='docs/doc[@for="DesignerExtenders.RemoveExtenderProviders"]/*' />
        /// <devdoc>
        ///      This is called at the appropriate time to remove any extra extender
        ///      providers previously added to the designer host.
        /// </devdoc>
        public void Dispose() {
            if (extenderService != null && providers != null) {
                for (int i = 0; i < providers.Length; i++) {
                    extenderService.RemoveExtenderProvider(providers[i]);
                }
                
                providers = null;
                extenderService = null;
            }
        }
        
        /// <include file='doc\DesignerExtenders.uex' path='docs/doc[@for="DesignerExtenders.CSharpExtenderProvider"]/*' />
        /// <devdoc>
        ///      This extender provider provides the "Modifiers" property.
        /// </devdoc>
        [
        ProvideProperty("Modifiers", typeof(IComponent))
        ]
        private class ModifiersExtenderProvider : IExtenderProvider {
            private IComponent baseComponent;

            /// <include file='doc\DesignerExtenders.uex' path='docs/doc[@for="DesignerExtenders.CSharpExtenderProvider.CanExtend"]/*' />
            /// <devdoc>
            ///     Determines if ths extender provider can extend the given object.  We extend
            ///     all objects, so we always return true.
            /// </devdoc>
            public bool CanExtend(object o) {

                if (! (o is IComponent)) {
                    return false;
                }
                
                // We don't add modifiers to the base component.
                //
                if (baseComponent == null) {
                    ISite site = ((IComponent)o).Site;
                    if (site != null) {
                        IDesignerHost host = (IDesignerHost)site.GetService(typeof(IDesignerHost));
                        if (host != null) {
                            baseComponent = host.RootComponent;
                        }
                    }
                }
                
                if (o == baseComponent) {
                    return false;
                }

                // Now see if this object is inherited.  If so, then we don't want to
                // extend.
                //
                if (!TypeDescriptor.GetAttributes(o)[typeof(InheritanceAttribute)].Equals(InheritanceAttribute.NotInherited)) {
                    return false;
                }

                return true;
            }

            /// <include file='doc\DesignerExtenders.uex' path='docs/doc[@for="DesignerExtenders.CSharpExtenderProvider.GetModifiers"]/*' />
            /// <devdoc>
            ///     This is an extender property that we offer to all components
            ///     on the form.  It implements the "Modifiers" property, which
            ///     is an enum represneing the "public/protected/private" scope
            ///     of a component.
            /// </devdoc>
            [
            DesignOnly(true),
            TypeConverter(typeof(ModifierConverter)),
            DefaultValue(MemberAttributes.Private),
            SRDescription(SR.DesignerPropModifiers),
            Category("Design")
            ]
            public MemberAttributes GetModifiers(IComponent comp) {
                ISite site = comp.Site;
                if (site != null) {
                    IDictionaryService dictionary = (IDictionaryService)site.GetService(typeof(IDictionaryService));
                    if (dictionary != null) {
                        object value = dictionary.GetValue(GetType());
                        if (value is MemberAttributes) {
                            return (MemberAttributes)value;
                        }
                    }
                }
                
                // Check to see if someone offered up a "DefaultModifiers" property so we can
                // decide a default.
                //
                PropertyDescriptorCollection props = TypeDescriptor.GetProperties(comp);
                PropertyDescriptor prop = props["DefaultModifiers"];
                if (prop != null && prop.PropertyType == typeof(MemberAttributes)) {
                    return (MemberAttributes)prop.GetValue(comp);
                }
                
                return MemberAttributes.Private;
            }

            /// <include file='doc\DesignerExtenders.uex' path='docs/doc[@for="DesignerExtenders.CSharpExtenderProvider.SetModifiers"]/*' />
            /// <devdoc>
            ///     This is an extender property that we offer to all components
            ///     on the form.  It implements the "Modifiers" property, which
            ///     is an enum represneing the "public/protected/private" scope
            ///     of a component.
            /// </devdoc>
            public void SetModifiers(IComponent comp, MemberAttributes modifiers) {
                ISite site = comp.Site;
                if (site != null) {
                    IDictionaryService dictionary = (IDictionaryService)site.GetService(typeof(IDictionaryService));
                    if (dictionary != null) {
                        dictionary.SetValue(GetType(), modifiers);
                    }
                }
            }
        }

        /// <include file='doc\DesignerExtenders.uex' path='docs/doc[@for="DesignerExtenders.CSharpInheritedExtenderProvider"]/*' />
        /// <devdoc>
        ///      This extender provider offers up read-only versions of
        ///      "Modifiers" for inherited components.
        /// </devdoc>
        [
        ProvideProperty("Modifiers", typeof(IComponent))
        ]
        private class ModifiersInheritedExtenderProvider : IExtenderProvider {
            private IComponent baseComponent;

            /// <include file='doc\DesignerExtenders.uex' path='docs/doc[@for="DesignerExtenders.CSharpInheritedExtenderProvider.CanExtend"]/*' />
            /// <devdoc>
            ///     Determines if ths extender provider can extend the given object.  We extend
            ///     all objects, so we always return true.
            /// </devdoc>
            public bool CanExtend(object o) {
            
                if (! (o is IComponent)) {
                    return false;
                }
                
                // We don't add modifiers to the base component.
                //
                if (baseComponent == null) {
                    ISite site = ((IComponent)o).Site;
                    if (site != null) {
                        IDesignerHost host = (IDesignerHost)site.GetService(typeof(IDesignerHost));
                        if (host != null) {
                            baseComponent = host.RootComponent;
                        }
                    }
                }
                
                if (o == baseComponent) {
                    return false;
                }

                // Now see if this object is inherited.  If so, then we are interested in it.
                //
                AttributeCollection attributes = TypeDescriptor.GetAttributes(o);
                if (!attributes[typeof(InheritanceAttribute)].Equals(InheritanceAttribute.NotInherited)) {
                    return true;
                }

                return false;
            }

            /// <include file='doc\DesignerExtenders.uex' path='docs/doc[@for="DesignerExtenders.CSharpInheritedExtenderProvider.GetModifiers"]/*' />
            /// <devdoc>
            ///     This is an extender property that we offer to all components
            ///     on the form.  It implements the "Modifiers" property, which
            ///     is an enum represneing the "public/protected/private" scope
            ///     of a component.
            /// </devdoc>
            [
            DesignOnly(true),
            TypeConverter(typeof(ModifierConverter)),
            DefaultValue(MemberAttributes.Private),
            SRDescription(SR.DesignerPropModifiers),
            Category("Design")
            ]
            public MemberAttributes GetModifiers(IComponent comp) {
                Debug.Assert(baseComponent != null, "CanExtend should have been called to set this up");
                Type baseType = baseComponent.GetType();
                
                ISite site = comp.Site;
                if (site != null) {
                    string name = site.Name;
                    if (name != null) {
                        FieldInfo field = baseType.GetField(name, BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static);
                        if (field != null) {
                            if (field.IsPrivate)            return MemberAttributes.Private;
                            if (field.IsPublic)             return MemberAttributes.Public;
                            if (field.IsFamily)             return MemberAttributes.Family;
                            if (field.IsAssembly)           return MemberAttributes.Assembly;
                        }
                        else {
                            // Visual Basic uses a property called Foo and generates a field called _Foo. We need to check the 
                            // visibility of this accessor to fix the modifiers up.
                            //
                            PropertyInfo prop = baseType.GetProperty(name, BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static);
                            if (prop != null) {
                                MethodInfo[] accessors = prop.GetAccessors(true);
                                if (accessors != null && accessors.Length > 0) {
                                    MethodInfo mi = accessors[0];
                                    if (mi != null) {
                                        if (mi.IsPrivate)            return MemberAttributes.Private;
                                        if (mi.IsPublic)             return MemberAttributes.Public;
                                        if (mi.IsFamily)             return MemberAttributes.Family;
                                        if (mi.IsAssembly)           return MemberAttributes.Assembly;
                                    }
                                }
                            }
                        }
                    }
                }
                return MemberAttributes.Private;
            }
        }

        private class ModifierConverter : TypeConverter {
        
            /// <devdoc>
            ///    <para>Gets a value indicating whether this converter can
            ///       convert an object in the given source type to the native type of the converter
            ///       using the context.</para>
            /// </devdoc>
            public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) {
                return GetConverter(context).CanConvertFrom(context, sourceType);
            }
    
            /// <devdoc>
            ///    <para>Gets a value indicating whether this converter can
            ///       convert an object to the given destination type using the context.</para>
            /// </devdoc>
            public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType) {
                return GetConverter(context).CanConvertTo(context, destinationType);
            }
    
            /// <devdoc>
            ///    <para>Converts the given object to the converter's native type.</para>
            /// </devdoc>
            public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) {
                return GetConverter(context).ConvertFrom(context, culture, value);
            }
    
            /// <devdoc>
            ///    <para>Converts the given value object to
            ///       the specified destination type using the specified context and arguments.</para>
            /// </devdoc>
            public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
                return GetConverter(context).ConvertTo(context, culture, value, destinationType);
            }
    
            /// <devdoc>
            /// <para>Re-creates an <see cref='System.Object'/> given a set of property values for the
            ///    object.</para>
            /// </devdoc>
            public override object CreateInstance(ITypeDescriptorContext context, IDictionary propertyValues) {
                return GetConverter(context).CreateInstance(context, propertyValues);
            }
    
            /// <devdoc>
            ///     Returns the type converter for the member attributes enum.  We search the context
            ///     for a code dom provider that can provide us more information.
            /// </devdoc>
            private TypeConverter GetConverter(ITypeDescriptorContext context) {
            
                TypeConverter modifierConverter = null;
                
                if (context != null) {
                    CodeDomProvider provider = (CodeDomProvider)context.GetService(typeof(CodeDomProvider));
                    if (provider != null) {
                        modifierConverter = provider.GetConverter(typeof(MemberAttributes));
                    }
                }
                
                if (modifierConverter == null) {
                    modifierConverter = TypeDescriptor.GetConverter(typeof(MemberAttributes));
                }
                
                return modifierConverter;
            }
            
            /// <devdoc>
            ///    <para>Gets a value indicating whether changing a value on this object requires a 
            ///       call to <see cref='System.ComponentModel.TypeConverter.CreateInstance'/> to create a new value,
            ///       using the specified context.</para>
            /// </devdoc>
            public override bool GetCreateInstanceSupported(ITypeDescriptorContext context) {
                return GetConverter(context).GetCreateInstanceSupported(context);
            }
    
            /// <devdoc>
            ///    <para>Gets a collection of properties for
            ///       the type of array specified by the value parameter using the specified context and
            ///       attributes.</para>
            /// </devdoc>
            public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes) {
                return GetConverter(context).GetProperties(context, value, attributes);
            }
           
            /// <devdoc>
            ///    <para>Gets a value indicating
            ///       whether this object supports properties using the
            ///       specified context.</para>
            /// </devdoc>
            public override bool GetPropertiesSupported(ITypeDescriptorContext context) {
                return GetConverter(context).GetPropertiesSupported(context);
            }
            
            /// <devdoc>
            ///    <para>Gets a collection of standard values for the data type this type converter is
            ///       designed for.</para>
            /// </devdoc>
            public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context) {
            
                // We restrict the set of standard values to those within the access mask.
                //
                StandardValuesCollection values = GetConverter(context).GetStandardValues(context);
                if (values != null && values.Count > 0) {
                    bool needMassage = false;
                    foreach(MemberAttributes value in values) {
                        if ((value & MemberAttributes.AccessMask) == 0) {
                            needMassage = true;
                            break;
                        }
                    }
                    
                    if (needMassage) {
                        ArrayList list = new ArrayList(values.Count);
                        
                        foreach(MemberAttributes value in values) {
                            if ((value & MemberAttributes.AccessMask) != 0 && value != MemberAttributes.AccessMask) {
                                list.Add(value);
                            }
                        }
                        
                        values = new StandardValuesCollection(list);
                    }
                }
                
                return values;
            }
    
            /// <devdoc>
            ///    <para>Gets a value indicating whether the collection of standard values returned from
            ///    <see cref='System.ComponentModel.TypeConverter.GetStandardValues'/> is an exclusive 
            ///       list of possible values, using the specified context.</para>
            /// </devdoc>
            public override bool GetStandardValuesExclusive(ITypeDescriptorContext context) {
                return GetConverter(context).GetStandardValuesExclusive(context);
            }
    
            /// <devdoc>
            ///    <para>Gets a value indicating
            ///       whether this object
            ///       supports a standard set of values that can be picked
            ///       from a list using the specified context.</para>
            /// </devdoc>
            public override bool GetStandardValuesSupported(ITypeDescriptorContext context) {
                return GetConverter(context).GetStandardValuesSupported(context);
            }
            
            /// <devdoc>
            ///    <para>Gets
            ///       a value indicating whether the given value object is valid for this type.</para>
            /// </devdoc>
            public override bool IsValid(ITypeDescriptorContext context, object value) {
                return GetConverter(context).IsValid(context, value);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\folderbrowserdialogdesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="FolderBrowserDialogDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms.Design {

    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Windows.Forms;
    using Microsoft.Win32;

    /// <devdoc>
    ///      This is the designer for FolderBrowserDialog components.
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class FolderBrowserDialogDesigner : ComponentDesigner {
        public override void OnSetComponentDefaults() {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\dockeditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="DockEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms.Design {
    
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System;    
    using System.ComponentModel.Design;
    using Microsoft.Win32;
    using System.Diagnostics;
    using System.Drawing;
    using System.Design;
    
    using System.Drawing.Design;
    using System.Windows.Forms;
    using System.Windows.Forms.ComponentModel;
    using System.Windows.Forms.Design;

    /// <include file='doc\DockEditor.uex' path='docs/doc[@for="DockEditor"]/*' />
    /// <internalonly/>
    /// <devdoc>
    ///    <para>
    ///       Implements the design time editor for specifying the
    ///    <see cref='System.Windows.Forms.Control.Dock'/> property.
    ///
    ///    </para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public sealed class DockEditor : UITypeEditor {
        private DockUI dockUI;

        /// <include file='doc\DockEditor.uex' path='docs/doc[@for="DockEditor.EditValue"]/*' />
        /// <devdoc>
        ///      Edits the given object value using the editor style provided by
        ///      GetEditorStyle.  A service provider is provided so that any
        ///      required editing services can be obtained.
        /// </devdoc>
        public override object EditValue(ITypeDescriptorContext context,  IServiceProvider  provider, object value) {

            object returnValue = value;

            if (provider != null) {
                IWindowsFormsEditorService edSvc = (IWindowsFormsEditorService)provider.GetService(typeof(IWindowsFormsEditorService));

                if (edSvc != null) {
                    if (dockUI == null) {
                        dockUI = new DockUI(this);
                    }
                    dockUI.Start(edSvc, value);
                    edSvc.DropDownControl(dockUI);
                    value = dockUI.Value;
                    dockUI.End();
                }
            }

            return value;
        }

        /// <include file='doc\DockEditor.uex' path='docs/doc[@for="DockEditor.GetEditStyle"]/*' />
        /// <devdoc>
        ///      Retrieves the editing style of the Edit method.  If the method
        ///      is not supported, this will return None.
        /// </devdoc>
        public override UITypeEditorEditStyle GetEditStyle(ITypeDescriptorContext context) {
            return UITypeEditorEditStyle.DropDown;
        }

        /// <include file='doc\DockEditor.uex' path='docs/doc[@for="DockEditor.DockUI"]/*' />
        /// <devdoc>
        ///     User Interface for the DockEditor.
        /// </devdoc>
        /// <internalonly/>
        private class DockUI : Control {

            // Even though the selections are mutually exclusive, I'm using
            // CheckBoxes instead of RadioButtons because RadioButtons fire Click
            // events whenever they get focus, which is bad when the user is trying
            // to tab to a specific control using the keyboard.
            private ContainerPlaceholder container = new ContainerPlaceholder();
            private CheckBox fill = new DockEditorCheckBox();
            private CheckBox left = new DockEditorCheckBox();
            private CheckBox right = new DockEditorCheckBox();
            private CheckBox top = new DockEditorCheckBox();
            private CheckBox bottom = new DockEditorCheckBox();
            private CheckBox none = new DockEditorCheckBox();
            private CheckBox[] upDownOrder;
            private CheckBox[] leftRightOrder;
            private CheckBox[] tabOrder;
            private DockEditor editor = null;
            private object value;
            private IWindowsFormsEditorService edSvc;

            public DockUI(DockEditor editor) {
                this.editor = editor;
                upDownOrder = new CheckBox[] { top, fill, bottom, none};
                leftRightOrder = new CheckBox[] { left, fill, right};
                tabOrder = new CheckBox[] { top, left, fill, right, bottom, none};

                InitializeComponent();
            }
            
            public object Value { 
                get {
                    return value;
                }
            }
            
            public void End() {
                edSvc = null;
                value = null;
            }

            public virtual DockStyle GetDock(CheckBox btn) {
                if (top == btn) {
                    return DockStyle.Top;
                }
                else if (left == btn) {
                    return DockStyle.Left;
                }
                else if (bottom == btn) {
                    return DockStyle.Bottom;
                }
                else if (right == btn) {
                    return DockStyle.Right;
                }
                else if (fill == btn) {
                    return DockStyle.Fill;
                }
                return DockStyle.None;
            }
            
            private void InitializeComponent() {
                SetBounds(0, 0, 94, 116);

                this.BackColor = SystemColors.Control;
                this.ForeColor = SystemColors.ControlText;

                none.Anchor = AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right;
                none.Location = new Point(2, 94);
                none.Size = new Size(90, 24);
                none.Text = DockStyle.None.ToString();
                none.TabIndex = 0;
                none.TabStop = true;
                none.Appearance = Appearance.Button;
                none.Click += new EventHandler(this.OnClick);
                none.KeyDown += new KeyEventHandler(this.OnKeyDown);
                none.AccessibleName = SR.GetString(SR.DockEditorNoneAccName);

                container.Anchor = AnchorStyles.Top | AnchorStyles.Left | AnchorStyles.Bottom | AnchorStyles.Right;
                container.Location = new Point(2, 2);
                container.Size = new Size(90, 90);
                
                none.Dock = DockStyle.Bottom;
                container.Dock = DockStyle.Fill;

                right.Dock = DockStyle.Right;
                right.Size = new Size(20,20);
                right.TabIndex = 4;
                right.TabStop = true;
                right.Text = " "; // Needs at least one character so focus rect will show.
                right.Appearance = Appearance.Button;
                right.Click += new EventHandler(this.OnClick);
                right.KeyDown += new KeyEventHandler(this.OnKeyDown);
                right.AccessibleName = SR.GetString(SR.DockEditorRightAccName);

                left.Dock = DockStyle.Left;
                left.Size = new Size(20,20);
                left.TabIndex = 2;
                left.TabStop = true;
                left.Text = " ";
                left.Appearance = Appearance.Button;
                left.Click += new EventHandler(this.OnClick);
                left.KeyDown += new KeyEventHandler(this.OnKeyDown);
                left.AccessibleName = SR.GetString(SR.DockEditorLeftAccName);

                top.Dock = DockStyle.Top;
                top.Size = new Size(20,20);
                top.TabIndex = 1;
                top.TabStop = true;
                top.Text = " ";
                top.Appearance = Appearance.Button;
                top.Click += new EventHandler(this.OnClick);
                top.KeyDown += new KeyEventHandler(this.OnKeyDown);
                top.AccessibleName = SR.GetString(SR.DockEditorTopAccName);

                bottom.Dock = DockStyle.Bottom;
                bottom.Size = new Size(20,20);
                bottom.TabIndex = 5;
                bottom.TabStop = true;
                bottom.Text = " ";
                bottom.Appearance = Appearance.Button;
                bottom.Click += new EventHandler(this.OnClick);
                bottom.KeyDown += new KeyEventHandler(this.OnKeyDown);
                bottom.AccessibleName = SR.GetString(SR.DockEditorBottomAccName);

                fill.Dock = DockStyle.Fill;
                fill.Size = new Size(20,20);
                fill.TabIndex = 3;
                fill.TabStop = true;
                fill.Text = " ";
                fill.Appearance = Appearance.Button;
                fill.Click += new EventHandler(this.OnClick);
                fill.KeyDown += new KeyEventHandler(this.OnKeyDown);
                fill.AccessibleName = SR.GetString(SR.DockEditorFillAccName);

                Controls.Clear();
                Controls.AddRange(new Control[]{
                                   container,
                                   none});
                                   
                container.Controls.Clear();                                   
                container.Controls.AddRange(new Control[]{
                                                fill,
                                                left,
                                                right,
                                                top,
                                                bottom,
                                                });
            }

            private void OnClick(object sender, EventArgs eventargs) {
                DockStyle val = GetDock((CheckBox)sender);
                if (val >= (DockStyle)0) {
                    value = val;
                }
                Teardown();
            }

            protected override void OnGotFocus(EventArgs e) {
                base.OnGotFocus(e);

                // Set focus to currently selected Dock style
                for (int i = 0; i < tabOrder.Length; i++) {
                    if (tabOrder[i].Checked) {
                        tabOrder[i].Focus();
                        break;
                    }
                }
            }

            private void OnKeyDown(object sender, KeyEventArgs e) {
                Keys key = e.KeyCode;
                Control target = null;
                int maxI;

                switch (key) {
                    case Keys.Up:
                    case Keys.Down:
                        // If we're going up or down from one of the 'sides', act like we're doing
                        // it from the center
                        if (sender == left || sender == right)
                            sender = fill;

                        maxI = upDownOrder.Length - 1;
                        for (int i = 0; i <= maxI; i++) {
                            if (upDownOrder[i] == sender) {
                                if (key == Keys.Up) {
                                    target = upDownOrder[Math.Max(i-1, 0)];
                                }
                                else {
                                    target = upDownOrder[Math.Min(i+1, maxI)];
                                }
                                break;
                            }
                        }
                        break;
                    case Keys.Left:
                    case Keys.Right:
                        maxI = leftRightOrder.Length - 1;
                        for (int i = 0; i <= maxI; i++) {
                            if (leftRightOrder[i] == sender) {
                                if (key == Keys.Left) {
                                    target = leftRightOrder[Math.Max(i-1, 0)];
                                }
                                else {
                                    target = leftRightOrder[Math.Min(i+1, maxI)];
                                }
                                break;
                            }
                        }
                        break;
                    case Keys.Tab:
                        for (int i = 0; i < tabOrder.Length; i++) {
                            if (tabOrder[i] == sender) {
                                i += ((e.Modifiers & Keys.Shift) == 0 ? 1 : -1);
                                i = (i < 0 ? i + tabOrder.Length : i % tabOrder.Length);
                                target = tabOrder[i];
                                break;
                            }
                        }
                        break;
                    case Keys.Return:
                        InvokeOnClick(((CheckBox)sender), EventArgs.Empty);  // Will tear down editor
                        return;
                    default:
                        return;  // Unhandled keys return here
                }
                e.Handled = true;

                if (target != null && target != sender) {
                    target.Focus();
                }
            }
            
            public void Start(IWindowsFormsEditorService edSvc, object value) {
                this.edSvc = edSvc;
                this.value = value;
                
                if (value is DockStyle) {
                    DockStyle dock = (DockStyle)value;
                    
                    none.Checked = false;
                    top.Checked = false;
                    left.Checked = false;
                    right.Checked = false;
                    bottom.Checked = false;
                    fill.Checked = false;
                    
                    switch (dock) {
                        case DockStyle.None:
                            none.Checked = true;
                            break;
                        case DockStyle.Top:
                            top.Checked = true;
                            break;
                        case DockStyle.Left:
                            left.Checked = true;
                            break;
                        case DockStyle.Right:
                            right.Checked = true;
                            break;
                        case DockStyle.Bottom:
                            bottom.Checked = true;
                            break;
                        case DockStyle.Fill:
                            fill.Checked = true;
                            break;
                    }
                }
            }
            
            private void Teardown() {
                edSvc.CloseDropDown();
            }
            
           
            

            // <doc>
            // <desc>
            // </desc>
            // </doc>
            //
            private class DockEditorCheckBox : CheckBox {
            
                protected override bool ShowFocusCues {
                   get {
                        return true;
                   }
                }
         
                
                protected override bool IsInputKey(System.Windows.Forms.Keys keyData) {
                    switch (keyData) {
                        case Keys.Left:
                        case Keys.Right:
                        case Keys.Up:
                        case Keys.Down:
                        case Keys.Return:
                            return true;
                    }
                    return base.IsInputKey(keyData);
                }
            }
            /// <include file='doc\DockEditor.uex' path='docs/doc[@for="DockEditor.DockUI.ContainerPlaceholder"]/*' />
            /// <devdoc>
            /// </devdoc>
            private class ContainerPlaceholder : Control {
                public ContainerPlaceholder() {
                    this.BackColor = SystemColors.Control;
                    this.TabStop = false;
                }

                protected override void OnPaint(PaintEventArgs e) {
                    Rectangle rc = this.ClientRectangle;
                    ControlPaint.DrawButton(e.Graphics, rc, ButtonState.Pushed);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\filenameeditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="FileNameEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms.Design {
    using System.Runtime.Serialization.Formatters;

    using System.Design;
    using System.Diagnostics;
    using System;
    using System.Drawing;
    using System.Drawing.Design;
    using System.Windows.Forms;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using Microsoft.Win32;

    /// <include file='doc\FileNameEditor.uex' path='docs/doc[@for="FileNameEditor"]/*' />
    /// <devdoc>
    ///    <para> 
    ///       Provides an
    ///       editor for filenames.</para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public class FileNameEditor : UITypeEditor {
    
        private OpenFileDialog openFileDialog;
        
        /// <include file='doc\FileNameEditor.uex' path='docs/doc[@for="FileNameEditor.EditValue"]/*' />
        /// <devdoc>
        ///      Edits the given object value using the editor style provided by
        ///      GetEditorStyle.  A service provider is provided so that any
        ///      required editing services can be obtained.
        /// </devdoc>
        public override object EditValue(ITypeDescriptorContext context,  IServiceProvider  provider, object value) {
        
            Debug.Assert(provider != null, "No service provider; we cannot edit the value");
            if (provider != null) {
                IWindowsFormsEditorService edSvc = (IWindowsFormsEditorService)provider.GetService(typeof(IWindowsFormsEditorService));
                
                Debug.Assert(edSvc != null, "No editor service; we cannot edit the value");
                if (edSvc != null) {
                    if (openFileDialog == null) {
                        openFileDialog = new OpenFileDialog();
                        InitializeDialog(openFileDialog);
                    }
                    
                    if (value is string) {
                        openFileDialog.FileName = (string)value;
                    }
                    
                    if (openFileDialog.ShowDialog() == DialogResult.OK) {
                        value = openFileDialog.FileName;
                        
                    }
                }
            }
            
            return value;
        }

        /// <include file='doc\FileNameEditor.uex' path='docs/doc[@for="FileNameEditor.GetEditStyle"]/*' />
        /// <devdoc>
        ///    <para>Gets the editing style of the Edit method. If the method
        ///       is not supported, this will return None.</para>
        /// </devdoc>
        public override UITypeEditorEditStyle GetEditStyle(ITypeDescriptorContext context) {
            return UITypeEditorEditStyle.Modal;
        }
        
        /// <include file='doc\FileNameEditor.uex' path='docs/doc[@for="FileNameEditor.InitializeDialog"]/*' />
        /// <devdoc>
        ///      Initializes the open file dialog when it is created.  This gives you
        ///      an opportunity to configure the dialog as you please.  The default
        ///      implementation provides a generic file filter and title.
        /// </devdoc>
        protected virtual void InitializeDialog(OpenFileDialog openFileDialog) {
            openFileDialog.Filter = SR.GetString(SR.GenericFileFilter);
            openFileDialog.Title = SR.GetString(SR.GenericOpenFile);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\helpfilefilenameeditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="HelpFileFileNameEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms.Design {
    using System.Design;
    using System.Runtime.Serialization.Formatters;

    using System.Diagnostics;

    using System;
    using System.Drawing;
    using System.ComponentModel;
    using Microsoft.Win32;

    /// <include file='doc\HelpFileFileNameEditor.uex' path='docs/doc[@for="HelpNamespaceEditor"]/*' />
    /// <devdoc>
    ///     This is a filename editor for choosing help files.
    /// </devdoc>
    /// <internalonly/>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class HelpNamespaceEditor : FileNameEditor {

        /// <include file='doc\HelpFileFileNameEditor.uex' path='docs/doc[@for="HelpNamespaceEditor.InitializeDialog"]/*' />
        /// <devdoc>
        ///      Initializes the open file dialog when it is created.  This gives you
        ///      an opportunity to configure the dialog as you please.  The default
        ///      implementation provides a generic file filter and title.
        /// </devdoc>
        protected override void InitializeDialog(OpenFileDialog openFileDialog) {
            openFileDialog.Filter = SR.GetString(SR.HelpProviderEditorFilter);
            openFileDialog.Title = SR.GetString(SR.HelpProviderEditorTitle);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\foldernameeditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="FolderNameEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms.Design {

    using System;
    using System.Design;
    using System.ComponentModel;
    using Microsoft.Win32;
    using System.Diagnostics;
    using System.Drawing.Design;
    using System.IO;
    using System.Security;
    using System.Security.Permissions;
    using System.Runtime.InteropServices;

    /// <include file='doc\FolderNameEditor.uex' path='docs/doc[@for="FolderNameEditor"]/*' />
    /// <internalonly/>
    /// <devdoc>
    ///    <para> Provides an editor
    ///       for choosing a folder from the filesystem.</para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public class FolderNameEditor : UITypeEditor {
        private FolderBrowser folderBrowser;

        /// <include file='doc\FolderNameEditor.uex' path='docs/doc[@for="FolderNameEditor.EditValue"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override object EditValue(ITypeDescriptorContext context,  IServiceProvider  provider, object value) {

            if (folderBrowser == null) {
                folderBrowser = new FolderBrowser();
                InitializeDialog(folderBrowser);
            }

            if (folderBrowser.ShowDialog() != System.Windows.Forms.DialogResult.OK) {
                return value;
            }

            return folderBrowser.DirectoryPath;
        }

        /// <include file='doc\FolderNameEditor.uex' path='docs/doc[@for="FolderNameEditor.GetEditStyle"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///      Retrieves the editing style of the Edit method.  If the method
        ///      is not supported, this will return None.
        /// </devdoc>
        public override UITypeEditorEditStyle GetEditStyle(ITypeDescriptorContext context) {
            return UITypeEditorEditStyle.Modal;
        }

        /// <include file='doc\FolderNameEditor.uex' path='docs/doc[@for="FolderNameEditor.InitializeDialog"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///      Initializes the folder browser dialog when it is created.  This gives you
        ///      an opportunity to configure the dialog as you please.  The default
        ///      implementation provides a generic folder browser.
        /// </devdoc>
        protected virtual void InitializeDialog(FolderBrowser folderBrowser) {
        }
        
        /// <include file='doc\FolderNameEditor.uex' path='docs/doc[@for="FolderNameEditor.FolderBrowser"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected sealed class FolderBrowser : Component {
            private static readonly int MAX_PATH = 260;
    
            // Root node of the tree view.
            private FolderBrowserFolder startLocation = FolderBrowserFolder.Desktop;
    
            // Browse info options
            private FolderBrowserStyles publicOptions = FolderBrowserStyles.RestrictToFilesystem;
            private UnsafeNativeMethods.BrowseInfos privateOptions = UnsafeNativeMethods.BrowseInfos.NewDialogStyle;
    
            // Description text to show.
            private string descriptionText = String.Empty;
    
            // Folder picked by the user.
            private string directoryPath = String.Empty;
    
            /// <include file='doc\FolderNameEditor.uex' path='docs/doc[@for="FolderNameEditor.FolderBrowser.Style"]/*' />
            /// <internalonly/>
            /// <devdoc>
            ///      The styles the folder browser will use when browsing
            ///      folders.  This should be a combination of flags from
            ///      the FolderBrowserStyles enum.
            /// </devdoc>
            public FolderBrowserStyles Style {
                get {
                    return publicOptions;
                }
                set {
                    publicOptions = value;
                }
            }
    
            /// <include file='doc\FolderNameEditor.uex' path='docs/doc[@for="FolderNameEditor.FolderBrowser.DirectoryPath"]/*' />
            /// <internalonly/>
            /// <devdoc>
            ///     Gets the directory path of the folder the user picked.
            /// </devdoc>
            public string DirectoryPath {
                get {
                    new FileIOPermission(FileIOPermissionAccess.PathDiscovery, directoryPath).Demand();
                    return directoryPath;
                }
            }
    
            /// <include file='doc\FolderNameEditor.uex' path='docs/doc[@for="FolderNameEditor.FolderBrowser.StartLocation"]/*' />
            /// <internalonly/>
            /// <devdoc>
            ///     Gets/sets the start location of the root node.
            /// </devdoc>
            public FolderBrowserFolder StartLocation {
                get {
                    return startLocation;
                }
                set {
                    new UIPermission(UIPermissionWindow.AllWindows).Demand();
                    startLocation = value;
                }
            }
    
            /// <include file='doc\FolderNameEditor.uex' path='docs/doc[@for="FolderNameEditor.FolderBrowser.Description"]/*' />
            /// <internalonly/>
            /// <devdoc>
            ///    <para>
            ///       Gets or sets a description to show above the folders. Here you can provide instructions for
            ///       selecting a folder.
            ///    </para>
            /// </devdoc>
            public string Description {
                get {
                    return descriptionText;
                }
                set {
                    new UIPermission(UIPermissionWindow.AllWindows).Demand();
                    descriptionText = (value == null) ? String.Empty: value;
                }
            }
    
            /// <include file='doc\FolderNameEditor.uex' path='docs/doc[@for="FolderNameEditor.FolderBrowser.GetSHMalloc"]/*' />
            /// <devdoc>
            ///     Helper function that returns the IMalloc interface used by the shell.
            /// </devdoc>
            private static UnsafeNativeMethods.IMalloc GetSHMalloc() {
                UnsafeNativeMethods.IMalloc[] malloc = new UnsafeNativeMethods.IMalloc[1];
    
                UnsafeNativeMethods.Shell32.SHGetMalloc(malloc);
    
                return malloc[0];
            }
    
            /// <include file='doc\FolderNameEditor.uex' path='docs/doc[@for="FolderNameEditor.FolderBrowser.ShowDialog"]/*' />
            /// <internalonly/>
            /// <devdoc>
            ///     Shows the folder browser dialog.
            /// </devdoc>
            public DialogResult ShowDialog() {
                return ShowDialog(null);
            }
            
            /// <include file='doc\FolderNameEditor.uex' path='docs/doc[@for="FolderNameEditor.FolderBrowser.ShowDialog1"]/*' />
            /// <internalonly/>
            /// <devdoc>
            ///     Shows the folder browser dialog with the specified owner.
            /// </devdoc>
            public DialogResult ShowDialog(IWin32Window owner) {
            
                IntPtr pidlRoot = IntPtr.Zero;
    
                // Get/find an owner HWND for this dialog
                IntPtr hWndOwner;
                 
                if (owner != null) {
                    hWndOwner = owner.Handle;
                }
                else {
                    hWndOwner = UnsafeNativeMethods.GetActiveWindow();
                }
    
                // Get the IDL for the specific startLocation
                UnsafeNativeMethods.Shell32.SHGetSpecialFolderLocation(hWndOwner, (int) startLocation, ref pidlRoot);
    
                if (pidlRoot == IntPtr.Zero) {
                    return DialogResult.Cancel;
                }
                
                int mergedOptions = (int)publicOptions | (int)privateOptions;
                
                if ((mergedOptions & (int)UnsafeNativeMethods.BrowseInfos.NewDialogStyle) != 0) {
                    Application.OleRequired();
                }
    
                IntPtr pidlRet = IntPtr.Zero;
    
                try {
                    // Construct a BROWSEINFO
                    UnsafeNativeMethods.BROWSEINFO bi = new UnsafeNativeMethods.BROWSEINFO();
    
                    IntPtr buffer = Marshal.AllocHGlobal(MAX_PATH);
    
                    bi.pidlRoot = pidlRoot;
                    bi.hwndOwner = hWndOwner;
                    bi.pszDisplayName = buffer;
                    bi.lpszTitle = descriptionText;
                    bi.ulFlags = mergedOptions;
                    bi.lpfn = IntPtr.Zero;
                    bi.lParam = IntPtr.Zero;
                    bi.iImage = 0;
    
                    // And show the dialog
                    pidlRet = UnsafeNativeMethods.Shell32.SHBrowseForFolder(bi);
    
                    if (pidlRet == IntPtr.Zero) {
                        // User pressed Cancel
                        return DialogResult.Cancel;
                    }
    
                    // Then retrieve the path from the IDList
                    UnsafeNativeMethods.Shell32.SHGetPathFromIDList(pidlRet, buffer);
    
                    // Convert to a string
                    directoryPath = Marshal.PtrToStringAuto(buffer);
    
                    // Then free all the stuff we've allocated or the SH API gave us
                    Marshal.FreeHGlobal(buffer);
                }
                finally {
                    UnsafeNativeMethods.IMalloc malloc = GetSHMalloc();
                    malloc.Free(pidlRoot);
    
                    if (pidlRet != IntPtr.Zero) {
                        malloc.Free(pidlRet);
                    }
                }
    
                return DialogResult.OK;
            }
        }

        /// <include file='doc\FolderNameEditor.uex' path='docs/doc[@for="FolderNameEditor.FolderBrowserFolder"]/*' />
        /// <internalonly/>
        protected enum FolderBrowserFolder {
        
            /// <include file='doc\FolderNameEditor.uex' path='docs/doc[@for="FolderNameEditor.FolderBrowserFolder.Desktop"]/*' />
            Desktop                   = 0x0000,
        
            /// <include file='doc\FolderNameEditor.uex' path='docs/doc[@for="FolderNameEditor.FolderBrowserFolder.Favorites"]/*' />
            Favorites                 = 0x0006,
        
            /// <include file='doc\FolderNameEditor.uex' path='docs/doc[@for="FolderNameEditor.FolderBrowserFolder.MyComputer"]/*' />
            MyComputer                = 0x0011,
        
            /// <include file='doc\FolderNameEditor.uex' path='docs/doc[@for="FolderNameEditor.FolderBrowserFolder.MyDocuments"]/*' />
            MyDocuments               = 0x0005,
        
            /// <include file='doc\FolderNameEditor.uex' path='docs/doc[@for="FolderNameEditor.FolderBrowserFolder.MyPictures"]/*' />
            MyPictures                = 0x0027,
        
            /// <include file='doc\FolderNameEditor.uex' path='docs/doc[@for="FolderNameEditor.FolderBrowserFolder.NetAndDialUpConnections"]/*' />
            NetAndDialUpConnections   = 0x0031,
        
            /// <include file='doc\FolderNameEditor.uex' path='docs/doc[@for="FolderNameEditor.FolderBrowserFolder.NetworkNeighborhood"]/*' />
            NetworkNeighborhood       = 0x0012,
        
            /// <include file='doc\FolderNameEditor.uex' path='docs/doc[@for="FolderNameEditor.FolderBrowserFolder.Printers"]/*' />
            Printers                  = 0x0004,
        
            /// <include file='doc\FolderNameEditor.uex' path='docs/doc[@for="FolderNameEditor.FolderBrowserFolder.Recent"]/*' />
            Recent                    = 0x0008,
        
            /// <include file='doc\FolderNameEditor.uex' path='docs/doc[@for="FolderNameEditor.FolderBrowserFolder.SendTo"]/*' />
            SendTo                    = 0x0009,
        
            /// <include file='doc\FolderNameEditor.uex' path='docs/doc[@for="FolderNameEditor.FolderBrowserFolder.StartMenu"]/*' />
            StartMenu                 = 0x000b,
        
            /// <include file='doc\FolderNameEditor.uex' path='docs/doc[@for="FolderNameEditor.FolderBrowserFolder.Templates"]/*' />
            Templates                 = 0x0015,
        }
        
        /// <include file='doc\FolderNameEditor.uex' path='docs/doc[@for="FolderNameEditor.FolderBrowserStyles"]/*' />
        /// <internalonly/>
        [Flags]    
        protected enum FolderBrowserStyles {
            
            /// <include file='doc\FolderNameEditor.uex' path='docs/doc[@for="FolderNameEditor.FolderBrowserStyles.BrowseForComputer"]/*' />
            BrowseForComputer = UnsafeNativeMethods.BrowseInfos.BrowseForComputer,
            
            /// <include file='doc\FolderNameEditor.uex' path='docs/doc[@for="FolderNameEditor.FolderBrowserStyles.BrowseForEverything"]/*' />
            BrowseForEverything = UnsafeNativeMethods.BrowseInfos.BrowseForEverything,
            
            /// <include file='doc\FolderNameEditor.uex' path='docs/doc[@for="FolderNameEditor.FolderBrowserStyles.BrowseForPrinter"]/*' />
            BrowseForPrinter = UnsafeNativeMethods.BrowseInfos.BrowseForPrinter,
            
            /// <include file='doc\FolderNameEditor.uex' path='docs/doc[@for="FolderNameEditor.FolderBrowserStyles.RestrictToDomain"]/*' />
            RestrictToDomain = UnsafeNativeMethods.BrowseInfos.DontGoBelowDomain,
            
            /// <include file='doc\FolderNameEditor.uex' path='docs/doc[@for="FolderNameEditor.FolderBrowserStyles.RestrictToFilesystem"]/*' />
            RestrictToFilesystem = UnsafeNativeMethods.BrowseInfos.ReturnOnlyFSDirs,
            
            /// <include file='doc\FolderNameEditor.uex' path='docs/doc[@for="FolderNameEditor.FolderBrowserStyles.RestrictToSubfolders"]/*' />
            RestrictToSubfolders = UnsafeNativeMethods.BrowseInfos.ReturnFSAncestors,
            
            /// <include file='doc\FolderNameEditor.uex' path='docs/doc[@for="FolderNameEditor.FolderBrowserStyles.ShowTextBox"]/*' />
            ShowTextBox = UnsafeNativeMethods.BrowseInfos.EditBox,
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\groupboxdesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="GroupBoxDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */

//#define TESTVALUEUI
namespace System.Windows.Forms.Design {
    

    using System.Diagnostics;

    using System;
    using System.Design;
    using System.Windows.Forms;
    using System.Drawing;
    using Microsoft.Win32;
    
    using System.ComponentModel;
    using System.Drawing.Design;
    using System.ComponentModel.Design;
    using System.Collections;

    /// <include file='doc\GroupBoxDesigner.uex' path='docs/doc[@for="GroupBoxDesigner"]/*' />
    /// <devdoc>
    ///     This class handles all design time behavior for the group box class.  Group
    ///     boxes may contain sub-components and therefore use the frame designer.
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class GroupBoxDesigner : ParentControlDesigner {
    
        private InheritanceUI inheritanceUI;
        
        /// <include file='doc\GroupBoxDesigner.uex' path='docs/doc[@for="GroupBoxDesigner.DefaultControlLocation"]/*' />
        /// <devdoc>
        /// Determines the default location for a control added to this designer.
        /// it is usualy (0,0), but may be modified if the container has special borders, etc.
        /// </devdoc>
        protected override Point DefaultControlLocation {
            get {
                GroupBox gb = (GroupBox)this.Control;
                return new Point(gb.DisplayRectangle.X,gb.DisplayRectangle.Y);
            }
        }
    
       #if TESTVALUEUI
        /// <include file='doc\GroupBoxDesigner.uex' path='docs/doc[@for="GroupBoxDesigner.Initialize"]/*' />
        /// <devdoc>
        ///     Initializes the designer with the given component.  The designer can
        ///     get the component's site and request services from it in this call.
        /// </devdoc>
        public override void Initialize(IComponent component) {
            base.Initialize(component);
            
            
            
            IPropertyValueUIService pvUISvc = (IPropertyValueUIService)component.Site.GetService(typeof(IPropertyValueUIService));
            
            if (pvUISvc != null) {
                pvUISvc.AddPropertyValueUIHandler(new PropertyValueUIHandler(this.OnGetUIValueItem));
            }
        }
        
        private void OnGetUIValueItem(object component, PropertyDescriptor propDesc, ArrayList valueUIItemList){
        
            if (propDesc.PropertyType == typeof(string)) {
                Bitmap bmp = new Bitmap(typeof(GroupBoxDesigner), "BoundProperty.bmp");
                bmp.MakeTransparent();
                valueUIItemList.Add(new LocalUIItem(bmp, new PropertyValueUIItemInvokeHandler(this.OnPropertyValueUIItemInvoke), "Data Can"));
                
                //bmp = new Bitmap("BoundProperty.bmp");
                valueUIItemList.Add(new LocalUIItem(bmp, new PropertyValueUIItemInvokeHandler(this.OnPropertyValueUIItemInvoke), "Little Button"));
            }
            
            
        }

        private void OnPropertyValueUIItemInvoke(ITypeDescriptorContext context, PropertyDescriptor descriptor, PropertyValueUIItem invokedItem) {
            Debug.Fail("propertyuivalue '" + invokedItem.ToolTip + "' invoked");
        }
        
        #endif
      
        /// <include file='doc\GroupBoxDesigner.uex' path='docs/doc[@for="GroupBoxDesigner.OnPaintAdornments"]/*' />
        /// <devdoc>
        ///      We override this because even though we still want to 
        ///      offset our grid for our display rectangle, we still want
        ///      to align to our parent's grid - so we don't look funny
        /// </devdoc>
        protected override void OnPaintAdornments(PaintEventArgs pe) {
            if (DrawGrid) {
                Control control = (Control)Control;
                Rectangle rectangle = Control.DisplayRectangle;
                
                rectangle.Width++; // gpr: FillRectangle with a TextureBrush comes up one pixel short
                rectangle.Height++;
                ControlPaint.DrawGrid(pe.Graphics, rectangle, GridSize, control.BackColor);
            }
            
            // If this control is being inherited, paint it
            //
            if (Inherited) {
                if (inheritanceUI == null) {
                    inheritanceUI = (InheritanceUI)GetService(typeof(InheritanceUI));
                }
                
                if (inheritanceUI != null) {
                    pe.Graphics.DrawImage(inheritanceUI.InheritanceGlyph, 0, 0);
                }
            }
        }

        /// <include file='doc\GroupBoxDesigner.uex' path='docs/doc[@for="GroupBoxDesigner.WndProc"]/*' />
        /// <devdoc>
        ///      We override our base class's WndProc here because
        ///      the group box always returns HTTRANSPARENT.  This
        ///      causes the mouse to go "through" the group box, but
        ///      that's not what we want at design time.
        /// </devdoc>
        protected override void WndProc(ref Message m) {
            switch (m.Msg) {
                case NativeMethods.WM_NCHITTEST:
                    // The group box always fires HTTRANSPARENT, which
                    // causes the message to go to our parent.  We want
                    // the group box's designer to get these messages, however,
                    // so change this.
                    //
                    base.WndProc(ref m);
                    if ((int)m.Result == NativeMethods.HTTRANSPARENT) {
                        m.Result = (IntPtr)NativeMethods.HTCLIENT;
                    }
                    break;

                default:
                    base.WndProc(ref m);
                    break;
            }
        }
        
        
        #if TESTVALUEUI
        
        internal class LocalUIItem : PropertyValueUIItem {
            private string itemName;
            
            public LocalUIItem(Image img, PropertyValueUIItemInvokeHandler handler, string itemName) : base(img, handler, itemName) {
                this.itemName = itemName;
            }
        }
        #endif
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\ieventhandlerservice.cs ===
//------------------------------------------------------------------------------
// <copyright file="IEventHandlerService.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms.Design {

    using System.Diagnostics;
    using System;
    using System.Windows.Forms;
    using System.ComponentModel;

    /// <include file='doc\IEventHandlerService.uex' path='docs/doc[@for="IEventHandlerService"]/*' />
    /// <devdoc>
    ///     The event handler service provides a unified way to handle
    ///     the various events that our form designer must process.  What
    ///     we want to be able to do is to write code in one place that
    ///     handles events of a certain type.  We also may need to globally
    ///     change the behavior of these events for modal functions like
    ///     the tab order UI.  Our designer, however, is in many pieces
    ///     so we must somehow funnel these events to a common place.
    ///
    ///     This service implements an "event stack" that contains the
    ///     current set of event handlers.  There can be different
    ///     types of handlers on the stack.  For example, we may push
    ///     a keyboard handler and a mouse handler.  When you request
    ///     a handler, we will find the topmost handler on the stack
    ///     that fits the class you requested.  This way the service
    ///     can be extended to any eventing scheme, and it also allows
    ///     sections of a handler to be replaced (eg, you can replace
    ///     mouse handling without effecting menus or the keyboard).
    /// </devdoc>    
    internal interface IEventHandlerService {

        event EventHandler EventHandlerChanged;

        /// <include file='doc\IEventHandlerService.uex' path='docs/doc[@for="IEventHandlerService.FocusWindow"]/*' />
        /// <devdoc>
        ///    <para>Gets the control that handles focus changes
        ///       for this event handler service.</para>
        /// </devdoc>
        Control FocusWindow {
            get;
        }

        /// <include file='doc\IEventHandlerService.uex' path='docs/doc[@for="IEventHandlerService.GetHandler"]/*' />
        /// <devdoc>
        ///    <para>Gets the currently active event handler of the specified type.</para>
        /// </devdoc>
        object GetHandler(Type handlerType);

        /// <include file='doc\IEventHandlerService.uex' path='docs/doc[@for="IEventHandlerService.PopHandler"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       Pops
        ///       the given handler off of the stack.</para>
        /// </devdoc>
        void PopHandler(object handler);

        /// <include file='doc\IEventHandlerService.uex' path='docs/doc[@for="IEventHandlerService.PushHandler"]/*' />
        /// <devdoc>
        ///    <para>Pushes a new event handler on the stack.</para>
        /// </devdoc>
        void PushHandler(object handler);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\formdocumentdesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="FormDocumentDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms.Design {
    
    using System.Design;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.Collections;
    using System.ComponentModel.Design;
    using System.Windows.Forms;
    using System.Windows.Forms.Design;
    using System.Drawing;
    using Microsoft.Win32;
    using System.Drawing.Design;

    /// <include file='doc\FormDocumentDesigner.uex' path='docs/doc[@for="FormDocumentDesigner"]/*' />
    /// <devdoc>
    ///      The FormDocumentDesigner class builds on the DocumentDesigner.  It adds shadowing
    ///      for form properties that need to be shadowed and it also adds logic to properly
    ///      paint the form's title bar to match the active document window.
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class FormDocumentDesigner : DocumentDesigner {
        private Size autoScaleBaseSize = Size.Empty;
        private bool inAutoscale = false;
        private int  heightDelta = 0;
        private bool                isMenuInherited;       //indicates if the 'active menu' is inherited
        private InheritanceAttribute inheritanceAttribute;
        private bool initializing = false;


        /// <include file='doc\FormDocumentDesigner.uex' path='docs/doc[@for="FormDocumentDesigner.AutoScaleBaseSize"]/*' />
        /// <devdoc>
        ///      Shadowed version of the AutoScaleBaseSize property.  We shadow this
        ///      so that it always persists.  Normally only properties that differ
        ///      from the default values at instantiation are persisted, but this
        ///      should always be written.  So, we shadow it and add our own
        ///      ShouldSerialize method.
        /// </devdoc>
        private Size AutoScaleBaseSize {
            get {
                return ((Form)Component).AutoScaleBaseSize;
            }

            set {
                // We do nothing at design time for this property; we always want
                // to use the calculated value from the component.
                autoScaleBaseSize = value;
            }
        }

        private bool ShouldSerializeAutoScaleBaseSize() 
        {
            return initializing ? false
                : ShadowProperties.ShouldSerializeValue("AutoScaleBaseSize", true);
        }

        /// <include file='doc\FormDocumentDesigner.uex' path='docs/doc[@for="FormDocumentDesigner.ClientSize"]/*' />
        /// <devdoc>
        ///      Shadow property for the ClientSize property -- this allows us to intercept client size changes
        ///      and apply the new menu height if necessary
        /// </devdoc>
        private Size ClientSize {
            get {
                return initializing ? new Size(-1, -1)
                    : ((Form)Component).ClientSize;
            }
            set {
                IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));

                if (host != null) {
                    if (host.Loading) {
                        
                        heightDelta = GetMenuHeight();
                    }
                }
                ((Form)Component).ClientSize = value;
            }
        }

        /// <include file='doc\FormDocumentDesigner.uex' path='docs/doc[@for="FormDocumentDesigner.IsMdiContainer"]/*' />
        /// <devdoc>
        ///      Shadow property for the IsMDIContainer property on a form.
        /// </devdoc>
        private bool IsMdiContainer {
            get {
                return((Form)Control).IsMdiContainer;
            }
            set {
                if (!value) {
                    UnhookChildControls(Control);
                }
                ((Form)Control).IsMdiContainer = value;
                if (value) {
                    HookChildControls(Control);
                }
            }
        }

        /// <include file='doc\FormDocumentDesigner.uex' path='docs/doc[@for="FormDocumentDesigner.IsMenuInherited"]/*' />
        /// <devdoc>
        ///      Returns true if the active menu is an inherited component.  We use this to determine if we 
        ///      we need to resize the base control or not.
        /// </devdoc>
        private bool IsMenuInherited {
            get {
                if (inheritanceAttribute == null && Menu != null) {
                    inheritanceAttribute = (InheritanceAttribute)TypeDescriptor.GetAttributes(Menu)[typeof(InheritanceAttribute)];
                    if (inheritanceAttribute.Equals(InheritanceAttribute.NotInherited)) {
                        isMenuInherited = false;
                    }
                    else {
                        isMenuInherited = true;
                    }
                }
                return isMenuInherited;
            }
        }

        
        /// <include file='doc\FormDocumentDesigner.uex' path='docs/doc[@for="FormDocumentDesigner.Menu"]/*' />
        /// <devdoc>
        ///     Accessor method for the menu property on control.  We shadow
        ///     this property at design time.
        /// </devdoc>
        private MainMenu Menu {
            get {
                return (MainMenu)ShadowProperties["Menu"];
            }

            set {
                if (value == ShadowProperties["Menu"]) {
                    return;
                }

                ShadowProperties["Menu"] = value;
                
                IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));

                if (host != null && !host.Loading) {
                    EnsureMenuEditorService(value);
                    if (menuEditorService != null)
                       menuEditorService.SetMenu(value);
                }
            }
        }

        /// <include file='doc\FormDocumentDesigner.uex' path='docs/doc[@for="FormDocumentDesigner.Opacity"]/*' />
        /// <devdoc>
        ///     Opacity property on control.  We shadow this property at design time.
        /// </devdoc>
        private double Opacity {
            get {
                return (double)ShadowProperties["Opacity"];
            }
            set {
                if (value < 0.0f || value > 1.0f) {
                    throw new ArgumentException(SR.GetString(SR.InvalidBoundArgument,
                                                                    "value",
                                                                    value.ToString(),
                                                                    "0.0",
                                                                    "1.0"), "value");
                }
                ShadowProperties["Opacity"] = value;
            }
        }

        private Size Size {
            get {
                return Control.Size;
            }
            set {
                IComponentChangeService cs = (IComponentChangeService)GetService(typeof(IComponentChangeService));
                PropertyDescriptorCollection props = TypeDescriptor.GetProperties(Component);
                if (cs != null) {
                    cs.OnComponentChanging(Component, props["ClientSize"]);
                }
                            
                Control.Size = value;

                if (cs != null) {
                    cs.OnComponentChanged(Component, props["ClientSize"], null, null);
                }
            }
        }

        /// <include file='doc\FormDocumentDesigner.uex' path='docs/doc[@for="FormDocumentDesigner.ShowInTaskbar"]/*' />
        /// <devdoc>
        ///     Accessor method for the showInTaskbar property on control.  We shadow
        ///     this property at design time.
        /// </devdoc>
        private bool ShowInTaskbar {
            get {
                return (bool)ShadowProperties["ShowInTaskbar"];
            }
            set {
                ShadowProperties["ShowInTaskbar"] = value;
            }
        }

        /// <include file='doc\FormDocumentDesigner.uex' path='docs/doc[@for="FormDocumentDesigner.WindowState"]/*' />
        /// <devdoc>
        ///     Accessor method for the windowState property on control.  We shadow
        ///     this property at design time.
        /// </devdoc>
        private FormWindowState WindowState {
            get {
                return (FormWindowState)ShadowProperties["WindowState"];
            }
            set {
                ShadowProperties["WindowState"] = value;
            }
        }

        private void ApplyAutoScaling(SizeF baseVar, Form form) {

            // We also don't do this if the property is empty.  Otherwise we will perform
            // two GetAutoScaleBaseSize calls only to find that they returned the same
            // value.
            //
            if (!baseVar.IsEmpty) {
                SizeF newVarF = Form.GetAutoScaleSize(form.Font);
                Size newVar = new Size((int)Math.Round(newVarF.Width), (int)Math.Round(newVarF.Height));

                // We save a significant amount of time by bailing early if there's no work to be done
                if (baseVar.Equals(newVar))
                    return;

                float percY = ((float)newVar.Height) / ((float)baseVar.Height);
                float percX = ((float)newVar.Width) / ((float)baseVar.Width);
                try {
                    inAutoscale = true;
                    form.Scale(percX, percY);
                }
                finally {
                    inAutoscale = false;
                }
                
            }
        }

        /// <include file='doc\FormDocumentDesigner.uex' path='docs/doc[@for="FormDocumentDesigner.Dispose"]/*' />
        /// <devdoc>
        ///     Disposes of this designer.
        /// </devdoc>
        protected override void Dispose(bool disposing) {
            if (disposing) {
                IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
                Debug.Assert(host != null, "Must have a designer host on dispose");

                if (host != null) {
                    host.LoadComplete -= new EventHandler(OnLoadComplete);
                    host.Activated -= new EventHandler(OnDesignerActivate);
                    host.Deactivated -= new EventHandler(OnDesignerDeactivate);
                }

                IComponentChangeService cs = (IComponentChangeService)GetService(typeof(IComponentChangeService));
                if (cs != null) {
                    cs.ComponentAdded -= new ComponentEventHandler(this.OnComponentAdded);
                    cs.ComponentRemoved -= new ComponentEventHandler(this.OnComponentRemoved);
                }
            }
            base.Dispose(disposing);
        }

        internal override void DoProperMenuSelection(ICollection selComponents) {
            foreach(object obj in selComponents) {
                //first check to see if our selection is any kind of menu: main, context, item
                // AND the designer for the component is this one
                //
                if (obj is Menu) {
                    //if it's a menu item, set the selection
                    if (obj is MenuItem ) {
                        Menu currentMenu = menuEditorService.GetMenu();
                        //before we set the selection, we need to check if the item belongs the current menu,
                        //if not, we need to set the menu editor to the appropiate menu, then set selection
                        //
                        MenuItem parent = (MenuItem)obj;
                        while (parent.Parent is MenuItem) {
                            parent = (MenuItem)parent.Parent;
                        }

                        if( !(currentMenu == parent.Parent) ) {
                            menuEditorService.SetMenu(parent.Parent);
                        }

                        //ok, here we have the correct editor selected for this item.
                        //Now, if there's only one item selected, then let the editor service know,
                        //if there is more than one - then the selection was done through the
                        //menu editor and we don't need to tell it
                        if(selComponents.Count == 1) {
                            menuEditorService.SetSelection((MenuItem)obj);
                        }
                    }
                    //here, either it's a main or context menu, even if the menu is the current one, 
                    //we still want to call this "SetMenu" method, 'cause that'll collapse it and 
                    //remove the focus
                    //
                    else {
                        menuEditorService.SetMenu((Menu)obj);
                    }
                    return;
                }
                //Here, something is selected, but it is in no way, shape, or form a menu
                //so, we'll collapse our active menu accordingly
                else {
                    if (Menu != null && Menu.MenuItems.Count == 0) {
                        menuEditorService.SetMenu(null);
                    }
                    else {
                        menuEditorService.SetMenu(Menu);
                    }
                    NativeMethods.SendMessage(Control.Handle, NativeMethods.WM_NCACTIVATE, 1, 0);
                }
            }
        }

        /// <devdoc>
        ///      Determines if a MenuEditorService has already been started.  If not,
        ///      this method will create a new instance of the service.  We override 
        ///      this because we want to allow any kind of menu to start the service,
        ///      not just ContextMenus.
        /// </devdoc>
        protected override void EnsureMenuEditorService(IComponent c) {
            if (menuEditorService == null && c is Menu) {
                menuEditorService = (IMenuEditorService)GetService(typeof(IMenuEditorService));
            }
        }

        /// <devdoc>
        /// Gets the current menu height so we know how much to increment the form size by
        /// </devdoc>
        private int GetMenuHeight() {

            if (Menu == null) {
                return 0;
            }

            if (menuEditorService != null) {
                // there is a magic property on teh menueditorservice that gives us this
                // information.  Unfortuantely, we can't compute it ourselves -- the menu
                // shown in the designer isn't a windows one so we can't ask windows.
                //
                PropertyDescriptor heightProp = TypeDescriptor.GetProperties(menuEditorService)["MenuHeight"];
                if (heightProp != null) {
                    int height = (int)heightProp.GetValue(menuEditorService);

                    if (IsMenuInherited && initializing) {
                        return height - SystemInformation.MenuHeight;
                    }
                    return height;
                }
            } 
            return SystemInformation.MenuHeight;
        }

        /// <include file='doc\FormDocumentDesigner.uex' path='docs/doc[@for="FormDocumentDesigner.Initialize"]/*' />
        /// <devdoc>
        ///     Initializes the designer with the given component.  The designer can
        ///     get the component's site and request services from it in this call.
        /// </devdoc>
        public override void Initialize(IComponent component) {
            // We have to shadow the WindowState before we call base.Initialize
            PropertyDescriptor windowStateProp = TypeDescriptor.GetProperties(component.GetType())["WindowState"];
            if (windowStateProp != null && windowStateProp.PropertyType == typeof(FormWindowState)) 
            {
                WindowState = (FormWindowState)windowStateProp.GetValue(component);
            }

            initializing = true;
            base.Initialize(component);
            initializing = false;

            Debug.Assert(component is Form, "FormDocumentDesigner expects its component to be a form.");

            IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
            if (host != null) {
                host.LoadComplete += new EventHandler(OnLoadComplete);
                host.Activated += new EventHandler(OnDesignerActivate);
                host.Deactivated += new EventHandler(OnDesignerDeactivate);
            }

            ((Form)Control).WindowState = FormWindowState.Normal;

            // Monitor component/remove add events for our tray
            //
            IComponentChangeService cs = (IComponentChangeService)GetService(typeof(IComponentChangeService));
            if (cs != null) {
                cs.ComponentAdded += new ComponentEventHandler(this.OnComponentAdded);
                cs.ComponentRemoved += new ComponentEventHandler(this.OnComponentRemoved);
            }
        }

        /// <include file='doc\FormDocumentDesigner.uex' path='docs/doc[@for="FormDocumentDesigner.OnComponentAdded"]/*' />
        /// <devdoc>
        ///      Called when a component is added to the design container.
        ///      If the component isn't a control, this will demand create
        ///      the component tray and add the component to it.
        /// </devdoc>
        private void OnComponentAdded(object source, ComponentEventArgs ce) {
            if (ce.Component is Menu) {
                IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
                if (host != null && !host.Loading) {
                    //if it's a MainMenu & we don't have one set for the form yet, then do it...
                    //
                    if(ce.Component is MainMenu && !ShadowProperties.Contains("Menu")) {
                        PropertyDescriptor menuProp = TypeDescriptor.GetProperties(Component)["Menu"];
                        Debug.Assert(menuProp != null, "What the hell happened to the Menu property");
                        menuProp.SetValue(Component, ce.Component);
                    }
                }
            }                                                                                        
        }
        
        /// <include file='doc\FormDocumentDesigner.uex' path='docs/doc[@for="FormDocumentDesigner.OnComponentRemoved"]/*' />
        /// <devdoc>
        ///      Called when a component is removed from the design container.
        ///      Here, we check if a menu is being removed and handle removing
        ///      the Form's mainmenu vs. other menus properly.
        /// </devdoc>
        private void OnComponentRemoved(object source, ComponentEventArgs ce) {
            if (ce.Component is Menu) {
                //if we deleted the form's mainmenu, set it null...
                if (ce.Component == Menu) {
                    PropertyDescriptor menuProp = TypeDescriptor.GetProperties(Component)["Menu"];
                    Debug.Assert(menuProp != null, "What the hell happened to the Menu property");
                    menuProp.SetValue(Component, null);
                }
                else if (menuEditorService != null && ce.Component == menuEditorService.GetMenu()) {
                    menuEditorService.SetMenu(Menu);
                }
            }
        }

        /// <include file='doc\FormDocumentDesigner.uex' path='docs/doc[@for="FormDocumentDesigner.OnCreateHandle"]/*' />
        /// <devdoc>
        ///      We're watching the handle creation in case we have a menu editor.
        ///      If we do, the menu editor will have to be torn down and recreated.
        /// </devdoc>
        protected override void OnCreateHandle() {
            if (Menu != null && menuEditorService !=null) {
                menuEditorService.SetMenu(null);
                menuEditorService.SetMenu(Menu);
            }
        }

        // <doc>
        // <desc>
        //      Called when our document becomes active.  We paint our form's
        //      border the appropriate color here.
        // </desc>
        // </doc>
        //
        private void OnDesignerActivate(object source, EventArgs evevent) {
            // Paint the form's title bar UI-active
            //
            Control control = Control;

            if (control != null && control.IsHandleCreated) {
                NativeMethods.SendMessage(control.Handle, NativeMethods.WM_NCACTIVATE, 1, 0);
                SafeNativeMethods.RedrawWindow(control.Handle, null, IntPtr.Zero, NativeMethods.RDW_FRAME);
            }
        }

        /// <include file='doc\FormDocumentDesigner.uex' path='docs/doc[@for="FormDocumentDesigner.OnDesignerDeactivate"]/*' />
        /// <devdoc>
        ///     Called by the host when we become inactive.  Here we update the
        ///     title bar of our form so it's the inactive color.
        /// </devdoc>
        private void OnDesignerDeactivate(object sender, EventArgs e) {
            Control control = Control;
            if (control != null && control.IsHandleCreated) {
                NativeMethods.SendMessage(control.Handle, NativeMethods.WM_NCACTIVATE, 0, 0);
                SafeNativeMethods.RedrawWindow(control.Handle, null, IntPtr.Zero, NativeMethods.RDW_FRAME);
            }
        }

        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.OnDragOver"]/*' />
        /// <devdoc>
        ///     Called when a drag drop object is dragged over the control designer view
        /// </devdoc>
        protected override void OnDragOver(DragEventArgs de) {
            base.OnDragOver(de);
            
            if (de.Effect != DragDropEffects.None) {
                Point newOffset = Control.PointToClient(new Point(de.X, de.Y));
                Rectangle clientRect = Control.ClientRectangle;
                if (!clientRect.Contains(newOffset)) {
                    de.Effect = DragDropEffects.None;
                }
            }
        }
        
        /// <include file='doc\FormDocumentDesigner.uex' path='docs/doc[@for="FormDocumentDesigner.OnLoadComplete"]/*' />
        /// <devdoc>
        ///      Called when our code loads.  Here we connect us as the selection
        ///      UI handler for ourselves.  This is a special case because for
        ///      the top level document, we are our own selection UI handler.
        /// </devdoc>
        private void OnLoadComplete(object source, EventArgs evevent) {
            ApplyAutoScaling(autoScaleBaseSize, (Form)Control);
            ISelectionUIService svc = (ISelectionUIService)GetService( typeof(ISelectionUIService) );
            if (svc != null) {
                svc.SyncSelection();
            }

            // if there is a menu and we need to update our height because of it,
            // do it now.
            //
            if (heightDelta != 0) {
                ((Form)Control).Height += heightDelta;
                heightDelta = 0;
            }
            
        }
        
        /// <include file='doc\FormDocumentDesigner.uex' path='docs/doc[@for="FormDocumentDesigner.PreFilterProperties"]/*' />
        /// <devdoc>
        ///      Allows a designer to filter the set of properties
        ///      the component it is designing will expose through the
        ///      TypeDescriptor object.  This method is called
        ///      immediately before its corresponding "Post" method.
        ///      If you are overriding this method you should call
        ///      the base implementation before you perform your own
        ///      filtering.
        /// </devdoc>
        protected override void PreFilterProperties(IDictionary properties) {
            PropertyDescriptor prop;
            
            base.PreFilterProperties(properties);
            
            // Handle shadowed properties
            //
            string[] shadowProps = new string[] {
                "Opacity",
                "Menu",
                "IsMdiContainer",
                "Size",
                "ShowInTaskBar",
                "WindowState",
                "AutoScaleBaseSize"
            };
            
            Attribute[] empty = new Attribute[0];
            
            for (int i = 0; i < shadowProps.Length; i++) {
                prop = (PropertyDescriptor)properties[shadowProps[i]];
                if (prop != null) {
                    properties[shadowProps[i]] = TypeDescriptor.CreateProperty(typeof(FormDocumentDesigner), prop, empty);
                }
            }
            
            // And set the new default value attribute for client base size, and shadow it as well.
            //
            prop = (PropertyDescriptor)properties["ClientSize"];
            if (prop != null) {
                properties["ClientSize"] = TypeDescriptor.CreateProperty(typeof(FormDocumentDesigner), prop, new DefaultValueAttribute(new Size(-1, -1)));
            }
        }
        
        /// <devdoc>
        ///     Handles the WM_WINDOWPOSCHANGING message
        /// </devdoc>
        /// <internalonly/>
        private unsafe void WmWindowPosChanging(ref Message m) {
    
            NativeMethods.WINDOWPOS* wp = (NativeMethods.WINDOWPOS *)m.LParam;


            bool updateSize = inAutoscale;

            if (!updateSize) {
                IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));

                if (host != null) {
                    updateSize = host.Loading;
                }
            } 
            

            // we want to update the size if we have a menu and...
            // 1) we're doing an autoscale
            // 2) we're loading a form without an inherited menu (inherited forms will already have the right size)
            //
            if (updateSize && Menu != null && (wp->flags & NativeMethods.SWP_NOSIZE) == 0 && (IsMenuInherited || inAutoscale)) {
                heightDelta = GetMenuHeight();
            }
        }

                 /// <include file='doc\DocumentDesigner.uex' path='docs/doc[@for="DocumentDesigner.WndProc"]/*' />
        /// <devdoc>
        ///      Overrides our base class WndProc to provide support for
        ///      the menu editor service.
        /// </devdoc>
        protected override void WndProc(ref Message m) {
            switch (m.Msg) {
                case NativeMethods.WM_WINDOWPOSCHANGING:
                    WmWindowPosChanging(ref m);
                    break;
            }
            base.WndProc(ref m);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\imagecollectioneditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="ImageCollectionEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms.Design {
    
    using System.Runtime.InteropServices;

    using System.Diagnostics;
    using System;
    using System.IO;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Windows.Forms;
    using System.Drawing;
    using System.Drawing.Design;
    using System.Windows.Forms.ComponentModel;

    /// <include file='doc\ImageCollectionEditor.uex' path='docs/doc[@for="ImageCollectionEditor"]/*' />
    /// <devdoc>
    ///    <para> 
    ///       Provides an editor for an image collection.</para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class ImageCollectionEditor : CollectionEditor {
    
        /// <include file='doc\ImageCollectionEditor.uex' path='docs/doc[@for="ImageCollectionEditor.ImageCollectionEditor"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Windows.Forms.Design.ImageCollectionEditor'/> class.</para>
        /// </devdoc>
        public ImageCollectionEditor(Type type) : base(type){
        }

        /// <include file='doc\ImageCollectionEditor.uex' path='docs/doc[@for="ImageCollectionEditor.CreateInstance"]/*' />
        /// <devdoc>
        ///    <para>Creates an instance of the specified type in the collection.</para>
        /// </devdoc>
        protected override object CreateInstance(Type type) {
            UITypeEditor editor = (UITypeEditor) TypeDescriptor.GetEditor(typeof(Image), typeof(UITypeEditor));
            Image image = (Image) editor.EditValue(this.Context, null);
            return image;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\imousehandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="IMouseHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms.Design {
    using System.ComponentModel;
    using System.Diagnostics;
    using System;    
    using System.Windows.Forms;
    using System.Drawing;
    using Microsoft.Win32;

    /// <include file='doc\IMouseHandler.uex' path='docs/doc[@for="IMouseHandler"]/*' />
    /// <devdoc>
    ///    <para> Provides a handler for mouse events and plugs into the designer eventing service.</para>
    /// </devdoc>
    internal interface IMouseHandler {

        /// <include file='doc\IMouseHandler.uex' path='docs/doc[@for="IMouseHandler.OnMouseDoubleClick"]/*' />
        /// <devdoc>
        ///    <para>This is called when the user double clicks on a component. The typical 
        ///       behavior is to create an event handler for the component's default event and
        ///       navigate to the handler.</para>
        /// </devdoc>
        void OnMouseDoubleClick(IComponent component);

        /// <include file='doc\IMouseHandler.uex' path='docs/doc[@for="IMouseHandler.OnMouseDown"]/*' />
        /// <devdoc>
        ///     This is called when a mouse button is depressed.  This will perform
        ///     the default drag action for the selected components,  which is to
        ///     move those components around by the mouse.
        /// </devdoc>
        void OnMouseDown(IComponent component, MouseButtons button, int x, int y);

        /// <include file='doc\IMouseHandler.uex' path='docs/doc[@for="IMouseHandler.OnMouseHover"]/*' />
        /// <devdoc>
        ///     This is called when the mouse momentarially hovers over the
        ///     view for the given component.
        /// </devdoc>
        void OnMouseHover(IComponent component);

        /// <include file='doc\IMouseHandler.uex' path='docs/doc[@for="IMouseHandler.OnMouseMove"]/*' />
        /// <devdoc>
        ///     This is called for each movement of the mouse.
        /// </devdoc>
        void OnMouseMove(IComponent component, int x, int y);

        /// <include file='doc\IMouseHandler.uex' path='docs/doc[@for="IMouseHandler.OnMouseUp"]/*' />
        /// <devdoc>
        ///     This is called when the user releases the mouse from a component.
        ///     This will update the UI to reflect the release of the mouse.
        ///
        /// </devdoc>
        void OnMouseUp(IComponent component, MouseButtons button);

        /// <include file='doc\IMouseHandler.uex' path='docs/doc[@for="IMouseHandler.OnSetCursor"]/*' />
        /// <devdoc>
        ///     This is called when the cursor for the given component should be updated.
        ///     The mouse is always over the given component's view when this is called.
        /// </devdoc>
        void OnSetCursor(IComponent component);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\imenustatushandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="IMenuStatusHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms.Design {

    using System.Diagnostics;

    using System;
    using Microsoft.Win32;
    using System.ComponentModel.Design;

    /// <include file='doc\IMenuStatusHandler.uex' path='docs/doc[@for="IMenuStatusHandler"]/*' />
    /// <devdoc>
    ///     We plug this interface into the designer event service for overriding
    ///     menu commands.
    /// </devdoc>
    internal interface IMenuStatusHandler {

        /// <include file='doc\IMenuStatusHandler.uex' path='docs/doc[@for="IMenuStatusHandler.OverrideInvoke"]/*' />
        /// <devdoc>
        ///     CommandSet will check with this handler on each status update
        ///     to see if the handler wants to override the availability of
        ///     this command.
        /// </devdoc>
        bool OverrideInvoke(MenuCommand cmd);
        
        /// <include file='doc\IMenuStatusHandler.uex' path='docs/doc[@for="IMenuStatusHandler.OverrideStatus"]/*' />
        /// <devdoc>
        ///     CommandSet will check with this handler on each status update
        ///     to see if the handler wants to override the availability of
        ///     this command.
        /// </devdoc>
        bool OverrideStatus(MenuCommand cmd);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\imenueditorservice.cs ===
//------------------------------------------------------------------------------
// <copyright file="IMenuEditorService.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms.Design {
    

    using System.Diagnostics;

    using System;
    using Microsoft.Win32;
    using System.Windows.Forms;

    /// <include file='doc\IMenuEditorService.uex' path='docs/doc[@for="IMenuEditorService"]/*' />
    /// <devdoc>
    ///    <para>Provides access to the menu editing service.</para>
    /// </devdoc>
    public interface IMenuEditorService {

        /// <include file='doc\IMenuEditorService.uex' path='docs/doc[@for="IMenuEditorService.GetMenu"]/*' />
        /// <devdoc>
        ///     Gets the current menu.
        /// </devdoc>
        Menu GetMenu();

        /// <include file='doc\IMenuEditorService.uex' path='docs/doc[@for="IMenuEditorService.IsActive"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether the current menu is active.</para>
        /// </devdoc>
        bool IsActive();

        /// <include file='doc\IMenuEditorService.uex' path='docs/doc[@for="IMenuEditorService.SetMenu"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       Sets the current menu visible
        ///       on the form.</para>
        /// </devdoc>
        void SetMenu(Menu menu);

        /// <include file='doc\IMenuEditorService.uex' path='docs/doc[@for="IMenuEditorService.SetSelection"]/*' />
        /// <devdoc>
        ///    <para>Sets the selected menu item of the current menu.</para>
        /// </devdoc>
        void SetSelection(MenuItem item);
        
        /// <include file='doc\IMenuEditorService.uex' path='docs/doc[@for="IMenuEditorService.MessageFilter"]/*' />
        /// <devdoc>
        ///      Allows the editor service to intercept Win32 messages.
        /// </devdoc>
        bool MessageFilter(ref Message m);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\imageindexeditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="ImageIndexEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms.Design {
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.Windows.Forms;
    using System.Drawing;
    using System.Drawing.Design;
        
    using System.ComponentModel.Design;
    using Microsoft.Win32;
    using System.Windows.Forms.Design;
    using System.Windows.Forms.ComponentModel;

    /// <include file='doc\ImageIndexEditor.uex' path='docs/doc[@for="ImageIndexEditor"]/*' />
    /// <devdoc>
    ///    <para> Provides an editor for visually picking an image index.</para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class ImageIndexEditor : UITypeEditor {
        ImageList       currentImageList;
        object          currentInstance;
        UITypeEditor    imageEditor;
    
        /// <include file='doc\ImageIndexEditor.uex' path='docs/doc[@for="ImageIndexEditor.ImageIndexEditor"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Windows.Forms.Design.ImageIndexEditor'/> class.</para>
        /// </devdoc>
        public ImageIndexEditor() {
            // Get the type editor for images.  We use the properties on
            // this to determine if we support value painting, etc.
            //
            imageEditor = (UITypeEditor)TypeDescriptor.GetEditor(typeof(Image), typeof(UITypeEditor));
        }
        
        /// <include file='doc\ImageIndexEditor.uex' path='docs/doc[@for="ImageIndexEditor.GetImage"]/*' />
        /// <devdoc>
        ///      Retrieves an image for the current context at current index.
        /// </devdoc>
        private Image GetImage(ITypeDescriptorContext context, int index) {
            Image image = null;
            object instance = context.Instance;
            
            // If the instances are different, then we need to re-aquire our image list.
            //
            if (index >= 0) {
                if (instance != currentInstance) {
                    currentInstance = instance;
                    PropertyDescriptor imageListProp = null;
                    
                    while(instance != null && imageListProp == null) {
                        PropertyDescriptorCollection props = TypeDescriptor.GetProperties(instance);
                        
                        foreach (PropertyDescriptor prop in props) {
                            if (typeof(ImageList).IsAssignableFrom(prop.PropertyType)) {
                                imageListProp = prop;
                                break;
                            }
                        }
                        
                        if (imageListProp == null) {
                        
                            // We didn't find the image list in this component.  See if the 
                            // component has a "parent" property.  If so, walk the tree...
                            //
                            PropertyDescriptor parentProp = props["Parent"];
                            if (parentProp != null) {
                                instance = parentProp.GetValue(instance);
                            }
                            else {
                                // Stick a fork in us, we're done.
                                //
                                instance = null;
                            }
                        }
                    }
                
                    if (imageListProp != null) {
                        currentImageList = (ImageList)imageListProp.GetValue(instance);
                    }
                }
                
                if (currentImageList != null && index < currentImageList.Images.Count) {
                    image = currentImageList.Images[index];
                }
            }
            
            return image;
        }

        /// <include file='doc\ImageIndexEditor.uex' path='docs/doc[@for="ImageIndexEditor.GetPaintValueSupported"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether this editor supports the painting of a representation
        ///       of an object's value.</para>
        /// </devdoc>
        public override bool GetPaintValueSupported(ITypeDescriptorContext context) {
            if (imageEditor != null) {
                return imageEditor.GetPaintValueSupported(context);
            }
            
            return false;
        }

        /// <include file='doc\ImageIndexEditor.uex' path='docs/doc[@for="ImageIndexEditor.PaintValue"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Paints a representative value of the given object to the provided
        ///       canvas. Painting should be done within the boundaries of the
        ///       provided rectangle.
        ///    </para>
        /// </devdoc>
        public override void PaintValue(PaintValueEventArgs e) {
            if (imageEditor != null && e.Value is int) {
                Image image = GetImage(e.Context, (int)e.Value);
                if (image != null) {
                    imageEditor.PaintValue(new PaintValueEventArgs(e.Context, image, e.Graphics, e.Bounds));
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\inheritanceui.cs ===
//------------------------------------------------------------------------------
// <copyright file="InheritanceUI.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms.Design {
    
    using System;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Design;
    using System.Drawing;
    using System.Diagnostics;
    using System.Windows.Forms;

    /// <devdoc>
    ///     This class handles the user interface for inherited components.
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class InheritanceUI {
        private static Bitmap inheritanceGlyph;
        private static Rectangle inheritanceGlyphRect;
        
        private ToolTip tooltip;

        /// <devdoc>
        ///     The bitmap we use to show inheritance.
        /// </devdoc>
        public Bitmap InheritanceGlyph {
            get {
                if (inheritanceGlyph == null) {
                    inheritanceGlyph = new Bitmap(typeof(InheritanceUI), "InheritedGlyph.bmp");
                    inheritanceGlyph.MakeTransparent();
                }
                
                return inheritanceGlyph;
            }
        }
        
        /// <devdoc>
        ///     The rectangle surrounding the glyph.
        /// </devdoc>
        public Rectangle InheritanceGlyphRectangle {
            get {
                if (inheritanceGlyphRect == Rectangle.Empty) {
                    Size size = InheritanceGlyph.Size;
                    inheritanceGlyphRect = new Rectangle(0, 0, size.Width, size.Height);
                }
                
                return inheritanceGlyphRect;
            }
        }
        
        /// <devdoc>
        ///     Adds an inherited control to our list.  This creates a tool tip for that
        ///     control.
        /// </devdoc>
        public void AddInheritedControl(Control c, InheritanceLevel level) {
            if (tooltip == null) {
                tooltip = new ToolTip();
                tooltip.ShowAlways = true;
            }
            
            Debug.Assert(level != InheritanceLevel.NotInherited, "This should only be called for inherited components.");
            
            string text;
            
            if (level == InheritanceLevel.InheritedReadOnly) {
                text = SR.GetString(SR.DesignerInheritedReadOnly);
            }
            else {
                text = SR.GetString(SR.DesignerInherited);
            }
            
            tooltip.SetToolTip(c, text);
            
            // Also, set all of its non-sited children
            foreach(Control child in c.Controls) {
                if (child.Site == null) {
                    tooltip.SetToolTip(child, text);
                }
            }
        }
        
        public void Dispose() {
            if (tooltip != null) {
                tooltip.Dispose();
            }
        }
    
        /// <devdoc>
        ///     Removes a previously added inherited control.
        /// </devdoc>
        public void RemoveInheritedControl(Control c) {
            if (tooltip != null && tooltip.GetToolTip(c).Length > 0) {
                tooltip.SetToolTip(c, null);
            
                // Also, set all of its non-sited children
                foreach(Control child in c.Controls) {
                    if (child.Site == null) {
                        tooltip.SetToolTip(child, null);
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\imagelistdesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="ImageListDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms.Design {
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.Design;
    using System.Collections;
    using System.ComponentModel.Design;
    using System.Windows.Forms;
    using System.Drawing;
    using Microsoft.Win32;
    using Timer = System.Windows.Forms.Timer;

    /// <include file='doc\ImageListDesigner.uex' path='docs/doc[@for="ImageListDesigner"]/*' />
    /// <devdoc>
    /// <para>Provides design-time functionality for <see cref='System.Windows.Forms.ImageList'/>.</para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class ImageListDesigner : ComponentDesigner {
        // The designer keeps a backup copy of all the images in the image list.  Unlike the image list,
        // we don't lose any information about size and color depth.
        private OriginalImageCollection originalImageCollection;


        /// <include file='doc\ImageListDesigner.uex' path='docs/doc[@for="ImageListDesigner.ColorDepth"]/*' />
        /// <devdoc>
        ///    <para>Accessor method for the ColorDepth property on ImageList. We shadow
        ///       this property at design time.</para>
        /// </devdoc>
        private ColorDepth ColorDepth {
            get {
                return ImageList.ColorDepth;
            }
            set {
                ImageList.Images.Clear();
                ImageList.ColorDepth = value;
                Images.PopulateHandle();
            }
        }

        /// <include file='doc\ImageListDesigner.uex' path='docs/doc[@for="ImageListDesigner.Images"]/*' />
        /// <devdoc>
        ///    <para>Accessor method for the Images property on ImageList. We shadow
        ///       this property at design time.</para>
        /// </devdoc>
        private OriginalImageCollection Images {
            get {
                if (originalImageCollection == null)
                    originalImageCollection = new OriginalImageCollection(this);
                return originalImageCollection;
            }
        }

        internal ImageList ImageList {
            get {
                return(ImageList) Component;
            }
        }

        /// <include file='doc\ImageListDesigner.uex' path='docs/doc[@for="ImageListDesigner.ImageSize"]/*' />
        /// <devdoc>
        ///    <para>Accessor method for the ImageSize property on ImageList. We shadow
        ///       this property at design time.</para>
        /// </devdoc>
        private Size ImageSize {
            get {
                return ImageList.ImageSize;
            }
            set {
                ImageList.Images.Clear();
                ImageList.ImageSize = value;
                Images.PopulateHandle();
            }
        }

        /// <include file='doc\ImageListDesigner.uex' path='docs/doc[@for="ImageListDesigner.ImageStream"]/*' />
        /// <devdoc>
        ///    <para>Accessor method for the ImageStream property on ImageList. We shadow
        ///       this property at design time.</para>
        /// </devdoc>
        private ImageListStreamer ImageStream {
            get {
                return ImageList.ImageStream;
            }
            set {
                ImageList.ImageStream = value;
                Images.ReloadFromImageList();
            }
        }

        /// <include file='doc\ImageListDesigner.uex' path='docs/doc[@for="ImageListDesigner.Dispose"]/*' />
        /// <devdoc>
        ///     Disposes of this designer.
        /// </devdoc>
        protected override void Dispose(bool disposing) {
            if (disposing) {
                IComponentChangeService cs = (IComponentChangeService)GetService(typeof(IComponentChangeService));
                if (cs != null) {
                    cs.ComponentChanging -= new ComponentChangingEventHandler(this.OnComponentChanging);
                    cs.ComponentChanged -= new ComponentChangedEventHandler(this.OnComponentChanged);
                }
            }

            base.Dispose(disposing);
        }

        /// <include file='doc\ImageListDesigner.uex' path='docs/doc[@for="ImageListDesigner.Initialize"]/*' />
        /// <devdoc>
        ///     Called by the host when we're first initialized.
        /// </devdoc>
        public override void Initialize(IComponent component) {
            base.Initialize(component);

            IComponentChangeService cs = (IComponentChangeService)GetService(typeof(IComponentChangeService));
            if (cs != null) {
                cs.ComponentChanging += new ComponentChangingEventHandler(this.OnComponentChanging);
                cs.ComponentChanged += new ComponentChangedEventHandler(this.OnComponentChanged);
            }
        }

        private void OnComponentChanging(object sender, ComponentChangingEventArgs e) {
            if (e.Component == Component && e.Member != null && e.Member.Name == "Images") {
                PropertyDescriptor imageProp = TypeDescriptor.GetProperties(Component)["ImageStream"];
                RaiseComponentChanging(imageProp);
            }
        }


        private void OnComponentChanged(object sender, ComponentChangedEventArgs e) {
            if (e.Component == Component && e.Member != null && e.Member.Name == "Images") {
                PropertyDescriptor imageProp = TypeDescriptor.GetProperties(Component)["ImageStream"];
                RaiseComponentChanging(imageProp);
            }
        }

        /// <include file='doc\ImageListDesigner.uex' path='docs/doc[@for="ImageListDesigner.PreFilterProperties"]/*' />
        /// <devdoc>
        ///    <para>Provides an opportunity for the designer to filter the properties.</para>
        /// </devdoc>
        protected override void PreFilterProperties(IDictionary properties) {
            base.PreFilterProperties(properties);

            // Handle shadowed properties
            //
            string[] shadowProps = new string[] {
                "ColorDepth",
                "ImageSize",
                "ImageStream",
            };

            Attribute[] empty = new Attribute[0];

            for (int i = 0; i < shadowProps.Length; i++) {
                PropertyDescriptor prop = (PropertyDescriptor)properties[shadowProps[i]];
                if (prop != null) {
                    properties[shadowProps[i]] = TypeDescriptor.CreateProperty(typeof(ImageListDesigner), prop, empty);
                }
            }

            // replace this one seperately because it is of a different type (OriginalImageCollection) than
            // the original property (ImageCollection)
            //
            PropertyDescriptor imageProp = (PropertyDescriptor)properties["Images"];

            if (imageProp != null) {
                Attribute[] attrs = new Attribute[imageProp.Attributes.Count];
                imageProp.Attributes.CopyTo(attrs, 0);
                properties["Images"] = TypeDescriptor.CreateProperty(typeof(ImageListDesigner), "Images", typeof(OriginalImageCollection), attrs);
            }

        }

        //  Shadow ImageList.Images to allow arbitrary handle recreation.
        [
           Editor("System.Windows.Forms.Design.ImageCollectionEditor, " + AssemblyRef.SystemDesign, typeof(System.Drawing.Design.UITypeEditor))
        ]
        internal class OriginalImageCollection : IList {
            private ImageListDesigner owner;
            private IList list = new ArrayList();

            internal OriginalImageCollection(ImageListDesigner owner) {
                this.owner = owner;
                // just in case it's got images
                ReloadFromImageList();
            }

            private void AssertInvariant() {
                Debug.Assert(owner != null, "OriginalImageCollection has no owner (ImageListDesigner)");
                Debug.Assert(list != null, "OriginalImageCollection has no list (ImageListDesigner)");
            }
            
            public int Count {
                get {
                    AssertInvariant();
                    return list.Count;
                }
            }
            
            public bool IsReadOnly {
                get {
                    return false;
                }
            }
            
            bool IList.IsFixedSize {
                get {
                    return false;
                }
            }

            [Browsable(false), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
            public Image this[int index] {
                get {
                    if (index < 0 || index >= Count)
                        throw new ArgumentOutOfRangeException(SR.GetString(SR.InvalidArgument,
                                                                  "index",
                                                                  index.ToString()));
                    return(Image) list[index];
                }
                set {
                    if (!(value is Bitmap))
                        throw new ArgumentException(SR.GetString(SR.ImageListDesignerMustBeBitmap));

                    if (index < 0 || index >= Count)
                        throw new ArgumentOutOfRangeException(SR.GetString(SR.InvalidArgument,
                                                                  "index",
                                                                  index.ToString()));

                    if (value == null)
                        throw new ArgumentException(SR.GetString(SR.InvalidArgument,
                                                                  "value",
                                                                  "null"));

                    AssertInvariant();
                    list[index] = value;
                    RecreateHandle();
                }

            }
            
            object IList.this[int index] {
                get {
                    return this[index];
                }
                set {
                    // Test for bitmap?
                    if (value is Image) {
                        this[index] = (Image)value;
                    }
                    else {
                        throw new ArgumentException("value");
                    }
                }
            }

            /// <include file='doc\ImageListDesigner.uex' path='docs/doc[@for="ImageListDesigner.OriginalImageCollection.Add"]/*' />
            /// <devdoc>
            ///     Add the given image to the ImageList.
            /// </devdoc>
            public int Add(Image value) {
                int index = list.Add(value);
                owner.ImageList.Images.Add(value);
                return index;
            }
            
            public void AddRange(Image[] values) {
                if (values == null) {
                    throw new ArgumentNullException("values");
                }
                foreach(Image value in values) {
                    if (value != null) {
                        Add(value);
                    }
                }
            }
            
            int IList.Add(object value) {
                if (value is Image) {
                    return Add((Image)value);
                }
                else {
                    throw new ArgumentException("value");
                }
            }

            // Called when reloading the form.  In this case, we have no "originals" list,
            // so we make one out of the image list.  
            internal void ReloadFromImageList() {
                list.Clear();
                foreach (Image image in owner.ImageList.Images) {
                    list.Add(image);
                }
            }

            /// <include file='doc\ImageListDesigner.uex' path='docs/doc[@for="ImageListDesigner.OriginalImageCollection.Clear"]/*' />
            /// <devdoc>
            ///     Remove all images and masks from the ImageList.
            /// </devdoc>
            public void Clear() {
                AssertInvariant();
                list.Clear();
                owner.ImageList.Images.Clear();
            }
            
            public bool Contains(Image value) {
                return list.Contains(value);
            }
            
            bool IList.Contains(object value) {
                if (value is Image) {
                    return Contains((Image)value);
                }
                else { 
                    return false;
                }
            }

            public IEnumerator GetEnumerator() {
                return list.GetEnumerator();
            }
            
            public int IndexOf(Image value) {
                return list.IndexOf(value);
            }
            
            int IList.IndexOf(object value) {
                if (value is Image) {
                    return IndexOf((Image)value);
                }
                else {
                    return -1;
                }
            }
            
            void IList.Insert(int index, object value) {
                throw new NotSupportedException();
            }
            
            internal void PopulateHandle() {
                for (int i = 0; i < list.Count; i++) {
                    Image image = (Image) list[i];
                    owner.ImageList.Images.Add(image);
                }
            }

            private void RecreateHandle() {
                owner.ImageList.Images.Clear();
                PopulateHandle();
            }

            public void Remove(Image value) {
                AssertInvariant();
                list.Remove(value);
                RecreateHandle();
            }
            
            void IList.Remove(object value) {
                if (value is Image) {
                    Remove((Image)value);
                }
            }
            
            public void RemoveAt(int index) {
                if (index < 0 || index >= Count)
                    throw new ArgumentOutOfRangeException(SR.GetString(SR.InvalidArgument,
                                                              "index",
                                                              index.ToString()));

                AssertInvariant();
                list.RemoveAt(index);
                RecreateHandle();
            }
            
            int ICollection.Count {
                get {
                    return Count;
                }
            }

            bool ICollection.IsSynchronized {
                get {
                    return false;
                }
            }

            object ICollection.SyncRoot {
                get {
                    return null;
                }
            }

            void ICollection.CopyTo(Array array, int index) {
                list.CopyTo(array, index);
            }

            IEnumerator IEnumerable.GetEnumerator() {
                return GetEnumerator();
            }
        } // end class OriginalImageCollection
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\documentdesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="DocumentDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms.Design {
    using System.Design;
    using System.Runtime.Serialization;
    using System.Runtime.Serialization.Formatters;
    using Microsoft.Win32;
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.IO;
    using System.Text;
    using System.Collections;    
    using System.ComponentModel.Design;
    using System.Drawing;
    using System.Drawing.Design;
    using System.Reflection;
    using System.Windows.Forms;
    using System.Globalization;

    /// <include file='doc\DocumentDesigner.uex' path='docs/doc[@for="DocumentDesigner"]/*' />
    /// <devdoc>
    ///    <para>Provides a designer that extends the ScrollableControlDesigner and implements 
    ///       IRootDesigner.</para>
    /// </devdoc>
    [
    System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode),
    ToolboxItemFilter("System.Windows.Forms")
    ]
    public class DocumentDesigner : ScrollableControlDesigner, IRootDesigner, IToolboxUser, IOleDragClient {

        private LocalizationExtenderProvider   localizer;
        private DesignerFrame                  frame;
        private ControlCommandSet              commandSet;
        private InheritanceService             inheritanceService;
        private EventHandlerService            eventHandlerService;
        private SelectionUIService             selectionUIService;
        private DesignBindingValueUIHandler    designBindingValueUIHandler;
        private DesignerExtenders              designerExtenders;
        private InheritanceUI                  inheritanceUI;
        private PbrsForward                    pbrsFwd;
        
        //used to keep the state of the tab order view
        //
        private bool queriedTabOrder = false;
        private MenuCommand tabOrderCommand = null;

        //our menu editor service
        //
        /// <include file='doc\DocumentDesigner.uex' path='docs/doc[@for="DocumentDesigner.menuEditorService"]/*' />
        protected IMenuEditorService    menuEditorService = null;


        // The component tray
        //
        private ComponentTray componentTray;

        private int trayHeight = 80;
        private bool trayLargeIcon = false;
        private bool trayAutoArrange = false;
        private bool trayLayoutSuspended = false;

        // Interaction with the toolbox.
        //
        private bool         tbxCategorySet = false;

        // ActiveX support
        //
        private static Guid htmlDesignTime = new Guid("73CEF3DD-AE85-11CF-A406-00AA00C00940");

        private Hashtable axTools = null;
        private static TraceSwitch AxToolSwitch     = new TraceSwitch("AxTool", "ActiveX Toolbox Tracing");
        private static readonly string axClipFormat = "CLSID";
        private ToolboxItemCreatorCallback toolboxCreator = null;

        /// <devdoc>
        ///     BackColor property on control.  We shadow this property at design time.
        /// </devdoc>
        private Color BackColor {
            get {
                return Control.BackColor;
            }
            set {
                ShadowProperties["BackColor"] = value;
                if (value.IsEmpty) {
                    value = SystemColors.Control;
                }
                Control.BackColor = value;
            }
        }

        /// <devdoc>
        ///     Location property on control.  We shadow this property at design time.
        /// </devdoc>
        [DefaultValue(typeof(Point), "0, 0")]
        private Point Location {
            get {
                return (Point)ShadowProperties["Location"];
            }
            set {
                ShadowProperties["Location"] = value;
            }
        }

        /// <include file='doc\DocumentDesigner.uex' path='docs/doc[@for="DocumentDesigner.SelectionRules"]/*' />
        /// <devdoc>
        ///     We override our selectino rules to make the document non-sizeable.
        /// </devdoc>
        public override SelectionRules SelectionRules {
            get {
                SelectionRules rules = base.SelectionRules;
                rules &= ~(SelectionRules.Moveable | SelectionRules.TopSizeable | SelectionRules.LeftSizeable);

                return rules;
            }
        }
    
        /// <devdoc>
        ///      Determines if the tab order UI is active.  When tab order is active, we don't want to forward
        ///      any WndProc messages to the menu editor service (those are all non-selectable components)
        /// </devdoc>
        private bool TabOrderActive {
            get {
                if (!queriedTabOrder) {
                    queriedTabOrder = true;
                    IMenuCommandService menuCommandService = (IMenuCommandService)GetService(typeof(IMenuCommandService));
                    if (menuCommandService != null)
                        tabOrderCommand = menuCommandService.FindCommand(MenuCommands.TabOrder);
                }

                if (tabOrderCommand != null) {
                    return tabOrderCommand.Checked;
                }

                return false;
            }
        }

        /// <devdoc>
        /// </devdoc>
        [DefaultValue(true)]
        private bool TrayAutoArrange {
            get {
                return trayAutoArrange;
            }

            set {
                trayAutoArrange = value;
                if (componentTray != null) {
                    componentTray.AutoArrange = trayAutoArrange;
                }
            }
        }

        /// <devdoc>
        /// </devdoc>
        [DefaultValue(false)]
        private bool TrayLargeIcon {
            get {
                return trayLargeIcon;
            }

            set {
                trayLargeIcon = value;
                if (componentTray != null) {
                    componentTray.ShowLargeIcons = trayLargeIcon;
                }
            }
        }

        /// <devdoc>
        /// </devdoc>
        [DefaultValue(80)]
        private int TrayHeight {
            get {
                if (componentTray != null) {
                    return componentTray.Height;
                }
                else {
                    return trayHeight;
                }
            }

            set {
                trayHeight = value;
                if (componentTray != null) {
                    componentTray.Height = trayHeight;
                }
            }
        }

        /// <include file='doc\DocumentDesigner.uex' path='docs/doc[@for="DocumentDesigner.IOleDragClient.GetControlForComponent"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Retrieves the control view instance for the given component.
        /// For Win32 designer, this will often be the component itself.
        /// </devdoc>
        Control IOleDragClient.GetControlForComponent(object component) {
            Control c = GetControl(component);
            if (c != null)
                return c;

            if (componentTray != null) {
                return ((IOleDragClient)componentTray).GetControlForComponent(component);
            }

            return null;
        }
        
        internal virtual bool CanDropComponents(DragEventArgs de) {
            // If there is no tray we bail.
            if (componentTray == null)
                return true;

            // Figure out if any of the components in the drag-drop are children
            // of our own tray. If so, we should prevent this drag-drop from proceeding.
            //
            OleDragDropHandler ddh = GetOleDragHandler();
            object[] dragComps = ddh.GetDraggingObjects(de);

            if (dragComps != null) {
                IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
                for (int  i = 0; i < dragComps.Length; i++) {
                    if (host == null || dragComps[i] == null || !(dragComps[i] is IComponent)) {
                        continue;
                    }

                    if (componentTray.IsTrayComponent((IComponent)dragComps[i])) {
                        return false;
                    }
                }
            }

            return true;
        }

        /// <include file='doc\DocumentDesigner.uex' path='docs/doc[@for="DocumentDesigner.Dispose"]/*' />
        /// <devdoc>
        ///     Disposes of this designer.
        /// </devdoc>
        protected override void Dispose(bool disposing) {
            if (disposing) {
                IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
                Debug.Assert(host != null, "Must have a designer host on dispose");

                if (host != null) {
                    host.RemoveService(typeof(IInheritanceService));
                    host.RemoveService(typeof(IEventHandlerService));
                    host.RemoveService(typeof(ISelectionUIService));
                    host.RemoveService(typeof(IOverlayService));
                    host.RemoveService(typeof(ISplitWindowService));
                    host.RemoveService(typeof(InheritanceUI));
                    host.Activated -= new EventHandler(OnDesignerActivate);
                    host.Deactivated -= new EventHandler(OnDesignerDeactivate);

                    // If the tray wasn't destroyed, then we got some sort of inbalance
                    // in our add/remove calls.  Don't sweat it, but do nuke the tray.
                    //
                    if (componentTray != null) {
                        ISplitWindowService sws = (ISplitWindowService)GetService(typeof(ISplitWindowService));
                        if (sws != null) {
                            sws.RemoveSplitWindow(componentTray);
                            componentTray.Dispose();
                            componentTray = null;
                        }

                        host.RemoveService(typeof(ComponentTray));
                    }

                    IComponentChangeService cs = (IComponentChangeService)GetService(typeof(IComponentChangeService));
                    if (cs != null) {
                        cs.ComponentAdded -= new ComponentEventHandler(this.OnComponentAdded);
                        cs.ComponentChanged -= new ComponentChangedEventHandler(this.OnComponentChanged);
                        cs.ComponentRemoved -= new ComponentEventHandler(this.OnComponentRemoved);
                    }

                    if (toolboxCreator != null) {
                        Debug.WriteLineIf(AxToolSwitch.TraceVerbose, "Removing DocumentDesigner as CLSID ToolboxItemCreator");                
                        IToolboxService toolbox = (IToolboxService)GetService(typeof(IToolboxService));
                        Debug.Assert(toolbox != null, "No toolbox service available");
                        if (toolbox != null) {
                            toolbox.RemoveCreator(axClipFormat, host);
                        }
                        toolboxCreator = null;
                    }
                }
                
                ISelectionService ss = (ISelectionService)GetService(typeof(ISelectionService));
                if (ss != null) {
                    ss.SelectionChanged -= new EventHandler(this.OnSelectionChanged);                    
                }
                
                if (localizer != null) {
                    localizer.Dispose();
                    localizer = null;
                }

                if (componentTray != null) {
                    if (host != null) {
                        ISplitWindowService sws = (ISplitWindowService)GetService(typeof(ISplitWindowService));
                        if (sws != null) {
                            sws.RemoveSplitWindow(componentTray);
                        }
                    }
                    componentTray.Dispose();
                    componentTray = null;
                }

                if (this.pbrsFwd != null) {
                    this.pbrsFwd.Dispose();
                    this.pbrsFwd = null;
                }

                if (frame != null) {
                    frame.Dispose();
                    frame = null;
                }

                if (commandSet != null) {
                    commandSet.Dispose();
                    commandSet = null;
                }

                if (inheritanceService != null) {
                    inheritanceService.Dispose();
                    inheritanceService = null;
                }

                if (inheritanceUI != null) {
                    inheritanceUI.Dispose();
                    inheritanceUI = null;
                }

                if (selectionUIService != null) {
                    selectionUIService.Dispose();
                    selectionUIService = null;
                }

                if (designBindingValueUIHandler != null) {
                
                    IPropertyValueUIService pvUISvc = (IPropertyValueUIService)GetService(typeof(IPropertyValueUIService));
                    if (pvUISvc != null) {
                        pvUISvc.RemovePropertyValueUIHandler(new PropertyValueUIHandler(designBindingValueUIHandler.OnGetUIValueItem));
                        pvUISvc = null;
                    }
                
                    designBindingValueUIHandler.Dispose();
                    designBindingValueUIHandler = null;
                }

                if (designerExtenders != null) {
                    designerExtenders.Dispose();
                    designerExtenders = null;
                }

                if (axTools != null) {
                    axTools.Clear();
                }
            }

            base.Dispose(disposing);
        }

        /// <devdoc>
        ///      Examines the current selection for a suitable frame designer.  This
        ///      is used when we are creating a new component so we know what control
        ///      to parent the component to.  This will always return a frame designer,
        ///      and may walk all the way up the control parent chain to this designer
        ///      if it needs to.
        /// </devdoc>
        private ParentControlDesigner GetSelectedParentControlDesigner() {
            ISelectionService s = (ISelectionService)GetService(typeof(ISelectionService));
            ParentControlDesigner parentControlDesigner = null;

            if (s != null) {
                // We first try the primary selection.  If that is null
                // or isn't a Control, we then walk the set of selected
                // objects.  Failing all of this, we default to us.
                //
                object sel = s.PrimarySelection;

                if (sel == null || !(sel is Control)) {
                    sel = null;

                    ICollection sels = s.GetSelectedComponents();

                    foreach(object obj in sels) {
                        if (obj is Control) {
                            sel = obj;
                            break;
                        }
                    }
                }

                if (sel != null) {
                    // Now that we have our currently selected component
                    // we can walk up the parent chain looking for a frame
                    // designer.
                    //
                    Debug.Assert(sel is Control, "Our logic is flawed - sel should be a Control");
                    Control c = (Control)sel;

                    IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));

                    if (host != null) {
                        while (c != null) {
                            object designer = host.GetDesigner(c);

                            if (designer is ParentControlDesigner) {
                                parentControlDesigner = (ParentControlDesigner)designer;
                                break;
                            }

                            c = c.Parent;
                        }
                    }
                }
            }

            if (parentControlDesigner == null) {
                parentControlDesigner = this;
            }

            return parentControlDesigner;
        }

        /// <include file='doc\DocumentDesigner.uex' path='docs/doc[@for="DocumentDesigner.GetToolSupported"]/*' />
        /// <devdoc>
        ///      Determines if the given tool is supported by this designer.
        ///      If a tool is supported then it will be enabled in the toolbox
        ///      when this designer regains focus.  Otherwise, it will be disabled.
        ///      Once a tool is marked as enabled or disabled it may not be
        ///      queried again.
        /// </devdoc>
        protected virtual bool GetToolSupported(ToolboxItem tool) {
            return true;
        }

        /// <include file='doc\DocumentDesigner.uex' path='docs/doc[@for="DocumentDesigner.Initialize"]/*' />
        /// <devdoc>
        ///     Initializes the designer with the given component.  The designer can
        ///     get the component's site and request services from it in this call.
        /// </devdoc>
        public override void Initialize(IComponent component) {
            
            base.Initialize(component);

            // If the back color of the control has not been established, force it to be
            // "Control" so it doesn't walk up the parent chain and grab the document window's
            // back color.
            //
            PropertyDescriptor backProp = TypeDescriptor.GetProperties(Component.GetType())["BackColor"];
            if (backProp != null && backProp.PropertyType == typeof(Color) && !backProp.ShouldSerializeValue(Component)) {
                Control.BackColor = SystemColors.Control;
            }
            
            IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
            IExtenderProviderService exps = (IExtenderProviderService)GetService(typeof(IExtenderProviderService));
            if (exps != null) {
                designerExtenders = new DesignerExtenders(exps);
            }
            
            if (host != null) {
                host.Activated += new EventHandler(OnDesignerActivate);
                host.Deactivated += new EventHandler(OnDesignerDeactivate);

                ServiceCreatorCallback callback = new ServiceCreatorCallback(this.OnCreateService);
                host.AddService(typeof(IEventHandlerService), callback);
                selectionUIService = new SelectionUIService(host);
                ((ISelectionUIService)selectionUIService).AssignSelectionUIHandler(component, this);
                host.AddService(typeof(ISelectionUIService), selectionUIService);
                
                // Create the view for this component. We first create the designer frame so we can provide
                // the overlay and split window services, and then later on we initilaize the frame with
                // the designer view.
                //
                frame = new DesignerFrame(component.Site);
                
                IOverlayService os = (IOverlayService)frame;
                host.AddService(typeof(IOverlayService), os);
                host.AddService(typeof(ISplitWindowService), frame);
                
                // Now that we have our view window, connect the selection UI into
                // it so we can render.
                //
                os.PushOverlay(selectionUIService);
                     
                // And component add and remove events for our tray
                //
                IComponentChangeService cs = (IComponentChangeService)GetService(typeof(IComponentChangeService));
                if (cs != null) {
                    cs.ComponentAdded += new ComponentEventHandler(this.OnComponentAdded);
                    cs.ComponentChanged += new ComponentChangedEventHandler(this.OnComponentChanged);
                    cs.ComponentRemoved += new ComponentEventHandler(this.OnComponentRemoved);
                }
                
                // We must do the ineritance scan early, but not so early that we haven't hooked events
                // to handle invisible components.  We also use the variable "inheritanceService"
                // as a check in OnCreateHandle -- we cannot call base.OnCreateHandle if we have
                // not done an inheritance scan yet, because this will cause the base control
                // class to hook all of the controls we may want to inherit.  So, we do the
                // scan, assign the variable, and then call OnCreateHandle if needed.
                //
                inheritanceUI = new InheritanceUI();
                host.AddService(typeof(InheritanceUI), inheritanceUI);

                InheritanceService isvc = new DocumentInheritanceService(this);
                host.AddService(typeof(IInheritanceService), isvc);
                isvc.AddInheritedComponents(component, component.Site.Container);
                inheritanceService = isvc;
                if (Control.IsHandleCreated) {
                    OnCreateHandle();
                }
                
                // Declare a new localizer instance... this will add 2 extender props (language and localizable)
                //
                localizer = new LocalizationExtenderProvider(component.Site, host.RootComponent);

                IPropertyValueUIService pvUISvc = (IPropertyValueUIService)component.Site.GetService(typeof(IPropertyValueUIService));

                if (pvUISvc != null) {
                    designBindingValueUIHandler = new DesignBindingValueUIHandler();
                    pvUISvc.AddPropertyValueUIHandler(new PropertyValueUIHandler(designBindingValueUIHandler.OnGetUIValueItem));
                }

                // Add the DocumentDesigner as a creator of CLSID toolbox items.
                //
                Debug.WriteLineIf(AxToolSwitch.TraceVerbose, "Adding DocumentDesigner as CLSID ToolboxItemCreator");                
                IToolboxService toolbox = (IToolboxService)host.GetService(typeof(IToolboxService));
                if (toolbox != null) {
                    toolboxCreator = new ToolboxItemCreatorCallback(this.OnCreateToolboxItem);
                    toolbox.AddCreator(toolboxCreator, axClipFormat, host);
                }
                
                // Listen for the completed load.  When finished, we need to select the form.  We don'
                // want to do it before we're done, however, or else the dimensions of the selection rectangle
                // could be off because during load, change events are not fired.
                //
                host.LoadComplete += new EventHandler(this.OnLoadComplete);
            }

            // Setup our menu command structure.
            //
            Debug.Assert(component.Site != null, "Designer host should have given us a site by now.");
            commandSet = new ControlCommandSet(component.Site);

            // Finally hook the designer view into the frame.  We do this last because the frame may
            // cause the control to be created, and if this happens before the inheritance scan we
            // will subclass the inherited controls before we get a chance to attach designers.  
            //
            frame.Initialize(Control);
            this.pbrsFwd = new PbrsForward(frame, component.Site);
            
            // And force some shadow properties that we change in the course of
            // initializing the form.
            //
            Location = new Point(0, 0);
        }

        /// <devdoc>
        ///     Checks to see if the give CLSID is an ActiveX control
        ///     that we support.  This ignores designtime controls.
        /// </devdoc>
        private bool IsSupportedActiveXControl(string clsid) {
            RegistryKey key = null;
            RegistryKey designtimeKey = null;

            try {
                string controlKey = "CLSID\\" + clsid + "\\Control";
                key = Registry.ClassesRoot.OpenSubKey(controlKey);
                if (key != null) {

                    // ASURT 36817:
                    // We are not going to support design-time controls for this revision. We use the guids under
                    // HKCR\Component Categories to decide which categories to avoid. Currently the only one is
                    // the "HTML Design-time Control" category implemented by VID controls.
                    //
                    string category = "CLSID\\" + clsid + "\\Implemented Categories\\{" + htmlDesignTime.ToString() + "}";
                    designtimeKey = Registry.ClassesRoot.OpenSubKey(category);
                    return(designtimeKey == null);
                }

                return false;
            }
            finally {
                if (key != null)
                    key.Close();

                if (designtimeKey != null)
                    designtimeKey.Close();
            }
        }

        /// <devdoc>
        ///      Called when a component is added to the design container.
        ///      If the component isn't a control, this will demand create
        ///      the component tray and add the component to it.
        /// </devdoc>
        private void OnComponentAdded(object source, ComponentEventArgs ce) {
            IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
            if (host != null) {
                IComponent component = ce.Component;

                //if the component is a contextMenu - we'll start of the service
                EnsureMenuEditorService(ce.Component);

                bool addControl = true;
    
                // This is the mirror to logic in ParentControlDesigner.  The component should be
                // added somewhere, and this logic decides where.
                //
                IDesigner designer = host.GetDesigner(component);
                if (designer is ControlDesigner) {
                    ControlDesigner cd = (ControlDesigner)designer;
                    if (!(cd.Control is Form) || !((Form)cd.Control).TopLevel) {
                        addControl = false;
                    }
                }
    
                if (addControl &&
                    TypeDescriptor.GetAttributes(component).Contains(DesignTimeVisibleAttribute.Yes)) {
    
                    if (componentTray == null) {
                        ISplitWindowService sws = (ISplitWindowService)GetService(typeof(ISplitWindowService));
                        if (sws != null) {
                            componentTray = new ComponentTray(this, Component.Site);
                            sws.AddSplitWindow(componentTray);
                            
                            componentTray.Height = trayHeight;
                            componentTray.ShowLargeIcons = trayLargeIcon;
                            componentTray.AutoArrange = trayAutoArrange;
    
                            host.AddService(typeof(ComponentTray), componentTray);
                        }
                    }
    
                    if (componentTray != null) {
                        // Suspend the layout of the tray through the loading
                        // process. This way, we won't continuosly try to layout
                        // components in auto arrange mode. We will instead let
                        // the controls restore themselves to their persisted state
                        // and then let auto-arrange kick in once.
                        //
                        if (host != null && host.Loading && !trayLayoutSuspended) {
                            trayLayoutSuspended = true;
                            componentTray.SuspendLayout();
                        }
                        componentTray.AddComponent(component);
                    }
                }
            }
        }

        /// <devdoc>
        ///      Called when a component is removed from the design container.
        ///      Here we check to see there are no more components on the tray
        ///      and if not, we will remove the tray.
        /// </devdoc>
        private void OnComponentRemoved(object source, ComponentEventArgs ce) {
            bool designableAsControl = (ce.Component is Control) && !(ce.Component is Form && ((Form)ce.Component).TopLevel);
            if (!designableAsControl && componentTray != null) {
                componentTray.RemoveComponent(ce.Component);

                if (componentTray.ComponentCount == 0) {
                    ISplitWindowService sws = (ISplitWindowService)GetService(typeof(ISplitWindowService));
                    if (sws != null) {
                        sws.RemoveSplitWindow(componentTray);
                        IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
                        if (host != null) {
                            host.RemoveService(typeof(ComponentTray));
                        }
                        componentTray.Dispose();
                        componentTray = null;
                    }
                }
            }
        }

        /// <include file='doc\DocumentDesigner.uex' path='docs/doc[@for="DocumentDesigner.OnContextMenu"]/*' />
        /// <devdoc>
        ///     Called when the context menu should be displayed.  This displays the document
        ///     context menu.
        /// </devdoc>
        protected override void OnContextMenu(int x, int y) {
            IMenuCommandService mcs = (IMenuCommandService)GetService(typeof(IMenuCommandService));
            if (mcs != null) {
                ISelectionService selSvc = (ISelectionService)GetService(typeof(ISelectionService));
                if (selSvc != null) {

                    // Here we check to see if we're the only component selected.  If not, then
                    // we'll display the standard component menu.
                    //
                    if (selSvc.SelectionCount == 1 && selSvc.GetComponentSelected(Component)) {
                        mcs.ShowContextMenu(MenuCommands.ContainerMenu, x, y);
                    }
                    else {
                        mcs.ShowContextMenu(MenuCommands.SelectionMenu, x, y);
                    }
                }
            }
        }

        /// <include file='doc\DocumentDesigner.uex' path='docs/doc[@for="DocumentDesigner.OnCreateHandle"]/*' />
        /// <devdoc>
        ///      This is called immediately after the control handle has been created.
        /// </devdoc>
        protected override void OnCreateHandle() {
            // Don't call base unless our inheritance serivce is already running.
            if (inheritanceService != null) {
                base.OnCreateHandle();
            }
        }

        /// <devdoc>
        ///     Creates some of the more infrequently used services we offer.
        /// </devdoc>
        private object OnCreateService(IServiceContainer container, Type serviceType) {
            if (serviceType == typeof(IEventHandlerService)) {
                if (eventHandlerService == null) {
                    eventHandlerService = new EventHandlerService(frame);
                }
                return eventHandlerService;
            }
            Debug.Fail("Called back to create a service we don't know how to create: " + serviceType.Name);
            return null;
        }
        
        /// <devdoc>
        ///      Called when our document becomes active.  We paint our form's
        ///      border the appropriate color here.
        /// </devdoc>
        private ToolboxItem OnCreateToolboxItem(object serializedData, string format) {
            Debug.WriteLineIf(AxToolSwitch.TraceVerbose, "Checking to see if: " + format + " is supported.");
            
            IDataObject dataObject = serializedData as IDataObject;
            
            if (dataObject == null) {
                Debug.Fail("Toolbox service didn't pass us a data object; that should never happen");
                return null;
            }
            
            // We only support the CLSID format.
            if (!format.Equals(axClipFormat)) {
                return null;
            }

            AxToolboxItem tool = null;

            // Read the stream out of the dataobject and get hold of the CLSID of the Toolbox item.
            //
            MemoryStream stm = (MemoryStream)dataObject.GetData(axClipFormat, true);
            int len = (int)stm.Length;
            byte[] bytes = new byte[len];
            stm.Read(bytes, 0, len);

            string clsid = System.Text.Encoding.Default.GetString(bytes);
            int index = clsid.IndexOf("}");
            clsid = clsid.Substring(0, index+1);
            Debug.WriteLineIf(AxToolSwitch.TraceVerbose, "\tCLSID of the Toolbox item: " + clsid);

            // Look to see if we can find the Control key for this CLSID. If present, create a 
            // new AxToolboxItem and add it to the cache.
            //
            if (IsSupportedActiveXControl(clsid)) {
                // Look to see if we have already cached the ToolboxItem. 
                //
                if (axTools != null) {
                    tool = (AxToolboxItem)axTools[clsid];
                    if (tool != null) {
                        if (AxToolSwitch.TraceVerbose) Debug.WriteLine("Found AxToolboxItem in tool cache");
                        return tool;
                    }
                }

                tool = new AxToolboxItem(clsid);
                if (axTools == null) {
                    axTools = new Hashtable();
                }
                axTools.Add(clsid, tool);
                Debug.WriteLineIf(AxToolSwitch.TraceVerbose, "\tAdded AxToolboxItem");
                return tool;
            }

            return null;
        }

        /// <devdoc>
        ///      Called when our document becomes active.  Here we try to
        ///      select the appropriate toolbox tab.
        /// </devdoc>
        private void OnDesignerActivate(object source, EventArgs evevent) {
            // set Windows Forms as the active toolbox tab
            //
            if (!tbxCategorySet) {
                IToolboxService toolboxSvc = (IToolboxService)GetService(typeof(IToolboxService));
                if (toolboxSvc != null) {
                    try {
                        toolboxSvc.SelectedCategory = SR.GetString(SR.DesignerDefaultTab);
                        tbxCategorySet = true;
                    }
                    catch (Exception ex) {
                        Debug.Fail("'" + SR.GetString(SR.DesignerDefaultTab) + "' is not a valid toolbox category [exception:" + ex.ToString() + "]");
                    }
                }
            }
        }

        /// <devdoc>
        ///     Called by the host when we become inactive.  Here we update the
        ///     title bar of our form so it's the inactive color.
        /// </devdoc>
        private void OnDesignerDeactivate(object sender, EventArgs e) {
            Control control = Control;
            if (control != null && control.IsHandleCreated) {
                NativeMethods.SendMessage(control.Handle, NativeMethods.WM_NCACTIVATE, 0, 0);
                SafeNativeMethods.RedrawWindow(control.Handle, null, IntPtr.Zero, NativeMethods.RDW_FRAME);
            }
        }

        /// <devdoc>
        ///     Called when the designer is finished loading.  Here we select the form.
        /// </devdoc>
        private void OnLoadComplete(object sender, EventArgs e) {
        
            // Remove the handler; we're done looking at this.
            //
            ((IDesignerHost)sender).LoadComplete -= new EventHandler(this.OnLoadComplete);
            
            // Restore the tray layout.
            //
            if (trayLayoutSuspended && componentTray != null)
                componentTray.ResumeLayout();

            // Select this component.
            //
            ISelectionService ss = (ISelectionService)GetService(typeof(ISelectionService));
            if (ss != null) {
                ss.SelectionChanged += new EventHandler(this.OnSelectionChanged);
                ss.SetSelectedComponents(new object[] {Component}, SelectionTypes.Replace);
                Debug.Assert(ss.PrimarySelection == Component, "Bug in selection service:  form should have primary selection.");
            }            
        }

        private void OnComponentChanged(object sender, ComponentChangedEventArgs e) {
            Control ctrl = e.Component as Control;
            if (ctrl != null && ctrl.IsHandleCreated) {
                UnsafeNativeMethods.NotifyWinEvent((int)AccessibleEvents.LocationChange, ctrl.Handle, NativeMethods.OBJID_CLIENT, 0);
                if (this.frame.Focused) {
                    UnsafeNativeMethods.NotifyWinEvent((int)AccessibleEvents.Focus, ctrl.Handle, NativeMethods.OBJID_CLIENT, 0);
                }
            }
        }       
               
        /// <devdoc>
        ///      Called by the selection service when the selection has changed.  We do a number 
        ///      of selection-related things here.
        /// </devdoc>
        private void OnSelectionChanged(Object sender, EventArgs e) {
            ISelectionService svc = (ISelectionService)GetService( typeof(ISelectionService) );
             if (svc != null) {
             
                ICollection selComponents = svc.GetSelectedComponents();
                
                // Setup the correct active accessibility selection / focus data
                //
                Debug.WriteLineIf(CompModSwitches.MSAA.TraceInfo, "MSAA: SelectionChanged");
                foreach(object selObj in selComponents) {
                    Control c = selObj as Control;
                    if (c != null) {
                        Debug.WriteLineIf(CompModSwitches.MSAA.TraceInfo, "MSAA: SelectionAdd, control = " + c.ToString());
                        UnsafeNativeMethods.NotifyWinEvent((int)AccessibleEvents.SelectionAdd, c.Handle, NativeMethods.OBJID_CLIENT, 0);
                    }
                }
                
                Control primary = svc.PrimarySelection as Control;
                if (primary != null) {
                    Debug.WriteLineIf(CompModSwitches.MSAA.TraceInfo, "MSAA: Focus, control = " + primary.ToString());
                    UnsafeNativeMethods.NotifyWinEvent((int)AccessibleEvents.Focus, primary.Handle, NativeMethods.OBJID_CLIENT, 0);
                }
                
                // see if there are visual controls selected.  If so, we add a context attribute.
                // Otherwise, we remove the attribute.  We do not count the form.
                //
                IHelpService hs = (IHelpService)GetService(typeof(IHelpService));

                if (hs != null) {
                    short type = 0;
                    string[] types = new string[] {
                        "VisualSelection",
                        "NonVisualSelection",
                        "MixedSelection"
                    };

                    foreach(object obj in selComponents) {
                        if (obj is Control) {
                            if (obj != Component) {
                                type |= 1;
                            }
                        }
                        else {
                            type |= 2;
                        }

                        if (type == 3) {
                            break;
                        }
                    }

                    // Remove any prior attribute
                    //
                    for (int i = 0; i < types.Length; i++) {
                        hs.RemoveContextAttribute("Keyword", types[i]);
                    }

                    if (type != 0) {
                        hs.AddContextAttribute("Keyword", types[type - 1], HelpKeywordType.GeneralKeyword);
                    }

                }
                // Activate / deactivate the menu editor.
                //
                if (menuEditorService != null)
                    DoProperMenuSelection(selComponents);
             }
        }

        internal virtual void DoProperMenuSelection(ICollection selComponents) {
            
            foreach(object obj in selComponents) {
                if (obj is ContextMenu) {
                    menuEditorService.SetMenu((Menu)obj);
                }
                else if (obj is MenuItem ) {
                    
                    //before we set the selection, we need to check if the item belongs the current menu,
                    //if not, we need to set the menu editor to the appropiate menu, then set selection
                    //
                    MenuItem parent = (MenuItem)obj;
                    while (parent.Parent is MenuItem) {
                        parent = (MenuItem)parent.Parent;
                    }

                    if(menuEditorService.GetMenu() != parent.Parent) {
                        menuEditorService.SetMenu(parent.Parent);
                    }

                    //ok, here we have the correct editor selected for this item.
                    //Now, if there's only one item selected, then let the editor service know,
                    //if there is more than one - then the selection was done through the
                    //menu editor and we don't need to tell it
                    if(selComponents.Count == 1) {
                        menuEditorService.SetSelection((MenuItem)obj);
                    }
                }
                //Here, something is selected, but the menuservice isn't interested
                //so, we'll collapse our active menu accordingly
                else menuEditorService.SetMenu(null);
            }
        }

        /// <include file='doc\DocumentDesigner.uex' path='docs/doc[@for="DocumentDesigner.EnsureMenuEditorService"]/*' />
        /// <devdoc>
        ///      Determines if a MenuEditorService has already been started.  If not,
        ///      this method will create a new instance of the service.
        /// </devdoc>
        protected virtual void EnsureMenuEditorService(IComponent c) {
            if (menuEditorService == null && c is ContextMenu) {
                menuEditorService = (IMenuEditorService)GetService(typeof(IMenuEditorService));
            }
        }

        /// <include file='doc\DocumentDesigner.uex' path='docs/doc[@for="DocumentDesigner.PreFilterProperties"]/*' />
        /// <devdoc>
        ///      Allows a designer to filter the set of properties
        ///      the component it is designing will expose through the
        ///      TypeDescriptor object.  This method is called
        ///      immediately before its corresponding "Post" method.
        ///      If you are overriding this method you should call
        ///      the base implementation before you perform your own
        ///      filtering.
        /// </devdoc>
        protected override void PreFilterProperties(IDictionary properties) {
            PropertyDescriptor prop;

            base.PreFilterProperties(properties);

            // Add any properties that the Tray will persist.
            properties["TrayHeight"] = TypeDescriptor.CreateProperty(typeof(DocumentDesigner), "TrayHeight", typeof(int),
                                                            BrowsableAttribute.No,
                                                            DesignOnlyAttribute.Yes,
                                                            new SRDescriptionAttribute("FormDocumentDesignerTraySizeDescr"),
                                                            CategoryAttribute.Design);

            properties["TrayLargeIcon"] = TypeDescriptor.CreateProperty(typeof(DocumentDesigner), "TrayLargeIcon", typeof(bool),
                                                               BrowsableAttribute.No,
                                                               DesignOnlyAttribute.Yes,
                                                               CategoryAttribute.Design);

            // Handle shadowed properties
            //
            string[] shadowProps = new string[] {
                    "Location",
                    "BackColor"
                };

            string[] noBrowseProps = new string[] {
                "Anchor",
                "Dock",
                "TabIndex",
                "TabStop",
                "Visible"
            };

            Attribute[] empty = new Attribute[0];

            for (int i = 0; i < shadowProps.Length; i++) {
                prop = (PropertyDescriptor)properties[shadowProps[i]];
                if (prop != null) {
                    properties[shadowProps[i]] = TypeDescriptor.CreateProperty(typeof(DocumentDesigner), prop, empty);
                }
            }

            for (int i = 0; i < noBrowseProps.Length; i++) {
                prop = (PropertyDescriptor)properties[noBrowseProps[i]];
                if (prop != null) {
                    properties[noBrowseProps[i]] = TypeDescriptor.CreateProperty(prop.ComponentType, prop, BrowsableAttribute.No, DesignerSerializationVisibilityAttribute.Hidden);
                }
            }
        }

        /// <devdoc>
        ///     Resets the back color to be based on the parent's back color.
        /// </devdoc>
        private void ResetBackColor() {
            BackColor = Color.Empty;
        }

        /// <devdoc>
        ///     Returns true if the BackColor property should be persisted in code gen.
        /// </devdoc>
        private bool ShouldSerializeBackColor() {
            // We push Color.Empty into our shadow cash during
            // init and also whenever we are reset.  We do this
            // so we can push a real color into the controls
            // back color to stop it from walking the parent chain.
            // But, we want it to look like we didn't push a color
            // so code gen won't write out "Color.Control"
            if (!ShadowProperties.Contains("BackColor") || ((Color)ShadowProperties["BackColor"]).IsEmpty) {
                return false;
            }

            return true;
        }

        /// <include file='doc\DocumentDesigner.uex' path='docs/doc[@for="DocumentDesigner.ToolPicked"]/*' />
        /// <devdoc>
        ///      This will be called when the user double-clicks on a
        ///      toolbox item.  The document designer should create
        ///      a component for the given tool.
        /// </devdoc>
        protected virtual void ToolPicked(ToolboxItem tool) {

            // If the tab order UI is showing, don't allow us to place a tool.
            //
            IMenuCommandService mcs = (IMenuCommandService)GetService(typeof(IMenuCommandService));
            if (mcs != null) {
                MenuCommand cmd = mcs.FindCommand(StandardCommands.TabOrder);
                if (cmd != null && cmd.Checked) {
                    return;
                }
            }

            IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
            if (host != null) {
                host.Activate();
            }
            
            // Just find the currently selected frame designer and ask it to create the tool.
            //
            try {
                ParentControlDesigner designer = GetSelectedParentControlDesigner();
                if (!InvokeGetInheritanceAttribute(designer).Equals(InheritanceAttribute.InheritedReadOnly)) {
                    InvokeCreateTool(designer, tool);
                    IToolboxService toolboxService = (IToolboxService)GetService(typeof(IToolboxService));
                    if (toolboxService != null) {
                        toolboxService.SelectedToolboxItemUsed();
                    }
                }
            }
            catch(Exception e) {
                DisplayError(e);
            }
        }

        /// <include file='doc\DocumentDesigner.uex' path='docs/doc[@for="DocumentDesigner.IRootDesigner.SupportedTechnologies"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// The list of technologies that this designer can support
        /// for its view.  Examples of different technologies are
        /// WinForms and Web Forms.  Other object models can be
        /// supported at design time, but they most be able to
        /// provide a view in one of the supported technologies.
        /// </devdoc>
        ViewTechnology[] IRootDesigner.SupportedTechnologies {
            get {
                return new ViewTechnology[] {ViewTechnology.WindowsForms};
            }
        }
        
        /// <include file='doc\DocumentDesigner.uex' path='docs/doc[@for="DocumentDesigner.IRootDesigner.GetView"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// The view for this document.  The designer
        /// should assume that the view will be shown shortly
        /// after this call is made and make any necessary
        /// preparations.
        /// </devdoc>
        object IRootDesigner.GetView(ViewTechnology technology) {
            if (technology != ViewTechnology.WindowsForms) {
                throw new ArgumentException();
            }
            return frame;
        }

        /// <include file='doc\DocumentDesigner.uex' path='docs/doc[@for="DocumentDesigner.IToolboxUser.GetToolSupported"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>Gets a value indicating whether the specified tool is supported by the current
        /// designer.</para>
        /// </devdoc>
        //
        bool IToolboxUser.GetToolSupported(ToolboxItem tool) {
            return GetToolSupported(tool);
        }

        /// <include file='doc\DocumentDesigner.uex' path='docs/doc[@for="DocumentDesigner.IToolboxUser.ToolPicked"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>Selects the specified tool.</para>
        /// </devdoc>
        void IToolboxUser.ToolPicked(ToolboxItem tool) {
            ToolPicked(tool);
        }
        
        /// <devdoc>
        ///     Handles the WM_WINDOWPOSCHANGING message
        /// </devdoc>
        /// <internalonly/>
        private unsafe void WmWindowPosChanged(ref Message m) {
    
            NativeMethods.WINDOWPOS* wp = (NativeMethods.WINDOWPOS *)m.LParam;
            
            if ((wp->flags & NativeMethods.SWP_NOSIZE) == 0 && menuEditorService != null && selectionUIService != null) {
                ((ISelectionUIService)selectionUIService).SyncSelection();
            }
        }
        
        /// <include file='doc\DocumentDesigner.uex' path='docs/doc[@for="DocumentDesigner.WndProc"]/*' />
        /// <devdoc>
        ///      Overrides our base class WndProc to provide support for
        ///      the menu editor service.
        /// </devdoc>
        protected override void WndProc(ref Message m) {
            if( menuEditorService != null) {
                // We want to pass the messages to the menu editor unless the taborder view is active
                // and the message will activate the menu editor (wm_ncXbuttondown messages)
                //
                if (!(TabOrderActive && (m.Msg == NativeMethods.WM_NCLBUTTONDOWN || m.Msg == NativeMethods.WM_NCRBUTTONDOWN))) {
                    if(menuEditorService.MessageFilter(ref m)) {
                        return;
                    }
                }
            }

            base.WndProc(ref m);

            if (m.Msg == NativeMethods.WM_WINDOWPOSCHANGED) {
                WmWindowPosChanged(ref m);
            }
        }
        
        //
        // <doc>
        // <desc>
        //      Toolbox item we implement so we can create ActiveX controls.
        // </desc>
        // <internalonly/>
        // </doc>
        [Serializable]
        private class AxToolboxItem : ToolboxItem {
            private string clsid;
            private Type axctlType = null;

            public AxToolboxItem(string clsid) : base(typeof(AxHost)) {
                this.clsid = clsid;
            }

            private AxToolboxItem(SerializationInfo info, StreamingContext context) {
                Deserialize(info, context);
            }
            
            /// <include file='doc\DocumentDesigner.uex' path='docs/doc[@for="DocumentDesigner.AxToolboxItem.CreateComponentsCore"]/*' />
            /// <devdoc>
            /// <para>Creates an instance of the ActiveX control. Calls VS7 project system
            /// to generate the wrappers if they are needed..</para>
            /// </devdoc>
            protected override IComponent[] CreateComponentsCore(IDesignerHost host) {
                IComponent[] comps = null;
                Debug.Assert(host != null, "Designer host is null!!!");

                // Get the DTE References object
                //
                object references = GetReferences(host);
                if (references != null) {
                    try {
                        TYPELIBATTR tlibAttr = GetTypeLibAttr();
                        
                        object[] args = new object[5];
                        args[0] = "{" + tlibAttr.guid.ToString() + "}";
                        args[1] = (int)tlibAttr.wMajorVerNum;
                        args[2] = (int)tlibAttr.wMinorVerNum;
                        args[3] = (int)tlibAttr.lcid;
                        
                        args[4] = "";
                        object tlbRef = references.GetType().InvokeMember("AddActiveX", BindingFlags.InvokeMethod | BindingFlags.Public, null, references, args);
                        Debug.Assert(tlbRef != null, "Null reference returned by AddActiveX (tlbimp) by the project system for: " + clsid);

                        args[4] = "aximp";
                        object axRef = references.GetType().InvokeMember("AddActiveX", BindingFlags.InvokeMethod | BindingFlags.Public, null, references, args);
                        Debug.Assert(axRef != null, "Null reference returned by AddActiveX (aximp) by the project system for: " + clsid);

                        axctlType = GetAxTypeFromReference(axRef, host);
                        
                    }
                    catch(TargetInvocationException tie) {
                        Debug.WriteLineIf(DocumentDesigner.AxToolSwitch.TraceVerbose, "Generating Ax References failed: " + tie.InnerException);
                        throw tie.InnerException;
                    }
                    catch(Exception e) {
                        Debug.WriteLineIf(DocumentDesigner.AxToolSwitch.TraceVerbose, "Generating Ax References failed: " + e);
                        throw e;
                    }
                }

                if (axctlType == null) {
                    IUIService uiSvc = (IUIService)host.GetService(typeof(IUIService));
                    if (uiSvc == null) {
                        MessageBox.Show(SR.GetString(SR.AxImportFailed));
                    }
                    else {
                        uiSvc.ShowError(SR.GetString(SR.AxImportFailed));
                    }
                    return new IComponent[0];
                }

                comps = new IComponent[1];
                try {
                    comps[0] = host.CreateComponent(axctlType);
                }
                catch (Exception e) {
                    Debug.Fail("Could not create type: " + e);
                    throw e;
                }

                Debug.Assert(comps[0] != null, "Could not create instance of ActiveX control wrappers!!!");
                return comps;
            }
        
            /// <include file='doc\DocumentDesigner.uex' path='docs/doc[@for="DocumentDesigner.AxToolboxItem.Deserialize"]/*' />
            /// <devdoc>
            /// <para>Loads the state of this 'AxToolboxItem'
            /// from the stream.</para>
            /// </devdoc>
            protected override void Deserialize(SerializationInfo info, StreamingContext context) {
                base.Deserialize(info, context);
                clsid = info.GetString("Clsid");
            }

            /// <devdoc>
            /// <para>Gets hold of the DTE Reference object and from there, opens the assembly of the
            /// ActiveX control we want to create. It then walks through all AxHost derived classes
            /// in that assembly, and returns the type that matches our control's CLSID.</para>
            /// </devdoc>
            private Type GetAxTypeFromReference(object reference, IDesignerHost host) {
                string path = (string)reference.GetType().InvokeMember("Path", BindingFlags.GetProperty | BindingFlags.Public, null, reference, null);

                // Missing reference will show up as an empty string.
                //
                if (path == null || path.Length <= 0) {
                    return null;
                }

                FileInfo file = new FileInfo(path);
                string fullPath = file.FullName;
                Debug.WriteLineIf(AxToolSwitch.TraceVerbose, "Checking: " + fullPath);

                ITypeResolutionService trs = (ITypeResolutionService)host.GetService(typeof(ITypeResolutionService));
                Debug.Assert(trs != null, "No type resolution service found.");

                Assembly a = trs.GetAssembly(AssemblyName.GetAssemblyName(fullPath));
                Debug.Assert(a != null, "No assembly found at " + fullPath);

                return GetAxTypeFromAssembly(a);
            }

            /// <devdoc>
            /// <para>Walks through all AxHost derived classes in the given assembly, 
            /// and returns the type that matches our control's CLSID.</para>
            /// </devdoc>
            private Type GetAxTypeFromAssembly(Assembly a) {
                Type[] types = a.GetModules()[0].GetTypes();
                int len = types.Length;
                for (int i = 0; i < len; ++i) {
                    Type t = types[i];
                    if (!(typeof(AxHost).IsAssignableFrom(t))) {
                        continue;
                    }

                    object[] attrs = t.GetCustomAttributes(typeof(AxHost.ClsidAttribute), false);
                    Debug.Assert(attrs != null && attrs.Length == 1, "Invalid number of GuidAttributes found on: " + t.FullName);

                    AxHost.ClsidAttribute guid = (AxHost.ClsidAttribute)attrs[0];
                    if (String.Compare(guid.Value, clsid, true, CultureInfo.InvariantCulture) == 0) {
                        return t;
                    }
                }

                return null;
            }

            /// <devdoc>
            /// <para>Gets the References collection object from the designer host. The steps are:
            ///     Get the ProjectItem from the IDesignerHost.
            ///     Get the Containing Project of the ProjectItem.
            ///     Get the VSProject of the Containing Project.
            ///     Get the References property of the VSProject.</para>
            /// </devdoc>
            private object GetReferences(IDesignerHost host) {
                Debug.Assert(host != null, "Null Designer Host");
                
                Type type;
                object ext = null;
                type = Type.GetType("EnvDTE.ProjectItem, " + AssemblyRef.EnvDTE);

                if (type == null) {
                    return null;
                }

                ext = host.GetService(type);
                if (ext == null)
                    return null;

                string name = ext.GetType().InvokeMember("Name", BindingFlags.GetProperty | BindingFlags.Public, null, ext, null).ToString();
                
                object project = ext.GetType().InvokeMember("ContainingProject", BindingFlags.GetProperty | BindingFlags.Public, null, ext, null);
                Debug.Assert(project != null, "No DTE Project for the current project item: " + name);

                object vsproject = project.GetType().InvokeMember("Object", BindingFlags.GetProperty | BindingFlags.Public, null, project, null);
                Debug.Assert(vsproject != null, "No VS Project for the current project item: " + name);

                object references = vsproject.GetType().InvokeMember("References", BindingFlags.GetProperty | BindingFlags.Public, null, vsproject, null);
                Debug.Assert(references != null, "No References for the current project item: " + name);

                return references;
            }

            /// <devdoc>
            /// <para>Gets the TypeLibAttr corresponding to the TLB containing our ActiveX control.</para>
            /// </devdoc>
            private TYPELIBATTR GetTypeLibAttr() {
                string controlKey = "CLSID\\" + clsid;
                RegistryKey key = Registry.ClassesRoot.OpenSubKey(controlKey);
                if (key == null) {
                    if (DocumentDesigner.AxToolSwitch.TraceVerbose) Debug.WriteLine("No registry key found for: " + controlKey);
                    throw new ArgumentException(SR.GetString(SR.AXNotRegistered, controlKey.ToString()));
                }

                // Load the typelib into memory.
                //
                UCOMITypeLib pTLB = null;

                // Try to get the TypeLib's Guid.
                //
                Guid tlbGuid = Guid.Empty;

                // Open the key for the TypeLib
                //
                RegistryKey tlbKey = key.OpenSubKey("TypeLib");

                if (tlbKey != null) {
                    // Get the major and minor version numbers.
                    //
                    RegistryKey verKey = key.OpenSubKey("Version");
                    Debug.Assert(verKey != null, "No version registry key found for: " + controlKey);

                    short majorVer = -1;
                    short minorVer = -1;
                    string ver = (string)verKey.GetValue("");
                    int dot = ver.IndexOf('.');
                    if (dot == -1) {
                        majorVer = Int16.Parse(ver);
                        minorVer = 0;
                    }
                    else {
                        majorVer = Int16.Parse(ver.Substring(0, dot));
                        minorVer = Int16.Parse(ver.Substring(dot + 1, ver.Length - dot - 1));
                    }
                    Debug.Assert(majorVer > 0 && minorVer >= 0, "No Major version number found for: " + controlKey);
                    verKey.Close();

                    object o = tlbKey.GetValue("");
                    tlbGuid = new Guid((string)o);
                    Debug.Assert(!tlbGuid.Equals(Guid.Empty), "No valid Guid found for: " + controlKey);
                    tlbKey.Close();

                    try {
                        pTLB = NativeMethods.LoadRegTypeLib(ref tlbGuid, majorVer, minorVer, Application.CurrentCulture.LCID);
                    }
                    catch (Exception e) {
                        if (AxWrapperGen.AxWrapper.Enabled) Debug.WriteLine("Failed to LoadRegTypeLib: " + e.ToString());
                    }
                }

                // Try to load the TLB directly from the InprocServer32.
                //
                // If that fails, try to load the TLB based on the TypeLib guid key.
                //
                if (pTLB == null) {
                    RegistryKey inprocServerKey = key.OpenSubKey("InprocServer32");
                    if (inprocServerKey != null) {
                        string inprocServer = (string)inprocServerKey.GetValue("");
                        Debug.Assert(inprocServer != null, "No valid InprocServer32 found for: " + controlKey);               
                        inprocServerKey.Close();

                        pTLB = NativeMethods.LoadTypeLib(inprocServer);
                    }
                }

                key.Close();

                if (pTLB != null) {
                    try {
                        IntPtr pTlibAttr = NativeMethods.InvalidIntPtr;
                        pTLB.GetLibAttr(out pTlibAttr);
                        if (pTlibAttr == NativeMethods.InvalidIntPtr) 
                            throw new ArgumentException(SR.GetString(SR.AXNotRegistered, controlKey.ToString()));
                        else {
                            // Marshal the returned int as a TLibAttr structure
                            //
                            TYPELIBATTR typeLibraryAttributes = (TYPELIBATTR) Marshal.PtrToStructure(pTlibAttr, typeof(TYPELIBATTR)); 
                            pTLB.ReleaseTLibAttr(pTlibAttr);
                            
                            return typeLibraryAttributes;
                        }
                    }
                    finally {
                        Marshal.ReleaseComObject(pTLB);
                    }
                }
                else {
                    throw new ArgumentException(SR.GetString(SR.AXNotRegistered, controlKey.ToString()));
                }

            }

            /// <include file='doc\DocumentDesigner.uex' path='docs/doc[@for="DocumentDesigner.AxToolboxItem.Serialize"]/*' />
            /// <devdoc>
            /// <para>Saves the state of this 'AxToolboxItem' to
            ///    the specified serialization info.</para>
            /// </devdoc>
            protected override void Serialize(SerializationInfo info, StreamingContext context) {
                if (DocumentDesigner.AxToolSwitch.TraceVerbose) Debug.WriteLine("Serializing AxToolboxItem:" + clsid);
                base.Serialize(info, context);
                info.AddValue("Clsid", clsid);
            }
        }

        /// <devdoc>
        ///      Document designer's version of the inheritance service.  For UI
        ///      components, we will allow private controls if those controls are
        ///      children of our document, since they will be visible.
        /// </devdoc>
        private class DocumentInheritanceService : InheritanceService {
            private DocumentDesigner designer;

            /// <include file='doc\DocumentDesigner.uex' path='docs/doc[@for="DocumentDesigner.DocumentInheritanceService.DocumentInheritanceService"]/*' />
            /// <devdoc>
            ///      Creates a new document inheritance service.
            /// </devdoc>
            public DocumentInheritanceService(DocumentDesigner designer) {
                this.designer = designer;
            }

            /// <include file='doc\DocumentDesigner.uex' path='docs/doc[@for="DocumentDesigner.DocumentInheritanceService.IgnoreInheritedMember"]/*' />
            /// <devdoc>
            ///    <para>Indicates the inherited members to ignore.</para>
            /// </devdoc>
            protected override bool IgnoreInheritedMember(MemberInfo member, IComponent component) {
    
                // We allow private members if they are controls on our design surface or
                // derive from Menu.
                //
                bool privateMember = false;
                Type memberType = null;
                
                if (member is FieldInfo) {
                    FieldInfo field = (FieldInfo)member;
                    privateMember = field.IsPrivate || field.IsAssembly;
                    memberType = field.FieldType;
                }
                else if (member is MethodInfo) {
                    MethodInfo method = (MethodInfo)member;
                    privateMember = method.IsPrivate || method.IsAssembly;
                    memberType = method.ReturnType;
                }
                else {
                    Debug.Fail("Unknown member type passed to IgnoreInheritedMember");
                    return true;
                }
            
                if (privateMember) {
                    if (typeof(Control).IsAssignableFrom(memberType)) {
                        // See if this member is a child of our document...
                        //
                        Control child = null;
                        if (member is FieldInfo) {
                            child = (Control)((FieldInfo)member).GetValue(component);
                        }
                        else if (member is MethodInfo) {
                            child = (Control)((MethodInfo)member).Invoke(component, null);
                        }
                        Control parent = designer.Control;
    
                        while (child != null && child != parent) {
                            child = child.Parent;
                        }
    
                        // If it is a child of our designer, we don't want to ignore this member.
                        //
                        if (child != null) {
                            return false;
                        }
                    }
                    else if (typeof(Menu).IsAssignableFrom(memberType)) {
                        object menu = null;
                        if (member is FieldInfo) {
                            menu = ((FieldInfo)member).GetValue(component);
                        }
                        else if (member is MethodInfo) {
                            menu = ((MethodInfo)member).Invoke(component, null);
                        }
                        if (menu != null) {
                            return false;
                        }
                    }
                }

                return base.IgnoreInheritedMember(member, component);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\ioledragclient.cs ===
//------------------------------------------------------------------------------
// <copyright file="IOleDragClient.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms.Design {
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.Collections;
    using System.Windows.Forms;    
    using System.Drawing;
    using Microsoft.Win32;


    internal interface IOleDragClient{

        IComponent Component {get;}

        /// <include file='doc\IOleDragClient.uex' path='docs/doc[@for="IOleDragClient.AddComponent"]/*' />
        /// <devdoc>
        /// Retrieves the control view instance for the designer that
        /// is hosting the drag.
        /// </devdoc>
        bool   AddComponent(IComponent component, string name, bool firstAdd);
        
        /// <include file='doc\IOleDragClient.uex' path='docs/doc[@for="IOleDragClient.CanModifyComponents"]/*' />
        /// <devdoc>
        /// Checks if the client is read only.  That is, if components can
        /// be added or removed from the designer.
        /// </devdoc>
        bool CanModifyComponents {get;}
        
        /// <include file='doc\IOleDragClient.uex' path='docs/doc[@for="IOleDragClient.IsDropOk"]/*' />
        /// <devdoc>
        /// Checks if it is valid to drop this type of a component on this client.
        /// </devdoc>
        bool IsDropOk(IComponent component);
        
        /// <include file='doc\IOleDragClient.uex' path='docs/doc[@for="IOleDragClient.GetDesignerControl"]/*' />
        /// <devdoc>
        /// Retrieves the control view instance for the designer that
        /// is hosting the drag.
        /// </devdoc>
        Control GetDesignerControl();

        /// <include file='doc\IOleDragClient.uex' path='docs/doc[@for="IOleDragClient.GetControlForComponent"]/*' />
        /// <devdoc>
        /// Retrieves the control view instance for the given component.
        /// For Win32 designer, this will often be the component itself.
        /// </devdoc>
        Control GetControlForComponent(object component);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\ioverlayservice.cs ===
//------------------------------------------------------------------------------
// <copyright file="IOverlayService.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms.Design {

    using System.Diagnostics;

    using System;
    using System.Windows.Forms;
    using Microsoft.Win32;

    /// <include file='doc\IOverlayService.uex' path='docs/doc[@for="IOverlayService"]/*' />
    /// <internalonly/>
    /// <devdoc>
    ///    <para>
    ///       IOverlayService is a service that supports adding simple overlay windows to a
    ///       design surface. Overlay windows can be used to paint extra glyphs on top of
    ///       existing controls. Once an overlay is added, it will be forced on top of
    ///       the Z-order for the other controls and overlays. If you want the overlay
    ///       to be transparent, then you must do this work yourself. A typical way to
    ///       make an overlay control transparent is to use the method setRegion
    ///       on the control class to define the non-transparent portion of the contro.
    ///    </para>
    /// </devdoc>
    internal interface IOverlayService {

        /// <include file='doc\IOverlayService.uex' path='docs/doc[@for="IOverlayService.PushOverlay"]/*' />
        /// <devdoc>
        ///     Pushes the given control on top of the overlay list.  This is a "push"
        ///     operation, meaning that it forces this control to the top of the existing
        ///     overlay list.
        ///
        /// </devdoc>
        void PushOverlay(Control control);

        /// <include file='doc\IOverlayService.uex' path='docs/doc[@for="IOverlayService.RemoveOverlay"]/*' />
        /// <devdoc>
        ///     Removes the given control from the overlay list.  Unlike pushOverlay,
        ///     this can remove a control from the middle of the overlay list.
        ///
        /// </devdoc>
        void RemoveOverlay(Control control);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\iselectionuihandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="ISelectionUIHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms.Design {
    using System.Runtime.Remoting;
    using System.ComponentModel;

    using System.Diagnostics;

    using System;
    using System.Drawing;
    using Microsoft.Win32;
    using System.ComponentModel.Design;

    /// <include file='doc\ISelectionUIHandler.uex' path='docs/doc[@for="ISelectionUIHandler"]/*' />
    /// <internalonly/>
    /// <devdoc>
    ///    <para>
    ///       This interface allows a designer to provide information to the selection UI
    ///       service that is needed to allow it to draw selection UI and to provide
    ///       automatic component drag support.
    ///    </para>
    /// </devdoc>
    internal interface ISelectionUIHandler {

        /// <include file='doc\ISelectionUIHandler.uex' path='docs/doc[@for="ISelectionUIHandler.BeginDrag"]/*' />
        /// <devdoc>
        ///     Begins a drag on the currently selected designer.  The designer should provide
        ///     UI feedback about the drag at this time.  Typically, this feedback consists
        ///     of an inverted rectangle for each component, or a caret if the component
        ///     is text.
        ///
        /// </devdoc>
        bool BeginDrag(object[] components, SelectionRules rules, int initialX, int initialY);

        /// <include file='doc\ISelectionUIHandler.uex' path='docs/doc[@for="ISelectionUIHandler.DragMoved"]/*' />
        /// <devdoc>
        ///     Called when the user has moved the mouse.  This will only be called on
        ///     the designer that returned true from beginDrag.  The designer
        ///     should update its UI feedback here.
        ///
        /// </devdoc>
        void DragMoved(object[] components, Rectangle offset);

        /// <include file='doc\ISelectionUIHandler.uex' path='docs/doc[@for="ISelectionUIHandler.EndDrag"]/*' />
        /// <devdoc>
        ///     Called when the user has completed the drag.  The designer should
        ///     remove any UI feedback it may be providing.
        ///
        /// </devdoc>
        void EndDrag(object[] components, bool cancel);

        /// <include file='doc\ISelectionUIHandler.uex' path='docs/doc[@for="ISelectionUIHandler.GetComponentBounds"]/*' />
        /// <devdoc>
        ///     Retrieves the shape of the component.  The component's shape should be in
        ///     absolute coordinates and in pixels, where 0,0 is the upper left corner of
        ///     the screen.
        ///
        /// </devdoc>
        Rectangle GetComponentBounds(object component);

        /// <include file='doc\ISelectionUIHandler.uex' path='docs/doc[@for="ISelectionUIHandler.GetComponentRules"]/*' />
        /// <devdoc>
        ///     Retrieves a set of rules concerning the movement capabilities of a component.
        ///     This should be one or more flags from the SelectionRules class.  If no designer
        ///     provides rules for a component, the component will not get any UI services.
        ///
        /// </devdoc>
        SelectionRules GetComponentRules(object component);

        /// <include file='doc\ISelectionUIHandler.uex' path='docs/doc[@for="ISelectionUIHandler.GetSelectionClipRect"]/*' />
        /// <devdoc>
        ///     Determines the rectangle that any selection adornments should be clipped
        ///     to. This is normally the client area (in screen coordinates) of the
        ///     container.
        /// </devdoc>
        Rectangle GetSelectionClipRect(object component);

        /// <include file='doc\ISelectionUIHandler.uex' path='docs/doc[@for="ISelectionUIHandler.OnSelectionDoubleClick"]/*' />
        /// <devdoc>
        ///     Handle a double-click on the selection rectangle
        ///     of the given component.
        /// </devdoc>
        void OnSelectionDoubleClick(IComponent component);

        /// <include file='doc\ISelectionUIHandler.uex' path='docs/doc[@for="ISelectionUIHandler.QueryBeginDrag"]/*' />
        /// <devdoc>
        ///     Queries to see if a drag operation
        ///     is valid on this handler for the given set of components.
        ///     If it returns true, BeginDrag will be called immediately after.
        /// </devdoc>
        bool QueryBeginDrag(object[] components, SelectionRules rules, int initialX, int initialY);


        /// <include file='doc\ISelectionUIHandler.uex' path='docs/doc[@for="ISelectionUIHandler.ShowContextMenu"]/*' />
        /// <devdoc>
        ///     Shows the context menu for the given component.
        /// </devdoc>
        void ShowContextMenu(IComponent component);

        void OleDragEnter(DragEventArgs de);
        void OleDragDrop(DragEventArgs de);
        void OleDragOver(DragEventArgs de);
        void OleDragLeave();

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\iselectionuiservice.cs ===
//------------------------------------------------------------------------------
// <copyright file="ISelectionUIService.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms.Design {
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.Drawing;    
    using System.ComponentModel.Design;

    /// <include file='doc\ISelectionUIService.uex' path='docs/doc[@for="ISelectionUIService"]/*' />
    /// <internalonly/>
    /// <devdoc>
    ///    <para>
    ///       The selection UI service is used to provide a standard
    ///       user interface for selection across designers. Using this service
    ///       is optional, but is recommended to provide a standard UI component
    ///       selection.
    ///    </para>
    /// </devdoc>
    internal interface ISelectionUIService {

        /// <include file='doc\ISelectionUIService.uex' path='docs/doc[@for="ISelectionUIService.Visible"]/*' />
        /// <devdoc>
        ///     Determines if the selection UI is shown or not.
        ///
        /// </devdoc>
        bool Visible { get; set; }

        /// <include file='doc\ISelectionUIService.uex' path='docs/doc[@for="ISelectionUIService.ContainerSelectorActive"]/*' />
        /// <devdoc>
        ///     Adds an event handler to the ContainerSelectorActive event.
        ///     This event is fired whenever the user interacts with the container
        ///     selector in a manor that would indicate that the selector should
        ///     continued to be displayed. Since the container selector normally
        ///     will vanish after a timeout, designers should listen to this event
        ///     and reset the timeout when this event occurs.
        /// </devdoc>
        event ContainerSelectorActiveEventHandler ContainerSelectorActive;

        /// <include file='doc\ISelectionUIService.uex' path='docs/doc[@for="ISelectionUIService.AssignSelectionUIHandler"]/*' />
        /// <devdoc>
        ///     Assigns a selection UI handler to a given component.  The handler will be
        ///     called when the UI service needs information about the component.  A single
        ///     selection UI handler can be assigned to multiple components.
        ///
        ///     When multiple components are dragged, only a single handler may control the
        ///     drag.  Because of this, only components that are assigned the same handler
        ///     as the primary selection are included in drag operations.
        ///
        ///     A selection UI handler is automatically unassigned when the component is removed
        ///     from the container or disposed.
        ///
        /// </devdoc>
        void AssignSelectionUIHandler(object component, ISelectionUIHandler handler);
        
        void ClearSelectionUIHandler(object component, ISelectionUIHandler handler);

        /// <include file='doc\ISelectionUIService.uex' path='docs/doc[@for="ISelectionUIService.BeginDrag"]/*' />
        /// <devdoc>
        ///     This can be called by an outside party to begin a drag of the currently selected
        ///     set of components.  At least one designer must have added a UI handler or
        ///     else this method will always return false.
        ///
        /// </devdoc>
        bool BeginDrag(SelectionRules rules, int initialX, int initialY);

        /// <include file='doc\ISelectionUIService.uex' path='docs/doc[@for="ISelectionUIService.Dragging"]/*' />
        /// <devdoc>
        ///     This can be used to determine if the user is in the middle of a drag operation.
        /// </devdoc>
        bool Dragging {get; }

        /// <include file='doc\ISelectionUIService.uex' path='docs/doc[@for="ISelectionUIService.DragMoved"]/*' />
        /// <devdoc>
        ///     Called by an outside party to update drag information.  This can only be called
        ///     after a successful call to beginDrag.
        ///
        /// </devdoc>
        void DragMoved(Rectangle offset);

        /// <include file='doc\ISelectionUIService.uex' path='docs/doc[@for="ISelectionUIService.EndDrag"]/*' />
        /// <devdoc>
        ///     Called by an outside party to finish a drag operation.  This can only be called
        ///     after a successful call to beginDrag.
        ///
        /// </devdoc>
        void EndDrag(bool cancel);

        /// <include file='doc\ISelectionUIService.uex' path='docs/doc[@for="ISelectionUIService.FilterSelection"]/*' />
        /// <devdoc>
        ///     Filters the set of selected components.  The selection service will retrieve all
        ///     components that are currently selected.  This method allows you to filter this
        ///     set down to components that match your criteria.  The selectionRules parameter
        ///     must contain one or more flags from the SelectionRules class.  These flags
        ///     allow you to constrain the set of selected objects to visible, movable,
        ///     sizeable or all objects.
        ///
        /// </devdoc>
        object[] FilterSelection(object [] components, SelectionRules selectionRules);

        /// <include file='doc\ISelectionUIService.uex' path='docs/doc[@for="ISelectionUIService.GetAdornmentDimensions"]/*' />
        /// <devdoc>
        ///     Retrieves the width and height of a selection border grab handle.
        ///     Designers may need this to properly position their user interfaces.
        ///
        /// </devdoc>
        Size GetAdornmentDimensions(AdornmentType adornmentType);

        /// <include file='doc\ISelectionUIService.uex' path='docs/doc[@for="ISelectionUIService.GetAdornmentHitTest"]/*' />
        /// <devdoc>
        ///     Tests to determine if the given screen coordinate is over an adornment
        ///     for the specified component. This will only return true if the
        ///     adornment, and selection UI, is visible.
        /// </devdoc>
        bool GetAdornmentHitTest(object component, Point pt);

        /// <include file='doc\ISelectionUIService.uex' path='docs/doc[@for="ISelectionUIService.GetContainerSelected"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether the specified component is the currently selected container.</para>
        /// </devdoc>
        bool GetContainerSelected(object component);

        /// <include file='doc\ISelectionUIService.uex' path='docs/doc[@for="ISelectionUIService.GetSelectionRules"]/*' />
        /// <devdoc>
        ///     Retrieves a set of flags that define rules for the selection.  Selection
        ///     rules indicate if the given component can be moved or sized, for example.
        ///
        /// </devdoc>
        SelectionRules GetSelectionRules(object component);

        /// <include file='doc\ISelectionUIService.uex' path='docs/doc[@for="ISelectionUIService.GetSelectionStyle"]/*' />
        /// <devdoc>
        ///     Allows you to configure the style of the selection frame that a
        ///     component uses.  This is useful if your component supports different
        ///     modes of operation (such as an in-place editing mode and a static
        ///     design mode).  Where possible, you should leave the selection style
        ///     as is and use the design-time hit testing feature of the IDesigner
        ///     interface to provide features at design time.  The value of style
        ///     must be one of the  SelectionStyle enum values.
        ///
        ///     The selection style is only valid for the duration that the component is
        ///     selected.
        ///
        /// </devdoc>
        SelectionStyles GetSelectionStyle(object component);

        /// <include file='doc\ISelectionUIService.uex' path='docs/doc[@for="ISelectionUIService.SetContainerSelected"]/*' />
        /// <devdoc>
        ///    <para>Changes the container selection status of the specified component.</para>
        /// </devdoc>
        void SetContainerSelected(object component, bool selected);

        /// <include file='doc\ISelectionUIService.uex' path='docs/doc[@for="ISelectionUIService.SetSelectionStyle"]/*' />
        /// <devdoc>
        ///     Allows you to configure the style of the selection frame that a
        ///     component uses.  This is useful if your component supports different
        ///     modes of operation (such as an in-place editing mode and a static
        ///     design mode).  Where possible, you should leave the selection style
        ///     as is and use the design-time hit testing feature of the IDesigner
        ///     interface to provide features at design time.  The value of style
        ///     must be one of the  SelectionStyle enum values.
        ///
        ///     The selection style is only valid for the duration that the component is
        ///     selected.
        ///
        /// </devdoc>
        void SetSelectionStyle(object component, SelectionStyles style);

        /// <include file='doc\ISelectionUIService.uex' path='docs/doc[@for="ISelectionUIService.SyncSelection"]/*' />
        /// <devdoc>
        ///     This should be called when a component has been moved, sized or re-parented,
        ///     but the change was not the result of a property change.  All property
        ///     changes are monitored by the selection UI service, so this is automatic most
        ///     of the time.  There are times, however, when a component may be moved without
        ///     a property change notification occurring.  Scrolling an auto scroll Win32
        ///     form is an example of this.
        ///
        ///     This method simply re-queries all currently selected components for their
        ///     bounds and udpates the selection handles for any that have changed.
        /// </devdoc>
        void SyncSelection();

        /// <include file='doc\ISelectionUIService.uex' path='docs/doc[@for="ISelectionUIService.SyncComponent"]/*' />
        /// <devdoc>
        ///     This should be called when a component's property changed, that the designer
        ///     thinks should result in a selection UI change.
        ///
        ///     This method simply re-queries all currently selected components for their
        ///     bounds and udpates the selection handles for any that have changed.
        /// </devdoc>
        void SyncComponent(object component);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\isplitwindowservice.cs ===
//------------------------------------------------------------------------------
// <copyright file="ISplitWindowService.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms.Design {

    using System.Diagnostics;

    using System.Windows.Forms;
    
    /// <include file='doc\ISplitWindowService.uex' path='docs/doc[@for="ISplitWindowService"]/*' />
    /// <internalonly/>
    /// <devdoc>
    ///    <para>
    ///       Supports the hosting of several 'pane' windows
    ///       separated by splitter bars.
    ///    </para>
    /// </devdoc>
    internal interface ISplitWindowService {

        /// <include file='doc\ISplitWindowService.uex' path='docs/doc[@for="ISplitWindowService.AddSplitWindow"]/*' />
        /// <devdoc>
        ///      Requests the service to add a window 'pane'.
        /// </devdoc>
        void AddSplitWindow(Control window);

        /// <include file='doc\ISplitWindowService.uex' path='docs/doc[@for="ISplitWindowService.RemoveSplitWindow"]/*' />
        /// <devdoc>
        ///      Requests the service to remove a window 'pane'.
        /// </devdoc>
        void RemoveSplitWindow(Control window);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\linkeddatamemberfieldeditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="LinkedDataMemberFieldEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms.Design {

    using System;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Drawing;
    using System.Drawing.Design;
    
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class LinkedDataMemberFieldEditor : UITypeEditor {

        private DesignBindingPicker designBindingPicker;
        
        public override object EditValue(ITypeDescriptorContext context,  IServiceProvider  provider, object value) {
            if (provider != null) {
                IWindowsFormsEditorService edSvc = (IWindowsFormsEditorService)provider.GetService(typeof(IWindowsFormsEditorService));

                if (edSvc != null && context.Instance != null) {
                    if (designBindingPicker == null) {
                        designBindingPicker = new DesignBindingPicker(context, /*multiple DataSources*/ false, /*select lists*/ false);
                    }
                    PropertyDescriptor dataSourceProperty = TypeDescriptor.GetProperties(context.Instance)["LinkedDataSource"];
                    if (dataSourceProperty != null) {
                        object dataSource = dataSourceProperty.GetValue(context.Instance);
                        if (dataSource != null) {
                            designBindingPicker.Start(context, edSvc, dataSource, new DesignBinding(null, (string)value));
                            edSvc.DropDownControl(designBindingPicker);
                            if (designBindingPicker.SelectedItem != null) {
                                value = designBindingPicker.SelectedItem.DataMember;
                            }
                            designBindingPicker.End();
                        }
                    }
                }
            }

            return value;
        }

        public override UITypeEditorEditStyle GetEditStyle(ITypeDescriptorContext context) {
            return UITypeEditorEditStyle.DropDown;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\linkareaeditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="LinkAreaEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms.Design {
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.InteropServices;

    using System.Diagnostics;
    using System;
    using System.Design;
    using System.Security.Permissions;
    using Microsoft.Win32;
    using System.Collections;
    using System.Windows.Forms;
    using System.Drawing;
    using System.Drawing.Design;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Windows.Forms.Design;
    using System.Windows.Forms.ComponentModel;

    /// <include file='doc\LinkAreaEditor.uex' path='docs/doc[@for="LinkAreaEditor"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides an editor that can be used to visually select and configure the link area of a link
    ///       label.
    ///    </para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class LinkAreaEditor : UITypeEditor {
    
        private LinkAreaUI linkAreaUI;
        
        /// <include file='doc\LinkAreaEditor.uex' path='docs/doc[@for="LinkAreaEditor.EditValue"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Edits the given object value using the editor style provided by
        ///       GetEditorStyle.
        ///    </para>
        /// </devdoc>
        public override object EditValue(ITypeDescriptorContext context,  IServiceProvider  provider, object value) {
        
            Debug.Assert(provider != null, "No service provider; we cannot edit the value");
            if (provider != null) {
                IWindowsFormsEditorService edSvc = (IWindowsFormsEditorService)provider.GetService(typeof(IWindowsFormsEditorService));
                
                Debug.Assert(edSvc != null, "No editor service; we cannot edit the value");
                if (edSvc != null) {
                    if (linkAreaUI == null) {
                        linkAreaUI = new LinkAreaUI(this);
                    }
                    
                    string text = string.Empty;
                    PropertyDescriptor prop = null;
                    
                    if (context != null && context.Instance != null) {
                        prop = TypeDescriptor.GetProperties(context.Instance)["Text"];
                        if (prop != null && prop.PropertyType == typeof(string)) {
                            text = (string)prop.GetValue(context.Instance);
                        }
                    }
                    
                    string originalText = text;
                    linkAreaUI.SampleText = text;
                    linkAreaUI.Start(edSvc, value);
                    
                    if (edSvc.ShowDialog(linkAreaUI) == DialogResult.OK) {
                        value = linkAreaUI.Value;
                        
                        text = linkAreaUI.SampleText;
                        if (!originalText.Equals(text) && prop != null && prop.PropertyType == typeof(string)) {
                            prop.SetValue(context.Instance, text);
                        }
                        
                    }
                    
                    linkAreaUI.End();
                }
            }
            
            return value;
        }

        /// <include file='doc\LinkAreaEditor.uex' path='docs/doc[@for="LinkAreaEditor.GetEditStyle"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the editing style of the Edit method.
        ///    </para>
        /// </devdoc>
        public override UITypeEditorEditStyle GetEditStyle(ITypeDescriptorContext context) {
            return UITypeEditorEditStyle.Modal;
        }
    
        /// <include file='doc\LinkAreaEditor.uex' path='docs/doc[@for="LinkAreaEditor.LinkAreaUI"]/*' />
        /// <devdoc>
        ///      Dialog box for the link area.
        /// </devdoc>
        internal class LinkAreaUI : Form {
            private Label caption = new Label();
            private TextBox sampleEdit = new TextBox();
            private Button okButton = new Button();
            private Button cancelButton = new Button();
            private LinkAreaEditor editor;
            private IWindowsFormsEditorService edSvc;
            private object value;
    
            public LinkAreaUI(LinkAreaEditor editor) {
                this.editor = editor;
                InitializeComponent();
            }
    
            public string SampleText {
                get {
                    return sampleEdit.Text;
                }
                set {
                    sampleEdit.Text = value;
                    UpdateSelection();
                }
            }
            
            public object Value { 
                get {
                    return value;
                }
            }
    
            public void End() {
                edSvc = null;
                value = null;
            }
            
            private void InitializeComponent() {
                this.StartPosition = FormStartPosition.CenterParent;
                this.ClientSize = new Size(300, 112);
                this.MinimumSize = new Size(300, 130);
                this.MinimizeBox = false;
                this.MaximizeBox = false;
                this.AcceptButton = okButton;
                this.CancelButton = cancelButton;

                caption.Location = new Point( 8, 14 );    
                caption.Size = new Size(284, 14);
                caption.Anchor = AnchorStyles.Right | AnchorStyles.Left | AnchorStyles.Top;
                Controls.Add(caption);
    
                sampleEdit.Anchor = AnchorStyles.Top | AnchorStyles.Left | AnchorStyles.Bottom | AnchorStyles.Right;
                sampleEdit.Multiline = true;
                sampleEdit.Location = new Point(8, 30);
                sampleEdit.Size = new Size(284, 47);
                Controls.Add(sampleEdit);
    
                okButton.Location = new Point(120, 83);
                okButton.Size = new Size(75, 23);
                okButton.Anchor = AnchorStyles.Bottom | AnchorStyles.Right;
                okButton.DialogResult = DialogResult.OK;
                okButton.Click += new EventHandler(this.okButton_click);
                Controls.Add(okButton);
    
                cancelButton.Location = new Point(200, 83);
                cancelButton.Size = new Size(75, 23);
                cancelButton.Anchor = AnchorStyles.Bottom | AnchorStyles.Right;
                cancelButton.DialogResult = DialogResult.Cancel;
                Controls.Add(cancelButton);
                this.Text = SR.GetString(SR.LinkAreaEditorCaption);
                okButton.Text = SR.GetString(SR.LinkAreaEditorOK);
                caption.Text = SR.GetString(SR.LinkAreaEditorDescription);
                cancelButton.Text = SR.GetString(SR.LinkAreaEditorCancel);
            }
                
            private void okButton_click(object sender, EventArgs e) {
                value = new LinkArea(sampleEdit.SelectionStart, sampleEdit.SelectionLength);
            }
    
            public void Start(IWindowsFormsEditorService edSvc, object value) {
                this.edSvc = edSvc;
                this.value = value;
                UpdateSelection();
                ActiveControl = sampleEdit;
            }
            
            private void UpdateSelection() {
                if (value is LinkArea) {
                    LinkArea pt = (LinkArea)value;
                    try {
                        sampleEdit.SelectionStart = pt.Start;
                        sampleEdit.SelectionLength = pt.Length;
                    }
                    catch(Exception) {
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\listboxdesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="ListBoxDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms.Design {
    
    using System.Design;
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;    
    using System.ComponentModel.Design;
    using System.Windows.Forms;

    /// <include file='doc\ListBoxDesigner.uex' path='docs/doc[@for="ListBoxDesigner"]/*' />
    /// <devdoc>
    ///      This class handles all design time behavior for the list box class.
    ///      It adds a sample item to the list box at design time.
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class ListBoxDesigner : ControlDesigner {
    
        /// <include file='doc\ListBoxDesigner.uex' path='docs/doc[@for="ListBoxDesigner.Dispose"]/*' />
        /// <devdoc>
        ///      Destroys this designer.
        /// </devdoc>
        protected override void Dispose(bool disposing) {
            
            if (disposing) {
                // Now, hook the component rename event so we can update the text in the
                // list box.
                //
                IComponentChangeService cs = (IComponentChangeService)GetService(typeof(IComponentChangeService));
                if (cs != null) {
                    cs.ComponentRename -= new ComponentRenameEventHandler(this.OnComponentRename);
                }
            }
            
            base.Dispose(disposing);
        }
        
        /// <include file='doc\ListBoxDesigner.uex' path='docs/doc[@for="ListBoxDesigner.Initialize"]/*' />
        /// <devdoc>
        ///     Called by the host when we're first initialized.
        /// </devdoc>
        public override void Initialize(IComponent component) {
            base.Initialize(component);
            
            // Now, hook the component rename event so we can update the text in the
            // list box.
            //
            IComponentChangeService cs = (IComponentChangeService)GetService(typeof(IComponentChangeService));
            if (cs != null) {
                cs.ComponentRename += new ComponentRenameEventHandler(this.OnComponentRename);
            }
        }
        
        /// <include file='doc\ListBoxDesigner.uex' path='docs/doc[@for="ListBoxDesigner.OnComponentRename"]/*' />
        /// <devdoc>
        ///      Raised when a component's name changes.  Here we update the contents of the list box
        ///      if we are displaying the component's name in it.
        /// </devdoc>
        private void OnComponentRename(object sender, ComponentRenameEventArgs e) {
            if (e.Component == Component) {
                UpdateControlName(e.NewName);
            }
        }
        
        /// <include file='doc\ListBoxDesigner.uex' path='docs/doc[@for="ListBoxDesigner.OnCreateHandle"]/*' />
        /// <devdoc>
        ///      This is called immediately after the control handle has been created.
        /// </devdoc>
        protected override void OnCreateHandle() {
            base.OnCreateHandle();
            PropertyDescriptor nameProp = TypeDescriptor.GetProperties(Component)["Name"];
            if (nameProp != null) {
                UpdateControlName(nameProp.GetValue(Component).ToString());
            }
        }
        
        /// <include file='doc\ListBoxDesigner.uex' path='docs/doc[@for="ListBoxDesigner.UpdateControlName"]/*' />
        /// <devdoc>
        ///      Updates the name being displayed on this control.  This will do nothing if
        ///      the control has items in it.
        /// </devdoc>
        private void UpdateControlName(string name) {
            ListBox lb = (ListBox)Control;
            if (lb.IsHandleCreated && lb.Items.Count == 0) {
                NativeMethods.SendMessage(lb.Handle, NativeMethods.LB_RESETCONTENT, 0, 0);
                NativeMethods.SendMessage(lb.Handle, NativeMethods.LB_ADDSTRING, 0, name);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\labeldesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="LabelDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms.Design {
    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;

    /// <include file='doc\LabelDesigner.uex' path='docs/doc[@for="LabelDesigner"]/*' />
    /// <devdoc>
    ///    <para> 
    ///       Provides a designer that can design components
    ///       that extend TextBoxBase.</para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class LabelDesigner : ControlDesigner {

        private EventHandler propChanged = null; // Delegate used to dirty the selectionUIItem when needed.
        
        /// <include file='doc\LabelDesigner.uex' path='docs/doc[@for="LabelDesigner.Dispose"]/*' />
        /// <devdoc>
        ///      Disposes of this object.
        /// </devdoc>
        protected override void Dispose(bool disposing) {
            if (disposing) {
                // Hook up the property change notification so that we can dirty the SelectionUIItem when needed.
                if (propChanged != null) {
                    ((Label)Control).AutoSizeChanged -= propChanged;
                }
            }
    
            base.Dispose(disposing);
        }

        /// <include file='doc\LabelDesigner.uex' path='docs/doc[@for="LabelDesigner.Initialize"]/*' />
        /// <devdoc>
        ///     Called by the host when we're first initialized.
        /// </devdoc>
        public override void Initialize(IComponent component) {
            base.Initialize(component);

            // Hook up the property change notification so that we can dirty the SelectionUIItem when needed.
            propChanged = new EventHandler(this.OnControlPropertyChanged);
            ((Label)Control).AutoSizeChanged += propChanged;
        }

        /// <include file='doc\LabelDesigner.uex' path='docs/doc[@for="LabelDesigner.OnControlPropertyChanged"]/*' />
        /// <devdoc>
        ///      For controls, we sync their property changed event so our component can track their location.
        /// </devdoc>
        private void OnControlPropertyChanged(object sender, EventArgs e) {
            ISelectionUIService selectionUISvc = (ISelectionUIService)GetService(typeof(ISelectionUIService));
            selectionUISvc.SyncComponent((IComponent)sender);
        }

        /// <include file='doc\LabelDesigner.uex' path='docs/doc[@for="LabelDesigner.SelectionRules"]/*' />
        /// <devdoc>
        ///     Retrieves a set of rules concerning the movement capabilities of a component.
        ///     This should be one or more flags from the SelectionRules class.  If no designer
        ///     provides rules for a component, the component will not get any UI services.
        /// </devdoc>
        public override SelectionRules SelectionRules {
            get {
                SelectionRules rules = base.SelectionRules;
                object component = Component;

                PropertyDescriptor propAutoSize = TypeDescriptor.GetProperties(component)["AutoSize"];
                if (propAutoSize != null) {
                    bool autoSize = (bool)propAutoSize.GetValue(component);

                    if (autoSize)
                        rules &= ~SelectionRules.AllSizeable;
                }

                return rules;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\listcontrolstringcollectioneditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="ListControlStringCollectionEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms.Design {
    using System.Design;
    using System.ComponentModel;
    using System;
    using System.Collections;
    using Microsoft.Win32;    
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Drawing;
    using System.Windows.Forms;

    /// <include file='doc\ListControlStringCollectionEditor.uex' path='docs/doc[@for="ListControlStringCollectionEditor"]/*' />
    /// <devdoc>
    ///      The ListControlStringCollectionEditor override StringCollectionEditor
    ///      to prevent the string collection from being edited if a DataSource
    ///      has been set on the control.
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class ListControlStringCollectionEditor : StringCollectionEditor {
        
        public ListControlStringCollectionEditor(Type type) : base(type) {
        }

        public override object EditValue(ITypeDescriptorContext context,  IServiceProvider  provider, object value) {
        
            // If we're trying to edit the items in an object that has a DataSource set, throw an exception
            //
            ListControl control = context.Instance as ListControl;
            if (control != null && control.DataSource != null) {
                throw new ArgumentException(SR.GetString(SR.DataSourceLocksItems));
            }
        
            return base.EditValue(context, provider, value);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\listviewdesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="ListViewDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms.Design {
    
    using System.ComponentModel;
    using System.ComponentModel.Design;

    using System.Diagnostics;
    using System.Collections;
    
    using System.Runtime.InteropServices;

    using System;
    using System.Design;
    using System.Windows.Forms;
    using System.Drawing;
    using Microsoft.Win32;

    /// <include file='doc\ListViewDesigner.uex' path='docs/doc[@for="ListViewDesigner"]/*' />
    /// <devdoc>
    ///      This is the designer for the list view control.  It implements hit testing for
    ///      the items in the list view.
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class ListViewDesigner : ControlDesigner {
        private NativeMethods.HDHITTESTINFO hdrhit = new NativeMethods.HDHITTESTINFO();

        /// <include file='doc\ListViewDesigner.uex' path='docs/doc[@for="ListViewDesigner.AssociatedComponents"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Retrieves a list of assosciated components.  These are components that should be incluced in a cut or copy operation on this component.
        ///    </para>
        /// </devdoc>
        public override ICollection AssociatedComponents {
            get {
                ListView lv = Control as ListView;
                if (lv != null) {
                    return lv.Columns;
                }
                return base.AssociatedComponents;
            }
        }


        /// <include file='doc\ListViewDesigner.uex' path='docs/doc[@for="ListViewDesigner.GetHitTest"]/*' />
        /// <devdoc>
        ///      We override GetHitTest to make the header in report view UI-active.
        /// </devdoc>
        protected override bool GetHitTest(Point point) {
            ListView lv = (ListView)Component;
            if (lv.View == View.Details) {
                Point lvPoint = Control.PointToClient(point);
                IntPtr hwndList = lv.Handle;
                IntPtr hwndHit = NativeMethods.ChildWindowFromPointEx(hwndList, lvPoint.X, lvPoint.Y, NativeMethods.CWP_SKIPINVISIBLE);

                if (hwndHit != IntPtr.Zero && hwndHit != hwndList) {
                    IntPtr hwndHdr = NativeMethods.SendMessage(hwndList, NativeMethods.LVM_GETHEADER, IntPtr.Zero, IntPtr.Zero);
                    if (hwndHit == hwndHdr) {
                        NativeMethods.POINT ptHdr = new NativeMethods.POINT();
                        ptHdr.x = point.X;
                        ptHdr.y = point.Y;
                        NativeMethods.MapWindowPoints(IntPtr.Zero, hwndHdr, ptHdr, 1);
                        hdrhit.pt_x = ptHdr.x;
                        hdrhit.pt_y = ptHdr.y;
                        NativeMethods.SendMessage(hwndHdr, NativeMethods.HDM_HITTEST, IntPtr.Zero, hdrhit);
                        if (hdrhit.flags == NativeMethods.HHT_ONDIVIDER)
                            return true;
                    }
                }
            }
            return false;
        }
        
        protected override void WndProc(ref Message m) {
        
            switch (m.Msg) {
            
                case NativeMethods.WM_NOTIFY:
                case NativeMethods.WM_REFLECT + NativeMethods.WM_NOTIFY:
                    NativeMethods.NMHDR nmhdr = (NativeMethods.NMHDR) Marshal.PtrToStructure(m.LParam, typeof(NativeMethods.NMHDR));
                    if (nmhdr.code == NativeMethods.HDN_ENDTRACK) {
                            
                        // Re-codegen if the columns have been resized
                        //
                        IComponentChangeService componentChangeService = (IComponentChangeService)GetService(typeof(IComponentChangeService));
                        componentChangeService.OnComponentChanged(Component, null, null, null);
                    }
		    break;
            }
            
            base.WndProc(ref m);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\monthcalendardesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="MonthCalendarDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms.Design {
    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;

    /// <include file='doc\MonthCalendarDesigner.uex' path='docs/doc[@for="MonthCalendarDesigner"]/*' />
    /// <devdoc>
    ///    <para> 
    ///       Provides a designer that can design components
    ///       that extend MonthCalendar.</para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class MonthCalendarDesigner : ControlDesigner {
    
        /// <include file='doc\MonthCalendarDesigner.uex' path='docs/doc[@for="MonthCalendarDesigner.SelectionRules"]/*' />
        /// <devdoc>
        ///     Retrieves a set of rules concerning the movement capabilities of a component.
        ///     This should be one or more flags from the SelectionRules class.  If no designer
        ///     provides rules for a component, the component will not get any UI services.
        /// </devdoc>
        public override SelectionRules SelectionRules {
            get {
                SelectionRules rules = base.SelectionRules;
                rules &= ~(SelectionRules.TopSizeable | SelectionRules.LeftSizeable);
                return rules;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\menucommands.cs ===
//------------------------------------------------------------------------------
// <copyright file="MenuCommands.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms.Design {
    using System.ComponentModel;

    using System.Diagnostics;

    using System;
    using System.ComponentModel.Design;
    using Microsoft.Win32;

    /// <include file='doc\MenuCommands.uex' path='docs/doc[@for="MenuCommands"]/*' />
    /// <devdoc>
    ///    <para>
    ///       This class contains command ID's and GUIDS that
    ///       correspond
    ///       to the host Command Bar menu layout.
    ///    </para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public sealed class MenuCommands : StandardCommands {

        /// <include file='doc\MenuCommands.uex' path='docs/doc[@for="MenuCommands.wfMenuGroup"]/*' />
        /// <devdoc>
        ///      This guid corresponds to the menu grouping Windows Forms will use for its menus.  This is
        ///      defined in the Windows Forms menu CTC file, but we need it here so we can define what
        ///      context menus to use.
        /// </devdoc>
        private static readonly Guid wfMenuGroup = new Guid("{74D21312-2AEE-11d1-8BFB-00A0C90F26F7}");

        /// <include file='doc\MenuCommands.uex' path='docs/doc[@for="MenuCommands.wfCommandSet"]/*' />
        /// <devdoc>
        ///     This guid corresponds to the Windows Forms command set.
        /// </devdoc>
        private static readonly Guid wfCommandSet = new Guid("{74D21313-2AEE-11d1-8BFB-00A0C90F26F7}");

        /// <include file='doc\MenuCommands.uex' path='docs/doc[@for="MenuCommands.guidVSStd2K"]/*' />
        /// <devdoc>
        ///     This guid is the standard vs 2k commands for key bindings
        /// </devdoc>
        private static readonly Guid guidVSStd2K = new Guid("{1496A755-94DE-11D0-8C3F-00C04FC2AAE2}");

        // Windows Forms specific popup menus
        //
        private const int mnuidSelection = 0x0500;
        private const int mnuidContainer = 0x0501;
        private const int mnuidTraySelection = 0x0503;
        private const int mnuidComponentTray = 0x0506;

        // Windows Forms specific menu items
        //
        private const int cmdidDesignerProperties = 0x1001;
        
        // Windows Forms specific keyboard commands
        //
        private const int cmdidReverseCancel        = 0x4001;
        private const int cmdidSpace                = 0x4015;

        private const int ECMD_CANCEL               = 103;
        private const int ECMD_RETURN               = 3;
        private const int ECMD_UP                   = 11;
        private const int ECMD_DOWN                 = 13;
        private const int ECMD_LEFT                 = 7;
        private const int ECMD_RIGHT                = 9;
        private const int ECMD_RIGHT_EXT            = 10;
        private const int ECMD_UP_EXT               = 12;
        private const int ECMD_LEFT_EXT             = 8;
        private const int ECMD_DOWN_EXT             = 14;
        private const int ECMD_TAB                  = 4;
        private const int ECMD_BACKTAB              = 5;

        private const int ECMD_CTLMOVELEFT          = 1224;
        private const int ECMD_CTLMOVEDOWN         = 1225;
        private const int ECMD_CTLMOVERIGHT         = 1226;
        private const int ECMD_CTLMOVEUP            = 1227;
        private const int ECMD_CTLSIZEDOWN          = 1228;
        private const int ECMD_CTLSIZEUP            = 1229;
        private const int ECMD_CTLSIZELEFT           = 1230;
        private const int ECMD_CTLSIZERIGHT          = 1231;
        
        /// <include file='doc\MenuCommands.uex' path='docs/doc[@for="MenuCommands.SelectionMenu"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly CommandID SelectionMenu           = new CommandID(wfMenuGroup, mnuidSelection);
        /// <include file='doc\MenuCommands.uex' path='docs/doc[@for="MenuCommands.ContainerMenu"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly CommandID ContainerMenu           = new CommandID(wfMenuGroup, mnuidContainer);
        /// <include file='doc\MenuCommands.uex' path='docs/doc[@for="MenuCommands.TraySelectionMenu"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly CommandID TraySelectionMenu       = new CommandID(wfMenuGroup, mnuidTraySelection);
        /// <include file='doc\MenuCommands.uex' path='docs/doc[@for="MenuCommands.ComponentTrayMenu"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly CommandID ComponentTrayMenu       = new CommandID(wfMenuGroup, mnuidComponentTray);

        // Windows Forms commands
        /// <include file='doc\MenuCommands.uex' path='docs/doc[@for="MenuCommands.DesignerProperties"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly CommandID DesignerProperties      = new CommandID(wfCommandSet, cmdidDesignerProperties);

        // Windows Forms Key commands        
        /// <include file='doc\MenuCommands.uex' path='docs/doc[@for="MenuCommands.KeyCancel"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly CommandID KeyCancel               = new CommandID(guidVSStd2K, ECMD_CANCEL);
        /// <include file='doc\MenuCommands.uex' path='docs/doc[@for="MenuCommands.KeyReverseCancel"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly CommandID KeyReverseCancel        = new CommandID(wfCommandSet, cmdidReverseCancel);
        /// <include file='doc\MenuCommands.uex' path='docs/doc[@for="MenuCommands.KeyDefaultAction"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly CommandID KeyDefaultAction        = new CommandID(guidVSStd2K, ECMD_RETURN);
        /// <include file='doc\MenuCommands.uex' path='docs/doc[@for="MenuCommands.KeyMoveUp"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly CommandID KeyMoveUp               = new CommandID(guidVSStd2K, ECMD_UP);
        /// <include file='doc\MenuCommands.uex' path='docs/doc[@for="MenuCommands.KeyMoveDown"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly CommandID KeyMoveDown             = new CommandID(guidVSStd2K, ECMD_DOWN);
        /// <include file='doc\MenuCommands.uex' path='docs/doc[@for="MenuCommands.KeyMoveLeft"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly CommandID KeyMoveLeft             = new CommandID(guidVSStd2K, ECMD_LEFT);
        /// <include file='doc\MenuCommands.uex' path='docs/doc[@for="MenuCommands.KeyMoveRight"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly CommandID KeyMoveRight            = new CommandID(guidVSStd2K, ECMD_RIGHT);
        /// <include file='doc\MenuCommands.uex' path='docs/doc[@for="MenuCommands.KeyNudgeUp"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly CommandID KeyNudgeUp              = new CommandID(guidVSStd2K, ECMD_CTLMOVEUP);
        /// <include file='doc\MenuCommands.uex' path='docs/doc[@for="MenuCommands.KeyNudgeDown"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly CommandID KeyNudgeDown            = new CommandID(guidVSStd2K, ECMD_CTLMOVEDOWN);
        /// <include file='doc\MenuCommands.uex' path='docs/doc[@for="MenuCommands.KeyNudgeLeft"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly CommandID KeyNudgeLeft            = new CommandID(guidVSStd2K, ECMD_CTLMOVELEFT);
        /// <include file='doc\MenuCommands.uex' path='docs/doc[@for="MenuCommands.KeyNudgeRight"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly CommandID KeyNudgeRight           = new CommandID(guidVSStd2K, ECMD_CTLMOVERIGHT);
        /// <include file='doc\MenuCommands.uex' path='docs/doc[@for="MenuCommands.KeySizeWidthIncrease"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly CommandID KeySizeWidthIncrease    = new CommandID(guidVSStd2K, ECMD_RIGHT_EXT);
        /// <include file='doc\MenuCommands.uex' path='docs/doc[@for="MenuCommands.KeySizeHeightIncrease"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly CommandID KeySizeHeightIncrease   = new CommandID(guidVSStd2K, ECMD_UP_EXT);
        /// <include file='doc\MenuCommands.uex' path='docs/doc[@for="MenuCommands.KeySizeWidthDecrease"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly CommandID KeySizeWidthDecrease    = new CommandID(guidVSStd2K, ECMD_LEFT_EXT);
        /// <include file='doc\MenuCommands.uex' path='docs/doc[@for="MenuCommands.KeySizeHeightDecrease"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly CommandID KeySizeHeightDecrease   = new CommandID(guidVSStd2K, ECMD_DOWN_EXT);
        /// <include file='doc\MenuCommands.uex' path='docs/doc[@for="MenuCommands.KeyNudgeWidthIncrease"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly CommandID KeyNudgeWidthIncrease   = new CommandID(guidVSStd2K, ECMD_CTLSIZERIGHT);
        /// <include file='doc\MenuCommands.uex' path='docs/doc[@for="MenuCommands.KeyNudgeHeightIncrease"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly CommandID KeyNudgeHeightIncrease  = new CommandID(guidVSStd2K, ECMD_CTLSIZEDOWN);
        /// <include file='doc\MenuCommands.uex' path='docs/doc[@for="MenuCommands.KeyNudgeWidthDecrease"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly CommandID KeyNudgeWidthDecrease   = new CommandID(guidVSStd2K, ECMD_CTLSIZELEFT);
        /// <include file='doc\MenuCommands.uex' path='docs/doc[@for="MenuCommands.KeyNudgeHeightDecrease"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly CommandID KeyNudgeHeightDecrease  = new CommandID(guidVSStd2K, ECMD_CTLSIZEUP);
        /// <include file='doc\MenuCommands.uex' path='docs/doc[@for="MenuCommands.KeySelectNext"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly CommandID KeySelectNext           = new CommandID(guidVSStd2K, ECMD_TAB);
        /// <include file='doc\MenuCommands.uex' path='docs/doc[@for="MenuCommands.KeySelectPrevious"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly CommandID KeySelectPrevious       = new CommandID(guidVSStd2K, ECMD_BACKTAB);
        /// <include file='doc\MenuCommands.uex' path='docs/doc[@for="MenuCommands.KeyTabOrderSelect"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly CommandID KeyTabOrderSelect       = new CommandID(wfCommandSet, cmdidSpace);
        
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\openfiledialogdesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="OpenFileDialogDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms.Design {

    using System;
    using System.Reflection;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Windows.Forms;

    /// <include file='doc\OpenFileDialogDesigner.uex' path='docs/doc[@for="OpenFileDialogDesigner"]/*' />
    /// <devdoc>
    ///      This is the designer for OpenFileDialog components.
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class OpenFileDialogDesigner : ComponentDesigner {
        public override void OnSetComponentDefaults() {
            base.OnSetComponentDefaults();
            FileDialog dialog = (FileDialog)Component;
            dialog.FileName = "";
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\paneldesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="PanelDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms.Design {
    using System.ComponentModel;

    using System.Diagnostics;

    using System;
    using System.Drawing;
    using System.Drawing.Drawing2D;
    using System.Windows.Forms;
    using Microsoft.Win32;

    /// <include file='doc\PanelDesigner.uex' path='docs/doc[@for="PanelDesigner"]/*' />
    /// <devdoc>
    ///      This class handles all design time behavior for the panel class.  This
    ///      draws a visible border on the panel if it doesn't have a border so the
    ///      user knows where the boundaries of the panel lie.
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class PanelDesigner : ScrollableControlDesigner {

        /// <include file='doc\PanelDesigner.uex' path='docs/doc[@for="PanelDesigner.DrawBorder"]/*' />
        /// <devdoc>
        ///      This draws a nice border around our panel.  We need
        ///      this because the panel can have no border and you can't
        ///      tell where it is.
        /// </devdoc>
        /// <internalonly/>
        private void DrawBorder(Graphics graphics) {
            Control ctl = Control;
            Rectangle rc = ctl.ClientRectangle;
            Color penColor;
            
            // Black or white pen?  Depends on the color of the control.
            //
            if (ctl.BackColor.GetBrightness() < .5) {
                penColor = ControlPaint.Light(ctl.BackColor);
            }
            else {
                penColor = ControlPaint.Dark(ctl.BackColor);;
            }
            
            Pen pen = new Pen(penColor);
            pen.DashStyle = DashStyle.Dash;
            
            rc.Width --;
            rc.Height--;
            graphics.DrawRectangle(pen, rc);
            
            pen.Dispose();
        }

        /// <include file='doc\PanelDesigner.uex' path='docs/doc[@for="PanelDesigner.OnPaintAdornments"]/*' />
        /// <devdoc>
        ///      Overrides our base class.  Here we check to see if there
        ///      is no border on the panel.  If not, we draw one so that
        ///      the panel shape is visible at design time.
        /// </devdoc>
        protected override void OnPaintAdornments(PaintEventArgs pe) {
            Panel panel = (Panel)Component;

            if (panel.BorderStyle == BorderStyle.None) {
                DrawBorder(pe.Graphics);
            }
            
            base.OnPaintAdornments(pe);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\pbrsforward.cs ===
//------------------------------------------------------------------------------
// <copyright file="PbrsForward.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms.Design {

    using System.Collections;    
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.Design;
    using System.ComponentModel.Design;
    using System.Windows.Forms;
    using System.Drawing;
    using Microsoft.Win32;

    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class PbrsForward : IWindowTarget   {

        private Control target;
        private IWindowTarget oldTarget;
        
        
        // we save the last key down so we can recreate the last message if we need to activate
        // the properties window...
        //
        private Message        lastKeyDown;
        private ArrayList      bufferedChars;
        
        private const int      WM_PRIVATE_POSTCHAR = NativeMethods.WM_USER + 0x1598;
        private bool           postCharMessage;

        private IMenuCommandService menuCommandSvc;
        private IServiceProvider sp;
        
        public PbrsForward(Control target, IServiceProvider sp) {
            this.target = target;
            this.oldTarget = target.WindowTarget;
            this.sp = sp;
            target.WindowTarget = this;
        }

           
        private IMenuCommandService MenuCommandService {
            get {
                if (menuCommandSvc == null && sp != null) {
                    menuCommandSvc = (IMenuCommandService)sp.GetService(typeof(IMenuCommandService));
                }
                return menuCommandSvc;
            }
        }

        public void Dispose() {
            target.WindowTarget = oldTarget;
        }


        /// <include file='doc\IWindowTarget.uex' path='docs/doc[@for="IWindowTarget.OnHandleChange"]/*' />
        /// <devdoc>
        ///      Called when the window handle of the control has changed.
        /// </devdoc>
        void IWindowTarget.OnHandleChange(IntPtr newHandle){
        }

        /// <include file='doc\IWindowTarget.uex' path='docs/doc[@for="IWindowTarget.OnMessage"]/*' />
        /// <devdoc>
        ///      Called to do control-specific processing for this window.
        /// </devdoc>
        void IWindowTarget.OnMessage(ref Message m){

         switch (m.Msg) {
            
                case WM_PRIVATE_POSTCHAR:

                   if (bufferedChars == null) {
                       return;
                   }

                   // recreate the keystroke to the newly activated window
                   IntPtr hWnd = NativeMethods.GetFocus();

                   foreach (BufferedKey bk in bufferedChars) {
                       if (bk.KeyDown.Msg != 0) {
                           NativeMethods.SendMessage(hWnd, NativeMethods.WM_KEYDOWN, bk.KeyDown.WParam, bk.KeyDown.LParam);
                       }
                       NativeMethods.SendMessage(hWnd, NativeMethods.WM_CHAR, bk.KeyChar.WParam, bk.KeyChar.LParam);
                       if (bk.KeyUp.Msg != 0) {
                           NativeMethods.SendMessage(hWnd, NativeMethods.WM_KEYUP, bk.KeyUp.WParam, bk.KeyUp.LParam);
                       }
                   }
                   bufferedChars.Clear();
                   return;
                case NativeMethods.WM_KEYDOWN:
                    this.lastKeyDown = m;
                    break;

                case NativeMethods.WM_IME_ENDCOMPOSITION:
                case NativeMethods.WM_KEYUP:
                    this.lastKeyDown.Msg = 0;
                    break;
            
                case NativeMethods.WM_CHAR: 
                    
                    if ((Control.ModifierKeys & (Keys.Control | Keys.Alt)) != 0) {
                        break;
                    }

                    if (bufferedChars == null) {
                        bufferedChars = new ArrayList();
                    }
                    bufferedChars.Add(new BufferedKey(lastKeyDown, m, lastKeyDown));
                    if (MenuCommandService != null) {
                        // throw the properties window command, we will redo the keystroke when we actually
                        // lose focus
                        postCharMessage = true;
                        MenuCommandService.GlobalInvoke(StandardCommands.PropertiesWindow);
                    }
                    break;
                    
                case NativeMethods.WM_KILLFOCUS:
                    if (postCharMessage) {
                        // see ASURT 45313
                        // now that we've actually lost focus, post this message to the queue.  This allows
                        // any activity that's in the queue to settle down before our characters are posted.
                        // to the queue.
                        //
                        // we post because we need to allow the focus to actually happen before we send 
                        // our strokes so we know where to send them
                        //
                        // we can't use the wParam here because it may not be the actual window that needs
                        // to pick up the strokes.
                        //
                        UnsafeNativeMethods.PostMessage(target.Handle, WM_PRIVATE_POSTCHAR, IntPtr.Zero, IntPtr.Zero);
                        postCharMessage = false;
                    }
                    break;
             }
        
            if (this.oldTarget != null) {
                oldTarget.OnMessage(ref m);
            }
        }


        private struct BufferedKey {
            public readonly Message KeyDown;
            public readonly Message KeyUp;
            public readonly Message KeyChar;

            public BufferedKey(Message keyDown, Message keyChar, Message keyUp) {
                this.KeyChar = keyChar;
                this.KeyDown = keyDown;
                this.KeyUp   = keyUp;
            }
        }
    
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\pictureboxdesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="PictureBoxDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   PictureBoxDesigner.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/

namespace System.Windows.Forms.Design {
    

    using System.Diagnostics;

    using System;
    using System.Windows.Forms;
    using System.Drawing;
    using Microsoft.Win32;
    
    using System.ComponentModel;
    using System.Drawing.Design;
    using System.ComponentModel.Design;
    using System.Collections;

    /// <include file='doc\PictureBoxDesigner.uex' path='docs/doc[@for="PictureBoxDesigner"]/*' />
    /// <devdoc>
    ///     This class handles all design time behavior for the group box class.  Group
    ///     boxes may contain sub-components and therefore use the frame designer.
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class PictureBoxDesigner : ControlDesigner {
        
        private EventHandler propChanged = null; // Delegate used to dirty the selectionUIItem when needed.
        
        /// <include file='doc\PictureBoxDesigner.uex' path='docs/doc[@for="PictureBoxDesigner.Dispose"]/*' />
        /// <devdoc>
        ///      Disposes of this object.
        /// </devdoc>
        protected override void Dispose(bool disposing) {
            if (disposing) {
                // Hook up the property change notification so that we can dirty the SelectionUIItem when needed.
                if (propChanged != null) {
                    ((PictureBox)Control).SizeModeChanged -= propChanged;
                }
            }
    
            base.Dispose(disposing);
        }
        
        /// <include file='doc\PictureBoxDesigner.uex' path='docs/doc[@for="PictureBoxDesigner.Initialize"]/*' />
        /// <devdoc>
        ///     Called by the host when we're first initialized.
        /// </devdoc>
        public override void Initialize(IComponent component) {
            base.Initialize(component);

            // Hook up the property change notification so that we can dirty the SelectionUIItem when needed.
            propChanged = new EventHandler(this.OnControlPropertyChanged);
            ((PictureBox)Control).SizeModeChanged += propChanged;
        }
        
        /// <include file='doc\PictureBoxDesigner.uex' path='docs/doc[@for="PictureBoxDesigner.OnControlPropertyChanged"]/*' />
        /// <devdoc>
        ///      For controls, we sync their property changed event so our component can track their location.
        /// </devdoc>
        private void OnControlPropertyChanged(object sender, EventArgs e) {
            ISelectionUIService selectionUISvc = (ISelectionUIService)GetService(typeof(ISelectionUIService));
            selectionUISvc.SyncComponent((IComponent)sender);
        }
        
        /// <include file='doc\PictureBoxDesigner.uex' path='docs/doc[@for="PictureBoxDesigner.SelectionRules"]/*' />
        /// <devdoc>
        ///     Retrieves a set of rules concerning the movement capabilities of a component.
        ///     This should be one or more flags from the SelectionRules class.  If no designer
        ///     provides rules for a component, the component will not get any UI services.
        /// </devdoc>
        public override SelectionRules SelectionRules {
            get {
                SelectionRules rules = base.SelectionRules;
                object component = Component;

                PropertyDescriptor propSizeMode = TypeDescriptor.GetProperties(Component)["SizeMode"];
                if (propSizeMode != null) {
                    PictureBoxSizeMode sizeMode = (PictureBoxSizeMode)propSizeMode.GetValue(component);

                    if (sizeMode == PictureBoxSizeMode.AutoSize) {
                        rules &= ~SelectionRules.AllSizeable;
                    }
                }

                return rules;
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\richtextboxdesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="RichTextBoxDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms.Design {
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.Design;
    using System.ComponentModel.Design;
    using System.Windows.Forms;
    using System.Drawing;
    using Microsoft.Win32;

    /// <include file='doc\RichTextBoxDesigner.uex' path='docs/doc[@for="RichTextBoxDesigner"]/*' />
    /// <devdoc>
    ///     The RichTextBoxDesigner provides rich designtime behavior for the
    ///     RichTextBox control.
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class RichTextBoxDesigner : ControlDesigner {
    
        /// <include file='doc\RichTextBoxDesigner.uex' path='docs/doc[@for="RichTextBoxDesigner.OnSetComponentDefaults"]/*' />
        /// <devdoc>
        ///     Called when the designer is intialized.  This allows the designer to provide some
        ///     meaningful default values in the control.  The default implementation of this
        ///     sets the control's text to its name.
        /// </devdoc>
        public override void OnSetComponentDefaults() {

            base.OnSetComponentDefaults();

            // Disable DragDrop at design time.
            // CONSIDER: Is this the correct function for doing this?
            Control control = Control;

            if (control != null && control.Handle != IntPtr.Zero) {
                NativeMethods.RevokeDragDrop(control.Handle);
                // DragAcceptFiles(control.Handle, false);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\propertygriddesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="PropertyGridDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   PropertyGridDesigner.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/

namespace System.Windows.Forms.Design {
    

    using System.Diagnostics;

    using System;
    using System.Windows.Forms;
    using System.Drawing;
    using Microsoft.Win32;
    
    using System.ComponentModel;
    using System.Drawing.Design;
    using System.ComponentModel.Design;
    using System.Collections;

    /// <include file='doc\PictureBoxDesigner.uex' path='docs/doc[@for="PictureBoxDesigner"]/*' />
    /// <devdoc>
    ///     This class handles all design time behavior for the property grid class.  Group
    ///     boxes may contain sub-components and therefore use the frame designer.
    /// </devdoc>
    internal class PropertyGridDesigner : ControlDesigner {
       /// <include file='doc\ControlDesigner.uex' path='docs/doc[@for="ControlDesigner.PreFilterProperties"]/*' />
        /// <devdoc>
        ///      Allows a designer to filter the set of properties
        ///      the component it is designing will expose through the
        ///      TypeDescriptor object.  This method is called
        ///      immediately before its corresponding "Post" method.
        ///      If you are overriding this method you should call
        ///      the base implementation before you perform your own
        ///      filtering.
        /// </devdoc>
        protected override void PreFilterProperties(IDictionary properties) {
            
            // remove the ScrollableControl props...
            //
            properties.Remove("AutoScroll");
            properties.Remove("AutoScrollMargin");
            properties.Remove("DockPadding");
            properties.Remove("AutoScrollMinSize");

            base.PreFilterProperties(properties);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\savefiledialogdesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="SaveFileDialogDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms.Design {

    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Windows.Forms;
    using Microsoft.Win32;

    /// <include file='doc\SaveFileDialogDesigner.uex' path='docs/doc[@for="SaveFileDialogDesigner"]/*' />
    /// <devdoc>
    ///      This is the designer for SaveFileDialog components.
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class SaveFileDialogDesigner : ComponentDesigner {
        public override void OnSetComponentDefaults() {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\scrollablecontroldesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="ScrollableControlDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms.Design {
    using System.Design;
    using System.Runtime.Serialization.Formatters;    
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.ComponentModel.Design;
    using System.Windows.Forms;
    using System.Drawing;
    using Microsoft.Win32;

    /// <include file='doc\ScrollableControlDesigner.uex' path='docs/doc[@for="ScrollableControlDesigner"]/*' />
    /// <devdoc>    
    ///     The ScrollableControlDesigner class builds on the ParentControlDesigner, and adds the implementation
    ///     of IWinFormsDesigner so that the designer can be hosted as a document.
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public class ScrollableControlDesigner : ParentControlDesigner {

        private ISelectionUIService selectionUISvc;

        /// <include file='doc\ScrollableControlDesigner.uex' path='docs/doc[@for="ScrollableControlDesigner.GetHitTest"]/*' />
        /// <devdoc>        
        ///     Overrides the base class's GetHitTest method to determine regions of the
        ///     control that should always be UI-Active.  For a form, if it has autoscroll
        ///     set the scroll bars are always UI active.
        /// </devdoc>
        protected override bool GetHitTest(Point pt) {
            if (base.GetHitTest(pt)) {
                return true;
            }
            
            // The scroll bars on a form are "live"
            //
            ScrollableControl f = (ScrollableControl)Control;
            if (f.IsHandleCreated && f.AutoScroll) {
                int hitTest = (int)NativeMethods.SendMessage(f.Handle, NativeMethods.WM_NCHITTEST, (IntPtr)0, (IntPtr)NativeMethods.Util.MAKELPARAM(pt.X, pt.Y));
                if (hitTest == NativeMethods.HTVSCROLL || hitTest == NativeMethods.HTHSCROLL) {
                    return true;
                }
            }
            return false;
        }

        /// <include file='doc\ScrollableControlDesigner.uex' path='docs/doc[@for="ScrollableControlDesigner.WndProc"]/*' />
        /// <devdoc>
        ///     We override our base class's WndProc to monitor certain messages.
        /// </devdoc>
        protected override void WndProc(ref Message m) {

            base.WndProc(ref m);
        
            switch(m.Msg) {
                case NativeMethods.WM_HSCROLL:
                case NativeMethods.WM_VSCROLL:
                
                    // When we scroll, we reposition a control without causing a
                    // property change event.  Therefore, we must tell the
                    // selection UI service to sync itself.
                    //
                    if (selectionUISvc == null) {
                        selectionUISvc = (ISelectionUIService)GetService(typeof(ISelectionUIService));
                    }

                    if (selectionUISvc != null) {
                        selectionUISvc.SyncSelection();
                    }

                    // Now we must paint our adornments, since the scroll does not
                    // trigger a paint event
                    //
                    Control.Invalidate();
                    Control.Update();
                    break;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\parentcontroldesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="ParentControlDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms.Design {
    using System.Design;
    using System.Threading;
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.Collections;
    using Microsoft.Win32;    
    using System.ComponentModel.Design;
    using System.Drawing;

    using System.Drawing.Design;
    using System.IO;
    using System.Windows.Forms;
    using ArrayList = System.Collections.ArrayList;

    /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner"]/*' />
    /// <devdoc>
    ///     The ParentControlDesigner class builds on the ControlDesigner.  It adds the ability
    ///     to manipulate child components, and provides a selection UI handler for all
    ///     components it contains.
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public class ParentControlDesigner : ControlDesigner, ISelectionUIHandler, IOleDragClient {

#if DEBUG
        private static TraceSwitch containerSelectSwitch     = new TraceSwitch("ContainerSelect", "Debug container selection");
#endif
        private static BooleanSwitch StepControls = new BooleanSwitch("StepControls", "ParentControlDesigner: step added controls");

        // These handle our drag feedback for selecting a group of components.
        // These come into play when the user clicks on our own component directly.
        //
        private ISelectionUIHandler             parentDraggingHandler = null;
        private Point                           mouseDragBase = InvalidPoint;      // the base point of the drag
        private Rectangle                       mouseDragOffset = Rectangle.Empty;    // always keeps the current rectangle
        private ToolboxItem                     mouseDragTool;      // the tool that's being dragged, if we're creating a component
        private FrameStyle                      mouseDragFrame;     // the frame style of this mouse drag

        private ParentControlSelectionUIHandler dragHandler;   // the selection UI handler for this frame
        private OleDragDropHandler              oleDragDropHandler; // handler for ole drag drop operations
        private EscapeHandler                   escapeHandler;      // active during drags to override escape.
        private Control                         pendingRemoveControl; // we've gotten an OnComponentRemoving, and are waiting for OnComponentRemove
        private IComponentChangeService         componentChangeSvc;
        
        // Services that we keep around for the duration of a drag.  you should always check
        // to see if you need to get this service.  We cache it, but demand create it.
        //
        private IToolboxService toolboxService;

        private const int ContainerSelectorTimerId = 1;
        private bool waitingForTimeout = false;

        private bool needOptionsDefaults = true;

        private const int   minGridSize = 2;
        private const int   maxGridSize = 200;

        // designer options...
        //
        private bool  gridSnap = true;
        private Size gridSize = Size.Empty;
        private bool  drawGrid = true;

        private bool defaultGridSnap = true;
        private bool defaultDrawGrid = true;
        private Size defaultGridSize = new Size(8, 8);

        private bool parentCanSetDrawGrid = true; //since we can inherit the grid/snap setting of our parent,
        private bool parentCanSetGridSize = true; //  these 3 properties let us know if these values have
        private bool parentCanSetGridSnap = true; //  been set explicitly by a user - so to ignore the parent's setting

        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.CurrentGridSize"]/*' />
        /// <devdoc>
        ///     This can be called to determine the current grid spacing and mode.
        ///     It is sensitive to what modifier keys the user currently has down and
        ///     will either return the current grid snap dimensons, or a 1x1 point
        ///     indicating no snap.
        /// </devdoc>
        private Size CurrentGridSize {
            get {
                Size snap;

                if (SnapToGrid) {
                    snap = gridSize;
                }
                else {
                    snap = new Size(1, 1);
                }
                return snap;
            }
        }

        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.DefaultControlLocation"]/*' />
        /// <devdoc>
        /// Determines the default location for a control added to this designer.
        /// it is usualy (0,0), but may be modified if the container has special borders, etc.
        /// </devdoc>
        protected virtual Point DefaultControlLocation {
            get {
                return new Point(0,0);
            }
        }

        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.DrawGrid"]/*' />
        /// <devdoc>
        ///     Accessor method for the DrawGrid property.  This property determines
        ///     if the grid should be drawn on a control.
        /// </devdoc>
        protected virtual bool DrawGrid {
            get {
                EnsureOptionsDefaults();
                return drawGrid;
            }
            set {
                EnsureOptionsDefaults();
                if (value != drawGrid) {
                    if (parentCanSetDrawGrid) {
                        parentCanSetDrawGrid = false;
                    }

                    drawGrid = value;

                    //invalidate the cotnrol to remove or draw the grid based on the new value
                    Control control = Control;
                    if (control != null) {
                        control.Invalidate(true);
                    }

                    //now, notify all child parent control designers that we have changed our setting
                    // 'cause they might to change along with us, unless the user has explicitly set
                    // those values...
                    IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
                    if (host != null) {
                        // for (int i = 0; i < children.Length; i++) {
                        foreach(Control child in Control.Controls) {
                            IDesigner designer = host.GetDesigner(child);                            
                            if (designer != null && designer is ParentControlDesigner) {
                                ((ParentControlDesigner)designer).DrawGridOfParentChanged(drawGrid);
                            }
                        }
                    }
                }
            }
        }

        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.EnableDragRect"]/*' />
        /// <devdoc>
        ///     Determines whether drag rects can be drawn on this designer.
        /// </devdoc>
        protected override bool EnableDragRect {
            get {
                return true;
            }
        }
        
        internal Size ParentGridSize {
            get {
                return GridSize;
            }
        }

        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.GridSize"]/*' />
        /// <devdoc>
        ///     Gets/Sets the GridSize property for a form or user control.
        /// </devdoc>
        protected Size GridSize {
            get {
                EnsureOptionsDefaults();
                return gridSize;
            }
            set {
                if (parentCanSetGridSize) {
                    parentCanSetGridSize = false;
                }
                EnsureOptionsDefaults() ;
                //do some validation checking here, against min & max GridSize
                //
                if ( value.Width < minGridSize || value.Height < minGridSize || 
                     value.Width > maxGridSize || value.Height > maxGridSize)
                    throw new ArgumentException(SR.GetString(SR.InvalidArgument,
                                                              "GridSize",
                                                              value.ToString()));

                gridSize = value;

                //invalidate the control
                Control control = Control;
                if (control != null) {
                    control.Invalidate(true);
                }

                //now, notify all child parent control designers that we have changed our setting
                // 'cause they might to change along with us, unless the user has explicitly set
                // those values...
                IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
                if (host != null) {
                    foreach(Control child in Control.Controls) {
                        IDesigner designer = host.GetDesigner(child);                        
                        if (designer != null && designer is ParentControlDesigner) {
                            ((ParentControlDesigner)designer).GridSizeOfParentChanged(gridSize);
                        }
                    }
                }
            }
        }

        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.SnapToGrid"]/*' />
        /// <devdoc>
        ///     Determines if we should snap to grid or not.
        /// </devdoc>
        private bool SnapToGrid {
            // If the control key is down, invert our snapping logic
            //
            get{
                EnsureOptionsDefaults();
                return gridSnap;
            }
            set{
                EnsureOptionsDefaults();
                // we need to undraw any current frame
                if (gridSnap != value) {
                    if (parentCanSetGridSnap) {
                        parentCanSetGridSnap = false;
                    }

                    gridSnap = value;

                    //now, notify all child parent control designers that we have changed our setting
                    // 'cause they might to change along with us, unless the user has explicitly set
                    // those values...                    
                    IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
                    if (host != null) {
                        foreach(Control child in Control.Controls) {
                            IDesigner designer = host.GetDesigner(child);                            
                            if (designer != null && designer is ParentControlDesigner) {
                                ((ParentControlDesigner)designer).GridSnapOfParentChanged(gridSnap);
                            }
                        }
                    }

                }
            }
        }

        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.AddChildComponents"]/*' />
        /// <devdoc>
        ///      Adds all the child components of a component
        ///      to the given container
        /// </devdoc>
        private void AddChildComponents(IComponent component, IContainer container, IDesignerHost host, ISelectionUIService uiSvc) {
        
            Control control = GetControl(component);
            
            if (control != null) {
                Control  parent = control;
                
                Control[] children = new Control[parent.Controls.Count];
                parent.Controls.CopyTo(children, 0);
                
                string name;
                ISite childSite;
                IContainer childContainer = null;

                object parentDesigner = host.GetDesigner(component);

                for (int i = 0; i < children.Length; i++) {
                    childSite = ((IComponent)children[i]).Site;

                    if (childSite != null) {
                        name = childSite.Name;
                        if (container.Components[name] != null) {
                            name = null;
                        }
                        childContainer = childSite.Container;
                    }
                    else {
                        //name = null;
                        // we don't want to add unsited child controls because
                        // these may be items from a composite control.  if they
                        // are legitamite children, the ComponentModelPersister would have
                        // sited them already.
                        //
                        continue;
                    }

                    if (childContainer != null) {
                        childContainer.Remove(children[i]);
                    }

                    if (name != null) {
                        container.Add(children[i], name);
                    }
                    else {
                        container.Add(children[i]);
                    }
                    
                    if (children[i].Parent != parent) {
                        parent.Controls.Add(children[i]);
                    }
                    else if (parentDesigner is ISelectionUIHandler) {
                        // setup the UI handler
                        uiSvc.AssignSelectionUIHandler(children[i], (ISelectionUIHandler)parentDesigner);
                    }
                    else {
                        // ugh, last resort
                        int childIndex = parent.Controls.GetChildIndex(children[i]);
                        parent.Controls.Remove(children[i]);
                        parent.Controls.Add(children[i]);
                        parent.Controls.SetChildIndex(children[i], childIndex);
                    }
                    
                    IDesigner designer = host.GetDesigner(component);
                    if ( designer is ComponentDesigner) {
                         ((ComponentDesigner)designer).InitializeNonDefault();
                    }
                    
                    // recurse;
                    AddChildComponents(children[i], container, host, uiSvc);
                }
            }
        }

        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.Dispose"]/*' />
        /// <devdoc>
        ///      Disposes this component.
        /// </devdoc>
        protected override void Dispose(bool disposing) {

            if (disposing) {
                // Stop any drag that we are currently processing.
                OnMouseDragEnd(false);
                EnableDragDrop(false);

                Control.ControlAdded -= new ControlEventHandler(this.OnChildControlAdded);
                Control.ControlRemoved -= new ControlEventHandler(this.OnChildControlRemoved);

                IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
                if (host != null) {
                    host.LoadComplete -= new EventHandler(this.OnLoadComplete);
                    componentChangeSvc.ComponentRemoving -= new ComponentEventHandler(this.OnComponentRemoving);
                    componentChangeSvc.ComponentRemoved -= new ComponentEventHandler(this.OnComponentRemoved);
                    componentChangeSvc = null;
                }
            }
            
            base.Dispose(disposing);
        }

        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.DrawGridOfParentChanged"]/*' />
        /// <devdoc>
        ///     This is called by the parent when the ParentControlDesigner's
        ///     grid/snap settings have changed.  Unless the user has explicitly
        ///     set these values, this designer will just inherit the new ones
        ///     from the parent.
        /// </devdoc>
        private void DrawGridOfParentChanged(bool drawGrid) {
            if (parentCanSetDrawGrid) {
                DrawGrid = drawGrid;
                parentCanSetDrawGrid = true;
            }
        }

        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.GridSizeOfParentChanged"]/*' />
        /// <devdoc>
        ///     This is called by the parent when the ParentControlDesigner's
        ///     grid/snap settings have changed.  Unless the user has explicitly
        ///     set these values, this designer will just inherit the new ones
        ///     from the parent.
        /// </devdoc>
        private void GridSizeOfParentChanged(Size gridSize) {
            if (parentCanSetGridSize) {
                GridSize = gridSize;
                parentCanSetGridSize = true;
            }
        }

        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.GridSnapOfParentChanged"]/*' />
        /// <devdoc>
        ///     This is called by the parent when the ParentControlDesigner's
        ///     grid/snap settings have changed.  Unless the user has explicitly
        ///     set these values, this designer will just inherit the new ones
        ///     from the parent.
        /// </devdoc>
        private void GridSnapOfParentChanged(bool gridSnap) {
            if (parentCanSetGridSnap) {
                SnapToGrid = gridSnap;
                parentCanSetGridSnap = true;
            }
        }

        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.InvokeCreateTool"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected static void InvokeCreateTool(ParentControlDesigner toInvoke, ToolboxItem tool) {
            toInvoke.CreateTool(tool);
        }
        
         /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.CanParent"]/*' />
         /// <devdoc>
        ///     Determines if the this designer can parent to the specified desinger --
        ///     generally this means if the control for this designer can parent the
        ///     given ControlDesigner's control.
        /// </devdoc>
        public virtual bool CanParent(ControlDesigner controlDesigner) {
            return CanParent(controlDesigner.Control);
        }
        
         /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.CanParent1"]/*' />
         /// <devdoc>
        ///     Determines if the this designer can parent to the specified desinger --
        ///     generally this means if the control for this designer can parent the
        ///     given ControlDesigner's control.
        /// </devdoc>
        public virtual bool CanParent(Control control) {
            return !control.Contains(this.Control);
        }
        
        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.CreateTool"]/*' />
        /// <devdoc>
        ///      Creates the given tool in the center of the currently selected
        ///      control.  The default size for the tool is used.
        /// </devdoc>
        protected void CreateTool(ToolboxItem tool) {
            CreateToolCore(tool, 0, 0, 0, 0, false, false);
        }

        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.CreateTool1"]/*' />
        /// <devdoc>
        ///      Creates the given tool in the currently selected control at the
        ///      given position.  The default size for the tool is used.
        /// </devdoc>
        protected void CreateTool(ToolboxItem tool, Point location) {
            CreateToolCore(tool, location.X, location.Y, 0, 0, true, false);
        }

        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.CreateTool2"]/*' />
        /// <devdoc>
        ///      Creates the given tool in the currently selected control.  The
        ///      tool is created with the provided shape.
        /// </devdoc>
        protected void CreateTool(ToolboxItem tool, Rectangle bounds) {
            CreateToolCore(tool, bounds.X, bounds.Y, bounds.Width, bounds.Height, true, true);
        }

        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.CreateToolCore"]/*' />
        /// <devdoc>
        ///      This is the worker method of all CreateTool methods.  It is the only one
        ///      that can be overridden.
        /// </devdoc>
        protected virtual IComponent[] CreateToolCore(ToolboxItem tool, int x, int y, int width, int height, bool hasLocation, bool hasSize) {

            // We invoke the drag drop handler for this.  This implementation is shared between all designers that
            // create components.
            //
            return GetOleDragHandler().CreateTool(tool, x, y, width, height, hasLocation, hasSize);
        }

        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.EnsureOptionsDefaults"]/*' />
        /// <devdoc>
        /// Ensure that we've picked up the correct grid/snap settings.  First, we'll set 
        /// the settings to a default value.  Next, we'll check to see if our parent has
        /// grid/snap settings - if so, we'll inherit those.  Finally, we'll get the setting
        /// from the options page.
        /// </devdoc>
        private void EnsureOptionsDefaults() {
            if (needOptionsDefaults) {
                defaultGridSnap = gridSnap = true;
                defaultDrawGrid = drawGrid = true;
                defaultGridSize = gridSize = new Size(8,8);

                //Before we check our options page, we need to see if our parent
                //is a ParentControlDesigner, is so, then we will want to inherit all
                //our grid/snap setting from it - instead of our options page
                //
                ParentControlDesigner parent = GetParentControlDesignerOfParent();
                if (parent != null) {
                    gridSize = parent.GridSize;
                    gridSnap = parent.SnapToGrid;
                    drawGrid = parent.DrawGrid;

                    needOptionsDefaults = false;
                    return;

                }

                IDesignerOptionService optSvc = (IDesignerOptionService)GetService(typeof(IDesignerOptionService));

                if (optSvc != null) {
                    object value = optSvc.GetOptionValue("WindowsFormsDesigner\\General", "SnapToGrid");
                    if (value is bool) defaultGridSnap = gridSnap = (bool)value;

                    value = optSvc.GetOptionValue("WindowsFormsDesigner\\General", "ShowGrid");
                    if (value is bool) defaultDrawGrid = drawGrid = (bool)value;

                    value = optSvc.GetOptionValue("WindowsFormsDesigner\\General", "GridSize");
                    if (value is Size) defaultGridSize = gridSize = (Size)value;
                }

                needOptionsDefaults = false;
            }
        }
        
        /// <devdoc>
        ///     Returns the component that this control represents, or NULL if no component
        ///     could be found.
        /// </devdoc>
        private IComponent GetComponentForControl(Control control) {
        
            IComponent component = null;
                    
            // Someone has added a control to us, but it's not sited.  Don't assign a UI handler, but
            // do walk through the components in the container to see if one of them has a control
            // designer that matches this control.  If so, then assign that component to the
            // selection UI handler.
            //
            IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
            if (host != null) {
                foreach(IComponent comp in host.Container.Components) {
                    ControlDesigner cd = host.GetDesigner(comp) as ControlDesigner;
                    if (cd != null && cd.Control == control) {
                        component = comp;
                        break;
                    }
                }
            }
            
            return component;
        }

        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.GetComponentsInRect"]/*' />
        /// <devdoc>
        ///     Finds the array of components within the given rectangle.  This uses the rectangle to
        ///     find controls within our control, and then uses those controls to find the actual
        ///     components.  It returns an object array so the output can be directly fed into
        ///     the selection service.
        /// </devdoc>
        private object[] GetComponentsInRect(Rectangle value, bool screenCoords) {
            ArrayList list = new ArrayList();
            Rectangle rect = screenCoords ? Control.RectangleToClient(value) : value;

            IContainer container = Component.Site.Container;

            Control control = Control;
            int controlCount = control.Controls.Count;

            for (int i = 0; i < controlCount; i++) {
                Control child = control.Controls[i];
                Rectangle bounds = child.Bounds;

                if (bounds.IntersectsWith(rect) && child.Site != null && child.Site.Container == container) {
                    list.Add(child);
                }
            }

            return list.ToArray();
        }
        
        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.GetControl"]/*' />
        /// <devdoc>
        /// Returns the control that represents the UI for the given component.
        /// </devdoc>
        protected Control GetControl(object component) {
            if (component is IComponent) {
                IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
                if (host != null) {
                    ControlDesigner cd = host.GetDesigner((IComponent)component) as ControlDesigner;
                    if (cd != null) {
                        return cd.Control;
                    }
                }
            }
            
            return null;
        }

        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.GetControlStackLocation"]/*' />
        /// <devdoc>
        /// Computes the next default location for a control. It tries to find a spot
        /// where no other controls are being obscured and the new control has 2 corners
        /// that don't have other controls under them.
        /// </devdoc>
        private Rectangle GetControlStackLocation(Rectangle centeredLocation) {

            Control parent = this.Control;
            
            int     parentHeight = parent.ClientSize.Height;
            int     parentWidth = parent.ClientSize.Width;
            
            if (centeredLocation.Bottom >= parentHeight ||
                centeredLocation.Right >= parentWidth) {

                centeredLocation.X = DefaultControlLocation.X;
                centeredLocation.Y = DefaultControlLocation.Y;
            }

            return centeredLocation;
        }

        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.GetDefaultSize"]/*' />
        /// <devdoc>
        ///     Retrieves the default dimensions for the given component class.
        /// </devdoc>
        private Size GetDefaultSize(IComponent component) {

            Size size = Size.Empty;
            DefaultValueAttribute sizeAttr = null;

            // attempt to get the size property of our component
            //
            PropertyDescriptor sizeProp = TypeDescriptor.GetProperties(component)["Size"];

            if (sizeProp != null) {

                // first, let's see if we can get a valid size...
                size = (Size)sizeProp.GetValue(component);

                // ...if not, we'll see if there's a default size attribute...
                if (size.Width <= 0 || size.Height <= 0) {
                    sizeAttr = (DefaultValueAttribute)sizeProp.Attributes[typeof(DefaultValueAttribute)];
                    if (sizeAttr != null) {
                        return((Size)sizeAttr.Value);
                    }
                }
                else {
                    return size;
                }
            }

            // Couldn't get the size or a def size attrib, returning 75,23...
            //
            return(new Size(75, 23));
        }

        internal OleDragDropHandler GetOleDragHandler() {
            if (oleDragDropHandler == null) {
                oleDragDropHandler = new ControlOleDragDropHandler(dragHandler, ( IServiceProvider )GetService(typeof(IDesignerHost)), this);
            }
            return oleDragDropHandler;
        }

        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.GetParentControlDesignerOfParent"]/*' />
        /// <devdoc>
        /// This method return the ParentControlDesigner of the parenting control, 
        /// it is used for inheriting the grid size, snap to grid, and draw grid
        /// of parenting controls.
        /// </devdoc>
        private ParentControlDesigner GetParentControlDesignerOfParent() {
            Control parent = Control.Parent;
            IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
            if (parent != null && host != null) {
                IDesigner designer = (IDesigner)host.GetDesigner(parent);
                if (designer != null && designer is ParentControlDesigner) {
                    return(ParentControlDesigner)designer;
                }
            }
            return null;
        }

        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.GetAdjustedSnapLocation"]/*' />
        /// <devdoc>
        ///     Updates the location of the control according to the GridSnap and Size.
        ///     This method simply calls GetUpdatedRect(), then ignores the width and
        ///     height
        /// </devdoc>
        private Rectangle GetAdjustedSnapLocation(Rectangle originalRect, Rectangle dragRect) {
            Rectangle adjustedRect = GetUpdatedRect(originalRect, dragRect, true);

            //now, preserve the width and height that was originally passed in
            adjustedRect.Width = dragRect.Width;
            adjustedRect.Height = dragRect.Height;

            //we need to keep in mind that if we adjust to the snap, that we could
            //have possibly moved the control's position outside of the display rect.
            //ex: groupbox's display rect.x = 3, but we might snap to 0.
            //so we need to check with the control's designer to make sure this 
            //doesn't happen
            //
            Point minimumLocation = DefaultControlLocation;
            if (adjustedRect.X < minimumLocation.X) {
                adjustedRect.X = minimumLocation.X;
            }
            if (adjustedRect.Y < minimumLocation.Y) {
                adjustedRect.Y = minimumLocation.Y;
            }

            //here's our rect that has been snapped to grid
            return adjustedRect;

        }


        internal Point GetSnappedPoint(Point pt) {
            Rectangle r = GetUpdatedRect(Rectangle.Empty, new Rectangle(pt.X, pt.Y, 0, 0), false);
            return new Point(r.X, r.Y);
        }

        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.GetUpdatedRect"]/*' />
        /// <devdoc>
        ///     Updates the given rectangle, adjusting it for grid snaps as
        ///     needed.
        /// </devdoc>
        protected Rectangle GetUpdatedRect(Rectangle originalRect, Rectangle dragRect, bool updateSize) {
           Rectangle updatedRect = Rectangle.Empty;//the rectangle with updated coords that we will return

           if (SnapToGrid) {
               Size gridSize = GridSize;
               Point halfGrid = new Point(gridSize.Width/2, gridSize.Height/2);
               
               updatedRect = dragRect;      

               // Calculate the new x,y coordinates of our rectangle...
               //
               int dragBottom = dragRect.Y + dragRect.Height;
               int dragRight  = dragRect.X + dragRect.Width;
               
               updatedRect.X =  originalRect.X;
               updatedRect.Y =  originalRect.Y;
               
               // decide to snap the start location to grid ...
               //
               if (dragRect.X != originalRect.X) {
                   updatedRect.X  = (dragRect.X / gridSize.Width) * gridSize.Width;
                   
                   // Snap the location to the grid point closest to the dragRect location
                   //
                   if (dragRect.X - updatedRect.X > halfGrid.X) {
                       updatedRect.X += gridSize.Width;
                   }
               }
               
               if (dragRect.Y != originalRect.Y) {
                   updatedRect.Y  = (dragRect.Y / gridSize.Height) * gridSize.Height;
                   
                   // Snap the location to the grid point closest to the dragRect location
                   //
                   if (dragRect.Y - updatedRect.Y > halfGrid.Y) {
                       updatedRect.Y += gridSize.Height;
                   }
               }
               
               // here, we need to calculate the new size depending on how we snap to the grid ...
               //
               if (updateSize) {
                    // update the width and the height
                    //
                    updatedRect.Width = ((dragRect.X + dragRect.Width) / gridSize.Width) * gridSize.Width - updatedRect.X;
                    updatedRect.Height = ((dragRect.Y + dragRect.Height) / gridSize.Height) * gridSize.Height - updatedRect.Y;

                    // ASURT 71552 <subhag> Added so that if the updated dimnesion is smaller than grid dimension then snap that dimension to
                    // the grid dimension
                    //
                    if (updatedRect.Width < gridSize.Width) 
                        updatedRect.Width = gridSize.Width;
                    if (updatedRect.Height < gridSize.Height)
                        updatedRect.Height = gridSize.Height;
               }
           }
           else {
               updatedRect = dragRect;
           }
           
           return updatedRect;
        }

        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.HookTimeout"]/*' />
        /// <devdoc>
        ///     Starts the timer to check for the container selector timeout
        /// </devdoc>
        private void HookTimeout() {
#if DEBUG
            if (containerSelectSwitch.TraceVerbose) Debug.WriteLine("CONTAINERSELECT", "CONTAINERSELECT: hook timeout");
#endif
            if (!waitingForTimeout) {
                NativeMethods.SetTimer(Control.Handle, ContainerSelectorTimerId, 1000, null);
                waitingForTimeout = true;
            }
        }

        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.Initialize"]/*' />
        /// <devdoc>
        ///     Initializes the designer with the given component.  The designer can
        ///     get the component's site and request services from it in this call.
        /// </devdoc>
        public override void Initialize(IComponent component) {
            base.Initialize(component);

            // The designer provides the selection UI handler for its children,
            // so we hook an event on the control so we can tell when it gets some
            // children added.
            //
            Control.ControlAdded += new ControlEventHandler(this.OnChildControlAdded);
            Control.ControlRemoved += new ControlEventHandler(this.OnChildControlRemoved);

            EnableDragDrop(true);
            dragHandler = new ParentControlSelectionUIHandler(this);
            
            // Hook load events.  At the end of load, we need to do a scan through all
            // of our child controls to see which ones are being inherited.  We 
            // connect these up.
            //
            IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
            if (host != null) {
                host.LoadComplete += new EventHandler(this.OnLoadComplete);
                componentChangeSvc = (IComponentChangeService)host.GetService(typeof(IComponentChangeService));
                if (componentChangeSvc != null) {
                    componentChangeSvc.ComponentRemoving += new ComponentEventHandler(this.OnComponentRemoving);
                    componentChangeSvc.ComponentRemoved += new ComponentEventHandler(this.OnComponentRemoved);
                }
            }
        }
        
        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.IsOptionDefault"]/*' />
        /// <devdoc>
        ///     Checks if an option has the default value
        /// </devdoc>
        private bool IsOptionDefault(string optionName, object value) {
            IDesignerOptionService optSvc = (IDesignerOptionService)GetService(typeof(IDesignerOptionService));

            object defaultValue = null;

            if (optSvc == null) {
                if (optionName.Equals("ShowGrid")) {
                    defaultValue = true;
                }
                else if (optionName.Equals("SnapToGrid")) {
                    defaultValue = true;
                }
                else if (optionName.Equals("GridSize")) {
                    defaultValue = new Size(8,8);
                }
            }
            else {
                defaultValue = optSvc.GetOptionValue("WindowsFormsDesigner\\General", optionName);
            }

            if (defaultValue != null) {
                return defaultValue.Equals(value);
            }
            else {
                return value == null;
            }
        }

        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.OnChildControlAdded"]/*' />
        /// <devdoc>
        ///      This is called by Control when a new child control has
        ///      been added.  Here we establish the selection UI handler
        ///      for the child control.
        /// </devdoc>
        private void OnChildControlAdded(object sender, ControlEventArgs e) {

            ISelectionUIService selectionUISvc = (ISelectionUIService)GetService(typeof(ISelectionUIService));
            Debug.Assert(selectionUISvc != null, "Unable to get selection ui service when adding child control");

            if (selectionUISvc != null) {
                IComponent component = e.Control;
                if (component.Site == null || !component.Site.DesignMode) {
                    component = GetComponentForControl(e.Control);
                }
                
                if (component != null) {
                    selectionUISvc.AssignSelectionUIHandler(component, this);
                }
            }
        }
        
        private void OnChildControlRemoved(object sender, ControlEventArgs e) {

            ISelectionUIService selectionUISvc = (ISelectionUIService)GetService(typeof(ISelectionUIService));
            Debug.Assert(selectionUISvc != null, "Unable to get selection ui service when adding child control");

            if (selectionUISvc != null) {
                IComponent component = e.Control;
                if (component.Site == null || !component.Site.DesignMode) {
                    component = GetComponentForControl(e.Control);
                }
                
                if (component != null) {
                    selectionUISvc.ClearSelectionUIHandler(component, this);
                }
            }
        }
        
        
        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.OnComponentRemoving"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void OnComponentRemoving(object sender, ComponentEventArgs e) {
            Control comp = e.Component as Control;
            if (comp != null && comp.Parent == Control) {
                pendingRemoveControl = (Control)comp;
                componentChangeSvc.OnComponentChanging(Control, TypeDescriptor.GetProperties(Control)["Controls"]);        
            }
        }
        
        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.OnComponentRemoved"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void OnComponentRemoved(object sender, ComponentEventArgs e) {
            if (e.Component == pendingRemoveControl) {
                pendingRemoveControl = null;
                componentChangeSvc.OnComponentChanged(Control, TypeDescriptor.GetProperties(Control)["Controls"], null, null);
            }
        }


        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.OnContainerSelectorActive"]/*' />
        /// <devdoc>
        ///      Called when the container selector has been activated.  The container selector will
        ///      notify us when interesting things occur, such as when the user right clicks on the
        ///      container selector.  Here we pop up our context menu.
        /// </devdoc>
        private void OnContainerSelectorActive(object sender, ContainerSelectorActiveEventArgs e) {
            if (e.Component == Component) {
#if DEBUG
                if (containerSelectSwitch.TraceVerbose) Debug.WriteLine("CONTAINERSELECT", "Selector active... reseting timeout");
#endif
                ResetTimeout();

                if (e.EventType == ContainerSelectorActiveEventArgsType.Contextmenu) {
                    Point cur = Control.MousePosition;
                    OnContextMenu(cur.X, cur.Y);
                }
            }
        }

        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.OnContainerSelectorTimeout"]/*' />
        /// <devdoc>
        ///     Called in response to the timeout on the container selector displayer. When
        ///     the timeout occurs, we want to hide the selector. However, since the mouse can
        ///     be resting on the selector, we want to not hide the selector when that occurs.
        /// </devdoc>
        private void OnContainerSelectorTimeout() {
            UnhookTimeout();
            if (Component == null) {
                return;
            }

#if DEBUG
            if (containerSelectSwitch.TraceVerbose) Debug.WriteLine("CONTAINERSELECT", "CONTAINERSELECT: selector timeout");
#endif
            ISelectionUIService selUI = (ISelectionUIService)GetService(typeof(ISelectionUIService));
            if (selUI != null && selUI.GetContainerSelected(Component)) {

                if (!selUI.GetAdornmentHitTest(Component, Control.MousePosition)) {
#if DEBUG
                    if (containerSelectSwitch.TraceVerbose) Debug.WriteLine("CONTAINERSELECT", "CONTAINERSELECT: remove container selection");
#endif
                    selUI.SetContainerSelected(Component, false);
                    selUI.ContainerSelectorActive -= new ContainerSelectorActiveEventHandler(this.OnContainerSelectorActive);
                }
                else {
                    HookTimeout();
                }
            }
        }

        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.OnDragDrop"]/*' />
        /// <devdoc>
        ///      Called in response to a drag drop for OLE drag and drop.  Here we
        ///      drop a toolbox component on our parent control.
        /// </devdoc>
        protected override void OnDragDrop(DragEventArgs de) {

            // pass the message on through if we need to.
            //
            if (parentDraggingHandler != null) {
                parentDraggingHandler.OleDragDrop(de);

                // ASURT 19433 -- if we've done a drop, clear the handler
                parentDraggingHandler = null;
                return;
            }

            if (mouseDragTool != null) {
                IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
                if (host != null) {
                    host.Activate();
                }
                try {
                    CreateTool(mouseDragTool, new Point(de.X, de.Y));
                }
                catch (Exception e) {
                    DisplayError(e);
                }
                return;
            }
            GetOleDragHandler().DoOleDragDrop(de);
        }

        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.OnDragEnter"]/*' />
        /// <devdoc>
        ///      Called in response to a drag enter for OLE drag and drop.
        /// </devdoc>
        protected override void OnDragEnter(DragEventArgs de) {
            Debug.Assert(parentDraggingHandler == null, "Huh?  How do we have a child on a drag enter?");

            // If tab order UI is being shown, then don't allow anything to be
            // dropped here.
            //
            IMenuCommandService ms = (IMenuCommandService)GetService(typeof(IMenuCommandService));
            if (ms != null) {
                MenuCommand tabCommand = ms.FindCommand(StandardCommands.TabOrder);
                if (tabCommand != null && tabCommand.Checked) {
                    de.Effect = DragDropEffects.None;
                    return;
                }
            }            

            // Get the objects that are being dragged
            //
            OleDragDropHandler ddh = GetOleDragHandler();
            Object[] dragComps = ddh.GetDraggingObjects(de);
            Control  draggedControl = null;
            object draggedDesigner = null;

            IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
            if (host != null) {
                object parentDesigner = host.GetDesigner(host.RootComponent);
                if (parentDesigner != null && parentDesigner is DocumentDesigner) {
                    if (!((DocumentDesigner)parentDesigner).CanDropComponents(de)) {
                        de.Effect = DragDropEffects.None;
                        return;
                    }
                }
            }            

            // if any of these objects are the parent of this object,
            // we need to fake the parents into thinking that they are still
            // dragging around or else we could drop a parent into it's
            // child and create an invalid parent-child relation.
            //
            if (dragComps != null) {
                for (int  i = 0; i < dragComps.Length; i++) {
                    if (host == null || dragComps[i] == null || !(dragComps[i] is IComponent)) {
                        continue;
                    }


                    // try go get the control for the thing that's being dragged
                    //
                    draggedDesigner = host.GetDesigner((IComponent)dragComps[i]);

                    if (draggedDesigner is IOleDragClient) {
                        draggedControl = ((IOleDragClient)this).GetControlForComponent(dragComps[i]);
                    }
                    
                    if (draggedControl == null && dragComps[i] is Control) {
                        draggedControl = (Control)dragComps[i];
                    }
                    else {
                        draggedControl = null;
                    }

                    // oh well, it's not a control so it doesn't matter
                    //
                    if (draggedControl == null) {
                        continue;
                    }

                    // If we're inheriting from a private container, we can't modify the controls collection.
                    // So drag-drop is only allowed within the container i.e. the dragged controls must already
                    // be parented to this container.
                    //
                    if (InheritanceAttribute == InheritanceAttribute.InheritedReadOnly && draggedControl.Parent != this.Control) {
                        de.Effect = DragDropEffects.None;
                        return;
                    }

                    // if the control we're dragging is a parent of this control, we will just forward
                    // all of the messages down to the control that owns the drag...which is the
                    // parent of the control that's being dragged.  Easy, huh?
                    //
                    if (draggedControl.Contains(this.Control)) {

                        // get the parent of the control that's being dragged
                        draggedControl = draggedControl.Parent;
                        Debug.Assert(draggedControl != null, "draggedControl has no parent");

                        // bad mojo here...
                        if (draggedControl == null) {
                            continue;
                        }

                        // get the designer of the parent and pass the message on through...
                        draggedDesigner = host.GetDesigner(draggedControl);
                        if (draggedDesigner is ISelectionUIHandler) {
                            parentDraggingHandler = (ISelectionUIHandler)draggedDesigner;
                            parentDraggingHandler.OleDragEnter(de);
                            return;
                        }
                    }
                }
            }

            if (toolboxService == null) {
                toolboxService = (IToolboxService)GetService(typeof(IToolboxService));
            }
            
            if (toolboxService != null) {
                mouseDragTool = toolboxService.DeserializeToolboxItem(de.Data, host);
                
                if (mouseDragTool != null) {
                
                    if (host != null) {
                        host.Activate();
                    }
    
                    Debug.Assert(0 != (int)(de.AllowedEffect & (DragDropEffects.Move | DragDropEffects.Copy)), "DragDropEffect.Move | .Copy isn't allowed?");
                    if ((int)(de.AllowedEffect & DragDropEffects.Move) != 0) {
                        de.Effect = DragDropEffects.Move;
                    }
                    else {
                        de.Effect = DragDropEffects.Copy;
                    }
    
                    // Also, select this parent control to indicate it will be the drop target.
                    //
                    ISelectionService sel = (ISelectionService)GetService(typeof(ISelectionService));
                    if (sel != null) {
                        sel.SetSelectedComponents(new object[] {Component}, SelectionTypes.Replace);
                    }
                }
            }

            if (mouseDragBase == InvalidPoint) {
                GetOleDragHandler().DoOleDragEnter(de);
            }
        }

        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.OnDragLeave"]/*' />
        /// <devdoc>
        ///     Called when a drag-drop operation leaves the control designer view
        ///
        /// </devdoc>
        protected override void OnDragLeave(EventArgs e) {
            mouseDragTool = null;
            
            // pass the message on through if we need to.
            //
            if (parentDraggingHandler != null) {
                parentDraggingHandler.OleDragLeave();
                parentDraggingHandler = null;
                return;
            }

            GetOleDragHandler().DoOleDragLeave();
        }

        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.OnDragOver"]/*' />
        /// <devdoc>
        ///     Called when a drag drop object is dragged over the control designer view
        /// </devdoc>
        protected override void OnDragOver(DragEventArgs de) {
            Debug.WriteLineIf(CompModSwitches.DragDrop.TraceInfo, "\tParentControlDesigner.OnDragOver: " + de.ToString());

            // If tab order UI is being shown, then don't allow anything to be
            // dropped here.
            //
            IMenuCommandService ms = (IMenuCommandService)GetService(typeof(IMenuCommandService));
            Debug.Assert(ms != null, "No menu command service");
            if (ms != null) {
                MenuCommand tabCommand = ms.FindCommand(StandardCommands.TabOrder);
                Debug.Assert(tabCommand != null, "Missing tab order command");
                if (tabCommand != null && tabCommand.Checked) {
                    de.Effect = DragDropEffects.None;
                    return;
                }
            }

            IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
            if (host != null) {
                object parentDesigner = host.GetDesigner(host.RootComponent);
                if (parentDesigner != null && parentDesigner is DocumentDesigner) {
                    if (!((DocumentDesigner)parentDesigner).CanDropComponents(de)) {
                        de.Effect = DragDropEffects.None;
                        return;
                    }
                }
            }

            // pass the message on through if we need to.
            //
            if (parentDraggingHandler != null) {
                parentDraggingHandler.OleDragOver(de);
                return;
            }

            if (mouseDragTool != null) {
                Debug.Assert(0!=(int)(de.AllowedEffect & DragDropEffects.Copy), "DragDropEffect.Move isn't allowed?");
                de.Effect = DragDropEffects.Copy;
                return;
            }

            Debug.WriteLineIf(CompModSwitches.DragDrop.TraceInfo, "\tParentControlDesigner.OnDragOver: " + de.ToString());
            GetOleDragHandler().DoOleDragOver(de);
        }


        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.OnGiveFeedback"]/*' />
        /// <devdoc>
        ///      Event handler for our GiveFeedback event, which is called when a drag operation
        ///      is in progress.  The host will call us with
        ///      this when an OLE drag event happens.
        /// </devdoc>
        protected override void OnGiveFeedback(GiveFeedbackEventArgs e) {
            GetOleDragHandler().DoOleGiveFeedback(e);
        }
        
        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.OnLoadComplete"]/*' />
        /// <devdoc>
        ///     Called after our load finishes.
        /// </devdoc>
        private void OnLoadComplete(object sender, EventArgs e) {

            // If our control is being inherited, then scan our children and hook them to our
            // UI handler.  Only do this for child controls that are also inherited.
            //
            Control control = Control;
            IContainer container = Component.Site.Container;

            ISelectionUIService selectionUISvc = (ISelectionUIService)GetService(typeof(ISelectionUIService));
            Debug.Assert(selectionUISvc != null, "Unable to get selection ui service when adding child control");

            if (selectionUISvc != null) {
                foreach(Control child in control.Controls) {
                    Debug.Assert(child != null, "Null child embeded in array!! Parent: " + control.GetType().FullName + "[" + control.Text + "]");

                    if (child.Site == null || child.Site.Container != container) {
                        continue;
                    }

                    if (TypeDescriptor.GetAttributes(child)[typeof(InheritanceAttribute)].Equals(InheritanceAttribute.NotInherited)) {
                        continue;
                    }

                    // We pass all our inspections.  Add this child to the selection UI handler.
                    //
                    selectionUISvc.AssignSelectionUIHandler(child, this);
                }
            }
        }

        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.OnMouseDragBegin"]/*' />
        /// <devdoc>
        ///     Called in response to the left mouse button being pressed on a
        ///     component.  The designer overrides this to provide a
        ///     "lasso" selection for components within the control.
        /// </devdoc>
        protected override void OnMouseDragBegin(int x, int y) {
            Control control = Control;

            // Figure out the drag frame style.  We use a dotted line for selecting
            // a component group, and a thick line for creating a new component.
            // If we are a privately inherited component, then we always use the
            // selection frame because we can't add components.
            //
            if (!InheritanceAttribute.Equals(InheritanceAttribute.InheritedReadOnly)) {
                if (toolboxService == null) {
                    toolboxService = (IToolboxService)GetService(typeof(IToolboxService));
                }

                if (toolboxService != null) {
                    mouseDragTool = toolboxService.GetSelectedToolboxItem((IDesignerHost)GetService(typeof(IDesignerHost)));
                }
            }

            // Set the mouse capture and clipping to this control.
            //
            control.Capture = true;
            Rectangle bounds;
            NativeMethods.RECT winRect = new NativeMethods.RECT();
            NativeMethods.GetWindowRect(control.Handle, ref winRect);
            bounds = Rectangle.FromLTRB(winRect.left, winRect.top, winRect.right, winRect.bottom);
            Cursor.Clip = bounds;

            mouseDragFrame = (mouseDragTool == null) ? FrameStyle.Dashed : FrameStyle.Thick;

            // Setting this non-null signifies that we are dragging with the
            // mouse.
            //
            mouseDragBase = new Point(x, y);

            // Select the given object.
            //
            ISelectionService selsvc = (ISelectionService)GetService(typeof(ISelectionService));

            if (selsvc != null) {
                selsvc.SetSelectedComponents(new object[] {Component}, SelectionTypes.Click);
            }

            // Get the event handler service.  We push a handler to handle the escape
            // key.
            //
            IEventHandlerService eventSvc = (IEventHandlerService)GetService(typeof(IEventHandlerService));
            if (eventSvc != null) {
                escapeHandler = new EscapeHandler(this);
                eventSvc.PushHandler(escapeHandler);
            }
        }

        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.OnMouseDragEnd"]/*' />
        /// <devdoc>
        ///     Called at the end of a drag operation.  This either commits or rolls back the
        ///     drag.
        /// </devdoc>
        protected override void OnMouseDragEnd(bool cancel) {
            // Do nothing if we're not dragging anything around
            //
            if (mouseDragBase == InvalidPoint) {
                // make sure we force the drag end
                base.OnMouseDragEnd(cancel);
                return;
            }

            // Important to null these out here, just in case we throw an exception
            //
            Rectangle   offset    = mouseDragOffset;
            ToolboxItem tool      = mouseDragTool;
            Point       baseVar   = mouseDragBase;

            mouseDragOffset = Rectangle.Empty;
            mouseDragBase = InvalidPoint;
            mouseDragTool = null;

            Control.Capture = false;
            Cursor.Clip = Rectangle.Empty;

            // Get the event handler service and pop our handler.
            //
            IEventHandlerService eventSvc = (IEventHandlerService)GetService(typeof(IEventHandlerService));
            if (eventSvc != null) {
                eventSvc.PopHandler(escapeHandler);
                escapeHandler = null;
            }

            // Quit now if we don't have an offset rect.  This indicates that
            // the user didn't move the mouse.
            //
            if (offset.IsEmpty) {
                // BUT, if we have a selected tool, create it here
                if (tool != null) {
                    try {
                        CreateTool(tool, baseVar);
                        if (toolboxService != null) {
                            toolboxService.SelectedToolboxItemUsed();
                        }
                    }
                    catch (Exception e) {
                        DisplayError(e);
                    }
                }
                return;
            }

            // Clear out the drag frame.
            //
            Control control = (Control)Control;
            ControlPaint.DrawReversibleFrame(offset, control.BackColor, mouseDragFrame);

            // Don't do anything else if the user wants to cancel.
            //
            if (cancel) {
                return;
            }

            // Do we select components, or do we create a new component?
            //
            if (tool != null) {
                try {
                    CreateTool(tool, offset);
                    if (toolboxService != null) {
                        toolboxService.SelectedToolboxItemUsed();
                    }
                }
                catch (Exception e) {
                    DisplayError(e);
                }
            }
            else {
                // Now find the set of controls within this offset and
                // select them.
                //
                ISelectionService selSvc = null;
                selSvc = (ISelectionService)GetService(typeof(ISelectionService));
                if (selSvc != null) {
                    object[] selection = GetComponentsInRect(offset, true);
                    if (selection.Length > 0) {
                        selSvc.SetSelectedComponents(selection);
                    }
                }
            }
        }

        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.OnMouseDragMove"]/*' />
        /// <devdoc>
        ///     Called for each movement of the mouse.  This will check to see if a drag operation
        ///     is in progress.  If so, it will pass the updated drag dimensions on to the selection
        ///     UI service.
        /// </devdoc>
        protected override void OnMouseDragMove(int x, int y) {
            // if we're doing an OLE drag, do nothing, or
            // Do nothing if we haven't initiated a drag
            //
            if (GetOleDragHandler().Dragging || mouseDragBase == InvalidPoint) {
                return;
            }

            Control control = (Control)Control;
            Color backColor = control.BackColor;

            // The first time we come in here our offset will be null.
            //
            if (!mouseDragOffset.IsEmpty) {
                ControlPaint.DrawReversibleFrame(mouseDragOffset, backColor, mouseDragFrame);
            }

            // Calculate the new offset.
            //
            mouseDragOffset.X = mouseDragBase.X;
            mouseDragOffset.Y = mouseDragBase.Y;
            mouseDragOffset.Width = x - mouseDragBase.X;
            mouseDragOffset.Height = y - mouseDragBase.Y;

            if (mouseDragOffset.Width < 0) {
                mouseDragOffset.X += mouseDragOffset.Width;
                mouseDragOffset.Width = -mouseDragOffset.Width;
            }
            if (mouseDragOffset.Height < 0) {
                mouseDragOffset.Y += mouseDragOffset.Height;
                mouseDragOffset.Height = -mouseDragOffset.Height;
            }

            // If we're dragging out a new component, update the drag rectangle
            // to use snaps, if they're set.
            //
            if (mouseDragTool != null) {
                // To snap properly, we must snap in client coordinates.  So, convert, snap
                // and re-convert.
                //
                mouseDragOffset = control.RectangleToClient(mouseDragOffset);
                mouseDragOffset = GetUpdatedRect(Rectangle.Empty, mouseDragOffset, true);
                mouseDragOffset = control.RectangleToScreen(mouseDragOffset);
            }

            // And draw the new drag frame
            //
            ControlPaint.DrawReversibleFrame(mouseDragOffset, backColor, mouseDragFrame);
        }

        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.OnMouseEnter"]/*' />
        /// <devdoc>
        ///     Called when the mouse enters the control. At this point we want to cancel the timeout
        ///     timer.
        /// </devdoc>
        protected override void OnMouseEnter() {
            if (Component == null) {
                return;
            }

#if DEBUG
            if (containerSelectSwitch.TraceVerbose) Debug.WriteLine("CONTAINERSELECT", "CONTAINERSELECT: mouse enter");
#endif
            UnhookTimeout();
        }

        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.OnMouseHover"]/*' />
        /// <devdoc>
        ///     Called when the user hovers over the control. At this point we want to display the
        ///     container selector. Note: Since the child controls pass this notification up, we
        ///     will display the container selector even if you hover over a child control.
        /// </devdoc>
        protected override void OnMouseHover() {
            if (Component == null) {
                return;
            }

#if DEBUG
            if (containerSelectSwitch.TraceVerbose) Debug.WriteLine("CONTAINERSELECT", "CONTAINERSELECT: mouse hover");
#endif
            IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
            IComponent baseComponent = null;
            if (host != null) {
                baseComponent = host.RootComponent;
            }

            if (baseComponent != Component) {
                ISelectionService selection = (ISelectionService)GetService(typeof(ISelectionService));
                ISelectionUIService selUI = (ISelectionUIService)GetService(typeof(ISelectionUIService));
                if (selUI != null && !selUI.GetContainerSelected(Component) && !selection.GetComponentSelected(Component)) {
#if DEBUG
                    if (containerSelectSwitch.TraceVerbose) Debug.WriteLine("CONTAINERSELECT", "CONTAINERSELECT: set container selection");
#endif
                    selUI.SetContainerSelected(Component, true);

                    // Remove first to get rid of any duplicates...
                    //
                    selUI.ContainerSelectorActive -= new ContainerSelectorActiveEventHandler(this.OnContainerSelectorActive);

                    // Add a new handler...
                    //
                    selUI.ContainerSelectorActive += new ContainerSelectorActiveEventHandler(this.OnContainerSelectorActive);
                }
            }
        }

        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.OnMouseLeave"]/*' />
        /// <devdoc>
        ///     Called when the mouse leaves the control. At this point we need to start listening
        ///     for the container selector timeout.
        /// </devdoc>
        protected override void OnMouseLeave() {
            if (Component == null) {
                return;
            }

#if DEBUG
            if (containerSelectSwitch.TraceVerbose) Debug.WriteLine("CONTAINERSELECT", "CONTAINERSELECT: mouse leave");
#endif
            ISelectionUIService selUI = (ISelectionUIService)GetService(typeof(ISelectionUIService));
            if (selUI != null && selUI.GetContainerSelected(Component)) {
#if DEBUG
                if (containerSelectSwitch.TraceVerbose) Debug.WriteLine("CONTAINERSELECT", "CONTAINERSELECT: start timeout");
#endif
                HookTimeout();
            }
        }

        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.OnPaintAdornments"]/*' />
        /// <devdoc>
        ///     Called after our component has finished painting.  Here we draw our grid surface
        /// </devdoc>
        protected override void OnPaintAdornments(PaintEventArgs pe) {
            if (DrawGrid) {
                Control control = (Control)Control;
                
                Rectangle displayRect = Control.DisplayRectangle;
                Rectangle clientRect = Control.ClientRectangle;
                
                Rectangle paintRect = new Rectangle( Math.Min(displayRect.X, clientRect.X), Math.Min(displayRect.Y, clientRect.Y),
                                                     Math.Max(displayRect.Width, clientRect.Width), Math.Max(displayRect.Height, clientRect.Height));

                float xlateX = (float)paintRect.X;
                float xlateY = (float)paintRect.Y;
                pe.Graphics.TranslateTransform(xlateX, xlateY);
                paintRect.X = paintRect.Y = 0;
                paintRect.Width++; // gpr: FillRectangle with a TextureBrush comes up one pixel short
                paintRect.Height++;
                ControlPaint.DrawGrid(pe.Graphics, paintRect, gridSize, control.BackColor);
                pe.Graphics.TranslateTransform(-xlateX, -xlateY);
            }
            base.OnPaintAdornments(pe);
        }

        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.OnSetCursor"]/*' />
        /// <devdoc>
        ///     Called each time the cursor needs to be set.  The ParentControlDesigner behavior here
        ///     will set the cursor to one of three things:
        ///     1.  If the toolbox service has a tool selected, it will allow the toolbox service to
        ///     set the cursor.
        ///     2.  The arrow will be set.  Parent controls allow dragging within their interior.
        /// </devdoc>
        protected override void OnSetCursor() {
            if (toolboxService == null) {
                toolboxService = (IToolboxService)GetService(typeof(IToolboxService));
            }

            if (toolboxService == null || !toolboxService.SetCursor() || InheritanceAttribute.Equals(InheritanceAttribute.InheritedReadOnly)) {
                Cursor.Current = Cursors.Default;
            }
        }

        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.PreFilterProperties"]/*' />
        /// <devdoc>
        ///      Allows a designer to filter the set of properties
        ///      the component it is designing will expose through the
        ///      TypeDescriptor object.  This method is called
        ///      immediately before its corresponding "Post" method.
        ///      If you are overriding this method you should call
        ///      the base implementation before you perform your own
        ///      filtering.
        /// </devdoc>
        protected override void PreFilterProperties(IDictionary properties) {
            base.PreFilterProperties(properties);

            properties["DrawGrid"] = TypeDescriptor.CreateProperty(typeof(ParentControlDesigner), "DrawGrid", typeof(bool),
                                                          BrowsableAttribute.Yes,
                                                          DesignOnlyAttribute.Yes,
                                                          new SRDescriptionAttribute("ParentControlDesignerDrawGridDescr"),
                                                          CategoryAttribute.Design);

            properties["SnapToGrid"] = TypeDescriptor.CreateProperty(typeof(ParentControlDesigner), "SnapToGrid", typeof(bool),
                                                            BrowsableAttribute.Yes,
                                                            DesignOnlyAttribute.Yes,
                                                            new SRDescriptionAttribute("ParentControlDesignerSnapToGridDescr"),
                                                            CategoryAttribute.Design);

            properties["GridSize"] = TypeDescriptor.CreateProperty(typeof(ParentControlDesigner), "GridSize", typeof(Size),
                                                          BrowsableAttribute.Yes,
                                                          new SRDescriptionAttribute(SR.ParentControlDesignerGridSizeDescr),
                                                          DesignOnlyAttribute.Yes,
                                                          CategoryAttribute.Design);

            properties["CurrentGridSize"] = TypeDescriptor.CreateProperty(typeof(ParentControlDesigner), "CurrentGridSize", typeof(Size),
                                                                 BrowsableAttribute.No,
                                                                 DesignerSerializationVisibilityAttribute.Hidden);
        }

        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.ResetTimeout"]/*' />
        /// <devdoc>
        ///     Resets the timeout for the container selector, if we are listening for it.
        /// </devdoc>
        private void ResetTimeout() {
            if (waitingForTimeout) {
                UnhookTimeout();
                HookTimeout();
            }
        }
       
        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.SetCursor"]/*' />
        /// <devdoc>
        ///     Asks the handler to set the appropriate cursor
        /// </devdoc>
        internal void SetCursor() {
            OnSetCursor();
        }

        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.ShouldSerializeDrawGrid"]/*' />
        /// <devdoc>
        ///     Determines if the DrawGrid property should be persisted.
        /// </devdoc>
        private bool ShouldSerializeDrawGrid() {
            //To determine if we need to persist this value, we first need to check
            //if we have a parent who is a parentcontroldesigner, then get their 
            //setting...
            //
            ParentControlDesigner parent = GetParentControlDesignerOfParent();
            if (parent != null) {
                return !(DrawGrid == parent.DrawGrid);
            }
            //Otherwise, we'll compare the value to the options page...
            //
            return !IsOptionDefault("ShowGrid", this.DrawGrid);
        }

        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.ShouldSerializeSnapToGrid"]/*' />
        /// <devdoc>
        ///     Determines if the SnapToGrid property should be persisted.
        /// </devdoc>
        private bool ShouldSerializeSnapToGrid() {
            //To determine if we need to persist this value, we first need to check
            //if we have a parent who is a parentcontroldesigner, then get their 
            //setting...
            //
            ParentControlDesigner parent = GetParentControlDesignerOfParent();
            if (parent != null) {
                return !(SnapToGrid == parent.SnapToGrid);
            }
            //Otherwise, we'll compare the value to the options page...
            //
            return !IsOptionDefault("SnapToGrid", this.SnapToGrid);
        }

        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.ShouldSerializeGridSize"]/*' />
        /// <devdoc>
        ///     Determines if the GridSize property should be persisted.
        /// </devdoc>
        private bool ShouldSerializeGridSize() {
            //To determine if we need to persist this value, we first need to check
            //if we have a parent who is a parentcontroldesigner, then get their 
            //setting...
            //
            ParentControlDesigner parent = GetParentControlDesignerOfParent();
            if (parent != null) {
                return !(GridSize.Equals(parent.GridSize));
            }
            //Otherwise, we'll compare the value to the options page...
            //
            return !IsOptionDefault("GridSize", this.GridSize);
        }

        private void ResetGridSize() {
            //Check to see if the parent is a valid parentcontroldesigner,
            //if so, then reset this value to the parents...
            //
            ParentControlDesigner parent = GetParentControlDesignerOfParent();
            if (parent != null) {
                this.GridSize = parent.GridSize;
                return;
            }
            //Otherwise, just look at our local default grid size...
            //
            this.GridSize = defaultGridSize;
        }
        
        private void ResetDrawGrid() {
            //Check to see if the parent is a valid parentcontroldesigner,
            //if so, then reset this value to the parents...
            //
            ParentControlDesigner parent = GetParentControlDesignerOfParent();
            if (parent != null) {
                this.DrawGrid = parent.DrawGrid;
                return;
            }
            //Otherwise, just look at our local default grid size...
            //
            this.DrawGrid = defaultDrawGrid;
        }
        
        private void ResetSnapToGrid() {
            //Check to see if the parent is a valid parentcontroldesigner,
            //if so, then reset this value to the parents...
            //
            ParentControlDesigner parent = GetParentControlDesignerOfParent();
            if (parent != null) {
                this.SnapToGrid = parent.SnapToGrid;
                return;
            }
            //Otherwise, just look at our local default grid size...
            //
            this.SnapToGrid = defaultGridSnap;
        }

        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.UnhookTimeout"]/*' />
        /// <devdoc>
        ///     Cancels the timer to check for the container selector timeout
        /// </devdoc>
        private void UnhookTimeout() {
#if DEBUG
            if (containerSelectSwitch.TraceVerbose) Debug.WriteLine("CONTAINERSELECT", "CONTAINERSELECT: unhook timeout");
#endif
            if (waitingForTimeout) {
                NativeMethods.KillTimer(Control.Handle, ContainerSelectorTimerId);
                waitingForTimeout = false;
            }
        }

        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.WndProc"]/*' />
        /// <devdoc>
        ///     Overrides ControlDesigner's WndProc.
        /// </devdoc>
        protected override void WndProc(ref Message m) {
            switch (m.Msg) {
                case NativeMethods.WM_TIMER:
                    if ((int)m.WParam == ContainerSelectorTimerId) {
                        OnContainerSelectorTimeout();

                        // don't call the base.WndProc...
                        return;
                    }
                    break;
            }
            base.WndProc(ref m);
        }

        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.IOleDragClient.Component"]/*' />
        /// <internalonly/>
        IComponent IOleDragClient.Component {
            get{
                return Component;
            }
        }

        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.IOleDragClient.AddComponent"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Retrieves the control view instance for the designer that
        /// is hosting the drag.
        /// </devdoc>
        bool IOleDragClient.AddComponent(IComponent component, string name, bool firstAdd) {
            IContainer container = Component.Site.Container;
            bool       containerMove = true;
            IContainer oldContainer = null;
            IDesignerHost localDesignerHost = (IDesignerHost)GetService(typeof(IDesignerHost));
            
            if (!firstAdd) {
                
                // just a move, so reparent
                if (component.Site != null) {
    
                    oldContainer = component.Site.Container;
                    
                    // check if there's already a component by this name in the
                    // get the undo service from the parent were deleteing from
                    IDesignerHost designerHost = (IDesignerHost)component.Site.GetService(typeof(IDesignerHost));
                    
                    containerMove = container != oldContainer; 
                    
                    if (containerMove) {
                        oldContainer.Remove(component);
                    }
                }
                if (containerMove) { 
    
                    // check if there's already a component by this name in the
                    // container
                    if (name != null && container.Components[name] != null) {
                        name = null;
                    }
    
                    // add it back
                    if (name != null) {
                        container.Add(component, name);
                    }
                    else {
                        container.Add(component);
                    }
                }
            }

            // make sure this designer will accept this component -- we wait until
            // now to be sure the components designer has been created.
            //
            if (!((IOleDragClient)this).IsDropOk(component)) {

               try {
                   IUIService uiSvc = (IUIService)GetService(typeof(IUIService));
                   string error = SR.GetString(SR.DesignerCantParentType, component.GetType().Name, Component.GetType().Name);
                   if (uiSvc != null) {
                      uiSvc.ShowError(error);
                   }
                   else {
                      MessageBox.Show(error);
                   }
                   return false;
               }
               finally {
                   if (containerMove) {
                       // move it back.
                       container.Remove(component);
                       if (oldContainer != null) {
                           oldContainer.Add(component);
                       }
                   }
               }
            }
            
            // make sure we can handle this thing, otherwise hand it to the base components designer
            //
            Control c = GetControl(component);
            
            if (c != null) {
                
                // set it's handler to this
                Control parent = Control;
            
                if (!(c is Form) || !((Form)c).TopLevel) {
                        
                    if (c.Parent != parent) {
                        PropertyDescriptor controlsProp = TypeDescriptor.GetProperties(parent)["Controls"];
                        // we want to insert rather than add it, so we add then move
                        // to the beginning
                        
                        if (c.Parent != null) {
                            Control cParent = c.Parent;
                            if (componentChangeSvc != null) {
                                componentChangeSvc.OnComponentChanging(cParent, controlsProp);
                            }
                            cParent.Controls.Remove(c);
                            if (componentChangeSvc != null) {
                               componentChangeSvc.OnComponentChanged(cParent, controlsProp, cParent.Controls, cParent.Controls);
                            }
                        }
                        
                        if (componentChangeSvc != null) {
                            componentChangeSvc.OnComponentChanging(parent, controlsProp);
                        }
                        parent.Controls.Add(c);
                        // sburke 78059 -- not sure why we need this call. this should move things to the beginning of the 
                        // z-order, but do we need that?
                        //
                        //parent.Controls.SetChildIndex(c, 0);
                        if (componentChangeSvc != null) {
                           componentChangeSvc.OnComponentChanged(parent, controlsProp, parent.Controls, parent.Controls);
                        }
                    }
                    else {
                        // here, we redo the add to make sure the handlers get setup right
                        int childIndex = parent.Controls.GetChildIndex(c);
                        parent.Controls.Remove(c);
                        parent.Controls.Add(c);
                        parent.Controls.SetChildIndex(c, childIndex);
                    }
                }
                c.Invalidate(true);
            }
            
            if (localDesignerHost != null && containerMove) {
                
                
                // sburke -- looks like we always want to do this to ensure that sited children get
                // handled properly.  if we respected the boolean before, the ui selection handlers
                // would cache designers, handlers, etc. and cause problems.
                IDesigner designer = localDesignerHost.GetDesigner(component);
                if ( designer is ComponentDesigner) {
                     ((ComponentDesigner)designer).InitializeNonDefault();
                }                                   
        
                AddChildComponents(component, container, localDesignerHost,
                                   (ISelectionUIService)GetService(typeof(ISelectionUIService)));
                                   
                
             }
             return true;
        }
        
        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.IOleDragClient.CanModifyComponents"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Checks if the client is read only.  That is, if components can
        /// be added or removed from the designer.
        /// </devdoc>
        bool IOleDragClient.CanModifyComponents {
            get {
                return(!InheritanceAttribute.Equals(InheritanceAttribute.InheritedReadOnly));
            }
        }
        
        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.IOleDragClient.IsDropOk"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Checks if it is valid to drop this type of a component on this client.
        /// </devdoc>
        bool IOleDragClient.IsDropOk(IComponent component) {

            IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
    
            if (host != null) {
                IDesigner designer = host.GetDesigner(component);
                bool disposeDesigner = false;
                
                // we need to create one then
                if (designer == null) {
                    designer = TypeDescriptor.CreateDesigner(component, typeof(IDesigner));
                    designer.Initialize(component);
                    disposeDesigner = true;
                }
               
                try {                    
                   if (designer != null && designer is ControlDesigner) {
                       return ((ControlDesigner)designer).CanBeParentedTo(this) && this.CanParent((ControlDesigner)designer);
                   } 
                }
                finally {
                  if (disposeDesigner) {
                     designer.Dispose();
                  }
                }
            }
            return true;
        }
        
        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.IOleDragClient.GetDesignerControl"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Retrieves the control view instance for the designer that
        /// is hosting the drag.
        /// </devdoc>
        Control IOleDragClient.GetDesignerControl() {
            return Control;
        }

        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.IOleDragClient.GetControlForComponent"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Retrieves the control view instance for the given component.
        /// For Win32 designer, this will often be the component itself.
        /// </devdoc>
        Control IOleDragClient.GetControlForComponent(object component) {
            return GetControl(component);
        }
        
        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.ISelectionUIHandler.BeginDrag"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Begins a drag operation.  A designer should examine the list of components
        /// to see if it wants to support the drag.  If it does, it should return
        /// true.  If it returns true, the designer should provide
        /// UI feedback about the drag at this time.  Typically, this feedback consists
        /// of an inverted rectangle for each component, or a caret if the component
        /// is text.
        /// </devdoc>
        bool ISelectionUIHandler.BeginDrag(object[] components, SelectionRules rules, int initialX, int initialY) {
            Debug.Assert(dragHandler != null, "We should have a drag handler by now");

            // allow the drag handler to setup it's state
            bool result = dragHandler.BeginDrag(components, rules, initialX, initialY);

            if (result) {
                // now do the ole part
                // returning true means we should just act like the regular
                // old operation occurred

                ArrayList disabledDrops = new ArrayList();

                try {
                    // make sure we can't drag into one of the components we're dragging...if we are, turn off our drag drop
                    // or we might drag onto something we're dragging, which is bad bad bad!
                    for (int i = 0; i < components.Length; i++) {
                        Control control = GetControl(components[i]);
                        if (control != null && control.AllowDrop) {
                            control.AllowDrop = false;
                            disabledDrops.Add(control);
                        }
                    }

                    if (GetOleDragHandler().DoBeginDrag(components, rules, initialX, initialY)) {
                        return result;
                    }
                    return false;

                }
                finally {
                    foreach(Control control in disabledDrops) {
                        control.AllowDrop = true;
                    }
                }
            }
            return result;
        }

        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.ISelectionUIHandler.DragMoved"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Called when the user has moved the mouse.  This will only be called on
        /// the designer that returned true from beginDrag.  The designer
        /// should update its UI feedback here.
        /// </devdoc>
        void ISelectionUIHandler.DragMoved(object[] components, Rectangle offset) {
            Debug.Assert(dragHandler != null, "We should have a drag handler by now");
            dragHandler.DragMoved(components, offset);
        }

        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.ISelectionUIHandler.EndDrag"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Called when the user has completed the drag.  The designer should
        /// remove any UI feedback it may be providing.
        /// </devdoc>
        void ISelectionUIHandler.EndDrag(object[] components, bool cancel) {
            Debug.Assert(dragHandler != null, "We should have a drag handler by now");
            dragHandler.EndDrag(components, cancel);

            ISelectionUIService selectionUISvc = (ISelectionUIService)GetService(typeof(ISelectionUIService));
            Debug.Assert(selectionUISvc != null, "Unable to get selection ui service when adding child control");

            if (selectionUISvc != null) {
                // We must check to ensure that UI service is still in drag mode.  It is
                // possible that the user hit escape, which will cancel drag mode.
                //
                if (selectionUISvc.Dragging) {
                    selectionUISvc.EndDrag(cancel);
                }
            }


            GetOleDragHandler().DoEndDrag(components, cancel);
        }

        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.ISelectionUIHandler.GetComponentBounds"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Retrieves the shape of the component.  The component's shape should be in
        /// absolute coordinates and in pixels, where 0,0 is the upper left corner of
        /// the screen.
        /// </devdoc>
        Rectangle ISelectionUIHandler.GetComponentBounds(object component) {
            Rectangle bounds = Rectangle.Empty;

            Control control = GetControl(component);
            
            if (control == null) {
                Debug.Fail("All components we assign to ISelectionUIService should be Controls");
                return bounds;
            }

            Control parent = control.Parent;

            if (parent != null && parent.IsHandleCreated) {
                Rectangle controlBounds = control.Bounds;
                bounds = parent.RectangleToScreen(controlBounds);
            }

            return bounds;
        }

        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.ISelectionUIHandler.GetComponentRules"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Retrieves a set of rules concerning the movement capabilities of a component.
        /// This should be one or more flags from the SelectionRules class.  If no designer
        /// provides rules for a component, the component will not get any UI services.
        /// </devdoc>
        SelectionRules ISelectionUIHandler.GetComponentRules(object component) {

            IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
            if (host != null && component is IComponent) {
                IDesigner designer = host.GetDesigner((IComponent)component);
                Debug.Assert(designer != null, "No designer found for: " + component);
                
                if (designer is ControlDesigner) {
                    return ((ControlDesigner)designer).SelectionRules;
                }
            }
            
            Debug.Fail("All components we assign to ISelectionUIService should be Controls");
            return SelectionRules.None;
        }

        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.ISelectionUIHandler.GetSelectionClipRect"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Determines the rectangle that any selection adornments should be clipped
        /// to. This is normally the client area (in screen coordinates) of the
        /// container.
        /// </devdoc>
        Rectangle ISelectionUIHandler.GetSelectionClipRect(object component) {
            Control container = Control;
            if (component != container && container.IsHandleCreated) {
                Rectangle clipRect = container.RectangleToScreen(container.ClientRectangle);

                //loop through all parents - find the most inner-most rectangle to clip with.
                Control parentCtl = container.Parent;
                while(parentCtl != null) {
                    clipRect.Intersect(parentCtl.RectangleToScreen(parentCtl.ClientRectangle));
                    parentCtl = parentCtl.Parent;
                }
                
                return clipRect;
            }
            return Rectangle.Empty;
        }

        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.ISelectionUIHandler.OleDragEnter"]/*' />
        /// <internalonly/>
        void ISelectionUIHandler.OleDragEnter(DragEventArgs de) {
            // pass the message on through if we need to.
            //
            if (parentDraggingHandler != null) {
                parentDraggingHandler.OleDragEnter(de);
                return;
            }

            OnDragEnter(de);
        }

        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.ISelectionUIHandler.OleDragDrop"]/*' />
        /// <internalonly/>
        void ISelectionUIHandler.OleDragDrop(DragEventArgs de) {

            // pass the message on through if we need to.
            //
            if (parentDraggingHandler != null) {
                parentDraggingHandler.OleDragDrop(de);
                return;
            }

            OnDragDrop(de);
        }

        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.ISelectionUIHandler.OleDragOver"]/*' />
        /// <internalonly/>
        void ISelectionUIHandler.OleDragOver(DragEventArgs de) {

            // pass the message on through if we need to.
            //
            if (parentDraggingHandler != null) {
                parentDraggingHandler.OleDragOver(de);
                return;
            }

            OnDragOver(de);
        }

        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.ISelectionUIHandler.OleDragLeave"]/*' />
        /// <internalonly/>
        void ISelectionUIHandler.OleDragLeave() {

            // pass the message on through if we need to.
            //
            if (parentDraggingHandler != null) {
                parentDraggingHandler.OleDragLeave();
                return;
            }

            OnDragLeave(EventArgs.Empty);
        }

        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.ISelectionUIHandler.OnSelectionDoubleClick"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Handle a double-click on the selection rectangle
        /// of the given component.
        /// </devdoc>
        void ISelectionUIHandler.OnSelectionDoubleClick(IComponent component) {
            ISite site = component.Site;
            if (site != null) {
                IDesignerHost host = (IDesignerHost)site.GetService(typeof(IDesignerHost));
                if (host != null) {
                    IDesigner designer = host.GetDesigner(component);
                    if (designer != null) {
                        designer.DoDefaultAction();
                    }
                }
            }
        }

        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.ISelectionUIHandler.QueryBeginDrag"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Queries to see if a drag operation
        /// is valid on this handler for the given set of components.
        /// If it returns true, BeginDrag will be called immediately after.
        /// </devdoc>
        bool ISelectionUIHandler.QueryBeginDrag(object[] components, SelectionRules rules, int initialX, int initialY) {
            return dragHandler.QueryBeginDrag(components, rules, initialX, initialY);
        }

        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.ISelectionUIHandler.ShowContextMenu"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Shows the context menu for the given component.
        /// </devdoc>
        void ISelectionUIHandler.ShowContextMenu(IComponent component) {
            Point cur = Control.MousePosition;
            OnContextMenu(cur.X, cur.Y);
        }

        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.ControlOleDragDropHandler"]/*' />
        /// <devdoc>
        ///     This is our version of a drag drop handler.  Our version handles placement of controls when creating them.
        /// </devdoc>
        private class ControlOleDragDropHandler : OleDragDropHandler {
            private ParentControlDesigner designer;

            public ControlOleDragDropHandler(SelectionUIHandler selectionHandler,  IServiceProvider  serviceProvider, ParentControlDesigner designer) : 
            base(selectionHandler, serviceProvider, designer) {
                this.designer = designer;
            }

            /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.ControlOleDragDropHandler.OnInitializeComponent"]/*' />
            /// <devdoc>
            ///     This is called by the drag drop handler for each new tool that is created.  It gives us a chance to
            ///     place the control on the correct designer.
            /// </devdoc>
            protected override void OnInitializeComponent(IComponent comp, int x, int y, int width, int height, bool hasLocation, bool hasSize) {
                base.OnInitializeComponent(comp, x, y, width, height, hasLocation, hasSize);

                // If this component doesn't have a control designer, or if this control
                // is top level, then ignore it.  We have the reverse logic in OnComponentAdded
                // in the document designer so that we will add those guys to the tray.
                //
                bool addControl = false;
                IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));

                if (host != null) {
                    IDesigner designer = host.GetDesigner(comp);
                    if (designer is ControlDesigner) {
                        ControlDesigner cd = (ControlDesigner)designer;
                        if (!(cd.Control is Form) || !((Form)cd.Control).TopLevel) {
                            addControl = true;
                        }
                    }
                }

                if (addControl) {
                    Rectangle bounds = new Rectangle();
                    Control   parentControl = designer.Control;

                    // If we were provided with a location, convert it to parent control coordinates.
                    // Otherwise, get the control's size and put the location in the middle of it
                    //
                    if (hasLocation) {
                        Point pt = new Point(x, y);
                        pt = parentControl.PointToClient(pt);
                        bounds.X = pt.X;
                        bounds.Y = pt.Y;
                    }
                    else {

                        // is the currently selected control this container?
                        //
                        ISelectionService   selSvc = (ISelectionService)GetService(typeof(ISelectionService));
                        object primarySelection = selSvc.PrimarySelection;
                        Control selectedControl = ((IOleDragClient)designer).GetControlForComponent(primarySelection);

                        // If the resulting control that came back isn't sited, it's not part of the
                        // design surface and should not be used as a marker.
                        //
                        if (selectedControl != null && selectedControl.Site == null) {
                            selectedControl = null;
                        }

                        // if the currently selected container is this parent
                        // control, default to 0,0
                        //
                        if (primarySelection == designer.Component || selectedControl == null) {
                            bounds.X = designer.DefaultControlLocation.X;
                            bounds.Y = designer.DefaultControlLocation.Y;
                        }
                        else {
                            // otherwise offset from selected control.
                            //
                            bounds.X = selectedControl.Location.X + designer.GridSize.Width;
                            bounds.Y = selectedControl.Location.Y + designer.GridSize.Height;
                        }

                    }

                    // If we were not given a size, ask the control for its default.  We
                    // also update the location here so the control is in the middle of
                    // the user's point, rather than at the edge.
                    //
                    if (hasSize) {
                        bounds.Width = width;
                        bounds.Height = height;
                    }
                    else {
                        Size size = designer.GetDefaultSize(comp);
                        bounds.Width = size.Width;
                        bounds.Height = size.Height;
                    }

                    // If we were given neither, center the control
                    //
                    if (!hasSize && !hasLocation) {

                        // get the adjusted location, then inflate
                        // the rect so we can find a nice spot
                        // for this control to live.
                        //
                        Rectangle tempBounds = designer.GetAdjustedSnapLocation(Rectangle.Empty, bounds);

                        // compute the stacking location
                        //
                        tempBounds = designer.GetControlStackLocation(tempBounds);   
                        bounds = tempBounds;
                    }
                    else {
                        // Finally, convert the bounds to the appropriate grid snaps
                        //
                        bounds = designer.GetAdjustedSnapLocation(Rectangle.Empty, bounds);
                    }

                    // Now see if the control has size and location properties.  Update
                    // these values if it does.
                    //
                    PropertyDescriptorCollection props = TypeDescriptor.GetProperties(comp);
                    PropertyDescriptor prop = props["Location"];
                    if (prop != null) {
                        prop.SetValue(comp, new Point(bounds.X, bounds.Y));
                    }

                    prop = props["Size"];
                    if (prop != null) {
                        prop.SetValue(comp, new Size(bounds.Width, bounds.Height));
                    }

                    // Parent the control to the designer and set it to the front.
                    //
                    Control control = (Control)comp;
                    
                    
                    PropertyDescriptor controlsProp = TypeDescriptor.GetProperties(parentControl)["Controls"];
                    if (designer.componentChangeSvc != null) {
                        designer.componentChangeSvc.OnComponentChanging(parentControl, controlsProp);
                    }
                    
                    parentControl.Controls.Add(control);

                    if (control.Left == 0 && control.Top == 0 && control.Width >= parentControl.Width && control.Height >= parentControl.Height) {
                        // bump the control down one gridsize just so it's selectable...
                        // 
                        Point loc = control.Location;
                        Size gridSize = designer.GridSize;
                        
                        loc.Offset(gridSize.Width, gridSize.Height);
                        control.Location = loc;
                    }
                    
                    if (designer.componentChangeSvc != null) {
                       designer.componentChangeSvc.OnComponentChanged(parentControl, controlsProp, parentControl.Controls, parentControl.Controls);
                    }
                    
                    // ASURT 78699 -- only bring the new control as far forward as the last inherited control ... we can't
                    // go in front of that because the base class AddRange will happen before us so we'll always be added
                    // under them.
                    //
                    int bestIndex = 0;
                    for (bestIndex = 0; bestIndex < parentControl.Controls.Count - 1; bestIndex++) {

                        Control child = parentControl.Controls[bestIndex];

                        if (child.Site == null) {
                            continue;
                        }

                        InheritanceAttribute inheritanceAttribute = (InheritanceAttribute)TypeDescriptor.GetAttributes(child)[typeof(InheritanceAttribute)];
                        InheritanceLevel inheritanceLevel = InheritanceLevel.NotInherited;
                        
                        if (inheritanceAttribute != null) {
                            inheritanceLevel = inheritanceAttribute.InheritanceLevel;
                        }

                        if (inheritanceLevel == InheritanceLevel.NotInherited) {
                            break;
                        }
                    }
                    parentControl.Controls.SetChildIndex(control, bestIndex);
                    control.Update();
                }
            }
        }

        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.EscapeHandler"]/*' />
        /// <devdoc>
        ///      This class overrides the escape command so that we can escape
        ///      out of our private drags.
        /// </devdoc>
        private class EscapeHandler : IMenuStatusHandler {
            private ParentControlDesigner designer;

            /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.EscapeHandler.EscapeHandler"]/*' />
            /// <devdoc>
            ///      Creates a new escape handler.
            /// </devdoc>
            public EscapeHandler(ParentControlDesigner designer) {
                this.designer = designer;
            }

            /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.EscapeHandler.OverrideInvoke"]/*' />
            /// <devdoc>
            ///     CommandSet will check with this handler on each status update
            ///     to see if the handler wants to override the availability of
            ///     this command.
            /// </devdoc>
            public bool OverrideInvoke(MenuCommand cmd) {
                if (cmd.CommandID.Equals(MenuCommands.KeyCancel)) {
                    designer.OnMouseDragEnd(true);
                    return true;
                }

                return false;
            }

            /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.EscapeHandler.OverrideStatus"]/*' />
            /// <devdoc>
            ///     CommandSet will check with this handler on each status update
            ///     to see if the handler wants to override the availability of
            ///     this command.
            /// </devdoc>
            public bool OverrideStatus(MenuCommand cmd) {
                if (cmd.CommandID.Equals(MenuCommands.KeyCancel)) {
                    cmd.Enabled = true;
                }
                else {
                    cmd.Enabled = false;
                }

                return true;
            }
        }

        /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.ParentControlSelectionUIHandler"]/*' />
        /// <devdoc>
        ///      This class inherits from the abstract SelectionUIHandler
        ///      class to provide a selection UI implementation for the
        ///      designer.
        /// </devdoc>
        private class ParentControlSelectionUIHandler : SelectionUIHandler {

            private ParentControlDesigner parentControlDesigner;

            /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.ParentControlSelectionUIHandler.ParentControlSelectionUIHandler"]/*' />
            /// <devdoc>
            ///      Creates a new selection UI handler for the given
            ///      designer.
            /// </devdoc>
            public ParentControlSelectionUIHandler(ParentControlDesigner parentControlDesigner) {
                this.parentControlDesigner = parentControlDesigner;
            }

            /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.ParentControlSelectionUIHandler.GetComponent"]/*' />
            /// <devdoc>
            ///      Retrieves the base component for the selection handler.
            /// </devdoc>
            protected override IComponent GetComponent() {
                return parentControlDesigner.Component;
            }

            /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.ParentControlSelectionUIHandler.GetControl"]/*' />
            /// <devdoc>
            ///      Retrieves the base component's UI control for the selection handler.
            /// </devdoc>
            protected override Control GetControl() {
                return parentControlDesigner.Control;
            }

            /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.ParentControlSelectionUIHandler.GetControl1"]/*' />
            /// <devdoc>
            ///      Retrieves the UI control for the given component.
            /// </devdoc>
            protected override Control GetControl(IComponent component) {
                Control control = parentControlDesigner.GetControl(component);
                Debug.Assert(control != null, "ParentControlDesigner UI service is getting a component that is not a control.");
                return control;
            }

            /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.ParentControlSelectionUIHandler.GetCurrentSnapSize"]/*' />
            /// <devdoc>
            ///      Retrieves the current grid snap size we should snap objects
            ///      to.
            /// </devdoc>
            protected override Size GetCurrentSnapSize() {
                return parentControlDesigner.CurrentGridSize;
            }

            /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.ParentControlSelectionUIHandler.GetService"]/*' />
            /// <devdoc>
            ///      We use this to request often-used services.
            /// </devdoc>
            protected override object GetService(Type serviceType) {
                return parentControlDesigner.GetService(serviceType);
            }

            /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.ParentControlSelectionUIHandler.GetShouldSnapToGrid"]/*' />
            /// <devdoc>
            ///      Determines if the selection UI handler should attempt to snap
            ///      objects to a grid.
            /// </devdoc>
            protected override bool GetShouldSnapToGrid() {
                return parentControlDesigner.SnapToGrid;
            }

            /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.ParentControlSelectionUIHandler.GetUpdatedRect"]/*' />
            /// <devdoc>
            ///      Given a rectangle, this updates the dimensions of it
            ///      with any grid snaps and returns a new rectangle.  If
            ///      no changes to the rectangle's size were needed, this
            ///      may return the same rectangle.
            /// </devdoc>
            public override Rectangle GetUpdatedRect(Rectangle originalRect, Rectangle dragRect, bool updateSize) {
                return parentControlDesigner.GetUpdatedRect(originalRect, dragRect, updateSize);
            }

            /// <include file='doc\ParentControlDesigner.uex' path='docs/doc[@for="ParentControlDesigner.ParentControlSelectionUIHandler.SetCursor"]/*' />
            /// <devdoc>
            ///     Asks the handler to set the appropriate cursor
            /// </devdoc>
            public override void SetCursor() {
                parentControlDesigner.SetCursor();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\selectedpatheditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="WorkingDirectoryEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms.Design 
{
    using System;
    using System.Windows.Forms.Design;

    /// <devdoc>
    ///     Folder editor for choosing the initial folder of the folder browser dialog.
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class SelectedPathEditor : FolderNameEditor
    {
        protected override void InitializeDialog(FolderBrowser folderBrowser)
        {
            folderBrowser.Description = System.Design.SR.GetString(System.Design.SR.SelectedPathEditorLabel);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\oledragdrophandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="OleDragDropHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms.Design {
    using System.Design;
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.ComponentModel.Design;
    using System.ComponentModel.Design.Serialization;
    using System.Windows.Forms;
    using System.Collections;
    using System.Drawing;
    using System.Drawing.Design;
    using Microsoft.Win32;
    using System.IO;
    using System.Runtime.Serialization.Formatters.Binary;

    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System